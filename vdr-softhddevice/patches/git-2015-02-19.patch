diff -Naur orig/audio.c mod/audio.c
--- orig/audio.c	2013-09-30 20:54:27.000000000 +0200
+++ mod/audio.c	2015-02-19 22:30:47.258794589 +0100
@@ -1,7 +1,7 @@
 ///
 ///	@file audio.c		@brief Audio module
 ///
-///	Copyright (c) 2009 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2009 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: a9da207397bc03fa2c6cc07b8edca1e939df7746 $
 //////////////////////////////////////////////////////////////////////////////
 
 ///
@@ -88,7 +88,7 @@
 #endif
 #endif
 
-#include <alsa/iatomic.h>		// portable atomic_t
+#include "iatomic.h"			// portable atomic_t
 
 #include "ringbuffer.h"
 #include "misc.h"
@@ -123,6 +123,8 @@
 //----------------------------------------------------------------------------
 
 char AudioAlsaDriverBroken;		///< disable broken driver message
+char AudioAlsaNoCloseOpen;		///< disable alsa close/open fix
+char AudioAlsaCloseOpenDelay;		///< enable alsa close/open delay fix
 
 static const char *AudioModuleName;	///< which audio module to use
 
@@ -130,6 +132,7 @@
 static const AudioModule *AudioUsedModule = &NoopModule;
 static const char *AudioPCMDevice;	///< PCM device name
 static const char *AudioPassthroughDevice;	///< Passthrough device name
+static char AudioAppendAES;		///< flag automatic append AES
 static const char *AudioMixerDevice;	///< mixer device name
 static const char *AudioMixerChannel;	///< mixer channel name
 static char AudioDoingInit;		///> flag in init, reduce error
@@ -146,6 +149,7 @@
 static pthread_t AudioThread;		///< audio play thread
 static pthread_mutex_t AudioMutex;	///< audio condition mutex
 static pthread_cond_t AudioStartCond;	///< condition variable
+static char AudioThreadStop;		///< stop audio thread
 #else
 static const int AudioThread;		///< dummy audio thread
 #endif
@@ -939,7 +943,6 @@
 	return -1;
     }
     for (;;) {
-	pthread_testcancel();
 	if (AudioPaused) {
 	    return 1;
 	}
@@ -1005,6 +1008,26 @@
 	Info(_("audio/alsa: using %sdevice '%s'\n"),
 	    passthrough ? "pass-through " : "", device);
     }
+    //
+    // for AC3 pass-through try to set the non-audio bit, use AES0=6
+    //
+    if (passthrough && AudioAppendAES) {
+#if 0
+	// FIXME: not yet finished
+	char *buf;
+	const char *s;
+	int n;
+
+	n = strlen(device);
+	buf = alloca(n + sizeof(":AES0=6") + 1);
+	strcpy(buf, device);
+	if (!(s = strchr(buf, ':'))) {
+	    // no alsa parameters
+	    strcpy(buf + n, ":AES=6");
+	}
+	Debug(3, "audio/alsa: try '%s'\n", buf);
+#endif
+    }
     // open none blocking; if device is already used, we don't want wait
     if ((err =
 	    snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK,
@@ -1189,17 +1212,23 @@
 	// FIXME: if open fails for fe. pass-through, we never recover
 	return -1;
     }
-    if (1) {				// close+open to fix HDMI no sound bug
+    if (!AudioAlsaNoCloseOpen) {	// close+open to fix HDMI no sound bug
 	snd_pcm_t *handle;
 
 	handle = AlsaPCMHandle;
-	// FIXME: need lock
+	// no lock needed, thread exit in main loop only
+	//Debug(3, "audio: %s [\n", __FUNCTION__);
 	AlsaPCMHandle = NULL;		// other threads should check handle
 	snd_pcm_close(handle);
+	if (AudioAlsaCloseOpenDelay) {
+	    usleep(50 * 1000);		// 50ms delay for alsa recovery
+	}
+	// FIXME: can use multiple retries
 	if (!(handle = AlsaOpenPCM(passthrough))) {
 	    return -1;
 	}
 	AlsaPCMHandle = handle;
+	//Debug(3, "audio: %s ]\n", __FUNCTION__);
     }
 
     for (;;) {
@@ -1521,7 +1550,6 @@
     for (;;) {
 	struct pollfd fds[1];
 
-	pthread_testcancel();
 	if (AudioPaused) {
 	    return 1;
 	}
@@ -2023,6 +2051,12 @@
 {
     Debug(3, "audio: play thread started\n");
     for (;;) {
+	// check if we should stop the thread
+	if (AudioThreadStop) {
+	    Debug(3, "audio: play thread stopped\n");
+	    return PTHREAD_CANCELED;
+	}
+
 	Debug(3, "audio: wait on start condition\n");
 	pthread_mutex_lock(&AudioMutex);
 	AudioRunning = 0;
@@ -2043,25 +2077,32 @@
 	    int read;
 	    int flush;
 	    int err;
+	    int i;
 
+	    // check if we should stop the thread
+	    if (AudioThreadStop) {
+		Debug(3, "audio: play thread stopped\n");
+		return PTHREAD_CANCELED;
+	    }
 	    // look if there is a flush command in the queue
 	    flush = 0;
 	    filled = atomic_read(&AudioRingFilled);
 	    read = AudioRingRead;
-	    while (filled--) {
+	    i = filled;
+	    while (i--) {
 		read = (read + 1) % AUDIO_RING_MAX;
 		if (AudioRing[read].FlushBuffers) {
 		    AudioRing[read].FlushBuffers = 0;
 		    AudioRingRead = read;
-		    atomic_set(&AudioRingFilled, filled);
 		    // handle all flush in queue
-		    flush = 1;
+		    flush = filled - i;
 		}
 	    }
 
 	    if (flush) {
-		Debug(3, "audio: flush\n");
+		Debug(3, "audio: flush %d ring buffer(s)\n", flush);
 		AudioUsedModule->FlushBuffers();
+		atomic_sub(flush, &AudioRingFilled);
 		if (AudioNextRing()) {
 		    Debug(3, "audio: break after flush\n");
 		    break;
@@ -2127,6 +2168,7 @@
 */
 static void AudioInitThread(void)
 {
+    AudioThreadStop = 0;
     pthread_mutex_init(&AudioMutex, NULL);
     pthread_cond_init(&AudioStartCond, NULL);
     pthread_create(&AudioThread, NULL, AudioPlayHandlerThread, NULL);
@@ -2140,10 +2182,12 @@
 {
     void *retval;
 
+    Debug(3, "audio: %s\n", __FUNCTION__);
+
     if (AudioThread) {
-	if (pthread_cancel(AudioThread)) {
-	    Error(_("audio: can't queue cancel play thread\n"));
-	}
+	AudioThreadStop = 1;
+	AudioRunning = 1;		// wakeup thread, if needed
+	pthread_cond_signal(&AudioStartCond);
 	if (pthread_join(AudioThread, &retval) || retval != PTHREAD_CANCELED) {
 	    Error(_("audio: can't cancel play thread\n"));
 	}
@@ -2421,8 +2465,23 @@
     int old;
     int i;
 
+    if (atomic_read(&AudioRingFilled) >= AUDIO_RING_MAX) {
+	// wait for space in ring buffer, should never happen
+	for (i = 0; i < 24 * 2; ++i) {
+	    if (atomic_read(&AudioRingFilled) < AUDIO_RING_MAX) {
+		break;
+	    }
+	    Debug(3, "audio: flush out of ring buffers\n");
+	    usleep(1 * 1000);		// avoid hot polling
+	}
+	if (atomic_read(&AudioRingFilled) >= AUDIO_RING_MAX) {
+	    // FIXME: We can set the flush flag in the last wrote ring buffer
+	    Error(_("audio: flush out of ring buffers\n"));
+	    return;
+	}
+    }
+
     old = AudioRingWrite;
-    // FIXME: check ring buffer overflow
     AudioRingWrite = (AudioRingWrite + 1) % AUDIO_RING_MAX;
     AudioRing[AudioRingWrite].FlushBuffers = 1;
     AudioRing[AudioRingWrite].Passthrough = AudioRing[old].Passthrough;
@@ -2439,12 +2498,13 @@
 
     atomic_inc(&AudioRingFilled);
 
-    // FIXME: wait for flush complete?
+    // FIXME: wait for flush complete needed?
     for (i = 0; i < 24 * 2; ++i) {
 	if (!AudioRunning) {		// wakeup thread to flush buffers
 	    AudioRunning = 1;
 	    pthread_cond_signal(&AudioStartCond);
 	}
+	// FIXME: waiting on zero isn't correct, but currently works
 	if (!atomic_read(&AudioRingFilled)) {
 	    break;
 	}
@@ -2757,6 +2817,20 @@
 }
 
 /**
+**	Set automatic AES flag handling.
+**
+**	@param onoff	turn setting AES flag on or off
+*/
+void AudioSetAutoAES(int onoff)
+{
+    if (onoff < 0) {
+	AudioAppendAES ^= 1;
+    } else {
+	AudioAppendAES = onoff;
+    }
+}
+
+/**
 **	Initialize audio output module.
 **
 **	@todo FIXME: make audio output module selectable.
@@ -2935,6 +3009,8 @@
 {
     const AudioModule *module;
 
+    Debug(3, "audio: %s\n", __FUNCTION__);
+
 #ifdef USE_AUDIO_THREAD
     if (AudioUsedModule->Thread) {	// supports threads
 	AudioExitThread();
diff -Naur orig/audio.h mod/audio.h
--- orig/audio.h	2013-09-30 20:54:27.000000000 +0200
+++ mod/audio.h	2015-02-19 22:30:47.258794589 +0100
@@ -1,7 +1,7 @@
 ///
 ///	@file audio.h		@brief Audio module headerfile
 ///
-///	Copyright (c) 2009 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2009 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: da055758af70cfdb9ab1989d5fcfb218c5d6a366 $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup Audio
@@ -52,6 +52,7 @@
     /// set pass-through device
 extern void AudioSetPassthroughDevice(const char *);
 extern void AudioSetChannel(const char *);	///< set mixer channel
+extern void AudioSetAutoAES(int);	///< set automatic AES flag handling
 extern void AudioInit(void);		///< setup audio module
 extern void AudioExit(void);		///< cleanup and exit audio module
 
@@ -60,5 +61,7 @@
 //----------------------------------------------------------------------------
 
 extern char AudioAlsaDriverBroken;	///< disable broken driver message
+extern char AudioAlsaNoCloseOpen;	///< disable alsa close/open fix
+extern char AudioAlsaCloseOpenDelay;	///< enable alsa close/open delay fix
 
 /// @}
diff -Naur orig/ChangeLog mod/ChangeLog
--- orig/ChangeLog	2013-09-30 20:54:27.000000000 +0200
+++ mod/ChangeLog	2015-02-19 22:30:47.250794590 +0100
@@ -1,6 +1,97 @@
 User johns
 Date:
 
+    Fix for compile with vdr 2.1.10, for older vdr versions.
+
+User jinx
+Date: Mon Feb 16 09:58:06 CET 2015
+
+    Enable toggle AC3 downmix.
+
+User johns
+Date: Thu Feb 12 10:30:50 CET 2015
+
+    Compile with vdr 2.1.10.
+    Fix bug: AVCodecContext.framerate not supported.
+    Use video stream frame rate for A/V sync.
+
+User Antti Seppälä
+Date: Thu Oct 16 14:15:15 CEST 2014
+
+    Corrected black surface for va-api.
+
+User johns
+Date: Thu Oct 16 14:05:17 CEST 2014
+
+    Newer va-api intel drivers support PutImage.
+    Use more portable fork for vfork.
+    Fix crash with VA-API vdpau backend.
+
+User mini73
+Date: Sat Oct 11 16:53:18 CEST 2014
+
+    Fix bug: random rubbish at the end of letter.
+
+User johns
+Date: Tue Sep 23 12:36:39 CEST 2014
+
+    Fix audio thread close race condition.
+    Support ffmpeg new AVFrame API in the audio codec.
+    Config for automatic AES parameters.
+    Use GCC built-in functions for atomic operations.
+
+User master_red
+Date: Wed Jun  4 14:44:32 CEST 2014
+
+    Support detach or suspend in plugin menu.
+
+User johns
+Date:  Fri May 30 10:18:20 CEST 2014
+
+    Fix "make clean-plugins".
+    Fix compile with newer libav.
+    Fix OSD bugs.
+    Add some VA-API VPP info outputs.
+    Remove build files for old unstable VDR.
+
+User  hd.brummy
+Date: Thu Jan 30 10:40:49 CET 2014
+
+    Update gentoo ebuild.
+
+User johns
+Date: Thu Jan 30 10:36:53 CET 2014
+
+    Fix spelling in arguments help.
+    Add Workaround for alsa blocking audio device.
+    Improves thread handling for audio flush and close.
+
+User mini73
+Date: Fri Jan 24 11:30:49 CET 2014
+
+    Fix bug: learing x11 remote keys fails.
+    Add support for umlauts in input fields.
+
+User johns
+Date: Tue Jan 14 14:59:44 CET 2014
+
+    Fix alternative OSD support with VDPAU bitmap surfaces.
+    Fix compile error with VDR 2.1.3.
+    Fix bug: memory leak.
+    PIP close clears the last used PIP channel.
+    Fix bug: -DOSD_DEBUG uses old (deleted) variable.
+    Fix bug: Option softhddevice.BlackPicture has no effect.
+
+User Dr. Seltsam
+Date: Tue Nov  5 16:46:34 CET 2013
+
+    Add support to configure and clear buffers on channel switch.
+
+User johns
+Date: Tue Oct  8 10:18:04 CET 2013
+
+    CLOCK_REALTIME -> CLOCK_MONOTONIC to allow time changes.
+    Add function VideoStreamOpen and always use VideoStreamClose.
     Softer audio/video sync.
     Add function GetStats to the video output module.
     Add function ResetStart to the video output module.
diff -Naur orig/codec.c mod/codec.c
--- orig/codec.c	2013-09-30 20:54:27.000000000 +0200
+++ mod/codec.c	2015-02-19 22:30:47.262794589 +0100
@@ -1,7 +1,7 @@
 ///
 ///	@file codec.c	@brief Codec functions
 ///
-///	Copyright (c) 2009 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2009 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 10011c3780ec4a2ae6b5e30efeaf3b81e7a6d24d $
 //////////////////////////////////////////////////////////////////////////////
 
 ///
@@ -38,8 +38,12 @@
 #define USE_AC3_DRIFT_CORRECTION
     /// use ffmpeg libswresample API (autodected, Makefile)
 #define noUSE_SWRESAMPLE
+    /// use libav libavresample API (autodected, Makefile)
+#define noUSE_AVRESAMPLE
 
 #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
 #ifdef __FreeBSD__
 #include <sys/endian.h>
@@ -54,8 +58,8 @@
 #define _(str) gettext(str)		///< gettext shortcut
 #define _N(str) str			///< gettext_noop shortcut
 
-#include <alsa/iatomic.h>
 #include <libavcodec/avcodec.h>
+#include <libavutil/mem.h>
 // support old ffmpeg versions <1.0
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(55,18,102)
 #define AVCodecID CodecID
@@ -70,6 +74,10 @@
 #ifdef USE_SWRESAMPLE
 #include <libswresample/swresample.h>
 #endif
+#ifdef USE_AVRESAMPLE
+#include <libavresample/avresample.h>
+#include <libavutil/opt.h>
+#endif
 
 #ifndef __USE_GNU
 #define __USE_GNU
@@ -79,6 +87,7 @@
 #ifdef MAIN_H
 #include MAIN_H
 #endif
+#include "iatomic.h"
 #include "misc.h"
 #include "video.h"
 #include "audio.h"
@@ -201,7 +210,9 @@
 
 	//Debug(3, "codec: use surface %#010x\n", surface);
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,48,101)
 	frame->type = FF_BUFFER_TYPE_USER;
+#endif
 #if LIBAVCODEC_VERSION_INT <= AV_VERSION_INT(53,46,0)
 	frame->age = 256 * 256 * 256 * 64;
 #endif
@@ -211,12 +222,14 @@
 	frame->data[2] = NULL;
 	frame->data[3] = NULL;
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,66,100)
 	// reordered frames
 	if (video_ctx->pkt) {
 	    frame->pkt_pts = video_ctx->pkt->pts;
 	} else {
 	    frame->pkt_pts = AV_NOPTS_VALUE;
 	}
+#endif
 	return 0;
     }
 #endif
@@ -228,7 +241,9 @@
 
 	//Debug(3, "codec: use surface %#010x\n", surface);
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,48,101)
 	frame->type = FF_BUFFER_TYPE_USER;
+#endif
 #if LIBAVCODEC_VERSION_INT <= AV_VERSION_INT(53,46,0)
 	frame->age = 256 * 256 * 256 * 64;
 #endif
@@ -236,12 +251,14 @@
 	frame->data[0] = (void *)(size_t) surface;
 	frame->data[3] = (void *)(size_t) surface;
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,66,100)
 	// reordered frames
 	if (video_ctx->pkt) {
 	    frame->pkt_pts = video_ctx->pkt->pts;
 	} else {
 	    frame->pkt_pts = AV_NOPTS_VALUE;
 	}
+#endif
 	return 0;
     }
     //Debug(3, "codec: fallback to default get_buffer\n");
@@ -664,16 +681,23 @@
     int HwSampleRate;			///< hw sample rate
     int HwChannels;			///< hw channels
 
-#ifndef USE_SWRESAMPLE
-    ReSampleContext *ReSample;		///< audio resampling context
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58,28,1)
+    AVFrame *Frame;			///< decoded audio frame buffer
+#endif
+
+#if !defined(USE_SWRESAMPLE) && !defined(USE_AVRESAMPLE)
+    ReSampleContext *ReSample;		///< old resampling context
 #endif
 #ifdef USE_SWRESAMPLE
 #if LIBSWRESAMPLE_VERSION_INT < AV_VERSION_INT(0, 15, 100)
-    struct SwrContext *Resample;	///< audio software resample context
+    struct SwrContext *Resample;	///< ffmpeg software resample context
 #else
-    SwrContext *Resample;		///< audio software resample context
+    SwrContext *Resample;		///< ffmpeg software resample context
 #endif
 #endif
+#ifdef USE_AVRESAMPLE
+    AVAudioResampleContext *Resample;	///< libav software resample context
+#endif
 
     uint16_t Spdif[24576 / 2];		///< SPDIF output buffer
     int SpdifIndex;			///< index into SPDIF output buffer
@@ -687,7 +711,7 @@
     int DriftCorr;			///< audio drift correction value
     int DriftFrac;			///< audio drift fraction for ac3
 
-#ifndef USE_SWRESAMPLE
+#if !defined(USE_SWRESAMPLE) && !defined(USE_AVRESAMPLE)
     struct AVResampleContext *AvResample;	///< second audio resample context
 #define MAX_CHANNELS 8			///< max number of channels supported
     int16_t *Buffer[MAX_CHANNELS];	///< deinterleave sample buffers
@@ -737,6 +761,11 @@
     if (!(audio_decoder = calloc(1, sizeof(*audio_decoder)))) {
 	Fatal(_("codec: can't allocate audio decoder\n"));
     }
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58,28,1)
+    if (!(audio_decoder->Frame = av_frame_alloc())) {
+	Fatal(_("codec: can't allocate audio decoder frame buffer\n"));
+    }
+#endif
 
     return audio_decoder;
 }
@@ -748,6 +777,9 @@
 */
 void CodecAudioDelDecoder(AudioDecoder * decoder)
 {
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58,28,1)
+    av_frame_free(&decoder->Frame);	// callee does checks
+#endif
     free(decoder);
 }
 
@@ -785,7 +817,7 @@
 	    AV_CH_LAYOUT_STEREO_DOWNMIX;
     }
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,61,100)
-    // this has no effect
+    // this has no effect (with ffmpeg and libav)
     // audio_decoder->AudioCtx->request_sample_fmt = AV_SAMPLE_FMT_S16;
 #endif
     pthread_mutex_lock(&CodecLockMutex);
@@ -834,7 +866,7 @@
 void CodecAudioClose(AudioDecoder * audio_decoder)
 {
     // FIXME: output any buffered data
-#ifndef USE_SWRESAMPLE
+#if !defined(USE_SWRESAMPLE) && !defined(USE_AVRESAMPLE)
     if (audio_decoder->AvResample) {
 	int ch;
 
@@ -860,6 +892,11 @@
 	swr_free(&audio_decoder->Resample);
     }
 #endif
+#ifdef USE_AVRESAMPLE
+    if (audio_decoder->Resample) {
+	avresample_free(&audio_decoder->Resample);
+    }
+#endif
     if (audio_decoder->AudioCtx) {
 	pthread_mutex_lock(&CodecLockMutex);
 	avcodec_close(audio_decoder->AudioCtx);
@@ -1155,7 +1192,7 @@
     return 0;
 }
 
-#ifndef USE_SWRESAMPLE
+#if !defined(USE_SWRESAMPLE) && !defined(USE_AVRESAMPLE)
 
 /**
 **	Set/update audio pts clock.
@@ -1557,7 +1594,7 @@
 
 #endif
 
-#ifdef USE_SWRESAMPLE
+#if defined(USE_SWRESAMPLE) || defined(USE_AVRESAMPLE)
 
 /**
 **	Set/update audio pts clock.
@@ -1646,6 +1683,7 @@
 	}
     }
 
+#ifdef USE_SWRESAMPLE
     if (audio_decoder->Resample && audio_decoder->DriftCorr) {
 	int distance;
 
@@ -1660,6 +1698,18 @@
 	    Debug(3, "codec/audio: swr_set_compensation failed\n");
 	}
     }
+#endif
+#ifdef USE_AVRESAMPLE
+    if (audio_decoder->Resample && audio_decoder->DriftCorr) {
+	int distance;
+
+	distance = (pts_diff * audio_decoder->HwSampleRate) / (900 * 1000);
+	if (avresample_set_compensation(audio_decoder->Resample,
+		audio_decoder->DriftCorr / 10, distance)) {
+	    Debug(3, "codec/audio: swr_set_compensation failed\n");
+	}
+    }
+#endif
     if (1) {
 	static int c;
 
@@ -1699,6 +1749,7 @@
     }
 #endif
 
+#ifdef USE_SWRESAMPLE
     audio_decoder->Resample =
 	swr_alloc_set_opts(audio_decoder->Resample, audio_ctx->channel_layout,
 	AV_SAMPLE_FMT_S16, audio_decoder->HwSampleRate,
@@ -1709,6 +1760,33 @@
     } else {
 	Error(_("codec/audio: can't setup resample\n"));
     }
+#endif
+#ifdef USE_AVRESAMPLE
+    if (!(audio_decoder->Resample = avresample_alloc_context())) {
+	Error(_("codec/audio: can't setup resample\n"));
+	return;
+    }
+
+    av_opt_set_int(audio_decoder->Resample, "in_channel_layout",
+	audio_ctx->channel_layout, 0);
+    av_opt_set_int(audio_decoder->Resample, "in_sample_fmt",
+	audio_ctx->sample_fmt, 0);
+    av_opt_set_int(audio_decoder->Resample, "in_sample_rate",
+	audio_ctx->sample_rate, 0);
+    av_opt_set_int(audio_decoder->Resample, "out_channel_layout",
+	audio_ctx->channel_layout, 0);
+    av_opt_set_int(audio_decoder->Resample, "out_sample_fmt",
+	AV_SAMPLE_FMT_S16, 0);
+    av_opt_set_int(audio_decoder->Resample, "out_sample_rate",
+	audio_decoder->HwSampleRate, 0);
+
+    if (avresample_open(audio_decoder->Resample)) {
+	avresample_free(&audio_decoder->Resample);
+	audio_decoder->Resample = NULL;
+	Error(_("codec/audio: can't open resample\n"));
+	return;
+    }
+#endif
 }
 
 /**
@@ -1724,16 +1802,31 @@
 void CodecAudioDecode(AudioDecoder * audio_decoder, const AVPacket * avpkt)
 {
     AVCodecContext *audio_ctx;
-    AVFrame frame;
+
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58,28,1)
+    AVFrame frame[1];
+#else
+    AVFrame *frame;
+#endif
     int got_frame;
     int n;
 
     audio_ctx = audio_decoder->AudioCtx;
 
     // FIXME: don't need to decode pass-through codecs
-    frame.data[0] = NULL;
-    n = avcodec_decode_audio4(audio_ctx, &frame, &got_frame,
+
+    // new AVFrame API
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58,28,1)
+    avcodec_get_frame_defaults(frame);
+#else
+    frame = audio_decoder->Frame;
+    av_frame_unref(frame);
+#endif
+
+    got_frame = 0;
+    n = avcodec_decode_audio4(audio_ctx, frame, &got_frame,
 	(AVPacket *) avpkt);
+
     if (n != avpkt->size) {
 	if (n == AVERROR(EAGAIN)) {
 	    Error(_("codec/audio: latm\n"));
@@ -1775,7 +1868,7 @@
 
 	data_sz =
 	    av_samples_get_buffer_size(&plane_sz, audio_ctx->channels,
-	    frame.nb_samples, audio_ctx->sample_fmt, 1);
+	    frame->nb_samples, audio_ctx->sample_fmt, 1);
 	fprintf(stderr, "codec/audio: sample_fmt %s\n",
 	    av_get_sample_fmt_name(audio_ctx->sample_fmt));
 	av_get_channel_layout_string(strbuf, 32, audio_ctx->channels,
@@ -1783,9 +1876,9 @@
 	fprintf(stderr, "codec/audio: layout %s\n", strbuf);
 	fprintf(stderr,
 	    "codec/audio: channels %d samples %d plane %d data %d\n",
-	    audio_ctx->channels, frame.nb_samples, plane_sz, data_sz);
+	    audio_ctx->channels, frame->nb_samples, plane_sz, data_sz);
     }
-
+#ifdef USE_SWRESAMPLE
     if (audio_decoder->Resample) {
 	uint8_t outbuf[8192 * 2 * 8];
 	uint8_t *out[1];
@@ -1793,7 +1886,29 @@
 	out[0] = outbuf;
 	n = swr_convert(audio_decoder->Resample, out,
 	    sizeof(outbuf) / (2 * audio_decoder->HwChannels),
-	    (const uint8_t **)frame.extended_data, frame.nb_samples);
+	    (const uint8_t **)frame->extended_data, frame->nb_samples);
+	if (n > 0) {
+	    if (!(audio_decoder->Passthrough & CodecPCM)) {
+		CodecReorderAudioFrame((int16_t *) outbuf,
+		    n * 2 * audio_decoder->HwChannels,
+		    audio_decoder->HwChannels);
+	    }
+	    AudioEnqueue(outbuf, n * 2 * audio_decoder->HwChannels);
+	}
+	return;
+    }
+#endif
+
+#ifdef USE_AVRESAMPLE
+    if (audio_decoder->Resample) {
+	uint8_t outbuf[8192 * 2 * 8];
+	uint8_t *out[1];
+
+	out[0] = outbuf;
+	n = avresample_convert(audio_decoder->Resample, out, 0,
+	    sizeof(outbuf) / (2 * audio_decoder->HwChannels),
+	    (uint8_t **) frame->extended_data, 0, frame->nb_samples);
+	// FIXME: set out_linesize, in_linesize correct
 	if (n > 0) {
 	    if (!(audio_decoder->Passthrough & CodecPCM)) {
 		CodecReorderAudioFrame((int16_t *) outbuf,
@@ -1804,6 +1919,8 @@
 	}
 	return;
     }
+#endif
+
 #ifdef DEBUG
     // should be never reached
     fprintf(stderr, "oops\n");
diff -Naur orig/codec.h mod/codec.h
--- orig/codec.h	2013-09-30 20:54:27.000000000 +0200
+++ mod/codec.h	2015-02-19 22:30:47.262794589 +0100
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 995573a37d63ab35ed13aed6ca333eebe2041c3e $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup Codec
diff -Naur orig/iatomic.h mod/iatomic.h
--- orig/iatomic.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/iatomic.h	2015-02-19 22:30:47.262794589 +0100
@@ -0,0 +1,97 @@
+///
+///	@file iatomic.h @brief Misc function header file
+///
+///	Copyright (c) 2014 by Johns.  All Rights Reserved.
+///
+///	Contributor(s):
+///
+///	License: AGPLv3
+///
+///	This program is free software: you can redistribute it and/or modify
+///	it under the terms of the GNU Affero General Public License as
+///	published by the Free Software Foundation, either version 3 of the
+///	License.
+///
+///	This program is distributed in the hope that it will be useful,
+///	but WITHOUT ANY WARRANTY; without even the implied warranty of
+///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+///	GNU Affero General Public License for more details.
+///
+///	$Id: 59e1684aaa6678ecdebb6ce0df6ce5b5f461dd6e $
+//////////////////////////////////////////////////////////////////////////////
+
+/// @addtogroup iatomic
+/// @{
+
+#define GCC_VERSION (__GNUC__ * 10000 \
+	+ __GNUC_MINOR__ * 100 \
+	+ __GNUC_PATCHLEVEL__)
+
+//	gcc before 4.7 didn't support atomic builtins,
+//	use alsa atomic functions.
+#if GCC_VERSION < 40700
+
+#include <alsa/iatomic.h>
+
+#else
+
+//////////////////////////////////////////////////////////////////////////////
+//	Defines
+//////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////
+//	Declares
+//////////////////////////////////////////////////////////////////////////////
+
+///
+///	atomic type, 24 bit useable,
+///
+typedef volatile int atomic_t;
+
+//////////////////////////////////////////////////////////////////////////////
+//	Prototypes
+//////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////
+//	Inlines
+//////////////////////////////////////////////////////////////////////////////
+
+///
+///	Set atomic value.
+///
+#define atomic_set(ptr, val) \
+    __atomic_store_n(ptr, val, __ATOMIC_SEQ_CST)
+
+///
+///	Read atomic value.
+///
+#define atomic_read(ptr) \
+    __atomic_load_n(ptr, __ATOMIC_SEQ_CST)
+
+///
+///	Increment atomic value.
+///
+#define atomic_inc(ptr) \
+    __atomic_add_fetch(ptr, 1, __ATOMIC_SEQ_CST)
+
+///
+///	Decrement atomic value.
+///
+#define atomic_dec(ptr) \
+    __atomic_sub_fetch(ptr, 1, __ATOMIC_SEQ_CST)
+
+///
+///	Add to atomic value.
+///
+#define atomic_add(val, ptr) \
+    __atomic_add_fetch(ptr, val, __ATOMIC_SEQ_CST)
+
+///
+///	Subtract from atomic value.
+///
+#define atomic_sub(val, ptr) \
+    __atomic_sub_fetch(ptr, val, __ATOMIC_SEQ_CST)
+
+#endif
+
+/// @}
diff -Naur orig/Makefile mod/Makefile
--- orig/Makefile	2013-09-30 20:54:27.000000000 +0200
+++ mod/Makefile	2015-02-19 22:30:47.250794590 +0100
@@ -1,7 +1,7 @@
 #
 # Makefile for a Video Disk Recorder plugin
 #
-# $Id$
+# $Id: 187a9170996aed0b5a1783e229edddd9f4d628c7 $
 
 # The official name of this plugin.
 # This name will be used in the '-P...' option of VDR to load the plugin.
@@ -25,6 +25,10 @@
 SCREENSAVER ?= 1
     # use ffmpeg libswresample
 SWRESAMPLE ?= $(shell pkg-config --exists libswresample && echo 1)
+    # use libav libavresample
+ifneq ($(SWRESAMPLE),1)
+AVRESAMPLE ?= $(shell pkg-config --exists libavresample && echo 1)
+endif
 
 CONFIG := # -DDEBUG #-DOSD_DEBUG	# enable debug output+functions
 #CONFIG += -DSTILL_DEBUG=2		# still picture debug verbose level
@@ -37,6 +41,7 @@
 #CONFIG += -DUSE_MPEG_COMPLETE		# support only complete mpeg packets
 #CONFIG += -DH264_EOS_TRICKSPEED	# insert seq end packets for trickspeed
 #CONDIF += -DDUMP_TRICKSPEED		# dump trickspeed packets
+#CONFIG += -DUSE_BITMAP			# VDPAU, use bitmap surface for OSD
 CONFIG += -DUSE_VDR_SPU			# use VDR SPU decoder.
 #CONFIG += -DUSE_SOFTLIMIT		# (tobe removed) limit the buffer fill
 
@@ -77,6 +82,11 @@
 _CFLAGS += $(shell pkg-config --cflags libswresample)
 LIBS += $(shell pkg-config --libs libswresample)
 endif
+ifeq ($(AVRESAMPLE),1)
+CONFIG += -DUSE_AVRESAMPLE
+_CFLAGS += $(shell pkg-config --cflags libavresample)
+LIBS += $(shell pkg-config --libs libavresample)
+endif
 
 _CFLAGS += $(shell pkg-config --cflags libavcodec x11 x11-xcb xcb xcb-icccm)
 LIBS += -lrt $(shell pkg-config --libs libavcodec x11 x11-xcb xcb xcb-icccm)
@@ -102,10 +112,10 @@
 export CXXFLAGS = $(call PKGCFG,cxxflags)
 
 ifeq ($(CFLAGS),)
-$(error CFLAGS not set)
+$(warning CFLAGS not set)
 endif
 ifeq ($(CXXFLAGS),)
-$(error CXXFLAGS not set)
+$(warning CXXFLAGS not set)
 endif
 
 ### The version number of VDR's plugin API:
diff -Naur orig/Makefile-pre1.7.36 mod/Makefile-pre1.7.36
--- orig/Makefile-pre1.7.36	2013-09-30 20:54:27.000000000 +0200
+++ mod/Makefile-pre1.7.36	1970-01-01 01:00:00.000000000 +0100
@@ -1,188 +0,0 @@
-#
-# Makefile for a Video Disk Recorder plugin
-#
-# $Id$
-
-# The official name of this plugin.
-# This name will be used in the '-P...' option of VDR to load the plugin.
-# By default the main source file also carries this name.
-# IMPORTANT: the presence of this macro is important for the Make.config
-# file. So it must be defined, even if it is not used here!
-#
-PLUGIN = softhddevice
-
-### The version number of this plugin (taken from the main source file):
-
-VERSION = $(shell grep 'static const char \*const VERSION *=' $(PLUGIN).cpp | awk '{ print $$7 }' | sed -e 's/[";]//g')
-GIT_REV = $(shell git describe --always 2>/dev/null)
-
-### Configuration (edit this for your needs)
-
-CONFIG := #-DDEBUG #-DOSD_DEBUG
-CONFIG += -DAV_INFO -DAV_INFO_TIME=3000	# debug a/v sync
-CONFIG += -DUSE_PIP			# PIP support
-#CONFIG += -DHAVE_PTHREAD_NAME		# supports new pthread_setname_np
-#CONFIG += -DNO_TS_AUDIO		# disable ts audio parser
-#CONFIG += -DUSE_TS_VIDEO		# build new ts video parser
-					# use ffmpeg libswresample
-CONFIG += $(shell pkg-config --exists libswresample && echo "-DUSE_SWRESAMPLE")
-CONFIG += -DUSE_SCREENSAVER		# use functions to disable screensaver
-CONFIG += $(shell pkg-config --exists vdpau && echo "-DUSE_VDPAU")
-CONFIG += $(shell pkg-config --exists libva && echo "-DUSE_VAAPI")
-CONFIG += $(shell pkg-config --exists alsa && echo "-DUSE_ALSA")
-CONFIG += -DUSE_OSS
-
-### The C++ compiler and options:
-
-CC	 ?= gcc
-CXX	 ?= g++
-CFLAGS	 ?=	-g -O2 -W -Wall -Wextra -Winit-self \
-		-Wdeclaration-after-statement \
-		-ftree-vectorize -msse3 -flax-vector-conversions -fPIC
-CXXFLAGS ?= -g -O2 -W -Wall -Wextra -Werror=overloaded-virtual -fPIC
-
-### The directory environment:
-
-VDRDIR ?= ../../..
-LIBDIR ?= ../../lib
-TMPDIR ?= /tmp
-
-### Make sure that necessary options are included:
-
--include $(VDRDIR)/Make.global
-
-### Allow user defined options to overwrite defaults:
-
--include $(VDRDIR)/Make.config
-
-### The version number of VDR's plugin API (taken from VDR's "config.h"):
-
-APIVERSION = $(shell sed -ne '/define APIVERSION/s/^.*"\(.*\)".*$$/\1/p' $(VDRDIR)/config.h)
-
-### The name of the distribution archive:
-
-ARCHIVE = $(PLUGIN)-$(VERSION)
-PACKAGE = vdr-$(ARCHIVE)
-
-### Includes, Defines and dependencies (add further entries here):
-
-INCLUDES += -I$(VDRDIR)/include
-
-DEFINES += $(CONFIG) -D_GNU_SOURCE -DPLUGIN_NAME_I18N='"$(PLUGIN)"' \
-	$(if $(GIT_REV), -DGIT_REV='"$(GIT_REV)"')
-
-_CFLAGS = $(DEFINES) $(INCLUDES) \
-	$(shell pkg-config --cflags libavcodec) \
-	`pkg-config --cflags x11 x11-xcb xcb xcb-xv xcb-shm xcb-dpms xcb-atom\
-		xcb-screensaver xcb-randr xcb-glx xcb-icccm xcb-keysyms`\
-	`pkg-config --cflags gl glu` \
-	$(if $(findstring USE_SWRESAMPLE,$(CONFIG)), \
-		$(shell pkg-config --cflags libswresample)) \
-	$(if $(findstring USE_VAAPI,$(CONFIG)), \
-		`pkg-config --cflags libva-x11 libva-glx libva`) \
-	$(if $(findstring USE_ALSA,$(CONFIG)), \
-		`pkg-config --cflags alsa`)
-
-#override _CFLAGS  += -Werror
-override CXXFLAGS += $(_CFLAGS)
-override CFLAGS	  += $(_CFLAGS)
-
-LIBS += -lrt \
-	$(shell pkg-config --libs libavcodec) \
-	`pkg-config --libs x11 x11-xcb xcb xcb-xv xcb-shm xcb-dpms xcb-atom\
-		xcb-screensaver xcb-randr xcb-glx xcb-icccm xcb-keysyms`\
-	`pkg-config --libs gl glu` \
-	$(if $(findstring USE_SWRESAMPLE,$(CONFIG)), \
-		$(shell pkg-config --libs libswresample)) \
-	$(if $(findstring USE_VDPAU,$(CONFIG)), \
-		`pkg-config --libs vdpau`) \
-	$(if $(findstring USE_VAAPI,$(CONFIG)), \
-		`pkg-config --libs libva-x11 libva-glx libva`) \
-	$(if $(findstring USE_ALSA,$(CONFIG)), \
-		`pkg-config --libs alsa`)
-
-### The object files (add further files here):
-
-OBJS = $(PLUGIN).o softhddev.o video.o audio.o codec.o ringbuffer.o
-SRCS = $(wildcard $(OBJS:.o=.c)) $(PLUGIN).cpp
-
-### The main target:
-
-all: libvdr-$(PLUGIN).so i18n
-
-### Implicit rules:
-#
-#%.o: %.cpp
-#	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
-
-### Dependencies:
-
-MAKEDEP = $(CC) -MM -MG
-DEPFILE = .dependencies
-$(DEPFILE): Makefile
-	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(SRCS) >$@
-
-$(OBJS): Makefile
-
--include $(DEPFILE)
-
-### Internationalization (I18N):
-
-PODIR	  = po
-LOCALEDIR = $(VDRDIR)/locale
-I18Npo	  = $(wildcard $(PODIR)/*.po)
-I18Nmsgs  = $(addprefix $(LOCALEDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, $(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
-I18Npot	  = $(PODIR)/$(PLUGIN).pot
-
-%.mo: %.po
-	msgfmt -c -o $@ $<
-
-$(I18Npot): $(wildcard *.cpp) $(wildcard *.c)
-	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP \
-	-k_ -k_N --package-name=VDR --package-version=$(VDRVERSION) \
-	--msgid-bugs-address='<see README>' -o $@ $^
-
-%.po: $(I18Npot)
-	msgmerge -U --no-wrap --no-location --backup=none -q $@ $<
-	@touch $@
-
-$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.mo
-	@mkdir -p $(dir $@)
-	cp $< $@
-
-.PHONY: i18n
-i18n: $(I18Nmsgs) $(I18Npot)
-
-### Targets:
-
-libvdr-$(PLUGIN).so: $(OBJS) Makefile
-	$(CXX) $(CXXFLAGS) $(LDFLAGS) -shared -fPIC $(OBJS) -o $@ $(LIBS)
-	@cp --remove-destination $@ $(LIBDIR)/$@.$(APIVERSION)
-
-dist: $(I18Npo) clean
-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@mkdir $(TMPDIR)/$(ARCHIVE)
-	@cp -a * $(TMPDIR)/$(ARCHIVE)
-	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@echo Distribution package created as $(PACKAGE).tgz
-
-clean:
-	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~ $(PODIR)/*.mo $(PODIR)/*.pot
-
-install:	libvdr-$(PLUGIN).so
-	cp --remove-destination libvdr-$(PLUGIN).so \
-		/usr/lib/vdr/plugins/libvdr-$(PLUGIN).so.$(APIVERSION)
-
-HDRS=	$(wildcard *.h)
-
-indent:
-	for i in $(SRCS) $(HDRS); do \
-		indent $$i; \
-		unexpand -a $$i | sed -e s/constconst/const/ > $$i.up; \
-		mv $$i.up $$i; \
-	done
-
-video_test: video.c Makefile
-	$(CC) -DVIDEO_TEST -DVERSION='"$(VERSION)"' $(CFLAGS) $(LDFLAGS) $< $(LIBS) \
-	-o $@
diff -Naur orig/misc.h mod/misc.h
--- orig/misc.h	2013-09-30 20:54:27.000000000 +0200
+++ mod/misc.h	2015-02-19 22:30:47.262794589 +0100
@@ -18,7 +18,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: f5ff4b300aa33eb721d658c0c9374c8499b67318 $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup misc
diff -Naur orig/po/de_DE.po mod/po/de_DE.po
--- orig/po/de_DE.po	2013-09-30 20:54:27.000000000 +0200
+++ mod/po/de_DE.po	2015-02-19 22:30:47.262794589 +0100
@@ -7,10 +7,10 @@
 msgstr ""
 "Project-Id-Version: VDR \n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-08-03 17:21+0200\n"
-"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
-"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
-"Language-Team: LANGUAGE <LL@li.org>\n"
+"POT-Creation-Date: 2014-10-31 12:36+0100\n"
+"PO-Revision-Date: blabla\n"
+"Last-Translator: blabla\n"
+"Language-Team: blabla\n"
 "Language: german\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=utf-8\n"
@@ -229,9 +229,6 @@
 msgid "audio: can't set channels %d sample-rate %dHz\n"
 msgstr ""
 
-msgid "audio: can't queue cancel play thread\n"
-msgstr ""
-
 msgid "audio: can't cancel play thread\n"
 msgstr ""
 
@@ -239,6 +236,9 @@
 msgid "audio: can't place %d samples in ring buffer\n"
 msgstr ""
 
+msgid "audio: flush out of ring buffers\n"
+msgstr ""
+
 #, c-format
 msgid "audio: '%s' output module used\n"
 msgstr ""
@@ -276,6 +276,9 @@
 msgid "codec: can't allocate audio decoder\n"
 msgstr ""
 
+msgid "codec: can't allocate audio decoder frame buffer\n"
+msgstr ""
+
 msgid "codec: can't allocate audio codec context\n"
 msgstr ""
 
@@ -306,6 +309,9 @@
 msgid "codec/audio: can't setup resample\n"
 msgstr ""
 
+msgid "codec/audio: can't open resample\n"
+msgstr ""
+
 msgid "codec/audio: latm\n"
 msgstr ""
 
@@ -483,6 +489,9 @@
 msgid "Suspend"
 msgstr "Unterbrechen"
 
+msgid "Detach from main menu entry"
+msgstr "Detach durch HauptmenÃ¼eintrag"
+
 msgid "Suspend closes video+audio"
 msgstr "Unterbrechen schlieÃt Video+Audio"
 
@@ -510,6 +519,9 @@
 msgid "Black during channel switch"
 msgstr "Schwarz wÃ¤hrend Kanalwechsel"
 
+msgid "Clear decoder on channel switch"
+msgstr "Decoder bei Kanalwechsel leeren"
+
 msgid "Brightness (-1000..1000) (vdpau)"
 msgstr "Helligkeit (-1000..1000) (vdpau)"
 
@@ -595,7 +607,7 @@
 msgstr ""
 
 msgid "Enable (E-)AC-3 (decoder) downmix"
-msgstr ""
+msgstr "Aktiviere (E-)AC-3 (decoder) downmix"
 
 msgid "Volume control"
 msgstr "LautstÃ¤rkesteuerung"
@@ -624,6 +636,9 @@
 msgid "Audio buffer size (ms)"
 msgstr "Audio PuffergrÃ¶Ãe (ms)"
 
+msgid "Enable automatic AES"
+msgstr "Aktiviere automatiche AES"
+
 msgid "Picture-In-Picture"
 msgstr "Bild in Bild (PIP)"
 
@@ -688,6 +703,9 @@
 msgid "Channel not available!"
 msgstr "Kanal nicht verfÃ¼gbar!"
 
+msgid "Detach SoftHdDevice"
+msgstr ""
+
 msgid "Suspend SoftHdDevice"
 msgstr "Unterbreche SoftHdDevice"
 
@@ -735,6 +753,12 @@
 msgid "audio delay changed to %d"
 msgstr ""
 
+msgid "surround downmix enabled"
+msgstr ""
+
+msgid "surround downmix disabled"
+msgstr ""
+
 msgid "auto-crop disabled and freezed"
 msgstr ""
 
@@ -975,14 +999,20 @@
 msgid "video: output buffer full, dropping frame (%d/%d)\n"
 msgstr ""
 
-msgid "video/vaapi: can't create a surface\n"
+#, c-format
+msgid "video/vaapi: can't create a surface: %s\n"
 msgstr ""
 
 #, c-format
-msgid "video/vaapi: vaDeriveImage failed %d\n"
+msgid "video/vaapi: can't associate subpicture: %s\n"
 msgstr ""
 
-msgid "video/vaapi: can't map the image!\n"
+#, c-format
+msgid "video/vaapi: can't create image: %s\n"
+msgstr ""
+
+#, c-format
+msgid "video/vaapi: can't map the image: %s\n"
 msgstr ""
 
 msgid "video/vaapi: can't unmap the image!\n"
@@ -998,12 +1028,19 @@
 msgstr ""
 
 #, c-format
+msgid "video/vaapi: vaDeriveImage failed %d\n"
+msgstr ""
+
+#, c-format
 msgid "video/vaapi: can't put image: %d!\n"
 msgstr ""
 
 msgid "video/vaapi: stream <-> surface size mismatch\n"
 msgstr ""
 
+msgid "video/vaapi: can't map the image!\n"
+msgstr ""
+
 #, c-format
 msgid "video/vaapi: can't put image err:%d!\n"
 msgstr ""
@@ -1031,7 +1068,7 @@
 msgid "video/vaapi: can't find a supported subpicture format"
 msgstr ""
 
-msgid "video/vaapi: vaapi supports unscaled osd\n"
+msgid "video/vaapi: supports unscaled osd\n"
 msgstr ""
 
 msgid "video/vaapi: can't create osd image\n"
diff -Naur orig/README.txt mod/README.txt
--- orig/README.txt	2013-09-30 20:54:27.000000000 +0200
+++ mod/README.txt	2015-02-19 22:30:47.254794589 +0100
@@ -16,7 +16,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.
 
-$Id$
+$Id: 5267da021a68b4a727b479417334bfbe67bbba14 $
 
 A software and GPU emulated HD output device plugin for VDR.
 
@@ -233,6 +233,10 @@
 	0 disable black picture during channel switch
 	1 enable black picture during channel switch
 
+	softhddevice.ClearOnSwitch = 0
+	0 keep video und audio buffers during channel switch
+	1 clear video and audio buffers on channel switch
+
 	softhddevice.Video4to3DisplayFormat = 1
 	0 pan and scan
 	1 letter box
@@ -317,6 +321,7 @@
 	@softhddevice Blue 1 2		toggle pass-through
 	@softhddevice Blue 1 3		decrease audio delay by 10ms
 	@softhddevice Blue 1 4		increase audio delay by 10ms
+	@softhddevice Blue 1 5		toggle ac3 mixdown
 	@softhddevice Blue 2 0		disable fullscreen
 	@softhddevice Blue 2 1		enable fullscreen
 	@softhddevice Blue 2 2		toggle fullscreen
@@ -352,7 +357,7 @@
 
 	media-video/ffmpeg (version >=0.7)
 		Complete solution to record, convert and stream audio and
-		video. Includes libavcodec.
+		video. Includes libavcodec and libswresample.
 		http://ffmpeg.org
 	media-libs/alsa-lib
 		Advanced Linux Sound Architecture Library
diff -Naur orig/ringbuffer.c mod/ringbuffer.c
--- orig/ringbuffer.c	2013-09-30 20:54:27.000000000 +0200
+++ mod/ringbuffer.c	2015-02-19 22:30:47.262794589 +0100
@@ -1,7 +1,7 @@
 ///
 ///	@file ringbuffer.c	@brief Ringbuffer module
 ///
-///	Copyright (c) 2009, 2011  by Johns.  All Rights Reserved.
+///	Copyright (c) 2009, 2011, 2014	by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: c9497b197ce7e7a6ba397944edc7ccb161152efd $
 //////////////////////////////////////////////////////////////////////////////
 
 ///
@@ -30,8 +30,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include <alsa/iatomic.h>
-
+#include "iatomic.h"
 #include "ringbuffer.h"
 
     /// ring buffer structure
diff -Naur orig/ringbuffer.h mod/ringbuffer.h
--- orig/ringbuffer.h	2013-09-30 20:54:27.000000000 +0200
+++ mod/ringbuffer.h	2015-02-19 22:30:47.262794589 +0100
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 8a2b4c171f1024afb8b8a7a7add631b7ebe2d45e $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup Ringbuffer
diff -Naur orig/softhddev.c mod/softhddev.c
--- orig/softhddev.c	2013-09-30 20:54:27.000000000 +0200
+++ mod/softhddev.c	2015-02-19 22:30:47.266794589 +0100
@@ -1,7 +1,7 @@
 ///
 ///	@file softhddev.c	@brief A software HD device plugin for VDR.
 ///
-///	Copyright (c) 2011 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2011 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 79c5e31e973cbfa1250ba59d0e4c10a558dd99d6 $
 //////////////////////////////////////////////////////////////////////////////
 
 #define noUSE_SOFTLIMIT			///< add soft buffer limits to Play..
@@ -32,15 +32,18 @@
 #include <fcntl.h>
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <stdint.h>
 #include <inttypes.h>
 #include <unistd.h>
+#include <string.h>
 
 #include <libintl.h>
 #define _(str) gettext(str)		///< gettext shortcut
 #define _N(str) str			///< gettext_noop shortcut
 
 #include <libavcodec/avcodec.h>
+#include <libavutil/mem.h>
 // support old ffmpeg versions <1.0
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(55,18,102)
 #define AVCodecID CodecID
@@ -60,6 +63,7 @@
 #endif
 #include <pthread.h>
 
+#include "iatomic.h"			// portable atomic_t
 #include "misc.h"
 #include "softhddev.h"
 
@@ -83,6 +87,7 @@
 #endif
 
 extern int ConfigAudioBufferTime;	///< config size ms of audio buffer
+extern int ConfigVideoClearOnSwitch;	//<  clear decoder on channel switch
 char ConfigStartX11Server;		///< flag start the x11 server
 static char ConfigStartSuspended;	///< flag to start in suspend mode
 static char ConfigFullscreen;		///< fullscreen modus
@@ -1096,6 +1101,7 @@
     if (AudioChannelID != id) {		// id changed audio track changed
 	AudioChannelID = id;
 	AudioCodecID = AV_CODEC_ID_NONE;
+	Debug(3, "audio/demux: new channel id\n");
     }
     // Private stream + LPCM ID
     if ((id & 0xF0) == 0xA0) {
@@ -1299,12 +1305,19 @@
     AudioSetVolume((volume * 1000) / 255);
 }
 
+/**
+***	Resets channel ID (restarts audio).
+**/
+void ResetChannelId(void)
+{
+    AudioChannelID = -1;
+    Debug(3, "audio/demux: reset channel id\n");
+}
+
 //////////////////////////////////////////////////////////////////////////////
 //	Video
 //////////////////////////////////////////////////////////////////////////////
 
-#include <alsa/iatomic.h>		// portable atomic_t
-
 #define VIDEO_BUFFER_SIZE (512 * 1024)	///< video PES buffer default size
 #define VIDEO_PACKET_MAX 192		///< max number of video packets
 
@@ -1743,22 +1756,40 @@
 #endif
 
 /**
+**	Open video stream.
+**
+**	@param stream	video stream
+*/
+static void VideoStreamOpen(VideoStream * stream)
+{
+    stream->SkipStream = 1;
+    stream->CodecID = AV_CODEC_ID_NONE;
+    stream->LastCodecID = AV_CODEC_ID_NONE;
+
+    if ((stream->HwDecoder = VideoNewHwDecoder(stream))) {
+	stream->Decoder = CodecVideoNewDecoder(stream->HwDecoder);
+	VideoPacketInit(stream);
+	stream->SkipStream = 0;
+    }
+}
+
+/**
 **	Close video stream.
 **
 **	@param stream	video stream
+**	@param delhw	flag delete hardware decoder
 **
-**	@note must be called from the video thread, othewise xcb has a
+**	@note must be called from the video thread, otherwise xcb has a
 **	deadlock.
 */
-static void VideoStreamClose(VideoStream * stream)
+static void VideoStreamClose(VideoStream * stream, int delhw)
 {
-    // FIXME: use this function to close the main video stream!
     stream->SkipStream = 1;
     if (stream->Decoder) {
 	VideoDecoder *decoder;
 
 	decoder = stream->Decoder;
-	// FIXME: this lock shouldn't be necessary now
+	// FIXME: remove this lock for main stream close
 	pthread_mutex_lock(&stream->DecoderLockMutex);
 	stream->Decoder = NULL;		// lock read thread
 	pthread_mutex_unlock(&stream->DecoderLockMutex);
@@ -1766,7 +1797,9 @@
 	CodecVideoDelDecoder(decoder);
     }
     if (stream->HwDecoder) {
-	VideoDelHwDecoder(stream->HwDecoder);
+	if (delhw) {
+	    VideoDelHwDecoder(stream->HwDecoder);
+	}
 	stream->HwDecoder = NULL;
 	// FIXME: CodecVideoClose calls/uses hw decoder
     }
@@ -1796,13 +1829,14 @@
     }
 
     if (stream->Close) {		// close stream request
-	VideoStreamClose(stream);
+	VideoStreamClose(stream, 1);
 	stream->Close = 0;
 	return 1;
     }
     if (stream->ClearBuffers) {		// clear buffer request
 	atomic_set(&stream->PacketsFilled, 0);
 	stream->PacketRead = stream->PacketWrite;
+	// FIXME: ->Decoder already checked
 	if (stream->Decoder) {
 	    CodecVideoFlushBuffers(stream->Decoder);
 	    VideoResetStart(stream->HwDecoder);
@@ -1839,13 +1873,14 @@
     }
 
     if (stream->Close) {		// close stream request
-	VideoStreamClose(stream);
+	VideoStreamClose(stream, 1);
 	stream->Close = 0;
 	return 1;
     }
     if (stream->ClearBuffers) {		// clear buffer request
 	atomic_set(&stream->PacketsFilled, 0);
 	stream->PacketRead = stream->PacketWrite;
+	// FIXME: ->Decoder already checked
 	if (stream->Decoder) {
 	    CodecVideoFlushBuffers(stream->Decoder);
 	    VideoResetStart(stream->HwDecoder);
@@ -1988,17 +2023,8 @@
     }
     VideoOsdInit();
     if (!MyVideoStream->Decoder) {
-	MyVideoStream->SkipStream = 1;
-	MyVideoStream->CodecID = AV_CODEC_ID_NONE;
-	MyVideoStream->LastCodecID = AV_CODEC_ID_NONE;
-
-	if ((MyVideoStream->HwDecoder = VideoNewHwDecoder(MyVideoStream))) {
-	    MyVideoStream->Decoder =
-		CodecVideoNewDecoder(MyVideoStream->HwDecoder);
-	    VideoPacketInit(MyVideoStream);
-	    AudioSyncStream = MyVideoStream;
-	    MyVideoStream->SkipStream = 0;
-	}
+	VideoStreamOpen(MyVideoStream);
+	AudioSyncStream = MyVideoStream;
     }
 }
 
@@ -2010,6 +2036,10 @@
     VideoOsdExit();
     VideoExit();
     AudioSyncStream = NULL;
+#if 1
+    // FIXME: done by exit: VideoDelHwDecoder(MyVideoStream->HwDecoder);
+    VideoStreamClose(MyVideoStream, 0);
+#else
     MyVideoStream->SkipStream = 1;
     if (MyVideoStream->Decoder) {
 	VideoDecoder *decoder;
@@ -2030,6 +2060,7 @@
 
     MyVideoStream->NewStream = 1;
     MyVideoStream->InvalidPesCounter = 0;
+#endif
 }
 
 #ifdef DEBUG
@@ -2447,45 +2478,48 @@
 */
 int SetPlayMode(int play_mode)
 {
-    VideoDisplayWakeup();
-    // tell video parser we have new stream
-    if (MyVideoStream->Decoder && !MyVideoStream->SkipStream) {
-	if (MyVideoStream->ClearClose) {	// replay clear buffers on close
-	    Clear();			// flush all buffers
-	    MyVideoStream->ClearClose = 0;
-	}
-	if (MyVideoStream->CodecID != AV_CODEC_ID_NONE) {
-	    MyVideoStream->NewStream = 1;
-	    MyVideoStream->InvalidPesCounter = 0;
-	    // tell hw decoder we are closing stream
-	    VideoSetClosing(MyVideoStream->HwDecoder);
-	    VideoResetStart(MyVideoStream->HwDecoder);
-#ifdef DEBUG
-	    VideoSwitch = GetMsTicks();
-#endif
-	}
-    }
-    if (MyAudioDecoder) {		// tell audio parser we have new stream
-	if (AudioCodecID != AV_CODEC_ID_NONE) {
-	    NewAudioStream = 1;
-	}
-    }
     switch (play_mode) {
-	case 0:			// nothing
-	case 1:			// audio/video from player
+	case 0:			// audio/video from decoder
+	    // tell video parser we get new stream
+	    if (MyVideoStream->Decoder && !MyVideoStream->SkipStream) {
+		// clear buffers on close configured always or replay only
+		if (ConfigVideoClearOnSwitch || MyVideoStream->ClearClose) {
+		    Clear();		// flush all buffers
+		    MyVideoStream->ClearClose = 0;
+		}
+		if (MyVideoStream->CodecID != AV_CODEC_ID_NONE) {
+		    MyVideoStream->NewStream = 1;
+		    MyVideoStream->InvalidPesCounter = 0;
+		    // tell hw decoder we are closing stream
+		    VideoSetClosing(MyVideoStream->HwDecoder);
+		    VideoResetStart(MyVideoStream->HwDecoder);
+#ifdef DEBUG
+		    VideoSwitch = GetMsTicks();
+		    Debug(3, "video: new stream start\n");
+#endif
+		}
+	    }
+	    if (MyAudioDecoder) {	// tell audio parser we have new stream
+		if (AudioCodecID != AV_CODEC_ID_NONE) {
+		    NewAudioStream = 1;
+		}
+	    }
 	    break;
-	case 2:			// audio only
-	    Debug(3, "softhddev: FIXME: audio only, silence video errors\n");
+	case 1:			// audio/video from player
+	    VideoDisplayWakeup();
+	    Play();
 	    break;
-	case 3:			// audio only, black screen
+	case 2:			// audio only from player, video from decoder
+	case 3:			// audio only from player, no video (black screen)
 	    Debug(3, "softhddev: FIXME: audio only, silence video errors\n");
+	    VideoDisplayWakeup();
+	    Play();
 	    break;
-	case 4:			// video only
+	case 4:			// video only from player, audio from decoder
+	    VideoDisplayWakeup();
+	    Play();
 	    break;
     }
-
-    Play();
-
     return 1;
 }
 
@@ -2569,8 +2603,10 @@
 
     VideoResetPacket(MyVideoStream);	// terminate work
     MyVideoStream->ClearBuffers = 1;
-    AudioFlushBuffers();
-    //NewAudioStream = 1;
+    if (!SkipAudio) {
+	AudioFlushBuffers();
+	//NewAudioStream = 1;
+    }
     // FIXME: audio avcodec_flush_buffers, video is done by VideoClearBuffers
 
     // wait for empty buffers
@@ -2866,6 +2902,8 @@
 	"\tstill-hw-decoder\tenable hardware decoder for still-pictures\n"
 	"\tstill-h264-hw-decoder\tenable h264 hw decoder for still-pictures\n"
 	"\talsa-driver-broken\tdisable broken alsa driver message\n"
+	"\talsa-no-close-open\tdisable close open to fix alsa no sound bug\n"
+	"\talsa-close-open-delay\tenable close open delay to fix no sound bug\n"
 	"\tignore-repeat-pict\tdisable repeat pict message\n"
 	"  -D\t\tstart in detached mode\n";
 }
@@ -2942,6 +2980,10 @@
 		    ConfigStillDecoder = 1;
 		} else if (!strcasecmp("alsa-driver-broken", optarg)) {
 		    AudioAlsaDriverBroken = 1;
+		} else if (!strcasecmp("alsa-no-close-open", optarg)) {
+		    AudioAlsaNoCloseOpen = 1;
+		} else if (!strcasecmp("alsa-close-open-delay", optarg)) {
+		    AudioAlsaCloseOpenDelay = 1;
 		} else if (!strcasecmp("ignore-repeat-pict", optarg)) {
 		    VideoIgnoreRepeatPict = 1;
 		} else {
@@ -3060,7 +3102,7 @@
     Debug(3, "x-setup: Starting X server '%s' '%s'\n", args[0],
 	X11ServerArguments);
     //	fork
-    if ((pid = vfork())) {		// parent
+    if ((pid = fork())) {		// parent
 
 	X11ServerPid = pid;
 	Debug(3, "x-setup: Started x-server pid=%d\n", X11ServerPid);
@@ -3280,6 +3322,8 @@
     DelPip();				// must stop PIP
 #endif
 
+    // FIXME: should not be correct, if not both are suspended!
+    // Move down into if (video) ...
     MyVideoStream->SkipStream = 1;
     SkipAudio = 1;
 
@@ -3426,16 +3470,7 @@
     }
 
     if (!PipVideoStream->Decoder) {
-	PipVideoStream->SkipStream = 1;
-	PipVideoStream->CodecID = AV_CODEC_ID_NONE;
-	PipVideoStream->LastCodecID = AV_CODEC_ID_NONE;
-
-	if ((PipVideoStream->HwDecoder = VideoNewHwDecoder(PipVideoStream))) {
-	    PipVideoStream->Decoder =
-		CodecVideoNewDecoder(PipVideoStream->HwDecoder);
-	    VideoPacketInit(PipVideoStream);
-	    PipVideoStream->SkipStream = 0;
-	}
+	VideoStreamOpen(PipVideoStream);
     }
     PipSetPosition(x, y, width, height, pip_x, pip_y, pip_width, pip_height);
 }
@@ -3453,34 +3488,11 @@
 
     ScaleVideo(0, 0, 0, 0);
 
-#if 0
-    PipVideoStream->SkipStream = 1;	// lock write thread
-    if (PipVideoStream->Decoder) {
-	VideoDecoder *decoder;
-
-	decoder = PipVideoStream->Decoder;
-	pthread_mutex_lock(&PipVideoStream->DecoderLockMutex);
-	PipVideoStream->Decoder = NULL;	// lock read thread
-	pthread_mutex_unlock(&PipVideoStream->DecoderLockMutex);
-	CodecVideoClose(decoder);
-	CodecVideoDelDecoder(decoder);
-    }
-    if (PipVideoStream->HwDecoder) {
-	VideoDelHwDecoder(PipVideoStream->HwDecoder);
-	PipVideoStream->HwDecoder = NULL;
-	// FIXME: CodecVideoClose calls/uses hw decoder
-    }
-    VideoPacketExit(PipVideoStream);
-
-    PipVideoStream->NewStream = 1;
-    PipVideoStream->InvalidPesCounter = 0;
-#else
     PipVideoStream->Close = 1;
     for (i = 0; PipVideoStream->Close && i < 50; ++i) {
 	usleep(1 * 1000);
     }
     Info("[softhddev]%s: pip close %dms\n", __FUNCTION__, i);
-#endif
 }
 
 /**
diff -Naur orig/softhddev.h mod/softhddev.h
--- orig/softhddev.h	2013-09-30 20:54:27.000000000 +0200
+++ mod/softhddev.h	2015-02-19 22:30:47.270794589 +0100
@@ -1,7 +1,7 @@
 ///
 ///	@file softhddev.h	@brief software HD device plugin header file.
 ///
-///	Copyright (c) 2011 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2011 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: a79350320687537f7484100404db1531f94502ce $
 //////////////////////////////////////////////////////////////////////////////
 
 #ifdef __cplusplus
@@ -25,7 +25,8 @@
 {
 #endif
     /// C callback feed key press
-    extern void FeedKeyPress(const char *, const char *, int, int);
+    extern void FeedKeyPress(const char *, const char *, int, int,
+	const char *);
 
     /// C plugin get osd size and ascpect
     extern void GetOsdSize(int *, int *, double *);
@@ -41,6 +42,8 @@
     extern int PlayTsAudio(const uint8_t *, int);
     /// C plugin set audio volume
     extern void SetVolumeDevice(int);
+    /// C plugin reset channel id (restarts audio)
+    extern void ResetChannelId(void);
 
     /// C plugin play video packet
     extern int PlayVideo(const uint8_t *, int);
diff -Naur orig/softhddevice.cpp mod/softhddevice.cpp
--- orig/softhddevice.cpp	2013-09-30 20:54:27.000000000 +0200
+++ mod/softhddevice.cpp	2015-02-19 22:30:47.274794589 +0100
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 310855b004c761c5b305a53fcee14ff41b21f025 $
 //////////////////////////////////////////////////////////////////////////////
 
 #define __STDC_CONSTANT_MACROS		///< needed for ffmpeg UINT64_C
@@ -79,6 +79,7 @@
 
 static char ConfigMakePrimary;		///< config primary wanted
 static char ConfigHideMainMenuEntry;	///< config hide main menu entry
+static char ConfigDetachFromMainMenu;	///< detach from main menu entry instead of suspend
 static char ConfigSuspendClose;		///< suspend should close devices
 static char ConfigSuspendX11;		///< suspend should stop x11
 
@@ -91,6 +92,7 @@
 static char ConfigVideo60HzMode;	///< config use 60Hz display mode
 static char ConfigVideoSoftStartSync;	///< config use softstart sync
 static char ConfigVideoBlackPicture;	///< config enable black picture mode
+char ConfigVideoClearOnSwitch;		///< config enable Clear on channel switch
 
 static int ConfigVideoBrightness;	///< config video brightness
 static int ConfigVideoContrast = 1000;	///< config video contrast
@@ -138,6 +140,7 @@
 static int ConfigAudioMaxCompression;	///< config max volume compression
 static int ConfigAudioStereoDescent;	///< config reduce stereo loudness
 int ConfigAudioBufferTime;		///< config size ms of audio buffer
+static int ConfigAudioAutoAES;		///< config automatic AES handling
 
 static char *ConfigX11Display;		///< config x11 display
 static char *ConfigAudioDevice;		///< config audio stereo device
@@ -211,9 +214,10 @@
 **	@param key	pressed/released key name
 **	@param repeat	repeated key flag
 **	@param release	released key flag
+**	@param letter	x11 character string (system setting locale)
 */
 extern "C" void FeedKeyPress(const char *keymap, const char *key, int repeat,
-    int release)
+    int release, const char *letter)
 {
     cRemote *remote;
     cSoftRemote *csoft;
@@ -236,9 +240,18 @@
 	csoft = new cSoftRemote(keymap);
     }
 
-    //dsyslog("[softhddev]%s %s, %s\n", __FUNCTION__, keymap, key);
+    //dsyslog("[softhddev]%s %s, %s, %s\n", __FUNCTION__, keymap, key, letter);
     if (key[1]) {			// no single character
-	csoft->Put(key, repeat, release);
+	if (!csoft->Put(key, repeat, release) && letter
+	    && !cRemote::IsLearning()) {
+	    cCharSetConv conv;
+	    unsigned code;
+
+	    code = Utf8CharGet(conv.Convert(letter));
+	    if (code <= 0xFF) {
+		cRemote::Put(KBDKEY(code));	// feed it for edit mode
+	    }
+	}
     } else if (!csoft->Put(key, repeat, release)) {
 	cRemote::Put(KBDKEY(key[0]));	// feed it for edit mode
     }
@@ -255,10 +268,12 @@
 {
   public:
     static volatile char Dirty;		///< flag force redraw everything
-    int OsdLevel;			///< current osd level
+    int OsdLevel;			///< current osd level FIXME: remove
 
      cSoftOsd(int, int, uint);		///< osd constructor
      virtual ~ cSoftOsd(void);		///< osd destructor
+    /// set the sub-areas to the given areas
+    virtual eOsdError SetAreas(const tArea *, int);
     virtual void Flush(void);		///< commits all data to the hardware
     virtual void SetActive(bool);	///< sets OSD to be the active one
 };
@@ -284,11 +299,6 @@
     }
     cOsd::SetActive(on);
 
-    // ignore sub-title if menu is open
-    if (OsdLevel >= OSD_LEVEL_SUBTITLES && IsOpen()) {
-	return;
-    }
-
     if (on) {
 	Dirty = 1;
 	// only flush here if there are already bitmaps
@@ -320,7 +330,6 @@
 #endif
 
     OsdLevel = level;
-    SetActive(true);
 }
 
 /**
@@ -352,6 +361,31 @@
 }
 
 /**
++*	Set the sub-areas to the given areas
+*/
+eOsdError cSoftOsd::SetAreas(const tArea * areas, int n)
+{
+#ifdef OSD_DEBUG
+    dsyslog("[softhddev]%s: %d areas \n", __FUNCTION__, n);
+#endif
+
+    // clear old OSD, when new areas are set
+    if (!IsTrueColor()) {
+	cBitmap *bitmap;
+	int i;
+
+	for (i = 0; (bitmap = GetBitmap(i)); i++) {
+	    bitmap->Clean();
+	}
+    }
+    if (Active()) {
+	VideoOsdClear();
+	Dirty = 1;
+    }
+    return cOsd::SetAreas(areas, n);
+}
+
+/**
 **	Actually commits all data to the OSD hardware.
 */
 void cSoftOsd::Flush(void)
@@ -366,10 +400,6 @@
     if (!Active()) {			// this osd is not active
 	return;
     }
-    // don't draw sub-title if menu is active
-    if (OsdLevel >= OSD_LEVEL_SUBTITLES && IsOpen()) {
-	return;
-    }
 #ifdef USE_YAEPG
     // support yaepghd, video window
     if (vidWin.bpp) {
@@ -385,17 +415,6 @@
     }
 #endif
 
-    //
-    //	VDR draws subtitle without clearing the old
-    //
-    if (OsdLevel >= OSD_LEVEL_SUBTITLES) {
-	VideoOsdClear();
-	cSoftOsd::Dirty = 1;
-#ifdef OSD_DEBUG
-	dsyslog("[softhddev]%s: subtitle clear\n", __FUNCTION__);
-#endif
-    }
-
     if (!IsTrueColor()) {
 	cBitmap *bitmap;
 	int i;
@@ -472,12 +491,12 @@
 	    // FIXME: reuse argb
 	    free(argb);
 	}
-	cSoftOsd::Dirty = 0;
+	Dirty = 0;
 	return;
     }
 
     LOCK_PIXMAPS;
-    while ((pm = RenderPixmaps())) {
+    while ((pm = (dynamic_cast < cPixmapMemory * >(RenderPixmaps())))) {
 	int x;
 	int y;
 	int w;
@@ -494,9 +513,13 @@
 #endif
 	OsdDrawARGB(x, y, w, h, pm->Data());
 
+#if APIVERSNUM >= 20110
+	DestroyPixmap(pm);
+#else
 	delete pm;
+#endif
     }
-    cSoftOsd::Dirty = 0;
+    Dirty = 0;
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -580,6 +603,7 @@
     int General;
     int MakePrimary;
     int HideMainMenuEntry;
+    int DetachFromMainMenu;
     int OsdSize;
     int OsdWidth;
     int OsdHeight;
@@ -595,6 +619,7 @@
     int _60HzMode;
     int SoftStartSync;
     int BlackPicture;
+    int ClearOnSwitch;
 
     int Brightness;
     int Contrast;
@@ -630,6 +655,7 @@
     int AudioMaxCompression;
     int AudioStereoDescent;
     int AudioBufferTime;
+    int AudioAutoAES;
 
 #ifdef USE_PIP
     int Pip;
@@ -757,6 +783,8 @@
 	//	suspend
 	//
 	Add(SeparatorItem(tr("Suspend")));
+	Add(new cMenuEditBoolItem(tr("Detach from main menu entry"),
+		&DetachFromMainMenu, trVDR("no"), trVDR("yes")));
 	Add(new cMenuEditBoolItem(tr("Suspend closes video+audio"),
 		&SuspendClose, trVDR("no"), trVDR("yes")));
 	Add(new cMenuEditBoolItem(tr("Suspend stops x11"), &SuspendX11,
@@ -785,6 +813,8 @@
 		trVDR("no"), trVDR("yes")));
 	Add(new cMenuEditBoolItem(tr("Black during channel switch"),
 		&BlackPicture, trVDR("no"), trVDR("yes")));
+	Add(new cMenuEditBoolItem(tr("Clear decoder on channel switch"),
+		&ClearOnSwitch, trVDR("no"), trVDR("yes")));
 
 	Add(new cMenuEditIntItem(tr("Brightness (-1000..1000) (vdpau)"),
 		&Brightness, -1000, 1000, tr("min"), tr("max")));
@@ -872,6 +902,8 @@
 		&AudioStereoDescent, 0, 1000));
 	Add(new cMenuEditIntItem(tr("Audio buffer size (ms)"),
 		&AudioBufferTime, 0, 1000));
+	Add(new cMenuEditBoolItem(tr("Enable automatic AES"), &AudioAutoAES,
+		trVDR("no"), trVDR("yes")));
     }
 #ifdef USE_PIP
     //
@@ -977,6 +1009,7 @@
     General = 0;
     MakePrimary = ConfigMakePrimary;
     HideMainMenuEntry = ConfigHideMainMenuEntry;
+    DetachFromMainMenu = ConfigDetachFromMainMenu;
     //
     //	osd
     //
@@ -1010,6 +1043,7 @@
     _60HzMode = ConfigVideo60HzMode;
     SoftStartSync = ConfigVideoSoftStartSync;
     BlackPicture = ConfigVideoBlackPicture;
+    ClearOnSwitch = ConfigVideoClearOnSwitch;
 
     Brightness = ConfigVideoBrightness;
     Contrast = ConfigVideoContrast;
@@ -1053,6 +1087,7 @@
     AudioMaxCompression = ConfigAudioMaxCompression;
     AudioStereoDescent = ConfigAudioStereoDescent;
     AudioBufferTime = ConfigAudioBufferTime;
+    AudioAutoAES = ConfigAudioAutoAES;
 
 #ifdef USE_PIP
     //
@@ -1089,6 +1124,8 @@
     SetupStore("MakePrimary", ConfigMakePrimary = MakePrimary);
     SetupStore("HideMainMenuEntry", ConfigHideMainMenuEntry =
 	HideMainMenuEntry);
+    SetupStore("DetachFromMainMenu", ConfigDetachFromMainMenu =
+	DetachFromMainMenu);
     switch (OsdSize) {
 	case 0:
 	    OsdWidth = 0;
@@ -1133,6 +1170,7 @@
     VideoSetSoftStartSync(ConfigVideoSoftStartSync);
     SetupStore("BlackPicture", ConfigVideoBlackPicture = BlackPicture);
     VideoSetBlackPicture(ConfigVideoBlackPicture);
+    SetupStore("ClearOnSwitch", ConfigVideoClearOnSwitch = ClearOnSwitch);
 
     SetupStore("Brightness", ConfigVideoBrightness = Brightness);
     VideoSetBrightness(ConfigVideoBrightness);
@@ -1214,6 +1252,8 @@
 	AudioStereoDescent);
     AudioSetStereoDescent(ConfigAudioStereoDescent);
     SetupStore("AudioBufferTime", ConfigAudioBufferTime = AudioBufferTime);
+    SetupStore("AudioAutoAES", ConfigAudioAutoAES = AudioAutoAES);
+    AudioSetAutoAES(ConfigAudioAutoAES);
 
 #ifdef USE_PIP
     SetupStore("pip.X", ConfigPipX = PipX);
@@ -1746,7 +1786,12 @@
     Clear();				// clear the menu
 
     SetHasHotkeys();
-    Add(new cOsdItem(hk(tr("Suspend SoftHdDevice")), osUser1));
+
+    if (ConfigDetachFromMainMenu) {
+	Add(new cOsdItem(hk(tr("Detach SoftHdDevice")), osUser1));
+    } else {
+	Add(new cOsdItem(hk(tr("Suspend SoftHdDevice")), osUser1));
+    }
 #ifdef USE_PIP
     if (PipReceiver) {
 	Add(new cOsdItem(hk(tr("PIP toggle on/off: off")), osUser2));
@@ -1842,6 +1887,17 @@
 		cString::sprintf(tr("audio delay changed to %d"),
 		    ConfigVideoAudioDelay));
 	    break;
+	case 15:
+	    ConfigAudioDownmix ^= 1;
+	    fprintf(stderr, "toggle downmix\n");
+	    CodecSetAudioDownmix(ConfigAudioDownmix);
+	    if (ConfigAudioDownmix) {
+		Skins.QueueMessage(mtInfo, tr("surround downmix enabled"));
+	    } else {
+		Skins.QueueMessage(mtInfo, tr("surround downmix disabled"));
+	    }
+	    ResetChannelId();
+	    break;
 
 	case 20:			// disable full screen
 	    VideoSetFullscreen(0);
@@ -1916,6 +1972,7 @@
 	    break;
 	case 108:
 	    DelPip();
+	    PipChannelNr = 0;
 	    break;
 #endif
 
@@ -1993,9 +2050,14 @@
 	    if (SuspendMode == NOT_SUSPENDED && !cSoftHdControl::Player) {
 		cControl::Launch(new cSoftHdControl);
 		cControl::Attach();
-		Suspend(ConfigSuspendClose, ConfigSuspendClose,
-		    ConfigSuspendX11);
-		SuspendMode = SUSPEND_NORMAL;
+		if (ConfigDetachFromMainMenu) {
+		    Suspend(1, 1, 0);
+		    SuspendMode = SUSPEND_DETACHED;
+		} else {
+		    Suspend(ConfigSuspendClose, ConfigSuspendClose,
+			ConfigSuspendX11);
+		    SuspendMode = SUSPEND_NORMAL;
+		}
 		if (ShutdownHandler.GetUserInactiveTime()) {
 		    dsyslog("[softhddev]%s: set user inactive\n",
 			__FUNCTION__);
@@ -2021,6 +2083,7 @@
 	    return osEnd;
 	case osUser8:
 	    DelPip();
+	    PipChannelNr = 0;
 	    return osEnd;
 #endif
 	default:
@@ -2043,7 +2106,11 @@
     virtual bool HasDecoder(void) const;
     virtual bool CanReplay(void) const;
     virtual bool SetPlayMode(ePlayMode);
+#if APIVERSNUM >= 20103
+    virtual void TrickSpeed(int, bool);
+#else
     virtual void TrickSpeed(int);
+#endif
     virtual void Clear(void);
     virtual void Play(void);
     virtual void Freeze(void);
@@ -2231,13 +2298,23 @@
 **	times.
 **
 **	@param speed	trick speed
+**	@param forward	flag forward direction
 */
+#if APIVERSNUM >= 20103
+void cSoftHdDevice::TrickSpeed(int speed, bool forward)
+{
+    dsyslog("[softhddev]%s: %d %d\n", __FUNCTION__, speed, forward);
+
+    ::TrickSpeed(speed);
+}
+#else
 void cSoftHdDevice::TrickSpeed(int speed)
 {
     dsyslog("[softhddev]%s: %d\n", __FUNCTION__, speed);
 
     ::TrickSpeed(speed);
 }
+#endif
 
 /**
 **	Clears all video and audio data from the device.
@@ -2542,8 +2619,8 @@
 void cSoftHdDevice::ScaleVideo(const cRect & rect)
 {
 #ifdef OSD_DEBUG
-    dsyslog("[softhddev]%s: %dx%d%+d%+d\n", __FUNCTION__, VidWinRect.Width(),
-	VidWinRect.Height(), VidWinRect.X(), VidWinRect.Y());
+    dsyslog("[softhddev]%s: %dx%d%+d%+d\n", __FUNCTION__, rect.Width(),
+	rect.Height(), rect.X(), rect.Y());
 #endif
     ::ScaleVideo(rect.X(), rect.Y(), rect.Width(), rect.Height());
 }
@@ -2803,6 +2880,10 @@
 	ConfigHideMainMenuEntry = atoi(value);
 	return true;
     }
+    if (!strcasecmp(name, "DetachFromMainMenu")) {
+	ConfigDetachFromMainMenu = atoi(value);
+	return true;
+    }
     if (!strcasecmp(name, "Osd.Width")) {
 	ConfigOsdWidth = atoi(value);
 	VideoSetOsdSize(ConfigOsdWidth, ConfigOsdHeight);
@@ -2852,6 +2933,10 @@
 	VideoSetBlackPicture(ConfigVideoBlackPicture = atoi(value));
 	return true;
     }
+    if (!strcasecmp(name, "ClearOnSwitch")) {
+	ConfigVideoClearOnSwitch = atoi(value);
+	return true;
+    }
     if (!strcasecmp(name, "Brightness")) {
 	VideoSetBrightness(ConfigVideoBrightness = atoi(value));
 	return true;
@@ -2998,6 +3083,11 @@
 	ConfigAudioBufferTime = atoi(value);
 	return true;
     }
+    if (!strcasecmp(name, "AudioAutoAES")) {
+	ConfigAudioAutoAES = atoi(value);
+	AudioSetAutoAES(ConfigAudioAutoAES);
+	return true;
+    }
 #ifdef USE_PIP
     if (!strcasecmp(name, "pip.X")) {
 	ConfigPipX = atoi(value);
@@ -3183,7 +3273,7 @@
 	"    11: enable audio pass-through\n"
 	"    12: toggle audio pass-through\n"
 	"    13: decrease audio delay by 10ms\n"
-	"    14: increase audio delay by 10ms\n"
+	"    14: increase audio delay by 10ms\n" "    15: toggle ac3 mixdown\n"
 	"    20: disable fullscreen\n\040   21: enable fullscreen\n"
 	"    22: toggle fullscreen\n"
 	"    23: disable auto-crop\n\040   24: enable auto-crop\n"
diff -Naur orig/softhddevice.h mod/softhddevice.h
--- orig/softhddevice.h	2013-09-30 20:54:27.000000000 +0200
+++ mod/softhddevice.h	2015-02-19 22:30:47.274794589 +0100
@@ -1,7 +1,7 @@
 ///
 ///	@file softhddevice.h	@brief software HD device plugin header file.
 ///
-///	Copyright (c) 2011 by Johns.  All Rights Reserved.
+///	Copyright (c) 2011, 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,5 +17,5 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 3bc44809950ec019529638cad9223a85d4ab5576 $
 //////////////////////////////////////////////////////////////////////////////
diff -Naur orig/softhddevice_service.h mod/softhddevice_service.h
--- orig/softhddevice_service.h	2013-09-30 20:54:27.000000000 +0200
+++ mod/softhddevice_service.h	2015-02-19 22:30:47.274794589 +0100
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: c7c2d5e8b724515d7c767668aab717b27f4e4068 $
 //////////////////////////////////////////////////////////////////////////////
 
 #pragma once
diff -Naur orig/Todo mod/Todo
--- orig/Todo	2013-09-30 20:54:27.000000000 +0200
+++ mod/Todo	2015-02-19 22:30:47.254794589 +0100
@@ -45,6 +45,7 @@
     still-picture of PES recordings should use VideoMpegEnqueue.
     convert PIX_FMT_... PixelFormat to new names AV_PIX_FMT_..., AVPixelFormat.
     atmo service support 3D grab
+    no warnings during still picture
 
 vdpau:
     software deinterlace path not working.
@@ -127,6 +128,7 @@
     svdrp prim: support plugin names for device numbers.
     Workaround exists: hangup PipVideoStream -> Vdpau_get_format -> xcb -> poll
 	+ lock DecoderLockMutex
+    check compiletime and runtime ffmpeg/libav version during init.
 
 future features (not planed for 1.0 - 1.5)
 
diff -Naur orig/video.c mod/video.c
--- orig/video.c	2013-09-30 20:54:27.000000000 +0200
+++ mod/video.c	2015-02-19 22:30:47.294794588 +0100
@@ -1,7 +1,7 @@
 ///
 ///	@file video.c	@brief Video module
 ///
-///	Copyright (c) 2009 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2009 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 56cae364180758d7fc1a21e2fe193f151eca3652 $
 //////////////////////////////////////////////////////////////////////////////
 
 ///
@@ -46,7 +46,7 @@
 #define USE_DOUBLEBUFFER		///< use GLX double buffers
 //#define USE_VAAPI				///< enable vaapi support
 //#define USE_VDPAU				///< enable vdpau support
-#define noUSE_BITMAP			///< use vdpau bitmap surface
+//#define USE_BITMAP			///< use vdpau bitmap surface
 //#define AV_INFO				///< log a/v sync informations
 #ifndef AV_INFO_TIME
 #define AV_INFO_TIME (50 * 60)		///< a/v info every minute
@@ -64,13 +64,12 @@
 #include <stdint.h>
 #include <string.h>
 #include <unistd.h>
+#include <math.h>
 
 #include <libintl.h>
 #define _(str) gettext(str)		///< gettext shortcut
 #define _N(str) str			///< gettext_noop shortcut
 
-#include <alsa/iatomic.h>		// portable atomic_t
-
 #ifdef USE_VIDEO_THREAD
 #ifndef __USE_GNU
 #define __USE_GNU
@@ -135,6 +134,9 @@
 
 #ifdef USE_VAAPI
 #include <va/va_x11.h>
+#if VA_CHECK_VERSION(0,33,99)
+#include <va/va_vpp.h>
+#endif
 #ifdef USE_GLX
 #include <va/va_glx.h>
 #endif
@@ -175,6 +177,7 @@
 #define FFMPEG_BUG1_WORKAROUND		///< get_format bug workaround
 #endif
 
+#include "iatomic.h"			// portable atomic_t
 #include "misc.h"
 #include "video.h"
 #include "audio.h"
@@ -443,13 +446,32 @@
 ///
 ///	@note frame->interlaced_frame can't be used for interlace detection
 ///
-static void VideoSetPts(int64_t * pts_p, int interlaced, const AVFrame * frame)
+static void VideoSetPts(int64_t * pts_p, int interlaced,
+    const AVCodecContext * video_ctx, const AVFrame * frame)
 {
     int64_t pts;
+    int duration;
+
+    //
+    //	Get duration for this frame.
+    //	FIXME: using framerate as workaround for av_frame_get_pkt_duration
+    //
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(56,13,100)
+    // FIXME: need frame rate for older versions
+    duration = interlaced ? 40 : 20;	// 50Hz -> 20ms default
+#else
+    if (video_ctx->framerate.num != 0 && video_ctx->framerate.den != 0) {
+	duration = 1000 * video_ctx->framerate.den / video_ctx->framerate.num;
+    } else {
+	duration = interlaced ? 40 : 20;	// 50Hz -> 20ms default
+    }
+    Debug(4, "video: %d/%d %" PRIx64 " -> %d\n", video_ctx->framerate.den,
+	video_ctx->framerate.num, av_frame_get_pkt_duration(frame), duration);
+#endif
 
     // update video clock
     if (*pts_p != (int64_t) AV_NOPTS_VALUE) {
-	*pts_p += interlaced ? 40 * 90 : 20 * 90;
+	*pts_p += duration * 90;
 	//Info("video: %s +pts\n", Timestamp2String(*pts_p));
     }
     //av_opt_ptr(avcodec_get_frame_class(), frame, "best_effort_timestamp");
@@ -912,13 +934,13 @@
     // FIXME: if not; use zero buffer
     // FIXME: if not; use dirty area
 
-    texbuf = calloc(OsdWidth * OsdHeight, 4);
-
     // set glx context
     if (!glXMakeCurrent(XlibDisplay, VideoWindow, GlxContext)) {
 	Error(_("video/glx: can't make glx context current\n"));
 	return;
     }
+
+    texbuf = calloc(OsdWidth * OsdHeight, 4);
     GlxUploadOsdTexture(0, 0, OsdWidth, OsdHeight, texbuf);
     glXMakeCurrent(XlibDisplay, None, NULL);
 
@@ -1443,7 +1465,6 @@
 static char VaapiBuggyXvBA;		///< fix xvba-video bugs
 static char VaapiBuggyVdpau;		///< fix libva-driver-vdpau bugs
 static char VaapiBuggyIntel;		///< fix libva-driver-intel bugs
-static char VaapiNewIntel;		///< new libva-driver-intel driver
 
 static VADisplay *VaDisplay;		///< VA-API display
 
@@ -1454,6 +1475,10 @@
 static VASubpictureID VaOsdSubpicture = VA_INVALID_ID;	///< osd VA-API subpicture
 static char VaapiUnscaledOsd;		///< unscaled osd supported
 
+#if VA_CHECK_VERSION(0,33,99)
+static char VaapiVideoProcessing;	///< supports video processing
+#endif
+
     /// VA-API decoder typedef
 typedef struct _vaapi_decoder_ VaapiDecoder;
 
@@ -1993,9 +2018,13 @@
 
     decoder->PTS = AV_NOPTS_VALUE;
 
-    // get/put still not working
-    //decoder->GetPutImage = !VaapiBuggyIntel || VaapiNewIntel;
+    // old va-api intel driver didn't supported get/put-image.
+#if VA_CHECK_VERSION(0,33,99)
+    // FIXME: not the exact version with support
+    decoder->GetPutImage = 1;
+#else
     decoder->GetPutImage = !VaapiBuggyIntel;
+#endif
 
     VaapiDecoders[VaapiDecoderN++] = decoder;
 
@@ -2339,9 +2368,6 @@
     if (strstr(s, "Intel i965")) {
 	VaapiBuggyIntel = 1;
     }
-    if (strstr(s, "Intel i965 driver - 1.0.16.")) {
-	VaapiNewIntel = 1;
-    }
     //
     //	check which attributes are supported
     //
@@ -2364,6 +2390,30 @@
     Vaapi1080i();
 #endif
 
+#if VA_CHECK_VERSION(0,33,99)
+    //
+    //	check vpp support
+    //
+    if (1) {
+	VAEntrypoint entrypoints[vaMaxNumEntrypoints(VaDisplay)];
+	int entrypoint_n;
+	int i;
+
+	VaapiVideoProcessing = 0;
+	if (!vaQueryConfigEntrypoints(VaDisplay, VAProfileNone, entrypoints,
+		&entrypoint_n)) {
+
+	    for (i = 0; i < entrypoint_n; i++) {
+		fprintf(stderr, "oops %d\n", i);
+		if (entrypoints[i] == VAEntrypointVideoProc) {
+		    Info("video/vaapi: supports video processing\n");
+		    VaapiVideoProcessing = 1;
+		    break;
+		}
+	    }
+	}
+    }
+#endif
     return 1;
 }
 
@@ -2587,6 +2637,126 @@
 }
 
 ///
+///	Configure VA-API for new video format.
+///
+///	@param decoder	VA-API decoder
+///
+static void VaapiSetupVideoProcessing(VaapiDecoder * decoder)
+{
+#if VA_CHECK_VERSION(0,33,99)
+    VAProcFilterType filtertypes[VAProcFilterCount];
+    unsigned filtertype_n;
+    unsigned u;
+    unsigned v;
+    VAProcFilterCap denoise_caps[1];
+    unsigned denoise_cap_n;
+    VAProcFilterCapDeinterlacing deinterlacing_caps[VAProcDeinterlacingCount];
+    unsigned deinterlacing_cap_n;
+    VABufferID denoise_filter;
+    VABufferID deint_filter;
+    VABufferID sharpen_filter;
+    VABufferID color_filter;
+    VABufferID filters[VAProcFilterCount];
+    unsigned filter_n;
+
+    if (!VaapiVideoProcessing) {
+	return;
+    }
+    //
+    //	display and filter infos.
+    //
+    filtertype_n = VAProcFilterCount;	// API break this must be done
+    vaQueryVideoProcFilters(VaDisplay, decoder->VaapiContext->context_id,
+	filtertypes, &filtertype_n);
+    for (u = 0; u < filtertype_n; ++u) {
+	switch (filtertypes[u]) {
+	    case VAProcFilterNoiseReduction:
+		Info("video/vaapi: noise reduction supported\n");
+
+		denoise_cap_n = 1;
+		vaQueryVideoProcFilterCaps(VaDisplay,
+		    decoder->VaapiContext->context_id,
+		    VAProcFilterNoiseReduction, denoise_caps, &denoise_cap_n);
+		if (denoise_cap_n) {
+		    Info("video/vaapi: %.2f - %.2f ++ %.2f = %.2f\n",
+			denoise_caps->range.min_value,
+			denoise_caps->range.max_value,
+			denoise_caps->range.step,
+			denoise_caps->range.default_value);
+		}
+		break;
+	    case VAProcFilterDeinterlacing:
+		Info("video/vaapi: deinterlacing supported\n");
+
+		deinterlacing_cap_n = VAProcDeinterlacingCount;
+		vaQueryVideoProcFilterCaps(VaDisplay,
+		    decoder->VaapiContext->context_id,
+		    VAProcFilterDeinterlacing, deinterlacing_caps,
+		    &deinterlacing_cap_n);
+		for (v = 0; v < deinterlacing_cap_n; ++v) {
+		    switch (deinterlacing_caps[v].type) {
+			case VAProcDeinterlacingBob:
+			    Info("video/vaapi: bob deinterlace supported\n");
+			    break;
+			case VAProcDeinterlacingWeave:
+			    Info("video/vaapi: weave deinterlace supported\n");
+			    break;
+			case VAProcDeinterlacingMotionAdaptive:
+			    Info("video/vaapi: motion adaptive deinterlace supported\n");
+			    break;
+			case VAProcDeinterlacingMotionCompensated:
+			    Info("video/vaapi: motion compensated deinterlace supported\n");
+			    break;
+			default:
+			    Info("video/vaapi: unsupported deinterlace #%02x\n", deinterlacing_caps[v].type);
+			    break;
+		    }
+		}
+		break;
+	    case VAProcFilterSharpening:
+		Info("video/vaapi: sharpening supported\n");
+		break;
+	    case VAProcFilterColorBalance:
+		Info("video/vaapi: color balance supported\n");
+		break;
+	    default:
+		Info("video/vaapi: unsupported filter #%02x\n",
+		    filtertypes[u]);
+		break;
+	}
+    }
+
+    //
+    //	create pipeline filters
+    //
+    filter_n = 0;
+
+    filtertype_n = VAProcFilterCount;
+    vaQueryVideoProcFilters(VaDisplay, decoder->VaapiContext->context_id,
+	filtertypes, &filtertype_n);
+    for (u = 0; u < filtertype_n; ++u) {
+	switch (filtertypes[u]) {
+	    case VAProcFilterNoiseReduction:
+		break;
+	    case VAProcFilterDeinterlacing:
+		break;
+	    case VAProcFilterSharpening:
+		break;
+	    case VAProcFilterColorBalance:
+		break;
+	    default:
+		break;
+	}
+    }
+
+    //
+    //	query pipeline caps
+    //
+
+#endif
+}
+
+///
 ///	Get a free surface.  Called from ffmpeg.
 ///
 ///	@param decoder		VA-API decoder
@@ -2627,6 +2797,7 @@
 		vaErrorStr(status));
 	}
 	// FIXME: too late to switch to software rending on failures
+	VaapiSetupVideoProcessing(decoder);
     }
 #else
     (void)video_ctx;
@@ -2859,6 +3030,7 @@
 	    Error(_("codec: can't create context '%s'\n"), vaErrorStr(status));
 	    goto slow_path;
 	}
+	VaapiSetupVideoProcessing(decoder);
     }
 #endif
 
@@ -3402,66 +3574,85 @@
     }
 
     if (decoder->BlackSurface == VA_INVALID_ID) {
-	if (vaCreateSurfaces(decoder->VaDisplay, VA_RT_FORMAT_YUV420,
-		VideoWindowWidth, VideoWindowHeight, &decoder->BlackSurface, 1,
-		NULL, 0) != VA_STATUS_SUCCESS) {
-	    Error(_("video/vaapi: can't create a surface\n"));
+	uint8_t *va_image_data;
+	unsigned u;
+
+	status =
+	    vaCreateSurfaces(decoder->VaDisplay, VA_RT_FORMAT_YUV420,
+	    VideoWindowWidth, VideoWindowHeight, &decoder->BlackSurface, 1,
+	    NULL, 0);
+	if (status != VA_STATUS_SUCCESS) {
+	    Error(_("video/vaapi: can't create a surface: %s\n"),
+		vaErrorStr(status));
 	    return;
 	}
 	// full sized surface, no difference unscaled/scaled osd
-	if (vaAssociateSubpicture(decoder->VaDisplay, VaOsdSubpicture,
-		&decoder->BlackSurface, 1, 0, 0, VaOsdImage.width,
-		VaOsdImage.height, 0, 0, VideoWindowWidth, VideoWindowHeight,
-		0) != VA_STATUS_SUCCESS) {
-	    Error(_("video/vaapi: can't associate subpicture\n"));
+	status =
+	    vaAssociateSubpicture(decoder->VaDisplay, VaOsdSubpicture,
+	    &decoder->BlackSurface, 1, 0, 0, VaOsdImage.width,
+	    VaOsdImage.height, 0, 0, VideoWindowWidth, VideoWindowHeight, 0);
+	if (status != VA_STATUS_SUCCESS) {
+	    Error(_("video/vaapi: can't associate subpicture: %s\n"),
+		vaErrorStr(status));
 	}
 	Debug(3, "video/vaapi: associate %08x\n", decoder->BlackSurface);
-	// FIXME: check if intel forgets this also
 
-	if (0 && decoder->Image->image_id == VA_INVALID_ID) {
+	if (decoder->Image->image_id == VA_INVALID_ID) {
 	    VAImageFormat format[1];
-	    void *va_image_data;
-	    int i;
 
-	    printf("No image\n");
 	    VaapiFindImageFormat(decoder, PIX_FMT_NV12, format);
-	    if ((status =
-		    vaDeriveImage(decoder->VaDisplay, decoder->BlackSurface,
-			decoder->Image)) != VA_STATUS_SUCCESS) {
-		Error(_("video/vaapi: vaDeriveImage failed %d\n"), status);
-		if (vaCreateImage(VaDisplay, format, VideoWindowWidth,
-			VideoWindowHeight,
-			decoder->Image) != VA_STATUS_SUCCESS) {
-		    Error(_("video/vaapi: can't create image!\n"));
-		}
-	    }
-	    if (vaMapBuffer(VaDisplay, decoder->Image->buf, &va_image_data)
-		!= VA_STATUS_SUCCESS) {
-		Error(_("video/vaapi: can't map the image!\n"));
+	    status =
+		vaCreateImage(VaDisplay, format, VideoWindowWidth,
+		VideoWindowHeight, decoder->Image);
+	    if (status != VA_STATUS_SUCCESS) {
+		Error(_("video/vaapi: can't create image: %s\n"),
+		    vaErrorStr(status));
+		return;
 	    }
+	}
 
-	    for (i = 0; (unsigned)i < decoder->Image->data_size; i += 2) {
-		((uint8_t *) va_image_data)[i + 0] = 0xFF;
-		((uint8_t *) va_image_data)[i + 1] = 0xFF;
-	    }
+	status =
+	    vaMapBuffer(VaDisplay, decoder->Image->buf,
+	    (void **)&va_image_data);
+	if (status != VA_STATUS_SUCCESS) {
+	    Error(_("video/vaapi: can't map the image: %s\n"),
+		vaErrorStr(status));
+	    return;
+	}
 
-	    if (vaUnmapBuffer(VaDisplay,
-		    decoder->Image->buf) != VA_STATUS_SUCCESS) {
-		Error(_("video/vaapi: can't unmap the image!\n"));
-	    }
-	    if (vaDestroyImage(VaDisplay,
-		    decoder->Image->image_id) != VA_STATUS_SUCCESS) {
-		Error(_("video/vaapi: can't destroy image!\n"));
+	for (u = 0; u < decoder->Image->data_size; ++u) {
+	    if (u < decoder->Image->offsets[1]) {
+		va_image_data[u] = 0x00;	// Y
+	    } else if (u % 2 == 0) {
+		va_image_data[u] = 0x80;	// U
+	    } else {
+#ifdef DEBUG
+		// make black surface visible
+		va_image_data[u] = 0xFF;	// V
+#else
+		va_image_data[u] = 0x80;	// V
+#endif
 	    }
 	}
-	// FIXME: intel didn't support put image.
-	if (0
-	    && vaPutImage(VaDisplay, decoder->BlackSurface,
+
+	if (vaUnmapBuffer(VaDisplay, decoder->Image->buf) != VA_STATUS_SUCCESS) {
+	    Error(_("video/vaapi: can't unmap the image!\n"));
+	}
+
+	if (decoder->GetPutImage) {
+	    status =
+		vaPutImage(VaDisplay, decoder->BlackSurface,
 		decoder->Image->image_id, 0, 0, VideoWindowWidth,
-		VideoWindowHeight, 0, 0, VideoWindowWidth, VideoWindowHeight)
-	    != VA_STATUS_SUCCESS) {
-	    Error(_("video/vaapi: can't put image!\n"));
+		VideoWindowHeight, 0, 0, VideoWindowWidth, VideoWindowHeight);
+	    if (status != VA_STATUS_SUCCESS) {
+		Error(_("video/vaapi: can't put image!\n"));
+	    }
+	} else {
+	    // FIXME: PutImage isn't always supported
+	    Debug(3,
+		"video/vaapi: put image not supported, alternative path not written\n");
 	}
+
 #ifdef DEBUG
 	start = GetMsTicks();
 #endif
@@ -3491,7 +3682,7 @@
 		VA_FRAME_PICTURE)) != VA_STATUS_SUCCESS) {
 	Error(_("video/vaapi: vaPutSurface failed %d\n"), status);
     }
-    clock_gettime(CLOCK_REALTIME, &decoder->FrameTime);
+    clock_gettime(CLOCK_MONOTONIC, &decoder->FrameTime);
 
     put1 = GetMsTicks();
     if (put1 - sync > 2000) {
@@ -4731,7 +4922,7 @@
 	    put2 = put1;
 #endif
 	}
-	clock_gettime(CLOCK_REALTIME, &nowtime);
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
 	// FIXME: 31 only correct for 50Hz
 	if ((nowtime.tv_sec - decoder->FrameTime.tv_sec)
 	    * 1000 * 1000 * 1000 + (nowtime.tv_nsec -
@@ -4979,7 +5170,10 @@
 		_("video: decoder buffer empty, "
 		    "duping frame (%d/%d) %d v-buf\n"), decoder->FramesDuped,
 		decoder->FrameCounter, VideoGetBuffers(decoder->Stream));
-	    if (decoder->Closing < -300) {
+	    // some time no new picture or black video configured
+	    if (decoder->Closing < -300 || (VideoShowBlackPicture
+		    && decoder->Closing)) {
+		// clear ring buffer to trigger black picture
 		atomic_set(&decoder->SurfacesFilled, 0);
 	    }
 	}
@@ -5082,7 +5276,7 @@
     }
 
     if (!decoder->Closing) {
-	VideoSetPts(&decoder->PTS, decoder->Interlaced, frame);
+	VideoSetPts(&decoder->PTS, decoder->Interlaced, video_ctx, frame);
     }
     VaapiRenderFrame(decoder, video_ctx, frame);
 #ifdef USE_AUTOCROP
@@ -5159,7 +5353,7 @@
 	}
     }
 
-    clock_gettime(CLOCK_REALTIME, &nowtime);
+    clock_gettime(CLOCK_MONOTONIC, &nowtime);
     // time for one frame over?
     if ((nowtime.tv_sec - decoder->FrameTime.tv_sec)
 	* 1000 * 1000 * 1000 + (nowtime.tv_nsec - decoder->FrameTime.tv_nsec) <
@@ -5341,7 +5535,7 @@
 
     VaapiUnscaledOsd = 0;
     if (flags[u] & VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD) {
-	Info(_("video/vaapi: vaapi supports unscaled osd\n"));
+	Info(_("video/vaapi: supports unscaled osd\n"));
 	VaapiUnscaledOsd = 1;
     }
     //VaapiUnscaledOsd = 0;
@@ -8021,7 +8215,7 @@
 	status =
 	    VdpauOutputSurfaceRenderBitmapSurface(VdpauSurfacesRb
 	    [VdpauSurfaceIndex], &output_double_rect,
-	    VdpauOsdOutputSurface[!VdpauOsdSurfaceIndex], &source_rect, NULL,
+	    VdpauOsdBitmapSurface[!VdpauOsdSurfaceIndex], &source_rect, NULL,
 	    VideoTransparentOsd ? &blend_state : NULL,
 	    VDP_OUTPUT_SURFACE_RENDER_ROTATE_0);
 	if (status != VDP_STATUS_OK) {
@@ -8250,15 +8444,29 @@
 	output_rect.y1 = decoder->VideoHeight;
     }
 
+    // FIXME: double buffered osd disabled
+    // VdpauOsdSurfaceIndex always 0 and only 0 valid
+#ifdef USE_BITMAP
+    status =
+	VdpauOutputSurfaceRenderBitmapSurface(VdpauSurfacesRb
+	[VdpauSurfaceIndex], &output_rect,
+	VdpauOsdBitmapSurface[VdpauOsdSurfaceIndex], &source_rect, NULL, NULL,
+	VDP_OUTPUT_SURFACE_RENDER_ROTATE_0);
+    if (status != VDP_STATUS_OK) {
+	Error(_("video/vdpau: can't render output surface: %s\n"),
+	    VdpauGetErrorString(status));
+    }
+#else
     status =
 	VdpauOutputSurfaceRenderOutputSurface(VdpauSurfacesRb
 	[VdpauSurfaceIndex], &output_rect,
-	VdpauOsdOutputSurface[!VdpauOsdSurfaceIndex], &source_rect, NULL, NULL,
+	VdpauOsdOutputSurface[VdpauOsdSurfaceIndex], &source_rect, NULL, NULL,
 	VDP_OUTPUT_SURFACE_RENDER_ROTATE_0);
     if (status != VDP_STATUS_OK) {
 	Error(_("video/vdpau: can't render output surface: %s\n"),
 	    VdpauGetErrorString(status));
     }
+#endif
 }
 
 ///
@@ -8382,7 +8590,7 @@
 	    VdpauGetErrorString(status));
     }
     // FIXME: CLOCK_MONOTONIC_RAW
-    clock_gettime(CLOCK_REALTIME, &VdpauFrameTime);
+    clock_gettime(CLOCK_MONOTONIC, &VdpauFrameTime);
     for (i = 0; i < VdpauDecoderN; ++i) {
 	// remember time of last shown surface
 	VdpauDecoders[i]->FrameTime = VdpauFrameTime;
@@ -8609,7 +8817,10 @@
 		_("video: decoder buffer empty, "
 		    "duping frame (%d/%d) %d v-buf\n"), decoder->FramesDuped,
 		decoder->FrameCounter, VideoGetBuffers(decoder->Stream));
-	    if (decoder->Closing < -300) {
+	    // some time no new picture or black video configured
+	    if (decoder->Closing < -300 || (VideoShowBlackPicture
+		    && decoder->Closing)) {
+		// clear ring buffer to trigger black picture
 		atomic_set(&decoder->SurfacesFilled, 0);
 	    }
 	}
@@ -8687,7 +8898,7 @@
 
     if (VdpauPreemption) {		// display preempted
 	if (!decoder->Closing) {
-	    VideoSetPts(&decoder->PTS, decoder->Interlaced, frame);
+	    VideoSetPts(&decoder->PTS, decoder->Interlaced, video_ctx, frame);
 	}
 	return;
     }
@@ -8737,7 +8948,7 @@
 #endif
 
     if (!decoder->Closing) {
-	VideoSetPts(&decoder->PTS, decoder->Interlaced, frame);
+	VideoSetPts(&decoder->PTS, decoder->Interlaced, video_ctx, frame);
     }
     VdpauRenderFrame(decoder, video_ctx, frame);
 }
@@ -8884,7 +9095,7 @@
 	usleep(5 * 1000);
     }
 
-    clock_gettime(CLOCK_REALTIME, &nowtime);
+    clock_gettime(CLOCK_MONOTONIC, &nowtime);
     // time for one frame over?
     if ((nowtime.tv_sec - VdpauFrameTime.tv_sec) * 1000 * 1000 * 1000 +
 	(nowtime.tv_nsec - VdpauFrameTime.tv_nsec) < 15 * 1000 * 1000) {
@@ -8893,7 +9104,7 @@
 
     if (VdpauPreemption) {		// display preempted
 	if (VdpauPreemptionRecover()) {
-	    clock_gettime(CLOCK_REALTIME, &VdpauFrameTime);
+	    clock_gettime(CLOCK_MONOTONIC, &VdpauFrameTime);
 	    return;
 	}
     }
@@ -8925,7 +9136,7 @@
 static void VdpauSetOutputPosition(VdpauDecoder * decoder, int x, int y,
     int width, int height)
 {
-    Debug(3, "video/vdapu: output %dx%d%+d%+d\n", width, height, x, y);
+    Debug(3, "video/vdpau: output %dx%d%+d%+d\n", width, height, x, y);
 
     decoder->VideoX = x;
     decoder->VideoY = y;
@@ -9520,7 +9731,7 @@
 //----------------------------------------------------------------------------
 
 /// C callback feed key press
-extern void FeedKeyPress(const char *, const char *, int, int);
+extern void FeedKeyPress(const char *, const char *, int, int, const char *);
 
 ///
 ///	Handle XLib I/O Errors.
@@ -9564,6 +9775,8 @@
     KeySym keysym;
     const char *keynam;
     char buf[64];
+    char letter[64];
+    int letter_len;
     uint32_t values[1];
 
     VideoThreadLock();
@@ -9574,7 +9787,7 @@
 	    Debug(3, "video/event: ClientMessage\n");
 	    if (event.xclient.data.l[0] == (long)WmDeleteWindowAtom) {
 		Debug(3, "video/event: wm-delete-message\n");
-		FeedKeyPress("XKeySym", "Close", 0, 0);
+		FeedKeyPress("XKeySym", "Close", 0, 0, NULL);
 	    }
 	    break;
 
@@ -9603,8 +9816,14 @@
 	    break;
 	case KeyPress:
 	    VideoThreadLock();
-	    XLookupString(&event.xkey, buf, sizeof(buf), &keysym, NULL);
+	    letter_len =
+		XLookupString(&event.xkey, letter, sizeof(letter) - 1, &keysym,
+		NULL);
 	    VideoThreadUnlock();
+	    if (letter_len < 0) {
+		letter_len = 0;
+	    }
+	    letter[letter_len] = '\0';
 	    if (keysym == NoSymbol) {
 		Warning(_("video/event: No symbol for %d\n"),
 		    event.xkey.keycode);
@@ -9626,7 +9845,7 @@
 		strncat(buf, keynam, sizeof(buf) - 10);
 		keynam = buf;
 	    }
-	    FeedKeyPress("XKeySym", keynam, 0, 0);
+	    FeedKeyPress("XKeySym", keynam, 0, 0, letter);
 	    break;
 	case KeyRelease:
 	    break;
@@ -11283,7 +11502,8 @@
     const char *x, __attribute__ ((unused))
     const char *y, __attribute__ ((unused))
     int a, __attribute__ ((unused))
-    int b)
+    int b, __attribute__ ((unused))
+    const char *s)
 {
 }
 
@@ -11301,7 +11521,7 @@
 #ifdef GIT_REV
 	"(GIT-" GIT_REV ")"
 #endif
-	",\n\t(c) 2009 - 2013 by Johns\n"
+	",\n\t(c) 2009 - 2014 by Johns\n"
 	"\tLicense AGPLv3: GNU Affero General Public License version 3\n");
 }
 
diff -Naur orig/video.h mod/video.h
--- orig/video.h	2013-09-30 20:54:27.000000000 +0200
+++ mod/video.h	2015-02-19 22:30:47.294794588 +0100
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: fa3e44f3620c4cdae2b0512b13c298fc71ffff0b $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup Video
