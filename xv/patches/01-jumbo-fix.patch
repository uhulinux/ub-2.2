diff :  xv-3.10a-jumbo-fix-patch-20050410.txt

This is a unified diff.  It should be applied (using Larry Wall's "patch"
program) to the stock XV 3.10a sources.  If desired, the jumbo-enhancements
patch may be applied afterward.

diffs below:
   Makefile
   Makefile.std
   README.jumbo
   bggen.c
   bits/icon
   cleandir
   config.h
   copyright.h
   tiff/Makefile
   tiff/Makefile.std
   tiff/RANLIB.sh
   vdcomp.c
   xcmap.c
   xv.c
   xv.h
   xv24to8.c
   xvalg.c
   xvbmp.c
   xvbrowse.c
   xvbutt.c
   xvcolor.c
   xvctrl.c
   xvcut.c
   xvdflt.c
   xvdial.c
   xvdir.c
   xvevent.c
   xvfits.c
   xvgam.c
   xvgif.c
   xvgifwr.c
   xvgrab.c
   xvgraf.c
   xviff.c
   xvimage.c
   xvinfo.c
   xviris.c
   xvjpeg.c
   xvmisc.c
   xvpbm.c
   xvpcx.c
   xvpds.c
   xvpictoppm.c
   xvpm.c
   xvpopup.c
   xvps.c
   xvrle.c
   xvroot.c
   xvscrl.c
   xvsmooth.c
   xvsunras.c
   xvtarga.c
   xvtext.c
   xvtiff.c
   xvtiffwr.c
   xvxbm.c
   xvxpm.c
   xvxwd.c


diff -ruN xv-3.10a/Makefile xv-3.10a-bugfixes/Makefile
--- xv-3.10a/Makefile	1995-01-23 12:20:54.000000000 -0800
+++ xv-3.10a-bugfixes/Makefile	2005-04-06 08:17:13.000000000 -0700
@@ -2,7 +2,11 @@
 
 # your C compiler (and options) of choice
 CC = cc
-# CC = gcc -ansi
+#CC = gcc -ansi
+# note that -ansi kills __USE_MISC (gcc 2.95.3), which (at least in Linux)
+# determines whether stdlib.h includes prototypes for mktemp(), random(), etc.
+# (i.e., if you use it, you will get unnecessary compiler warnings)
+#CC = gcc
 
 # use this if you're using 'cc' on a DEC Alpha (OSF/1) or MIPS (Ultrix) system:
 # CC = cc -std1 -Olimit 750
@@ -14,8 +18,13 @@
 #       -Wuninitialized -Wparentheses
 
 
-CCOPTS = -O 
-
+CCOPTS = -O
+# these are the usual optimization and warning options for gcc; all such
+# warnings but one (mktemp() use) have been eliminated (at least on Linux):
+#CCOPTS = -O3 -Wall
+# for the next step up in gcc noise, try adding -W (but note that it adds a
+# huge number of unused-parameter and signed/unsigned comparison warnings):
+#CCOPTS = -O3 -Wall -W
 
 ### NOTE: Sun running OpenWindows:
 ### if you're using a SUN running OPENWINDOWS, you need to add these two
@@ -27,6 +36,10 @@
 ### '-I' options on the CCOPTS line to tell the compiler where said files are.
 
 
+# BeOS _may_ need to use a different version (below), but probably not
+CLEANDIR = cleandir
+
+
 ### Installation locations
 BINDIR = /usr/local/bin
 MANDIR = /usr/local/man/man1
@@ -38,7 +51,7 @@
 
 
 ########################### CONFIGURATION OPTIONS ############################
-### NOTE: be sure to check 'config.h', for a few other configuration options 
+### NOTE: be sure to check 'config.h', for a few other configuration options
 ##############################################################################
 
 ###
@@ -59,18 +72,25 @@
 ### if, for whatever reason, you're unable to get the TIFF library to compile
 ### on your machine, *COMMENT OUT* the following lines
 ###
-TIFF    = -DDOTIFF
+### GRR 20050319:  USE_TILED_TIFF_BOTLEFT_FIX enables an experimental fix for
+###   tiled TIFFs with ORIENTATION_BOTLEFT.  It may break other tiled TIFFs,
+###   or it may be required for certain other TIFF types (e.g., strips with
+###   ORIENTATION_BOTLEFT).  I don't have a sufficient variety of TIFF test
+###   images at hand.
+###
+#TIFF    = -DDOTIFF
+TIFF    = -DDOTIFF -DUSE_TILED_TIFF_BOTLEFT_FIX
 TIFFDIR = tiff
 TIFFINC = -I$(TIFFDIR)
 TIFFLIB = $(TIFFDIR)/libtiff.a
 $(TIFFLIB):
-	( cd $(TIFFDIR) ; make CC='$(CC)' )
+	( cd $(TIFFDIR) ; make CC='$(CC)' COPTS='$(CCOPTS) $(MCHN)' )
 
 
 ###
 ### if, for whatever reason, you're unable to get the PDS/VICAR support
 ### to compile (xvpds.c, and vdcomp.c), *COMMENT OUT* the following line,
-### and also remove 'vdcomp' from the 'all:' dependancy 
+### and also remove 'vdcomp' from the 'all:' dependancy
 ###
 PDS = -DDOPDS
 
@@ -78,17 +98,25 @@
 #----------System V----------
 
 # if you are running on a SysV-based machine, such as HP, Silicon Graphics,
-# Solaris, etc., uncomment the following line to get mostly there.  
+# Solaris, etc., uncomment the following line to get mostly there.
 #UNIX = -DSVR4
 
 
-#----------Machine Specific Configurations----------
+#----------Machine-Specific Configurations----------
+
+### If you are using a BeOS system, uncomment the following line
+#MCHN = -DUSE_GETCWD -I/usr/X11/include -L/usr/X11/lib
+###
+### The stock version of cleandir now should work for BeOS, too, so try
+### leaving this commented out:
+#CLEANDIR = cleandir.BeOS
+
 
 ### If you are using an SGI system, uncomment the following line
 #MCHN = -Dsgi
 
 
-### For HP-UX, uncomment the following line:
+### For HP-UX, uncomment the following line
 #MCHN= -Dhpux -D_HPUX_SOURCE
 # To use old HP compilers (HPUX 7.0 or so), you may need
 #MCHN= -Dhpux -D_HPUX_SOURCE +Ns4000
@@ -102,22 +130,22 @@
 
 
 ### for LINUX, uncomment the following line
-#MCHN = -DLINUX
+#MCHN = -DLINUX -L/usr/X11R6/lib
 
 
 # For SCO 1.1 (UNIX 3.2v2) machines, uncomment the following:
 #MCHN = -Dsco -DPOSIX
 #
 # For ODT 2.0 (UNIX 3.2v4) machines, uncomment the following:
-#MCHN= -Dsco -DPOSIX -DNO_RANDOM 
+#MCHN= -Dsco -DPOSIX -DNO_RANDOM
 #
 # Also, you should add '-lc -lx' to the end of the LIBS def below
 # -lx must be after -lc so you get the right directory routines.
 
 
 # for UMAX V by Encore Computers uncomment the following line for
-# the portable c compiler, system specific definitions and
-# location of local X11 library(if site specific, modify -L option)
+# the portable C compiler, system-specific definitions and
+# location of local X11 library (if site-specific, modify -L option)
 # No other switches should be necessary, or so I'm told...
 #
 #MCHN = -q extensions=pcc_c -D__UMAXV__ -L/usr2/usr/lib/X11 -DSVR4
@@ -147,8 +175,8 @@
 #TIMERS = -DUSLEEP
 
 
-# if XV locks up whenever you click on *any* of the buttons, the Timer() 
-# function in xvmisc.c is going out to lunch.  A simple workaround is to 
+# if XV locks up whenever you click on *any* of the buttons, the Timer()
+# function in xvmisc.c is going out to lunch.  A simple workaround is to
 # uncomment the following line:
 #TIMERS = -DNOTIMER
 
@@ -160,7 +188,7 @@
 #DXWM = -DDXWM
 
 
-# if, during compilation, your system complains about the types 
+# if, during compilation, your system complains about the types
 # 'u_long', 'u_short', 'u_int', etc. as being undefined, uncomment the
 # following line:
 #BSDTYPES = -DBSDTYPES
@@ -188,7 +216,9 @@
 	$(NODIRENT) $(VPRINTF) $(TIMERS) $(UNIX) $(BSDTYPES) $(RAND) \
 	$(DXWM) $(MCHN)
 
+### remove -lm for BeOS:
 LIBS = -lX11 $(JPEGLIB) $(TIFFLIB) -lm
+#LIBS = -lX11 $(JPEGLIB) $(TIFFLIB)
 
 OBJS = 	xv.o xvevent.o xvroot.o xvmisc.o xvimage.o xvcolor.o xvsmooth.o \
 	xv24to8.o xvgif.o xvpm.o xvinfo.o xvctrl.o xvscrl.o xvalg.o \
@@ -231,9 +261,10 @@
 
 clean:  xvclean
 	rm -f bggen vdcomp xcmap xvpictoppm
-	./cleandir $(JPEGDIR)
-	rm -f $(JPEGDIR)/jconfig.h $(JPEGDIR)/Makefile
-	./cleandir $(TIFFDIR)
+#	clean only local jpeg and tiff dirs, not user's or system's copies:
+	./$(CLEANDIR) jpeg
+	rm -f jpeg/jconfig.h jpeg/Makefile
+	./$(CLEANDIR) tiff
 
 
 install: all
@@ -246,8 +277,9 @@
 	cp docs/xvdocs.ps* $(LIBDIR)
 
 tar:
+#	tar only local jpeg and tiff dirs, not user's or system's copies:
 	tar cvf xv.tar Makefile* Imakefile *.c *.h bits \
-		docs unsupt vms $(JPEGDIR) $(TIFFDIR) $(MISC) 
+		docs unsupt vms jpeg tiff $(MISC)
 
 xvtar:
 	tar cvf xv.tar Makefile* Imakefile *.c *.h bits
@@ -257,26 +289,26 @@
 
 ################# bitmap dependencies ####################
 
-xv.o:      	bits/icon bits/iconmask bits/runicon bits/runiconm
-xv.o:      	bits/cboard50 bits/gray25 
+xv.o:		bits/icon bits/iconmask bits/runicon bits/runiconm
+xv.o:		bits/cboard50 bits/gray25
 
 xvbrowse.o:	bits/br_file bits/br_dir bits/br_exe bits/br_chr bits/br_blk
-xvbrowse.o:	bits/br_sock bits/br_fifo bits/br_error bits/br_unknown
+xvbrowse.o:	bits/br_sock bits/br_fifo bits/br_error # bits/br_unknown
 xvbrowse.o:	bits/br_cmpres bits/br_gif bits/br_pm bits/br_pbm
 xvbrowse.o:	bits/br_sunras bits/br_bmp bits/br_utah bits/br_iris
-xvbrowse.o:	bits/br_pcx bits/br_jfif bits/br_tiff bits/br_pds 
+xvbrowse.o:	bits/br_pcx bits/br_jfif bits/br_tiff bits/br_pds
 xvbrowse.o:	bits/br_ps bits/br_iff bits/br_targa bits/br_xpm
 xvbrowse.o:	bits/br_trash bits/fcurs bits/fccurs bits/fdcurs bits/fcursm
-xvbrowse.o:     bits/br_xwd
+xvbrowse.o:	bits/br_xwd
 
 xvbutt.o:	bits/cboard50 bits/rb_frame bits/rb_frame1 bits/rb_top
 xvbutt.o:	bits/rb_bot bits/rb_dtop bits/rb_dbot bits/rb_body
 xvbutt.o:	bits/rb_dot bits/cb_check bits/mb_chk
 
 xvctrl.o:	bits/gray25 bits/gray50 bits/i_fifo bits/i_chr bits/i_dir
-xvctrl.o: 	bits/i_blk bits/i_lnk bits/i_sock bits/i_exe bits/i_reg
+xvctrl.o:	bits/i_blk bits/i_lnk bits/i_sock bits/i_exe bits/i_reg
 xvctrl.o:	bits/h_rotl bits/h_rotr bits/fliph bits/flipv bits/p10
-xvctrl.o:	bits/m10 bits/cut bits/copy bits/paste bits/clear 
+xvctrl.o:	bits/m10 bits/cut bits/copy bits/paste bits/clear
 xvctrl.o:	bits/uicon bits/oicon1 bits/oicon2 bits/icon
 xvctrl.o:	bits/padimg bits/annot
 
@@ -285,13 +317,13 @@
 xvdflt.o:	bits/logo_top bits/logo_bot bits/logo_out bits/xv_jhb
 xvdflt.o:	bits/xv_cpyrt bits/xv_rev bits/xv_ver
 xvdflt.o:	bits/xf_left bits/xf_right bits/font5x9.h
-xvdflt.o:       xvdflt.h
+xvdflt.o:	xvdflt.h
 
 xvdial.o:	bits/dial_cw1 bits/dial_ccw1 bits/dial_cw2 bits/dial_ccw2
 
 xvdir.o:	bits/d_load bits/d_save
 
-xvevent.o:	bits/dropper bits/dropperm bits/pen bits/penm 
+xvevent.o:	bits/dropper bits/dropperm bits/pen bits/penm
 xvevent.o:	bits/blur bits/blurm
 
 xvgam.o:	bits/h_rotl bits/h_rotr bits/h_flip bits/h_sinc bits/h_sdec
diff -ruN xv-3.10a/Makefile.std xv-3.10a-bugfixes/Makefile.std
--- xv-3.10a/Makefile.std	1995-01-23 17:06:26.000000000 -0800
+++ xv-3.10a-bugfixes/Makefile.std	2005-04-06 08:17:13.000000000 -0700
@@ -2,7 +2,11 @@
 
 # your C compiler (and options) of choice
 CC = cc
-# CC = gcc -ansi
+#CC = gcc -ansi
+# note that -ansi kills __USE_MISC (gcc 2.95.3), which (at least in Linux)
+# determines whether stdlib.h includes prototypes for mktemp(), random(), etc.
+# (i.e., if you use it, you will get unnecessary compiler warnings)
+#CC = gcc
 
 # use this if you're using 'cc' on a DEC Alpha (OSF/1) or MIPS (Ultrix) system:
 # CC = cc -std1 -Olimit 750
@@ -14,8 +18,13 @@
 #       -Wuninitialized -Wparentheses
 
 
-CCOPTS = -O 
-
+CCOPTS = -O
+# these are the usual optimization and warning options for gcc; all such
+# warnings but one (mktemp() use) have been eliminated (at least on Linux):
+#CCOPTS = -O3 -Wall
+# for the next step up in gcc noise, try adding -W (but note that it adds a
+# huge number of unused-parameter and signed/unsigned comparison warnings):
+#CCOPTS = -O3 -Wall -W
 
 ### NOTE: Sun running OpenWindows:
 ### if you're using a SUN running OPENWINDOWS, you need to add these two
@@ -27,6 +36,10 @@
 ### '-I' options on the CCOPTS line to tell the compiler where said files are.
 
 
+# BeOS _may_ need to use a different version (below), but probably not
+CLEANDIR = cleandir
+
+
 ### Installation locations
 BINDIR = /usr/local/bin
 MANDIR = /usr/local/man/man1
@@ -38,7 +51,7 @@
 
 
 ########################### CONFIGURATION OPTIONS ############################
-### NOTE: be sure to check 'config.h', for a few other configuration options 
+### NOTE: be sure to check 'config.h', for a few other configuration options
 ##############################################################################
 
 ###
@@ -59,18 +72,25 @@
 ### if, for whatever reason, you're unable to get the TIFF library to compile
 ### on your machine, *COMMENT OUT* the following lines
 ###
-TIFF    = -DDOTIFF
+### GRR 20050319:  USE_TILED_TIFF_BOTLEFT_FIX enables an experimental fix for
+###   tiled TIFFs with ORIENTATION_BOTLEFT.  It may break other tiled TIFFs,
+###   or it may be required for certain other TIFF types (e.g., strips with
+###   ORIENTATION_BOTLEFT).  I don't have a sufficient variety of TIFF test
+###   images at hand.
+###
+#TIFF    = -DDOTIFF
+TIFF    = -DDOTIFF -DUSE_TILED_TIFF_BOTLEFT_FIX
 TIFFDIR = tiff
 TIFFINC = -I$(TIFFDIR)
 TIFFLIB = $(TIFFDIR)/libtiff.a
 $(TIFFLIB):
-	( cd $(TIFFDIR) ; make CC='$(CC)' )
+	( cd $(TIFFDIR) ; make CC='$(CC)' COPTS='$(CCOPTS) $(MCHN)' )
 
 
 ###
 ### if, for whatever reason, you're unable to get the PDS/VICAR support
 ### to compile (xvpds.c, and vdcomp.c), *COMMENT OUT* the following line,
-### and also remove 'vdcomp' from the 'all:' dependancy 
+### and also remove 'vdcomp' from the 'all:' dependancy
 ###
 PDS = -DDOPDS
 
@@ -78,17 +98,25 @@
 #----------System V----------
 
 # if you are running on a SysV-based machine, such as HP, Silicon Graphics,
-# Solaris, etc., uncomment the following line to get mostly there.  
+# Solaris, etc., uncomment the following line to get mostly there.
 #UNIX = -DSVR4
 
 
-#----------Machine Specific Configurations----------
+#----------Machine-Specific Configurations----------
+
+### If you are using a BeOS system, uncomment the following line
+#MCHN = -DUSE_GETCWD -I/usr/X11/include -L/usr/X11/lib
+###
+### The stock version of cleandir now should work for BeOS, too, so try
+### leaving this commented out:
+#CLEANDIR = cleandir.BeOS
+
 
 ### If you are using an SGI system, uncomment the following line
 #MCHN = -Dsgi
 
 
-### For HP-UX, uncomment the following line:
+### For HP-UX, uncomment the following line
 #MCHN= -Dhpux -D_HPUX_SOURCE
 # To use old HP compilers (HPUX 7.0 or so), you may need
 #MCHN= -Dhpux -D_HPUX_SOURCE +Ns4000
@@ -102,22 +130,22 @@
 
 
 ### for LINUX, uncomment the following line
-#MCHN = -DLINUX
+#MCHN = -DLINUX -L/usr/X11R6/lib
 
 
 # For SCO 1.1 (UNIX 3.2v2) machines, uncomment the following:
 #MCHN = -Dsco -DPOSIX
 #
 # For ODT 2.0 (UNIX 3.2v4) machines, uncomment the following:
-#MCHN= -Dsco -DPOSIX -DNO_RANDOM 
+#MCHN= -Dsco -DPOSIX -DNO_RANDOM
 #
 # Also, you should add '-lc -lx' to the end of the LIBS def below
 # -lx must be after -lc so you get the right directory routines.
 
 
 # for UMAX V by Encore Computers uncomment the following line for
-# the portable c compiler, system specific definitions and
-# location of local X11 library(if site specific, modify -L option)
+# the portable C compiler, system-specific definitions and
+# location of local X11 library (if site-specific, modify -L option)
 # No other switches should be necessary, or so I'm told...
 #
 #MCHN = -q extensions=pcc_c -D__UMAXV__ -L/usr2/usr/lib/X11 -DSVR4
@@ -147,8 +175,8 @@
 #TIMERS = -DUSLEEP
 
 
-# if XV locks up whenever you click on *any* of the buttons, the Timer() 
-# function in xvmisc.c is going out to lunch.  A simple workaround is to 
+# if XV locks up whenever you click on *any* of the buttons, the Timer()
+# function in xvmisc.c is going out to lunch.  A simple workaround is to
 # uncomment the following line:
 #TIMERS = -DNOTIMER
 
@@ -160,7 +188,7 @@
 #DXWM = -DDXWM
 
 
-# if, during compilation, your system complains about the types 
+# if, during compilation, your system complains about the types
 # 'u_long', 'u_short', 'u_int', etc. as being undefined, uncomment the
 # following line:
 #BSDTYPES = -DBSDTYPES
@@ -188,7 +216,9 @@
 	$(NODIRENT) $(VPRINTF) $(TIMERS) $(UNIX) $(BSDTYPES) $(RAND) \
 	$(DXWM) $(MCHN)
 
+### remove -lm for BeOS:
 LIBS = -lX11 $(JPEGLIB) $(TIFFLIB) -lm
+#LIBS = -lX11 $(JPEGLIB) $(TIFFLIB)
 
 OBJS = 	xv.o xvevent.o xvroot.o xvmisc.o xvimage.o xvcolor.o xvsmooth.o \
 	xv24to8.o xvgif.o xvpm.o xvinfo.o xvctrl.o xvscrl.o xvalg.o \
@@ -231,9 +261,10 @@
 
 clean:  xvclean
 	rm -f bggen vdcomp xcmap xvpictoppm
-	./cleandir $(JPEGDIR)
-	rm -f $(JPEGDIR)/jconfig.h $(JPEGDIR)/Makefile
-	./cleandir $(TIFFDIR)
+#	clean only local jpeg and tiff dirs, not user's or system's copies:
+	./$(CLEANDIR) jpeg
+	rm -f jpeg/jconfig.h jpeg/Makefile
+	./$(CLEANDIR) tiff
 
 
 install: all
@@ -246,8 +277,9 @@
 	cp docs/xvdocs.ps* $(LIBDIR)
 
 tar:
+#	tar only local jpeg and tiff dirs, not user's or system's copies:
 	tar cvf xv.tar Makefile* Imakefile *.c *.h bits \
-		docs unsupt vms $(JPEGDIR) $(TIFFDIR) $(MISC) 
+		docs unsupt vms jpeg tiff $(MISC)
 
 xvtar:
 	tar cvf xv.tar Makefile* Imakefile *.c *.h bits
@@ -257,26 +289,26 @@
 
 ################# bitmap dependencies ####################
 
-xv.o:      	bits/icon bits/iconmask bits/runicon bits/runiconm
-xv.o:      	bits/cboard50 bits/gray25 
+xv.o:		bits/icon bits/iconmask bits/runicon bits/runiconm
+xv.o:		bits/cboard50 bits/gray25
 
 xvbrowse.o:	bits/br_file bits/br_dir bits/br_exe bits/br_chr bits/br_blk
-xvbrowse.o:	bits/br_sock bits/br_fifo bits/br_error bits/br_unknown
+xvbrowse.o:	bits/br_sock bits/br_fifo bits/br_error # bits/br_unknown
 xvbrowse.o:	bits/br_cmpres bits/br_gif bits/br_pm bits/br_pbm
 xvbrowse.o:	bits/br_sunras bits/br_bmp bits/br_utah bits/br_iris
-xvbrowse.o:	bits/br_pcx bits/br_jfif bits/br_tiff bits/br_pds 
+xvbrowse.o:	bits/br_pcx bits/br_jfif bits/br_tiff bits/br_pds
 xvbrowse.o:	bits/br_ps bits/br_iff bits/br_targa bits/br_xpm
 xvbrowse.o:	bits/br_trash bits/fcurs bits/fccurs bits/fdcurs bits/fcursm
-xvbrowse.o:     bits/br_xwd
+xvbrowse.o:	bits/br_xwd
 
 xvbutt.o:	bits/cboard50 bits/rb_frame bits/rb_frame1 bits/rb_top
 xvbutt.o:	bits/rb_bot bits/rb_dtop bits/rb_dbot bits/rb_body
 xvbutt.o:	bits/rb_dot bits/cb_check bits/mb_chk
 
 xvctrl.o:	bits/gray25 bits/gray50 bits/i_fifo bits/i_chr bits/i_dir
-xvctrl.o: 	bits/i_blk bits/i_lnk bits/i_sock bits/i_exe bits/i_reg
+xvctrl.o:	bits/i_blk bits/i_lnk bits/i_sock bits/i_exe bits/i_reg
 xvctrl.o:	bits/h_rotl bits/h_rotr bits/fliph bits/flipv bits/p10
-xvctrl.o:	bits/m10 bits/cut bits/copy bits/paste bits/clear 
+xvctrl.o:	bits/m10 bits/cut bits/copy bits/paste bits/clear
 xvctrl.o:	bits/uicon bits/oicon1 bits/oicon2 bits/icon
 xvctrl.o:	bits/padimg bits/annot
 
@@ -285,13 +317,13 @@
 xvdflt.o:	bits/logo_top bits/logo_bot bits/logo_out bits/xv_jhb
 xvdflt.o:	bits/xv_cpyrt bits/xv_rev bits/xv_ver
 xvdflt.o:	bits/xf_left bits/xf_right bits/font5x9.h
-xvdflt.o:       xvdflt.h
+xvdflt.o:	xvdflt.h
 
 xvdial.o:	bits/dial_cw1 bits/dial_ccw1 bits/dial_cw2 bits/dial_ccw2
 
 xvdir.o:	bits/d_load bits/d_save
 
-xvevent.o:	bits/dropper bits/dropperm bits/pen bits/penm 
+xvevent.o:	bits/dropper bits/dropperm bits/pen bits/penm
 xvevent.o:	bits/blur bits/blurm
 
 xvgam.o:	bits/h_rotl bits/h_rotr bits/h_flip bits/h_sinc bits/h_sdec
diff -ruN xv-3.10a/README.jumbo xv-3.10a-bugfixes/README.jumbo
--- xv-3.10a/README.jumbo	1969-12-31 16:00:00.000000000 -0800
+++ xv-3.10a-bugfixes/README.jumbo	2005-04-10 19:55:23.000000000 -0700
@@ -0,0 +1,387 @@
+These are the latest versions of the XV jumbo patches I originally created
+in February 2000 (but never distributed) and eventually updated and released
+in May 2004, prompted by a discussion on LWN (http://lwn.net/Articles/76391/).
+Information about the patches, updates to the patches, and the patches
+themselves can all be found here:
+
+	http://pobox.com/~newt/greg_xv.html
+	http://freshmeat.net/projects/xvjumbopatches/
+
+(Use the "Subscribe to new releases" link on the latter page if you want to
+be notified of new versions automatically; trivial registration required.)
+
+These two patches incorporate all of the fix- and enhancement-patches
+available from John's XV site (http://www.trilon.com/xv/downloads.html
+and ftp://ftp.trilon.com/pub/xv/patches/), plus a number of my own fixes
+and additions, plus quite a few from other people--though not all of the
+ones I'd intended to (sorry, SJT, AT, and JPD!) due to lack of time after
+dealing with the latest security issue (which I discovered, sigh).  They're
+still not fully complete, and it's possible they never will be, but I do
+plan to continue working on them whenever the mood strikes--and I may even
+release them publicly on rare occasions.  (At the current rate, it looks
+like once a year may be the best we can hope for...we'll see.)
+
+Also be aware that several other people have had the same idea over the
+years.  Ones I've found, more or less by accident, include:
+
+ - Landon Curt "chongo" Noll (http://www.isthe.com/chongo/)
+   http://www.isthe.com/chongo/src/xv-patch/
+ - Mark Ashley <mark@ibiblio.org>
+   http://www.ibiblio.org/pub/packages/solaris/sparc/html/xv.3.10a.p19.html
+ - Peter Jordan <pete@dc.seflin.org>
+   http://www.ibiblio.org/pub/Linux/apps/graphics/viewers/X/xv-3.10a.patch.*
+ - Uwe F. Mayer (http://www.tux.org/~mayer/)
+   http://www.tux.org/~mayer/linux/book/node311.html
+ - Kurt Wall <kwall@kurtwerks.com>
+   http://www.kurtwerks.com/software/xv.html
+ - Chisato Yamauchi (http://phe.phyas.aichi-edu.ac.jp/~cyamauch/index_en.html)
+   http://phe.phyas.aichi-edu.ac.jp/~cyamauch/xv.html
+ - Daisuke Yabuki <dxy@optix.org>
+   http://www.optix.org/~dxy/solaris/xv/
+ - Pekoe (http://pekoe.lair.net/)
+   http://pekoe.lair.net/diary/xv.html
+ - FreeBSD FreshPorts
+   http://www.freshports.org/graphics/xv/
+ - <sudakyo@fat.coara.or.jp>
+   http://www.coara.or.jp/~sudakyo/XV_jp.html
+
+I very much doubt that this is an exhaustive list.  So far, most of the other
+patch-sets appear not to be quite as extensive or as up-to-date as my own,
+although the last three or four do include the [large] Japanese extension
+patches that I omitted--not because they're unworthy, but simply because I
+didn't find them until collisions between the two sets of patches had become
+a large problem.  (Maybe for the next release...  I'd intended to try for
+this release, but the security issues ended up taking almost all of my
+available time.  And, to be honest, from my perspective, inclusion of the
+jp-extension patches is more for completeness' sake than personal interest,
+so their priority is fairly low.)
+
+Below I summarize the component patches that are encompassed by my jumbo
+bugfixes and jumbo enhancements patches.  Unfortunately, some of my own
+additions never saw the light of day as standalone patches, but considering
+the number of overlaps (collisions) already implicit in this list, it would
+have been difficult to accomplish even if I'd had the time.  In any case,
+they're present in these jumbo patches but not chongo's, so those who _really_
+care can "subtract" the two sets of patches to see what I did.
+
+Here's a quick guide to the "third-party" credits in the lists below:
+
+  AAC = Andrey A. Chernov [ache]
+        (http://cvsweb.freebsd.org/ports/graphics/xv/files/patch-ab)
+  AD  = Andreas Dilger (adilger@clusterfs.com)
+  AL  = Alexander Lehmann (lehmann@usa.net)
+  AT  = Anthony Thyssen (http://www.cit.gu.edu.au/~anthony/)
+  DAC = David A. Clunie (http://www.dclunie.com/xv-pcd.html)
+  EK  = Egmont Koblinger (egmont@users.sourceforge.net)
+  GRR = Greg Roelofs (http://pobox.com/~newt/)
+  GV  = Guido Vollbeding (http://sylvana.net/guido/)
+  JCE = John C. Elliott (http://www.seasip.demon.co.uk/ZX/zxdload.html)
+  JHB = John H. Bradley, of course (http://www.trilon.com/xv/)
+  JPD = Jean-Pierre Demailly (http://www-fourier.ujf-grenoble.fr/~demailly/)
+  JR  = John Rochester (http://www.freebsd.org/cgi/query-pr.cgi?pr=2920)
+        (also http://cvsweb.freebsd.org/ports/graphics/xv/files/patch-af, -ag)
+  JZ  = Joe Zbiciak (http://spatula-city.org/~im14u2c/)
+  LCN = Landon Curt "chongo" Noll (http://www.isthe.com/chongo/)
+  PBJ = Peter Jordan (http://www.ibiblio.org/pub/Linux/apps/graphics/viewers/X/)
+  PSV = Pawel S. Veselov (http://manticore.2y.net/wbmp.html)
+  SB  = Sean Borman (http://www.nd.edu/~sborman/software/xvwheelmouse.html)
+  SJT = TenThumbs (tenthumbs@cybernex.net)
+  TA  = Tim Adye (http://hepwww.rl.ac.uk/Adye/xv-psnewstyle.html)
+
+Other credits are as listed on the XV Downloads page or in the respective
+patches (e.g., the jp-extension patches or within the PNG patch).
+
+Finally, please note that these patches have not been blessed by John Bradley
+in any way (although I copied him on the May 2004 announcement--no response).
+Nor have I personally tested every change and feature!  (See the BIG SCARY
+WARNING below for further caveats.)  In other words, they're both completely
+unofficial and completely unguaranteed.  But they seem to work for me.  (And
+when they don't, I fix 'em.  Eventually, anyway... ;-) )
+
+One further "final" note:  this may well be the last release to include
+separate fix- and enhancements-patches.  It is too much of a timesink to
+maintain parallel trees--not to mention parallel makefiles (generic/public
+vs. local/personal, old vs. new libjpeg/libtiff) and xv.h (unregistered/
+public vs. registered/personal), particularly when some fixes come about
+while working on an enhancement.  Henceforth--assuming, of course, that
+there _is_ a "henceforth"--I expect to merge the patches into a single
+jumbo patch.  (Alternatively, I may simply freeze the current fix-patch
+and continue to evolve only the enhancements patch; in particular, new
+fixes would appear only in it.  Either approach would be simple enough;
+feedback as to which would be preferable is welcomed.)
+
+GRR 20050410
+
+
+How to build
+------------
+
+The following assumes you, the user, already have the libtiff,[1]
+libjpeg,[2] libpng,[3] and zlib[4] libraries downloaded, patched (if
+necessary), compiled, and installed, not to mention a C compiler and
+the bzip2,[5] tar,[6] patch,[7] and make[8] utilities. You should also
+have downloaded the original XV 3.10a source distribution from the XV
+Downloads page[9] and be able to edit its Makefile and config.h files
+as indicated in the INSTALL file. Finally, you should know what a
+Unix(-style) command line is, where to find one, and how to wield it
+with abandon (or at least with adult supervision)--and preferably not
+as the root user until the make install step.  (A filesystem is a
+terrible thing to waste.)
+
+   [1] http://www.remotesensing.org/libtiff/
+   [2] http://www.ijg.org/
+   [3] http://www.libpng.org/pub/png/libpng.html
+   [4] http://www.zlib.net/
+   [5] http://sources.redhat.com/bzip2/
+   [6] http://www.gnu.org/directory/devel/specific/tar.html
+   [7] http://www.gnu.org/directory/devel/specific/patch.html
+   [8] http://www.gnu.org/directory/devel/specific/make.html
+   [9] http://www.trilon.com/xv/downloads.html#src-distrib
+
++-------------------------------------------------------------------------+
+|                                                                         |
+|                            BIG SCARY WARNING                            |
+|                                                                         |
+|  These patches work for Greg (and parts of them apparently work for     |
+|  various other people), and so far Greg's CPU still computes and his    |
+|  hard disks haven't been wiped.  But there's no guarantee that that     |
+|  will be the case for you! In particular, not every incorporated patch  |
+|  has been explicitly tested, nor has every possible subcase of the      |
+|  explicitly tested subset. (Read that again; it's grammatical.) Nor are |
+|  these patches officially blessed by John Bradley in any way. In other  |
+|  words, if you use these patches, you do so at your own risk. (Greg     |
+|  doesn't believe there are any serious problems remaining, but then,    |
+|  what programmer ever does? Bugs happen.)                               |
+|                                                                         |
++-------------------------------------------------------------------------+
+
+Assuming you have the prerequisites out of the way and aren't scared
+off by the Big Scary Warning, here's the build procedure:
+
+      bzip2 -dc xv-3.10a-jumbo-patches-20050410.tar.bz2 | tar xvf -
+      (or tar xvzf xv-3.10a-jumbo-patches-20050410.tar.gz) 
+
+      tar xvzf xv-3.10a.tar.gz 
+
+      cd xv-3.10a 
+
+      patch -p1 < ../xv-3.10a-jumbo-fix-patch-20050410.txt 
+
+      [optional] patch -p1 < ../xv-3.10a-jumbo-enh-patch-20050410.txt 
+
+      edit Makefile and config.h as directed in INSTALL file (in particular,
+      ensure paths to external libraries and header files are correct)
+
+      make 
+
+      ./xv your_favorite_image your_other_favorite_image etc. 
+
+If everything seems to be working to your satisfaction, go ahead and install: 
+
+      make -n install (and double-check that things will be installed
+      where you want them to be)
+
+      become root if necessary (e.g., type su)
+
+      make install 
+
+That wasn't so hard, was it? 
+
+
+Summary of incorporated and unincorporated patches
+--------------------------------------------------
+
+fixes ((*) = listed on XV Downloads page, (f) = on ftp site only):
+
+20040516:
+ - grabpatch (*)		[obsoleted by new-xvgrab.c below]
+ - vispatch (*)
+ - mp-tiff-patch (*)		[technically an enhancement, but JHB says...]
+ - longname.patch (*)		[*SECURITY*]
+ - xpm.patch (*)
+ - deepcolor.patch (*)		[slightly modified for language conformance]
+ - gifpatch (*)
+ - exceed_grab.patch (*)
+ - xv-redhat6-readme.txt (*)	[slightly modified for portability]
+ - beos.patch (*)		[modified for portability]
+ - croppad.patch (f)
+ - epsfpatch (f)
+ - tiff1200.patch (*)
+ - gssafer.patch (*)		[*SECURITY*]
+ - new-xvgrab.c (f)		[includes grabpatch but not exceed_grab.patch]
+ - xcmap.diff (AD)		[part of xv-3.10a-png-1.2d.tar.gz]
+ - fixes for huge number gcc -Wall warnings--including two bugs (GRR)
+ - fix for cleandir script when no makefile exists (GRR)
+ - *SECURITY* fix for gets() in vdcomp.c (GRR, LCN vdcomp-security.patch)
+ - *SECURITY* fix for getwd() on Linux (GRR, LCN Linux-compile.patch)
+ - fix for "no fuss" Linux compiles (LCN Linux-compile.patch)
+ - partial *SECURITY* fix for mktemp() in xv.c and xvdir.c (GRR)
+   (remaining instances in xv.c (2), xvimage.c, xvfits.c, xvpds.c, xvps.c, and
+   possibly xvtiff.c--most involve system())
+ - freebsd-vdcomp-newline.patch (AAC)
+ - xv-3.10a.patch.linux (PBJ)	[/bin/sh versions of cleandir, RANLIB.sh only]
+ - removed trailing white space (GRR)  [purely cosmetic]
+20050410:
+ - fix for YCbCr oversaturated-green bug(s) in TIFF decoder (GRR)
+ - provisional fix for contiguous tiled TIFFs with bottom-* orientation (GRR)
+ - fixes for gcc 3.3 -Wall warnings (GRR)
+ - fix for incorrect 16/24-bit display of xwd dumps (SJT)
+ - *SECURITY* fix for multiple input-validation bugs (OpenBSD/SuSE, Gentoo, GRR)
+   (this also completes the partial mktemp() security fix listed above)
+ - fix for (probable) 24-bit endianness bug in fixpix code (GRR)
+
+
+enhancements ((*) = listed on XV Downloads page, (<who>) = third-party):
+
+20040516:
+ - xv-3.10a.JPEG-patch (*)
+   (xv-3.10a.JPEG-patch.old differs only in ftp site listed in comments at top)
+ - xv-3.10a.TIFF-patch (*)
+ - xv-3.10a-png-1.2d.tar.gz (AL, AD) (*)
+   (xvjpeg.diff and xvtiff.diff ignored; xcmap.diff included in fixes)
+ - xvpng-1.2d-fix3.patch (GRR, SJT) (*)
+ - pdf.patch (*)
+ - windowid.patch + windowid.patch.readme (*)
+ - bmp32.patch (*)
+ - fixpix-20000610.tar.gz (GV)
+   (identical to 19961127 version except for README updates and new Win32 file)
+   [modified to be runtime-selectable via -/+fixpix option]
+ - browse-remember.patch (JZ)
+ - faster-smooth.patch (JZ)
+ - PAM support (GRR)
+ - PNG/GIF -ibg ("image background") transparency option (GRR)
+   (does not yet support TIFF, XPM or TGA)
+ - VersionInfo* in help screen (GRR)
+ - minor grammar/spelling fixes (GRR)
+ - floating-point support for -wait when USE_TICKS enabled (GRR)
+ - wheelmouse.patch (SB)
+ - freebsd-gravity-hints-patch (JR)
+ - xv-zx.patch (JCE)
+ - xv3.10a.wapbmp.patch (PSV)
+ - xv-3.10a-pcd.patch.20010708 (DAC)
+ - jp-ext-bzip2-1.1.patch
+   (from ftp://ftp.freebsd.org/pub/FreeBSD/ports/local-distfiles/shige/xv/)
+20050410:
+ - boosted maximum number of files from 4096 to 32768 (GRR)
+   (note that OS kernel limits may also apply; for example, in Linux see
+   MAX_ARG_PAGES in linux-<version>/include/linux/binfmts.h)
+ - xv-3.10a-bmp16.patch
+   (from http://www.coara.or.jp/~sudakyo/XV_jp.html)
+ - final-image delay (e.g., "-wait 0.2,3" : pause 3 secs on final image) (GRR)
+ - xv-numpad.patch (EK)
+ - xv-delete-is-not-backspace.patch (EK)
+ - made browser window (schnauzer) and icons configurable (AT, GRR)
+
+
+not (yet?) included:
+
+ - others from http://www.coara.or.jp/~sudakyo/XV_jp.html (some are duplicates):
+	-rw-r--r--      4644 Mar 11  2004 xv-3.10a-directory.patch
+	-rw-r--r--       462 Mar 11  2004 xv-3.10a-dirwkey.patch
+	-rw-r--r--       688 Mar 11  2004 xv-3.10a-docdir.patch
+	-rw-r--r--     11952 Mar 11  2004 xv-3.10a-download-test0.patch
+	-rw-r--r--     41786 Mar 11  2004 xv-3.10a-download-test1.patch
+	-rw-r--r--     42397 Mar 11  2004 xv-3.10a-download-test2.patch
+	-rw-r--r--     47679 Mar 11  2004 xv-3.10a-download-test3.patch
+	-rw-r--r--     52745 Mar 11  2004 xv-3.10a-download-test4.patch
+	-rw-r--r--       415 Mar 11  2004 xv-3.10a-formatstr.patch
+	-rw-r--r--      3423 Apr 24  2004 xv-3.10a-keyzoom.patch
+	-rw-r--r--      1461 Mar 11  2004 xv-3.10a-locale-linux.patch
+	-rw-r--r--     12387 Mar 15  2004 xv-3.10a-menubutton.patch
+	-rw-r--r--      1178 Apr 24  2004 xv-3.10a-noblink.patch
+	-rw-r--r--       484 Mar 11  2004 xv-3.10a-printkey.patch
+	-rw-r--r--     57092 Jul  9  2004 xv-3.10a-resolution.patch
+	-rw-r--r--      4645 Apr 24  2004 xv-3.10a-selall.patch
+	-rw-r--r--       360 Mar 11  2004 xv-3.10a-shortsleep.patch
+	-rw-r--r--       702 Apr 24  2004 xv-3.10a-showlongname.patch
+	-rw-r--r--      1205 Apr 24  2004 xv-3.10a-staytoppdir.patch
+	-rw-r--r--      1591 Mar 15  2004 xv-3.10a-sysconfdir.patch
+	-rw-r--r--      4228 Apr 24  2004 xv-3.10a-wheelmouse.patch
+	-rw-r--r--       744 Apr 24  2004 xv-3.10a-xvbutt_wait.patch
+	-rw-r--r--       712 Mar 11  2004 xv-3.10a-xvexecpath.patch
+	-rw-r--r--      3757 Jul  9  2004 xv-3.10a-xvscrl_button2.patch
+	-rw-r--r--      1494 Jul  9  2004 xv-3.10a-xvscrl_wait.patch
+	-rw-r--r--     19352 Jul  9  2004 xv-3.10a-xvzoom.patch
+	-rw-r--r--      1827 Apr 24  2004 xv-3.10a-zeroquit.patch
+
+ - xv310a-jp-extension-rev5.3.3.tar.gz		[extensive]
+ - xv-3.10a-jp-extension-5.3.3-png-1.2d.patch	[PNG patch relative to jp-ext]
+ - xv-3.10a+jp-extension-rev5.3.3+FLmask.v2.1+png+misc.patch	[??]
+
+ - xv-grab-imake-hips.patch (JPD)		[HIPS format, -startgrab option]
+ - xv-psnewstyle.patch (TA)			[coming later in 2005?]
+ - xv-3.10a.patch.linux (PBJ)			[maybe use vdcomp.c changes?]
+ - xvxpm-anthony-thyssen.c (AT)			["slate grey" bug already gone?]
+
+ - stuff in xv/unsupt:
+	-rw-r--r--     30527 Dec 22  1994 FITS.rite
+	-rw-r--r--     49152 Dec 22  1994 FITS.tar
+	-rw-r--r--      3753 Dec 22  1994 G3.patch1
+	-rw-r--r--     24576 Dec 22  1994 G3.tar
+	-rw-r--r--      1098 Dec 22  1994 INFO.cgm
+	-rw-r--r--      1941 Dec 22  1994 README
+	-rwxr-xr-x      1059 Dec 22  1994 getweather
+	-rwxr-xr-x      2186 Dec 22  1994 getweather.ksh
+	-rw-r--r--       856 Dec 22  1994 twm.fix
+	-rw-r--r--       844 Dec 22  1994 vargs.c
+	-rw-r--r--     47626 Dec 22  1994 vis
+	-rw-r--r--     21097 Dec 22  1994 xscm
+
+
+
+not finished (and/or even started ;-) ):
+
+ - fix xvpng.c not to use direct struct access
+ - fix for never-ending pile of SLOW popups when viewing TIFFs with unknown tags
+   (or truncated/corrupted images)
+ - fix for minor .Z inefficiency in xv.c ("FIXME")
+ - fix for filename entry-field mouse/cursor bogosity
+   (want at least positioning to work; preferably also select/cut/paste)
+ - fix for spacebar-for-next-image getting stuck at first text file
+ - fix for .ppm.gz "disk leak" [can't reproduce...already fixed?]
+   (maybe occurs only if filesystem is already nearly full?  bad .gz?)
+
+ - transparency support for TIFF, XPM and TGA images
+ - support for tiled background image (with transparent foreground image)
+ - MNG/JNG support
+
+
+ChangeLog
+---------
+
+  20000220
+    original pair of jumbo patches, comprising perhaps 16 fix-patches and a
+    dozen enhancement-patches; never publicly released 
+
+  20040516
+    first public release, incorporating 25 fix-patches and 21 enhancement-
+    patches
+
+  20040523
+    minor fix to xvctrl.c to support registered versions (GRR warnings-patch
+    was slightly overzealous); switched to tarball packaging
+
+  20040531
+    fixed undefined CLK_TCK with gcc -ansi (enh/USE_TICKS option); made
+    libjpeg, libtiff, libpng and zlib sections of makefile more consistent
+    (enh);
+
+  20040606
+    added freshmeat link, build instructions, and changelog to jumbo README
+    (this file)
+
+  20050213
+    increased max number of files from 4096 to 32768 (enh)
+
+  20050320-20050410
+    fixed two very long-standing YCbCr bugs in TIFF decoder (fix);
+    provisionally fixed bug in TIFF decoder for contiguous tiled TIFFs with
+    bottom-* orientation (fix/USE_TILED_TIFF_BOTLEFT_FIX option); fixed new
+    gcc 3.3 warnings (fix); fixed incorrect 16/24-bit display of xwd dumps
+    (fix); fixed multiple input-validation bugs (potential heap overflows)
+    and mktemp() dependencies (*SECURITY* fixes:  CAN-2004-1725, CAN-2004-
+    1726, CAN-2005-0665, CERT VU#622622, and others); added support for 16-
+    and 32-bit BMPs using bitfields "compression" (enh); fixed probable byte-
+    sex bug in 24-bit FixPix display code (enh/USE_24BIT_ENDIAN_FIX option);
+    fixed numerical-keypad NumLock behavior and delete-key behavior in file-
+    load/save window (enh); made schnauzer window and icons configurable (enh)
diff -ruN xv-3.10a/bggen.c xv-3.10a-bugfixes/bggen.c
--- xv-3.10a/bggen.c	1994-12-22 14:34:41.000000000 -0800
+++ xv-3.10a-bugfixes/bggen.c	2004-05-16 17:50:52.000000000 -0700
@@ -18,6 +18,11 @@
 #include <stdio.h>
 #include <math.h>
 
+#ifdef __STDC__
+#  include <stdlib.h>	/* atoi() */
+#  include <ctype.h>	/* isdigit() */
+#endif
+
 #ifndef M_PI
 #  define M_PI       3.1415926535897932385
 #endif
@@ -46,8 +51,8 @@
 
 typedef unsigned char byte;
 
-struct   color { int   r,g,b; 
-		 int   y; 
+struct   color { int   r,g,b;
+		 int   y;
 	       } colors[MAXCOLS], *cur, *nex;
 
 int      numcols;
@@ -62,7 +67,7 @@
 double computeDist PARM((int, int, int, int, int));
 void   writePPM    PARM((byte *, int, int, int));
 
-     
+
 /*************************************/
 int main(argc,argv)
      int    argc;
@@ -80,18 +85,18 @@
   char *geom    = NULL;
   char *rptgeom = NULL;
 
-  
+
 #ifdef VMS
   getredirection(&argc, &argv);
 #endif
-  
+
 
   for (i=1; i<argc; i++) {
     if (!strncmp(argv[i],"-d",(size_t) 2)) {         /* -d disp */
       i++;  if (i<argc) dname = argv[i];
     }
   }
-    
+
   if ((theDisp = XOpenDisplay(dname)) == NULL) {
     fprintf(stderr,"bggen:  Warning - can't open display, screen %s",
 	    "size unknown, color names not accepted.\n");
@@ -99,41 +104,41 @@
 
 
   cnt = 0;  numcols = 0;
-  
+
   /* parse cmd-line args */
   for (i=1; i<argc; i++) {
     if (!strcmp(argv[i],"-h")) {                          /* -h high */
       i++;  if (i<argc) high = atoi(argv[i]);
       hset++;
     }
-    
+
     else if (!strcmp(argv[i],"-w")) {                     /* -w wide */
       i++;  if (i<argc) wide = atoi(argv[i]);
       wset++;
     }
-    
+
     else if (!strcmp(argv[i],"-b")) {                     /* -b bits */
       i++;  if (i<argc) bits = atoi(argv[i]);
     }
-    
+
     else if (!strncmp(argv[i],"-g",(size_t) 2)) {         /* -g geom */
       i++;  if (i<argc) geom = argv[i];
     }
-    
+
     else if (!strncmp(argv[i],"-d",(size_t) 2)) {         /* -d disp */
       i++;  if (i<argc) dname = argv[i];
     }
-    
+
     else if (!strcmp(argv[i],"-G")) {                      /* -G rptgeom */
       i++;  if (i<argc) rptgeom = argv[i];
     }
-    
+
     else if (!strncmp(argv[i],"-a",(size_t) 2)) doascii++;  /* -a */
-    
+
     else if (!strcmp(argv[i],"-r")) {                     /* -r rot */
       i++;  if (i<argc) rot = atoi(argv[i]);
     }
-    
+
     else if (argv[i][0]=='-') usage();    /* any other '-' option is unknown */
 
     else if (isdigit(argv[i][0])) {
@@ -143,7 +148,7 @@
       case 2:  colors[numcols].b = atoi(argv[i]);  break;
       }
       cnt++;
-      
+
       if (cnt==3) {
 	if (numcols<MAXCOLS) numcols++;
 	cnt = 0;
@@ -176,50 +181,50 @@
       }
     }
   }
-  
-  
-  
+
+
+
   /* print error/usage message, if appropriate */
   if (cnt || numcols==0 || high<1 || wide<1 || bits<1 || bits>8) usage();
-  
-  
+
+
   if (geom) {
     int x,y;  unsigned int w,h;
     i = XParseGeometry(geom, &x, &y, &w, &h);
     if (i&WidthValue)  { wset++;  wide = (int) w; }
     if (i&HeightValue) { hset++;  high = (int) h; }
   }
-  
-  
+
+
   /* attempt to connect to X server and get screen dimensions */
   if (theDisp) {
     i = DefaultScreen(theDisp);
     if (!wset) wide = DisplayWidth(theDisp, i);
     if (!hset) high = DisplayHeight(theDisp, i);
   }
-  
-  
+
+
   /* normalize 'rot' */
   while (rot<   0) rot += 360;
   while (rot>=360) rot -= 360;
-  
-  
+
+
   rptwide = wide;  rpthigh = high;
   if (rptgeom) {
     int x,y;  unsigned int w,h;
     i = XParseGeometry(rptgeom, &x, &y, &w, &h);
     if (i&WidthValue)  rptwide = (int) w;
     if (i&HeightValue) rpthigh = (int) h;
-    
+
     RANGE(rptwide, 1, wide);
     RANGE(rpthigh, 1, high);
   }
-  
-  
 
-  
+
+
+
   rpic24 = (byte *) malloc(rptwide * rpthigh * 3 * sizeof(byte));
-  if (rptwide != wide || rpthigh != high) 
+  if (rptwide != wide || rpthigh != high)
     pic24  = (byte *) malloc(wide * high * 3 * sizeof(byte));
   else pic24 = rpic24;
 
@@ -229,7 +234,7 @@
     exit(1);
   }
   for (i=0, pp=pic24; i<wide*high*3; i++) *pp++ = 0;
-  
+
 
 
   /*** generate image ***/
@@ -244,34 +249,34 @@
       }
     }
   }
-  
-  
+
+
   else if (rot==0) {   /* un-rotated linear (vertical) gradient */
     for (i=0; i<numcols; i++)
       colors[i].y = ((rpthigh-1) * i) / (numcols-1);
-    
+
     cur = &colors[0];  nex = cur+1;
-    
+
     for (i=0; i<rpthigh; i++) {
       pp = rpic24 + (i * rptwide * 3);
 
       /* advance to next pair of colors if we're outside region */
       while (nex->y < i) { cur++; nex++; }
-      
+
       r = cur->r + ((nex->r - cur->r) * (i - cur->y)) / (nex->y - cur->y);
       g = cur->g + ((nex->g - cur->g) * (i - cur->y)) / (nex->y - cur->y);
       b = cur->b + ((nex->b - cur->b) * (i - cur->y)) / (nex->y - cur->y);
-      
+
       r = r & bmask[bits-1];
       g = g & bmask[bits-1];
       b = b & bmask[bits-1];
-      
+
       for (j=0; j<rptwide; j++) {
 	*pp++ = (byte) r;  *pp++ = (byte) g;  *pp++ = (byte) b;
       }
     }
   }
-  
+
   else dorot(rpic24, rptwide, rpthigh, rot);
 
 
@@ -293,7 +298,7 @@
 	y = ((i-ay) % rpthigh);
 
 	sp = rpic24 + (y * rptwide + x) * 3;
-	
+
 	pp[0] = *sp++;  pp[1] = *sp++;  pp[2] = *sp++;
       }
     }
@@ -355,12 +360,12 @@
     mind = computeDist(w-1,  0,    cx, cy, rot);
     maxd = computeDist(0,    h-1,  cx, cy, rot);
   }
-  
+
   del = maxd - mind;         /* maximum distance */
-  
+
   distdebug = 0;
-  
-  
+
+
   for (y=0; y<h; y++) {
     pp = pic + (y * w * 3);
     for (x=0; x<w; x++) {
@@ -368,11 +373,11 @@
       rat = (d - mind) / del;
       if (rat<0.0) rat = 0.0;
       if (rat>1.0) rat = 1.0;
-      
+
       cval = rat * nc1;
       bc   = floor(cval);
       crat = cval - bc;
-      
+
       if (bc < nc1) {
 	r = colors[bc].r + crat * (colors[bc+1].r - colors[bc].r);
 	g = colors[bc].g + crat * (colors[bc+1].g - colors[bc].g);
@@ -383,7 +388,7 @@
 	g = colors[nc1].g;
 	b = colors[nc1].b;
       }
-      
+
       *pp++ = (byte) r;  *pp++ = (byte) g;  *pp++ = (byte) b;
     }
   }
@@ -395,9 +400,9 @@
      int x,y,cx,cy,rot;
 {
   /* rot has to be in range 0-359 */
-  
-  double x1, y1, x2, y2, x3, y3, d, d1, b, theta;
-  
+
+  double x1, y1, x2, y2, x3, y3, d, d1, b;
+
   if (rot == 0)   return (double) (y - cy);
   if (rot == 180) return (double) (cy - y);
 
@@ -407,7 +412,7 @@
   /* x2,y2 = vertical projection onto a || line that runs through cx,cy */
   x2 = x1;
   y2 = cy - (cx-x2)*tant1;
-  
+
   d1 = y2 - y1;  /* vertical distance between lines */
   b  = d1 * cost1;
 
@@ -435,11 +440,11 @@
      int   w,h,doascii;
 {
   /* dumps a pic24 in PPM format to stdout */
-  
+
   int x,y;
-  
+
   printf("P%s %d %d 255\n", (doascii) ? "3" : "6", w, h);
-  
+
   for (y=0; y<h; y++) {
     if (doascii) {
       for (x=0; x<w; x++, pic+=3)
diff -ruN xv-3.10a/bits/icon xv-3.10a-bugfixes/bits/icon
--- xv-3.10a/bits/icon	1994-12-22 14:35:28.000000000 -0800
+++ xv-3.10a-bugfixes/bits/icon	2004-04-28 00:53:10.000000000 -0700
@@ -1,5 +1,6 @@
 #define icon_width 40
 #define icon_height 32
+#ifndef OMIT_ICON_BITS
 static unsigned char icon_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c,
@@ -15,3 +16,4 @@
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00};
+#endif
diff -ruN xv-3.10a/cleandir xv-3.10a-bugfixes/cleandir
--- xv-3.10a/cleandir	1994-12-22 14:34:50.000000000 -0800
+++ xv-3.10a-bugfixes/cleandir	2004-05-10 23:19:16.000000000 -0700
@@ -1,9 +1,13 @@
-#!/bin/csh -f
+#!/bin/sh -f
 # cleandir: if called with an argument, cd's there and does a 'make clean'
 #
 
-if ( x$1 != x ) then
-  echo "cleaning $1 subdirectory"
-  cd $1
-  make clean
-endif
+if [ x"$1" != x ]; then
+  if [ -f "$1"/makefile -o -f "$1"/Makefile ]; then
+    echo "cleaning '$1' subdirectory"
+    cd "$1"
+    make clean
+# else
+#   echo "no makefile found; NOT cleaning '$1' subdirectory"
+  fi
+fi
diff -ruN xv-3.10a/config.h xv-3.10a-bugfixes/config.h
--- xv-3.10a/config.h	1995-01-05 10:49:21.000000000 -0800
+++ xv-3.10a-bugfixes/config.h	2005-03-21 23:21:31.000000000 -0800
@@ -8,9 +8,9 @@
  *
  * if you have the gnu uncompression utility 'gunzip', XV can use it to
  * automatically 'unzip' any gzip'd files.  To enable this feature,
- * change 'undef' to 'define' in the following line.  Needless to say, if 
+ * change 'undef' to 'define' in the following line.  Needless to say, if
  * your gunzip is installed elsewhere on your machine, change the 'GUNZIP'
- * definition appropriately. (use 'which gunzip' to find if you have gunzip, 
+ * definition appropriately. (use 'which gunzip' to find if you have gunzip,
  * and where it lives)
  */
 #undef USE_GUNZIP
@@ -19,7 +19,8 @@
 #  ifdef VMS
 #    define GUNZIP "UNCOMPRESS"
 #  else
-#    define GUNZIP "/usr/local/bin/gunzip -q"
+/*   define GUNZIP "/usr/local/bin/gunzip -q"  */
+#    define GUNZIP "/usr/bin/gzip -dq"   /* more portable */
 #  endif
 #endif
 
@@ -70,18 +71,18 @@
  * PostScript file input support:
  *
  * if you have the 'ghostscript' package installed (version 2.6 or later),
- * XV can use it to read and display PostScript files.  To do so, 
+ * XV can use it to read and display PostScript files.  To do so,
  * uncomment the '#define GS_PATH' line, below.  You probably will not
  * need to modify the GS_LIB or GS_DEV lines, but if you do modify them,
  * be sure to uncomment them, as well.
  *
- * the ghostscript package can be acquired via anonymous ftp on 
+ * the ghostscript package can be acquired via anonymous ftp on
  * prep.ai.mit.edu, in the 'pub/gnu' directory
  *
- * GS_PATH specifies the complete path to your gs executable.  
+ * GS_PATH specifies the complete path to your gs executable.
  *
- * GS_LIB should be set if there's some other gs libs that should be 
- * searched, but aren't by default.  (In which case you should probably 
+ * GS_LIB should be set if there's some other gs libs that should be
+ * searched, but aren't by default.  (In which case you should probably
  * just fix your 'gs' so it looks in the right places without being told...)
  *
  * GS_DEV is the file format that ghostscript will convert PS into.  It
@@ -97,7 +98,7 @@
  * 'old-style' XV logo image:
  *
  * XV now has a nifty, new logo image.  The downside is that it increases
- * the size of the 'xv' executable by 250K or so, and it's possible that 
+ * the size of the 'xv' executable by 250K or so, and it's possible that
  * your compiler may choke while compiling 'xvdflt.c'.  If you're compiler
  * can't handle it, or you're running Linux on a system with minimal memory,
  * change 'undef' to 'define' in the following line
@@ -108,8 +109,8 @@
 
 /***************************************************************************
  * Backing Store:
- * 
- * XV can request that 'Backing Store' may be turned on ('WhenMapped') for 
+ *
+ * XV can request that 'Backing Store' may be turned on ('WhenMapped') for
  * several of its windows, which may help performance over a slow network
  * connection.  However, it has been known to behave strangely (or crash)
  * on some X servers, so it's left here as an option.  If you run into trouble
diff -ruN xv-3.10a/copyright.h xv-3.10a-bugfixes/copyright.h
--- xv-3.10a/copyright.h	1994-12-22 14:34:56.000000000 -0800
+++ xv-3.10a-bugfixes/copyright.h	2004-05-16 17:53:11.000000000 -0700
@@ -1,11 +1,11 @@
 /* Copyright Notice
  * ================
  * Copyright 1989, 1994 by John Bradley
- * 
- * Permission to copy and distribute XV in its entirety, for non-commercial 
- * purposes, is hereby granted without fee, provided that this license 
+ *
+ * Permission to copy and distribute XV in its entirety, for non-commercial
+ * purposes, is hereby granted without fee, provided that this license
  * information and copyright notice appear unmodified in all copies.
- * 
+ *
  * Note that distributing XV 'bundled' in with any product is considered
  * to be a 'commercial purpose'.
  *
@@ -13,16 +13,16 @@
  * and/or configured to be in their 'unregistered copy' mode, so that it
  * is made obvious to the user that XV is shareware, and that they should
  * consider donating, or at least reading this License Info.
- * 
+ *
  * The software may be modified for your own purposes, but modified
  * versions may not be distributed without prior consent of the author.
- * 
+ *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the author be held liable for any damages
  * arising from the use of this software.
- * 
+ *
  * If you would like to do something with XV that this copyright
- * prohibits (such as distributing it with a commercial product, 
+ * prohibits (such as distributing it with a commercial product,
  * using portions of the source in some other program, etc.), please
  * contact the author (preferably via email).  Arrangements can
  * probably be worked out.
@@ -34,13 +34,13 @@
  * larger donations are quite welcome.  Folks who donate $25 or more
  * can receive a Real Nice bound copy of the XV manual for no extra
  * charge.
- * 
+ *
  * Commercial, government, and institutional users must register their
  * copies of XV, for the price of $25 per workstation/X terminal or per
  * XV user, whichever is less.  Note that it does NOT say 'simultaneous user',
- * but rather, the total number of people who use XV on any sort of 
- * recurring basis. Site licenses are available (and recommended) for those 
- * who wish to run XV on a large (>10) number of machines.  
+ * but rather, the total number of people who use XV on any sort of
+ * recurring basis. Site licenses are available (and recommended) for those
+ * who wish to run XV on a large (>10) number of machines.
  * Contact the author for more details.
  *
  * The author may be contacted via:
diff -ruN xv-3.10a/tiff/Makefile xv-3.10a-bugfixes/tiff/Makefile
--- xv-3.10a/tiff/Makefile	1994-12-22 14:35:12.000000000 -0800
+++ xv-3.10a-bugfixes/tiff/Makefile	2004-05-16 18:49:11.000000000 -0700
@@ -30,8 +30,10 @@
 # OF THIS SOFTWARE.
 #
 
-AR=     ar
-RANLIB=	./RANLIB.csh
+AR=	ar
+CHMOD=	chmod
+#RANLIB=	./RANLIB.csh
+RANLIB=	./RANLIB.sh
 
 IPATH= -I.
 
@@ -60,6 +62,7 @@
 
 ${ALL}:	${OBJS}
 	${AR} rc libtiff.a $?
+	${CHMOD} +x ${RANLIB}
 	${RANLIB} libtiff.a
 
 ${OBJS}:	tiffio.h tiff.h tiffcomp.h tiffiop.h tiffconf.h
diff -ruN xv-3.10a/tiff/Makefile.std xv-3.10a-bugfixes/tiff/Makefile.std
--- xv-3.10a/tiff/Makefile.std	1994-12-22 14:35:16.000000000 -0800
+++ xv-3.10a-bugfixes/tiff/Makefile.std	2004-05-16 18:50:39.000000000 -0700
@@ -30,8 +30,10 @@
 # OF THIS SOFTWARE.
 #
 
-AR=     /bin/ar
-RANLIB=	./RANLIB.csh
+AR=	/bin/ar
+CHMOD=	chmod
+#RANLIB=	./RANLIB.csh
+RANLIB=	./RANLIB.sh
 
 IPATH= -I.
 
@@ -60,6 +62,7 @@
 
 ${ALL}:	${OBJS}
 	${AR} rc libtiff.a $?
+	${CHMOD} +x ${RANLIB}
 	${RANLIB} libtiff.a
 
 ${OBJS}:	tiffio.h tiff.h tiffcomp.h tiffiop.h tiffconf.h
diff -ruN xv-3.10a/tiff/RANLIB.sh xv-3.10a-bugfixes/tiff/RANLIB.sh
--- xv-3.10a/tiff/RANLIB.sh	1969-12-31 16:00:00.000000000 -0800
+++ xv-3.10a-bugfixes/tiff/RANLIB.sh	2004-05-10 23:31:38.000000000 -0700
@@ -0,0 +1,22 @@
+#!/bin/sh -f
+#
+# tests to see if the program 'ranlib' exists.  If it does, runs ranlib on
+# the first argument (a library name).  Otherwise, does nothing, and returns
+#
+# written by John Bradley for the XV 3.00 release
+# thanks to John Hagan for shell-script hackery
+#
+
+echo "executing 'ranlib $1'..."
+
+# Is there a ranlib?  Let's try and then suffer the consequences...
+ranlib $1 >& /dev/null
+
+if [ $? -ne 0  ]; then
+	echo "There doesn't seem to be a ranlib on this system..."
+	echo "Don't worry about it."
+fi
+
+echo ""
+echo ""
+
diff -ruN xv-3.10a/vdcomp.c xv-3.10a-bugfixes/vdcomp.c
--- xv-3.10a/vdcomp.c	1994-12-22 14:34:47.000000000 -0800
+++ xv-3.10a-bugfixes/vdcomp.c	2005-03-20 17:48:59.000000000 -0800
@@ -5,8 +5,8 @@
 /*  Decompresses images using Kris Becker's subroutine DECOMP.C     */
 /*  which is included in this program in a shortened version.       */
 /*                                                                  */
-/*  Reads a variable length compressed PDS image and outputs a      */
-/*  fixed length uncompressed image file in PDS format with         */
+/*  Reads a variable-length compressed PDS image and outputs a      */
+/*  fixed-length uncompressed image file in PDS format with         */
 /*  labels, image histogram, engineering table, line header table   */
 /*  and an image with PDS, FITS, VICAR or no labels.  If used on    */
 /*  a non-byte-swapped machine the image histogram is un-swapped.   */
@@ -108,7 +108,9 @@
      !defined(bsd43)                     && \
      !defined(aux)                       && \
      !defined(__bsdi__)                  && \
-     !defined(sequent)
+     !defined(sequent)                   && \
+     !defined(__FreeBSD__)               && \
+     !defined(__OpenBSD__)
 
 #  if defined(hp300) || defined(hp800) || defined(NeXT)
 #   include <sys/malloc.h>                /* it's in 'sys' on HPs and NeXT */
@@ -121,15 +123,17 @@
 
 #include <X11/Xos.h>
 
-#define TRUE                  1
-#define FALSE                 0
+#define TRUE         1
+#define FALSE        0
 
-                                    /* pc i/o defines               */
-#define O_BINARY         0x8000     /* file mode is binary          */
+#define NAMELEN      1024           /* inname and outname sizes     */
 
-                                    /* vax i/o defines              */
-#define RECORD_TYPE      "rfm=fix"  /* VAX fixed length output      */
-#define CTX              "ctx=bin"  /* no translation of \n         */
+                                    /* PC I/O defines               */
+#define O_BINARY     0x8000         /* file mode is binary          */
+
+                                    /* VAX/VMS I/O defines          */
+#define RECORD_TYPE  "rfm=fix"      /* VAX/VMS fixed-length output  */
+#define CTX          "ctx=bin"      /* no translation of \n         */
 #define FOP          "fop=cif,sup"  /* file processing ops          */
 
 typedef struct leaf { struct leaf *right;
@@ -176,7 +180,7 @@
 
 int                infile;
 FILE               *outfile;
-char               inname[1024],outname[1024];
+char               inname[NAMELEN], outname[NAMELEN];
 int                output_format;
 int                record_bytes, max_lines;
 int                line_samples, fits_pad;
@@ -185,8 +189,8 @@
 
 /*************************************************/
 int main(argc,argv)
-     int  argc;
-     char **argv;
+  int  argc;
+  char **argv;
 {
   unsigned char ibuf[2048],obuf[2048];
   unsigned char blank=32;
@@ -200,12 +204,12 @@
   /*                                                                   */
   /*********************************************************************/
 
-  strcpy(inname,"   ");  
+  strcpy(inname,"   ");
   strcpy(outname,"   ");
   output_format = 0;
 
   if (argc == 1);                     /* prompt user for parameters */
-  else if (argc == 2 && (strncmp(argv[1],"help",(size_t) 4) == 0 || 
+  else if (argc == 2 && (strncmp(argv[1],"help",(size_t) 4) == 0 ||
 			 strncmp(argv[1],"HELP",(size_t) 4) == 0 ||
 			 strncmp(argv[1],"?",   (size_t) 1) == 0)) {
     fprintf(stderr,
@@ -214,18 +218,22 @@
     fprintf(stderr,"   infile        - name of compressed image file. \n");
     fprintf(stderr,"   outfile       - name of uncompressed output file.\n");
     fprintf(stderr,"   output format - selected from the following list:\n");
-    fprintf(stderr,"\n");   
-    fprintf(stderr,"     1  SFDU/PDS format [DEFAULT].\n");   
-    fprintf(stderr,"     2  FITS format.              \n");   
-    fprintf(stderr,"     3  VICAR format.             \n");   
-    fprintf(stderr,"     4  Unlabelled binary array.  \n\n");   
+    fprintf(stderr,"\n");
+    fprintf(stderr,"     1  SFDU/PDS format [DEFAULT].\n");
+    fprintf(stderr,"     2  FITS format.              \n");
+    fprintf(stderr,"     3  VICAR format.             \n");
+    fprintf(stderr,"     4  Unlabelled binary array.  \n\n");
     exit(1);
-  }  
+  }
   else {
-    strcpy(inname,argv[1]);  
-    if (argc >= 3) strcpy(outname,argv[2]); 
+    strncpy(inname, argv[1], sizeof(inname)-1);
+    inname[sizeof(inname)-1] = '\0';
+    if (argc >= 3) {
+      strncpy(outname, argv[2], sizeof(outname)-1);
+      outname[sizeof(outname)-1] = '\0';
+    }
     if (argc == 3) output_format = 1;
-    if (argc == 4) sscanf(argv[3],"%d",&output_format); 
+    if (argc == 4) sscanf(argv[3],"%d",&output_format);
   }
 
   host = check_host();
@@ -244,13 +252,13 @@
     case 4: no_labels(host);     break;
   }
 
-  if (record_bytes == 836) {  /* set up values for image sizes */ 
+  if (record_bytes == 836) {  /* set up values for image sizes */
     max_lines    =  800;
     fits_pad     = 2240;
     line_samples =  800;
   }
   else {
-    max_lines    = 1056;         
+    max_lines    = 1056;
     fits_pad     = 1536;
     line_samples = 1204;
   }
@@ -394,12 +402,12 @@
     if (record_bytes == 1204) /* do checksum for viking */
       for (i=0; i<record_bytes; i++) checksum += (int)obuf[i];
 
-    if ((line % 100 == 0) && (outfile != stdout)) 
+    if ((line % 100 == 0) && (outfile != stdout))
       fprintf(stderr,"\nline %d",line);
 
   } while (length > 0 && line < max_lines);
 
-  if (record_bytes == 1204  && (outfile  != stdout)) 
+  if (record_bytes == 1204  && (outfile  != stdout))
     /* print checksum for viking */
     fprintf(stderr,"\n Image label checksum = %d computed checksum = %d\n",
 	    label_checksum,checksum);
@@ -425,33 +433,36 @@
 /*********************************************************************/
 
 int get_files(host)
-int host;
+  int host;
 {
-  short   shortint;
   typedef long    off_t;
+  short   shortint;
+  char    *s;
 
   if (inname[0] == ' ') {
     printf("\nEnter name of file to be decompressed: ");
-    gets (inname);
+    fgets(inname, sizeof(inname), stdin);
+    if ((s = strchr(inname, '\n')) != NULL)
+      *s = '\0';
   }
 
-  if (host == 1 | host == 2) {
-    if ((infile = open(inname,O_RDONLY | O_BINARY)) <= 0) {
-      fprintf(stderr,"\ncan't open input file: %s\n",inname);
+  if (host == 1 || host == 2) {
+    if ((infile = open(inname, O_RDONLY | O_BINARY)) <= 0) {
+      fprintf(stderr,"\ncan't open input file: %s\n", inname);
       exit(1);
     }
   }
-  else if (host == 3 | host == 5) {
-    if ((infile = open(inname,O_RDONLY)) <= 0) {
-      fprintf(stderr,"\ncan't open input file: %s\n",inname);
+  else if (host == 3 || host == 5) {
+    if ((infile = open(inname, O_RDONLY)) <= 0) {
+      fprintf(stderr,"\ncan't open input file: %s\n", inname);
       exit(1);
     }
 
     /****************************************************************/
-    /* If we are on a vax see if the file is in var length format.  */
-    /* This logic is in here in case the vax file has been stored   */
+    /* If we are on a VAX see if the file is in var length format.  */
+    /* This logic is in here in case the VAX file has been stored   */
     /* in fixed or undefined format.  This might be necessary since */
-    /* vax variable length files can't be moved to other computer   */
+    /* VAX variable-length files can't be moved to other computer   */
     /* systems with standard comm programs (kermit, for example).   */
     /****************************************************************/
 
@@ -459,9 +470,9 @@
        read(infile,&shortint, (size_t) 2);
        if (shortint > 0 && shortint < 80) {
 	 host = 4;              /* change host to 4                */
-	 printf("This is not a VAX variable length file.");
+	 printf("This is not a VAX variable-length file.");
        }
-       else printf("This is a VAX variable length file.");
+       else printf("This is a VAX variable-length file.");
        lseek(infile,(off_t) 0,0);     /* reposition to beginning of file */
      }
   }
@@ -474,13 +485,17 @@
       printf("\n  3.  VICAR format.");
       printf("\n  4.  Unlabelled binary array.\n");
       printf("\n  Enter format number:");
-      gets(inname);
+      fgets(inname, sizeof(inname), stdin);
+      if ((s = strchr(inname, '\n')) != NULL)
+        *s = '\0';
       output_format = atoi(inname);
     } while (output_format < 1 || output_format > 4);
 
   if (outname[0] == ' ') {
     printf("\nEnter name of uncompressed output file: ");
-    gets (outname);
+    fgets(outname, sizeof(outname), stdin);
+    if ((s = strchr(outname, '\n')) != NULL)
+      *s = '\0';
   }
 
   return(host);
@@ -495,68 +510,68 @@
 /*********************************************************************/
 
 void open_files(host)
-int *host;
+  int *host;
 {
   if (*host == 1 || *host == 2 || *host == 5)  {
     if (outname[0] == '-') outfile=stdout;
-    else if ((outfile = fopen(outname,"wb"))==NULL) {
-      fprintf(stderr,"\ncan't open output file: %s\n",outname);
+    else if ((outfile = fopen(outname, "wb"))==NULL) {
+      fprintf(stderr,"\ncan't open output file: %s\n", outname);
       exit(1);
     }
   }
 
   else if (*host == 3 || *host == 4) {
     if (output_format == 1) {     /* write PDS format blocks */
-      if (record_bytes == 836) { 
-	if ((outfile=fopen(outname,"w"
+      if (record_bytes == 836) {
+	if ((outfile=fopen(outname, "w"
 #ifdef VMS
 			   ,"mrs=836",FOP,CTX,RECORD_TYPE
 #endif
 			   ))==NULL) {
-	  fprintf(stderr,"\ncan't open output file: %s\n",outname);
+	  fprintf(stderr,"\ncan't open output file: %s\n", outname);
 	  exit(1);
 	}
       }
       else {
-	if ((outfile=fopen(outname,"w"
+	if ((outfile=fopen(outname, "w"
 #ifdef VMS
 			   ,"mrs=1204",FOP,CTX,RECORD_TYPE
 #endif
 			   ))==NULL) {
-	  fprintf(stderr,"\ncan't open output file: %s\n",outname);
+	  fprintf(stderr,"\ncan't open output file: %s\n", outname);
 	  exit(1);
 	}
       }
     }
     else if (output_format == 2) {  /* write FITS format blocks */
-      if ((outfile=fopen(outname,"w"
+      if ((outfile=fopen(outname, "w"
 #ifdef VMS
 			 ,"mrs=2880",FOP,CTX,RECORD_TYPE
 #endif
 			 ))==NULL) {
-	fprintf(stderr,"\ncan't open output file: %s\n",outname);
+	fprintf(stderr,"\ncan't open output file: %s\n", outname);
 	exit(1);
       }
     }
 
-    else {                       /* write fixed length records */
-      if (record_bytes == 836) { 
-	if ((outfile=fopen(outname,"w"
+    else {                       /* write fixed-length records */
+      if (record_bytes == 836) {
+	if ((outfile=fopen(outname, "w"
 #ifdef VMS
 			   ,"mrs=800",FOP,CTX,RECORD_TYPE
 #endif
 			   ))==NULL) {
-	  fprintf(stderr,"\ncan't open output file: %s\n",outname);
+	  fprintf(stderr,"\ncan't open output file: %s\n", outname);
 	  exit(1);
 	}
       }
       else {
-	if ((outfile=fopen(outname,"w"
+	if ((outfile=fopen(outname, "w"
 #ifdef VMS
 			   ,"mrs=1204",FOP,CTX,RECORD_TYPE
 #endif
 			   ))==NULL) {
-	  fprintf(stderr,"\ncan't open output file: %s\n",outname);
+	  fprintf(stderr,"\ncan't open output file: %s\n", outname);
 	  exit(1);
 	}
       }
@@ -572,11 +587,11 @@
 /*********************************************************************/
 
 void pds_labels(host)
-     int host;
+  int host;
 {
-  char          outstring[80],ibuf[2048];
+  char          ibuf[2048];
   unsigned char cr=13,lf=10,blank=32;
-  short         length,nlen,total_bytes,line,i;
+  short         length,total_bytes,i;
 
 
   total_bytes = 0;
@@ -613,11 +628,11 @@
 	       (size_t) 53,(size_t) 1,outfile);
       else
         fwrite("CCSD3ZF0000100000001NJPL3IF0PDS200000001 = SFDU_LABEL",
-	       (size_t) 53,(size_t) 1,outfile);      
+	       (size_t) 53,(size_t) 1,outfile);
 
       fprintf(outfile,"%c%c",cr,lf);
       fwrite("/*          FILE FORMAT AND LENGTH */",(size_t) 37,(size_t) 1,
-	     outfile);      
+	     outfile);
       fprintf(outfile,"%c%c",cr,lf);
       fwrite("RECORD_TYPE                      = FIXED_LENGTH",(size_t) 47,
 	     (size_t) 1,outfile);
@@ -710,7 +725,7 @@
       }
       else {
 	strcpy(ibuf+35,"60");
-	length = length - 2; 
+	length = length - 2;
       }
 
       fwrite(ibuf,(size_t) length,(size_t) 1,outfile);
@@ -730,7 +745,7 @@
     }
 
     else if ((i = strncmp(ibuf," ENCODING",(size_t) 9)) == 0);
-    
+
     /*****************************************************************/
     /* delete the encoding type label in the image object            */
     /*****************************************************************/
@@ -787,10 +802,10 @@
 /*********************************************************************/
 
 void fits_labels(host)
-int host;
+  int host;
 {
   char          ibuf[2048],outstring[80];
-  short         length,nlen,total_bytes,line,i;
+  short         length,total_bytes,i;
   unsigned char cr=13,lf=10,blank=32;
 
   do {
@@ -799,7 +814,7 @@
     /*****************************************************************/
     /* find the checksum and store in label_checksum                 */
     /*****************************************************************/
-    if ((i = strncmp(ibuf," CHECKSUM",(size_t) 9)) == 0) { 
+    if ((i = strncmp(ibuf," CHECKSUM",(size_t) 9)) == 0) {
       ibuf[length]   = '\0';
       label_checksum = atol(ibuf+35);
     }
@@ -842,7 +857,7 @@
 
   if (record_bytes == 836)
     strcpy(outstring,"NAXIS1  =                  800");
-  else 
+  else
     strcpy(outstring,"NAXIS1  =                 1204");
 
   strcat(outstring,"                                               ");
@@ -862,7 +877,7 @@
 
   strcpy(outstring,"END                             ");
   strcat(outstring,"                                               ");
-  
+
   fwrite(outstring,(size_t) 78,(size_t) 1,outfile);
   fprintf(outfile,"%c%c",cr,lf);
   total_bytes = total_bytes + 80;
@@ -871,6 +886,7 @@
   for (i=total_bytes; i<2880; i++) fputc(blank,outfile);
 }
 
+
 /*********************************************************************/
 /*                                                                   */
 /* subroutine vicar_labels - write vicar labels to output file       */
@@ -878,11 +894,10 @@
 /*********************************************************************/
 
 void vicar_labels(host)
-int host;
-
+  int host;
 {
   char          ibuf[2048],outstring[80];
-  short         length,nlen,total_bytes,line,i;
+  short         length,total_bytes,i;
   unsigned char cr=13,lf=10,blank=32;
 
   do {
@@ -890,7 +905,7 @@
     /*****************************************************************/
     /* find the checksum and store in label_checksum                 */
     /*****************************************************************/
-    if ((i = strncmp(ibuf," CHECKSUM",(size_t) 9)) == 0) { 
+    if ((i = strncmp(ibuf," CHECKSUM",(size_t) 9)) == 0) {
       ibuf[length]   = '\0';
       label_checksum = atol(ibuf+35);
     }
@@ -950,10 +965,10 @@
 /*********************************************************************/
 
 void no_labels(host)
-int host;
+  int host;
 {
-  char          ibuf[2048],outstring[80];
-  short         length,nlen,total_bytes,line,i;
+  char          ibuf[2048];
+  short         length,i;
 
   do {
     length = read_var(ibuf,host);
@@ -961,7 +976,7 @@
     /*****************************************************************/
     /* find the checksum and store in label_checksum                 */
     /*****************************************************************/
-    if ((i = strncmp(ibuf," CHECKSUM",(size_t) 9)) == 0) { 
+    if ((i = strncmp(ibuf," CHECKSUM",(size_t) 9)) == 0) {
       ibuf[length]   = '\0';
       label_checksum = atol(ibuf+35);
     }
@@ -984,15 +999,16 @@
   open_files(&host);
 }
 
+
 /*********************************************************************/
 /*                                                                   */
-/* subroutine read_var - read variable length records from input file*/
+/* subroutine read_var - read variable-length records from input file*/
 /*                                                                   */
 /*********************************************************************/
 
 int read_var(ibuf,host)
-char  *ibuf;
-int   host;
+  char  *ibuf;
+  int   host;
 {
   int   length,result,nlen;
   char  temp;
@@ -1027,19 +1043,19 @@
     return (length);
 
   case 3: /*******************************************************/
-          /* VAX host with variable length support               */
+          /* VAX host with variable-length support               */
           /*******************************************************/
     length = read(infile,ibuf,(size_t) 2048/* upper bound */);
     return (length);
 
   case 4: /*******************************************************/
-          /* VAX host, but not a variable length file            */
+          /* VAX host, but not a variable-length file            */
           /*******************************************************/
     length = 0;
     result = read(infile,&length,(size_t) 2);
     nlen =   read(infile,ibuf,(size_t) length+(length%2));
 
-    /* check to see if we crossed a vax record boundary          */
+    /* check to see if we crossed a VAX record boundary          */
     while (nlen < length)
       nlen += read(infile,ibuf+nlen,(size_t) length+(length%2)-nlen);
     return (length);
@@ -1061,6 +1077,7 @@
   return 0;
 }
 
+
 /*********************************************************************/
 /*                                                                   */
 /* subroutine check_host - find out what kind of machine we are on   */
@@ -1115,23 +1132,23 @@
 	   "Host 5 - 32 bit integers without swapping, no var len support.");
   }
 
-  if ((*outname)!='-') fprintf(stderr,"%s\n",hostname);
+  if ((*outname) != '-') fprintf(stderr, "%s\n", hostname);
   return(host);
 }
 
 
-int swap_int(inval)  /* swap 4 byte integer                       */
-     int inval;
+int swap_int(inval)  /* swap 4 byte integer */
+  int inval;
 {
-  union /* this union is used to swap 16 and 32 bit integers          */
+  union /* this union is used to swap 16 and 32 bit integers */
     {
       char  ichar[4];
       short slen;
       int   llen;
     } onion;
   char   temp;
-  
-  /* byte swap the input field                                      */
+
+  /* byte swap the input field */
   onion.llen   = inval;
   temp   = onion.ichar[0];
   onion.ichar[0]=onion.ichar[3];
@@ -1146,17 +1163,16 @@
 /****************************************************************************
 *_TITLE decompress - decompresses image lines stored in compressed format   *
 *_ARGS  TYPE       NAME      I/O        DESCRIPTION                         */
-        char *ibuf;        /* I         Compressed data buffer              */
-        char *obuf;        /* O         Decompressed image line             */
-        int       *nin;   /* I         Number of bytes on input buffer     */
-        int       *nout;  /* I         Number of bytes in output buffer    */
-
+        char       *ibuf;  /* I         Compressed data buffer              */
+        char       *obuf;  /* O         Decompressed image line             */
+        int        *nin;   /* I         Number of bytes on input buffer     */
+        int        *nout;  /* I         Number of bytes in output buffer    */
 {
   /* The external root pointer to tree */
   extern NODE *tree;
 
   dcmprs(ibuf,obuf,nin,nout,tree);
-  
+
   return;
 }
 
@@ -1165,8 +1181,7 @@
 /***************************************************************************
 *_TITLE decmpinit - initializes the Huffman tree                           *
 *_ARGS  TYPE       NAME      I/O        DESCRIPTION                        */
-        int      *hist;  /* I         First-difference histogram.        */
-
+        int        *hist;  /* I         First-difference histogram.        */
 {
   extern NODE *tree;          /* Huffman tree root pointer */
   tree = huff_tree(hist);
@@ -1178,8 +1193,7 @@
 /****************************************************************************
 *_TITLE huff_tree - constructs the Huffman tree; returns pointer to root    *
 *_ARGS  TYPE          NAME        I/O   DESCRIPTION                         */
-        int     *hist;     /* I    First difference histogram          */
-
+        int          *hist;     /* I    First difference histogram          */
 {
   /*  Local variables used */
   int freq_list[512];      /* Histogram frequency list */
@@ -1189,7 +1203,6 @@
   NODE **np;        /* Node list pointer */
 
   int num_freq;   /* Number non-zero frequencies in histogram */
-  int sum;                 /* Sum of all frequencies */
 
   short int num_nodes; /* Counter for DN initialization */
   short int cnt;       /* Miscellaneous counter */
@@ -1228,7 +1241,7 @@
 
     j = 0;
     for (i=4 ; --i >= 0 ; j = (j << 8) | *(cp+i));
-    
+
     /* Now make the assignment */
     *fp++ = j;
     temp = new_node(num_nodes);
@@ -1341,7 +1354,7 @@
       l--;
       if ( j <= freq_list) break;
     }
-    
+
   }
   return;
 }
@@ -1362,9 +1375,9 @@
   NODE *ptr = root;        /* pointer to position in tree */
   unsigned char test;      /* test byte for bit set */
   unsigned char idn;       /* input compressed byte */
-  
+
   char odn;                /* last dn value decompressed */
-  
+
   char *ilim = ibuf + *nin;         /* end of compressed bytes */
   char *olim = obuf + *nout;        /* end of output buffer */
 
@@ -1406,10 +1419,9 @@
 /****************************************************************************
 *_TITLE free_tree - free memory of all allocated nodes                      *
 *_ARGS  TYPE       NAME       I/O        DESCRIPTION                        */
-        int      *nfreed;  /* O        Return of total count of nodes     *
+        int        *nfreed;  /* O        Return of total count of nodes     *
 *                                        freed.                             */
-
-/*
+/*                                                                          *
 *_DESCR This routine is supplied to the programmer to free up all the       *
 *       allocated memory required to build the huffman tree.  The count     *
 *       of the nodes freed is returned in the parameter 'nfreed'.  The      *
@@ -1417,11 +1429,10 @@
 *       than one file per run, the program will not keep allocating new     *
 *       memory without first deallocating all previous nodes associated     *
 *       with the previous file decompression.                               *
-
+*                                                                           *
 *_HIST  16-AUG-89 Kris Becker   USGS, Flagstaff Original Version            *
 *_END                                                                       *
 ****************************************************************************/
-
 {
   int total_free = 0;
 
@@ -1435,36 +1446,33 @@
 
 int free_node(pnode,total_free)
 /***************************************************************************
-*_TITLE free_node - deallocates an allocated NODE pointer
+*_TITLE free_node - deallocates an allocated NODE pointer                  *
 *_ARGS  TYPE     NAME          I/O   DESCRIPTION                           */
         NODE     *pnode;       /* I  Pointer to node to free               */
-        int       total_free;   /* I  Total number of freed nodes           */
-
-/*
+        int      total_free;   /* I  Total number of freed nodes           */
+/*                                                                         *
 *_DESCR  free_node will check both right and left pointers of a node       *
 *        and then free the current node using the free() C utility.        *
 *        Note that all nodes attached to the node via right or left        *
 *        pointers area also freed, so be sure that this is the desired     *
 *        result when calling this routine.                                 *
-
+*                                                                          *
 *        This routine is supplied to allow successive calls to the         *
 *        decmpinit routine.  It will free up the memory allocated          *
 *        by previous calls to the decmpinit routine.  The call to free     *
-*        a previous huffman tree is:  total = free_node(tree,(int) 0);    *
+*        a previous huffman tree is:  total = free_node(tree,(int) 0);     *
 *        This call must be done by the programmer application routine      *
 *        and is not done by any of these routines.                         *
 *_HIST   16-AUG-89  Kris Becker U.S.G.S  Flagstaff Original Version        */
 {
   if (pnode == (NODE *) NULL) return(total_free);
-  
+
   if (pnode->right != (NODE *) NULL)
     total_free = free_node(pnode->right,total_free);
   if (pnode->left != (NODE *) NULL)
     total_free = free_node(pnode->left,total_free);
-  
+
   free((char *) pnode);
   return(total_free + 1);
 }
 
-
-
diff -ruN xv-3.10a/xcmap.c xv-3.10a-bugfixes/xcmap.c
--- xv-3.10a/xcmap.c	1995-01-03 13:14:52.000000000 -0800
+++ xv-3.10a-bugfixes/xcmap.c	2005-03-20 15:51:59.000000000 -0800
@@ -9,6 +9,9 @@
 
 /* include files */
 #include <stdio.h>
+#ifdef __STDC__
+#  include <stdlib.h>   /* exit(), abs() */
+#endif
 #include <sys/types.h>
 #include <ctype.h>
 
@@ -18,7 +21,7 @@
 #include <X11/cursorfont.h>
 
 #ifdef VMS
-#define index strchr
+#  define index strchr
 #endif
 
 typedef unsigned char byte;
@@ -75,50 +78,50 @@
   int        i;
   char      *display, *geom;
   XEvent     event;
-  
+
   cmd = argv[0];
   display = geom = NULL;
-  
-  
+
+
   /*********************Options*********************/
-  
+
   for (i = 1; i < argc; i++) {
     char *strind;
-    
+
     if (!strncmp(argv[i],"-g", (size_t)2)) {	/* geometry */
       i++;
       geom = argv[i];
       continue;
     }
-    
+
     if (argv[i][0] == '=') {		/* old-style geometry */
       geom = argv[i];
       continue;
     }
-    
+
     if (!strncmp(argv[i],"-d",(size_t) 2)) {	/* display */
       i++;
       display = argv[i];
       continue;
     }
-    
+
     strind = (char *) index(argv[i], ':');	/* old-style display */
     if(strind != NULL) {
       display = argv[i];
       continue;
     }
-    
+
     Syntax();
   }
-  
-  
+
+
   /*****************************************************/
-  
+
   /* Open up the display. */
-  
+
   if ( (theDisp=XOpenDisplay(display)) == NULL)
     FatalError("can't open display");
-  
+
   theScreen = DefaultScreen(theDisp);
   theCmap   = DefaultColormap(theDisp, theScreen);
   rootW     = RootWindow(theDisp,theScreen);
@@ -126,9 +129,9 @@
   fcol      = WhitePixel(theDisp,theScreen);
   bcol      = BlackPixel(theDisp,theScreen);
   theVisual = DefaultVisual(theDisp,theScreen);
-  
+
   dispcells = DisplayCells(theDisp, theScreen);
-  
+
   if (dispcells>256) {
     sprintf(tmpstr,"dispcells = %d.  %s",
 	    dispcells, "This program can only deal with <= 8-bit displays.");
@@ -140,27 +143,32 @@
     nxcells = nycells = 8;
   else if (dispcells>4)
     nxcells = nycells = 4;
-  else
+  else if (dispcells>2)
     nxcells = nycells = 2;
-  
+  else
+  {
+    nxcells = 2;
+    nycells = 1;
+  }
+
   /**************** Create/Open X Resources ***************/
   if ((mfinfo = XLoadQueryFont(theDisp,FONT))==NULL) {
     sprintf(tmpstr,"couldn't open '%s' font",FONT);
     FatalError(tmpstr);
   }
-  
+
   mfont=mfinfo->fid;
   XSetFont(theDisp,theGC,mfont);
   XSetForeground(theDisp,theGC,fcol);
   XSetBackground(theDisp,theGC,bcol);
-  
+
   CreateMainWindow(cmd,geom,argc,argv);
   Resize(WIDE,HIGH);
-  
-  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask 
+
+  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask
 	       | StructureNotifyMask | ButtonPressMask);
   XMapWindow(theDisp,mainW);
-  
+
   /**************** Main loop *****************/
   while (1) {
     XNextEvent(theDisp, &event);
@@ -177,41 +185,41 @@
   switch (event->type) {
   case Expose: {
     XExposeEvent *exp_event = (XExposeEvent *) event;
-    
-    if (exp_event->window==mainW) 
+
+    if (exp_event->window==mainW)
       DrawWindow(exp_event->x,exp_event->y,
 		 exp_event->width, exp_event->height);
   }
     break;
-    
+
   case ButtonPress: {
     XButtonEvent *but_event = (XButtonEvent *) event;
-    
-    if (but_event->window == mainW && but_event->button == Button1) 
+
+    if (but_event->window == mainW && but_event->button == Button1)
       TrackMouse(but_event->x, but_event->y);
   }
     break;
-    
+
   case KeyPress: {
     XKeyEvent *key_event = (XKeyEvent *) event;
     KeySym ks;
     XComposeStatus status;
-    
+
     XLookupString(key_event,tmpstr,128,&ks,&status);
     if (tmpstr[0]=='q' || tmpstr[0]=='Q') Quit();
   }
     break;
-    
+
   case ConfigureNotify: {
     XConfigureEvent *conf_event = (XConfigureEvent *) event;
-    
-    if (conf_event->window == mainW && 
+
+    if (conf_event->window == mainW &&
 	(conf_event->width != WIDE || conf_event->height != HIGH))
       Resize(conf_event->width, conf_event->height);
   }
     break;
-    
-    
+
+
   case CirculateNotify:
   case MapNotify:
   case DestroyNotify:
@@ -220,7 +228,7 @@
   case UnmapNotify:
   case MappingNotify:
   case ClientMessage:         break;
-    
+
   default:		/* ignore unexpected events */
     break;
   }  /* end of switch */
@@ -262,24 +270,31 @@
   XSizeHints hints;
   int i,x,y;
   unsigned int w,h;
-  
+
   WIDE = HIGH = 256;			/* default window size */
-  
+
   x=y=w=h=1;
   i=XParseGeometry(geom,&x,&y,&w,&h);
-  if (i&WidthValue)  WIDE = (int) w;
-  if (i&HeightValue) HIGH = (int) h;
-  
-  if (i&XValue || i&YValue) hints.flags = USPosition;  
-  else hints.flags = PPosition;
-  
-  hints.flags |= USSize;
-  
-  if (i&XValue && i&XNegative) 
-    x = XDisplayWidth(theDisp,theScreen)-WIDE-abs(x);
-  if (i&YValue && i&YNegative) 
-    y = XDisplayHeight(theDisp,theScreen)-HIGH-abs(y);
-  
+  if (i&WidthValue)
+  {
+    WIDE = (int) w;
+    hints.flags |= USSize;
+  }
+  if (i&HeightValue)
+  {
+    HIGH = (int) h;
+    hints.flags |= USSize;
+  }
+
+  if (i&XValue || i&YValue)
+  {
+    if (i&XNegative)
+      x = XDisplayWidth(theDisp,theScreen)-WIDE-abs(x);
+    if (i&YNegative)
+      y = XDisplayHeight(theDisp,theScreen)-HIGH-abs(y);
+    hints.flags |= USPosition;
+  }
+
   hints.x=x;             hints.y=y;
   hints.width  = WIDE;   hints.height = HIGH;
   hints.max_width  = DisplayWidth(theDisp,theScreen);
@@ -288,22 +303,22 @@
   hints.min_height = 16;
   hints.width_inc = hints.height_inc = 16;
   hints.flags |= PMaxSize | PMinSize | PResizeInc;
-  
+
   xswa.background_pixel = bcol;
   xswa.border_pixel     = fcol;
   xswa.cursor = XCreateFontCursor (theDisp, XC_top_left_arrow);
   xswamask = CWBackPixel | CWBorderPixel | CWCursor;
-  
+
   mainW = XCreateWindow(theDisp,rootW,x,y,(unsigned int) WIDE,
-			(unsigned int) HIGH, 2, 0, 
+			(unsigned int) HIGH, 2, 0,
 			(unsigned int) CopyFromParent,
 			CopyFromParent, xswamask, &xswa);
-  
+
   XSetStandardProperties(theDisp,mainW,"xcmap","xcmap",None,
 			 argv,argc,&hints);
-  
+
   if (!mainW) FatalError("Can't open main window");
-  
+
 }
 
 
@@ -312,11 +327,11 @@
      int x,y,w,h;
 {
   int i,j,x1,y1,x2,y2;
-  
+
   x1 = x / cWIDE;      y1 = y / cHIGH;	/* (x1,y1) (x2,y2): bounding */
   x2 = ((x+w) + cWIDE - 1) / cWIDE;		/*       rect in cell coords */
   y2 = ((y+h) + cHIGH - 1) / cHIGH;
-  
+
   for (i=y1; i<y2; i++) {
     for (j=x1; j<x2; j++) {
       XSetForeground(theDisp,theGC,(unsigned long) (i*nycells+j) );
@@ -343,18 +358,18 @@
 {
   /* called when there's a button press in the window.  draws the pixel
      value, and loops until button is released */
-  
+
   Window        rootW,childW;
   int           rx,ry,x,y;
   unsigned int  mask;
-  
+
   pvalup = 0;
   DrawPixValue(mx,my);
-  
+
   while (1) {
     if (XQueryPointer(theDisp,mainW,&rootW,&childW,&rx,&ry,&x,&y,&mask)) {
       if (!(mask & Button1Mask)) break;    /* button released */
-      
+
       DrawPixValue(x,y);
     }
   }
@@ -367,10 +382,10 @@
 {
   static unsigned long pix, lastpix;
   static int           pvaly;
-  
+
   if (x<0) x=0;  if (x>=WIDE) x=WIDE-1;
   if (y<0) y=0;  if (y>=HIGH) y=HIGH-1;
-  
+
   if (!pvalup) {	/* it's not up.  make it so */
     if (y >= HIGH/2) pvaly = 0;  else pvaly = HIGH - 12;
     pvalup = 1;
@@ -378,30 +393,30 @@
     XClearArea(theDisp,mainW,0,pvaly,
 	       (unsigned int) WIDE, (unsigned int) 13,True);
   }
-  
+
   x /= cWIDE;  y /= cHIGH;
-  
+
   pix = y * nxcells + x;
-  
+
   if (pix != lastpix) {
     XColor def;
     char  *sp;
-    
+
     XSetForeground(theDisp,theGC,fcol);
     lastpix = def.pixel = pix;
     if (pix<dispcells) {
       XQueryColor(theDisp, theCmap, &def);
       sprintf(tmpstr, "Pix %3ld = ($%04x, $%04x, $%04x)",
 	      pix, def.red, def.green, def.blue);
-      
-      /* make the hex uppercase */        
-      for (sp=tmpstr+4; *sp; sp++) 
+
+      /* make the hex uppercase */
+      for (sp=tmpstr+4; *sp; sp++)
 	if (islower(*sp)) *sp = toupper(*sp);
     }
     else {
       sprintf(tmpstr, "Pix %3ld is out of legal range. ", pix);
     }
-    
+
     XDrawImageString(theDisp,mainW,theGC,5,pvaly+10,tmpstr,
 		     (int) strlen(tmpstr));
   }
diff -ruN xv-3.10a/xv.c xv-3.10a-bugfixes/xv.c
--- xv-3.10a/xv.c	1995-01-19 10:08:43.000000000 -0800
+++ xv-3.10a-bugfixes/xv.c	2005-03-20 22:25:22.000000000 -0800
@@ -33,9 +33,9 @@
 
 /* a mono-spaced font needed for the 'pixel value tracking' feature */
 #define MFONT1 "-misc-fixed-medium-r-normal-*-13-*"
-#define MFONT2 "6x13"   
+#define MFONT2 "6x13"
 #define MFONT3 "-*-courier-medium-r-*-*-12-*"
-#define MFONT4 "fixed"   
+#define MFONT4 "fixed"
 
 
 /* default positions for various windows */
@@ -116,13 +116,13 @@
 
 /* formerly local vars in main, made local to this module when
    parseResources() and parseCmdLine() were split out of main() */
-   
+
 int   imap, ctrlmap, gmap, browmap, cmtmap, clrroot, nopos, limit2x;
 char *display, *whitestr, *blackstr, *histr, *lostr,
      *infogeom, *fgstr, *bgstr, *ctrlgeom, *gamgeom, *browgeom, *tmpstr;
 char *rootfgstr, *rootbgstr, *visualstr, *textgeom, *cmtgeom;
 char *monofontname, *flistName;
-int  curstype, stdinflag, browseMode, savenorm, preview, pscomp, preset, 
+int  curstype, stdinflag, browseMode, savenorm, preview, pscomp, preset,
      rmodeset, gamset, cgamset, perfect, owncmap, rwcolor, stdcmap;
 int  nodecor;
 double gamval, rgamval, ggamval, bgamval;
@@ -177,16 +177,16 @@
 
   LocalCmap = browCmap = 0;
   stdinflag = 0;
-  autoclose = autoDelete = 0; 
+  autoclose = autoDelete = 0;
   cmapInGam = 0;
   grabDelay = 0;
   showzoomcursor = 0;
   perfect = owncmap = stdcmap = rwcolor = 0;
 
   ignoreConfigs = 0;
-  browPerfect = 1;  
+  browPerfect = 1;
   gamval = rgamval = ggamval = bgamval = 1.0;
-  
+
   picType = -1;              /* gets set once file is loaded */
   colorMapMode = CM_NORMAL;
   haveStdCmap  = STD_NONE;
@@ -230,11 +230,11 @@
   }
 
   /* init command-line options flags */
-  infogeom = DEFINFOGEOM;  ctrlgeom = DEFCTRLGEOM;  
+  infogeom = DEFINFOGEOM;  ctrlgeom = DEFCTRLGEOM;
   gamgeom  = DEFGAMGEOM;   browgeom = DEFBROWGEOM;
   textgeom = DEFTEXTGEOM;  cmtgeom  = DEFCMTGEOM;
 
-  ncols = -1;  mono = 0;  
+  ncols = -1;  mono = 0;
   ninstall = 0;  fixedaspect = 0;  noFreeCols = nodecor = 0;
   DEBUG = 0;  bwidth = 2;
   nolimits = useroot = clrroot = noqcheck = 0;
@@ -306,7 +306,7 @@
   /*****************************************************/
   /*** X Setup                                       ***/
   /*****************************************************/
-  
+
   theScreen = DefaultScreen(theDisp);
   theCmap   = DefaultColormap(theDisp, theScreen);
   rootW     = RootWindow(theDisp,theScreen);
@@ -321,52 +321,66 @@
   rootDEEP = dispDEEP;
 
   /* things dependant on theVisual:
-   *    dispDEEP, theScreen, rootW, ncells, theCmap, theGC, 
+   *    dispDEEP, theScreen, rootW, ncells, theCmap, theGC,
    *    vrWIDE, dispWIDE, vrHIGH, dispHIGH, maxWIDE, maxHIGH
    */
 
 
-
   /* if we *haven't* had a non-default visual specified,
-     see if we have a TrueColor or DirectColor visual of 24 or 32 bits, 
+     see if we have a TrueColor or DirectColor visual of 24 or 32 bits,
      and if so, use that as the default visual (prefer TrueColor) */
 
   if (!visualstr && !useroot) {
+    VisualID     defvid;
     XVisualInfo *vinfo, rvinfo;
     int          best,  numvis;
     long         flags;
 
-    best = -1;
+    best          = -1;
     rvinfo.class  = TrueColor;
     rvinfo.screen = theScreen;
-    flags = VisualClassMask | VisualScreenMask;
-    
+    flags         = VisualClassMask | VisualScreenMask;
+    defvid        = XVisualIDFromVisual(DefaultVisual(theDisp,
+						      DefaultScreen(theDisp)));
+
     vinfo = XGetVisualInfo(theDisp, flags, &rvinfo, &numvis);
-    if (vinfo) {     /* look for a TrueColor, 24-bit or more (pref 24) */
-      for (i=0, best = -1; i<numvis; i++) {
+    if (vinfo) {
+      /* Check list, use 'default', first 24-bit, or first >24-bit */
+      for (i=0; i<numvis && best==-1; i++) {   /* default? */
+	if ((vinfo[i].visualid == defvid) && (vinfo[i].depth >= 24)) best=i;
+      }
+      for (i=0; i<numvis && best==-1; i++) {   /* 24-bit ? */
 	if (vinfo[i].depth == 24) best = i;
-	else if (vinfo[i].depth>24 && best<0) best = i;
+      }
+      for (i=0; i<numvis && best==-1; i++) {   /* >24-bit ? */
+	if (vinfo[i].depth >= 24) best = i;
       }
     }
 
     if (best == -1) {   /* look for a DirectColor, 24-bit or more (pref 24) */
       rvinfo.class = DirectColor;
       if (vinfo) XFree((char *) vinfo);
+
       vinfo = XGetVisualInfo(theDisp, flags, &rvinfo, &numvis);
       if (vinfo) {
-	for (i=0, best = -1; i<numvis; i++) {
+	for (i=0; i<numvis && best==-1; i++) {   /* default? */
+	  if ((vinfo[i].visualid == defvid) && (vinfo[i].depth >= 24)) best=i;
+	}
+	for (i=0; i<numvis && best==-1; i++) {   /* 24-bit ? */
 	  if (vinfo[i].depth == 24) best = i;
-	  else if (vinfo[i].depth>24 && best<0) best = i;
+	}
+	for (i=0; i<numvis && best==-1; i++) {   /* >24-bit ? */
+	  if (vinfo[i].depth >= 24) best = i;
 	}
       }
     }
-    
+
     if (best>=0 && best<numvis) useOtherVisual(vinfo, best);
     if (vinfo) XFree((char *) vinfo);
   }
 
 
-			   
+
   if (visualstr && useroot) {
     fprintf(stderr, "%s: %sUsing default visual.\n",
 	    cmd, "Warning:  Can't use specified visual on root.  ");
@@ -401,11 +415,11 @@
       long vinfomask;
       int numvis, best;
 
-      if (vclass >= 0) { 
+      if (vclass >= 0) {
 	rvinfo.class = vclass;   vinfomask = VisualClassMask;
       }
       else { rvinfo.visualid = vid;  vinfomask = VisualIDMask; }
-      
+
       rvinfo.screen = theScreen;
       vinfomask |= VisualScreenMask;
 
@@ -429,9 +443,9 @@
   /* make linear colormap for DirectColor visual */
   if (theVisual->class == DirectColor) makeDirectCmap();
 
-  defaultVis = (XVisualIDFromVisual(theVisual) == 
+  defaultVis = (XVisualIDFromVisual(theVisual) ==
        XVisualIDFromVisual(DefaultVisual(theDisp, DefaultScreen(theDisp))));
-    
+
 
   /* turn GraphicsExposures OFF in the default GC */
   {
@@ -456,12 +470,12 @@
     Atom actual_type;
     int actual_format;
     unsigned long nitems, bytesafter;
-    Window *newRoot = NULL;
+    byte *newRoot = NULL;   /* byte instead of Window avoids type-pun warning */
     XWindowAttributes xwa;
     if (XGetWindowProperty (theDisp, children[i], __SWM_VROOT, 0L, 1L,
 	  False, XA_WINDOW, &actual_type, &actual_format, &nitems,
 	  &bytesafter, (unsigned char **) &newRoot) == Success && newRoot) {
-      vrootW = *newRoot;
+      vrootW = *(Window *)newRoot;
       XGetWindowAttributes(theDisp, vrootW, &xwa);
       vrWIDE = xwa.width;  vrHIGH = xwa.height;
       dispDEEP = xwa.depth;
@@ -492,7 +506,7 @@
     XColor fc, bc;
     fc.red = fc.green = fc.blue = 0xffff;
     bc.red = bc.green = bc.blue = 0x0000;
-    
+
     XRecolorCursor(theDisp, zoom, &fc, &bc);
   }
 
@@ -541,7 +555,7 @@
 
 
   /* set up fg,bg colors */
-  fg = black;   bg = white;  
+  fg = black;   bg = white;
   if (fgstr && XParseColor(theDisp, theCmap, fgstr, &ecdef) &&
       xvAllocColor(theDisp, theCmap, &ecdef)) {
     fg = ecdef.pixel;
@@ -590,7 +604,7 @@
     if (theVisual->class == StaticGray || theVisual->class == GrayScale)
       mono = 1;
   }
-  
+
 
 
   iconPix  = MakePix1(rootW, icon_bits,     icon_width,    icon_height);
@@ -598,27 +612,27 @@
   riconPix = MakePix1(rootW, runicon_bits,  runicon_width, runicon_height);
   riconmask= MakePix1(rootW, runiconm_bits, runiconm_width,runiconm_height);
 
-  if (!iconPix || !iconmask || !riconPix || !riconmask) 
+  if (!iconPix || !iconmask || !riconPix || !riconmask)
     FatalError("Unable to create icon pixmaps\n");
 
-  gray50Tile = XCreatePixmapFromBitmapData(theDisp, rootW, 
+  gray50Tile = XCreatePixmapFromBitmapData(theDisp, rootW,
 				(char *) cboard50_bits,
-				cboard50_width, cboard50_height, 
+				cboard50_width, cboard50_height,
 				infofg, infobg, dispDEEP);
   if (!gray50Tile) FatalError("Unable to create gray50Tile bitmap\n");
 
-  gray25Tile = XCreatePixmapFromBitmapData(theDisp, rootW, 
+  gray25Tile = XCreatePixmapFromBitmapData(theDisp, rootW,
 				(char *) gray25_bits,
-				gray25_width, gray25_height, 
+				gray25_width, gray25_height,
 				infofg, infobg, dispDEEP);
   if (!gray25Tile) FatalError("Unable to create gray25Tile bitmap\n");
 
 
   /* try to load fonts */
-  if ( (mfinfo = XLoadQueryFont(theDisp,FONT1))==NULL && 
-       (mfinfo = XLoadQueryFont(theDisp,FONT2))==NULL && 
-       (mfinfo = XLoadQueryFont(theDisp,FONT3))==NULL && 
-       (mfinfo = XLoadQueryFont(theDisp,FONT4))==NULL && 
+  if ( (mfinfo = XLoadQueryFont(theDisp,FONT1))==NULL &&
+       (mfinfo = XLoadQueryFont(theDisp,FONT2))==NULL &&
+       (mfinfo = XLoadQueryFont(theDisp,FONT3))==NULL &&
+       (mfinfo = XLoadQueryFont(theDisp,FONT4))==NULL &&
        (mfinfo = XLoadQueryFont(theDisp,FONT5))==NULL) {
     sprintf(str,
 	    "couldn't open the following fonts:\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s",
@@ -632,14 +646,14 @@
 
   if (monofontname) {
     monofinfo = XLoadQueryFont(theDisp, monofontname);
-    if (!monofinfo) fprintf(stderr,"xv: unable to load font '%s'\n", 
+    if (!monofinfo) fprintf(stderr,"xv: unable to load font '%s'\n",
 			    monofontname);
-  }    
+  }
 
   if (!monofinfo) {
-    if ((monofinfo = XLoadQueryFont(theDisp,MFONT1))==NULL && 
-	(monofinfo = XLoadQueryFont(theDisp,MFONT2))==NULL && 
-	(monofinfo = XLoadQueryFont(theDisp,MFONT3))==NULL && 
+    if ((monofinfo = XLoadQueryFont(theDisp,MFONT1))==NULL &&
+	(monofinfo = XLoadQueryFont(theDisp,MFONT2))==NULL &&
+	(monofinfo = XLoadQueryFont(theDisp,MFONT3))==NULL &&
 	(monofinfo = XLoadQueryFont(theDisp,MFONT4))==NULL) {
       sprintf(str,"couldn't open %s fonts:\n\t%s\n\t%s\n\t%s\n\t%s",
 	      "any of the following",
@@ -649,28 +663,28 @@
   }
 
   monofont=monofinfo->fid;
-  
 
-  
-  
+
+
+
   /* if ncols wasn't set, set it to 2^dispDEEP, unless dispDEEP=1, in which
      case ncols = 0;  (ncols = max number of colors allocated.  on 1-bit
      displays, no colors are allocated */
-  
+
   if (ncols == -1) {
     if (dispDEEP>1) ncols = 1 << ((dispDEEP>8) ? 8 : dispDEEP);
     else ncols = 0;
   }
   else if (ncols>256) ncols = 256;       /* so program doesn't blow up */
-  
-  
+
+
   GenerateFSGamma();  /* has to be done before 'OpenBrowse()' is called */
-  
-  
-  
+
+
+
   /* no filenames.  build one-name (stdio) list (if stdinflag) */
   if (numnames==0) {
-    if (stdinflag) {  
+    if (stdinflag) {
       /* have to malloc namelist[0] so we can free it in deleteFromList() */
       namelist[0] = (char *) malloc(strlen(STDINSTR) + 1);
       if (!namelist[0]) FatalError("unable to to build namelist[0]");
@@ -679,16 +693,16 @@
     }
     else namelist[0] = NULL;
   }
-  
+
   if (numnames) makeDispNames();
-  
-  
-  if (viewonly || autoquit) { 
-    imap = ctrlmap = gmap = browmap = cmtmap = 0; 
+
+
+  if (viewonly || autoquit) {
+    imap = ctrlmap = gmap = browmap = cmtmap = 0;
     novbrowse = 1;
   }
-  
-  
+
+
   /* create the info box window */
   CreateInfo(infogeom);
   XSelectInput(theDisp, infoW, ExposureMask | ButtonPressMask | KeyPressMask
@@ -698,12 +712,12 @@
     RedrawInfo(0,0,1000,1000);  /* explicit draw if mapped */
     XFlush(theDisp);
   }
-  
-  
+
+
   /* create the control box window */
   CreateCtrl(ctrlgeom);
   epicMode = EM_RAW;   SetEpicMode();
-  
+
   XSelectInput(theDisp, ctrlW, ExposureMask | ButtonPressMask | KeyPressMask
 	       | StructureNotifyMask);
   if (ctrlmap < 0) {    /* map iconified */
@@ -719,22 +733,22 @@
     RedrawCtrl(0,0,1000,1000);   /* explicit draw if mapped */
     XFlush(theDisp);
   }
-  
+
   fixDispNames();
   ChangedCtrlList();
-  
+
   /* disable root modes if using non-default visual */
   if (!defaultVis) {
     for (i=RMB_ROOT; i<RMB_MAX; i++) rootMB.dim[i] = 1;
   }
-  
-  
+
+
   /* create the directory window */
   CreateDirW(NULL);
   XSelectInput(theDisp, dirW, ExposureMask | ButtonPressMask | KeyPressMask);
   browseCB.val = browseMode;
   savenormCB.val = savenorm;
-  
+
   /* create the gamma window */
   CreateGam(gamgeom, (gamset) ? gamval : -1.0,
 	    (cgamset) ? rgamval : -1.0,
@@ -744,60 +758,60 @@
   XSelectInput(theDisp, gamW, ExposureMask | ButtonPressMask | KeyPressMask
 	       | StructureNotifyMask
 	       | (cmapInGam ? ColormapChangeMask : 0));
-  
+
   GamBox(gmap);     /* map it (or not) */
-  
-  
-  
+
+
+
   stdnfcols = 0;   /* so we don't try to free any if we don't create any */
-  
+
   if (!novbrowse) {
     MakeBrowCmap();
     /* create the visual browser window */
     CreateBrowse(browgeom, fgstr, bgstr, histr, lostr);
-    
+
     if (browmap) OpenBrowse();
   }
   else windowMB.dim[WMB_BROWSE] = 1;    /* disable visual schnauzer */
-  
-  
+
+
   CreateTextWins(textgeom, cmtgeom);
   if (cmtmap) OpenCommentText();
-  
-  
+
+
   /* create the ps window */
   CreatePSD(NULL);
   XSetTransientForHint(theDisp, psW, dirW);
   encapsCB.val = preview;
   pscompCB.val = pscomp;
-  
-  
+
+
 #ifdef HAVE_JPEG
   CreateJPEGW();
   XSetTransientForHint(theDisp, jpegW, dirW);
 #endif
-  
+
 #ifdef HAVE_TIFF
   CreateTIFFW();
   XSetTransientForHint(theDisp, tiffW, dirW);
 #endif
-  
-  
+
+
   LoadFishCursors();
   SetCursors(-1);
-  
-  
+
+
   /* if we're not on a colormapped display, turn off rwcolor */
   if (!CMAPVIS(theVisual)) {
     if (rwcolor) fprintf(stderr, "xv: not a colormapped display.  %s\n",
 			 "'rwcolor' turned off.");
-    
+
     allocMode = AM_READONLY;
     dispMB.flags[DMB_COLRW] = 0;  /* de-'check' */
     dispMB.dim[DMB_COLRW] = 1;    /* and dim it */
   }
-  
-  
+
+
   if (force24) {
     Set824Menus(PIC24);
     conv24MB.flags[CONV24_LOCK]  = 1;
@@ -812,15 +826,15 @@
     Set824Menus(PIC8);     /* default mode */
     picType = PIC8;
   }
-  
-  
-  
+
+
+
   /* make std colormap, maybe */
   ChangeCmapMode(colorMapMode, 0, 0);
 
 
-  
-  
+
+
   /* Do The Thing... */
   mainLoop();
   Quit(0);
@@ -832,12 +846,12 @@
 /*****************************************************/
 static void makeDirectCmap()
 {
-  int    i, j, cmaplen, numgot;
+  int    i, cmaplen, numgot;
   byte   origgot[256];
   XColor c;
   u_long rmask, gmask, bmask;
   int    rshift, gshift, bshift;
-  
+
 
   rmask = theVisual->red_mask;
   gmask = theVisual->green_mask;
@@ -849,22 +863,22 @@
 
   if (rshift<0) rmask = rmask << (-rshift);
            else rmask = rmask >> rshift;
-  
+
   if (gshift<0) gmask = gmask << (-gshift);
            else gmask = gmask >> gshift;
-  
+
   if (bshift<0) bmask = bmask << (-bshift);
            else bmask = bmask >> bshift;
 
 
   cmaplen = theVisual->map_entries;
   if (cmaplen>256) cmaplen=256;
-  
+
 
   /* try to alloc a 'cmaplen' long grayscale colormap.  May not get all
      entries for whatever reason.  Build table 'directConv[]' that
      maps range [0..(cmaplen-1)] into set of colors we did get */
-  
+
   for (i=0; i<256; i++) {  origgot[i] = 0;  directConv[i] = 0; }
 
   for (i=numgot=0; i<cmaplen; i++) {
@@ -882,9 +896,9 @@
     }
   }
 
-  
+
   if (numgot == 0) FatalError("Got no entries in DirectColor cmap!\n");
-  
+
   /* directConv may or may not have holes in it. */
   for (i=0; i<cmaplen; i++) {
     if (!origgot[i]) {
@@ -892,10 +906,10 @@
       numbak = numfwd = 0;
       while ((i - numbak) >= 0       && !origgot[i-numbak]) numbak++;
       while ((i + numfwd) <  cmaplen && !origgot[i+numfwd]) numfwd++;
-      
+
       if (i-numbak<0        || !origgot[i-numbak]) numbak = 999;
       if (i+numfwd>=cmaplen || !origgot[i+numfwd]) numfwd = 999;
-      
+
       if      (numbak<numfwd) directConv[i] = directConv[i-numbak];
       else if (numfwd<999)    directConv[i] = directConv[i+numfwd];
       else FatalError("DirectColor cmap:  can't happen!");
@@ -926,14 +940,14 @@
 {
   if (!vinfo || best<0) return;
 
-  if (vinfo[best].visualid == 
+  if (vinfo[best].visualid ==
       XVisualIDFromVisual(DefaultVisual(theDisp, theScreen))) return;
 
   theVisual = vinfo[best].visual;
 
   if (DEBUG) {
     fprintf(stderr,"%s: using %s visual (0x%0x), depth = %d, screen = %d\n",
-	    cmd, 
+	    cmd,
 	    (vinfo[best].class==StaticGray)  ? "StaticGray" :
 	    (vinfo[best].class==StaticColor) ? "StaticColor" :
 	    (vinfo[best].class==TrueColor)   ? "TrueColor" :
@@ -947,41 +961,41 @@
 	    (int) vinfo[best].red_mask, (int) vinfo[best].green_mask,
 	    (int) vinfo[best].blue_mask, vinfo[best].bits_per_rgb);
   }
-  
+
   dispDEEP  = vinfo[best].depth;
   theScreen = vinfo[best].screen;
   rootW     = RootWindow(theDisp, theScreen);
   ncells    = vinfo[best].colormap_size;
   theCmap   = XCreateColormap(theDisp, rootW, theVisual, AllocNone);
-  
+
   {
     /* create a temporary window using this visual so we can
        create a GC for this visual */
-    
-    Window win;  
+
+    Window win;
     XSetWindowAttributes xswa;
     XGCValues xgcv;
     unsigned long xswamask;
-    
+
     XFlush(theDisp);
     XSync(theDisp, False);
-    
+
     xswa.background_pixel = 0;
     xswa.border_pixel     = 1;
     xswa.colormap         = theCmap;
     xswamask = CWBackPixel | CWBorderPixel | CWColormap;
-    
+
     win = XCreateWindow(theDisp, rootW, 0, 0, 100, 100, 2, (int) dispDEEP,
 			InputOutput, theVisual, xswamask, &xswa);
-    
+
     XFlush(theDisp);
     XSync(theDisp, False);
-    
+
     theGC = XCreateGC(theDisp, win, 0L, &xgcv);
-    
+
     XDestroyWindow(theDisp, win);
   }
-  
+
   vrWIDE = dispWIDE  = DisplayWidth(theDisp,theScreen);
   vrHIGH = dispHIGH  = DisplayHeight(theDisp,theScreen);
   maxWIDE = dispWIDE;  maxHIGH = dispHIGH;
@@ -1037,8 +1051,8 @@
       fprintf(stderr,"%s: unable to parse 'aspect' resource\n",cmd);
     else defaspect = (float) n / (float) d;
   }
-      
-  if (rd_flag("2xlimit"))        limit2x     = def_int;      
+
+  if (rd_flag("2xlimit"))        limit2x     = def_int;
   if (rd_flag("auto4x3"))        auto4x3     = def_int;
   if (rd_flag("autoClose"))      autoclose   = def_int;
   if (rd_flag("autoCrop"))       autocrop    = def_int;
@@ -1073,7 +1087,7 @@
 
   if (rd_str ("expand")) {
     if (index(def_str, ':')) {
-      if (sscanf(def_str, "%lf:%lf", &hexpand, &vexpand)!=2) 
+      if (sscanf(def_str, "%lf:%lf", &hexpand, &vexpand)!=2)
 	{ hexpand = vexpand = 1.0; }
     }
     else hexpand = vexpand = atof(def_str);
@@ -1108,7 +1122,7 @@
   if (rd_flag("ownCmap"))        owncmap     = def_int;
   if (rd_flag("perfect"))        perfect     = def_int;
   if (rd_flag("popupKludge"))    winCtrPosKludge = def_int;
-  if (rd_str ("print"))          strncpy(printCmd, def_str, 
+  if (rd_str ("print"))          strncpy(printCmd, def_str,
 					 (size_t) PRINTCMDLEN);
   if (rd_flag("pscompress"))     pscomp      = def_int;
   if (rd_flag("pspreview"))      preview     = def_int;
@@ -1146,7 +1160,7 @@
 
     not_in_first_half = 0;
 
-    if (argv[i][0] != '-' && argv[i][0] != '+') { 
+    if (argv[i][0] != '-' && argv[i][0] != '+') {
       /* a file name.  put it in list */
 
       if (!nostat) {
@@ -1186,54 +1200,54 @@
 
     else if (!argcmp(argv[i],"-best24",3,0,&pm))          /* -best */
       conv24 = CONV24_BEST;
-    
+
     else if (!argcmp(argv[i],"-bg",3,0,&pm))              /* bg color */
       { if (++i<argc) bgstr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-black",3,0,&pm))           /* black color */
       { if (++i<argc) blackstr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-bw",3,0,&pm))              /* border width */
       { if (++i<argc) bwidth=atoi(argv[i]); }
-    
+
     else if (!argcmp(argv[i],"-cecmap",4,1,&cmapInGam));  /* cmapInGam */
-    
+
     else if (!argcmp(argv[i],"-cegeometry",4,0,&pm))      /* gammageom */
       { if (++i<argc) gamgeom = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-cemap",4,1,&gmap));        /* gmap */
-    
+
     else if (!argcmp(argv[i],"-cgamma",4,0,&pm)) {        /* color gamma */
       if (i+3<argc) {
-	rgamval = atof(argv[++i]); 
-	ggamval = atof(argv[++i]); 
-	bgamval = atof(argv[++i]); 
+	rgamval = atof(argv[++i]);
+	ggamval = atof(argv[++i]);
+	bgamval = atof(argv[++i]);
       }
       cgamset++;
     }
-    
+
     else if (!argcmp(argv[i],"-cgeometry",4,0,&pm))	  /* ctrlgeom */
       { if (++i<argc) ctrlgeom = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-clear",4,1,&clrroot));	  /* clear */
     else if (!argcmp(argv[i],"-close",4,1,&autoclose));	  /* close */
     else if (!argcmp(argv[i],"-cmap", 3,1,&ctrlmap));	  /* ctrlmap */
 
     else if (!argcmp(argv[i],"-cmtgeometry",5,0,&pm))	  /* comment geom */
       { if (++i<argc) cmtgeom = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-cmtmap",5,1,&cmtmap));	  /* map cmt window */
-    
+
     else if (!argcmp(argv[i],"-crop",3,0,&pm)) {          /* crop */
       if (i+4<argc) {
-	acropX = atoi(argv[++i]); 
-	acropY = atoi(argv[++i]); 
-	acropW = atoi(argv[++i]); 
-	acropH = atoi(argv[++i]); 
+	acropX = atoi(argv[++i]);
+	acropY = atoi(argv[++i]);
+	acropW = atoi(argv[++i]);
+	acropH = atoi(argv[++i]);
       }
       acrop++;
     }
-    
+
     else if (!argcmp(argv[i],"-cursor",3,0,&pm))	  /* cursor */
       { if (++i<argc) curstype = atoi(argv[i]); }
 
@@ -1265,7 +1279,7 @@
     else if (!argcmp(argv[i],"-expand",2,0,&pm)) {	  /* expand factor */
       if (++i<argc) {
 	if (index(argv[i], ':')) {
-	  if (sscanf(argv[i], "%lf:%lf", &hexpand, &vexpand)!=2) 
+	  if (sscanf(argv[i], "%lf:%lf", &hexpand, &vexpand)!=2)
 	    { hexpand = vexpand = 1.0; }
 	}
 	else hexpand = vexpand = atof(argv[i]);
@@ -1274,47 +1288,47 @@
 
     else if (!argcmp(argv[i],"-fg",3,0,&pm))              /* fg color */
       { if (++i<argc) fgstr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-fixed",3,1,&fixedaspect)); /* fix asp. ratio */
-    
+
     else if (!argcmp(argv[i],"-flist",3,0,&pm))           /* file list */
       { if (++i<argc) flistName = argv[i]; }
 
     else if (!argcmp(argv[i],"-gamma",3,0,&pm))	          /* gamma */
       { if (++i<argc) gamval = atof(argv[i]);  gamset++; }
-    
+
     else if (!argcmp(argv[i],"-geometry",3,0,&pm))	  /* geometry */
       { if (++i<argc) maingeom = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-grabdelay",3,0,&pm))	  /* grabDelay */
       { if (++i<argc) grabDelay = atoi(argv[i]); }
-    
+
     else if (!argcmp(argv[i],"-gsdev",4,0,&pm))	          /* gsDevice */
       { if (++i<argc) gsDev = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-gsgeom",4,0,&pm))          /* gsGeometry */
       { if (++i<argc) gsGeomStr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-gsres",4,0,&pm))           /* gsResolution */
       { if (++i<argc) gsRes=abs(atoi(argv[i])); }
-    
+
     else if (!argcmp(argv[i],"-hflip",3,1,&autohflip));   /* hflip */
 
     else if (!argcmp(argv[i],"-hi",3,0,&pm))	          /* highlight */
       { if (++i<argc) histr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-hist", 4,1,&autohisteq));  /* hist eq */
 
     else if (!argcmp(argv[i],"-hsv",   3,1,&hsvmode));     /* hsvmode */
 
     else if (!argcmp(argv[i],"-icgeometry",4,0,&pm))       /* icon geometry */
       { if (++i<argc) icongeom = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-iconic",4,1,&startIconic)); /* iconic */
-    
+
     else if (!argcmp(argv[i],"-igeometry",3,0,&pm))        /* infogeom */
       { if (++i<argc) infogeom = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-imap",     3,1,&imap));        /* imap */
     else if (!argcmp(argv[i],"-lbrowse",  3,1,&browseMode));  /* browse mode */
 
@@ -1323,8 +1337,8 @@
 
     else if (!argcmp(argv[i],"-loadclear",4,1,&clearonload)); /* clearonload */
 
-    
-    else not_in_first_half = 1;     
+
+    else not_in_first_half = 1;
 
 
 
@@ -1339,18 +1353,18 @@
     if (!argcmp(argv[i],"-max",4,1,&automax));	        /* auto maximize */
     else if (!argcmp(argv[i],"-maxpect",5,1,&pm))       /* auto maximize */
       { automax=pm; fixedaspect=pm; }
-    
+
     else if (!argcmp(argv[i],"-mfn",3,0,&pm))           /* mono font name */
       { if (++i<argc) monofontname = argv[i]; }
 
     else if (!argcmp(argv[i],"-mono",3,1,&mono));	/* mono */
-    
+
     else if (!argcmp(argv[i],"-name",3,0,&pm))          /* name */
       { if (++i<argc) winTitle = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-ncols",3,0,&pm))        /* ncols */
       { if (++i<argc) ncols=abs(atoi(argv[i])); }
-    
+
     else if (!argcmp(argv[i],"-ninstall",  3,1,&ninstall));   /* inst cmaps?*/
     else if (!argcmp(argv[i],"-nodecor",   4,1,&nodecor));
     else if (!argcmp(argv[i],"-nofreecols",4,1,&noFreeCols));
@@ -1367,61 +1381,61 @@
 
     else if (!argcmp(argv[i],"-preset",3,0,&pm))      /* preset */
       { if (++i<argc) preset=abs(atoi(argv[i])); }
-    
+
     else if (!argcmp(argv[i],"-quick24",5,0,&pm))     /* quick 24-to-8 conv */
       conv24 = CONV24_FAST;
-    
+
     else if (!argcmp(argv[i],"-quit",   2,1,&autoquit));   /* auto-quit */
     else if (!argcmp(argv[i],"-random", 4,1,&randomShow)); /* random */
     else if (!argcmp(argv[i],"-raw",    4,1,&autoraw));    /* force raw */
 
     else if (!argcmp(argv[i],"-rbg",3,0,&pm))      /* root background color */
       { if (++i<argc) rootbgstr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-rfg",3,0,&pm))      /* root foreground color */
       { if (++i<argc) rootfgstr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-rgb",4,1,&pm))      /* rgb mode */
       hsvmode = !pm;
-    
+
     else if (!argcmp(argv[i],"-RM",3,0,&pm))	   /* auto-delete */
       autoDelete = 1;
-    
+
     else if (!argcmp(argv[i],"-rmode",3,0,&pm))	   /* root pattern */
-      { if (++i<argc) rootMode = atoi(argv[i]); 
+      { if (++i<argc) rootMode = atoi(argv[i]);
 	useroot++;  rmodeset++;
       }
-    
+
     else if (!argcmp(argv[i],"-root",4,1,&useroot));  /* use root window */
-    
+
     else if (!argcmp(argv[i],"-rotate",4,0,&pm))      /* rotate */
       { if (++i<argc) autorotate = atoi(argv[i]); }
-    
+
     else if (!argcmp(argv[i],"-rv",3,1,&revvideo));   /* reverse video */
     else if (!argcmp(argv[i],"-rw",3,1,&rwcolor));    /* use r/w color */
 
     else if (!argcmp(argv[i],"-slow24",3,0,&pm))      /* slow 24->-8 conv.*/
       conv24 = CONV24_SLOW;
-    
+
     else if (!argcmp(argv[i],"-smooth",3,1,&autosmooth));  /* autosmooth */
     else if (!argcmp(argv[i],"-stdcmap",3,1,&stdcmap));    /* use stdcmap */
 
     else if (!argcmp(argv[i],"-tgeometry",2,0,&pm))	   /* textview geom */
       { if (++i<argc) textgeom = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-vflip",3,1,&autovflip));	   /* vflip */
     else if (!argcmp(argv[i],"-viewonly",4,1,&viewonly));  /* viewonly */
 
     else if (!argcmp(argv[i],"-visual",4,0,&pm))           /* visual */
       { if (++i<argc) visualstr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-vsdisable",4,1,&novbrowse)); /* disable sch? */
-    
+
     else if (!argcmp(argv[i],"-vsgeometry",4,0,&pm))	/* visSchnauzer geom */
       { if (++i<argc) browgeom = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-vsmap",4,1,&browmap));	/* visSchnauzer map */
-    
+
     else if (!argcmp(argv[i],"-vsperfect",3,1,&browPerfect));	/* vs perf. */
 
     else if (!argcmp(argv[i],"-wait",3,0,&pm)) {        /* secs betwn pics */
@@ -1430,12 +1444,12 @@
 	if (waitsec<0) waitsec = 0;
       }
     }
-    
+
     else if (!argcmp(argv[i],"-white",3,0,&pm))	        /* white color */
       { if (++i<argc) whitestr = argv[i]; }
-    
+
     else if (!argcmp(argv[i],"-wloop",3,1,&waitloop));	/* waitloop */
-    
+
     else if (not_in_first_half) cmdSyntax();
   }
 
@@ -1462,7 +1476,7 @@
   }
 
 
-  if (flistName) 
+  if (flistName)
     add_filelist_to_namelist(flistName, namelist, &numnames, MAXNAMES);
 
   RANGE(curstype,0,254);
@@ -1475,16 +1489,16 @@
 
   /* if using root, generally gotta map ctrl window, 'cause there won't be
      any way to ask for it.  (no kbd or mouse events from rootW) */
-  if (useroot && !autoquit) ctrlmap = -1;    
+  if (useroot && !autoquit) ctrlmap = -1;
+
 
-  
   if (abs(autorotate) !=   0 && abs(autorotate) != 90 &&
       abs(autorotate) != 180 && abs(autorotate) != 270) {
     fprintf(stderr,"Invalid auto rotation value (%d) ignored.\n", autorotate);
     fprintf(stderr,"  (Valid values:  0, +-90, +-180, +-270)\n");
 
     autorotate = 0;
-  } 
+  }
 
 
   if (grabDelay < 0 || grabDelay > 15) {
@@ -1498,7 +1512,7 @@
     fprintf(stderr,"  (Valid values:  1, 2, 3, 4)\n");
 
     preset = 0;
-  } 
+  }
 
   if (waitsec < 0) noFreeCols = 0;   /* disallow nfc if not doing slideshow */
   if (noFreeCols && perfect) { perfect = 0;  owncmap = 1; }
@@ -1512,13 +1526,13 @@
 
   defaultCmapMode = colorMapMode;  /* default mode for 8-bit images */
 
-  if (nopos) { 
+  if (nopos) {
     maingeom = infogeom = ctrlgeom = gamgeom = browgeom = textgeom = NULL;
     cmtgeom = NULL;
   }
 
   /* if -root and -maxp, disallow 'integer' tiling modes */
-  if (useroot && fixedaspect && automax && !rmodeset && 
+  if (useroot && fixedaspect && automax && !rmodeset &&
       (rootMode == RM_TILE || rootMode == RM_IMIRROR))
     rootMode = RM_CSOLID;
 }
@@ -1656,7 +1670,7 @@
 /***********************************/
 static void rmodeSyntax()
 {
-  fprintf(stderr,"%s: unknown root mode '%d'.  Valid modes are:\n", 
+  fprintf(stderr,"%s: unknown root mode '%d'.  Valid modes are:\n",
 	  cmd, rootMode);
   fprintf(stderr,"\t0: tiling\n");
   fprintf(stderr,"\t1: integer tiling\n");
@@ -1679,13 +1693,11 @@
      int  minlen, plusallowed;
      int *plusminus;
 {
-  /* does a string compare between a1 and a2.  To return '0', a1 and a2 
+  /* does a string compare between a1 and a2.  To return '0', a1 and a2
      must match to the length of a2, and that length has to
      be at least 'minlen'.  Otherwise, return non-zero.  plusminus set to '1'
      if '-option', '0' if '+option' */
 
-  int i;
-
   if ((strlen(a1) < (size_t) minlen) || (strlen(a2) < (size_t) minlen))
     return 1;
   if (strlen(a1) > strlen(a2)) return 1;
@@ -1694,7 +1706,7 @@
 
   if (a1[0]=='-' || (plusallowed && a1[0]=='+')) {
     /* only set if we match */
-    *plusminus = (a1[0] == '-');    
+    *plusminus = (a1[0] == '-');
     return 0;
   }
 
@@ -1721,8 +1733,7 @@
   int   oldCXOFF, oldCYOFF, oldCWIDE, oldCHIGH, wascropped;
   char *tmp;
   char *fullname,       /* full name of the original file */
-        filename[512],  /* full name of file to load (could be /tmp/xxx)*/
-        globnm[512];    /* globbed version of fullname of orig file */
+        filename[512];  /* full name of file to load (could be /tmp/xxx)*/
 
   xvbzero((char *) &pinfo, sizeof(PICINFO));
 
@@ -1748,7 +1759,7 @@
 
   /* if we're not loading next or prev page in a multi-page doc, kill off
      page files */
-  if (strlen(pageBaseName) && filenum!=OP_PAGEDN && filenum!=OP_PAGEUP) 
+  if (strlen(pageBaseName) && filenum!=OP_PAGEDN && filenum!=OP_PAGEUP)
     killpage = 1;
 
 
@@ -1799,7 +1810,7 @@
   }
 
   else if (filenum == PADDED) {
-    /* need fullfname (used for window/icon name), 
+    /* need fullfname (used for window/icon name),
        basefname(compute from fullfname) */
 
     i = LoadPad(&pinfo, fullfname);
@@ -1864,7 +1875,7 @@
 
 
   /* chop off trailing ".Z", ".z", or ".gz" from displayed basefname, if any */
-  if (strlen(basefname) > (size_t) 2     && 
+  if (strlen(basefname) > (size_t) 2     &&
       strcmp(basefname+strlen(basefname)-2,".Z")==0)
     basefname[strlen(basefname)-2]='\0';
   else {
@@ -1872,7 +1883,7 @@
     if (strlen(basefname)>2 && strcmp(basefname+strlen(basefname)-2,".Z")==0)
       basefname[strlen(basefname)-2]='\0';
 
-    else if (strlen(basefname)>3 && 
+    else if (strlen(basefname)>3 &&
 	     strcmp(basefname+strlen(basefname)-3,".gz")==0)
       basefname[strlen(basefname)-3]='\0';
 #endif /* GUNZIP */
@@ -1881,7 +1892,7 @@
 
   if (filenum == LOADPIC && ISPIPE(fullname[0])) {
     /* if we're reading from a pipe, 'filename' will have the /tmp/xvXXXXXX
-       filename, and we can skip a lot of stuff:  (such as prepending 
+       filename, and we can skip a lot of stuff:  (such as prepending
        'initdir' to relative paths, dealing with reading from stdin, etc. */
 
     /* at this point, fullname = "! do some commands",
@@ -1891,11 +1902,11 @@
 
   else {  /* NOT reading from a PIPE */
 
-    /* if fullname doesn't start with a '/' (ie, it's a relative path), 
-       (and it's not LOADPIC and it's not the special case '<stdin>') 
+    /* if fullname doesn't start with a '/' (ie, it's a relative path),
+       (and it's not LOADPIC and it's not the special case '<stdin>')
        then we need to prepend a directory name to it:
-       
-       prepend 'initdir', 
+
+       prepend 'initdir',
        if we have a searchdir (ie, we have multiple places to look),
              see if such a file exists (via fopen()),
        if it does, we're done.
@@ -1904,7 +1915,7 @@
        if it does, we're done.
        if it doesn't, remove all prepended directories, and fall through
              to error code below.  */
-    
+
     if (filenum!=LOADPIC && fullname[0]!='/' && strcmp(fullname,STDINSTR)!=0) {
       char *tmp1;
 
@@ -1954,26 +1965,30 @@
 	}
       }
     }
-    
+
     strcpy(filename, fullname);
-    
-    
+
+
     /* if the file is STDIN, write it out to a temp file */
 
     if (strcmp(filename,STDINSTR)==0) {
-      FILE *fp;
+      FILE *fp = NULL;
 
-#ifndef VMS      
+#ifndef VMS
       sprintf(filename,"%s/xvXXXXXX",tmpdir);
 #else /* it is VMS */
       sprintf(filename, "[]xvXXXXXX");
 #endif
+
+#ifdef USE_MKSTEMP
+      fp = fdopen(mkstemp(filename), "w");
+#else
       mktemp(filename);
+      fp = fopen(filename, "w");
+#endif
+      if (!fp) FatalError("openPic(): can't write temporary file");
 
       clearerr(stdin);
-      fp = fopen(filename,"w");
-      if (!fp) FatalError("openPic(): can't write temporary file");
-    
       while ( (i=getchar()) != EOF) putc(i,fp);
       fclose(fp);
 
@@ -2003,7 +2018,7 @@
 	) {
 
       filetype = ReadFileType(tmpname);    /* and try again */
-      
+
       /* if we made a /tmp file (from stdin, etc.) won't need it any more */
       if (strcmp(fullname,filename)!=0) unlink(filename);
 
@@ -2084,7 +2099,7 @@
   /**************/
   /* SUCCESS!!! */
   /**************/
-    
+
 
  GOTIMAGE:
   /* successfully read this picture.  No failures from here on out
@@ -2097,7 +2112,7 @@
   if (conv24MB.flags[CONV24_LOCK]) {  /* locked */
     if (pinfo.type==PIC24 && picType==PIC8) {           /* 24 -> 8 bit */
       byte *pic8;
-      pic8 = Conv24to8(pinfo.pic, pinfo.w, pinfo.h, ncols, 
+      pic8 = Conv24to8(pinfo.pic, pinfo.w, pinfo.h, ncols,
 		       pinfo.r, pinfo.g, pinfo.b);
       free(pinfo.pic);
       pinfo.pic = pic8;
@@ -2108,7 +2123,7 @@
 
     else if (pinfo.type!=PIC24 && picType==PIC24) {    /* 8 -> 24 bit */
       byte *pic24;
-      pic24 = Conv8to24(pinfo.pic, pinfo.w, pinfo.h, 
+      pic24 = Conv8to24(pinfo.pic, pinfo.w, pinfo.h,
 			pinfo.r, pinfo.g, pinfo.b);
       free(pinfo.pic);
       pinfo.pic  = pic24;
@@ -2144,7 +2159,7 @@
 
   if (mainW && !useroot) {
     /* avoid generating excess configure events while we resize the window */
-    XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask 
+    XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask
 		 | StructureNotifyMask
                  | ButtonPressMask | KeyReleaseMask
                  | EnterWindowMask | LeaveWindowMask);
@@ -2162,7 +2177,7 @@
   pHIGH = pinfo.h;
   if (pinfo.frmType >=0) SetDirSaveMode(F_FORMAT, pinfo.frmType);
   if (pinfo.colType >=0) SetDirSaveMode(F_COLORS, pinfo.colType);
-  
+
   SetISTR(ISTR_FORMAT, pinfo.fullInfo);
   strcpy(formatStr, pinfo.shrtInfo);
   picComments = pinfo.comment;
@@ -2195,11 +2210,11 @@
 
 
   SetISTR(ISTR_INFO,formatStr);
-	
+
   SetInfoMode(INF_PART);
-  SetISTR(ISTR_FILENAME, 
-	  (filenum==DFLTPIC || filenum==GRABBED || frompipe)
-	  ? "<none>" : basefname);
+  SetISTR(ISTR_FILENAME, "%s",
+	  (filenum==DFLTPIC || filenum==GRABBED || frompipe) ?
+	  "<none>" : basefname);
 
   SetISTR(ISTR_RES,"%d x %d",pWIDE,pHIGH);
   SetISTR(ISTR_COLOR, "");
@@ -2219,7 +2234,7 @@
 
 
   /* handle various 'auto-whatever' command line options
-     Note that if 'frompoll' is set, things that have to do with 
+     Note that if 'frompoll' is set, things that have to do with
      setting the expansion factor are skipped, as we'll want it to
      display in the (already-existing) window at the same size */
 
@@ -2254,7 +2269,7 @@
       w = eWIDE;  h = (w*3) / 4;
       eWIDE = w;  eHIGH = h;
     }
-    
+
 
     if (eWIDE != cWIDE || eHIGH != cHIGH) epic = (byte *) NULL;
 
@@ -2306,14 +2321,14 @@
     aspWIDE = eWIDE;  aspHIGH = eHIGH;   /* aspect-corrected eWIDE,eHIGH */
 
     if (hexpand < 0.0) eWIDE=(int)(aspWIDE / -hexpand);  /* neg:  reciprocal */
-                  else eWIDE=(int)(aspWIDE *  hexpand);  
+                  else eWIDE=(int)(aspWIDE *  hexpand);
     if (vexpand < 0.0) eHIGH=(int)(aspHIGH / -vexpand);  /* neg:  reciprocal */
-                  else eHIGH=(int)(aspHIGH *  vexpand);  
+                  else eHIGH=(int)(aspHIGH *  vexpand);
 
     if (maingeom) {
       /* deal with geometry spec.  Note, they shouldn't have given us
        *both* an expansion factor and a geomsize.  The geomsize wins out */
-    
+
       int i,x,y,gewide,gehigh;  u_int w,h;
 
       gewide = eWIDE;  gehigh = eHIGH;
@@ -2321,11 +2336,11 @@
 
       if (i&WidthValue)  gewide = (int) w;
       if (i&HeightValue) gehigh = (int) h;
-      
+
       /* handle case where the pinheads only specified width *or * height */
       if (( i&WidthValue && ~i&HeightValue) ||
 	  (~i&WidthValue &&  i&HeightValue)) {
-    
+
 	if (i&WidthValue) { gehigh = (aspHIGH * gewide) / pWIDE; }
 	             else { gewide = (aspWIDE * gehigh) / pHIGH; }
       }
@@ -2391,7 +2406,7 @@
 
     /* if we're using an integer tiled root mode, truncate eWIDE/eHIGH to
        be an integer divisor of the display size */
-      
+
     if (useroot && (rootMode == RM_TILE || rootMode == RM_IMIRROR)) {
       /* make picture size a divisor of the rootW size.  round down */
       i = (dispWIDE + eWIDE-1) / eWIDE;   eWIDE = (dispWIDE + i-1) / i;
@@ -2419,7 +2434,7 @@
 
     /* 'dithering' makes no sense in 24-bit mode */
     if (picType == PIC24 && epicMode == EM_DITH) epicMode = EM_RAW;
-    
+
     SetEpicMode();
   } /* end of !frompoll */
 
@@ -2450,7 +2465,7 @@
   if (useroot) mainW = vrootW;
   if (eWIDE != cWIDE || eHIGH != cHIGH) epic = (byte *) NULL;
 
-  NewPicGetColors(autonorm, autohisteq); 
+  NewPicGetColors(autonorm, autohisteq);
 
   GenerateEpic(eWIDE, eHIGH);     /* want to dither *after* color allocs */
   CreateXImage();
@@ -2474,7 +2489,7 @@
   SetISTR(ISTR_INFO,"%s  %s  %s", formatStr,
 	  (picType==PIC8) ? "8-bit mode." : "24-bit mode.",
 	  tmp);
-	
+
   SetInfoMode(INF_FULL);
   if (freename) free(fullname);
 
@@ -2499,16 +2514,16 @@
 
   return 1;
 
-  
+
  FAILED:
   SetCursors(-1);
   KillPageFiles(pinfo.pagebname, pinfo.numpages);
 
-  if (fullname && strcmp(fullname,filename)!=0) 
+  if (fullname && strcmp(fullname,filename)!=0)
     unlink(filename);   /* kill /tmp file */
   if (freename) free(fullname);
 
-  if (!fromint && !polling && filenum>=0 && filenum<nList.nstr) 
+  if (!fromint && !polling && filenum>=0 && filenum<nList.nstr)
     deleteFromList(filenum);
 
   if (polling) sleep(1);
@@ -2546,7 +2561,7 @@
   fp = xv_fopen(fname, "r");
   if (!fp) return RFT_ERROR;
 
-  n = fread(magicno, (size_t) 1, (size_t) 30, fp);  
+  n = fread(magicno, (size_t) 1, (size_t) 30, fp);
   fclose(fp);
 
   if (n<30) return RFT_UNKNOWN;    /* files less than 30 bytes long... */
@@ -2559,7 +2574,7 @@
   else if (strncmp((char *) magicno,"VIEW", (size_t) 4)==0 ||
 	   strncmp((char *) magicno,"WEIV", (size_t) 4)==0)     rv = RFT_PM;
 
-  else if (magicno[0] == 'P' && magicno[1]>='1' && 
+  else if (magicno[0] == 'P' && magicno[1]>='1' &&
 	   magicno[1]<='6')                             rv = RFT_PBM;
 
   /* note: have to check XPM before XBM, as first 2 chars are the same */
@@ -2586,7 +2601,7 @@
 
   else if (magicno[0]==0x0a && magicno[1] <= 5)         rv = RFT_PCX;
 
-  else if (strncmp((char *) magicno,   "FORM", (size_t) 4)==0 && 
+  else if (strncmp((char *) magicno,   "FORM", (size_t) 4)==0 &&
 	   strncmp((char *) magicno+8, "ILBM", (size_t) 4)==0)   rv = RFT_IFF;
 
   else if (magicno[0]==0 && magicno[1]==0 &&
@@ -2597,12 +2612,12 @@
   else if (magicno[4]==0x00 && magicno[5]==0x00 &&
 	   magicno[6]==0x00 && magicno[7]==0x07)        rv = RFT_XWD;
 
-  else if (strncmp((char *) magicno,"SIMPLE  ", (size_t) 8)==0 && 
+  else if (strncmp((char *) magicno,"SIMPLE  ", (size_t) 8)==0 &&
 	   magicno[29] == 'T')                          rv = RFT_FITS;
-  
+
 
 #ifdef HAVE_JPEG
-  else if (magicno[0]==0xff && magicno[1]==0xd8 && 
+  else if (magicno[0]==0xff && magicno[1]==0xd8 &&
 	   magicno[2]==0xff)                            rv = RFT_JFIF;
 #endif
 
@@ -2668,7 +2683,7 @@
 #endif
 
 #ifdef HAVE_TIFF
-  case RFT_TIFF:    rv = LoadTIFF  (fname, pinfo);           break;
+  case RFT_TIFF:    rv = LoadTIFF  (fname, pinfo, quick);    break;
 #endif
 
 #ifdef HAVE_PDS
@@ -2703,7 +2718,7 @@
      to what it was.  necessary because uncompress doesn't handle files
      that don't end with '.Z' */
 
-  if (strlen(name) >= (size_t) 2            && 
+  if (strlen(name) >= (size_t) 2            &&
       strcmp(name + strlen(name)-2,".Z")!=0 &&
       strcmp(name + strlen(name)-2,".z")!=0) {
     strcpy(namez, name);
@@ -2721,34 +2736,42 @@
 #endif   /* not VMS and not GUNZIP */
 
 
-  
 #ifndef VMS
   sprintf(uncompname, "%s/xvuXXXXXX", tmpdir);
+#else
+  strcpy(uncompname, "[]xvuXXXXXX");
+#endif
+
+#ifdef USE_MKSTEMP
+  close(mkstemp(uncompname));
+#else
   mktemp(uncompname);
+#endif
+
+#ifndef VMS
   sprintf(buf,"%s -c %s >%s", UNCOMPRESS, fname, uncompname);
 #else /* it IS VMS */
-  strcpy(uncompname, "[]xvuXXXXXX");
-  mktemp(uncompname);
-#  ifdef GUNZIP
+# ifdef GUNZIP
   sprintf(buf,"%s %s %s", UNCOMPRESS, fname, uncompname);
-#  else
+# else
   sprintf(buf,"%s %s", UNCOMPRESS, fname);
-#  endif
+# endif
 #endif
 
   SetISTR(ISTR_INFO, "Uncompressing '%s'...", BaseName(fname));
 #ifndef VMS
-  if (system(buf)) {
+  if (system(buf))
 #else
-  if (!system(buf)) {
+  if (!system(buf))
 #endif
+  {
     SetISTR(ISTR_INFO, "Unable to uncompress '%s'.", BaseName(fname));
     Warning();
     return 0;
   }
 
-#ifndef VMS  
-  /* if we renamed the file to end with a .Z for the sake of 'uncompress', 
+#ifndef VMS
+  /* if we renamed the file to end with a .Z for the sake of 'uncompress',
      rename it back to what it once was... */
 
   if (strlen(namez)) {
@@ -2769,7 +2792,7 @@
     }
    */
 #endif /* not VMS */
-  
+
   return 1;
 }
 
@@ -2798,11 +2821,11 @@
 {
   int i;
 
-  /* some stuff that necessary whenever running an algorithm or 
+  /* some stuff that necessary whenever running an algorithm or
      installing a new 'pic' (or switching 824 modes) */
 
   numcols = 0;   /* gets set by SortColormap:  set to 0 for PIC24 images */
-  for (i=0; i<256; i++) cols[i]=infobg;   
+  for (i=0; i<256; i++) cols[i]=infobg;
 
   if (picType == PIC8) {
     byte trans[256];
@@ -2811,18 +2834,18 @@
   }
 
   if (picType == PIC8) {
-    /* see if image is a b/w bitmap.  
+    /* see if image is a b/w bitmap.
        If so, use '-black' and '-white' colors */
     if (numcols == 2) {
       if ((rMap[0] == gMap[0] && rMap[0] == bMap[0] && rMap[0] == 255) &&
 	  (rMap[1] == gMap[1] && rMap[1] == bMap[1] && rMap[1] ==   0)) {
 	/* 0=wht, 1=blk */
-	rMap[0] = (whtRGB>>16)&0xff;  
-	gMap[0] = (whtRGB>>8)&0xff;  
+	rMap[0] = (whtRGB>>16)&0xff;
+	gMap[0] = (whtRGB>>8)&0xff;
 	bMap[0] = whtRGB&0xff;
 
 	rMap[1] = (blkRGB>>16)&0xff;
-	gMap[1] = (blkRGB>>8)&0xff;  
+	gMap[1] = (blkRGB>>8)&0xff;
 	bMap[1] = blkRGB&0xff;
       }
 
@@ -2852,10 +2875,10 @@
     }
 
     /* save the desired RGB colormap (before dicking with it) */
-    for (i=0; i<numcols; i++) { 
-      rorg[i] = rcmap[i] = rMap[i];  
-      gorg[i] = gcmap[i] = gMap[i];  
-      borg[i] = bcmap[i] = bMap[i];  
+    for (i=0; i<numcols; i++) {
+      rorg[i] = rcmap[i] = rMap[i];
+      gorg[i] = gcmap[i] = gMap[i];
+      borg[i] = bcmap[i] = bMap[i];
     }
   }
 
@@ -2888,7 +2911,7 @@
 {
   /* cmd is something like: "! bggen 100 0 0"
    *
-   * runs command (with "> /tmp/xv******" appended).  
+   * runs command (with "> /tmp/xv******" appended).
    * returns "/tmp/xv******" in fname
    * returns '0' if everything's cool, '1' on error
    */
@@ -2899,8 +2922,12 @@
   if (!cmd || (strlen(cmd) < (size_t) 2)) return 1;
 
   sprintf(tmpname,"%s/xvXXXXXX", tmpdir);
+#ifdef USE_MKSTEMP
+  close(mkstemp(tmpname));
+#else
   mktemp(tmpname);
-  if (tmpname[0] == '\0') {   /* mktemp() blew up */
+#endif
+  if (tmpname[0] == '\0') {   /* mktemp() or mkstemp() blew up */
     sprintf(str,"Unable to create temporary filename.");
     ErrPopUp(str, "\nHow unlikely!");
     return 1;
@@ -2946,7 +2973,7 @@
     while (numnames>0) {
       if (openPic(0)) return;  /* success */
       else {
-	if (polling && !i) 
+	if (polling && !i)
 	  fprintf(stderr,"%s: POLLING: Waiting for file '%s' \n\tto %s\n",
 		  cmd, namelist[0], "be created, or whatever...");
 	i = 1;
@@ -2970,11 +2997,11 @@
   int i;
 
   if (curname>=0) i = curname+1;
-  else if (nList.selected >= 0 && nList.selected < numnames) 
+  else if (nList.selected >= 0 && nList.selected < numnames)
        i = nList.selected;
   else i = 0;
 
- 
+
   while (i<numnames && !openPic(i));
   if (i<numnames) return;    /* success */
 
@@ -2989,7 +3016,7 @@
 
   if (!randomShow) {
     if (curname>=0) i = curname+1;
-    else if (nList.selected >= 0 && nList.selected < numnames) 
+    else if (nList.selected >= 0 && nList.selected < numnames)
       i = nList.selected;
     else i = 0;
 
@@ -3015,7 +3042,7 @@
     if (!randomShow) {
 
       if (curname>=0) i = curname+1;
-      else if (nList.selected >= 0 && nList.selected < numnames) 
+      else if (nList.selected >= 0 && nList.selected < numnames)
 	i = nList.selected;
       else i = 0;
 
@@ -3044,7 +3071,7 @@
   int i;
 
   if (curname>0) i = curname-1;
-  else if (nList.selected>0 && nList.selected < numnames) 
+  else if (nList.selected>0 && nList.selected < numnames)
     i = nList.selected - 1;
   else i = numnames-1;
 
@@ -3089,7 +3116,7 @@
     loadList = (byte *) malloc((size_t) listLen);
     for (k=0; k<listLen; k++) loadList[k] = 0;
   }
-  
+
   if (left_to_load <= 0) {   /* we've loaded all the pics */
     for (k=0; k<listLen; k++) loadList[k] = 0;   /* clear flags */
     left_to_load = listLen;
@@ -3097,7 +3124,7 @@
   }
 
   for (k=abs(random()) % listLen;  loadList[k];  k = (k+1) % listLen);
-  
+
   left_to_load--;
   loadList[k] = TRUE;
 
@@ -3107,13 +3134,13 @@
 /****************/
 static void mainLoop()
 {
-  /* search forward until we manage to display a picture, 
-     then call EventLoop.  EventLoop will eventually return 
+  /* search forward until we manage to display a picture,
+     then call EventLoop.  EventLoop will eventually return
      NEXTPIC, PREVPIC, NEXTQUIT, QUIT, or, if >= 0, a filenum to GOTO */
 
   int i;
 
-  /* if curname<0 (there is no 'current' file), 'Next' means view the 
+  /* if curname<0 (there is no 'current' file), 'Next' means view the
      selected file (or the 0th file, if no selection either), and 'Prev' means
      view the one right before the selected file */
 
@@ -3133,7 +3160,7 @@
     }
 
     else if (i==PREVPIC) {
-      if (curname>0 || (curname<0 && nList.selected>0)) 
+      if (curname>0 || (curname<0 && nList.selected>0))
 	openPrevPic();
     }
 
@@ -3151,7 +3178,7 @@
 
     else if (i==THISNEXT) {  /* open current sel, 'next' until success */
       int j;
-      j = nList.selected;  
+      j = nList.selected;
       if (j<0) j = 0;
       while (j<numnames && !openPic(j));
       if (!pic) openPic(DFLTPIC);
@@ -3219,12 +3246,12 @@
   hints.width = eWIDE;          hints.height = eHIGH;
   hints.max_width  = maxWIDE;   hints.max_height = maxHIGH;
   hints.flags |= USSize | PMaxSize;
-    
+
   xswa.bit_gravity = StaticGravity;
   xswa.background_pixel = bg;
   xswa.border_pixel     = fg;
   xswa.colormap         = theCmap;
-  
+
   xswa.backing_store    = WhenMapped;
 
   /* NOTE: I've turned 'backing-store' off on the image window, as some
@@ -3233,9 +3260,9 @@
      improvement anyway (for the image window), unless you're on a slow
      network.  In any event, I'm not *turning off* backing store, I'm
      just not explicitly turning it *on*.  If your X server is set up
-     that windows, by default, have backing-store turned on, then the 
+     that windows, by default, have backing-store turned on, then the
      image window will, too */
-  
+
   xswamask = CWBackPixel | CWBorderPixel | CWColormap /* | CWBackingStore */;
   if (!clearonload) xswamask |= CWBitGravity;
 
@@ -3251,11 +3278,11 @@
 
     SetWindowPos(&xwa);
     hints.flags = PSize | PMaxSize;
-  } 
+  }
 
   else {
     mainW = XCreateWindow(theDisp,rootW,x,y, (u_int) eWIDE, (u_int) eHIGH,
-			  (u_int) bwidth, (int) dispDEEP, InputOutput, 
+			  (u_int) bwidth, (int) dispDEEP, InputOutput,
 			  theVisual, xswamask, &xswa);
     if (!mainW) FatalError("can't create window!");
 
@@ -3274,8 +3301,8 @@
   xwmh.input = True;
   xwmh.flags = InputHint;
 
-  xwmh.icon_pixmap = iconPix;  
-  xwmh.icon_mask   = iconmask;  
+  xwmh.icon_pixmap = iconPix;
+  xwmh.icon_mask   = iconmask;
   xwmh.flags |= (IconPixmapHint | IconMaskHint);
 
 
@@ -3302,7 +3329,7 @@
   XSetClassHint(theDisp, mainW, &classh);
 
 
-  if (nodecor) {   /* turn of image window decorations (in MWM) */ 
+  if (nodecor) {   /* turn of image window decorations (in MWM) */
     Atom mwm_wm_hints;
     struct s_mwmhints {
       long   flags;
@@ -3311,7 +3338,7 @@
       u_long input_mode;
       long   status;
     } mwmhints;
-    
+
     mwm_wm_hints = XInternAtom(theDisp, "_MOTIF_WM_HINTS", False);
     if (mwm_wm_hints != None) {
       xvbzero((char *) &mwmhints, sizeof(mwmhints));
@@ -3319,13 +3346,13 @@
       mwmhints.decorations = 4;
 
       XChangeProperty(theDisp, mainW, mwm_wm_hints, mwm_wm_hints, 32,
-		      PropModeReplace, (byte *) &mwmhints, 
-		      (int) (sizeof(mwmhints))/4); 
+		      PropModeReplace, (byte *) &mwmhints,
+		      (int) (sizeof(mwmhints))/4);
       XSync(theDisp, False);
     }
   }
 
-    
+
   firstTime = 0;
 }
 
@@ -3366,8 +3393,8 @@
 int   *w, *h;
 {
   /* computes new values of eWIDE and eHIGH which will have aspect ratio
-     'normaspect'.  If 'grow' it will preserve aspect by enlarging, 
-     otherwise, it will shrink to preserve aspect ratio.  
+     'normaspect'.  If 'grow' it will preserve aspect by enlarging,
+     otherwise, it will shrink to preserve aspect ratio.
      Returns these values in 'w' and 'h' */
 
   float xr,yr,curaspect,a,exp;
@@ -3380,14 +3407,14 @@
   curaspect  = xr / yr;
 
   /* if too narrow & shrink, shrink height.  too wide and grow, grow height */
-  if ((curaspect < normaspect && !grow) || 
+  if ((curaspect < normaspect && !grow) ||
       (curaspect > normaspect &&  grow)) {    /* modify height */
     exp = curaspect / normaspect;
     *h = (int) (eHIGH * exp + .5);
   }
 
   /* if too narrow & grow, grow width.  too wide and shrink, shrink width */
-  if ((curaspect < normaspect &&  grow) || 
+  if ((curaspect < normaspect &&  grow) ||
       (curaspect > normaspect && !grow)) {    /* modify width */
     exp = normaspect / curaspect;
     *w = (int) (eWIDE * exp + .5);
@@ -3423,22 +3450,22 @@
   suffix = namelist[0];
   prelen = 0;   /* length of prefix to be removed */
   n = i = 0;    /* shut up pesky compiler warnings */
-  
+
   done = 0;
   while (!done) {
     suffix = (char *) index(suffix,'/');    /* find next '/' in file name */
     if (!suffix) break;
-    
+
     suffix++;                       /* go past it */
     n = suffix - namelist[0];
     for (i=1; i<numnames; i++) {
       if (strncmp(namelist[0], namelist[i], (size_t) n)!=0) { done=1; break; }
     }
-    
+
     if (!done) prelen = n;
   }
-  
-  for (i=0; i<numnames; i++) 
+
+  for (i=0; i<numnames; i++)
     dispnames[i] = namelist[i] + prelen;
 }
 
@@ -3447,20 +3474,20 @@
 static void fixDispNames()
 {
   /* fix dispnames array so that names don't go off right edge */
-  
+
   int   i,j;
   char *tmp;
-  
+
   for (i=j=0; i<numnames; i++) {
     char *dname;
-    
+
     dname = dispnames[i];
     if (StringWidth(dname) > (nList.w-10-16)) {  /* have to trunc. */
       tmp = dname;
       while (1) {
 	tmp = (char *) index(tmp,'/'); /* find next '/' in filename */
 	if (!tmp) { tmp = dname;  break; }
-	
+
 	tmp++;                   /* move to char following the '/' */
 	if (StringWidth(tmp) <= (nList.w-10-16)) { /* is cool now */
 	  j++;  break;
@@ -3484,9 +3511,9 @@
 
   name = GetDirFName();
   GetDirPath(cwd);
-  
+
   AddFNameToCtrlList(cwd, name);
-  
+
   if (select) {
     nList.selected = numnames-1;
     curname = numnames - 1;
@@ -3501,32 +3528,32 @@
      char *fpath, *fname;
 {
   /* stick given path/name into 'namelist'.  Doesn't redraw list */
-  
-  char *fullname, *dname;
+
+  char *fullname;
   char cwd[MAXPATHLEN], globnm[MAXPATHLEN+100];
   int i;
-  
+
   if (!fpath) fpath = "";  /* bulletproofing... */
-  if (!fname) fname = "";  
-  
+  if (!fname) fname = "";
+
   if (numnames == MAXNAMES) return;  /* full up */
-  
+
   /* handle globbing */
   if (fname[0] == '~') {
     strcpy(globnm, fname);
     Globify(globnm);
     fname = globnm;
   }
-  
+
   if (fname[0] != '/') {  /* prepend path */
     strcpy(cwd, fpath);   /* copy it to a modifiable place */
-    
+
     /* make sure fpath has a trailing '/' char */
     if (strlen(cwd)==0 || cwd[strlen(cwd)-1]!='/') strcat(cwd, "/");
-    
+
     fullname = (char *) malloc(strlen(cwd) + strlen(fname) + 2);
     if (!fullname) FatalError("couldn't alloc name in AddFNameToCtrlList()\n");
-    
+
     sprintf(fullname, "%s%s", cwd, fname);
   }
   else {                 /* copy name to fullname */
@@ -3534,15 +3561,15 @@
     if (!fullname) FatalError("couldn't alloc name in AddFNameToCtrlList()\n");
     strcpy(fullname, fname);
   }
-  
-  
+
+
   /* see if this name is a duplicate.  Don't add it if it is. */
   for (i=0; i<numnames; i++)
     if (strcmp(fullname, namelist[i]) == 0) {
       free(fullname);
       return;
     }
-  
+
   namelist[numnames] = fullname;
   numnames++;
   makeDispNames();
@@ -3578,7 +3605,7 @@
   /* called to enable/disable the Prev/Next buttons whenever curname and/or
      numnames and/or nList.selected change */
 
-  /* if curname<0 (there is no 'current' file), 'Next' means view the 
+  /* if curname<0 (there is no 'current' file), 'Next' means view the
      selected file (or the 0th file, if no selection either), and 'Prev' means
      view the one right before the selected file */
 
@@ -3591,15 +3618,15 @@
     BTSetActive(&but[BPREV], (curname>0));
   }
 }
-  
+
 
 /***********************************/
 int DeleteCmd()
 {
   /* 'delete' button was pressed.  Pop up a dialog box to determine
      what should be deleted, then do it.
-     returns '1' if THE CURRENTLY VIEWED entry was deleted from the list, 
-     in which case the 'selected' filename on the ctrl list is now 
+     returns '1' if THE CURRENTLY VIEWED entry was deleted from the list,
+     in which case the 'selected' filename on the ctrl list is now
      different, and should be auto-loaded, or something */
 
   static char *bnames[] = { "\004Disk File", "\nList Entry", "\033Cancel" };
@@ -3616,9 +3643,9 @@
 	  "'Disk File' deletes file associated with selection.");
 
   del = PopUp(str, bnames, 3);
-  
+
   if (del == 2) return 0;   /* cancel */
-  
+
   if (del == 0) {           /* 'Disk File' */
     char *name;
     if (namelist[delnum][0] != '/') {    /* prepend 'initdir' */
@@ -3669,13 +3696,13 @@
 
   if (delnum != numnames-1) {
     /* snip out of namelist and dispnames lists */
-    xvbcopy((char *) &namelist[delnum+1], (char *) &namelist[delnum], 
+    xvbcopy((char *) &namelist[delnum+1], (char *) &namelist[delnum],
 	  (numnames - delnum - 1) * sizeof(namelist[0]));
 
-    xvbcopy((char *) &dispnames[delnum+1], (char *) &dispnames[delnum], 
+    xvbcopy((char *) &dispnames[delnum+1], (char *) &dispnames[delnum],
 	  (numnames - delnum - 1) * sizeof(dispnames[0]));
   }
-  
+
   numnames--;
   if (numnames==0) BTSetActive(&but[BDELETE],0);
   windowMB.dim[WMB_TEXTVIEW] = (numnames==0);
@@ -3686,7 +3713,7 @@
   if (nList.selected >= numnames) nList.selected = numnames-1;
   if (nList.selected < 0) nList.selected = 0;
 
-  SCSetRange(&nList.scrl, 0, numnames - nList.nlines, 
+  SCSetRange(&nList.scrl, 0, numnames - nList.nlines,
 	     nList.scrl.val, nList.nlines-1);
   ScrollToCurrent(&nList);
   DrawCtrlNumFiles();
@@ -3753,7 +3780,7 @@
     if (useroot && resetroot) ClearRoot();
 
     if (mainW == (Window) NULL || useroot) {  /* window not visible */
-      useroot = 0;  
+      useroot = 0;
 
       if (haveoldinfo) {             /* just remap mainW and resize it */
 	XWMHints xwmh;
@@ -3771,8 +3798,8 @@
 	xwmh.input = True;
 	xwmh.flags = InputHint;
 
-	xwmh.icon_pixmap = iconPix;  
-	xwmh.icon_mask   = iconmask;  
+	xwmh.icon_pixmap = iconPix;
+	xwmh.icon_mask   = iconmask;
 	xwmh.flags |= ( IconPixmapHint | IconMaskHint) ;
 
 	xwmh.flags |= StateHint;
@@ -3787,7 +3814,7 @@
       else {                         /* first time.  need to create mainW */
 	mainW = (Window) NULL;
 	createMainWindow(maingeom, fnam);
-	XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask 
+	XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask
 		     | StructureNotifyMask | ButtonPressMask
 		     | KeyReleaseMask | ColormapChangeMask
 		     | EnterWindowMask | LeaveWindowMask );
@@ -3802,7 +3829,7 @@
 
     else {                            /* mainW already visible */
       createMainWindow(maingeom, fnam);
-      XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask 
+      XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask
 		   | StructureNotifyMask | ButtonPressMask
 		   | KeyReleaseMask | ColormapChangeMask
 		   | EnterWindowMask | LeaveWindowMask );
@@ -3845,13 +3872,13 @@
       if (LocalCmap) regen=1;
 
       /* this reallocs the colors */
-      if (colorMapMode==CM_PERFECT || colorMapMode==CM_OWNCMAP) 
+      if (colorMapMode==CM_PERFECT || colorMapMode==CM_OWNCMAP)
 	ChangeCmapMode(CM_NORMAL, 0, 0);
-      
-      
+
+
       XUnmapWindow(theDisp, mainW);
       mainW = vrootW;
-      
+
       if (!ctrlUp) {    /* make sure ctrl is up when going to 'root' mode */
 	XWMHints xwmh;
 	xwmh.input         = True;
@@ -3861,7 +3888,7 @@
 	CtrlBox(1);
       }
     }
-      
+
     useroot = 1;
     rootMode = dispMode - RMB_ROOT;
     ew = eWIDE;  eh = eHIGH;
@@ -3877,7 +3904,7 @@
       GenerateEpic(ew, eh);
       CreateXImage();
     }
-    else if (regen) CreateXImage();                    
+    else if (regen) CreateXImage();
 
     KillOldRootInfo();
     MakeRootPic();
@@ -3954,7 +3981,7 @@
   if (rd_str_cl(name, "", 0)) {     /* sets def_str */
     if (sscanf(def_str, "%d", &def_int) == 1) return 1;
     else {
-      fprintf(stderr, "%s: couldn't read integer value for %s resource\n", 
+      fprintf(stderr, "%s: couldn't read integer value for %s resource\n",
 	      cmd, name);
       return 0;
     }
@@ -3976,14 +4003,14 @@
 char *name;
 {
   /* returns '1' if successful.  result in def_int */
-  
+
   char buf[256];
 
   if (rd_str_cl(name, "", 0)) {  /* sets def_str */
     strcpy(buf, def_str);
     lower_str(buf);
 
-    def_int = (strcmp(buf, "on")==0) || 
+    def_int = (strcmp(buf, "on")==0) ||
               (strcmp(buf, "1")==0) ||
 	      (strcmp(buf, "true")==0) ||
 	      (strcmp(buf, "yes")==0);
@@ -3992,12 +4019,12 @@
 
   else return 0;
 }
-    
+
 
 
 
 static int xrm_initted = 0;
- 
+
 /***********************************/
 int rd_str_cl (name_str, class_str, reinit)
      char *name_str;
@@ -4044,14 +4071,14 @@
       byte *data;
 
       i = XGetWindowProperty(theDisp, RootWindow(theDisp, 0),
-			     resAtom, 0L, 1L, False, 
-			     XA_STRING, &actType, &actFormat, &nitems, &nleft, 
+			     resAtom, 0L, 1L, False,
+			     XA_STRING, &actType, &actFormat, &nitems, &nleft,
 			     (unsigned char **) &data);
       if (i==Success && actType==XA_STRING && actFormat==8) {
 	if (nitems>0 && data) XFree(data);
-	i = XGetWindowProperty(theDisp, RootWindow(theDisp, 0), resAtom, 0L, 
+	i = XGetWindowProperty(theDisp, RootWindow(theDisp, 0), resAtom, 0L,
 			       (long) ((nleft+4+3)/4),
-			       False, XA_STRING, &actType, &actFormat, 
+			       False, XA_STRING, &actType, &actFormat,
 			       &nitems, &nleft, (unsigned char **) &data);
 	if (i==Success && actType==XA_STRING && actFormat==8 && data) {
 	  def_resource = XrmGetStringDatabase((char *) data);
@@ -4064,8 +4091,8 @@
 
 
     if (!gotit) {
-      xrm_str = XResourceManagerString(theDisp); 
-      
+      xrm_str = XResourceManagerString(theDisp);
+
       if (xrm_str) {
 	def_resource = XrmGetStringDatabase(xrm_str);
 	if (DEBUG) fprintf(stderr,"rd_str_cl: Using RESOURCE_MANAGER prop.\n");
@@ -4073,7 +4100,7 @@
       else {    /* no RESOURCE_MANAGER prop.  read from 'likely' file */
 	char foo[256], *homedir, *xenviron;
 	XrmDatabase res1;
-	
+
 #ifdef VMS
 	strcpy(foo, "SYS$LOGIN:DECW$XDEFAULTS.DAT");
 #else
@@ -4081,33 +4108,33 @@
 	if (!homedir) homedir = ".";
 	sprintf(foo,"%s/.Xdefaults", homedir);
 #endif
-	
+
 	def_resource = XrmGetFileDatabase(foo);
-	
+
 	if (DEBUG) {
 	  fprintf(stderr,"rd_str_cl: No RESOURCE_MANAGER prop.\n");
 	  fprintf(stderr,"rd_str_cl: Using file '%s' (%s)  ",
 		  foo, (def_resource) ? "success" : "failure");
 	}
-	
-	
+
+
 	/* merge file pointed to by XENVIRONMENT */
 	xenviron = (char *) getenv("XENVIRONMENT");
 	if (xenviron) {
 	  res1 = XrmGetFileDatabase(xenviron);
-	  
+
 	  if (DEBUG) {
 	    fprintf(stderr,"merging XENVIRONMENT='%s' (%s)  ",
 		    xenviron, (res1) ? "success" : "failure");
 	  }
-	  
+
 	  if (res1) {    /* merge databases */
 	    if (!def_resource) def_resource = res1;
 	    else XrmMergeDatabases(res1, &def_resource);
 	  }
 	}
-	
-	
+
+
 	if (DEBUG) fprintf(stderr,"\n\n");
       }
     }
@@ -4120,13 +4147,13 @@
   strcpy (q_name, PROGNAME);
   strcat (q_name, ".");
   strcat (q_name, name_str);
-  
+
   strcpy (q_class, "Program");
   strcat (q_class, ".");
   strcat (q_class, class_str);
 
   (void) XrmGetResource(def_resource, q_name, q_class, &type, &result);
-  
+
   def_str = result.addr;
   if (def_str) return (1);
   else return (0);
diff -ruN xv-3.10a/xv.h xv-3.10a-bugfixes/xv.h
--- xv-3.10a/xv.h	1995-01-23 12:22:23.000000000 -0800
+++ xv-3.10a-bugfixes/xv.h	2005-04-10 09:37:18.000000000 -0700
@@ -1,6 +1,6 @@
 /*
  *  xv.h  -  header file for xv, but you probably guessed as much
- * 
+ *
  *  Author:    John Bradley  (bradley@cis.upenn.edu)
  */
 
@@ -8,8 +8,14 @@
 #include "config.h"
 
 
-#define REVDATE   "Version 3.10a  Rev: 12/29/94"
-#define VERSTR    "3.10a"
+/* xv 3.10a:				19941229 */
+/* PNG patch 1.2d:			19960731 */
+/* GRR orig jumbo fixes patch:		20000213 */
+/* GRR orig jumbo enhancements patch:	20000220 */
+/* GRR 1st public jumbo F+E patches:	20040531 */
+/* GRR 2nd public jumbo F+E patches:	20050410 */
+#define REVDATE   "version 3.10a-jumboFix of 20050410"
+#define VERSTR    "3.10a-20050410"
 
 /*
  * uncomment the following, and modify for your site, but only if you've
@@ -62,15 +68,27 @@
 #endif
 
 
-#ifdef LINUX
+/* at least on Linux, the following file (1) includes sys/types.h and
+ * (2) defines __USE_BSD (which was not defined before here), so __linux__
+ * block is now moved after this #include */
+#include <X11/Xos.h>     /* need type declarations immediately */
+
+
+#ifdef __linux__
 #  ifndef _LINUX_LIMITS_H
 #    include <linux/limits.h>
 #  endif
+#  define USLEEP
+   /* want only one or the other defined, not both: */
+#  if !defined(BSDTYPES) && !defined(__USE_BSD)
+#    define BSDTYPES
+#  endif
+#  if defined(BSDTYPES) && defined(__USE_BSD)
+#    undef BSDTYPES
+#  endif
 #endif
 
 
-#include <X11/Xos.h>     /* need type declarations immediately */
-
 /*********************************************************/
 
 
@@ -115,17 +133,21 @@
 #ifndef VMS
 #  include <errno.h>
    extern int   errno;             /* SHOULD be in errno.h, but often isn't */
-#  ifndef __NetBSD__
+#  if !defined(__NetBSD__) && !(defined(__linux__) && defined(__USE_BSD))
      extern char *sys_errlist[];     /* this too... */
 #  endif
 #endif
 
 
 /* not everyone has the strerror() function, or so I'm told */
-#ifndef VMS
-#  define ERRSTR(x) sys_errlist[x]
-#else
+#ifdef VMS
 #  define ERRSTR(x) strerror(x, vaxc$errno)
+#else
+#  if defined(__BEOS__) || defined(__linux__) /* or all modern/glibc systems? */
+#    define ERRSTR(x) strerror(x)
+#  else
+#    define ERRSTR(x) sys_errlist[x]
+#  endif
 #endif
 
 
@@ -159,7 +181,9 @@
      !defined(bsd43)                     && \
      !defined(aux)                       && \
      !defined(__bsdi__)                  && \
-     !defined(sequent)
+     !defined(sequent)                   && \
+     !defined(__FreeBSD__)               && \
+     !defined(__OpenBSD__)
 
 #  if defined(hp300) || defined(hp800) || defined(NeXT)
 #   include <sys/malloc.h>                /* it's in 'sys' on HPs and NeXT */
@@ -205,6 +229,10 @@
 #    include <limits.h>
 #  endif
 
+#  ifdef __BEOS__
+#    include <socket.h>
+#  endif
+
 /*** for select() call ***/
 #  ifdef __hpux
 #    define XV_FDTYPE (int *)
@@ -259,7 +287,7 @@
  * make them if missing, along with a few fictitious ones
  *      Cameron Simpson  (cameron@cse.unsw.edu.au)
  */
- 
+
 #ifndef         S_ISDIR         /* missing POSIX-type macros */
 #  define       S_ISDIR(mode)   (((mode)&S_IFMT) == S_IFDIR)
 #  define       S_ISBLK(mode)   (((mode)&S_IFMT) == S_IFBLK)
@@ -308,10 +336,18 @@
 
 #ifndef VMS       /* VMS hates multi-line definitions */
 #  if defined(SVR4)  || defined(SYSV) || defined(sco) || \
-      defined(XENIX) || defined(__osf__) 
+      defined(XENIX) || defined(__osf__) || defined(__linux__)
 #    undef  USE_GETCWD
 #    define USE_GETCWD          /* use 'getcwd()' instead of 'getwd()' */
-#  endif
+#  endif                        /* >> SECURITY ISSUE << */
+#endif
+
+
+/* GRR 20040430:  This is new and still only partially implemented.  No doubt
+ *                there are many other systems that have mkstemp() (SUSv3),
+ *                but let's start small...  */
+#if defined(__linux__) || defined(__OpenBSD__)
+#  define USE_MKSTEMP           /* use 'mkstemp()' instead of 'mktemp()' */
 #endif
 
 
@@ -320,15 +356,15 @@
 /*****************************/
 
 #ifdef DOJPEG
-#define HAVE_JPEG
+#  define HAVE_JPEG
 #endif
 
 #ifdef DOTIFF
-#define HAVE_TIFF
+#  define HAVE_TIFF
 #endif
 
 #ifdef DOPDS
-#define HAVE_PDS
+#  define HAVE_PDS
 #endif
 
 
@@ -442,7 +478,7 @@
 
 /* following list gives indicies into 'saveFormats[]' array in xvdir.c
    note that JPEG and TIFF entries may or may not exist, and following
-   constants have to be adjusted accordingly.  Also, don't worry about 
+   constants have to be adjusted accordingly.  Also, don't worry about
    duplicate cases if JPGINC or TIFINC = 0.  All code that references
    F_JPEG or F_TIFF is #ifdef'd, so it won't be a problem */
 
@@ -482,7 +518,7 @@
 /* return values from ReadFileType()
  * positive values are *definitely* readable formats (HAVE_*** is defined)
  * negative values are random files that XV can't read, but display as
- *   different icons in the visual browser 
+ *   different icons in the visual browser
  */
 #define RFT_ERROR    -1    /* couldn't open file, or whatever... */
 #define RFT_UNKNOWN   0
@@ -742,7 +778,7 @@
 
 typedef unsigned char byte;
 
-typedef struct scrl { 
+typedef struct scrl {
                  Window win;            /* window ID */
 		 int x,y,w,h;           /* window coords in parent */
 		 int len;               /* length of major axis */
@@ -972,12 +1008,12 @@
                                    /* this is converted to 'theImage' */
 WHERE int           eWIDE, eHIGH;  /* size of epic */
 
-WHERE byte          *egampic;      /* expanded, gammified cpic 
+WHERE byte          *egampic;      /* expanded, gammified cpic
 				      (only used in 24-bit mode) */
 
 WHERE int           p_offx, p_offy;  /* offset of reparented windows */
 WHERE int           ch_offx,ch_offy; /* ChngAttr ofst for reparented windows */
-WHERE int           kludge_offx,     /* WM kludges for SetWindowPos routine */ 
+WHERE int           kludge_offx,     /* WM kludges for SetWindowPos routine */
                     kludge_offy;
 WHERE int           winCtrPosKludge; /* kludge for popup positioning... */
 
@@ -1072,7 +1108,7 @@
 WHERE int           autoDelete;       /* delete cmd-line files on exit? */
 
 #define PRINTCMDLEN 256
-WHERE char          printCmd[PRINTCMDLEN]; 
+WHERE char          printCmd[PRINTCMDLEN];
 
 /* stuff used for 'info' box */
 WHERE Window        infoW;
@@ -1135,7 +1171,7 @@
 /* stuff used for 'ps' box */
 WHERE Window        psW;
 WHERE int           psUp;       /* is psW mapped, or what? */
-WHERE CBUTT         encapsCB, pscompCB;   
+WHERE CBUTT         encapsCB, pscompCB;
 WHERE char         *gsDev, *gsGeomStr;
 WHERE int           gsRes;
 
@@ -1210,7 +1246,7 @@
 
 /*************************** XVMISC.C ***************************/
 void StoreDeleteWindowProp  PARM((Window));
-Window CreateWindow         PARM((char *, char *, char *, int, int, 
+Window CreateWindow         PARM((char *, char *, char *, int, int,
 				  u_long, u_long, int));
 void DrawString             PARM((Window, int, int, char *));
 void CenterString           PARM((Window, int, int, char *));
@@ -1222,7 +1258,7 @@
 void GenExpose              PARM((Window, int, int, u_int, u_int));
 void DimRect                PARM((Window, int, int, u_int, u_int, u_long));
 
-void Draw3dRect             PARM((Window, int, int, u_int, u_int, int, int, 
+void Draw3dRect             PARM((Window, int, int, u_int, u_int, int, int,
 				    u_long, u_long, u_long));
 
 void RemapKeyCheck          PARM((KeySym, char *, int *));
@@ -1237,7 +1273,7 @@
 void SetCursors             PARM((int));
 char *BaseName              PARM((char *));
 
-void DrawTempGauge          PARM((Window, int, int, int, int, double, 
+void DrawTempGauge          PARM((Window, int, int, int, int, double,
 				  u_long, u_long, u_long, u_long, char *));
 void ProgressMeter          PARM((int, int, int, char *));
 void XVDeletedFile          PARM((char *));
@@ -1248,6 +1284,7 @@
 void xv_getwd               PARM((char *, size_t));
 char *xv_strstr             PARM((char *, char *));
 FILE *xv_fopen              PARM((char *, char *));
+void xv_mktemp              PARM((char *, char *));
 void Timer                  PARM((int));
 
 /*************************** XVCOLOR.C ***************************/
@@ -1282,11 +1319,11 @@
 void DrawEpic               PARM((void));
 void KillOldPics            PARM((void));
 
-byte *FSDither              PARM((byte *, int, int, int, 
+byte *FSDither              PARM((byte *, int, int, int,
 				  byte *, byte *, byte *, int, int));
 
 void CreateXImage           PARM((void));
-XImage *Pic8ToXImage        PARM((byte *, u_int, u_int, u_long *, 
+XImage *Pic8ToXImage        PARM((byte *, u_int, u_int, u_long *,
 				  byte *, byte *, byte *));
 
 XImage *Pic24ToXImage       PARM((byte *, u_int, u_int));
@@ -1306,21 +1343,21 @@
 void DoAlg                  PARM((int));
 
 /*************************** XVSMOOTH.C ***************************/
-byte *SmoothResize          PARM((byte *, int, int, int, int, byte *, byte *, 
+byte *SmoothResize          PARM((byte *, int, int, int, int, byte *, byte *,
 				  byte *, byte *, byte *, byte *, int));
 
-byte *Smooth24              PARM((byte *, int, int, int, int, int, 
+byte *Smooth24              PARM((byte *, int, int, int, int, int,
 				  byte *, byte *, byte *));
 
-byte *DoColorDither         PARM((byte *, byte *, int, int, byte *, byte *, 
+byte *DoColorDither         PARM((byte *, byte *, int, int, byte *, byte *,
 				  byte *, byte *, byte *, byte *, int));
 
-byte *Do332ColorDither      PARM((byte *, byte *, int, int, byte *, byte *, 
+byte *Do332ColorDither      PARM((byte *, byte *, int, int, byte *, byte *,
 				  byte *, byte *, byte *, byte *, int));
 
 /*************************** XV24TO8.C **************************/
 void Init24to8             PARM((void));
-byte *Conv24to8            PARM((byte *, int, int, int, 
+byte *Conv24to8            PARM((byte *, int, int, int,
 				 byte *, byte *, byte *));
 
 byte *Conv8to24            PARM((byte *, int, int, byte *, byte *, byte *));
@@ -1337,7 +1374,7 @@
 void DrawCtrlStr           PARM((void));
 void ScrollToCurrent       PARM((LIST *));
 
-void LSCreate              PARM((LIST *, Window, int, int, int, int, int, 
+void LSCreate              PARM((LIST *, Window, int, int, int, int, int,
 				 char **, int, u_long, u_long, u_long, u_long,
 				 void (*)(int, SCRL *), int, int));
 
@@ -1384,7 +1421,7 @@
 FILE *OpenOutFile          PARM((char *));
 int  CloseOutFile          PARM((FILE *, char *, int));
 
-byte *GenSavePic           PARM((int*, int*,int*, int*, int*, 
+byte *GenSavePic           PARM((int*, int*,int*, int*, int*,
 				 byte**, byte**, byte**));
 void GetSaveSize           PARM((int *, int *));
 
@@ -1451,11 +1488,11 @@
 void GamSetAutoApply       PARM((int));
 
 /*************************** XVSCRL.C ***************************/
-void SCCreate              PARM((SCRL *, Window, int, int, int, int, 
-				 int, int, int, int, u_long, u_long, 
+void SCCreate              PARM((SCRL *, Window, int, int, int, int,
+				 int, int, int, int, u_long, u_long,
 				 u_long, u_long, void (*)(int, SCRL *)));
 
-void SCChange              PARM((SCRL *, int, int, int, int, int, 
+void SCChange              PARM((SCRL *, int, int, int, int, int,
 				 int, int, int));
 
 void SCSetRange            PARM((SCRL *, int, int, int, int));
@@ -1465,8 +1502,8 @@
 
 
 /*************************** XVDIAL.C ***************************/
-void DCreate               PARM((DIAL *, Window, int, int, int, int, int, 
-				 int, int, int, u_long, u_long, u_long, 
+void DCreate               PARM((DIAL *, Window, int, int, int, int, int,
+				 int, int, int, u_long, u_long, u_long,
 				 u_long, char *, char *));
 
 void DSetRange             PARM((DIAL *, int, int, int, int));
@@ -1477,7 +1514,7 @@
 
 
 /**************************** XVBUTT.C ***************************/
-void BTCreate              PARM((BUTT *, Window, int, int, u_int, u_int, 
+void BTCreate              PARM((BUTT *, Window, int, int, u_int, u_int,
 				 char *, u_long, u_long, u_long, u_long));
 
 void BTSetActive           PARM((BUTT *, int));
@@ -1485,7 +1522,7 @@
 int  BTTrack               PARM((BUTT *));
 
 
-RBUTT *RBCreate            PARM((RBUTT *, Window, int, int, char *, 
+RBUTT *RBCreate            PARM((RBUTT *, Window, int, int, char *,
 				 u_long, u_long, u_long, u_long));
 
 void   RBRedraw            PARM((RBUTT *, int));
@@ -1497,7 +1534,7 @@
 int    RBTrack             PARM((RBUTT *, int));
 
 
-void   CBCreate            PARM((CBUTT *, Window, int, int, char *, 
+void   CBCreate            PARM((CBUTT *, Window, int, int, char *,
 				 u_long, u_long, u_long, u_long));
 
 void   CBRedraw            PARM((CBUTT *));
@@ -1506,8 +1543,8 @@
 int    CBTrack             PARM((CBUTT *));
 
 
-void   MBCreate            PARM((MBUTT *, Window, int, int, u_int, u_int, 
-				 char *, 
+void   MBCreate            PARM((MBUTT *, Window, int, int, u_int, u_int,
+				 char *,
 				 char **, int,u_long,u_long, u_long, u_long));
 
 void   MBRedraw            PARM((MBUTT *));
@@ -1519,7 +1556,7 @@
 
 
 /**************************** XVGRAF.C ***************************/
-void   CreateGraf          PARM((GRAF *, Window, int, int, 
+void   CreateGraf          PARM((GRAF *, Window, int, int,
 				 u_long, u_long, char *));
 
 void   InitGraf            PARM((GRAF *));
@@ -1539,32 +1576,32 @@
 int LoadGIF                PARM((char *, PICINFO *));
 
 /*************************** XVGIFWR.C **************************/
-int WriteGIF               PARM((FILE *, byte *, int, int, int, 
+int WriteGIF               PARM((FILE *, byte *, int, int, int,
 				 byte *, byte *, byte *, int, int, char *));
 
 /**************************** XVPM.C ****************************/
 int LoadPM                 PARM((char *, PICINFO *));
-int WritePM                PARM((FILE *, byte *, int, int, int, byte *, 
+int WritePM                PARM((FILE *, byte *, int, int, int, byte *,
 				 byte *, byte *, int, int, char *));
 
 /**************************** XVPBM.C ***************************/
 int LoadPBM                PARM((char *, PICINFO *));
-int WritePBM               PARM((FILE *, byte *, int, int, int, byte *, 
+int WritePBM               PARM((FILE *, byte *, int, int, int, byte *,
 				 byte *, byte *, int, int, int, char *));
 
 /**************************** XVXBM.C ***************************/
 int LoadXBM                PARM((char *, PICINFO *));
-int WriteXBM               PARM((FILE *, byte *, int, int, byte *, byte *, 
+int WriteXBM               PARM((FILE *, byte *, int, int, byte *, byte *,
 				 byte *, char *));
 
 /**************************** XVSUNRAS.C ***************************/
 int LoadSunRas             PARM((char *, PICINFO *));
-int WriteSunRas            PARM((FILE *, byte *, int, int, int, byte *, 
+int WriteSunRas            PARM((FILE *, byte *, int, int, int, byte *,
 				 byte *, byte*, int, int, int));
 
 /**************************** XVBMP.C ***************************/
 int LoadBMP                PARM((char *, PICINFO *));
-int WriteBMP               PARM((FILE *, byte *, int, int, int, byte *, 
+int WriteBMP               PARM((FILE *, byte *, int, int, int, byte *,
 				 byte *, byte *, int, int));
 
 /**************************** XVRLE.C ***************************/
@@ -1572,7 +1609,7 @@
 
 /**************************** XVIRIS.C ***************************/
 int LoadIRIS               PARM((char *, PICINFO *));
-int WriteIRIS              PARM((FILE *, byte *, int, int, int, byte *, 
+int WriteIRIS              PARM((FILE *, byte *, int, int, int, byte *,
 				 byte *, byte *, int, int));
 
 /**************************** XVPCX.C ***************************/
@@ -1583,12 +1620,12 @@
 
 /**************************** XVTARGA.C ***************************/
 int LoadTarga              PARM((char *, PICINFO *));
-int WriteTarga             PARM((FILE *, byte *, int, int, int, byte *, 
+int WriteTarga             PARM((FILE *, byte *, int, int, int, byte *,
 				 byte *, byte *, int, int));
 
 /**************************** XVXPM.C ***************************/
 int LoadXPM                PARM((char *, PICINFO *));
-int WriteXPM               PARM((FILE *, byte *, int, int, int, byte *, 
+int WriteXPM               PARM((FILE *, byte *, int, int, int, byte *,
 				 byte *, byte *, int, int, char *, char *));
 
 /**************************** XVXWD.C ***************************/
@@ -1607,7 +1644,7 @@
 void JPEGSaveParams        PARM((char *, int));
 
 /**************************** XVTIFF.C ***************************/
-int   LoadTIFF             PARM((char *, PICINFO *));
+int   LoadTIFF             PARM((char *, PICINFO *, int));
 void  CreateTIFFW          PARM((void));
 void  TIFFDialog           PARM((int));
 int   TIFFCheckEvent       PARM((XEvent *));
@@ -1628,7 +1665,7 @@
 void  CenterMapWindow      PARM((Window, int, int, int, int));
 int   PopUp                PARM((char *, char **, int));
 void  ErrPopUp             PARM((char *, char *));
-int   GetStrPopUp          PARM((char *, char **, int, char *, int, 
+int   GetStrPopUp          PARM((char *, char **, int, char *, int,
 				 char *, int));
 int   GrabPopUp            PARM((int *, int *));
 int   PadPopUp             PARM((int *, char **, int *, int *, int *, int *));
diff -ruN xv-3.10a/xv24to8.c xv-3.10a-bugfixes/xv24to8.c
--- xv-3.10a/xv24to8.c	1995-01-13 11:49:21.000000000 -0800
+++ xv-3.10a-bugfixes/xv24to8.c	2004-05-16 18:00:58.000000000 -0700
@@ -14,15 +14,15 @@
  *
  * The Conv24to8 procedure will set up the following:  it will allocate, make
  * & return 'pic8', a 'w' by 'h' (passed in values) 8-bit picture.
- * it will load up the rmap, gmap and bmap colormap arrays.  it will NOT 
+ * it will load up the rmap, gmap and bmap colormap arrays.  it will NOT
  * calculate numcols, since the cmap sort procedure has to be called anyway
  *
- * Conv24to8 returns 'pic8' if successful, 'NULL' on failure (presumably on a 
+ * Conv24to8 returns 'pic8' if successful, 'NULL' on failure (presumably on a
  * malloc())
  *
- * The 'slow' code, while still based on Heckbert's Median Cut algorithm, 
+ * The 'slow' code, while still based on Heckbert's Median Cut algorithm,
  * has been shamelessly lifted from the Independent JPEG Group's software
- * (jquant2.c), as (for a variety of reasons) theirs was far better than 
+ * (jquant2.c), as (for a variety of reasons) theirs was far better than
  * the version I was previously using.  Thanks guys!
  *
  * Also, as is my way, I've stripped out most of the IJG's well-written
@@ -65,10 +65,10 @@
 {
   /* returns pointer to new 8-bit-per-pixel image (w*h) if successful, or
      NULL if unsuccessful */
-  
+
   int   i;
   byte *pic8;
-  
+
   if (!pic24) return NULL;
 
   pic8 = (byte *) malloc((size_t) (w * h));
@@ -79,9 +79,9 @@
 
   if (nc<=0) nc = 255;  /* 'nc == 0' breaks code */
 
-  if (!noqcheck && quick_check(pic24, w,h, pic8, rm,gm,bm, nc)) { 
+  if (!noqcheck && quick_check(pic24, w,h, pic8, rm,gm,bm, nc)) {
     SetISTR(ISTR_INFO,"No color compression was necessary.\n");
-    return pic8;   
+    return pic8;
   }
 
   switch (conv24) {
@@ -89,19 +89,19 @@
     SetISTR(ISTR_INFO,"Doing 'quick' 24-bit to 8-bit conversion.");
     i = quick_quant(pic24, w, h, pic8, rm, gm, bm, nc);
     break;
-    
+
   case CONV24_BEST:
     SetISTR(ISTR_INFO,"Doing 'best' 24-bit to 8-bit conversion.");
     i = ppm_quant(pic24, w, h, pic8, rm, gm, bm, nc);
     break;
-    
+
   case CONV24_SLOW:
   default:
     SetISTR(ISTR_INFO,"Doing 'slow' 24-bit to 8-bit conversion.");
     i = slow_quant(pic24, w, h, pic8, rm, gm, bm, nc);
     break;
   }
-  
+
   if (i) { free(pic8);  pic8 = NULL; }
   return pic8;
 }
@@ -134,7 +134,7 @@
 
   return pic24;
 }
-  
+
 
 /****************************/
 static int quick_check(pic24, w,h, pic8, rmap,gmap,bmap, maxcol)
@@ -154,10 +154,10 @@
   if (maxcol>256) maxcol = 256;
 
   /* put the first color in the table by hand */
-  nc = 0;  mid = 0;  
+  nc = 0;  mid = 0;
 
   for (i=w*h,p=pic24; i; i--) {
-    col  = (((u_long) *p++) << 16);  
+    col  = (((u_long) *p++) << 16);
     col += (((u_long) *p++) << 8);
     col +=  *p++;
 
@@ -184,7 +184,7 @@
      pic24 into colormap offsets into 'colors' */
 
   for (i=w*h,p=pic24, pix=pic8; i; i--,pix++) {
-    col  = (((u_long) *p++) << 16);  
+    col  = (((u_long) *p++) << 16);
     col += (((u_long) *p++) << 8);
     col +=  *p++;
 
@@ -206,7 +206,7 @@
 
   /* and load up the 'desired colormap' */
   for (i=0; i<nc; i++) {
-    rmap[i] =  colors[i]>>16;  
+    rmap[i] =  colors[i]>>16;
     gmap[i] = (colors[i]>>8) & 0xff;
     bmap[i] =  colors[i]     & 0xff;
   }
@@ -224,7 +224,7 @@
 {
   /* called after 'pic8' has been alloced, pWIDE,pHIGH set up, mono/1-bit
      checked already */
-  
+
 /* up to 256 colors:     3 bits R, 3 bits G, 2 bits B  (RRRGGGBB) */
 #define RMASK      0xe0
 #define RSHIFT        0
@@ -252,7 +252,7 @@
     gmap[i] = (((i<<GSHIFT) & GMASK) * 255 + GMASK/2) / GMASK;
     bmap[i] = (((i<<BSHIFT) & BMASK) * 255 + BMASK/2) / BMASK;
   }
-  
+
 
   thisline = (int *) malloc(pwide3 * sizeof(int));
   nextline = (int *) malloc(pwide3 * sizeof(int));
@@ -262,40 +262,40 @@
     fprintf(stderr,"%s: unable to allocate memory in quick_quant()\n", cmd);
     return(1);
   }
-  
+
   /* get first line of picture */
   for (j=pwide3, tmpptr=nextline; j; j--) *tmpptr++ = (int) *p24++;
-  
+
   for (i=0; i<h; i++) {
     tmpptr = thisline;  thisline = nextline;  nextline = tmpptr;   /* swap */
-    
+
     if ((i&0x3f) == 0) WaitCursor();
 
     if (i!=imax)   /* get next line */
       for (j=pwide3, tmpptr=nextline; j; j--)
 	*tmpptr++ = (int) *p24++;
-    
+
     for (j=0, thisptr=thisline, nextptr=nextline; j<w; j++,pp++) {
       r1 = *thisptr++;  g1 = *thisptr++;  b1 = *thisptr++;
-      RANGE(r1,0,255);  RANGE(g1,0,255);  RANGE(b1,0,255);  
-      
+      RANGE(r1,0,255);  RANGE(g1,0,255);  RANGE(b1,0,255);
+
       /* choose actual pixel value */
-      val = (((r1&RMASK)>>RSHIFT) | ((g1&GMASK)>>GSHIFT) | 
+      val = (((r1&RMASK)>>RSHIFT) | ((g1&GMASK)>>GSHIFT) |
 	     ((b1&BMASK)>>BSHIFT));
       *pp = val;
-      
+
       /* compute color errors */
       r1 -= rmap[val];
       g1 -= gmap[val];
       b1 -= bmap[val];
-      
+
       /* Add fractions of errors to adjacent pixels */
       if (j!=jmax) {  /* adjust RIGHT pixel */
 	thisptr[0] += (r1*7) / 16;
 	thisptr[1] += (g1*7) / 16;
 	thisptr[2] += (b1*7) / 16;
       }
-      
+
       if (i!=imax) {	/* do BOTTOM pixel */
 	nextptr[0] += (r1*5) / 16;
 	nextptr[1] += (g1*5) / 16;
@@ -316,7 +316,7 @@
       }
     }
   }
-  
+
   free(thisline);
   free(nextline);
   return 0;
@@ -329,7 +329,7 @@
 #undef BMASK
 #undef BSHIFT
 }
-      
+
 
 
 
@@ -381,7 +381,7 @@
 
 /* Luminance macro. */
 
-/* 
+/*
  * #define PPM_LUMIN(p) \
  *   ( 0.299 * PPM_GETR(p) + 0.587 * PPM_GETG(p) + 0.114 * PPM_GETB(p) )
  */
@@ -472,7 +472,7 @@
 
   if (DEBUG) fprintf(stderr,"%s: remapping to ppm-style internal fmt\n", fn);
   WaitCursor();
-  
+
   pixels = (pixel **) malloc(rows * sizeof(pixel *));
   if (!pixels) FatalError("couldn't allocate 'pixels' array");
   for (row=0; row<rows; row++) {
@@ -488,7 +488,7 @@
   if (DEBUG) fprintf(stderr,"%s: done format remapping\n", fn);
 
 
-    
+
 
   /*
    *  attempt to make a histogram of the colors, unclustered.
@@ -503,7 +503,7 @@
 
     chv = ppm_computechist(pixels, cols, rows, MAXCOLORS, &colors);
     if (chv != (chist_vec) 0) break;
-    
+
     if (DEBUG) fprintf(stderr, "%s: too many colors!\n", fn);
     newmaxval = maxval / 2;
     if (DEBUG) fprintf(stderr, "%s: rescaling colors (maxval=%d) %s\n",
@@ -635,7 +635,7 @@
   int boxes;
 
   bv = (box_vector) malloc(sizeof(struct box) * newcolors);
-  colormap = (chist_vec) 
+  colormap = (chist_vec)
              malloc(sizeof(struct chist_item) * newcolors );
 
   if (!bv || !colormap) FatalError("unable to malloc in mediancut()");
@@ -723,7 +723,7 @@
       else if (gl >= bl)
 	qsort((char*) &(chv[indx]), (size_t) clrs, sizeof(struct chist_item),
 	      greencompare );
-      else 
+      else
 	qsort((char*) &(chv[indx]), (size_t) clrs, sizeof(struct chist_item),
 	      bluecompare );
     }
@@ -750,7 +750,7 @@
     ++boxes;
     qsort((char*) bv, (size_t) boxes, sizeof(struct box), sumcompare);
   }  /* while (boxes ... */
-  
+
   /*
    ** Ok, we've got enough boxes.  Now choose a representative color for
    ** each box.  There are a number of possible ways to make this choice.
@@ -761,7 +761,7 @@
    ** method is used by switching the commenting on the REP_ defines at
    ** the beginning of this source file.
    */
-  
+
   for (bi=0; bi<boxes; bi++) {
     /* REP_AVERAGE_PIXELS version */
     register int indx = bv[bi].index;
@@ -791,7 +791,7 @@
 static int redcompare(p1, p2)
      const void *p1, *p2;
 {
-  return (int) PPM_GETR( ((chist_vec)p1)->color ) - 
+  return (int) PPM_GETR( ((chist_vec)p1)->color ) -
          (int) PPM_GETR( ((chist_vec)p2)->color );
 }
 
@@ -799,7 +799,7 @@
 static int greencompare(p1, p2)
      const void *p1, *p2;
 {
-  return (int) PPM_GETG( ((chist_vec)p1)->color ) - 
+  return (int) PPM_GETG( ((chist_vec)p1)->color ) -
          (int) PPM_GETG( ((chist_vec)p2)->color );
 }
 
@@ -807,7 +807,7 @@
 static int bluecompare(p1, p2)
      const void *p1, *p2;
 {
-  return (int) PPM_GETB( ((chist_vec)p1)->color ) - 
+  return (int) PPM_GETB( ((chist_vec)p1)->color ) -
          (int) PPM_GETB( ((chist_vec)p2)->color );
 }
 
@@ -821,7 +821,7 @@
 
 
 /****************************************************************************/
-static chist_vec 
+static chist_vec
   ppm_computechist(pixels, cols, rows, maxcolors, colorsP)
      pixel** pixels;
      int cols, rows, maxcolors;
@@ -840,7 +840,7 @@
 
 
 /****************************************************************************/
-static chash_table ppm_computechash(pixels, cols, rows, 
+static chash_table ppm_computechash(pixels, cols, rows,
 					    maxcolors, colorsP )
      pixel** pixels;
      int cols, rows, maxcolors;
@@ -861,14 +861,14 @@
 
       for (chl = cht[hash]; chl != (chist_list) 0; chl = chl->next)
 	if (PPM_EQUAL(chl->ch.color, *pP)) break;
-      
+
       if (chl != (chist_list) 0) ++(chl->ch.value);
       else {
 	if ((*colorsP)++ > maxcolors) {
 	  ppm_freechash(cht);
 	  return (chash_table) 0;
 	}
-	
+
 	chl = (chist_list) malloc(sizeof(struct chist_list_item));
 	if (!chl) FatalError("ran out of memory computing hash table");
 
@@ -878,7 +878,7 @@
 	cht[hash] = chl;
       }
     }
-  
+
   return cht;
 }
 
@@ -1114,7 +1114,7 @@
   register int i;
   register long maxc = 0;
   boxptr which = NULL;
-  
+
   for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
     if (boxp->colorcount > maxc && boxp->volume > 0) {
       which = boxp;
@@ -1133,7 +1133,7 @@
   register int i;
   register INT32 maxv = 0;
   boxptr which = NULL;
-  
+
   for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
     if (boxp->volume > maxv) {
       which = boxp;
@@ -1153,11 +1153,11 @@
   int c0min,c0max,c1min,c1max,c2min,c2max;
   INT32 dist0,dist1,dist2;
   long ccount;
-  
+
   c0min = boxp->c0min;  c0max = boxp->c0max;
   c1min = boxp->c1min;  c1max = boxp->c1max;
   c2min = boxp->c2min;  c2max = boxp->c2max;
-  
+
   if (c0max > c0min)
     for (c0 = c0min; c0 <= c0max; c0++)
       for (c1 = c1min; c1 <= c1max; c1++) {
@@ -1229,7 +1229,7 @@
   dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
   dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
   boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
-  
+
   ccount = 0;
   for (c0 = c0min; c0 <= c0max; c0++)
     for (c1 = c1min; c1 <= c1max; c1++) {
@@ -1315,11 +1315,11 @@
   long c0total = 0;
   long c1total = 0;
   long c2total = 0;
-  
+
   c0min = boxp->c0min;  c0max = boxp->c0max;
   c1min = boxp->c1min;  c1max = boxp->c1max;
   c2min = boxp->c2min;  c2max = boxp->c2max;
-  
+
   for (c0 = c0min; c0 <= c0max; c0++)
     for (c1 = c1min; c1 <= c1max; c1++) {
       histp = & histogram[c0][c1][c2min];
@@ -1332,7 +1332,7 @@
 	}
       }
     }
-  
+
   sl_colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
   sl_colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
   sl_colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
@@ -1505,12 +1505,12 @@
   bptr = bestdist;
   for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
     *bptr++ = 0x7FFFFFFFL;
-  
+
   /* Nominal steps between cell centers ("x" in Thomas article) */
 #define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
 #define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
 #define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
-  
+
   for (i = 0; i < numcolors; i++) {
     icolor = colorlist[i];
     /* Compute (square of) distance from minc0/c1/c2 to this color */
@@ -1576,7 +1576,7 @@
   minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
   minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
   minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
-  
+
   numcolors = find_nearby_colors(minc0, minc1, minc2, colorlist);
 
   /* Determine the actually nearest colors. */
diff -ruN xv-3.10a/xvalg.c xv-3.10a-bugfixes/xvalg.c
--- xv-3.10a/xvalg.c	1994-12-22 14:34:47.000000000 -0800
+++ xv-3.10a-bugfixes/xvalg.c	2004-05-16 18:01:13.000000000 -0700
@@ -38,7 +38,7 @@
 				 double, int));
 static void doPixel        PARM((byte *,int,int,byte *, int,int,int,int,
 				 int, int));
-static void doSpread       PARM((byte *,int,int,byte *, int,int,int,int, 
+static void doSpread       PARM((byte *,int,int,byte *, int,int,int,int,
 				 int, int));
 static void doMedianFilter PARM((byte *,int,int,byte *, int,int,int,int, int));
 
@@ -89,7 +89,7 @@
 /************************************************************/
 void AlgInit()
 {
-  /* called whenver an image file is loaded.  disposes of origPic 
+  /* called whenver an image file is loaded.  disposes of origPic
      if neccessary, and points it to null */
 
   if (origPic) free(origPic);
@@ -160,7 +160,7 @@
 {
   /* runs a n*n convolution mask (all 1's) over 'pic',
      producing a 24-bit version.  Then calls 24to8 to generate a new 8-bit
-     image, and installs it. 
+     image, and installs it.
 
      Note that 'n' must be odd for things to work properly */
 
@@ -169,7 +169,7 @@
   static char *labels[] = { "\nOk", "\033Cancel" };
   char         txt[256];
   static char  buf[64] = { '3', '\0' };
-  
+
   sprintf(txt, "Blur:                                   \n\n%s",
 	  "Enter mask size (ex. 3, 5, 7, ...)");
 
@@ -178,7 +178,7 @@
   n = atoi(buf);
 
   if (n < 1 || (n&1)!=1) {
-    ErrPopUp("Error:  The value entered must be odd and greater than zero.", 
+    ErrPopUp("Error:  The value entered must be odd and greater than zero.",
 	     "\nOh!");
     return;
   }
@@ -194,7 +194,7 @@
 
   if (start24bitAlg(&pic24, &tmpPic)) return;
   xvbcopy((char *) pic24, (char *) tmpPic, (size_t) (pWIDE*pHIGH*3));
-    
+
   doBlurConvolv(pic24, pWIDE,pHIGH, tmpPic, sx,sy,sw,sh, n);
 
   end24bitAlg(pic24, tmpPic);
@@ -212,7 +212,7 @@
   static char *labels[] = { "\nOk", "\033Cancel" };
   char         txt[256];
   static char  buf[64] = { '7', '5', '\0' };
-  
+
   sprintf(txt, "Sharpen:                                   \n\n%s",
 	  "Enter enhancement factor (0-99%)");
 
@@ -236,7 +236,7 @@
 
   if (start24bitAlg(&pic24, &tmpPic)) return;
   xvbcopy((char *) pic24, (char *) tmpPic, (size_t) (pWIDE*pHIGH*3));
-    
+
   doSharpConvolv(pic24, pWIDE,pHIGH, tmpPic, sx,sy,sw,sh, n);
 
   end24bitAlg(pic24, tmpPic);
@@ -264,7 +264,7 @@
   xvbcopy((char *) pic24, (char *) tmpPic, (size_t) (pWIDE*pHIGH*3));
 
   doEdgeConvolv(pic24, pWIDE, pHIGH, tmpPic, sx,sy,sw,sh);
-  
+
   SetISTR(ISTR_INFO, "%snormalizing...", str);
 
   /* Normalize results */
@@ -292,19 +292,19 @@
 /************************/
 static void TinFoil()
 {
-  byte *pic24, *p24, *tmpPic, *tp, *tlp;
+  byte *pic24, *tmpPic, *tp, *tlp;
   char *str;
-  int  i, j, v, maxv,sx,sy,sw,sh;
-  
+  int  i, j, v, sx,sy,sw,sh;
+
   WaitCursor();
-  
+
   str = "Doing cheesy embossing effect...";
   SetISTR(ISTR_INFO, str);
-  
+
   if (HaveSelection()) GetSelRCoords(&sx,&sy,&sw,&sh);
   else { sx = 0;  sy = 0;  sw = pWIDE;  sh = pHIGH; }
   CropRect2Rect(&sx,&sy,&sw,&sh, 0,0,pWIDE,pHIGH);
-  
+
   if (start24bitAlg(&pic24, &tmpPic)) return;
   xvbcopy((char *) pic24, (char *) tmpPic, (size_t) (pWIDE*pHIGH*3));
 
@@ -315,9 +315,9 @@
       *tp++ = 128;  *tp++ = 128;  *tp++ = 128;
     }
   }
-  
+
   doAngleConvolv(pic24, pWIDE, pHIGH, tmpPic, sx,sy,sw,sh);
-  
+
   /* mono-ify selected area of tmpPic */
   for (i=sy; i<sy+sh; i++) {
     tp = tlp = tmpPic + (i*pWIDE + sx) * 3;
@@ -327,9 +327,9 @@
       tp[0] = tp[1] = tp[2] = (byte) v;
     }
   }
-    
+
   end24bitAlg(pic24, tmpPic);
-}  
+}
 
 
 /************************/
@@ -345,7 +345,7 @@
   if (HaveSelection()) GetSelRCoords(&sx,&sy,&sw,&sh);
   else { sx = 0;  sy = 0;  sw = pWIDE;  sh = pHIGH; }
   CropRect2Rect(&sx,&sy,&sw,&sh, 0,0,pWIDE,pHIGH);
-  
+
   if (start24bitAlg(&pic24, &tmpPic)) return;
   xvbcopy((char *) pic24, (char *) tmpPic, (size_t) (pWIDE*pHIGH*3));
 
@@ -365,7 +365,7 @@
   if (HaveSelection()) GetSelRCoords(&sx,&sy,&sw,&sh);
   else { sx = 0;  sy = 0;  sw = pWIDE;  sh = pHIGH; }
   CropRect2Rect(&sx,&sy,&sw,&sh, 0,0,pWIDE,pHIGH);
-  
+
   WaitCursor();
 
   if (start24bitAlg(&pic24, &tmpPic)) return;
@@ -396,12 +396,12 @@
   rotval = atof(buf);
 
   if (rotval == 0.0) return;
-  
+
 
   if (HaveSelection()) GetSelRCoords(&sx,&sy,&sw,&sh);
   else { sx = 0;  sy = 0;  sw = pWIDE;  sh = pHIGH; }
   CropRect2Rect(&sx,&sy,&sw,&sh, 0,0,pWIDE,pHIGH);
-  
+
   WaitCursor();
 
   if (start24bitAlg(&pic24, &tmpPic)) return;
@@ -443,11 +443,11 @@
     return;
   }
 
-  
+
   if (HaveSelection()) GetSelRCoords(&sx,&sy,&sw,&sh);
   else { sx = 0;  sy = 0;  sw = pWIDE;  sh = pHIGH; }
   CropRect2Rect(&sx,&sy,&sw,&sh, 0,0,pWIDE,pHIGH);
-  
+
   WaitCursor();
 
   if (start24bitAlg(&pic24, &tmpPic)) return;
@@ -493,11 +493,11 @@
     return;
   }
 
-  
+
   if (HaveSelection()) GetSelRCoords(&sx,&sy,&sw,&sh);
   else { sx = 0;  sy = 0;  sw = pWIDE;  sh = pHIGH; }
   CropRect2Rect(&sx,&sy,&sw,&sh, 0,0,pWIDE,pHIGH);
-  
+
   WaitCursor();
 
   if (start24bitAlg(&pic24, &tmpPic)) return;
@@ -521,7 +521,7 @@
   static char *labels[] = { "\nOk", "\033Cancel" };
   char         txt[256];
   static char  buf[64] = { '3', '\0' };
-  
+
   sprintf(txt, "DeSpeckle (median filter):                          \n\n%s",
 	  "Enter mask size (ex. 3, 5, 7, ...)");
 
@@ -530,7 +530,7 @@
   n = atoi(buf);
 
   if (n < 1 || (n&1)!=1) {
-    ErrPopUp("Error:  The value entered must be odd and greater than zero.", 
+    ErrPopUp("Error:  The value entered must be odd and greater than zero.",
 	     "\nOh!");
     return;
   }
@@ -546,7 +546,7 @@
 
   if (start24bitAlg(&pic24, &tmpPic)) return;
   xvbcopy((char *) pic24, (char *) tmpPic, (size_t) (pWIDE*pHIGH*3));
-    
+
   doMedianFilter(pic24, pWIDE,pHIGH, tmpPic, sx,sy,sw,sh, n);
 
   end24bitAlg(pic24, tmpPic);
@@ -560,7 +560,7 @@
      int   w,h, selx,sely,selw,selh, n;
 {
 
-  /* convolves with an n*n array, consisting of only 1's.  
+  /* convolves with an n*n array, consisting of only 1's.
      Operates on rectangular region 'selx,sely,selw,selh' (in pic coords)
      Region is guaranteed to be completely within pic boundaries
      'n' must be odd */
@@ -568,7 +568,7 @@
   register byte *p24;
   register int   rsum,gsum,bsum;
   byte          *rp;
-  int            i,j,k,x,y,x1,y1,count,n2;
+  int            x,y,x1,y1,count,n2;
 
 
   printUTime("start of blurConvolv");
@@ -589,7 +589,7 @@
       for (y1=y-n2; y1<=y+n2; y1++) {
 
 	if (y1>=sely && y1<sely+selh) {
-	  p24 = pic24 + y1*w*3 +(x-n2)*3; 
+	  p24 = pic24 + y1*w*3 +(x-n2)*3;
 
 	  for (x1=x-n2; x1<=x+n2; x1++) {
 	    if (x1>=selx && x1<selx+selw) {
@@ -631,7 +631,7 @@
   byte  *p24;
   int    rv, gv, bv;
   byte  *rp;
-  int    i,j,k,x,y,x1,y1;
+  int    i,x,y;
   double fact, ifact, hue,sat,val, vsum;
   double *linem1, *line0, *linep1, *tmpptr;
 
@@ -673,7 +673,7 @@
   for (y=sely+1; y<(sely+selh)-1; y++) {
     ProgressMeter(sely+1, (sely+selh)-2, y, "Sharpen");
     if ((y & 15) == 0) WaitCursor();
-    
+
     tmpptr = linem1;   linem1 = line0;   line0 = linep1;   linep1 = tmpptr;
 
     /* get next line */
@@ -691,7 +691,7 @@
       vsum = linem1[i-1] + linem1[i] + linem1[i+1] +
 	     line0 [i-1] + line0 [i] + line0 [i+1] +
 	     linep1[i-1] + linep1[i] + linep1[i+1];
-      
+
       rgb2hsv((int) p24[0], (int) p24[1], (int) p24[2], &hue, &sat, &val);
 
       val = ((val - (fact * vsum) / 9) / ifact);
@@ -723,22 +723,22 @@
 {
 
   /* convolves with two edge detection masks (vertical and horizontal)
-     simultaneously, taking Max(abs(results)) 
-     
+     simultaneously, taking Max(abs(results))
+
      The two masks are (hard coded):
 
           -1 0 1             -1 -1 -1
       H = -1 0 1     and V =  0  0  0
           -1 0 1              1  1  1
 
-     divided into 
+     divided into
            -1 0 0         0 0 0         0 0 1        0  1 0
        a =  0 0 0 ,  b = -1 0 1 ,  c =  0 0 0 ,  d = 0  0 0 .
             0 0 1         0 0 0        -1 0 0        0 -1 0
 
      So H = a + b + c,  V = a - c - d.
      gradient = max(abs(H),abs(V)).
-          
+
      Also, only does pixels in which the masks fit fully onto the picture
      (no pesky boundary conditionals)  */
 
@@ -746,7 +746,7 @@
   register byte *p24;
   register int   bperlin, a, b, c, d, rsum, gsum, bsum;
   byte          *rp;
-  int            i, x, y;
+  int            x, y;
 
 
   printUTime("start of edgeConvolv");
@@ -818,13 +818,13 @@
 {
 
   /* convolves with edge detection mask, at 45 degrees to horizontal.
-     
+
      The mask is (hard coded):
 
              -2 -1 0
              -1  0 1
               0  1 2
-          
+
      Also, only does pixels in which the masks fit fully onto the picture
      (no pesky boundary conditionals)
 
@@ -833,7 +833,7 @@
   register byte *p24;
   register int   bperlin,rsum,gsum,bsum;
   byte          *rp;
-  int            i, x,y;
+  int            x,y;
 
 
   printUTime("start of doAngleConvolv");
@@ -912,14 +912,14 @@
      for each pixel in the image (assume, for a second, a grayscale image),
      compute a histogram of the n*n rectangle centered on the pixel.
      replace the pixel with the color that had the greatest # of hits in
-     the histogram.  Note that 'n' should be odd. 
+     the histogram.  Note that 'n' should be odd.
 
      I've modified the algorithm to do the *right* thing for RGB images.
      (jhb, 6/94)  */
 
 
   register byte *pp;
-  register int   bperlin, rsum,gsum,bsum;
+  register int   bperlin;
   byte          *rp, *p24, *plin;
   int            i,j,k,x,y,n2,col,cnt,maxcnt;
   int           *nnrect;
@@ -933,7 +933,7 @@
 
   /* nnrect[] is an n*n array of ints, with '-1' meaning 'outside the region'
      otherwise they'll have 24-bit RGB values */
-  
+
   nnrect = (int *) malloc(n * n * sizeof(int));
   if (!nnrect) FatalError("can't malloc nnrect[] in doOilPaint()\n");
 
@@ -943,13 +943,13 @@
 
     p24 = pic24 + ((y-n2)*w + selx-n2)*3;   /* pts to top-left of mask */
     rp  = results + (y*w + selx)*3;
-    
+
     for (x=selx; x<selx+selw; x++) {
       /* fill 'nnrect' with valid pixels from n*n region centered round x,y */
       pp = plin = p24;
       for (i=y-n2, k=0; i<y+n2; i++) {
 	for (j=x-n2; j<x+n2; j++, k++, pp+=3) {
-	  if (i>=sely && i<sely+selh && j>=selx && j<selx+selw) { 
+	  if (i>=sely && i<sely+selh && j>=selx && j<selx+selw) {
 	    nnrect[k] = (((int) pp[0])<<16) | (((int) pp[1])<<8) | pp[2];
 	  }
 	  else nnrect[k] = -1;
@@ -957,7 +957,7 @@
 	plin += bperlin;  pp = plin;
       }
 
-      
+
       /* find 'most popular color' in nnrect, not counting '-1' */
       maxcnt = cnt = col = 0;
       for (i=0; i<n*n; i++) {
@@ -1021,7 +1021,7 @@
     p24 = pic24 + (y*w + selx) * 3;
     rf += (double) p24[0];  gf += (double) p24[1];  bf += (double) p24[2];
     i++;
-    
+
     p24 = pic24 + (y*w + (selx+selw-1)) * 3;
     rf += (double) p24[0];  gf += (double) p24[1];  bf += (double) p24[2];
     i++;
@@ -1047,7 +1047,7 @@
       if (dx==0 && dy==0) { ex = selx;  ey = sely; }  /* don't care */
       else if (dx==0) {	ex = cx;  ey = (dy<0) ? sely : sely+selh-1; }
       else if (dy==0) {	ey = cy;  ex = (dx<0) ? selx : selx+selw-1; }
-      else { 
+      else {
 	slope = ((double) dy) / dx;
 	if (fabs(slope) > fabs(dslope)) {   /* y axis is major */
 	  ey = (dy<0) ? sely : sely+selh-1;
@@ -1092,7 +1092,7 @@
   printUTime("end of blend");
 }
 
-  
+
 
 /************************/
 static void doRotate(pic24, w, h, results, selx,sely,selw,selh, rotval, clear)
@@ -1104,7 +1104,7 @@
      by the amount specified in degrees (rotval), and stores the result in
      'results', which is also a w*h 24-bit image.  The rotated bits are
      clipped to fit in 'results'.  If 'clear', the (unrotated) rectangular
-     region is cleared (in results) first.  
+     region is cleared (in results) first.
      sel[x,y,w,h] is guaranteed to be within image bounds */
 
   byte  *pp, *dp;
@@ -1118,7 +1118,7 @@
   printUTime("start of rotate");
 
   /*
-   * cfx,cfy  -  center point of sel rectangle (double) 
+   * cfx,cfy  -  center point of sel rectangle (double)
    * rx1,ry1  -  top-left  of sel, rotated
    * rx2,ry2  -  bot-left  of sel, rotated
    * rx3,ry3  -  top-right of sel, rotated
@@ -1174,7 +1174,7 @@
   /* now, for each pixel in rb[x,y,w,h], do the inverse rotation to see if
      it would be in the original unrotated selection rectangle.  if it *is*,
      compute and store an appropriate color, otherwise skip it */
- 
+
   for (y=rby; y<rby+rbh; y++) {
     dp = results + (y * w + rbx) * 3;
 
@@ -1194,7 +1194,7 @@
 	int    p0r,p0g,p0b, p1r,p1g,p1b, p2r,p2g,p2b, p3r,p3g,p3b;
 	int    rv,gv,bv;
 	double rd,gd,bd, p0wgt, p1wgt, p2wgt, p3wgt;
-	
+
 	/* compute the color, same idea as in Smooth**().  The color
 	   will be a linear combination of the colors of the center pixel,
 	   its left-or-right neighbor, its top-or-bottom neighbor, and
@@ -1265,9 +1265,9 @@
 }
 #endif /* ROTATE_FOO */
 
-	dp[0] = (byte) (rv&0xff);  
-	dp[1] = (byte) (gv&0xff);  
-	dp[2] = (byte) (bv&0xff);  
+	dp[0] = (byte) (rv&0xff);
+	dp[1] = (byte) (gv&0xff);
+	dp[2] = (byte) (bv&0xff);
       }
     }
   }
@@ -1311,11 +1311,11 @@
 #ifdef FOO
   fprintf(stderr,"rotXfer:  rotating (%4d,%4d) %7.2f degrees around",
 	  x,y, rad*180.0 / M_PI);
-  fprintf(stderr,"(%4d,%4d) -> %7.2f %7.2f  (d=%f ang=%f)\n", 
+  fprintf(stderr,"(%4d,%4d) -> %7.2f %7.2f  (d=%f ang=%f)\n",
 	  cx,cy, *rx,*ry, d, ang);
 #endif
 }
-  
+
 
 
 /************************/
@@ -1323,29 +1323,29 @@
      byte *pic24, *results;
      int   w, h, selx,sely,selw,selh, pixX,pixY;
 {
-  /* runs 'pixelization' algorithm.  replaces each pixX-by-pixY region 
+  /* runs 'pixelization' algorithm.  replaces each pixX-by-pixY region
      (smaller on edges) with the average color within that region */
-  
+
   byte  *pp;
   int    nwide, nhigh, i,j, x,y, x1,y1, stx,sty;
   int    nsum, rsum, gsum, bsum;
-  
+
   printUTime("start of pixelize");
-  
+
   /* center grid on selection */
   nwide = (selw + pixX-1) / pixX;
   nhigh = (selh + pixY-1) / pixY;
-  
+
   stx = selx - (nwide*pixX - selw)/2;
   sty = sely - (nhigh*pixY - selh)/2;
-  
+
   y = sty;
   for (i=0; i<nhigh; i++, y+=pixY) {
     ProgressMeter(0, nhigh-1, i, "Pixelize");
-    
+
     x = stx;
     for (j=0; j<nwide; j++, x+=pixX) {
-      
+
       /* COMPUTE AVERAGE COLOR FOR RECT:[x,y,pixX,pixY] */
       nsum = rsum = gsum = bsum = 0;
       for (y1=y; y1<y+pixY; y1++) {
@@ -1357,17 +1357,17 @@
 	  }
 	}
       }
-      
+
       if (nsum>0) {   /* just to be safe... */
 	rsum /= nsum;  gsum /= nsum;  bsum /= nsum;
 	RANGE(rsum,0,255);  RANGE(gsum,0,255);  RANGE(bsum,0,255);
       }
-      
-      
+
+
       /* STORE color in rect:[x,y,pixX,pixY] */
       for (y1=y; y1<y+pixY; y1++) {
 	if (!j && (y1 & 255)==0) WaitCursor();
-	
+
 	pp = results + (y1 * w + x) * 3;
 	for (x1=x; x1<x+pixX; x1++, pp+=3) {
 	  if (PTINRECT(x1,y1, selx,sely,selw,selh)) {
@@ -1381,7 +1381,7 @@
   printUTime("end of pixelize");
 }
 
-  
+
 
 /************************/
 static void doSpread(pic24, w, h, results, selx,sely,selw,selh, pixX, pixY)
@@ -1393,17 +1393,17 @@
      by pixX,pixY.  If pixX<0, it is treated as a single 'distance' value
      (after being abs()'d). */
 
-  /* assumes that initially 'results' is a copy of pic24.  Doesn't 
+  /* assumes that initially 'results' is a copy of pic24.  Doesn't
      even look at pic24 */
-  
+
   byte  *pp, *dp, r,g,b;
-  int    x,y, dx,dy, x1,y1, d, xrng, xoff, yrng, yoff, i,j;
+  int    x,y, x1,y1, d;
   int    minx, maxx, miny, maxy, rdist;
   time_t nowT;
 
   time(&nowT);
   srandom((unsigned int) nowT);
-  
+
   printUTime("start of spread");
 
   for (y=sely; y<sely+selh; y++) {
@@ -1453,7 +1453,7 @@
   printUTime("end of spread");
 }
 
-  
+
 
 /************************/
 static void doMedianFilter(pic24, w, h, results, selx,sely,selw,selh, n)
@@ -1468,7 +1468,7 @@
   register byte *p24;
   register int   rsum,gsum,bsum;
   byte          *rp;
-  int            i,j,k,x,y,x1,y1,count,n2,nsq,c2;
+  int            x,y,x1,y1,count,n2,nsq,c2;
   int           *rtab, *gtab, *btab;
 
   printUTime("start of doMedianFilter");
@@ -1494,7 +1494,7 @@
       for (y1=y-n2; y1<=y+n2; y1++) {
 
 	if (y1>=sely && y1<sely+selh) {
-	  p24 = pic24 + y1*w*3 +(x-n2)*3; 
+	  p24 = pic24 + y1*w*3 +(x-n2)*3;
 
 	  for (x1=x-n2; x1<=x+n2; x1++) {
 	    if (x1>=selx && x1<selx+selw) {
@@ -1509,12 +1509,12 @@
       }
 
 
-      /* now sort the rtab,gtab,btab arrays, (using shell sort) 
-	 and pick the middle value.  doing it in-line, rather than 
+      /* now sort the rtab,gtab,btab arrays, (using shell sort)
+	 and pick the middle value.  doing it in-line, rather than
 	 as a function call (ie, 'qsort()') , for speed */
-      {  
+      {
 	int i,j,t,d;
-	
+
 	for (d=count/2;  d>0;  d=d/2) {
 	  for (i=d; i<count; i++) {
 	    for (j=i-d;  j>=0 && rtab[j]>rtab[j+d];  j-=d) {
@@ -1531,14 +1531,14 @@
 	  }
 	}
       }
-      
+
       c2 = count/2;
       *rp++ = (byte) ( (count&1) ? rtab[c2] : (rtab[c2] + rtab[c2-1])/2);
       *rp++ = (byte) ( (count&1) ? gtab[c2] : (gtab[c2] + gtab[c2-1])/2);
       *rp++ = (byte) ( (count&1) ? btab[c2] : (btab[c2] + btab[c2-1])/2);
     }
   }
-  
+
   free(rtab);  free(gtab);  free(btab);
   printUTime("end of doMedianFilter");
 }
@@ -1549,7 +1549,7 @@
 static void intsort(a, n)
      int *a, n;
 {
-  /* uses the shell-sort algorithm.  for the relatively small data sets 
+  /* uses the shell-sort algorithm.  for the relatively small data sets
      we'll be using, should be quicker than qsort() because of all the
      function calling overhead associated with qsort(). */
 
@@ -1571,7 +1571,7 @@
      byte **pic24, **tmpPic;
 {
   /* generates a 24-bit version of 'pic', if neccessary, and also mallocs
-   * a pWIDE*pHIGH*3 24-bit output pic.  
+   * a pWIDE*pHIGH*3 24-bit output pic.
    *
    * Returns '1' if there's some sort of screwup, '0' if cool
    */
@@ -1588,7 +1588,7 @@
   *tmpPic = (byte *) calloc((size_t) (pWIDE * pHIGH * 3), (size_t) 1);
   if (!(*tmpPic)) {
     SetCursors(-1);
-    ErrPopUp("Unable to malloc() tmp 24-bit image in start24bitAlg()", 
+    ErrPopUp("Unable to malloc() tmp 24-bit image in start24bitAlg()",
 	     "\nTough!");
     if (picType == PIC8) free(*pic24);
     return 1;
@@ -1609,16 +1609,16 @@
   saveOrigPic();  /* also kills pic/cpic/epic/egampic/theImage, NOT pic24 */
 
   /* copy results to pic24 */
-  xvbcopy((char *) outPic, (char *) pic24, (size_t) (pWIDE*pHIGH*3)); 
+  xvbcopy((char *) outPic, (char *) pic24, (size_t) (pWIDE*pHIGH*3));
   free(outPic);
 
   if (picType == PIC8) {
     pic = Conv24to8(pic24, pWIDE, pHIGH, ncols, rMap,gMap,bMap);
     free(pic24);
-    if (!pic) { 
+    if (!pic) {
       SetCursors(-1);
       ErrPopUp("Some sort of failure occured in 24to8 conversion\n","\nDamn!");
-      NoAlg(); 
+      NoAlg();
       return;
     }
   }
@@ -1632,7 +1632,7 @@
 static void saveOrigPic()
 {
   /* saves original picture into origPic, if it hasn't already been done.
-     This allows us to undo algorithms...  
+     This allows us to undo algorithms...
 
      Also, frees all pics, (except 'pic', if we're in PIC24 mode) */
 
@@ -1649,7 +1649,7 @@
     /* make a backup copy of 'pic' */
     origPic = (byte *) malloc((size_t)(pWIDE*pHIGH*((picType==PIC8) ? 1 : 3)));
     if (!origPic) FatalError("out of memory in 'saveOrigPic()'");
-    xvbcopy((char *) pic, (char *) origPic, 
+    xvbcopy((char *) pic, (char *) origPic,
 	    (size_t) (pWIDE * pHIGH * ((picType==PIC8) ? 1 : 3)));
 
     origPicType = picType;
diff -ruN xv-3.10a/xvbmp.c xv-3.10a-bugfixes/xvbmp.c
--- xv-3.10a/xvbmp.c	1994-12-22 14:34:42.000000000 -0800
+++ xv-3.10a-bugfixes/xvbmp.c	2005-03-27 18:12:17.000000000 -0800
@@ -14,7 +14,7 @@
    rest of the pic is filled with 0's.
 
    a file with garbage characters in it is an unloadable file.  All allocated
-   stuff is tossed, and LoadPBM returns non-zero
+   stuff is tossed, and LoadBMP returns non-zero
 
    not being able to malloc is a Fatal Error.  The program is aborted. */
 
@@ -54,9 +54,9 @@
 {
   FILE         *fp;
   int          i, c, c1, rv;
-  unsigned int bfSize, bfOffBits, biSize, biWidth, biHeight, biPlanes;
-  unsigned int biBitCount, biCompression, biSizeImage, biXPelsPerMeter;
-  unsigned int biYPelsPerMeter, biClrUsed, biClrImportant;
+  u_int        bfSize, bfOffBits, biSize, biWidth, biHeight, biPlanes;
+  u_int        biBitCount, biCompression, biSizeImage, biXPelsPerMeter;
+  u_int        biYPelsPerMeter, biClrUsed, biClrImportant;
   int bPad;
   char         *cmpstr;
   byte         *pic24, *pic8;
@@ -69,7 +69,7 @@
 
   fp = xv_fopen(fname,"r");
   if (!fp) return (bmpError(bname, "couldn't open file"));
-  
+
   fseek(fp, 0L, 2);      /* figure out the file size */
   filesize = ftell(fp);
   fseek(fp, 0L, 0);
@@ -104,11 +104,11 @@
     biHeight        = getshort(fp);
     biPlanes        = getshort(fp);
     biBitCount      = getshort(fp);
-    
+
     /* Not in old versions so have to compute them*/
     biSizeImage = (((biPlanes * biBitCount*biWidth)+31)/32)*4*biHeight;
-    
-    biCompression   = BI_RGB; 
+
+    biCompression   = BI_RGB;
     biXPelsPerMeter = biYPelsPerMeter = 0;
     biClrUsed       = biClrImportant  = 0;
   }
@@ -127,11 +127,14 @@
 
 
   /* error checking */
-  if ((biBitCount!=1 && biBitCount!=4 && biBitCount!=8 && biBitCount!=24) || 
-      biPlanes!=1 || biCompression>BI_RLE4) {
-
-    sprintf(buf,"Bogus BMP File!  (bitCount=%d, Planes=%d, Compression=%d)",
-	    biBitCount, biPlanes, biCompression);
+  if ((biBitCount!=1 && biBitCount!=4 && biBitCount!=8 && biBitCount!=24) ||
+      biPlanes!=1 || biCompression>BI_RLE4 ||
+      biWidth<=0 || biHeight<=0 ||
+      (biClrUsed && biClrUsed > (1 << biBitCount))) {
+
+    sprintf(buf,
+	    "Bogus BMP File!  (%dx%d, Bits=%d, Colors=%d, Planes=%d, Compr=%d)",
+	    biWidth, biHeight, biBitCount, biClrUsed, biPlanes, biCompression);
 
     bmpError(bname, buf);
     goto ERROR;
@@ -154,7 +157,7 @@
     /* skip ahead to colormap, using biSize */
     c = biSize - 40;    /* 40 bytes read from biSize to biClrImportant */
     for (i=0; i<c; i++) getc(fp);
-    
+
     bPad = bfOffBits - (biSize + 14);
   }
 
@@ -162,6 +165,11 @@
   if (biBitCount!=24) {
     int i, cmaplen;
 
+/* this is superfluous; see identical test in "error checking" block above
+  if (biClrUsed > (1 << biBitCount))
+    biClrUsed = (1 << biBitCount);
+ */
+
     cmaplen = (biClrUsed) ? biClrUsed : 1 << biBitCount;
     for (i=0; i<cmaplen; i++) {
       pinfo->b[i] = getc(fp);
@@ -173,7 +181,7 @@
       }
     }
 
-    if (FERROR(fp)) 
+    if (FERROR(fp))
       { bmpError(bname,"EOF reached in BMP colormap"); goto ERROR; }
 
     if (DEBUG>1) {
@@ -188,7 +196,7 @@
   if (biSize != WIN_OS2_OLD) {
     /* Waste any unused bytes between the colour map (if present)
        and the start of the actual bitmap data. */
-    
+
     while (bPad > 0) {
       (void) getc(fp);
       bPad--;
@@ -198,11 +206,21 @@
   /* create pic8 or pic24 */
 
   if (biBitCount==24) {
-    pic24 = (byte *) calloc((size_t) biWidth * biHeight * 3, (size_t) 1);
+    u_int npixels = biWidth * biHeight;
+    u_int count = 3 * npixels;
+
+    if (biWidth == 0 || biHeight == 0 || npixels/biWidth != biHeight ||
+        count/3 != npixels)
+      return (bmpError(bname, "image dimensions too large"));
+    pic24 = (byte *) calloc((size_t) count, (size_t) 1);
     if (!pic24) return (bmpError(bname, "couldn't malloc 'pic24'"));
   }
   else {
-    pic8 = (byte *) calloc((size_t) biWidth * biHeight, (size_t) 1);
+    u_int npixels = biWidth * biHeight;
+
+    if (biWidth == 0 || biHeight == 0 || npixels/biWidth != biHeight)
+      return (bmpError(bname, "image dimensions too large"));
+    pic8 = (byte *) calloc((size_t) npixels, (size_t) 1);
     if (!pic8) return(bmpError(bname, "couldn't malloc 'pic8'"));
   }
 
@@ -216,7 +234,7 @@
 					  biCompression);
   else                      rv = loadBMP24(fp,pic24,biWidth,biHeight);
 
-  if (rv) bmpError(bname, "File appears truncated.  Winging it.\n");
+  if (rv) bmpError(bname, "File appears truncated.  Winging it.");
 
   fclose(fp);
 
@@ -254,7 +272,7 @@
  ERROR:
   fclose(fp);
   return 0;
-}  
+}
 
 
 /*******************************************/
@@ -277,7 +295,7 @@
 	c = getc(fp);
 	bitnum = 0;
       }
-      
+
       if (j<w) {
 	*pp++ = (c & 0x80) ? 1 : 0;
 	c <<= 1;
@@ -287,7 +305,7 @@
   }
 
   return (FERROR(fp));
-}  
+}
 
 
 
@@ -299,24 +317,24 @@
 {
   int   i,j,c,c1,x,y,nybnum,padw,rv;
   byte *pp;
-  
-  
+
+
   rv = 0;
   c = c1 = 0;
-  
+
   if (comp == BI_RGB) {   /* read uncompressed data */
     padw = ((w + 7)/8) * 8; /* 'w' padded to a multiple of 8pix (32 bits) */
-    
+
     for (i=h-1; i>=0; i--) {
       pp = pic8 + (i * w);
       if ((i&0x3f)==0) WaitCursor();
-      
+
       for (j=nybnum=0; j<padw; j++,nybnum++) {
 	if ((nybnum & 1) == 0) { /* read next byte */
 	  c = getc(fp);
 	  nybnum = 0;
 	}
-	
+
 	if (j<w) {
 	  *pp++ = (c & 0xf0) >> 4;
 	  c <<= 4;
@@ -325,55 +343,55 @@
       if (FERROR(fp)) break;
     }
   }
-  
+
   else if (comp == BI_RLE4) {  /* read RLE4 compressed data */
-    x = y = 0;  
+    x = y = 0;
     pp = pic8 + x + (h-y-1)*w;
-    
+
     while (y<h) {
       c = getc(fp);  if (c == EOF) { rv = 1;  break; }
-      
+
       if (c) {                                   /* encoded mode */
 	c1 = getc(fp);
-	for (i=0; i<c; i++,x++,pp++) 
+	for (i=0; i<c; i++,x++,pp++)
 	  *pp = (i&1) ? (c1 & 0x0f) : ((c1>>4)&0x0f);
       }
-      
+
       else {    /* c==0x00  :  escape codes */
 	c = getc(fp);  if (c == EOF) { rv = 1;  break; }
-	
+
 	if      (c == 0x00) {                    /* end of line */
 	  x=0;  y++;  pp = pic8 + x + (h-y-1)*w;
-	} 
-	
+	}
+
 	else if (c == 0x01) break;               /* end of pic8 */
-	
+
 	else if (c == 0x02) {                    /* delta */
 	  c = getc(fp);  x += c;
 	  c = getc(fp);  y += c;
 	  pp = pic8 + x + (h-y-1)*w;
 	}
-	
+
 	else {                                   /* absolute mode */
 	  for (i=0; i<c; i++, x++, pp++) {
 	    if ((i&1) == 0) c1 = getc(fp);
 	    *pp = (i&1) ? (c1 & 0x0f) : ((c1>>4)&0x0f);
 	  }
-	  
+
 	  if (((c&3)==1) || ((c&3)==2)) getc(fp);  /* read pad byte */
 	}
       }  /* escape processing */
       if (FERROR(fp)) break;
     }  /* while */
   }
-  
+
   else {
     fprintf(stderr,"unknown BMP compression type 0x%0x\n", comp);
   }
-  
+
   if (FERROR(fp)) rv = 1;
   return rv;
-}  
+}
 
 
 
@@ -385,7 +403,7 @@
 {
   int   i,j,c,c1,padw,x,y,rv;
   byte *pp;
-  
+
   rv = 0;
 
   if (comp == BI_RGB) {   /* read uncompressed data */
@@ -404,7 +422,7 @@
   }
 
   else if (comp == BI_RLE8) {  /* read RLE8 compressed data */
-    x = y = 0;  
+    x = y = 0;
     pp = pic8 + x + (h-y-1)*w;
 
     while (y<h) {
@@ -420,7 +438,7 @@
 
 	if      (c == 0x00) {                    /* end of line */
 	  x=0;  y++;  pp = pic8 + x + (h-y-1)*w;
-	} 
+	}
 
 	else if (c == 0x01) break;               /* end of pic8 */
 
@@ -435,21 +453,21 @@
 	    c1 = getc(fp);
 	    *pp = c1;
 	  }
-	  
+
 	  if (c & 1) getc(fp);  /* odd length run: read an extra pad byte */
 	}
       }  /* escape processing */
       if (FERROR(fp)) break;
     }  /* while */
   }
-  
+
   else {
     fprintf(stderr,"unknown BMP compression type 0x%0x\n", comp);
   }
 
   if (FERROR(fp)) rv = 1;
   return rv;
-}  
+}
 
 
 
@@ -469,7 +487,7 @@
   for (i=h-1; i>=0; i--) {
     pp = pic24 + (i * w * 3);
     if ((i&0x3f)==0) WaitCursor();
-    
+
     for (j=0; j<w; j++) {
       pp[2] = getc(fp);   /* blue */
       pp[1] = getc(fp);   /* green */
@@ -484,30 +502,30 @@
   }
 
   return rv;
-}  
+}
 
 
 
 /*******************************************/
-static unsigned int getshort(fp)
+static u_int getshort(fp)
      FILE *fp;
 {
   int c, c1;
   c = getc(fp);  c1 = getc(fp);
-  return ((unsigned int) c) + (((unsigned int) c1) << 8);
+  return ((u_int) c) + (((u_int) c1) << 8);
 }
 
 
 /*******************************************/
-static unsigned int getint(fp)
+static u_int getint(fp)
      FILE *fp;
 {
   int c, c1, c2, c3;
   c = getc(fp);  c1 = getc(fp);  c2 = getc(fp);  c3 = getc(fp);
-  return ((unsigned int) c) +
-         (((unsigned int) c1) << 8) + 
-	 (((unsigned int) c2) << 16) +
-	 (((unsigned int) c3) << 24);
+  return  ((u_int) c) +
+         (((u_int) c1) << 8) +
+	 (((u_int) c2) << 16) +
+	 (((u_int) c3) << 24);
 }
 
 
@@ -518,7 +536,7 @@
 {
   int c, c1;
 
-  c = ((unsigned int ) i) & 0xff;  c1 = (((unsigned int) i)>>8) & 0xff;
+  c = ((u_int) i) & 0xff;  c1 = (((u_int) i)>>8) & 0xff;
   putc(c, fp);   putc(c1,fp);
 }
 
@@ -529,10 +547,10 @@
      int i;
 {
   int c, c1, c2, c3;
-  c  = ((unsigned int ) i)      & 0xff;  
-  c1 = (((unsigned int) i)>>8)  & 0xff;
-  c2 = (((unsigned int) i)>>16) & 0xff;
-  c3 = (((unsigned int) i)>>24) & 0xff;
+  c  =  ((u_int) i)      & 0xff;
+  c1 = (((u_int) i)>>8)  & 0xff;
+  c2 = (((u_int) i)>>16) & 0xff;
+  c3 = (((u_int) i)>>24) & 0xff;
 
   putc(c, fp);   putc(c1,fp);  putc(c2,fp);  putc(c3,fp);
 }
@@ -562,11 +580,11 @@
    *    8-bit image
    * note that PIC24 and F_BWDITHER/F_REDUCED won't happen
    *
-   * if colorstyle == F_BWDITHER, it writes a 1-bit image 
+   * if colorstyle == F_BWDITHER, it writes a 1-bit image
    *
    */
 
-  int i,j, nc, nbits, bperlin, cmaplen;
+  int i,j, nc, nbits, bperlin, cmaplen, npixels;
   byte *graypic, *sp, *dp, graymap[256];
 
   nc = nbits = cmaplen = 0;
@@ -576,10 +594,16 @@
     /* generate a faked 8-bit per pixel image with a grayscale cmap,
        so that it can just fall through existing 8-bit code */
 
-    graypic = (byte *) malloc((size_t) w*h);
+    npixels = w * h;
+    if (w <= 0 || h <= 0 || npixels/w != h) {
+      SetISTR(ISTR_WARNING, "image dimensions too large");
+      return -1;
+    }
+
+    graypic = (byte *) malloc((size_t) npixels);
     if (!graypic) FatalError("unable to malloc in WriteBMP()");
 
-    for (i=0,sp=pic824,dp=graypic; i<w*h; i++,sp+=3, dp++) {
+    for (i=0,sp=pic824,dp=graypic; i<npixels; i++,sp+=3, dp++) {
       *dp = MONO(sp[0],sp[1],sp[2]);
     }
 
@@ -611,7 +635,7 @@
     for (i=0; i<numcols; i++) {
       /* see if color #i is a duplicate */
       for (j=0; j<i; j++) {
-	if (rmap[i] == rmap[j] && gmap[i] == gmap[j] && 
+	if (rmap[i] == rmap[j] && gmap[i] == gmap[j] &&
 	    bmap[i] == bmap[j]) break;
       }
 
@@ -689,13 +713,13 @@
 #else
   if (!FERROR(fp)) return -1;
 #endif
-  
+
   return 0;
 }
 
 
-	  
-	  
+
+
 /*******************************************/
 static void writeBMP1(fp, pic8, w, h)
      FILE *fp;
@@ -708,7 +732,7 @@
   padw = ((w + 31)/32) * 32;  /* 'w', padded to be a multiple of 32 */
 
   for (i=h-1; i>=0; i--) {
-    pp = pic8 + (i * w);  
+    pp = pic8 + (i * w);
     if ((i&0x3f)==0) WaitCursor();
 
     for (j=bitnum=c=0; j<=padw; j++,bitnum++) {
@@ -716,7 +740,7 @@
 	putc(c,fp);
 	bitnum = c = 0;
       }
-      
+
       c <<= 1;
 
       if (j<w) {
@@ -724,7 +748,7 @@
       }
     }
   }
-}  
+}
 
 
 
@@ -758,7 +782,7 @@
       }
     }
   }
-}  
+}
 
 
 
@@ -768,7 +792,7 @@
      byte *pic8;
      int  w,h;
 {
-  int   i,j,c,padw;
+  int   i,j,padw;
   byte *pp;
 
   padw = ((w + 3)/4) * 4; /* 'w' padded to a multiple of 4pix (32 bits) */
@@ -780,7 +804,7 @@
     for (j=0; j<w; j++) putc(pc2nc[*pp++], fp);
     for ( ; j<padw; j++) putc(0, fp);
   }
-}  
+}
 
 
 /*******************************************/
@@ -789,7 +813,7 @@
      byte *pic24;
      int  w,h;
 {
-  int   i,j,c,padb;
+  int   i,j,padb;
   byte *pp;
 
   padb = (4 - ((w*3) % 4)) & 0x03;  /* # of pad bytes to write at EOscanline */
@@ -807,7 +831,7 @@
 
     for (j=0; j<padb; j++) putc(0, fp);
   }
-}  
+}
 
 
 
diff -ruN xv-3.10a/xvbrowse.c xv-3.10a-bugfixes/xvbrowse.c
--- xv-3.10a/xvbrowse.c	1995-01-19 09:49:17.000000000 -0800
+++ xv-3.10a-bugfixes/xvbrowse.c	2004-05-16 18:01:25.000000000 -0700
@@ -1,6 +1,6 @@
 /*
  *  xvbrowse.c  -  visual schnauzer routines
- * 
+ *
  *  includes:
  *      void CreateBrowse(char *, char *, char *, char *, char *);
  *      void OpenBrowse();
@@ -34,7 +34,7 @@
 #include "bits/br_sock"
 #include "bits/br_fifo"
 #include "bits/br_error"
-#include "bits/br_unknown"
+/* #include "bits/br_unknown"	commented out (near line 492) */
 #include "bits/br_cmpres"
 
 #include "bits/br_gif"
@@ -97,7 +97,7 @@
 #define BF_MAX      28    /* # of built-in icons */
 
 #define ISLOADABLE(ftyp) (ftyp!=BF_DIR  && ftyp!=BF_CHR && ftyp!=BF_BLK && \
-			  ftyp!=BF_SOCK && ftyp!=BF_FIFO) 
+			  ftyp!=BF_SOCK && ftyp!=BF_FIFO)
 
 #define DEF_BROWWIDE 615   /* default size of window */
 #define DEF_BROWHIGH 356
@@ -150,12 +150,12 @@
 static char *hideHstr = "Hide 'hidden' files";
 
 static char *cmdMList[] = { "Change directory...\t^c",
-		            "Delete file(s)\t^d",  
-			    "New directory...\t^n",   
-			    "Rename file...\t^r",     
+		            "Delete file(s)\t^d",
+			    "New directory...\t^n",
+			    "Rename file...\t^r",
 			    "Rescan directory\t^s",
-			    "Update icons\t^u",    
-			    "Open new window\t^w", 
+			    "Update icons\t^u",
+			    "Open new window\t^w",
 			    "Generate icon(s)\t^g",
 			    "Select all files\t^a",
 			    "Text view\t^t",
@@ -260,7 +260,7 @@
 static void genSelectedIcons PARM((BROWINFO *));
 static void genIcon          PARM((BROWINFO *, BFIL *));
 static void loadThumbFile    PARM((BROWINFO *, BFIL *));
-static void writeThumbFile   PARM((BROWINFO *, BFIL *, byte *, int, 
+static void writeThumbFile   PARM((BROWINFO *, BFIL *, byte *, int,
 				      int, char *));
 
 static void makeThumbDir     PARM((BROWINFO *));
@@ -284,7 +284,7 @@
 static void rm_dir           PARM((BROWINFO *, char *));
 static void rm_dir1          PARM((BROWINFO *));
 
-static void dragFiles        PARM((BROWINFO *, BROWINFO *, char *, char *, 
+static void dragFiles        PARM((BROWINFO *, BROWINFO *, char *, char *,
 				   char *, char **, int, int));
 static int  moveFile         PARM((char *, char *));
 static int  copyFile         PARM((char *, char *));
@@ -369,8 +369,8 @@
       if (gset & YNegative) gy1 = gy - i * 20;
 	               else gy1 = gy + i * 20;
 
-      if ((gset & WidthValue) && (gset & HeightValue)) 
-	sprintf(wgeom, "%dx%d%s%d%s%d", gw, gh, 
+      if ((gset & WidthValue) && (gset & HeightValue))
+	sprintf(wgeom, "%dx%d%s%d%s%d", gw, gh,
 		(gset & XNegative) ? "-" : "+", abs(gx1),
 		(gset & YNegative) ? "-" : "+", abs(gy1));
       else
@@ -402,11 +402,11 @@
 
     /* note: everything is sized and positioned in ResizeBrowse() */
 
-    br->iconW = XCreateSimpleWindow(theDisp, br->win, 1,1, 100,100, 
+    br->iconW = XCreateSimpleWindow(theDisp, br->win, 1,1, 100,100,
 				     1,browfg,browbg);
     if (!br->iconW) FatalError("can't create schnauzer icon window!");
 
-    SCCreate(&(br->scrl), br->win, 0,0, 1,100, 0,0,0,0, 
+    SCCreate(&(br->scrl), br->win, 0,0, 1,100, 0,0,0,0,
 	     browfg, browbg, browhi, browlo, drawIconWin);
 
 
@@ -486,7 +486,7 @@
   bfIcons[BF_SOCK]=MakePix1(br->win,br_sock_bits,br_sock_width,br_sock_height);
   bfIcons[BF_FIFO]=MakePix1(br->win,br_fifo_bits,br_fifo_width,br_fifo_height);
 
-  bfIcons[BF_ERROR]   = MakePix1(br->win, br_error_bits, 
+  bfIcons[BF_ERROR]   = MakePix1(br->win, br_error_bits,
 			       br_error_width,     br_error_height);
 
 /* bfIcons[BF_UNKNOWN] = MakePix1(br->win, br_unknown_bits,
@@ -501,9 +501,9 @@
 
   bfIcons[BF_SUNRAS]  = MakePix1(br->win, br_sunras_bits,
 				 br_sunras_width, br_sunras_height);
-  bfIcons[BF_BMP]     = MakePix1(br->win,br_bmp_bits, 
+  bfIcons[BF_BMP]     = MakePix1(br->win,br_bmp_bits,
 				 br_bmp_width, br_bmp_height);
-  bfIcons[BF_UTAHRLE] = MakePix1(br->win, br_utahrle_bits, 
+  bfIcons[BF_UTAHRLE] = MakePix1(br->win, br_utahrle_bits,
 				 br_utahrle_width, br_utahrle_height);
 
   bfIcons[BF_IRIS]=MakePix1(br->win,br_iris_bits,br_iris_width,br_iris_height);
@@ -528,13 +528,13 @@
 
   /* check that they all got built */
   for (i=0; i<BF_MAX && bfIcons[i]; i++);
-  if (i<BF_MAX) 
+  if (i<BF_MAX)
     FatalError("unable to create all built-in icons for schnauzer");
 
   for (i=0; i<MAXBRWIN; i++) {
     resizeBrowse(&binfo[i], DEF_BROWWIDE, DEF_BROWHIGH);
 
-    XSelectInput(theDisp, binfo[i].win, ExposureMask | ButtonPressMask | 
+    XSelectInput(theDisp, binfo[i].win, ExposureMask | ButtonPressMask |
 		 KeyPressMask | StructureNotifyMask);
   }
 
@@ -557,7 +557,7 @@
     movecurs = XCreatePixmapCursor(theDisp,mcpix,fcmpix,&cursfg,&cursbg,13,13);
     copycurs = XCreatePixmapCursor(theDisp,ccpix,fcmpix,&cursfg,&cursbg,13,13);
     delcurs  = XCreatePixmapCursor(theDisp,dcpix,fcmpix,&cursbg,&cursfg,13,13);
-    if (!movecurs || !copycurs || !delcurs) 
+    if (!movecurs || !copycurs || !delcurs)
       FatalError("unable to create schnauzer cursors...");
   }
   else FatalError("unable to create schnauzer cursors...");
@@ -566,7 +566,7 @@
   XFreePixmap(theDisp, ccpix);
   XFreePixmap(theDisp, dcpix);
   XFreePixmap(theDisp, fcmpix);
-    
+
 
   hasBeenSized = 1;  /* we can now start looking at browse events */
 }
@@ -586,11 +586,11 @@
     if (!br->vis) break;
   }
   if (i==MAXBRWIN) return;  /* full up: shouldn't happen */
-  
+
   anyBrowUp = 1;
   XMapRaised(theDisp, br->win);
   br->vis = 1;
-  
+
   freeBfList(br);
 
   /* see if some browser is pointing to the same path as CWD.  If so,
@@ -645,7 +645,7 @@
   /* free all info for this browse window */
   freeBfList(br);
   sprintf(br->path, BOGUSPATH);
-  
+
   /* turn on 'open new window' command doodads */
   windowMB.dim[WMB_BROWSE] = 0;
   for (i=0; i<MAXBRWIN; i++) {
@@ -739,8 +739,7 @@
   /* checks event to see if it's a browse-window related thing.  If it
      is, it eats the event and returns '1', otherwise '0'. */
 
-  int    i, rv;
-  char buf[1024];
+  int    rv;
 
   rv = 1;
 
@@ -788,7 +787,7 @@
 	fprintf(stderr,"grouped %d expose events into %d,%d %dx%d rect\n",
 		count, rect.x, rect.y, rect.width, rect.height);
       }
-      
+
       if      (e->window == br->win)   drawBrow(br);
 
       else if (e->window == br->iconW)
@@ -811,7 +810,7 @@
       if      (e->window == br->win)      clickBrow(br,x,y);
       else if (e->window == br->scrl.win) SCTrack(&(br->scrl),x,y);
       else if (e->window == br->iconW) {
-	i = clickIconWin(br, x,y,(unsigned long) e->time, 
+	i = clickIconWin(br, x,y,(unsigned long) e->time,
 			 (e->state&ControlMask) || (e->state&ShiftMask));
 
       }
@@ -837,7 +836,7 @@
 
       if (br->wide != e->width || br->high != e->height) {
 	if (DEBUG) fprintf(stderr,"Forcing a redraw!  (from configure)\n");
-	XClearArea(theDisp, br->win, 0, 0, 
+	XClearArea(theDisp, br->win, 0, 0,
 		   (u_int) e->width, (u_int) e->height, True);
 	resizeBrowse(br, e->width, e->height);
       }
@@ -877,7 +876,7 @@
      int w,h;
 {
   XSizeHints hints;
-  int        i, minv, maxv, curv, page, maxh;
+  int        i, maxv, page, maxh;
 
   if (br->wide == w && br->high == h) return;  /* no change in size */
 
@@ -895,7 +894,7 @@
   br->iwHigh = (maxh / ISPACE_HIGH) * ISPACE_HIGH;
   if (br->iwHigh < ISPACE_HIGH) br->iwHigh = ISPACE_HIGH;
 
-  XMoveResizeWindow(theDisp, br->iconW, LRMARGINS, TOPMARGIN, 
+  XMoveResizeWindow(theDisp, br->iconW, LRMARGINS, TOPMARGIN,
 		    (u_int) br->iwWide, (u_int) br->iwHigh);
 
 
@@ -907,11 +906,11 @@
   for (i=0; i<BR_NBUTTS; i++) {
     /* 'close' always goes on right-most edge */
 
-    if (i<br->numbutshown) 
+    if (i<br->numbutshown)
       br->but[i].x = br->wide - (1+br->numbutshown-i) * (BUTTW+5);
     else if (i==BR_CLOSE)
       br->but[i].x = br->wide - (BUTTW+5);
-    else 
+    else
       br->but[i].x = br->wide + 10;    /* offscreen */
 
     br->but[i].y = br->high - BUTTH - 5;
@@ -928,11 +927,11 @@
   br->numWide = br->iwWide / ISPACE_WIDE;
   br->visHigh = br->iwHigh / ISPACE_HIGH;
 
-  /* compute minv,maxv,curv,page values based on new current size */
+  /* compute maxv,page values based on new current size */
   computeScrlVals(br, &maxv, &page);
   if (br->scrl.val>maxv) br->scrl.val = maxv;
-  
-  SCChange(&br->scrl, LRMARGINS+br->iwWide+1, TOPMARGIN, 
+
+  SCChange(&br->scrl, LRMARGINS+br->iwWide+1, TOPMARGIN,
 	   1, br->iwHigh, 0, maxv, br->scrl.val, page);
 }
 
@@ -945,7 +944,7 @@
   /* put string in *all* browse windows */
   int i;
 
-  for (i=0; i<MAXBRWIN; i++) 
+  for (i=0; i<MAXBRWIN; i++)
     setBrowStr(&binfo[i], str);
 }
 
@@ -956,6 +955,7 @@
      char *str;
 {
   strncpy(br->dispstr, str, (size_t) 256);
+  br->dispstr[255] = '\0';
   drawBrowStr(br);
   XFlush(theDisp);
 }
@@ -992,7 +992,7 @@
 
 	char tmp[64];
 
-	sprintf(tmp, "Re-coloring icons:  processed %d out of %d...", 
+	sprintf(tmp, "Re-coloring icons:  processed %d out of %d...",
 		i+1, br->bfLen);
 	setBrowStr(br, tmp);
       }
@@ -1011,14 +1011,14 @@
 {
   /* called when file 'name' has been deleted.  If any of the browsers
      were showing the directory that the file was in, does a rescan() */
-  
+
   int  i;
   char buf[MAXPATHLEN + 2], *tmp;
 
   strcpy(buf, name);
   tmp = BaseName(buf);
   *tmp = '\0';     /* truncate after last '/' */
-  
+
   for (i=0; i<MAXBRWIN; i++) {
     if (strcmp(binfo[i].path, buf)==0) rescanDir(&binfo[i]);
   }
@@ -1070,9 +1070,9 @@
   case BR_GENICON: genSelectedIcons(br);  break;
 
   case BR_SELALL:  {
-                     int i;  char buf[128];
+                     int i;
 
-		     for (i=0; i<br->bfLen; i++) 
+		     for (i=0; i<br->bfLen; i++)
 		       br->bfList[i].lit = 1;
 		     br->numlit = br->bfLen;
 
@@ -1087,13 +1087,13 @@
                    break;
 
   case BR_TEXTVIEW: doTextCmd(br);       break;
- 
+
   case BR_QUIT:     Quit(0);             break;
 
   case BR_CLOSE:    closeBrowse(br);     break;
 
   case BR_HIDDEN:   br->showhidden = !br->showhidden;
-                    br->cmdMB.list[cmd] = (br->showhidden) 
+                    br->cmdMB.list[cmd] = (br->showhidden)
 		                              ? hideHstr : showHstr;
                     rescanDir(br);
                     break;
@@ -1137,16 +1137,16 @@
 
   if (br->bfLen != 1) sprintf(foo, "%d files", br->bfLen);
   else strcpy(foo, "1 file");
-    
+
   XSetForeground(theDisp, theGC, browbg);
-  XFillRectangle(theDisp,br->win, theGC, x+1,y+1, 
+  XFillRectangle(theDisp,br->win, theGC, x+1,y+1,
 		 (u_int) StringWidth(foo)+6, (u_int) br->dirMB.h-1);
 
   XSetForeground(theDisp,theGC,browfg);
   XDrawRectangle(theDisp,br->win, theGC, x,y,
 		 (u_int) StringWidth(foo)+7, (u_int) br->dirMB.h);
 
-  Draw3dRect(br->win, x+1, y+1, (u_int) StringWidth(foo)+5, 
+  Draw3dRect(br->win, x+1, y+1, (u_int) StringWidth(foo)+5,
 	     (u_int) br->dirMB.h-2, R3D_IN, 2,  browhi, browlo, browbg);
 
   XSetForeground(theDisp,theGC,browfg);
@@ -1163,7 +1163,7 @@
 
   if (nf != 1) sprintf(foo,"%d files",nf);
   else strcpy(foo,"1 file");
-    
+
   XClearArea(theDisp,br->win, 30, br->dirMB.y,
 	     (u_int) StringWidth(foo)+8, (u_int) br->dirMB.h+1, False);
 }
@@ -1185,13 +1185,13 @@
 
   XSetForeground(theDisp,theGC,browfg);
   XDrawRectangle(theDisp,br->win, theGC, x,y, (u_int) w, (u_int) h);
-  Draw3dRect(br->win, x+1, y+1, (u_int) w-2, (u_int) h-2, 
+  Draw3dRect(br->win, x+1, y+1, (u_int) w-2, (u_int) h-2,
 	     R3D_IN, 2,  browhi, browlo, browbg);
 
   XSetForeground(theDisp,theGC,browfg);
   XSetBackground(theDisp,theGC,browbg);
-  XCopyPlane(theDisp, trashPix, br->win, theGC, 
-	     0,0,(u_int) br_trash_width, (u_int) br_trash_height, 
+  XCopyPlane(theDisp, trashPix, br->win, theGC,
+	     0,0,(u_int) br_trash_width, (u_int) br_trash_height,
 	     x+(w-br_trash_width)/2, y+(h-br_trash_height)/2,
 	     1L);
 }
@@ -1222,7 +1222,7 @@
   y = br->high - (BUTTH+10) - (CHIGH + 6);
 
   XSetForeground(theDisp, theGC, browbg);
-  XFillRectangle(theDisp, br->win, theGC, 0, y+3, 
+  XFillRectangle(theDisp, br->win, theGC, 0, y+3,
 		 (u_int) br->wide, (u_int) CHIGH+1);
 
   XSetForeground(theDisp, theGC, browfg);
@@ -1277,7 +1277,7 @@
 {
   /* sets the '# files selected' string in the brow window appropriately */
 
-  /* criteria:  
+  /* criteria:
    *    if no files are lit, display ''
    *    if 1 file is lit, pretend it was selected, fall through...
    *    if 1 or more files are lit
@@ -1316,7 +1316,7 @@
 
 	else if (bf->ftype != BF_DIR) {     /* no info.  display file size */
 	  struct stat st;
-	      
+
 	  sprintf(buf, "%s%s", br->path, bf->name);  /* build filename */
 	  if (stat(buf, &st) == 0) {
 	    sprintf(buf, "%s:  %ld bytes", bf->name, st.st_size);
@@ -1360,8 +1360,8 @@
       if (j>=0 && j < br->bfLen) drawIcon(br,j);
     }
   }
-      
-  Draw3dRect(br->iconW, 0, 0, (u_int) br->iwWide-1, (u_int) br->iwHigh-1, 
+
+  Draw3dRect(br->iconW, 0, 0, (u_int) br->iwWide-1, (u_int) br->iwHigh-1,
 	     R3D_IN, 2, browhi, browlo, browbg);
 }
 
@@ -1371,10 +1371,8 @@
      int delta;
      SCRL *sptr;
 {
-  int   i,indx, x,y, ix,iy, num;
-  BFIL     *bf;
+  int   i,indx, num;
   BROWINFO *br;
-  char  tmpstr[64], *nstr;
 
   /* figure out BROWINFO pointer from SCRL pointer */
   for (i=0; i<MAXBRWIN; i++) {
@@ -1385,7 +1383,7 @@
   br = &binfo[i];
 
   /* make sure we've been sized.  Necessary, as creating/modifying the
-     scrollbar calls this routine directly, rather than through 
+     scrollbar calls this routine directly, rather than through
      BrowseCheckEvent() */
 
   if (!hasBeenSized) return;
@@ -1413,12 +1411,12 @@
 	if (y+h > br->iwHigh-4) h = (br->iwHigh-4)-y + 2;
       }
       XFillRectangle(theDisp, br->iconW, theGC, x, y, ISPACE_WIDE, (u_int) h);
-	
+
       if (indx>=0 && indx < br->bfLen) drawIcon(br, indx);
     }
   }
 
-  Draw3dRect(br->iconW, 0, 0, (u_int) br->iwWide-1, (u_int) br->iwHigh-1, 
+  Draw3dRect(br->iconW, 0, 0, (u_int) br->iwWide-1, (u_int) br->iwHigh-1,
 	     R3D_IN, 2, browhi, browlo, browbg);
 }
 
@@ -1431,7 +1429,10 @@
 {
   int i,x,y,ix,iy,sw,sh,sx,sy;
   BFIL *bf;
-  char  tmpstr[64], fixedname[64], *nstr, *str;
+  char  tmpstr[64], *nstr, *str;
+#ifdef VMS
+  char  fixedname[64];
+#endif
 
 
   if (num<0 || num >= br->bfLen) return;
@@ -1463,12 +1464,12 @@
   }
 
   else if (bf->ftype == BF_HAVEIMG && bf->ximage) {
-    XPutImage(theDisp, br->iconW, theGC, bf->ximage, 0,0, ix,iy, 
+    XPutImage(theDisp, br->iconW, theGC, bf->ximage, 0,0, ix,iy,
 	      (u_int) bf->w, (u_int) bf->h);
   }
 
   else {  /* shouldn't happen */
-    XDrawRectangle(theDisp, br->iconW, theGC, ix, iy, 
+    XDrawRectangle(theDisp, br->iconW, theGC, ix, iy,
 		   (u_int) bf->w, (u_int) bf->h);
   }
 
@@ -1488,24 +1489,25 @@
 
   /* decide if the title is too big, and shorten if neccesary */
   if (StringWidth(str) > ISPACE_WIDE-6) {
-    int dotpos; 
+    int dotpos;
     strncpy(tmpstr, str, (size_t) 56);
+    tmpstr[56] = '\0'; /* MR: otherwise it dies on long file names */
     dotpos = strlen(tmpstr);
     strcat(tmpstr,"...");
 
     while(StringWidth(tmpstr) > ISPACE_WIDE-6 && dotpos>0) {
       /* change last non-dot char in tmpstr to a dot, and lop off
 	 last dot */
-	    
+
       dotpos--;
       tmpstr[dotpos] = '.';
       tmpstr[dotpos+3] = '\0';
     }
-    
+
     nstr = tmpstr;
   }
   else nstr = str;
-  
+
 
   /* draw the title */
   sw = StringWidth(nstr);
@@ -1516,12 +1518,12 @@
 
   XSetForeground(theDisp, theGC,
 		 (bf->lit && bf->lit!=ICON_ONLY) ? browfg : browbg);
-  XFillRectangle(theDisp, br->iconW, theGC, sx, sy, 
+  XFillRectangle(theDisp, br->iconW, theGC, sx, sy,
 		 (u_int) sw + 4, (u_int) sh + 2);
 
   XSetForeground(theDisp, theGC,
 		 (bf->lit && bf->lit!=ICON_ONLY) ? browbg : browfg);
-  CenterString(br->iconW, x + ISPACE_WIDE/2, 
+  CenterString(br->iconW, x + ISPACE_WIDE/2,
 	       y + ISPACE_TOP + ISIZE_HIGH + ISPACE_TTOP + CHIGH/2, nstr);
 }
 
@@ -1535,7 +1537,6 @@
 
   int i,x,y,ix,iy,w,h;
   BFIL *bf;
-  char  tmpstr[64], *nstr;
 
   if (num<0 || num >= br->bfLen) return;
   bf = &(br->bfList[num]);
@@ -1579,12 +1580,12 @@
   y = (i / br->numWide) * ISPACE_HIGH;
 
   XSetForeground(theDisp, theGC, browbg);
-  XFillRectangle(theDisp, br->iconW, theGC, 
+  XFillRectangle(theDisp, br->iconW, theGC,
 		 x, y + ISPACE_TOP + ISIZE_HIGH + ISPACE_TTOP - 1,
 		 (u_int) ISPACE_WIDE, (u_int) LINEHIGH);
 
-  if (ctrlColor) 
-    Draw3dRect(br->iconW, 0, 0, (u_int) br->iwWide-1, (u_int) br->iwHigh-1, 
+  if (ctrlColor)
+    Draw3dRect(br->iconW, 0, 0, (u_int) br->iwWide-1, (u_int) br->iwHigh-1,
 	       R3D_IN, 2, browhi, browlo, browbg);
 }
 
@@ -1658,7 +1659,7 @@
   /* returns '-1' normally, returns an index into bfList[] if the user
      double-clicks an icon */
 
-  int       i,j, base, num, x,y,ix,iy, rv, sel, cpymode, dodel;
+  int       i,j, rv, sel, cpymode, dodel;
   BROWINFO *destBr;
   BFIL     *bf;
   char      buf[256], *destFolderName;
@@ -1681,7 +1682,7 @@
     }
 
     changedNumLit(br, sel, 0);
-    br->lastIconClicked = -1;  
+    br->lastIconClicked = -1;
   }
 
 
@@ -1725,10 +1726,9 @@
 
     changedNumLit(br, sel, 0);
 
-    
+
     /* see if we've double-clicked something */
     if (sel==br->lastIconClicked && mtime-br->lastClickTime < DBLCLICKTIME) {
-      int k;
       br->lastIconClicked = -1;    /* YES */
 
       doubleClick(br, sel);
@@ -1759,10 +1759,10 @@
     first = 1;  hasrect = 0;  cpymode = 0;
     origsval = br->scrl.val;
 
-    if ( (sel>=0 && !multi) || sel==-1) {  
+    if ( (sel>=0 && !multi) || sel==-1) {
       /* clicked on an icon, or clicked on nothing... */
 
-      while (!XQueryPointer(theDisp, rootW, &rW, &cW, &rootx, &rooty, 
+      while (!XQueryPointer(theDisp, rootW, &rW, &cW, &rootx, &rooty,
 			    &x,&y,&mask));
       if (mask & Button1Mask) {  /* still held down */
 
@@ -1773,7 +1773,7 @@
 	else curs = movecurs;
 
 	/* change cursors */
-	for (i=0; i<MAXBRWIN; i++) 
+	for (i=0; i<MAXBRWIN; i++)
 	  XDefineCursor(theDisp,binfo[i].iconW, curs);
 
 	samepos = oldx = oldy = oldbrnum = 0;
@@ -1785,43 +1785,43 @@
 
 	  if (sel>=0) {  /* see if changed copy/move status (and cursor) */
 	    int cmod;
-	    
+
 	    cmod = (mask&ControlMask || mask&ShiftMask) ? 1 : 0;
 
 	    if (cmod != cpymode && !dodel) {
 	      curs = (cmod) ? copycurs : movecurs;
-	      	for (i=0; i<MAXBRWIN; i++) 
+	      	for (i=0; i<MAXBRWIN; i++)
 		  XDefineCursor(theDisp,binfo[i].iconW, curs);
 	    }
 	    cpymode = cmod;
-	    
-	    
+
+
 	    /* see if cursor is in any of the trash can areas */
 	    for (i=0; i<MAXBRWIN; i++) {
 	      if (binfo[i].vis) {
-		XTranslateCoordinates(theDisp, rW, binfo[i].win, rootx,rooty, 
+		XTranslateCoordinates(theDisp, rW, binfo[i].win, rootx,rooty,
 				      &bwx,&bwy, &cW);
 		if (inTrash(&binfo[i], bwx, bwy)) break;
 	      }
 	    }
-	    
+
 	    if (dodel && i==MAXBRWIN) {        /* moved out */
 	      dodel = 0;
 	      curs = (cpymode) ? copycurs : movecurs;
-	      for (i=0; i<MAXBRWIN; i++) 
+	      for (i=0; i<MAXBRWIN; i++)
 		XDefineCursor(theDisp,binfo[i].iconW, curs);
 	    }
-	    
+
 	    else if (!dodel && i<MAXBRWIN) {   /* moved in */
 	      dodel = 1;
-	      for (i=0; i<MAXBRWIN; i++) 
+	      for (i=0; i<MAXBRWIN; i++)
 		XDefineCursor(theDisp,binfo[i].iconW, delcurs);
 	    }
 	  }
 
 
 
-	  XTranslateCoordinates(theDisp, rW, br->iconW, rootx,rooty, 
+	  XTranslateCoordinates(theDisp, rW, br->iconW, rootx,rooty,
 				&iwx,&iwy, &cW);
 
 	  /* find deepest child that the mouse is in */
@@ -1837,12 +1837,12 @@
 	  /* if it's in any icon window, and we're doing icon-dragging
 	     OR we're doing a rectangle-drag */
 
-	  if (i<MAXBRWIN || sel == -1) {  
+	  if (i<MAXBRWIN || sel == -1) {
 	    if (i<MAXBRWIN) destBr = &binfo[i];
 	    if (sel == -1)  destBr = br;
 
-	    /* AUTO-SCROLLING:  scroll any icon window if we're doing an 
-	       icon-drag.  Only scroll the original window if we're doing 
+	    /* AUTO-SCROLLING:  scroll any icon window if we're doing an
+	       icon-drag.  Only scroll the original window if we're doing
 	       a rect drag */
 
 	    if (sel>=0 && (oldx!=x || oldy!=y || oldbrnum!=i)) {  /* moved */
@@ -1873,7 +1873,7 @@
 	      }
 	    }
 
-	    
+
 	    /* if we clicked on an icon (originally), and therefore are
 	       showing the 'move files' cursor, see if the cursor is within
 	       the icon region of any folders.  If so, light up *the icon
@@ -1904,9 +1904,9 @@
 
 	    /* Dragging a selection rectangle. */
 
-	    else { 
+	    else {
 	      static int prevx, prevy, prevcnt;
-	      int        origy, top, left, wide, high, cnt;
+	      int        origy, cnt;
 
 	      if (first) { prevx = mx;  prevy = my;  first=0;  prevcnt = -1; }
 
@@ -1922,18 +1922,18 @@
 
 		rx  = (mx    < x) ? mx    : x;
 		ry  = (origy < y) ? origy : y;
-		rw  = abs(mx - x);  
+		rw  = abs(mx - x);
 		rh  = abs(origy - y);
 
 		/* figure out which icons need to be lit/unlit.  Only
 		   redraw those that have changed state */
-		
+
 		for (i=0,cnt=0, bf=br->bfList; i<br->bfLen; i++,bf++) {
-		  int ix, iy, isin, light;
+		  int ix, iy, isin;
 
-		  ix = ((i%br->numWide) * ISPACE_WIDE) 
+		  ix = ((i%br->numWide) * ISPACE_WIDE)
 		                  + ISPACE_WIDE/2 - bf->w/2;
-		  iy = ((i/br->numWide) * ISPACE_HIGH) 
+		  iy = ((i/br->numWide) * ISPACE_HIGH)
 		                  + ISPACE_TOP + ISIZE_HIGH - bf->h;
 
 		  iy = iy - br->scrl.val * ISPACE_HIGH;
@@ -1994,7 +1994,7 @@
 	}
 
 	/* RELEASED BUTTON:  back to normal arrow cursor */
-	for (i=0; i<MAXBRWIN; i++) 
+	for (i=0; i<MAXBRWIN; i++)
 	  XDefineCursor(theDisp, binfo[i].iconW, None);
 
 	if (sel == -1) {  /* was dragging rectangle */
@@ -2007,7 +2007,7 @@
 	    if (bf->lit == TEMP_LIT || bf->lit == TEMP_LIT1) {
 	      bf->lit = 1;  drawIcon(br, i);
 	    }
-	    
+
 	    if (bf->lit) br->numlit++;
 	  }
 
@@ -2020,7 +2020,6 @@
 
   /* if doing a copy or a move, do the thing to the files */
   if (sel >= 0) {
-    char *destFolder;
 
     if (DEBUG) {
       fprintf(stderr,"---------------\n");
@@ -2029,7 +2028,7 @@
       fprintf(stderr,"Dest Folder: '%s'\n", destFolderName);
     }
 
-    
+
     if (!br->numlit) {
       if (DEBUG) fprintf(stderr, "no selected files.  Nothing to do!\n");
     }
@@ -2042,7 +2041,7 @@
       if (DEBUG) fprintf(stderr, "no destination.  Nothing to do!\n");
     }
 
-    else if (strcmp(destFolderName,".")     == 0 && 
+    else if (strcmp(destFolderName,".")     == 0 &&
 	     strcmp(br->path, destBr->path) == 0) {
       if (DEBUG) fprintf(stderr,"source == destination.  Nothing to do!\n");
     }
@@ -2067,12 +2066,12 @@
 	}
       }
       if (DEBUG) fprintf(stderr,"\n\n");
- 
+
 #ifdef VMS
       /*
-       * For VMS, our directory file names are identifed by the 
-       * special filename extension, ".DIR".  Unfortunately, this 
-       * needs to be stripped before we ever actually use the name 
+       * For VMS, our directory file names are identifed by the
+       * special filename extension, ".DIR".  Unfortunately, this
+       * needs to be stripped before we ever actually use the name
        * in a copy command... :(     RLD 26-FEB-1993
        */
 
@@ -2080,7 +2079,7 @@
 #endif
 
 
-      dragFiles(br, destBr, br->path, destBr->path, destFolderName, nlist, 
+      dragFiles(br, destBr, br->path, destBr->path, destFolderName, nlist,
 		ncnt, cpymode);
 
       /* free namelist */
@@ -2155,7 +2154,7 @@
   }
 
 
-  
+
   /* double-clicked something.  We should do something about it */
   if (br->bfList[sel].ftype == BF_DIR) {  /* try to cd */
 #ifndef VMS
@@ -2193,7 +2192,7 @@
       *event_retP = THISNEXT;
     }
     else { *event_retP = LOADPIC;  SetDirFName(buf);  }
-    
+
     *event_doneP = 1;     /* make MainLoop load image */
   }
 }
@@ -2259,7 +2258,7 @@
   stlen = XLookupString(kevt, buf, 128, &ks, (XComposeStatus *) NULL);
   shift = kevt->state & ShiftMask;
   ck    = CursorKey(ks, shift, 1);
-  dealt = 1;  
+  dealt = 1;
 
   RemapKeyCheck(ks, buf, &stlen);
 
@@ -2306,7 +2305,7 @@
       char fname[MAXPATHLEN];
 
       /* if 'shift-space' find last lit icon, select the next one after it,
-	 and load it.  If 'space' do the same, but lose prior lit.  These 
+	 and load it.  If 'space' do the same, but lose prior lit.  These
 	 are the only cases where br->numlit >1 allowed */
 
       if (br->numlit>1  && buf[0] != ' ') return;
@@ -2314,7 +2313,7 @@
       if (buf[0]==' ' && (br->numlit>1 || (br->numlit==1 && shift))) {
 	for (i=br->bfLen-1; i>=0 && !br->bfList[i].lit; i--);  /* i=last lit */
 	if (i==br->bfLen-1) return;
-	
+
 	i++;
 	if (!shift) {
 	  for (j=0; j<br->bfLen; j++) {
@@ -2364,7 +2363,7 @@
 	for (i=0; i<br->bfLen && !br->bfList[i].lit; i++);  /* find lit one */
 	sprintf(fname, "%s%s", br->path, br->bfList[i].name);
 	viewsel = !(strcmp(fname, fullfname));
-	
+
 	if (viewsel) {
 	  if (buf[0]==' ') browKey(br, CK_RIGHT);
 	              else browKey(br, CK_LEFT);
@@ -2372,7 +2371,7 @@
 
 	if (!br->bfList[i].lit || !viewsel) {   /* changed selection */
 	  for (i=0; i<br->bfLen && !br->bfList[i].lit; i++);  /* find it */
-	  if (br->bfList[i].ftype != BF_DIR) 
+	  if (br->bfList[i].ftype != BF_DIR)
 	    doubleClick(br, -1);
 	}
       }
@@ -2410,10 +2409,10 @@
   /* handle up/down/left/right keys
    *
    * if precisely *one* item is lit, than the up/down/left/right keys move
-   * the selection.  
+   * the selection.
    *
    * if NO items are lit, then left/right select the first/last fully-displayed
-   * icon, and up/down simply scroll window up or down, without selecting 
+   * icon, and up/down simply scroll window up or down, without selecting
    * anything
    *
    * if more than one item is lit, up/down/left/right keys BEEP
@@ -2443,8 +2442,8 @@
 	if (key == CK_DOWN)  j = i + br->numWide;
 	if (key == CK_LEFT)  j = i - 1;
 	if (key == CK_RIGHT) j = i + 1;
-	
-	if (j >= 0 && j < br->bfLen) {  
+
+	if (j >= 0 && j < br->bfLen) {
 	  br->bfList[i].lit = 0;
 	  br->bfList[j].lit = 1;
 	  makeIconVisible(br,j);
@@ -2455,7 +2454,7 @@
       }
     }
 
-  
+
     if (br->numlit == 0) {   /* no current selection */
       if (key == CK_UP)   SCSetVal(&br->scrl, br->scrl.val - 1);
       if (key == CK_DOWN) SCSetVal(&br->scrl, br->scrl.val + 1);
@@ -2541,13 +2540,13 @@
        *  The VMS chdir always needs 2 components (device and directory),
        *  so convert "/device" to "/device/000000" and convert
        *  "/" to "/XV_Root_Device/000000" (XV_RootDevice will need to be
-       *  a special concealed device setup to provide list of available 
+       *  a special concealed device setup to provide list of available
        *  disks).
        *
        *  End 'tmppath' by changing trailing '/' (of dir name) to a '\0'
        */
       *rindex ( tmppath, '/') = '\0';
-      if ( ((br->ndirs-sel) == 2) && (strlen(tmppath) > 1) ) 
+      if ( ((br->ndirs-sel) == 2) && (strlen(tmppath) > 1) )
 	strcat ( tmppath, "/000000" ); /* add root dir for device */
       else if  ((br->ndirs-sel) == 1 )
 	strcpy ( tmppath, "/XV_Root_Device/000000" );  /* fake top level */
@@ -2599,7 +2598,7 @@
 static void copyDirInfo(srcbr, dstbr)
      BROWINFO *srcbr, *dstbr;
 {
-  /* copies br info from an already existing browser window 
+  /* copies br info from an already existing browser window
      (ie, one that is already showing the same directory) */
 
   int i, oldnum, maxv, page;
@@ -2619,7 +2618,7 @@
   dstbr->dirMB.list  = srcbr->mblist;
   dstbr->dirMB.nlist = srcbr->ndirs;
 
-  XClearArea(theDisp, dstbr->dirMB.win, dstbr->dirMB.x, dstbr->dirMB.y, 
+  XClearArea(theDisp, dstbr->dirMB.win, dstbr->dirMB.x, dstbr->dirMB.y,
 	     dstbr->dirMB.w+3, dstbr->dirMB.h+3, False);
 
   i = StringWidth(dstbr->mblist[0]) + 10;
@@ -2644,7 +2643,7 @@
 
     if ((i&0x03) == 0) drawTemp(dstbr, i, dstbr->bfLen);
     if ((i & 0x3f) == 0) WaitCursor();
-    
+
     sbf = &(srcbr->bfList[i]);
     dbf = &(dstbr->bfList[i]);
 
@@ -2670,7 +2669,7 @@
     if (sbf->pimage) {
       dbf->pimage = (byte *) malloc((size_t) dbf->w * dbf->h);
       if (!dbf->pimage) FatalError("ran out of memory for dbf->pimage");
-      xvbcopy((char *) sbf->pimage, (char *) dbf->pimage, 
+      xvbcopy((char *) sbf->pimage, (char *) dbf->pimage,
 	      (size_t) (dbf->w * dbf->h));
     }
     else dbf->pimage = (byte *) NULL;
@@ -2681,10 +2680,10 @@
       xvbcopy((char *) sbf->ximage, (char *) dbf->ximage, sizeof(XImage));
 
       if (sbf->ximage->data) {
-	dbf->ximage->data = (char *) malloc((size_t) dbf->ximage->height * 
+	dbf->ximage->data = (char *) malloc((size_t) dbf->ximage->height *
 					    dbf->ximage->bytes_per_line);
 	if (!dbf->ximage->data) FatalError("ran out of memory for ximg data");
-	xvbcopy((char *) sbf->ximage->data, (char *) dbf->ximage->data, 
+	xvbcopy((char *) sbf->ximage->data, (char *) dbf->ximage->data,
 		(size_t) dbf->ximage->height * dbf->ximage->bytes_per_line);
       }
     }
@@ -2701,15 +2700,15 @@
   computeScrlVals(dstbr, &maxv, &page);
   if (dstbr->scrl.val > maxv) dstbr->scrl.val = maxv;
 
-  XClearArea(theDisp, dstbr->iconW, 0, 0, (u_int) dstbr->iwWide, 
+  XClearArea(theDisp, dstbr->iconW, 0, 0, (u_int) dstbr->iwWide,
 	     (u_int) dstbr->iwHigh, True);
   SCSetRange(&dstbr->scrl, 0, maxv, dstbr->scrl.val, page);
 
   SetCursors(-1);
 }
 
-    
-  
+
+
 
 /***************************************************************/
 static void scanDir(br)
@@ -2726,7 +2725,7 @@
    * and it's reasonable to expect folks to want to add their own bitmaps
    */
 
-  int   i,j,k,oldbflen,vmsparent;
+  int   i,j,oldbflen,vmsparent;
   BFIL *bf;
 
   DIR           *dirp;
@@ -2775,7 +2774,7 @@
 
   /* build brMBlist */
   for (i = br->ndirs-1,j=0; i>=0; i--,j++) {
-    size_t stlen = (i<(br->ndirs-1)) ? dirnames[i+1] - dirnames[i] 
+    size_t stlen = (i<(br->ndirs-1)) ? dirnames[i+1] - dirnames[i]
                                   : strlen(dirnames[i]);
 
     br->mblist[j] = (char *) malloc(stlen+1);
@@ -2784,13 +2783,13 @@
     strncpy(br->mblist[j], dirnames[i], stlen);
     br->mblist[j][stlen] = '\0';
   }
-    
+
 
   /* refresh the brdirMB button */
   br->dirMB.list  = br->mblist;
   br->dirMB.nlist = br->ndirs;
 
-  XClearArea(theDisp, br->dirMB.win, br->dirMB.x, br->dirMB.y, 
+  XClearArea(theDisp, br->dirMB.win, br->dirMB.x, br->dirMB.y,
 	     br->dirMB.w+3, br->dirMB.h+3, False);
 
   i = StringWidth(br->mblist[0]) + 10;
@@ -2815,7 +2814,7 @@
   /* count how many files are in the list */
 
   dirp = opendir(".");
-  if (!dirp) {  
+  if (!dirp) {
     endScan(br, oldbflen);
     setBrowStr(br, "Couldn't read current directory.");
     SetCursors(-1);
@@ -2827,11 +2826,11 @@
 #endif
 
   while ( (dp = readdir(dirp)) != NULL) {
-    if (strcmp(dp->d_name, ".") && 
+    if (strcmp(dp->d_name, ".") &&
 	strcmp(dp->d_name, THUMBDIR)) {
-      if (!br->showhidden && dp->d_name[0] == '.' && 
+      if (!br->showhidden && dp->d_name[0] == '.' &&
 	  strcmp(dp->d_name,"..")!=0) continue;
-      else 
+      else
 	br->bfLen++;
     }
     if ((br->bfLen & 0x3f) == 0) WaitCursor();
@@ -2877,13 +2876,13 @@
       }
       else {
 	do { dp = readdir(dirp); }
-	while (dp && (strcmp(dp->d_name, ".")==0                    || 
+	while (dp && (strcmp(dp->d_name, ".")==0                    ||
 		      strcmp(dp->d_name, THUMBDIR)==0               ||
 		      strcmp(dp->d_name, THUMBDIRNAME)==0           ||
 		      (br->ndirs==1 && strcmp(dp->d_name,"..")==0)  ||
-		      (!br->showhidden && dp->d_name[0] == '.' && 
+		      (!br->showhidden && dp->d_name[0] == '.' &&
 		       strcmp(dp->d_name,"..")!=0)));
-      
+
 	if (!dp) { br->bfLen = i;  break; }   /* dir got shorter... */
       }
 
@@ -2940,11 +2939,11 @@
   if (w<1) w = 1;
   if (h<1) h = 1;
 
-  XClearArea(theDisp, br->iconW, (ctrlColor) ? 2 : 0, (ctrlColor) ? 2 : 0, 
+  XClearArea(theDisp, br->iconW, (ctrlColor) ? 2 : 0, (ctrlColor) ? 2 : 0,
 	     (u_int) w, (u_int) h, False);
 
   SCSetRange(&br->scrl, 0, maxv, br->scrl.val, page);
-  
+
   SetCursors(-1);
 }
 
@@ -2972,7 +2971,7 @@
   bf->pimage = (byte *) NULL;
   bf->ximage = (XImage *) NULL;
   bf->lit    = 0;
-	
+
 
   if (stat(bf->name, &st)==0) {
     bf->ftype = stat2bf((u_int) st.st_mode);
@@ -3048,11 +3047,11 @@
   bfcompares++;
   if ((bfcompares & 0x7f)==0) WaitCursor();
 
-  /* sort critera:  directories first, in alphabetical order, 
+  /* sort critera:  directories first, in alphabetical order,
      followed by everything else, in alphabetical order */
-  
+
   if ((b1->ftype == BF_DIR && b2->ftype == BF_DIR) ||
-      (b1->ftype != BF_DIR && b2->ftype != BF_DIR)) 
+      (b1->ftype != BF_DIR && b2->ftype != BF_DIR))
     return strcmp(b1->name, b2->name);
 
   else if (b1->ftype == BF_DIR && b2->ftype != BF_DIR) return -1;
@@ -3108,7 +3107,7 @@
     for (i=0; i<bflen; i++) {
       bfnames[i] = (char *) malloc(strlen(br->bfList[i].name) + 1);
       if (!bfnames[i]) FatalError("couldn't alloc bfnames in rescanDir()");
-      
+
       strcpy(bfnames[i], br->bfList[i].name);
     }
   }
@@ -3121,7 +3120,7 @@
 
   /* note, either (or both) dirnames/bfnames can be NULL, in which case
      their respective 'len's will be zero */
-  
+
   /* sort the two name lists */
   if (bflen)  qsort((char *) bfnames,  (size_t) bflen, sizeof(char *),namcmp);
   if (dirlen) qsort((char *) dirnames, (size_t) dirlen,sizeof(char *),namcmp);
@@ -3153,7 +3152,7 @@
     }
   }
   bflen = j;
-  
+
 
   for (i=j=0; i<dirlen; i++) {
     if (dirnames[i] && strcmp(dirnames[i],".") && strcmp(dirnames[i],"..") &&
@@ -3162,21 +3161,21 @@
     }
   }
   dirlen = j;
-  
+
 
   if (DEBUG) {
     fprintf(stderr,"%d files seem to have gone away:  ", bflen);
-    for (i=0; i<bflen; i++) 
+    for (i=0; i<bflen; i++)
       fprintf(stderr,"%s ", bfnames[i]);
     fprintf(stderr,"\n\n");
 
     fprintf(stderr,"%d files seem to have appeared:  ", dirlen);
-    for (i=0; i<dirlen; i++) 
+    for (i=0; i<dirlen; i++)
       fprintf(stderr,"%s ", dirnames[i]);
     fprintf(stderr,"\n\n");
   }
-   
-  
+
+
   /* create a new bfList */
   newlen = br->bfLen - bflen + dirlen;  /* oldlen - #del'd + #created */
   if (newlen>0) {
@@ -3241,7 +3240,7 @@
       if (bf->pimage)  free(bf->pimage);
       if (bf->ximage)  xvDestroyImage(bf->ximage);
     }
-    
+
     free(br->bfList);
   }
 
@@ -3267,13 +3266,13 @@
      int  *lenP;
      int   dohidden;
 {
-  /* loads up all directory entries into an array.  This *isn't* a great 
-     way to do it, but I can't count on 'scandir()' existing on 
+  /* loads up all directory entries into an array.  This *isn't* a great
+     way to do it, but I can't count on 'scandir()' existing on
      every system.  Returns 'NULL' on failure, or pointer to array of
      'lenP' strings on success.  '.' and '..' ARE included in list
      if !dohidden, all '.*' files are skipped (except . and ..) */
 
-  int    i, j, dirlen;
+  int    i, dirlen;
   DIR   *dirp;
   char **names;
 #ifdef NODIRENT
@@ -3294,9 +3293,9 @@
   /* count # of entries in dir (worst case) */
   for (dirlen=0;  (dp = readdir(dirp)) != NULL;  dirlen++);
   if (!dirlen) {
-    closedir(dirp);  
+    closedir(dirp);
     *lenP = dirlen;
-    return (char **) NULL; 
+    return (char **) NULL;
   }
 
 
@@ -3312,7 +3311,7 @@
 
     if (!dohidden) {
 #ifndef VMS
-      if (dp->d_name[0] == '.' && 
+      if (dp->d_name[0] == '.' &&
 	  strcmp(dp->d_name,"." )!=0 &&
 	  strcmp(dp->d_name,"..")!=0) continue;
 #endif
@@ -3324,7 +3323,7 @@
     strcpy(names[i], dp->d_name);
     i++;
   }
-  
+
   if (i<dirlen) dirlen = i;     /* dir got shorter... */
 
   closedir(dirp);
@@ -3359,7 +3358,7 @@
 static void genSelectedIcons(br)
      BROWINFO *br;
 {
-  int i, sval, first, numvis, cnt;
+  int i, cnt;
 
   setBrowStr(br, "");
 
@@ -3395,7 +3394,7 @@
      BFIL *bf;
 {
   /* given a BFIL entry, load up the file.
-   * if we succeeded in loading up the file, 
+   * if we succeeded in loading up the file,
    *      generate an aspect-correct 8-bit image using brow Cmap
    * otherwise
    *      replace this icon with the BF_UNKNOWN, or BF_ERR icons
@@ -3408,20 +3407,20 @@
   byte   *icon24, *icon8;
   char    str[256], str1[256], *readname, uncompname[128];
   char    basefname[128], *uncName;
-  
-  
+
+
   if (!bf || !bf->name || bf->name[0] == '\0') return;   /* shouldn't happen */
   str[0] = '\0';
   basefname[0] = '\0';
   pinfo.pic = (byte *) NULL;
   pinfo.comment = (char *) NULL;
   readname = bf->name;
-  
+
   /* free any old info in 'bf' */
   if (bf->imginfo) free          (bf->imginfo);
   if (bf->pimage)  free          (bf->pimage);
   if (bf->ximage)  xvDestroyImage(bf->ximage);
-  
+
   bf->imginfo = (char *)   NULL;
   bf->pimage  = (byte *)   NULL;
   bf->ximage  = (XImage *) NULL;
@@ -3429,9 +3428,9 @@
 
   /* skip all 'special' files */
   if (!ISLOADABLE(bf->ftype)) return;
-  
+
   filetype = ReadFileType(bf->name);
-  
+
   if (filetype == RFT_COMPRESS) {
 #if (defined(VMS) && !defined(GUNZIP))
     /* VMS decompress doesn't like the file to have a trailing .Z in fname
@@ -3442,7 +3441,7 @@
 #else
     uncName = bf->name;
 #endif
-    
+
     if (UncompressFile(uncName, uncompname)) {
       filetype = ReadFileType(uncompname);
       readname = uncompname;
@@ -3453,61 +3452,61 @@
       bf->ftype = BF_ERROR;
     }
   }
-  
+
   /* get rid of comments.  don't need 'em */
   if (pinfo.comment) free(pinfo.comment);  pinfo.comment = (char *) NULL;
-  
-  if (filetype == RFT_ERROR) { 
+
+  if (filetype == RFT_ERROR) {
     sprintf(str,"Couldn't open file '%s'", bf->name);
     setBrowStr(br, str);
     bf->ftype = BF_ERROR;
   }
-  
+
   else if (filetype == RFT_UNKNOWN) {
     /* if it *was* an 'exe', leave it that way */
     if (bf->ftype != BF_EXE) bf->ftype = BF_UNKNOWN;
   }
-  
+
   else {
     /* otherwise it's a known filetype... do the *hard* part now... */
-    
+
     i = ReadPicFile(readname, filetype, &pinfo, 1);
     KillPageFiles(pinfo.pagebname, pinfo.numpages);
-    
+
     if (!i) bf->ftype = BF_ERROR;
-    
+
     if (i && (pinfo.w<=0 || pinfo.h<=0)) {        /* bogus size */
       bf->ftype = BF_ERROR;
       free(pinfo.pic);  pinfo.pic = (byte *) NULL;
     }
-    
+
     if (bf->ftype==BF_ERROR && filetype==RFT_XBM) bf->ftype = BF_UNKNOWN;
   }
-  
+
   /* get rid of comment, as we don't need it */
-  if (pinfo.comment) { 
+  if (pinfo.comment) {
     free(pinfo.comment);  pinfo.comment = (char *) NULL;
   }
-  
+
   /* if we made an uncompressed file, we can rm it now */
   if (readname != bf->name) unlink(readname);
-  
-  
+
+
   /* at this point either BF_ERROR, BF_UNKNOWN, BF_EXE or pic */
-  
+
   if (!pinfo.pic) {
     if (bf->ftype == BF_EXE) return;  /* don't write thumbfiles for exe's */
-    
+
     bf->w = br_file_width;  bf->h = br_file_height;
     writeThumbFile(br, bf, NULL, 0, 0, NULL);   /* BF_ERROR, BF_UNKNOWN */
     return;
   }
-  
+
   /* at this point, we have a pic, so it must be an image file */
-  
-  
+
+
   /* compute size of icon  (iwide,ihigh) */
-  
+
   wexpand = (double) pinfo.w / (double) ISIZE_WIDE;
   hexpand = (double) pinfo.h / (double) ISIZE_HIGH;
 
@@ -3527,13 +3526,13 @@
 
 
   /* generate icon */
-  icon24 = Smooth24(pinfo.pic, pinfo.type==PIC24, pinfo.w, pinfo.h, 
+  icon24 = Smooth24(pinfo.pic, pinfo.type==PIC24, pinfo.w, pinfo.h,
 		    iwide, ihigh, pinfo.r,pinfo.g,pinfo.b);
   if (!icon24) { bf->ftype = BF_FILE;  free(pinfo.pic); return; }
 
   sprintf(str, "%dx%d ", pinfo.normw, pinfo.normh);
   switch (filetype) {
-  case RFT_GIF:      if (xv_strstr(pinfo.shrtInfo, "GIF89")) 
+  case RFT_GIF:      if (xv_strstr(pinfo.shrtInfo, "GIF89"))
                        strcat(str,"GIF89 file");
                      else
 		       strcat(str,"GIF87 file");
@@ -3543,12 +3542,12 @@
 
   case RFT_PBM:      if (xv_strstr(pinfo.fullInfo, "raw")) strcat(str,"Raw ");
                      else strcat(str,"Ascii ");
-    
+
                      for (i=0; i<3 && (strlen(pinfo.fullInfo)>(size_t)3); i++){
 		       str1[0] = pinfo.fullInfo[i];  str1[1] = '\0';
 		       strcat(str, str1);
 		     }
-         
+
                      strcat(str," file");
                      break;
 
@@ -3569,19 +3568,19 @@
   case RFT_FITS:     strcat(str,"FITS file");             break;
   default:           strcat(str,"file of unknown type");  break;
   }
-  
-  
+
+
   /* find out length of original file */
   {  FILE *fp;
      long  filesize;
      char  buf[64];
-     
+
      fp = fopen(bf->name, "r");
      if (fp) {
        fseek(fp, 0L, 2);
        filesize = ftell(fp);
        fclose(fp);
-       
+
        sprintf(buf,"  (%ld bytes)", filesize);
        strcat(str, buf);
      }
@@ -3609,17 +3608,17 @@
   bf->w       = iwide;
   bf->h       = ihigh;
   bf->ftype   = BF_HAVEIMG;
-  
+
   bf->ximage = Pic8ToXImage(icon8, (u_int) iwide, (u_int) ihigh, browcols,
 			    browR, browG, browB);
-  
+
   free(icon24);
   free(pinfo.pic);
 }
 
 
 
-    
+
 
 
 /*
@@ -3682,7 +3681,7 @@
   /* read comments until we see '#END_OF_COMMENTS', or hit EOF */
   while (1) {
     if (!fgets(buf, 256, fp)) goto errexit;
-    
+
     if      (!strncmp(buf, "#END_OF_COMMENTS", strlen("#END_OF_COMMENTS")))
       break;
 
@@ -3714,7 +3713,7 @@
 
 
   /* read width, height, maxval */
-  if (!fgets(buf, 256, fp) || sscanf(buf, "%d %d %d", &w, &h, &mv) != 3) 
+  if (!fgets(buf, 256, fp) || sscanf(buf, "%d %d %d", &w, &h, &mv) != 3)
     goto errexit;
 
 
@@ -3738,14 +3737,14 @@
     bf->h       = h;
     bf->ftype   = BF_HAVEIMG;
     bf->imginfo = info;
-    
-    bf->ximage = Pic8ToXImage(icon8, (u_int) w, (u_int) h, browcols, 
+
+    bf->ximage = Pic8ToXImage(icon8, (u_int) w, (u_int) h, browcols,
 			      browR, browG, browB);
   }
   else {
     if (info) free(info);
   }
-  
+
   fclose(fp);
   return;
 
@@ -3757,7 +3756,7 @@
 }
 
 
-  
+
 /***************************************************************/
 static void writeThumbFile(br, bf, icon8, w, h, info)
      BROWINFO *br;
@@ -3787,7 +3786,7 @@
 
   fp = fopen(thFname, "w");
   if (!fp) {
-    sprintf(buf, "Can't create thumbnail file '%s':  %s", thFname, 
+    sprintf(buf, "Can't create thumbnail file '%s':  %s", thFname,
 	    ERRSTR(errno));
     setBrowStr(br, buf);
     return;            /* can't write... */
@@ -3829,9 +3828,9 @@
     setBrowStr(br, buf);
     return;            /* can't write... */
   }
-  
+
   fclose(fp);
-  
+
   chmod(thFname, (mode_t) perm);
 }
 
@@ -3915,7 +3914,7 @@
 
       if (s1 || s2 || filest.st_mtime > thumbst.st_mtime ||
 	              filest.st_ctime > thumbst.st_ctime) {
-	/* either stat'ing the file or the thumbfile failed, or 
+	/* either stat'ing the file or the thumbfile failed, or
 	   both stat's succeeded and the file has a newer mod or creation
 	   time than the thumbnail file */
 
@@ -3926,8 +3925,8 @@
 
 	if (bf->ftype != BF_EXE) {
 	  iconsBuilt++;
-	  if (DEBUG) 
-	    fprintf(stderr,"icon made:fname='%s' thfname='%s' %d,%d,%d,%d\n",
+	  if (DEBUG)
+	    fprintf(stderr,"icon made:fname='%s' thfname='%s' %d,%d,%ld,%ld\n",
 		    bf->name, thfname, s1,s2,filest.st_mtime,thumbst.st_mtime);
 	}
       }
@@ -3974,7 +3973,7 @@
 	}
       }
       statcount++;
-      
+
       if ((statcount % 30)==0) WaitCursor();
     }
     closedir(dirp);
@@ -3998,16 +3997,16 @@
 {
   if (maxcnt<1) return;   /* none of that naughty ol' divide by zero stuff */
 
-  DrawTempGauge(br->win, 5, br->dirMB.y, 
+  DrawTempGauge(br->win, 5, br->dirMB.y,
 		(int) br->dirMB.x-10, (int) br->dirMB.h,
 		(double) cnt / (double) maxcnt,
 		browfg, browbg, browhi, browlo, "");
 }
- 
+
 static void clearTemp(br)
   BROWINFO *br;
 {
-  XClearArea(theDisp, br->win, 5, br->dirMB.y, 
+  XClearArea(theDisp, br->win, 5, br->dirMB.y,
 	     (u_int) br->dirMB.x-10+1, (u_int) br->dirMB.h + 1, True);
 }
 
@@ -4048,7 +4047,7 @@
   /* find the selected file */
   for (i=0; i<br->bfLen && !br->bfList[i].lit; i++);
   if (i==br->bfLen) return;    /* shouldn't happen */
-  
+
   origname = br->bfList[i].name;   num = i;
 
   if (strcmp(origname, "..")==0) {
@@ -4058,7 +4057,7 @@
     return;
   }
 
-  sprintf(txt, "Enter a new name for the %s '%s':", 
+  sprintf(txt, "Enter a new name for the %s '%s':",
 	  (br->bfList[i].ftype==BF_DIR) ? "directory" : "file",
 	  origname);
 
@@ -4107,7 +4106,7 @@
   drawIcon(br, num);
 
   for (i=0; i<MAXBRWIN; i++) {
-    if (&binfo[i] != br && strcmp(binfo[i].path, br->path)==0) 
+    if (&binfo[i] != br && strcmp(binfo[i].path, br->path)==0)
       rescanDir(&binfo[i]);
   }
 
@@ -4133,7 +4132,7 @@
   if (cdBrow(br)) return;
 
   buf[0] = '\0';
-  i = GetStrPopUp("Enter name for new directory:", labels, 2, 
+  i = GetStrPopUp("Enter name for new directory:", labels, 2,
 		  buf, 128, "/ |\'\"<>,", 0);
   if (i) return;     /* cancelled */
 
@@ -4161,7 +4160,7 @@
 
   /* rescan current br, and all other br's pointing to same directory */
   for (i=0; i<MAXBRWIN; i++) {
-    if (strcmp(binfo[i].path, br->path)==0) 
+    if (strcmp(binfo[i].path, br->path)==0)
       rescanDir(&binfo[i]);
   }
 
@@ -4179,7 +4178,7 @@
   int          i;
   static char  buf[MAXPATHLEN+100];
   static char *labels[] = { "\nOk", "\033Cancel" };
-  char str[512];		
+  char str[512];
 
   buf[0] = '\0';
   i = GetStrPopUp("Change to directory:", labels, 2, buf, MAXPATHLEN, " ", 0);
@@ -4226,7 +4225,7 @@
    */
 
   BFIL  *bf;
-  int    i, j, numdirs, numfiles, slen, firstdel;
+  int    i, numdirs, numfiles, slen, firstdel;
   char   buf[512];
   static char *yesno[]  = { "\004Delete", "\033Cancel" };
 
@@ -4258,7 +4257,7 @@
   }
 
 
-  /* if any plain files are being toasted, bring up the low-key 
+  /* if any plain files are being toasted, bring up the low-key
      confirmation box */
 
   if (numfiles) {
@@ -4281,7 +4280,7 @@
     i = PopUp(buf, yesno, 2);
     if (i) return;              /* cancelled */
   }
-     
+
 
   /* if any directories are being toasted, bring up the are you REALLY sure
      confirmation box */
@@ -4309,7 +4308,7 @@
 
 
   /* okay, at this point they've been warned.  do the deletion */
-  
+
   for (i=0, bf=br->bfList;  i<br->bfLen;  i++,bf++) {
     if (bf->lit) {
       if (bf->ftype == BF_DIR) rm_dir (br, bf->name);
@@ -4340,7 +4339,7 @@
 
   /* rescan other br's that are looking at this directory */
   for (i=0; i<MAXBRWIN; i++) {
-    if (&binfo[i] != br && strcmp(binfo[i].path, br->path)==0) 
+    if (&binfo[i] != br && strcmp(binfo[i].path, br->path)==0)
       rescanDir(&binfo[i]);
   }
 
@@ -4356,7 +4355,7 @@
   int          i;
   static char  buf[MAXPATHLEN+100];
   static char *labels[] = { "\nOk", "\033Cancel" };
-  char str[512];		
+  char str[512];
 
   buf[0] = '\0';
   strcpy(str,"Select file name(s).  Wildcard '*' is allowed.  ");
@@ -4396,7 +4395,7 @@
 {
   int          i;
   static char *labels[] = { "\nOk", "\033Cancel" };
-  char         str[512];		
+  char         str[512];
 
   strcpy(str,"Recursive Update:  This could take *quite* a while.\n");
   strcat(str,"Are you sure?");
@@ -4415,7 +4414,7 @@
 
 
 /*******************************************/
-static void recurseUpdate(br, subdir) 
+static void recurseUpdate(br, subdir)
      BROWINFO *br;
      char     *subdir;
 {
@@ -4430,7 +4429,7 @@
    *      and for each subdir in this dir, recurse
    *
    * if cur dir != orig dir, cd back to orig dir and reload 'br'
-   */ 
+   */
 
   int  i;
   char orgDir[MAXPATHLEN + 2];
@@ -4449,7 +4448,7 @@
   }
 
   xv_getwd(curDir, sizeof(curDir));
-  
+
   /* have we looped? */
   for (i=0; i<dirStackLen && strcmp(curDir, dirStack[i]); i++);
   if (i<dirStackLen) {   /* YES */
@@ -4481,8 +4480,8 @@
   /* do subdirectories of this directory, not counting .  .. and .xvpics */
   for (i=0; i<br->bfLen; i++) {
     bf = &(br->bfList[i]);
-    if (bf                     && 
-	bf->ftype == BF_DIR    && 
+    if (bf                     &&
+	bf->ftype == BF_DIR    &&
 	strcmp(bf->name, ".")  &&
 	strcmp(bf->name, "..") &&
         strcmp(bf->name, THUMBDIRNAME) ) {
@@ -4524,7 +4523,7 @@
   tmp = (char *) rindex(buf1, '/');
   if (!tmp) strcpy(buf1,".");
   else *tmp = '\0';
-  
+
   sprintf(buf, "%s/%s/%s", buf1, THUMBDIR, BaseName(name));
   if (DEBUG) fprintf(stderr,"   (%s)\n", buf);
 
@@ -4548,7 +4547,7 @@
      BROWINFO *br;
 {
   /* recursively delete this directory, and all things under it */
-  
+
   int    i, dirlen, longpath, oldpathlen;
   char **names, *name, buf[512];
   struct stat st;
@@ -4569,7 +4568,7 @@
       name = names[i];
 
       /* skip . and .. (not that we should ever see them... */
-      if (name[0] == '.' && (name[1]=='\0' || 
+      if (name[0] == '.' && (name[1]=='\0' ||
 			     (name[1]=='.' && name[2]=='\0'))) goto done;
 
       if (strlen(name) + oldpathlen >= (MAXPATHLEN-3)) {
@@ -4586,7 +4585,7 @@
 	rmdirPath[oldpathlen] = '\0';
 	goto done;
       }
-	
+
       if (stat2bf((u_int) st.st_mode) == BF_DIR) {  /* skip, for now */
 	rmdirPath[oldpathlen] = '\0';
 	continue;   /* don't remove from list */
@@ -4594,7 +4593,7 @@
 
       rm_file(br, rmdirPath);
       rmdirPath[oldpathlen] = '\0';
-      
+
     done:     /* remove name from list */
       free(name);
       names[i] = (char *) NULL;
@@ -4645,19 +4644,19 @@
 
 
 /*******************************************/
-static void dragFiles(srcBr, dstBr, srcpath, dstpath, dstdir, 
+static void dragFiles(srcBr, dstBr, srcpath, dstpath, dstdir,
 		      names, nlen, cpymode)
      BROWINFO *srcBr, *dstBr;
      char     *srcpath, *dstpath, *dstdir, **names;
      int       nlen, cpymode;
 {
-  /* move or copy file(s) and their associated thumbnail files.  
+  /* move or copy file(s) and their associated thumbnail files.
      srcpath and dstpath will have trailing '/'s.  dstdir is name of
      folder in dstpath (or "." or "..") to write to.  names is an nlen
      long array of strings (the simple filenames of the files to move)
      if 'cpymode' copy files, otherwise move them */
 
-  int  i, j, k, dothumbs, fail;
+  int  i, j, dothumbs, fail;
   char dstp[MAXPATHLEN + 1];
   char src[MAXPATHLEN+1], dst[MAXPATHLEN+1];
   char buf[128];
@@ -4750,7 +4749,7 @@
 
 
   /* clear all files in the destination folder */
-  for (i=0; i<dstBr->bfLen; i++) { 
+  for (i=0; i<dstBr->bfLen; i++) {
     dstBr->bfList[i].lit = 0;
   }
   dstBr->numlit = 0;
@@ -4760,10 +4759,10 @@
   for (i=0; i<nlen; i++) {
     char *name;  BFIL *bf;
     name = names[i];
-    for (j=0, bf=dstBr->bfList; 
+    for (j=0, bf=dstBr->bfList;
 	 j<dstBr->bfLen && strcmp(name, bf->name)!=0; j++, bf++);
-    if (j<dstBr->bfLen) { 
-      bf->lit = 1;  dstBr->numlit++; 
+    if (j<dstBr->bfLen) {
+      bf->lit = 1;  dstBr->numlit++;
     }
   }
 
@@ -4783,10 +4782,10 @@
   changedNumLit(srcBr, -1, 0);
 
 
-  if (fail) sprintf(buf, "Some files were not %s because of errors.", 
+  if (fail) sprintf(buf, "Some files were not %s because of errors.",
 		    cpymode ? "copied" : "moved");
 
-  else if (nlen>1) sprintf(buf, "%d files %s", nlen, 
+  else if (nlen>1) sprintf(buf, "%d files %s", nlen,
 			   (cpymode) ? "copied" : "moved");
   else buf[0] = '\0';
   setBrowStr(srcBr, buf);
@@ -4824,7 +4823,7 @@
     dstdir = (stat2bf((u_int) st.st_mode) == BF_DIR);
 
     if (overwrite==OWRT_ASK) {
-      sprintf(buf, "%s '%s' exists.\n\nOverwrite?", 
+      sprintf(buf, "%s '%s' exists.\n\nOverwrite?",
 	      dstdir ? "Directory" : "File", dst);
       i = PopUp(buf, owbuts, 4);
 
@@ -4848,7 +4847,7 @@
     }
   }
 
-  
+
   if (!rename(src, dst)) return 0;   /* Ok */
   if (errno != EXDEV) return 1;      /* failure, of some sort */
 
@@ -4896,7 +4895,7 @@
   /* possible cases:  source is either a file or a directory, or doesn't exist,
      destination is either a file, a directory, or doesn't exist.
 
-     if source doesn't exist, nothing to do.  
+     if source doesn't exist, nothing to do.
      if source is a file:
         if dest is a file, popup 'overwriting' question, delete file if ok
 	if dest is a dir,  popup 'overwriting dir' question, delete dir if ok
@@ -4957,7 +4956,7 @@
   /* destination doesn't exist no more, if it ever did... */
   userMask = umask(0);  /* grab the umask */
   umask((mode_t) userMask);      /* put it back... */
-  
+
 
   strcpy(cpSrcPath, src);
   strcpy(cpDstPath, dst);
@@ -5017,7 +5016,7 @@
      called recursively by cp_dir, there are *no* guarantees that either file
      exists or not */
 
-  int         i, havedst;
+  int         havedst;
   struct stat srcSt, dstSt;
 
   if (stat(cpSrcPath, &srcSt)) {   /* src doesn't exist, usefully... */
@@ -5037,7 +5036,7 @@
   }
 
 
-  switch(stat2bf((u_int) srcSt.st_mode)) {   
+  switch(stat2bf((u_int) srcSt.st_mode)) {
     /* determine how to copy, by filetype */
 
     /* NOTE:  There is no S_IFLNK case here, since we're using 'stat()' and
@@ -5059,12 +5058,12 @@
       return;
     }
   }
-    
+
     cp_dir();
     if (!havedst) chmod(cpDstPath, srcSt.st_mode);
-    
+
     break;
-    
+
 
   case BF_CHR:
   case BF_BLK:   cp_special(&srcSt, havedst);    break;
@@ -5089,12 +5088,12 @@
 {
   int    i, dirlen, oldsrclen, olddstlen, longpath;
   char **names, *name;
-  struct stat  srcSt, dstSt;
+  struct stat  srcSt;
 
 
   /* src and dst directories both exists now.  copy entries */
 
-  if (DEBUG) fprintf(stderr,"cp_dir:   src='%s',  dst='%s'\n", 
+  if (DEBUG) fprintf(stderr,"cp_dir:   src='%s',  dst='%s'\n",
 		     cpSrcPath, cpDstPath);
 
   longpath  = 0;
@@ -5110,9 +5109,9 @@
 
   for (i=0; i<dirlen && overwrite!=OWRT_CANCEL; i++) {
     name = names[i];
-    if (name[0] == '.' && (name[1]=='\0' || 
+    if (name[0] == '.' && (name[1]=='\0' ||
 			   (name[1]=='.' && name[2]=='\0'))) goto done;
-    
+
     /* add name to src and dst paths */
     if ((strlen(name) + oldsrclen >= (MAXPATHLEN-3)) ||
 	(strlen(name) + olddstlen >= (MAXPATHLEN-3)))   {
@@ -5130,12 +5129,12 @@
       cpSrcPath[oldsrclen] = '\0';
       goto done;
     }
-     
+
     if (stat2bf((u_int) srcSt.st_mode) == BF_DIR) {
       cpSrcPath[oldsrclen] = '\0';
       continue;                     /* don't remove from list, just skip */
     }
-     
+
     strcat(cpDstPath, "/");
     strcat(cpDstPath, name);
     cp();                         /* RECURSE */
@@ -5169,7 +5168,7 @@
     strcat(cpDstPath, name);
 
     cp();                        /* RECURSE */
-    
+
     cpSrcPath[oldsrclen] = '\0';
     cpDstPath[olddstlen] = '\0';
   }
@@ -5191,10 +5190,10 @@
 /*****************************/
 {
   register int srcFd, dstFd, rcount, wcount, i;
-  char         str[512], buf[8192];
+  char         buf[8192];
   static char  *owbuts[4] = { "\nOk", "dDon't Ask", "nNo", "\033Cancel" };
 
-  if (DEBUG) fprintf(stderr,"cp_file:  src='%s',  dst='%s'\n", 
+  if (DEBUG) fprintf(stderr,"cp_file:  src='%s',  dst='%s'\n",
 		     cpSrcPath, cpDstPath);
 
   if ((srcFd = open(cpSrcPath, O_RDONLY, 0)) == -1) {
@@ -5255,7 +5254,7 @@
      int exists;
 /*********************************/
 {
-  if (DEBUG) fprintf(stderr,"cp_spec:  src='%s',  dst='%s'\n", 
+  if (DEBUG) fprintf(stderr,"cp_spec:  src='%s',  dst='%s'\n",
 		     cpSrcPath, cpDstPath);
 
   if (exists && unlink(cpDstPath)) {
@@ -5281,7 +5280,7 @@
      int exists;
 /*********************************/
 {
-  if (DEBUG) fprintf(stderr,"cp_fifo:  src='%s',  dst='%s'\n", 
+  if (DEBUG) fprintf(stderr,"cp_fifo:  src='%s',  dst='%s'\n",
 		     cpSrcPath, cpDstPath);
 
 #ifdef S_IFIFO
@@ -5302,12 +5301,12 @@
 
 
 
-  
+
 /*********************************/
 static int stat2bf(uistmode)
      u_int uistmode;
 {
-  /* given the 'st.st_mode' field from a successful stat(), returns 
+  /* given the 'st.st_mode' field from a successful stat(), returns
      BF_FILE, BF_DIR, BF_BLK, BF_CHR, BF_FIFO, or BF_SOCK.  Does *NOT*
      return BF_EXE */
 
@@ -5357,8 +5356,8 @@
 static int selmatch1(name, arg)
      char *name, *arg;
 {
-  /* returns non-zero if 'name' matches 'arg'.  Any '*' chars found in arg 
-     are considered wildcards that match any number of characters, 
+  /* returns non-zero if 'name' matches 'arg'.  Any '*' chars found in arg
+     are considered wildcards that match any number of characters,
      including zero. */
 
   char *sp, *oldnp;
@@ -5379,7 +5378,7 @@
 	while (*name) name++;
 	while (*arg ) arg++;
 	name--;  arg--;
-	
+
 	while (*arg != '*') {
 	  if (*arg != *name || name<oldnp) return 0;
 	  arg--;  name--;
@@ -5388,7 +5387,7 @@
       }
 
       else {  /* there are more '*'s in arg... */
-	/* find the first occurrence of the string between the two '*'s.  
+	/* find the first occurrence of the string between the two '*'s.
 	   if the '*'s are next to each other, just throw away the first one */
 
 	arg++;  /* points to char after  first  '*' */
@@ -5410,7 +5409,7 @@
 	  arg = sp+1;
 	}
       }
-    }	  
+    }
   }
 
   if (!*arg && !*name) return 1;
diff -ruN xv-3.10a/xvbutt.c xv-3.10a-bugfixes/xvbutt.c
--- xv-3.10a/xvbutt.c	1995-01-03 13:19:51.000000000 -0800
+++ xv-3.10a-bugfixes/xvbutt.c	2004-05-16 18:01:29.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * xvbutt.c - regular, 'radio', 'checkbox', and 'menu' pushbuttons
  *
  * callable functions:
@@ -16,7 +16,7 @@
  *   RBSetActive()          -  sets active status of an RBUTT
  *   RBClick()              -  finds clicked-on rb in a list
  *   RBTrack()              -  tracks rb after click, until release
- * 
+ *
  *   CBCreate()             -  create a CBUTT (checkbox button)
  *   CBRedraw()             -  redraw a CBUTT
  *   CBSetActive()          -  change active status of a CBUTT
@@ -26,7 +26,7 @@
  *   MBCreate()             -  create a MBUTT (menu button)
  *   MBRedraw()             -  redraw a MBUTT
  *   MBSetActive()          -  change active status of a MBUTT
- *   MBWhich()              -  returns # of first checked selection 
+ *   MBWhich()              -  returns # of first checked selection
  *   MBSelect()             -  similar to RBSelect() ...
  *   MBClick()              -  returns true if given MB was clicked on
  *   MBTrack()              -  tracks MBUTT after click, until release
@@ -116,7 +116,7 @@
 void BTRedraw(bp)
 BUTT *bp;
 {
-  int          i,x,y,r,x1,y1;
+  int          x,y,r,x1,y1;
   unsigned int w,h;
   XPoint       tpts[10], bpts[10], ipts[5];
 
@@ -170,13 +170,13 @@
     XSetForeground(theDisp, theGC, bp->fg);
     XDrawLines(theDisp, bp->win, theGC, ipts, 5, CoordModeOrigin);  /* inset */
 
-    XDrawLine(theDisp, bp->win, theGC, x+1,             y + 1,  
+    XDrawLine(theDisp, bp->win, theGC, x+1,             y + 1,
 	      ipts[0].x, ipts[0].y);
     XDrawLine(theDisp, bp->win, theGC, x+1,             y + (int) h - 1,
 	      ipts[1].x, ipts[1].y);
     XDrawLine(theDisp, bp->win, theGC, x + (int) w - 1, y + (int) h - 1,
 	      ipts[2].x, ipts[2].y);
-    XDrawLine(theDisp, bp->win, theGC, x + (int) w - 1, y+1,  
+    XDrawLine(theDisp, bp->win, theGC, x + (int) w - 1, y+1,
 	      ipts[3].x, ipts[3].y);
 
     if (bp->lit) {
@@ -184,12 +184,12 @@
       XDrawRectangle(theDisp, bp->win, theGC, x+1, y+1, w-2, h-2);
     }
   }
-    
+
   else {   /* ctrlColor */
     XSetForeground(theDisp, theGC, bp->bg);
     XFillRectangle(theDisp, bp->win, theGC, x+1, y+1, w-1, h-1);
 
-    Draw3dRect(bp->win, x+1, y+1, w-2, h-2, R3D_OUT, bp->fwidth, 
+    Draw3dRect(bp->win, x+1, y+1, w-2, h-2, R3D_OUT, bp->fwidth,
 	       bp->hi, bp->lo, bp->bg);
 
     XSetForeground(theDisp, theGC, bp->fg);
@@ -198,7 +198,7 @@
     if (bp->lit)
       XDrawRectangle(theDisp, bp->win, theGC, x+1, y+1, w-2, h-2);
   }
-    
+
 
 
 
@@ -210,7 +210,7 @@
 
     XSetBackground(theDisp, theGC, bp->bg);
 
-    if (bp->colorpix) 
+    if (bp->colorpix)
       XCopyArea (theDisp,bp->pix, bp->win, theGC, 0,0,bp->pw,bp->ph, x1,y1);
     else
       XCopyPlane(theDisp,bp->pix, bp->win, theGC, 0,0,bp->pw,bp->ph, x1,y1,1L);
@@ -262,15 +262,15 @@
     if (bp->lit==inval && PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h)) {
       bp->lit = !inval;  BTRedraw(bp);  XFlush(theDisp);
     }
-    
+
     if (bp->lit!=inval && !PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h)) {
       bp->lit = inval;  BTRedraw(bp);  XFlush(theDisp);
     }
   }
 
   rval = (bp->lit != inval);
-  
-  if (bp->lit && !bp->toggle) 
+
+  if (bp->lit && !bp->toggle)
     { bp->lit = 0;  BTRedraw(bp);  XFlush(theDisp); }
 
   return(rval);
@@ -295,13 +295,13 @@
 {
   /* mallocs an RBUTT, fills in the fields, and appends it to rblist
      if rblist is NULL, this is the first rb in the list.  It will
-     be made the 'selected' one 
+     be made the 'selected' one
 
-     Note: no need to check return status.  It'll fatal error if it 
+     Note: no need to check return status.  It'll fatal error if it
      can't malloc */
 
   RBUTT *rb, *rbptr;
-  Pixmap rb_frame, rb_frame1, rb_top, rb_bot, rb_dtop, rb_dbot, rb_body, 
+  Pixmap rb_frame, rb_frame1, rb_top, rb_bot, rb_dtop, rb_dbot, rb_body,
          rb_dot;
 
   rb = (RBUTT *) malloc(sizeof(RBUTT));
@@ -348,7 +348,7 @@
     rb_off    = XCreatePixmap(theDisp, rootW, RBSIZE, RBSIZE, dispDEEP);
     rb_off1   = XCreatePixmap(theDisp, rootW, RBSIZE, RBSIZE, dispDEEP);
 
-    if (!rb_frame || !rb_frame1 || !rb_top || !rb_bot || !rb_dtop || 
+    if (!rb_frame || !rb_frame1 || !rb_top || !rb_bot || !rb_dtop ||
 	!rb_dbot  || !rb_body   || !rb_dot || !rb_on  || !rb_on1  ||
 	!rb_off   || !rb_off1)
       FatalError("unable to create radio-button pixmaps");
@@ -410,7 +410,7 @@
       XFillRectangle(theDisp, rb_on,   theGC, 0,0,RBSIZE,RBSIZE);
       XFillRectangle(theDisp, rb_on1,  theGC, 0,0,RBSIZE,RBSIZE);
     }
-      
+
     XSetStipple(theDisp, theGC, rb_frame);
     XSetForeground(theDisp, theGC, fg);
     XFillRectangle(theDisp, rb_on,   theGC, 0,0,RBSIZE,RBSIZE);
@@ -437,7 +437,7 @@
 
   return(rb);
 }
-  
+
 
 
 
@@ -475,23 +475,23 @@
      int   lit;
 {
   /* draws the rb being pointed at */
-  
+
   Pixmap pix;
-  
+
   if (!rb) return;  /* rb = NULL */
-  
+
   XSetForeground(theDisp, theGC, rb->fg);
-  
+
   if (rb->selected) { pix = (lit) ? rb_on1 : rb_on; }
   else { pix = (lit) ? rb_off1 : rb_off; }
-  
+
   XCopyArea(theDisp, pix, rb->win, theGC, 0,0,RBSIZE,RBSIZE, rb->x, rb->y);
-  DrawString(rb->win, rb->x + RBSIZE + 4, 
+  DrawString(rb->win, rb->x + RBSIZE + 4,
 	     rb->y + RBSIZE/2 - CHIGH/2 + ASCENT, rb->str);
 
   if (!rb->active) {  /* if non-active, dim button and string */
     DimRect(rb->win, rb->x, rb->y, RBSIZE, RBSIZE, rb->bg);
-    DimRect(rb->win, rb->x + RBSIZE + 4, rb->y + RBSIZE/2 - CHIGH/2, 
+    DimRect(rb->win, rb->x + RBSIZE + 4, rb->y + RBSIZE/2 - CHIGH/2,
 	    (u_int) StringWidth(rb->str), (u_int) CHIGH, rb->bg);
   }
 }
@@ -527,19 +527,19 @@
 }
 
 
-	      
+
 /***********************************************/
 int RBWhich(rblist)
      RBUTT *rblist;
 {
   int i;
-  
+
   /* returns index of currently selected rb.  if none, returns -1 */
-  
+
   i = 0;
-  while (rblist && !rblist->selected) 
+  while (rblist && !rblist->selected)
     { rblist = (RBUTT *) rblist->next;  i++; }
-  
+
   if (!rblist) return -1;             /* didn't find one */
   return i;
 }
@@ -550,9 +550,9 @@
      RBUTT *rblist;
 {
   int i;
-  
+
   /* returns # of rb's in the list */
-  
+
   i = 0;
   while (rblist) { rblist = (RBUTT *) rblist->next; i++; }
   return i;
@@ -566,13 +566,13 @@
 {
   RBUTT *rb;
   int    i;
-  
+
   /* sets 'active' status of rb #n.  does redrawing */
-  
+
   rb=rblist;  i=0;
   while (rb && i!=n) { rb = (RBUTT *) rb->next; i++; }
   if (!rb) return;                         /* n out of range.  do nothing */
-  
+
   if (rb->active != act) {
     rb->active = act;
     drawRB(rb, 0);
@@ -588,13 +588,13 @@
   int i;
 
   /* searches through rblist to see if mouse click at mx,my is in the
-     clickable region of any of the rb's.  If it finds one, it returns 
+     clickable region of any of the rb's.  If it finds one, it returns
      it's index in the list.  If not, returns -1 */
 
   i = 0;
   while (rblist) {
     if (PTINRECT(mx, my, rblist->x, rblist->y, RBSIZE, RBSIZE)) break;
-    
+
     rblist = (RBUTT *) rblist->next;
     i++;
   }
@@ -613,9 +613,9 @@
   Window       rW, cW;
   int          i, x, y, rx, ry, lit, rv;
   unsigned int mask;
-  
+
   /* returns '1' if selection changed */
-  
+
   rb=rblist;  i=0;
   while (rb && i!=n) { rb = (RBUTT *) rb->next; i++; }
   if (!rb) return 0;                    /* n out of range */
@@ -637,7 +637,7 @@
       drawRB(rb, lit);
       XFlush(theDisp);
     }
-    
+
     if (lit && !PTINRECT(x, y, rb->x, rb->y, RBSIZE, RBSIZE)) {
       lit=0;
       drawRB(rb, lit);
@@ -690,14 +690,14 @@
      do so.  We'll be needing them, y'see... */
 
   if (!cbpixmade) {
-    cbcheck = XCreatePixmapFromBitmapData(theDisp, rootW, 
+    cbcheck = XCreatePixmapFromBitmapData(theDisp, rootW,
 	     (char *) cb_check_bits,
 	     cb_check_width, cb_check_height, fg, bg, dispDEEP);
 
     cbpixmade = 1;
   }
 }
-  
+
 
 
 
@@ -708,25 +708,25 @@
   /* draws the cb being pointed at */
 
   XSetForeground(theDisp, theGC, cb->bg);
-  XFillRectangle(theDisp, cb->win, theGC, cb->x+2, cb->y+2, 
+  XFillRectangle(theDisp, cb->win, theGC, cb->x+2, cb->y+2,
 		 XVCBSIZE-3,XVCBSIZE-3);
 
   XSetForeground(theDisp, theGC, cb->fg);
   XDrawRectangle(theDisp, cb->win, theGC, cb->x, cb->y, XVCBSIZE, XVCBSIZE);
   Draw3dRect(cb->win, cb->x+1, cb->y+1, XVCBSIZE-2, XVCBSIZE-2, R3D_OUT, 2,
-	     cb->hi, cb->lo, cb->bg); 
+	     cb->hi, cb->lo, cb->bg);
 
-  if (cb->val) XCopyArea(theDisp, cbcheck, cb->win, theGC, 
-			 0, 0, cb_check_width, cb_check_height, 
+  if (cb->val) XCopyArea(theDisp, cbcheck, cb->win, theGC,
+			 0, 0, cb_check_width, cb_check_height,
 			 cb->x+3, cb->y+3);
- 
+
   XSetForeground(theDisp, theGC, cb->fg);
-  DrawString(cb->win, cb->x + XVCBSIZE+4, 
+  DrawString(cb->win, cb->x + XVCBSIZE+4,
 	     cb->y+XVCBSIZE/2 - CHIGH/2 + ASCENT, cb->str);
 
   if (!cb->active) {  /* if non-active, dim button and string */
     DimRect(cb->win, cb->x, cb->y, XVCBSIZE, XVCBSIZE, cb->bg);
-    DimRect(cb->win, cb->x + XVCBSIZE+4, cb->y+XVCBSIZE/2 - CHIGH/2, 
+    DimRect(cb->win, cb->x + XVCBSIZE+4, cb->y+XVCBSIZE/2 - CHIGH/2,
 	    (u_int) StringWidth(cb->str), (u_int) CHIGH, cb->bg);
   }
 }
@@ -761,7 +761,6 @@
   Window       rW, cW;
   int          x, y, rx, ry, lit;
   unsigned int mask;
-  Pixmap litpix, darkpix;
 
   /* called once we've figured out that the mouse clicked in 'cb' */
 
@@ -782,7 +781,7 @@
       drawCB(cb,lit);
       XFlush(theDisp);
     }
-    
+
     if (lit && !PTINRECT(x, y, cb->x, cb->y, XVCBSIZE, XVCBSIZE)) {
       lit=0;
       drawCB(cb,lit);
@@ -809,28 +808,28 @@
 {
   /* draws highlighting */
   if (lit) {
-    if (ctrlColor) 
+    if (ctrlColor)
       Draw3dRect(cb->win, cb->x+1, cb->y+1, XVCBSIZE-2, XVCBSIZE-2, R3D_IN, 2,
 		 cb->hi, cb->lo, cb->bg);
     else {
       XSetForeground(theDisp, theGC, cb->fg);
-      XDrawRectangle(theDisp, cb->win, theGC, cb->x+1, cb->y+1, 
+      XDrawRectangle(theDisp, cb->win, theGC, cb->x+1, cb->y+1,
 		     XVCBSIZE-2, XVCBSIZE-2);
     }
   }
 
   else {
-    if (ctrlColor) 
+    if (ctrlColor)
       Draw3dRect(cb->win, cb->x+1, cb->y+1, XVCBSIZE-2, XVCBSIZE-2, R3D_OUT, 2,
 		 cb->hi, cb->lo, cb->bg);
     else {
       XSetForeground(theDisp, theGC, cb->bg);
-      XDrawRectangle(theDisp, cb->win, theGC, cb->x+1, cb->y+1, 
+      XDrawRectangle(theDisp, cb->win, theGC, cb->x+1, cb->y+1,
 		     XVCBSIZE-2, XVCBSIZE-2);
     }
   }
 }
-    
+
 
 
 /******************* MBUTT ROUTINES ************************/
@@ -851,7 +850,7 @@
   XSetWindowAttributes xswa;
   unsigned long        xswamask;
   int i;
-  
+
   if (!mbpixmade) {
     mbchk = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) mb_chk_bits,
 	     mb_chk_width, mb_chk_height, fg, bg, dispDEEP);
@@ -889,7 +888,7 @@
   xswa.save_under       = True;
   xswamask = CWBackPixel | CWBorderPixel | CWSaveUnder;
 
-  mb->mwin = XCreateWindow(theDisp, mb->win, x, y, w, h, 
+  mb->mwin = XCreateWindow(theDisp, mb->win, x, y, w, h,
 			   (u_int) 2, (int) dispDEEP, InputOutput,
 			   theVisual, xswamask, &xswa);
 
@@ -898,7 +897,7 @@
   XSelectInput(theDisp, mb->mwin, ExposureMask | VisibilityChangeMask);
   XSetTransientForHint(theDisp, mb->mwin, mb->win);
 }
-  
+
 
 
 
@@ -908,15 +907,15 @@
 {
   /* draws a menu button in it's normal state.  (When it's actively being
      used (to select an item), all drawing is handled in MBTrack) */
-  
+
   int          x,y,i,r,x1,y1;
   unsigned int w,h;
-  
+
   r = 2;  /* amt of shadow */
   x = mb->x;  y = mb->y;  w = mb->w;  h = mb->h;
-  x1 = x + (int) w;  
+  x1 = x + (int) w;
   y1 = y + (int) h;
-  
+
   XSetForeground(theDisp, theGC, mb->bg);
   XFillRectangle(theDisp, mb->win, theGC, x+1, y+1, w-1, h-1);
 
@@ -940,7 +939,7 @@
     XSetBackground(theDisp, theGC, mb->bg);
     XCopyPlane(theDisp, mb->pix, mb->win, theGC, 0,0,
 	       (u_int) mb->pw, (u_int) mb->ph, x1,y1, 1L);
-    if (!mb->active) 
+    if (!mb->active)
       DimRect(mb->win, x1,y1, (u_int) mb->pw, (u_int) mb->ph, mb->bg);
   }
 
@@ -997,14 +996,14 @@
      MBUTT *mb;
 {
   /* returns index of first checked selection, or '-1' if nothing selected */
-  
+
   int i;
 
   if (!mb->hascheck) return -1;
 
   for (i=0; i<mb->nlist; i++)
     if (mb->flags[i]) return i;
-  
+
   return -1;
 }
 
@@ -1017,13 +1016,13 @@
   /* makes entry #n the selected entry (ie, the only one with a check mark)
      Does all redrawing.  Does nothing if entry #n already selected.
      Don't let it select 'dim' entries */
-  
+
   int i;
-  
+
   if (n<0 || n>mb->nlist) return;               /* # out of range */
   if (!mb->hascheck)      return;               /* shouldn't happen */
   if (mb->flags[n])       return;               /* already selected */
-  
+
   for (i=0; i<MAXMBLEN; i++) mb->flags[i] = 0;
 
   mb->flags[n] = 1;
@@ -1083,7 +1082,7 @@
     }
   }
   mwide += 8;                             /* extra room at edges */
-  
+
   /* make wider if any checked menu items */
   for (i=0; i<mb->nlist && !mb->flags[i]; i++);
   hascheck = (i<mb->nlist || mb->hascheck);
@@ -1091,7 +1090,7 @@
   if (hascheck && mb->title) mwide += 8;
 
   if (mwide < (mb->w+1)) mwide = mb->w+1; /* at least as wide as button */
-    
+
   mhigh = mb->nlist * LINEHIGH + 2 + extratop;
 
   mx = mb->x-1;  my = mb->y - 1;
@@ -1144,10 +1143,10 @@
     }
 
     if (mb->flags[i]) {
-      XCopyArea(theDisp, mbchk, win, theGC, 0, 0, mb_chk_width, mb_chk_height, 
+      XCopyArea(theDisp, mbchk, win, theGC, 0, 0, mb_chk_width, mb_chk_height,
 		x - 10, y - 8);
     }
-    
+
     if (!strcmp(mb->list[i], MBSEP)) {
       mb->dim[i] = 1;    /* don't select this one */
       if (ctrlColor) {
@@ -1161,15 +1160,15 @@
 	XDrawLine(theDisp,win,theGC,4,y-(ASCENT/2)+1, mwide-5, y-(ASCENT/2)+1);
 	XSetForeground(theDisp, theGC, mb->fg);
       }
-      else 
+      else
 	XDrawLine(theDisp, win, theGC, 4, y-(ASCENT/2), mwide-5, y-(ASCENT/2));
     }
     else {
       DrawString(win, x, y, txtstr);
-      if (tabstr) 
+      if (tabstr)
 	DrawString(win, mwide - mtabwide - 4, y, tabstr);
 
-      if (mb->dim[i]) 
+      if (mb->dim[i])
 	DimRect(win, x, y-ASCENT, (u_int) mwide, (u_int) CHIGH, mb->bg);
       XSetForeground(theDisp, theGC, mb->fg);
     }
diff -ruN xv-3.10a/xvcolor.c xv-3.10a-bugfixes/xvcolor.c
--- xv-3.10a/xvcolor.c	1995-01-06 11:29:23.000000000 -0800
+++ xv-3.10a-bugfixes/xvcolor.c	2004-05-16 18:01:37.000000000 -0700
@@ -52,7 +52,7 @@
      int   pwide, phigh, *pnumcols;
 {
   /* operates on 8-bit images.  sorts the colormap into 'best' order
-   * 'order' is the 'best' order to allocate the colors.  'trans' is a 
+   * 'order' is the 'best' order to allocate the colors.  'trans' is a
    * transformation to be done to pic, cpic, and epic (in PIC8 mode) to
    * compress the colormap
    */
@@ -67,22 +67,22 @@
   /* initialize histogram and compute it */
   for (i=0; i<256; i++) hist[i]=0;
   for (i=pwide*phigh, p=pic; i; i--, p++) hist[*p]++;
-  
+
   if (DEBUG>1) {
     fprintf(stderr,"%s: Desired colormap\n",cmd);
-    for (i=0; i<256; i++) 
+    for (i=0; i<256; i++)
       if (hist[i]) fprintf(stderr,"(%3d  %02x,%02x,%02x %d)\n",
 			   i,rmap[i],gmap[i],bmap[i], hist[i]);
     fprintf(stderr,"\n\n");
   }
-  
-  
+
+
   /* put the actually-used colors into the 'c' array in the order they occur
      also, while we're at it, calculate ncols, and close up gaps in
      colortable */
-  
+
   for (i=ncols=0; i<256; i++) {
-    if (hist[i]) { 
+    if (hist[i]) {
       rmap[ncols] = rmap[i];
       gmap[ncols] = gmap[i];
       bmap[ncols] = bmap[i];
@@ -104,8 +104,8 @@
   }
   xvbcopy((char *) &c[entry], (char *) &c1[0], sizeof(CMAPENT));
   c[entry].use = 0;   /* dealt with */
-  
-  
+
+
   /* sort rest of colormap.  Half of the entries are allocated on the
      basis of distance from already allocated colors, and half on the
      basis of usage.  (NB: 'taxicab' distance is used throughout this file.)
@@ -116,7 +116,7 @@
      To obtain O(n^2) performance, we keep each unselected color
      (in c[], with use>0) marked with the minimum distance to any of
      the selected colors (in c1[]).  Each time we select a color, we
-     can update the minimum distances in O(n) time. 
+     can update the minimum distances in O(n) time.
 
      mod by Tom Lane   Tom.Lane@g.gp.cs.cmu.edu */
 
@@ -134,8 +134,8 @@
       for (j=0, cj=c; j<ncols; j++,cj++) {
 	if (cj->use) {      /* this color has not been marked already */
 	  /* update mindist */
-          d = (cj->r - ckR)*(cj->r - ckR) + 
-	      (cj->g - ckG)*(cj->g - ckG) + 
+          d = (cj->r - ckR)*(cj->r - ckR) +
+	      (cj->g - ckG)*(cj->g - ckG) +
 	      (cj->b - ckB)*(cj->b - ckB);
           if (cj->mindist > d) cj->mindist = d;
 	  if (cj->mindist > mdist) { mdist = cj->mindist;  entry = j; }
@@ -148,8 +148,8 @@
       for (j=0, cj=c; j<ncols; j++,cj++) {
 	if (cj->use) {  /* this color has not been marked already */
 	  /* update mindist */
-          d = (cj->r - ckR)*(cj->r - ckR) + 
-	      (cj->g - ckG)*(cj->g - ckG) + 
+          d = (cj->r - ckR)*(cj->r - ckR) +
+	      (cj->g - ckG)*(cj->g - ckG) +
     	      (cj->b - ckB)*(cj->b - ckB);
           if (cj->mindist > d) cj->mindist = d;
 	  if (cj->use > mdist) { mdist = cj->use;  entry = j; }
@@ -162,18 +162,18 @@
     xvbcopy((char *) &c[entry], (char *) &c1[i], sizeof(CMAPENT));
     c[entry].use = 0;
   }
-  
+
 
   for (i=0; i<ncols; i++) order[i] = (byte) c1[i].oldindex;
 
   if (DEBUG>1) {
     fprintf(stderr,"%s: result of sorting colormap\n",cmd);
-    for (i=0; i<ncols; i++) 
+    for (i=0; i<ncols; i++)
       fprintf(stderr,"(%3d  %02x,%02x,%02x)     ",i,rmap[i],gmap[i],bmap[i]);
     fprintf(stderr,"\n\n");
-    
+
     fprintf(stderr,"%s: allocation order table\n",cmd);
-    for (i=0; i<ncols; i++) 
+    for (i=0; i<ncols; i++)
       fprintf(stderr,"order[%d] = -> %d\n", i, order[i]);
     fprintf(stderr,"\n");
   }
@@ -240,7 +240,7 @@
       SetISTR(ISTR_COLOR,"Using %s colormap.",
 	      (haveStdCmap == STD_111 ? "2x2x2" :
 	       haveStdCmap == STD_222 ? "4x4x4" :
-	       haveStdCmap == STD_232 ? "4x8x4" : 
+	       haveStdCmap == STD_232 ? "4x8x4" :
                haveStdCmap == STD_666 ? "6x6x6" : "8x8x4"));
 
       if (ncols>0) SetISTR(ISTR_COLOR2,stdCmapSuccess);
@@ -251,7 +251,7 @@
 
     for (i=0; i<numcols; i++) {
       int i332;
-      i332 = ((int)rMap[i]&0xe0) | (((int)gMap[i]&0xe0)>>3) | 
+      i332 = ((int)rMap[i]&0xe0) | (((int)gMap[i]&0xe0)>>3) |
 	     (((int)bMap[i]&0xc0)>>6);
 
       cols[i]  = stdcols[i332];
@@ -291,7 +291,7 @@
   }
 
   else {
-    for (i=0; i<nfcols; i++) 
+    for (i=0; i<nfcols; i++)
       xvFreeColors(theDisp, theCmap, &freecols[i], 1, 0L);
 
     nfcols = 0;
@@ -314,19 +314,19 @@
   unique = p2alloc = 0;
   rwthistime = 0;
 
-  /* FIRST PASS COLOR ALLOCATION:  
+  /* FIRST PASS COLOR ALLOCATION:
      for each color in the 'desired colormap', try to get it via
      xvAllocColor().  If for any reason it fails, mark that pixel
      'unallocated' and worry about it later.  Repeat. */
 
-  /* attempt to allocate first ncols entries in colormap 
+  /* attempt to allocate first ncols entries in colormap
      note: On displays with less than 8 bits per RGB gun, it's quite
      possible that different colors in the original picture will be
      mapped to the same color on the screen.  X does this for you
-     silently.  However, this is not-desirable for this application, 
+     silently.  However, this is not-desirable for this application,
      because when I say 'allocate me 32 colors' I want it to allocate
      32 different colors, not 32 instances of the same 4 shades... */
-  
+
 
   for (i=0; i<256; i++) failed[i] = 1;
 
@@ -334,7 +334,7 @@
 
   for (i=0; i<numcols && unique<ncols; i++) {
     c = colAllocOrder[i];
-    if (mono) { 
+    if (mono) {
       int intens = MONO(rMap[c], gMap[c], bMap[c]);
       defs[c].red = defs[c].green = defs[c].blue = intens<<8;
     }
@@ -346,8 +346,8 @@
 
     defs[c].flags = DoRed | DoGreen | DoBlue;
 
-    if (!(colorMapMode==CM_OWNCMAP && cmap==theCmap && CMAPVIS(theVisual)) 
-	&& xvAllocColor(theDisp,cmap,&defs[c])) { 
+    if (!(colorMapMode==CM_OWNCMAP && cmap==theCmap && CMAPVIS(theVisual))
+	&& xvAllocColor(theDisp,cmap,&defs[c])) {
       unsigned long pixel, *fcptr;
 
       pixel = cols[c] = defs[c].pixel;
@@ -355,7 +355,7 @@
       gdisp[c] = defs[c].green >> 8;
       bdisp[c] = defs[c].blue  >> 8;
       failed[c]= 0;
-      
+
       /* see if the newly allocated color is new and different */
       for (j=0, fcptr=freecols; j<nfcols && *fcptr!=pixel; j++,fcptr++);
       if (j==nfcols) unique++;
@@ -365,24 +365,24 @@
     }
 
     else {
-      /* the allocation failed.  If we want 'perfect' color, and we haven't 
+      /* the allocation failed.  If we want 'perfect' color, and we haven't
 	 already created our own colormap, we'll want to do so */
       if ((colorMapMode == CM_PERFECT || colorMapMode == CM_OWNCMAP)
 	  && !LocalCmap && CMAPVIS(theVisual)) {
 	LocalCmap = XCreateColormap(theDisp, vrootW, theVisual, AllocNone);
-	
+
 	if (LocalCmap) {  /* succeeded, presumably */
 	  /* free all colors that were allocated, and try again with the
 	     new colormap.  This is necessary because 'XCopyColormapAndFree()'
 	     has the unpleasant side effect of freeing up the various
 	     colors I need for the control panel, etc. */
 
-	  for (i=0; i<nfcols; i++) 
+	  for (i=0; i<nfcols; i++)
 	    xvFreeColors(theDisp, theCmap, &freecols[i], 1, 0L);
-	  
+
 	  if (mainW && !useroot) XSetWindowColormap(theDisp,mainW, LocalCmap);
 
-	  if (mainW && !useroot && cmapInGam) 
+	  if (mainW && !useroot && cmapInGam)
 	    XSetWindowColormap(theDisp,gamW, LocalCmap);
 	  cmap = LocalCmap;
 
@@ -402,9 +402,9 @@
       }
     }
   }  /* FIRST PASS */
-  
-  
-  
+
+
+
   if (nfcols==numcols) {
     if (numcols != unique)
       SetISTR(ISTR_COLOR,"Got all %d colors.  (%d unique)", numcols,
@@ -415,7 +415,7 @@
     SetISTR(ISTR_COLOR2,"");
     return;
   }
-  
+
 
 
   /* SECOND PASS COLOR ALLOCATION:
@@ -427,7 +427,7 @@
      is in the X colormap.  Try to allocate that color (read only).
      If that fails, the THIRD PASS will deal with it */
 
-  SetISTR(ISTR_COLOR,"Got %d of %d colors.  (%d unique)", 
+  SetISTR(ISTR_COLOR,"Got %d of %d colors.  (%d unique)",
 	  nfcols,numcols,unique);
 
   /* read entire colormap (or first 256 entries) into 'ctab' */
@@ -436,28 +436,28 @@
   if (dc>0) {  /* only do SECOND PASS if there IS a colormap to read */
     for (i=0; i<dc; i++) ctab[i].pixel = (unsigned long) i;
     XQueryColors(theDisp, cmap, ctab, dc);
-    
+
     for (i=0; i<numcols && unique<ncols; i++) {
       c = colAllocOrder[i];
-      
+
       if (failed[c]) {  /* an unallocated pixel */
 	int d, mdist, close;
 	int rd, gd, bd, ri, gi, bi;
-	
+
 	mdist = 1000000;   close = -1;
 	ri = rMap[c];  gi = gMap[c];  bi = bMap[c];
-	
+
 	for (j=0; j<dc; j++) {
 	  rd = ri - (ctab[j].red  >>8);
 	  gd = gi - (ctab[j].green>>8);
 	  bd = bi - (ctab[j].blue >>8);
-	  
+
 	  d = rd*rd + gd*gd + bd*bd;
 	  if (d<mdist) { mdist=d; close=j; }
 	}
-	
+
 	if (close<0) FatalError("This Can't Happen! (How reassuring.)");
-	if (xvAllocColor(theDisp, cmap, &ctab[close])) { 
+	if (xvAllocColor(theDisp, cmap, &ctab[close])) {
 	  xvbcopy((char *) &ctab[close], (char *) &defs[c], sizeof(XColor));
 	  failed[c]= 0;
 	  cols[c]  = ctab[close].pixel;
@@ -487,7 +487,7 @@
 
       mdist = 1000000;   close = -1;
       ri = rMap[c];  gi = gMap[c];  bi = bMap[c];
-      
+
       /* search the alloc'd colors */
       for (j=0; j<nfcols; j++) {
 	k = fc2pcol[j];
@@ -535,7 +535,7 @@
     unsigned long pmr[1], pix[1];
     c = colAllocOrder[i];
 
-    if (cellgroup[c]) {  
+    if (cellgroup[c]) {
       int n;
       /* this color is part of a group.  see if its group's
 	 been seen already, and if so, skip this */
@@ -548,11 +548,11 @@
       }
     }
 
-    if (!(colorMapMode==CM_OWNCMAP && cmap==theCmap && CMAPVIS(theVisual)) && 
+    if (!(colorMapMode==CM_OWNCMAP && cmap==theCmap && CMAPVIS(theVisual)) &&
 	XAllocColorCells(theDisp, cmap, False, pmr, 0, pix, 1)) {
       defs[c].pixel = cols[c] = pix[0];
       failed[c] = 0;
-      if (mono) { 
+      if (mono) {
 	int intens = MONO(rMap[c], gMap[c], bMap[c]);
 	defs[c].red = defs[c].green = defs[c].blue = intens<<8;
       }
@@ -573,20 +573,20 @@
     }
 
     else {
-      if ((colorMapMode == CM_PERFECT || colorMapMode == CM_OWNCMAP) 
+      if ((colorMapMode == CM_PERFECT || colorMapMode == CM_OWNCMAP)
 	  && !LocalCmap && CMAPVIS(theVisual)) {
 	LocalCmap = XCreateColormap(theDisp, vrootW, theVisual, AllocNone);
-	
+
 	/* free all colors that were allocated, and try again with the
 	   new colormap.  This is necessary because 'XCopyColormapAndFree()'
 	   has the unpleasant side effect of freeing up the various
 	   colors I need for the control panel, etc. */
 
-	for (i=0; i<nfcols; i++) 
+	for (i=0; i<nfcols; i++)
 	  xvFreeColors(theDisp, theCmap, &freecols[i], 1, 0L);
-	
+
 	if (mainW && !useroot) XSetWindowColormap(theDisp,mainW, LocalCmap);
-	if (mainW && !useroot && cmapInGam) 
+	if (mainW && !useroot && cmapInGam)
 	  XSetWindowColormap(theDisp,gamW, LocalCmap);
 	cmap = LocalCmap;
 
@@ -608,7 +608,7 @@
   }
 
   else {
-    /* Failed to allocate all colors in picture.  Map remaining desired 
+    /* Failed to allocate all colors in picture.  Map remaining desired
        colors into closest allocated desired colors */
 
       if (nfcols==0 && !LocalCmap) {
@@ -623,7 +623,7 @@
 	allocROColors();
 	return;
       }
-	
+
       SetISTR(ISTR_COLOR,"Got %d of %d colors.",  nfcols,numcols);
 
       for (i=0; i<numcols; i++) {
@@ -662,7 +662,7 @@
     j = fc2pcol[i];
     defs[j].pixel = freecols[i];
 
-    if (mono) { 
+    if (mono) {
       int intens = MONO(rMap[j], gMap[j], bMap[j]);
       defs[j].red = defs[j].green = defs[j].blue = intens<<8;
     }
@@ -706,9 +706,9 @@
   if (theVisual->class == TrueColor || theVisual->class == DirectColor) {
     unsigned long r, g, b, rmask, gmask, bmask, origr, origg, origb;
     int rshift, gshift, bshift;
-    
-    /* shift r,g,b so that high bit of 16-bit color specification is 
-     * aligned with high bit of r,g,b-mask in visual, 
+
+    /* shift r,g,b so that high bit of 16-bit color specification is
+     * aligned with high bit of r,g,b-mask in visual,
      * AND each component with its mask,
      * and OR the three components together
      */
@@ -781,7 +781,7 @@
 	      "         mask=%04lx,%04lx,%04lx  pix=%08lx\n",
 	      rmask, gmask, bmask, cdef->pixel);
     }
-    
+
     return 1;
   }
   else {
@@ -811,7 +811,7 @@
 {
   int i, j;
 
-  /* if regroup is set, we *must* do a full realloc, as the cols[] array 
+  /* if regroup is set, we *must* do a full realloc, as the cols[] array
      isn't correct anymore.  (cell groupings changed) */
 
   ApplyECctrls();  /* set {r,g,b}cmap[editColor] based on dial settings */
@@ -830,16 +830,16 @@
     }
   }
 
-    
+
   /* do something clever if we're using R/W color and this colorcell isn't
      shared */
 
   if (!regroup && allocMode==AM_READWRITE && rwthistime) {
     /* let's try to be clever */
-    /* determine if the editColor cell is unique, or shared (among 
+    /* determine if the editColor cell is unique, or shared (among
        non-group members, that is) */
 
-    for (i=j=0; i<numcols; i++) 
+    for (i=j=0; i<numcols; i++)
       if (rwpc2pc[i] == rwpc2pc[editColor]) j++;
 
     /* if this is a group, subtract off the non-this-one pixels from group */
@@ -901,7 +901,7 @@
   }
 
   /* shift 0..i-1 down one position */
-  xvbcopy((char *) colAllocOrder, (char *) colAllocOrder+1, 
+  xvbcopy((char *) colAllocOrder, (char *) colAllocOrder+1,
 	  i * sizeof(colAllocOrder[0]));
   colAllocOrder[0] = editColor;
 }
@@ -930,9 +930,9 @@
    *   stdfreecols[256]    - list of colors to free on exit
    *   stdnfcols           - # of colors to free
    *
-   * possibly modifies browR, browG, browB, and browcols arrays 
+   * possibly modifies browR, browG, browB, and browcols arrays
    *     (if !browPerfect)
-   */       
+   */
 
   /* returns '1' if the colors were reallocated, '0' otherwise */
 
@@ -946,18 +946,18 @@
 
   /* note:
    *   if (ncols==0) (ie, we're either on, or emulating a b/w display),
-   *   build std*[], std*disp[], colormaps, but don't actually 
+   *   build std*[], std*disp[], colormaps, but don't actually
    *   allocate any colors.
    */
 
-  int i,j,r,g,b, desMode, screwed;
+  int i, r,g,b, desMode, screwed;
   XColor def;
   byte rmap[256],gmap[256],bmap[256],order[256];
   unsigned long descols[256];
   int des2got[256], failed[256];
   int maplen, exactCnt, nearCnt;
-  
-  
+
+
   /* generate stdr,stdg,stdb cmap.  Same in all cases */
   for (r=0, i=0; r<8; r++)
     for (g=0; g<8; g++)
@@ -966,10 +966,10 @@
 	stdg[i] = (g*255)/7;
 	stdb[i] = (b*255)/3;
       }
-  
-  
+
+
   /* determine what size cmap we should build */
-  if (theVisual->class == TrueColor || 
+  if (theVisual->class == TrueColor ||
       theVisual->class == DirectColor) desMode = STD_332;
   else if (colorMapMode == CM_STDCMAP) desMode = STD_232;
   else desMode = STD_222;
@@ -983,9 +983,9 @@
   }
 
 
-  if (DEBUG) fprintf(stderr,"MakeStdCmaps: have=%d, des=%d, ncols=%d\n", 
+  if (DEBUG) fprintf(stderr,"MakeStdCmaps: have=%d, des=%d, ncols=%d\n",
 		     haveStdCmap, desMode, ncols);
-  
+
   if (haveStdCmap != STD_NONE && haveStdCmap == desMode) return 0;
   freeStdCmaps();
 
@@ -997,7 +997,7 @@
   for (i=0; i<256; i++) des2got[i] = i;
   exactCnt = nearCnt = 0;
 
-  
+
   if (desMode == STD_111) {   /* try to alloc 8 colors */
     /* generate a 1/1/1 desired colormap */
     maplen = 8;
@@ -1009,7 +1009,7 @@
 	  bmap[i] = (b*255);
 	}
   }
-  
+
   else if (desMode == STD_222) {   /* try to alloc 64 colors */
     /* generate a 2/2/2 desired colormap */
     maplen = 64;
@@ -1021,7 +1021,7 @@
 	  bmap[i] = (b*255)/3;
 	}
   }
-  
+
   else if (desMode == STD_232) {   /* try to alloc 128 colors */
     /* generate a 2/3/2 desired colormap */
     maplen = 128;
@@ -1033,7 +1033,7 @@
 	  bmap[i] = (b*255)/3;
 	}
   }
-  
+
   else if (desMode == STD_666) {   /* try to alloc 216 colors */
     /* generate a 6*6*6 desired colormap */
     maplen = 216;
@@ -1045,14 +1045,14 @@
 	  bmap[i] = (b*255)/5;
 	}
   }
-  
+
   else {   /* desMode == STD_332 */
     maplen = 256;
     for (i=0; i<maplen; i++) {
       rmap[i] = stdr[i];  gmap[i] = stdg[i];  bmap[i] = stdb[i];
     }
   }
-  
+
 
   /* sort the colors according to the diversity algorithm... */
   diverseOrder(rmap,gmap,bmap,maplen,order);
@@ -1072,7 +1072,7 @@
       def.red   = rmap[order[i]] << 8;
       def.green = gmap[order[i]] << 8;
       def.blue  = bmap[order[i]] << 8;
-      
+
       def.flags = DoRed | DoGreen | DoBlue;
 
       if (xvAllocColor(theDisp, theCmap, &def)) {  /* success */
@@ -1090,34 +1090,34 @@
 
     if (numgot != maplen) {
       /* PHASE 2:  find 'close' colors in colormap, try to alloc those */
-      
+
       /* read entire colormap (or first 256 entries) into 'ctab' */
       dc = (ncells<256) ? ncells : 256;
       if (dc>0) {
 	for (i=0; i<dc; i++) ctab[i].pixel = (unsigned long) i;
 	XQueryColors(theDisp, theCmap, ctab, dc);
-	
+
 	for (i=0; i<maplen; i++) {
 	  if (failed[i]) {
-	    
+
 	    /* find closest color in colormap, and try to alloc it */
 	    mind = 1000000;   /* greater than 3 * (256^2) */
 	    for (j=0,num = -1; j<dc; j++) {
 	      rd = rmap[i] - (ctab[j].red  >>8);
 	      gd = gmap[i] - (ctab[j].green>>8);
 	      bd = bmap[i] - (ctab[j].blue >>8);
-	      
+
 	      d = CDIST(rd, gd, bd);
 	      if (d<mind) { mind = d;  num = j; }
 	    }
-	    
+
 	    if (num < 0) screwed = 1;
 	    else if (xvAllocColor(theDisp, theCmap, &ctab[num])) {  /*success*/
 	      des2got[i] = i;
 	      descols[i] = ctab[num].pixel;
 	      failed[i]  = 0;
-	      nearCnt++; 
-	      /* for (j=0; j<stdnfcols && stdfreecols[j]!=ctab[num].pixel; 
+	      nearCnt++;
+	      /* for (j=0; j<stdnfcols && stdfreecols[j]!=ctab[num].pixel;
 		 j++); */
 	      stdfreecols[stdnfcols++] = ctab[num].pixel;
 	    }
@@ -1125,12 +1125,12 @@
 	}
       }
     }
-      
-    /* PHASE 3:  map remaining unallocated colors into closest we got */  
-    
+
+    /* PHASE 3:  map remaining unallocated colors into closest we got */
+
     for (i=0; i<maplen; i++) {
       if (failed[i]) {
-	
+
 	/* find closest alloc'd color */
 	mind = 1000000;   /* greater than 3 * (256^2) */
 	for (j=0,num=0; j<maplen; j++) {
@@ -1139,7 +1139,7 @@
 	    if (d<mind) { mind = d;  num = j; }
 	  }
 	}
-	
+
 	if (failed[num]) screwed = 1;
 	else {
 	  descols[i] = descols[num];
@@ -1151,8 +1151,8 @@
   }
 
 
-  /* at this point, we have 'descols', a maplen long array of 
-     X pixel values that maps 1/1/1, 2/2/2, 6*6*6, or 3/3/2 values 
+  /* at this point, we have 'descols', a maplen long array of
+     X pixel values that maps 1/1/1, 2/2/2, 6*6*6, or 3/3/2 values
      into an X pixel value */
 
   /* build stdcols and stdrdisp,stdgdisp,stdbdisp colormap */
@@ -1170,7 +1170,7 @@
 
 	  stdcols[i332] = descols[des2got[i111]];
 	}
-  } 
+  }
 
   else if (desMode == STD_222) {
     for (r=0; r<8; r++)
@@ -1186,7 +1186,7 @@
 
 	  stdcols[i332] = descols[des2got[i222]];
 	}
-  } 
+  }
 
   else if (desMode == STD_232) {
     for (r=0; r<8; r++)
@@ -1201,7 +1201,7 @@
 	  stdbdisp[i332] = bmap[des2got[i232]];
 	  stdcols[i332]  = descols[des2got[i232]];
 	}
-  } 
+  }
 
   else if (desMode == STD_666) {
     for (r=0,i=0; r<8; r++)
@@ -1221,7 +1221,7 @@
 
 	  stdcols[i]  = descols[des2got[i666]];
 	}
-  } 
+  }
 
   else {  /* desMode == STD_332 */
     for (i=0; i<256; i++) {
@@ -1249,22 +1249,22 @@
   if (DEBUG > 1) {
     fprintf(stderr,"MakeStdCmaps:  ncols=%d  maplen=%d\n", ncols, maplen);
     fprintf(stderr,"  std*[]= ");
-    for (i=0; i<256; i++) 
+    for (i=0; i<256; i++)
       fprintf(stderr,"%02x,%02x,%02x  ",stdr[i],stdg[i],stdb[i]);
     fprintf(stderr,"\n\n");
 
     fprintf(stderr,"  disp[]= ");
-    for (i=0; i<256; i++) 
+    for (i=0; i<256; i++)
       fprintf(stderr,"%02x,%02x,%02x  ",stdrdisp[i],stdgdisp[i],stdbdisp[i]);
     fprintf(stderr,"\n\n");
 
     fprintf(stderr,"  stdcols[]= ");
-    for (i=0; i<256; i++) 
+    for (i=0; i<256; i++)
       fprintf(stderr,"%02lx ",stdcols[i]);
     fprintf(stderr,"\n\n");
 
     fprintf(stderr,"  stdfreecols[%d] = ", stdnfcols);
-    for (i=0; i<stdnfcols; i++) 
+    for (i=0; i<stdnfcols; i++)
       fprintf(stderr,"%02lx ",stdfreecols[i]);
     fprintf(stderr,"\n\n");
   }
@@ -1272,8 +1272,8 @@
   if (exactCnt == maplen)
     sprintf(stdCmapSuccess, "Got all %d colors.", exactCnt);
   else {
-    if (nearCnt>0) 
-      sprintf(stdCmapSuccess, "Got %d out of %d colors.  (%d close color%s)", 
+    if (nearCnt>0)
+      sprintf(stdCmapSuccess, "Got %d out of %d colors.  (%d close color%s)",
 	      exactCnt, maplen, nearCnt, (nearCnt>1) ? "s" : "");
     else
       sprintf(stdCmapSuccess, "Got %d out of %d colors.", exactCnt, maplen);
@@ -1292,11 +1292,11 @@
   /* This function should only be called once, at the start of the program.
    *
    * produces many things:
-   *   browR,browG,browB[256] 
+   *   browR,browG,browB[256]
    *                       - a 3/3/2 colormap used by genIcon
    *   browcols[256]       - maps 3/3/2 values into X colors
    *   browCmap            - local cmap used in browse window, if browPerfect
-   */       
+   */
 
   int    i,j,r,g,b, screwed, num, exactCnt, nearCnt;
   XColor def;
@@ -1306,8 +1306,8 @@
   long   d, mind;
 
 
-  if (DEBUG) 
-    fprintf(stderr,"MakeBrowCmap:  perfect = %d, ncols = %d\n", 
+  if (DEBUG)
+    fprintf(stderr,"MakeBrowCmap:  perfect = %d, ncols = %d\n",
 	    browPerfect, ncols);
 
   if (ncols == 0 || !CMAPVIS(theVisual)) browPerfect = 0;
@@ -1350,7 +1350,7 @@
     def.red   = rmap[order[i]] << 8;
     def.green = gmap[order[i]] << 8;
     def.blue  = bmap[order[i]] << 8;
-      
+
     def.flags = DoRed | DoGreen | DoBlue;
 
     if (xvAllocColor(theDisp, browCmap, &def)) {  /* success */
@@ -1358,14 +1358,14 @@
       descols[order[i]] = def.pixel;
 
       if (DEBUG>1)
-	fprintf(stderr,"makebrowcmap: Phase 1: Alloc %x,%x,%x succeeded!\n", 
+	fprintf(stderr,"makebrowcmap: Phase 1: Alloc %x,%x,%x succeeded!\n",
 		rmap[order[i]], gmap[order[i]], bmap[order[i]]);
     }
     else failed[order[i]] = 1;
   }
 
-    
-  /* PHASE 2:  map remaining unallocated colors into closest we got */  
+
+  /* PHASE 2:  map remaining unallocated colors into closest we got */
 
   for (i=0; i<256; i++) {
     if (failed[i]) {
@@ -1377,9 +1377,9 @@
 	  if (d<mind) { mind = d;  num = j; }
 	}
       }
-	  
+
       if (DEBUG>1)
-	fprintf(stderr,"makebrowcmap: closest to %x,%x,%x = %x,%x,%x\n", 
+	fprintf(stderr,"makebrowcmap: closest to %x,%x,%x = %x,%x,%x\n",
 		rmap[i],gmap[i],bmap[i], rmap[num], gmap[num], bmap[num]);
 
       if (failed[num]) screwed = 1;
@@ -1406,7 +1406,7 @@
      byte *rmap, *gmap, *bmap, *order;
      int   maplen;
 {
-  /* takes a colormap (maxlen 256) and produces an order array that 
+  /* takes a colormap (maxlen 256) and produces an order array that
      contains the most-diverse order for allocating these colors */
 
   int dist[256], i, pick, maxv, ocnt, d;
@@ -1422,7 +1422,7 @@
 
   ocnt = 0;
   order[ocnt++] = pick;
-  
+
   /* init dist[] array */
   for (i=0; i<maplen; i++) dist[i] = 1000000;
 
@@ -1509,14 +1509,14 @@
   else if (cmode == CM_NORMAL) {
     if (novbrowse || browPerfect || haveStdCmap != iconCmapSize)
       freeStdCmaps();
-    
+
     /* if using browser, and killed stdcmap, make icon stdcmap */
     if (!novbrowse && !browPerfect && haveStdCmap == STD_NONE) {
       if (MakeStdCmaps() && anyBrowUp && CMAPVIS(theVisual))
 	RegenBrowseIcons();
     }
   }
-  
+
   else if (cmode == CM_PERFECT) { }
   else if (cmode == CM_OWNCMAP) { }
 
@@ -1540,7 +1540,7 @@
     SetEpicMode();
     if (genepic) GenerateEpic(eWIDE, eHIGH);
   }
-  else { 
+  else {
     if (oldmode == CM_STDCMAP && cmode != CM_STDCMAP && epicMode != EM_RAW) {
       /* just left STDCMAP mode.  Switch to using 'RAW' */
       epicMode = EM_RAW;
diff -ruN xv-3.10a/xvctrl.c xv-3.10a-bugfixes/xvctrl.c
--- xv-3.10a/xvctrl.c	1994-12-22 14:34:41.000000000 -0800
+++ xv-3.10a-bugfixes/xvctrl.c	2004-05-23 11:56:37.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * xvctrl.c - Control box handling functions
  *
  * callable functions:
@@ -9,7 +9,7 @@
  *   RedrawCtrl(x,y,w,h)    -  called by 'expose' events
  *   ClickCtrl(x,y)
  *   DrawCtrlStr()          -  called to redraw 'ISTR_INFO' string in ctrlW
- *   ScrollToCurrent()      -  called when list selection is changed 
+ *   ScrollToCurrent()      -  called when list selection is changed
  *
  *   LSCreate()             -  creates a listbox
  *   LSRedraw()             -  redraws 'namelist' box
@@ -49,7 +49,10 @@
 #include "bits/uicon"
 #include "bits/oicon1"
 #include "bits/oicon2"
-#include "bits/icon"
+#ifdef REGSTR
+#  define OMIT_ICON_BITS
+#  include "bits/icon"
+#endif
 
 #define CTRLWIDE 440               /* (fixed) size of control window */
 #define CTRLHIGH 348 /* 379 */
@@ -80,7 +83,7 @@
    in xv.h */
 
 
-static char *dispMList[] = { "Raw\tr", 
+static char *dispMList[] = { "Raw\tr",
 			     "Dithered\td",
 			     "Smooth\ts",
 			     MBSEP,
@@ -91,7 +94,7 @@
 			     "Use Own Colormap",
 			     "Use Std. Colormap" };
 
-static char *rootMList[] = { "Window", 
+static char *rootMList[] = { "Window",
 			     "Root: tiled",
 			     "Root: integer tiled",
 			     "Root: mirrored",
@@ -159,12 +162,12 @@
 void CreateCtrl(geom)
      char *geom;
 {
-  int i, listh, topskip;
+  int listh, topskip;
   double skip;
   XSetWindowAttributes xswa;
   Pixmap oicon1Pix, oicon2Pix;
 
-  ctrlW = CreateWindow("xv controls", "XVcontrols", geom, 
+  ctrlW = CreateWindow("xv controls", "XVcontrols", geom,
 		       CTRLWIDE, CTRLHIGH, infofg, infobg, 0);
   if (!ctrlW) FatalError("can't create controls window!");
 
@@ -205,10 +208,10 @@
   oicon2Pix = MakePix1(ctrlW, oicon2_bits,  oicon2_width,  oicon2_height);
 
   if (!grayTile  || !dimStip  || !fifoPix   || !chrPix    || !dirPix    ||
-      !blkPix    || !lnkPix   || !regPix    || !rotlPix   || !fliphPix  || 
+      !blkPix    || !lnkPix   || !regPix    || !rotlPix   || !fliphPix  ||
       !flipvPix  || !p10Pix   || !m10Pix    || !cutPix    || !copyPix   ||
       !pastePix  || !clearPix || !uiconPix  || !oiconPix  || !oicon1Pix ||
-      !oicon2Pix || !padPix   || !annotPix) 
+      !oicon2Pix || !padPix   || !annotPix)
     FatalError("unable to create all pixmaps in CreateCtrl()\n");
 
 
@@ -226,7 +229,7 @@
   XFreePixmap(theDisp, oicon1Pix);
   XFreePixmap(theDisp, oicon2Pix);
 
-  
+
 
   if (ctrlColor) XSetWindowBackground(theDisp, ctrlW, locol);
             else XSetWindowBackgroundPixmap(theDisp, ctrlW, grayTile);
@@ -234,7 +237,7 @@
   listh = LINEHIGH * NLINES;
 
   LSCreate(&nList, ctrlW, 5, 52, (CTRLWIDE-BUTTW-18),
-	   LINEHIGH*NLINES, NLINES, dispnames, numnames, 
+	   LINEHIGH*NLINES, NLINES, dispnames, numnames,
 	   infofg, infobg, hicol, locol, RedrawNList, 0, 0);
   nList.selected = 0;  /* default to first name selected */
 
@@ -245,8 +248,8 @@
 
   topskip = nList.y;
   skip =  ((double) (nList.h - (CHIGH+5))) / 6.0;
-  if (skip > SBUTTH+8) {  
-    skip = SBUTTH + 7;  
+  if (skip > SBUTTH+8) {
+    skip = SBUTTH + 7;
     topskip = nList.y + (nList.h - (6*skip + (CHIGH+5))) / 2;
   }
 
@@ -258,7 +261,7 @@
 #define R_BY3 (topskip + (int)(3*skip))
 #define R_BY4 (topskip + (int)(4*skip))
 #define R_BY5 (topskip + (int)(5*skip))
-  
+
   BTCreate(&but[BNEXT],    ctrlW, R_BX0, R_BY0, R_BW1, SBUTTH, "Next",   BCLS);
   BTCreate(&but[BPREV],    ctrlW, R_BX0, R_BY1, R_BW1, SBUTTH, "Prev",   BCLS);
   BTCreate(&but[BLOAD],    ctrlW, R_BX0, R_BY2, R_BW1, SBUTTH, "Load",   BCLS);
@@ -309,7 +312,7 @@
   BTCreate(&but[BABOUT],  ctrlW,BX4,  BY1,BUTTW,BUTTH,"About XV",BCLS);
   BTCreate(&but[BQUIT],   ctrlW,BX5,  BY1,BUTTW,BUTTH,"Quit",    BCLS);
 
-  BTCreate(&but[BXV],     ctrlW,5,5, 100, (u_int) nList.y - 5 - 2 - 5, 
+  BTCreate(&but[BXV],     ctrlW,5,5, 100, (u_int) nList.y - 5 - 2 - 5,
 	   "", BCLS);
 
   SetButtPix(&but[BCOPY],  copyPix,  copy_width,   copy_height);
@@ -329,7 +332,7 @@
   if (ctrlColor) {
     SetButtPix(&but[BXV], oiconPix, oicon1_width,  oicon1_height);
     but[BXV].colorpix = 1;
-  } 
+  }
   else SetButtPix(&but[BXV], iconPix, icon_width,  icon_height);
 #else
   SetButtPix(&but[BXV], uiconPix, uicon_width,  uicon_height);
@@ -338,21 +341,21 @@
   XMapSubwindows(theDisp, ctrlW);
 
 
-  /* have to create menu buttons after XMapSubWindows, as we *don't* want 
+  /* have to create menu buttons after XMapSubWindows, as we *don't* want
      the popup menus mapped */
 
-  MBCreate(&dispMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+2), 5,112,19, 
+  MBCreate(&dispMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+2), 5,112,19,
 	   "Display",    dispMList,   DMB_MAX,    BCLS);
-  MBCreate(&conv24MB, ctrlW, CTRLWIDE - 8 - 112 - (112+2),   5,112,19, 
+  MBCreate(&conv24MB, ctrlW, CTRLWIDE - 8 - 112 - (112+2),   5,112,19,
 	   "24/8 Bit",   conv24MList, CONV24_MAX, BCLS);
-  MBCreate(&algMB,    ctrlW, CTRLWIDE - 8 - 112,             5,112,19, 
+  MBCreate(&algMB,    ctrlW, CTRLWIDE - 8 - 112,             5,112,19,
 	   "Algorithms", algMList,    ALG_MAX,    BCLS);
 
-  MBCreate(&rootMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+2), 5+21,112,19, 
+  MBCreate(&rootMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+2), 5+21,112,19,
 	   "Root",       rootMList,   RMB_MAX,    BCLS);
-  MBCreate(&windowMB, ctrlW, CTRLWIDE - 8 - 112 - (112+2),   5+21,112,19, 
+  MBCreate(&windowMB, ctrlW, CTRLWIDE - 8 - 112 - (112+2),   5+21,112,19,
 	   "Windows",    windowMList, WMB_MAX,    BCLS);
-  MBCreate(&sizeMB,   ctrlW, CTRLWIDE - 8 - 112,             5+21,112,19, 
+  MBCreate(&sizeMB,   ctrlW, CTRLWIDE - 8 - 112,             5+21,112,19,
 	   "Image Size", sizeMList,   SZMB_MAX,   BCLS);
 
 
@@ -395,7 +398,7 @@
      byte *bits;
      int   w,h;
 {
-  return XCreatePixmapFromBitmapData(theDisp, win, (char *) bits, 
+  return XCreatePixmapFromBitmapData(theDisp, win, (char *) bits,
 				     (u_int) w, (u_int) h, 1L,0L,1);
 }
 
@@ -404,7 +407,7 @@
 void CtrlBox(vis)
 int vis;
 {
-  if (vis) XMapRaised(theDisp, ctrlW);  
+  if (vis) XMapRaised(theDisp, ctrlW);
   else     XUnmapWindow(theDisp, ctrlW);
 
   ctrlUp = vis;
@@ -416,7 +419,6 @@
 int x,y,w,h;
 {
   int i;
-  XRectangle xr;
 
   RANGE(w, 0, CTRLWIDE);
   RANGE(h, 0, CTRLHIGH);
@@ -452,7 +454,7 @@
 /***************************************************/
 void DrawCtrlNumFiles()
 {
-  int x,y,w,h;
+  int x,y,w;
   char foo[40];
 
   x  = but[BNEXT].x;
@@ -463,14 +465,14 @@
   XSetBackground(theDisp, theGC, infobg);
 
   sprintf(foo, "%d file%s", numnames, (numnames==1) ? "" : "s");
-    
+
   XSetForeground(theDisp, theGC, infobg);
   XFillRectangle(theDisp,ctrlW, theGC, x+1,y+1, (u_int) w-1, (u_int) CHIGH+5);
 
   XSetForeground(theDisp,theGC,infofg);
   XDrawRectangle(theDisp,ctrlW, theGC, x,y,     (u_int) w,   (u_int) CHIGH+6);
 
-  Draw3dRect(ctrlW, x+1,y+1,                    (u_int) w-2, (u_int) CHIGH+4, 
+  Draw3dRect(ctrlW, x+1,y+1,                    (u_int) w-2, (u_int) CHIGH+4,
 	     R3D_IN, 2, hicol, locol, infobg);
 
   XSetForeground(theDisp,theGC,infofg);
@@ -489,7 +491,7 @@
   st1 = GetISTR(ISTR_WARNING);
 
   XSetForeground(theDisp, theGC, infobg);
-  XFillRectangle(theDisp, ctrlW, theGC, 0, y+1, 
+  XFillRectangle(theDisp, ctrlW, theGC, 0, y+1,
 		 CTRLWIDE, (u_int)((CHIGH+4)*2+1));
 
   XSetForeground(theDisp, theGC, infofg);
@@ -501,7 +503,7 @@
     XSetForeground(theDisp, theGC, locol);
     XDrawLine(theDisp, ctrlW, theGC, 0, y+1,   CTRLWIDE, y+1);
     XDrawLine(theDisp, ctrlW, theGC, 0, y+CHIGH+5, CTRLWIDE, y+CHIGH+5);
-    XDrawLine(theDisp, ctrlW, theGC, 0, y+(CHIGH+4)*2+1, 
+    XDrawLine(theDisp, ctrlW, theGC, 0, y+(CHIGH+4)*2+1,
 	      CTRLWIDE, y+(CHIGH+4)*2+1);
   }
 
@@ -542,16 +544,16 @@
 void ScrollToCurrent(lst)
 LIST *lst;
 {
-  /* called when selected item on list is changed.  Makes the selected 
+  /* called when selected item on list is changed.  Makes the selected
      item visible.  If it already is, nothing happens.  Otherwise, it
-     attempts to scroll so that the selection appears in the middle of 
+     attempts to scroll so that the selection appears in the middle of
      the list window */
 
   int halfway;
 
   if (lst->selected < 0) return;  /* no selection, do nothing */
 
-  if (lst->selected > lst->scrl.val && 
+  if (lst->selected > lst->scrl.val &&
       lst->selected <  lst->scrl.val + lst->nlines-1) LSRedraw(lst, 0);
   else {
     halfway = (lst->nlines)/2;   /* offset to the halfway pt. of the list */
@@ -590,7 +592,7 @@
   lp->win = XCreateSimpleWindow(theDisp,win,x,y,(u_int) w, (u_int) h,1,fg,bg);
   if (!lp->win) FatalError("can't create list window!");
 
-  lp->x = x;    lp->y = y;   
+  lp->x = x;    lp->y = y;
   lp->w = w;    lp->h = h;
   lp->fg = fg;  lp->bg = bg;
   lp->hi = hi;  lp->lo = lo;
@@ -603,7 +605,7 @@
 
   XSelectInput(theDisp, lp->win, ExposureMask | ButtonPressMask);
 
-  SCCreate(&lp->scrl, lp->win, w-20, -1, 1, h, 0, 
+  SCCreate(&lp->scrl, lp->win, w-20, -1, 1, h, 0,
 	   nstr-nlines, 0, nlines-1, fg, bg, hi, lo, fptr);
 
   XMapSubwindows(theDisp, lp->win);
@@ -646,7 +648,7 @@
 LIST *lp;
 {
   /* redraws lists 3d-effect, which can be trounced by drawSel() */
-  Draw3dRect(lp->win, 0, 0, lp->w-1, lp->h-1, R3D_IN, 2, 
+  Draw3dRect(lp->win, 0, 0, lp->w-1, lp->h-1, R3D_IN, 2,
 	     lp->hi, lp->lo, lp->bg);
 }
 
@@ -675,43 +677,43 @@
   else { fg = lp->fg;  bg = lp->bg; }
 
   XSetForeground(theDisp, theGC, bg);
-  XFillRectangle(theDisp, lp->win, theGC, x0, y0+i*LINEHIGH, 
+  XFillRectangle(theDisp, lp->win, theGC, x0, y0+i*LINEHIGH,
 		 (u_int) wide+1, (u_int) LINEHIGH);
 
   if (j>=0 && j<lp->nstr) {   /* only draw string if valid */
     XSetForeground(theDisp, theGC, fg);
     XSetBackground(theDisp, theGC, bg);
 
-    if (!lp->filetypes) 
+    if (!lp->filetypes)
       DrawString(lp->win, x0+3, y0+i*LINEHIGH + ASCENT + 1, lp->str[j]);
     else {
       int ypos = y0 + i*LINEHIGH + (LINEHIGH - i_fifo_height)/2;
 
-      if (lp->str[j][0] == C_FIFO) 
+      if (lp->str[j][0] == C_FIFO)
 	XCopyPlane(theDisp, fifoPix, lp->win, theGC, 0, 0,
 		   i_fifo_width, i_fifo_height, x0+3, ypos, 1L);
 
-      else if (lp->str[j][0] == C_CHR) 
+      else if (lp->str[j][0] == C_CHR)
 	XCopyPlane(theDisp, chrPix, lp->win, theGC, 0, 0,
 		   i_chr_width, i_chr_height, x0+3, ypos, 1L);
 
-      else if (lp->str[j][0] == C_DIR) 
+      else if (lp->str[j][0] == C_DIR)
 	XCopyPlane(theDisp, dirPix, lp->win, theGC, 0, 0,
 		   i_dir_width, i_dir_height, x0+3, ypos, 1L);
 
-      else if (lp->str[j][0] == C_BLK) 
+      else if (lp->str[j][0] == C_BLK)
 	XCopyPlane(theDisp, blkPix, lp->win, theGC, 0, 0,
 		   i_blk_width, i_blk_height, x0+3, ypos, 1L);
 
-      else if (lp->str[j][0] == C_LNK) 
+      else if (lp->str[j][0] == C_LNK)
 	XCopyPlane(theDisp, lnkPix, lp->win, theGC, 0, 0,
 		   i_lnk_width, i_lnk_height, x0+3, ypos, 1L);
 
-      else if (lp->str[j][0] == C_SOCK) 
+      else if (lp->str[j][0] == C_SOCK)
 	XCopyPlane(theDisp, sockPix, lp->win, theGC, 0, 0,
 		   i_sock_width, i_sock_height, x0+3, ypos, 1L);
 
-      else if (lp->str[j][0] == C_EXE) 
+      else if (lp->str[j][0] == C_EXE)
 	XCopyPlane(theDisp, exePix, lp->win, theGC, 0, 0,
 		   i_exe_width, i_exe_height, x0+3, ypos, 1L);
 
@@ -720,8 +722,8 @@
 		   i_reg_width, i_reg_height, x0+3, ypos, 1L);
 
 
-      DrawString(lp->win, x0+3 + i_fifo_width + 3, 
-		  y0+i*LINEHIGH + ASCENT + 1, 
+      DrawString(lp->win, x0+3 + i_fifo_width + 3,
+		  y0+i*LINEHIGH + ASCENT + 1,
 		  lp->str[j]+1);
     }
   }
@@ -735,7 +737,7 @@
 {
   int  i;
 
-  for (i = lp->scrl.val; i < lp->scrl.val + lp->nlines; i++) 
+  for (i = lp->scrl.val; i < lp->scrl.val + lp->nlines; i++)
     drawSel(lp,i);
   ls3d(lp);
 }
@@ -762,7 +764,7 @@
   if (sel >= lp->nstr) sel = lp->selected;
 
   /* see if it's a double click */
-  if (ev->time - lasttime < DBLCLKTIME && sel==lastsel 
+  if (ev->time - lasttime < DBLCLKTIME && sel==lastsel
       && (lp->scrl.val + (y-y0)/LINEHIGH) < lp->nstr
       && !INACTIVE(lp,sel)) {
     return (sel);
@@ -782,7 +784,7 @@
   while (XQueryPointer(theDisp,lp->win,&rW,&cW,&rx,&ry,&x,&y,&mask)) {
     if (!(mask & Button1Mask)) break;    /* button released */
 
-    if (y<y0) { /* scroll up in list */ 
+    if (y<y0) { /* scroll up in list */
       if (lp->scrl.val > lp->scrl.min) {
 	lp->selected = lp->scrl.val - 1;
 	SCSetVal(&lp->scrl, lp->scrl.val - 1);
@@ -804,7 +806,7 @@
       if (sel >= lp->nstr) sel = lp->nstr - 1;
 
       if (sel != lp->selected && sel >= lp->scrl.val &&
-	  sel < lp->scrl.val + lp->nlines) {  
+	  sel < lp->scrl.val + lp->nlines) {
 	/* dragged to another on current page */
 	oldsel = lp->selected;
 	lp->selected = sel;
@@ -829,17 +831,17 @@
   else if (key==LS_PAGEDOWN) SCSetVal(&lp->scrl,lp->scrl.val + (lp->nlines-1));
   else if (key==LS_HOME)     SCSetVal(&lp->scrl,lp->scrl.min);
   else if (key==LS_END)      SCSetVal(&lp->scrl,lp->scrl.max);
-  
+
   else if (key==LS_LINEUP)   {
     /* if the selected item visible, but not the top line */
-    if (lp->selected > lp->scrl.val && 
+    if (lp->selected > lp->scrl.val &&
 	lp->selected <= lp->scrl.val + lp->nlines - 1) {
       /* then just move it */
       lp->selected--;
       drawSel(lp, lp->selected);  drawSel(lp, lp->selected+1);
       ls3d(lp);
     }
-    
+
     /* if it's the top line... */
     else if (lp->selected == lp->scrl.val) {
       if (lp->selected > 0) {
@@ -847,7 +849,7 @@
 	SCSetVal(&lp->scrl, lp->selected);
       }
     }
-    
+
     /* if it's not visible, put it on the bottom line */
     else {
       lp->selected = lp->scrl.val + lp->nlines - 1;
@@ -856,10 +858,10 @@
       ls3d(lp);
     }
   }
-  
+
   else if (key==LS_LINEDOWN)   {
     /* if the selected item visible, but not the bottom line */
-    if (lp->selected >= lp->scrl.val && 
+    if (lp->selected >= lp->scrl.val &&
 	lp->selected < lp->scrl.val + lp->nlines - 1) {
       if (lp->selected < lp->nstr-1) {
 	/* then just move it */
@@ -868,7 +870,7 @@
 	ls3d(lp);
       }
     }
-    
+
     /* if it's the bottom line... */
     else if (lp->selected == lp->scrl.val + lp->nlines - 1) {
       if (lp->selected < lp->nstr-1) {
@@ -876,7 +878,7 @@
 	SCSetVal(&lp->scrl, lp->scrl.val+1);
       }
     }
-    
+
     /* if it's not visible, put it on the top line */
     else {
       lp->selected = lp->scrl.val;
diff -ruN xv-3.10a/xvcut.c xv-3.10a-bugfixes/xvcut.c
--- xv-3.10a/xvcut.c	1995-01-13 11:55:48.000000000 -0800
+++ xv-3.10a-bugfixes/xvcut.c	2004-05-16 18:01:43.000000000 -0700
@@ -15,7 +15,7 @@
  *      static void  clearSelectedArea();
  *      static void  makeClipFName    ();
  *      static int   countcols24      (byte *, int,int, int,int,int,int));
- *      static int   countNewCols     (byte*, int, int, byte*, int, 
+ *      static int   countNewCols     (byte*, int, int, byte*, int,
  *                                     int, int, int, int);
  *
  *             void  InitSelection  ();
@@ -72,7 +72,7 @@
 static void clearSelectedArea  PARM((void));
 static void makeClipFName      PARM((void));
 static int  countcols24        PARM((byte *, int, int, int, int, int, int));
-static int  countNewCols       PARM((byte *, int, int, byte *, int, 
+static int  countNewCols       PARM((byte *, int, int, byte *, int,
 				     int, int, int, int));
 static int  dragHandle         PARM((XButtonEvent *));
 static void dragSelection      PARM((XButtonEvent *, u_int, int));
@@ -210,7 +210,7 @@
   if (!PasteAllowed()) { XBell(theDisp, 0);  return; }
 
   cimg = getFromClip();
-  if (!cimg) return;  
+  if (!cimg) return;
 
   /* if there's no selection, make one! */
   if (!HaveSelection()) makePasteSel(cimg);
@@ -231,7 +231,7 @@
 
   byte *dp, *dpic, *clippic, *clipcmap;
   int   clipw, cliph, clipis24, len, istran, trval;
-  int   i, j, sx,sy,sw,sh, cx,cy,cw,ch, dx,dy,dw,dh,dx2,dy2;
+  int   i, j, sx,sy,sw,sh, cx,cy,cw,ch, dx,dy,dw,dh;
 
 
   /*
@@ -245,7 +245,7 @@
 	((int) (cimg[CIMG_LEN + 2]<<16)) |
 	((int) (cimg[CIMG_LEN + 3]<<24));
 
-  if (len < CIMG_PIC24) return;        
+  if (len < CIMG_PIC24) return;
 
   istran    = cimg[CIMG_TRANS];
   trval     = cimg[CIMG_TRVAL];
@@ -268,7 +268,7 @@
    * already, because if we *are*, we'd prefer to do any clipboard rescaling
    * in 24-bit space for the obvious reasons.
    *
-   * possibilities:  
+   * possibilities:
    *   PIC24  -  easy, do clipboard rescale in 24-bit space
    *   PIC8, and clipboard is 8 bits, (or 24-bits, but with <=256 colors)
    *      and total unique colors < 256:
@@ -283,7 +283,7 @@
 
   /* dx,dy,dw,dh is the rectangle (in PIC coords) where the paste will occur
      (cropped to be entirely within PIC */
-  
+
   dx = sx;  dy = sy;  dw = sw;  dh = sh;
   CropRect2Rect(&dx, &dy, &dw, &dh, 0, 0, pWIDE, pHIGH);
 
@@ -291,7 +291,7 @@
   /* cx,cy,cw,ch is the rectangle of the clipboard data (in clipboard coords)
      that will actually be used in the paste operation */
 
-  cx = (sx>=0) ? 0 : ((-sx) * clipw) / sw;  
+  cx = (sx>=0) ? 0 : ((-sx) * clipw) / sw;
   cy = (sy>=0) ? 0 : ((-sy) * cliph) / sh;
   cw = (dw * clipw) / sw;
   ch = (dh * cliph) / sh;
@@ -302,26 +302,26 @@
   if (picType == PIC8) {
     int ncc, keep8;
     char buf[512];
-    
+
     if (clipis24) { /* pasting in a 24-bit image that *requires* promotion */
       static char *bnames[] = { "\nOkay", "\033Cancel" };
       strcpy(buf, "Warning:  Pasting this 24-bit image will require ");
       strcat(buf, "promoting the current image to 24 bits.");
-      
+
       if (PopUp(buf, bnames, 2)) goto exit;   /* Cancelled */
       else Change824Mode(PIC24);              /* promote pic to 24 bits */
     }
 
     else {   /* clip is 8 bits */
       ncc = countNewCols(clippic,clipw,cliph,clipcmap,clipis24,cx,cy,cw,ch);
-      
+
       if (ncc + numcols > 256) {
 	static char *bnames[] = { "\nPromote", "8Keep 8-bit", "\033Cancel" };
 	strcpy(buf,"Warning:  The image and the clipboard combine to have ");
 	strcat(buf,"more than 256 unique colors.  Promoting the ");
 	strcat(buf,"image to 24 bits is recommended, otherwise the contents ");
 	strcat(buf,"of the clipboard will probably lose some colors.");
-	
+
 	keep8 = PopUp(buf, bnames, 3);
 	if      (keep8==2) goto exit;              /* Cancel */
 	else if (keep8==0) Change824Mode(PIC24);   /* promote pic to 24 bits */
@@ -331,8 +331,8 @@
 
 
 
-  
-  
+
+
   /* legal possibilities at this point:
    *   pic is PIC24:  clip is 8 or 24
    *   pic is PIC8:   clip is 8, or clip is 24 but has 256 or fewer colors
@@ -342,18 +342,18 @@
 
   if (picType == PIC8) {
     int   clx, cly, r,g,b,k,mind,close,newcols;
-    byte *cp, *clp, *pp, *ccp, newr[256], newg[256], newb[256], remap[256];
+    byte *cp, *clp, *pp, newr[256], newg[256], newb[256], remap[256];
     byte  order[256], trans[256];
     int   bperpix, dpncols;
-    
+
     dpic = (byte *) malloc((size_t) dw * dh);
     if (!dpic) FatalError("Out of memory in DoImgPaste()\n");
-    
+
     bperpix = (clipis24) ? 3 : 1;
     newcols = 0;
-    
+
     /* dpic = a scaled, 8-bit representation of clippic[cx,cy,cw,ch] */
-    
+
     if (!clipis24) {   /* copy colormap from clip data into newr,g,b[] */
       for (i=0; i<256; i++) {
 	newr[i] = clipcmap[i*3];
@@ -366,22 +366,22 @@
       dp = dpic + i*dw;
       cly = cy + (i * ch) / dh;
       clp = clippic + (cly*clipw * bperpix);
-      
+
       for (j=0; j<dw; j++, dp++) {
 	/* get appropriate pixel from clippic */
 	clx = cx + (j * cw) / dw;
 	cp = clp + (clx * bperpix);
-	
+
 	if (!clipis24) *dp = *cp;
 	else {                            /* build colormap as we go... */
 	  r = *cp++;  g = *cp++;  b = *cp++;
-	  
+
 	  /* look it up in new colormap, add if not there */
 	  for (k=0; k<newcols && (r!=newr[k] || g!=newg[k] ||b!=newb[k]); k++);
 	  if (k==newcols && k<256) {
 	    newr[k]=r;  newg[k]=g;  newb[k]=b;  newcols++;
 	  }
-	  
+
 	  *dp = (byte) (k & 0xff);
 	}
       }
@@ -401,23 +401,23 @@
 	}
       }
     }
-    
-    
-    
+
+
+
     /* COLORMAP MERGING */
-    
+
     newcols = 0;
-    
+
     for (i=0; i<dpncols; i++) {
       if (istran && i==trval) continue;
-      
+
       for (j=0; j<numcols; j++) {              /* look for an exact match */
 	if (rMap[j]==newr[i] && gMap[j]==newg[i] && bMap[j]==newb[i]) break;
       }
       if (j<numcols) remap[i] = j;
       else {                                   /* no exact match */
 	newcols++;
-	
+
 	if (numcols < 256) {
 	  rMap[numcols] = newr[i];
 	  gMap[numcols] = newg[i];
@@ -429,7 +429,7 @@
 	  r = newr[i];  g=newg[i];  b=newb[i];
 	  mind = 256*256 + 256*256 + 256*256;
 	  for (j=close=0; j<numcols; j++) {
-	    k = ((rMap[j]-r) * (rMap[j]-r)) + 
+	    k = ((rMap[j]-r) * (rMap[j]-r)) +
 	      ((gMap[j]-g) * (gMap[j]-g)) +
 		((bMap[j]-b) * (bMap[j]-b));
 	    if (k<mind) { mind = k;  close = j; }
@@ -438,10 +438,10 @@
 	}
       }
     }
-    
-    
+
+
     /* copy the data into PIC */
-    
+
     dp = dpic;
     for (i=dy; i<dy+dh; i++) {
       pp = pic + (i*pWIDE) + dx;
@@ -451,7 +451,7 @@
       }
     }
     free(dpic);
-    
+
     if (newcols) InstallNewPic();      /* does color reallocation, etc. */
     else {
       GenerateCpic();
@@ -459,16 +459,16 @@
       DrawEpic();
     }
   }
-  
+
 
   /******************** PIC24 handling **********************/
-  
-  
+
+
   else {
     byte *tmppic, *cp, *pp, *clp;
     int   bperpix;
     int   trr, trg, trb, clx, cly;
-    
+
     trr = trg = trb = 0;
     if (istran) {
       if (clipis24) {
@@ -482,24 +482,24 @@
 	trb = clipcmap[trval*3+2];
       }
     }
-    
+
     bperpix = (clipis24) ? 3 : 1;
 
     if (!istran && (cw != dw || ch != dh)) {  /* need to resize, can smooth */
       byte rmap[256], gmap[256], bmap[256];
-      
+
       tmppic = (byte *) malloc((size_t) cw * ch * bperpix);
       if (!tmppic) FatalError("Out of memory in DoImgPaste()\n");
-      
-      /* copy relevant hunk of clippic into tmppic (Smooth24 only works on 
+
+      /* copy relevant hunk of clippic into tmppic (Smooth24 only works on
 	 complete images */
-      
+
       for (i=0; i<ch; i++) {
 	dp = tmppic + i*cw*bperpix;
 	cp = clippic + ((i+cy)*clipw + cx) * bperpix;
 	for (j=0; j<cw*bperpix; j++) *dp++ = *cp++;
       }
-      
+
       if (!clipis24) {
 	for (i=0; i<256; i++) {
 	  rmap[i] = clipcmap[i*3];
@@ -507,15 +507,15 @@
 	  bmap[i] = clipcmap[i*3+2];
 	}
       }
-      
+
       dpic = Smooth24(tmppic, clipis24, cw,ch, dw,dh, rmap,gmap,bmap);
       if (!dpic) FatalError("Out of memory (2) in DoImgPaste()\n");
       free(tmppic);
-      
+
       /* copy the resized, smoothed, 24-bit data into 'pic' */
-      
+
       /* XXX: (deal with smooth-resized transparent imgs) */
-      
+
       dp = dpic;
       for (i=dy; i<dy+dh; i++) {
 	pp = pic + (i*pWIDE + dx) * 3;
@@ -536,11 +536,11 @@
 	pp = pic + ((i+dy)*pWIDE + dx) * 3;
 	cly = cy + (i * ch) / dh;
 	clp = clippic + (cly*clipw * bperpix);
-	
+
 	for (j=0; j<dw; j++, pp+=3) {
 	  clx = cx + (j * cw) / dw;
 	  cp = clp + (clx * bperpix);
-	  
+
 	  if (clipis24) {
 	    if (!istran || cp[0]!=trr || cp[1]!=trg || cp[2]==trb) {
 	      pp[0] = *cp++;  pp[1] = *cp++;  pp[2] = *cp++;
@@ -557,14 +557,14 @@
       }
     }
 
-    
+
     GenerateCpic();
     GenerateEpic(eWIDE, eHIGH);
     DrawEpic();
   }
-  
-    
- exit:  
+
+
+ exit:
   SetCursors(-1);
 }
 
@@ -577,20 +577,20 @@
   XColor cfg, cbg;
 
   dragcurs = XCreateFontCursor(theDisp, XC_fleur);
-  p1 = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) cut_bits, 
+  p1 = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) cut_bits,
 				   cut_width,  cut_height, 1L, 0L, 1);
-  p2 = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) cutm_bits, 
+  p2 = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) cutm_bits,
 				   cutm_width, cutm_height, 1L, 0L, 1);
-  p3 = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) copy_bits, 
+  p3 = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) copy_bits,
 				   copy_width,  copy_height, 1L, 0L, 1);
-  p4 = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) copym_bits, 
+  p4 = XCreatePixmapFromBitmapData(theDisp, rootW, (char *) copym_bits,
 				   copym_width, copym_height, 1L, 0L, 1);
   if (p1 && p2 && p3 && p4) {
     cfg.red = cfg.green = cfg.blue = 0;
     cbg.red = cbg.green = cbg.blue = 0xffff;
-    cutcurs = XCreatePixmapCursor(theDisp, p1,p2, &cfg, &cbg, 
+    cutcurs = XCreatePixmapCursor(theDisp, p1,p2, &cfg, &cbg,
 				  cut_x_hot, cut_y_hot);
-    copycurs = XCreatePixmapCursor(theDisp, p3,p4, &cfg, &cbg, 
+    copycurs = XCreatePixmapCursor(theDisp, p3,p4, &cfg, &cbg,
 				  copy_x_hot, copy_y_hot);
     if (!cutcurs || !copycurs) FatalError("can't create cut/copy cursors...");
   }
@@ -619,7 +619,7 @@
 
   if (!CutAllowed()) {  XBell(theDisp, 0);  return (byte *) NULL; }
   if (!HaveSelection()) return (byte *) NULL;
-  
+
   GetSelRCoords(&x,&y,&w,&h);
   CropRect2Rect(&x,&y,&w,&h, 0,0,pWIDE,pHIGH);
 
@@ -663,15 +663,15 @@
   if (picType == PIC24 && !do24) {                  /* 24-bit data as 8-bit */
     int nc,pr,pg,pb;
     byte *cm;
-    
+
     nc = 0;
     dp = cimg + CIMG_PIC8;
-    
+
     for (i=y; i<y+h; i++) {
       pp = pic + i*pWIDE*3 + x*3;
       for (j=x; j<x+w; j++, pp+=3) {
 	pr = pp[0];  pg = pp[1];  pb = pp[2];
-	
+
 	cm = cimg + CIMG_CMAP;
 	for (k=0; k<nc; k++,cm+=3) {
 	  if (pr==cm[0] && pg==cm[1] && pb==cm[2]) break;
@@ -682,12 +682,12 @@
 	  cimg[CIMG_CMAP + nc*3 + 1] = pg;
 	  cimg[CIMG_CMAP + nc*3 + 2] = pb;
 	}
-	
+
 	*dp++ = (byte) k;
       }
     }
   }
-  
+
 
   else if (picType == PIC24) {                     /* 24-bit data as 24-bit */
     dp = cimg + CIMG_PIC24;
@@ -705,26 +705,26 @@
   else if (picType == PIC8) {                       /* 8-bit selection */
     byte *cm = cimg + CIMG_CMAP;
     for (i=0; i<256; i++) {                         /* copy colormap */
-      if (i<numcols) { 
+      if (i<numcols) {
 	*cm++ = rMap[i];
 	*cm++ = gMap[i];
 	*cm++ = bMap[i];
       }
     }
-    
+
     dp = cimg + CIMG_PIC8;
     for (i=y; i<y+h; i++) {                         /* copy image */
       pp = pic + i*pWIDE + x;
       for (j=x; j<x+w; j++) *dp++ = *pp++;
     }
   }
-    
+
   return cimg;
 }
 
 
 
-  
+
 /********************************************/
 static byte *getFromClip()
 {
@@ -743,14 +743,14 @@
     clipAtom = XInternAtom(theDisp, CLIPPROP, True);
     if (clipAtom != None) XDeleteProperty(theDisp, rootW, clipAtom);
   }
-  
-  
+
+
   clipAtom = XInternAtom(theDisp, CLIPPROP, True);             /* find prop */
   if (clipAtom != None) {
 
     /* try to retrieve the length of the data in the property */
-    i = XGetWindowProperty(theDisp, rootW, clipAtom, 0L, 1L, False, XA_STRING, 
-		       &actType, &actFormat, &nitems, &nleft, 
+    i = XGetWindowProperty(theDisp, rootW, clipAtom, 0L, 1L, False, XA_STRING,
+		       &actType, &actFormat, &nitems, &nleft,
 		       (unsigned char **) &data);
 
     if (i==Success && actType==XA_STRING && actFormat==8 && nleft>0) {
@@ -763,9 +763,9 @@
       XFree((void *) data);
 
       /* read the rest of the data (len bytes) */
-      i = XGetWindowProperty(theDisp, rootW, clipAtom, 1L, 
-			     (long) ((len-4)+3)/4, 
-			     False, XA_STRING, &actType, &actFormat, &nitems, 
+      i = XGetWindowProperty(theDisp, rootW, clipAtom, 1L,
+			     (long) ((len-4)+3)/4,
+			     False, XA_STRING, &actType, &actFormat, &nitems,
 			     &nleft, (unsigned char **) &data);
 
       if (i==Success) {
@@ -791,8 +791,8 @@
     }
   }
 
-  
-  /* if we're still here, then the prop method was less than successful. 
+
+  /* if we're still here, then the prop method was less than successful.
      use the file method, instead */
 
   if (!clipfname) makeClipFName();
@@ -800,7 +800,7 @@
   fp = fopen(clipfname, "r");
   if (!fp) {
     unlink(clipfname);
-    sprintf(str, "Can't read clipboard file '%s'\n\n  %s.", 
+    sprintf(str, "Can't read clipboard file '%s'\n\n  %s.",
 	    clipfname, ERRSTR(errno));
     ErrPopUp(str,"\nBletch!");
     return (byte *) NULL;
@@ -877,19 +877,19 @@
     clipAtom = XInternAtom(theDisp, CLIPPROP, True);
     if (clipAtom != None) XDeleteProperty(theDisp, rootW, clipAtom);
   }
-  
-  
+
+
   if (!forceClipFile) {
     clipAtom = XInternAtom(theDisp, CLIPPROP, False);  /* find or make prop */
     if (clipAtom != None) {
       /* try to store the data in the property */
-      
+
       xerrcode = 0;
       XChangeProperty(theDisp, rootW, clipAtom, XA_STRING, 8, PropModeReplace,
 		      cimg, len);
       XSync(theDisp, False);                         /* make it happen *now* */
       if (!xerrcode) return;                         /* success! */
-      
+
       /* failed, use file method */
       XDeleteProperty(theDisp, rootW, clipAtom);
     }
@@ -903,7 +903,7 @@
   fp = fopen(clipfname, "w");
   if (!fp) {
     unlink(clipfname);
-    sprintf(str, "Can't write clipboard file '%s'\n\n  %s.", 
+    sprintf(str, "Can't write clipboard file '%s'\n\n  %s.",
 	    clipfname, ERRSTR(errno));
     ErrPopUp(str,"\nBletch!");
     return;
@@ -996,7 +996,7 @@
   byte *pp;
 
   nc = 0;
-  
+
   for (i=y; nc<257 && i<y+h; i++) {
     pp = pic + i*pwide*3 + x*3;
     for (j=x; nc<257 && j<x+w; j++, pp+=3) {
@@ -1022,7 +1022,7 @@
    */
 
   int   i, j, k, nc, r,g,b;
-  byte *pp, *cp;
+  byte *pp;
   byte  newr[257], newg[257], newb[257];
 
   if (picType != PIC8) return 0;           /* shouldn't happen */
@@ -1034,7 +1034,7 @@
       pp = newpic + i*w*3 + cx*3;
       for (j=cx; j<cx+cw; j++) {
 	r = *pp++;  g = *pp++;  b = *pp++;
-	
+
 	/* lookup r,g,b in 'pic's colormap and the newcolors colormap */
 	for (k=0; k<nc && (r!=newr[k] || g!=newg[k] || b!=newb[k]); k++);
 	if (k==nc) {
@@ -1062,11 +1062,11 @@
     /* now see which of the used colors are new */
     for (i=0, nc=0; i<256; i++) {
       if (!coluse[i]) continue;
-      
-      r = newcmap[i*3];  
-      g = newcmap[i*3+1];  
+
+      r = newcmap[i*3];
+      g = newcmap[i*3+1];
       b = newcmap[i*3+2];
-      
+
       /* lookup r,g,b in pic's colormap */
       for (k=0; k<numcols && (r!=rMap[k] || g!=gMap[k] || b!=bMap[k]);k++);
       if (k==numcols) {  /* it's a new color, alright */
@@ -1075,7 +1075,7 @@
       }
     }
   }
-  
+
   return nc;
 }
 
@@ -1143,7 +1143,7 @@
   /* NOTE:  SELECTION IS *NOT* GUARANTEED to be within the bounds of 'pic'.
      It is only guaranteed to *intersect* pic. */
 
-  *xp = selrx;  *yp = selry;  
+  *xp = selrx;  *yp = selry;
   *wp = selrw;  *hp = selrh;
 }
 
@@ -1200,7 +1200,7 @@
     if (lastClickButton==Button1 && (ev->time - lastClickTime) < DBLCLKTIME) {
       lastClickButton=Button3;
       if (HaveSelection() && PTINRECT(px, py, selrx, selry, selrw, selrh)) {
-	EnableSelection(0); 
+	EnableSelection(0);
 	rv = 1;
       }
       else {
@@ -1225,7 +1225,7 @@
   else if (ev->button == Button2) {      /* do a drag & drop operation */
     if (HaveSelection() && PTINRECT(px,py,selrx,selry,selrw,selrh)) {
       /* clip selection rect to pic */
-      EnableSelection(0);  
+      EnableSelection(0);
       CropRect2Rect(&selrx, &selry, &selrw, &selrh, 0, 0, pWIDE, pHIGH);
 
       if (selrw<1 || selrh<1) rv = 0;
@@ -1253,8 +1253,8 @@
    * holding SHIFT constrains selection to be square,
    * holding CTRL  constrains selection to keep original aspect ratio
    */
-  
-  int          i, mex, mey, mpx, mpy, offx,offy;
+
+  int          mex, mey, mpx, mpy, offx,offy;
   int          sex, sey, sex2, sey2, sew, seh, sew2, seh2, hs, h2;
   int          istp, isbt, islf, isrt, isvm, ishm;
   int          cnstsq, cnstasp;
@@ -1272,7 +1272,7 @@
   sew2 = sew/2;
   seh2 = seh/2;
   sex2--;  sey2--;
-  
+
   if      (sew>=35 && seh>=35) hs=7;
   else if (sew>=20 && seh>=20) hs=5;
   else if (sew>= 9 && seh>= 9) hs=3;
@@ -1307,7 +1307,7 @@
 
 
   /* it's definitely in a handle...  track 'til released */
-  
+
   DrawSelection(0);
   selFilled   = 1;
   selTracking = 1;
@@ -1366,12 +1366,12 @@
                        else { chwide=1;  newwide = (int) (seh*orgaspect); }
 	}
       }
-      
+
       if (chwide) {
 	if (islf) { sex = (sex+sew) - newwide; }
 	sew = newwide;
       }
-      
+
       if (chhigh) {
 	if (istp) { sey = (sey+seh) - newhigh; }
 	seh = newhigh;
@@ -1380,7 +1380,7 @@
 
     if (sew<1) sew=1;
     if (seh<1) seh=1;
-    
+
     if (sex!=selrx || sey!=selry || sew!=selrw || seh!=selrh) {
       DrawSelection(0);
       selrx = sex;  selry = sey;  selrw = sew;  selrh = seh;
@@ -1395,14 +1395,14 @@
       Timer(100);
     }
   }
-  
+
   EnableSelection(0);
 
   selFilled   = 0;
   selTracking = 0;
 
   /* only 'enable' the selection if it intersects CPIC */
-  if (selrx < cXOFF+cWIDE && selrx+selrw > cXOFF && 
+  if (selrx < cXOFF+cWIDE && selrx+selrw > cXOFF &&
       selry < cYOFF+cHIGH && selry+selrh > cYOFF) EnableSelection(1);
 
   return 1;
@@ -1422,7 +1422,7 @@
    *
    * if 'dragndrop', changes cursor, monitors CTRL status
    */
-  
+
   int          mpx, mpy, offx, offy;
   int          newsx, newsy, orgsx, orgsy, cnstrain, docopy, lastdocopy;
   Window       rW, cW;
@@ -1436,9 +1436,9 @@
 
   CoordE2P(ev->x, ev->y, &mpx, &mpy);
   offx = mpx - selrx;  offy = mpy - selry;
-  
+
   /* track rectangle until we get a release */
-  
+
   DrawSelection(0);
   selFilled   = 1;
   selTracking = 1;
@@ -1467,7 +1467,7 @@
       dx = newsx - orgsx;  dy = newsy - orgsy;
       if      (abs(dx) > abs(dy)) dy = 0;
       else if (abs(dy) > abs(dx)) dx = 0;
-      
+
       newsx = orgsx + dx;  newsy = orgsy + dy;
     }
 
@@ -1485,7 +1485,7 @@
       Timer(100);
     }
   }
-  
+
   EnableSelection(0);
 
   selFilled   = 0;
@@ -1495,7 +1495,7 @@
 
   /* only do <whatever> if the selection intersects CPIC */
 
- if (selrx < cXOFF+cWIDE && selrx+selrw > cXOFF && 
+ if (selrx < cXOFF+cWIDE && selrx+selrw > cXOFF &&
       selry < cYOFF+cHIGH && selry+selrh > cYOFF) {
 
     EnableSelection(1);
@@ -1503,10 +1503,10 @@
     if (dragndrop) {
       int   tmpsx, tmpsy;
       byte *data;
-      
+
       tmpsx = selrx;  tmpsy = selry;
       selrx = orgsx;  selry = orgsy;
-      
+
       data = getSelection();         /* copy old data */
       if (data) {
 	if (!docopy) clearSelectedArea();
@@ -1531,29 +1531,29 @@
   int          rx,ry,ox,oy,x,y,active, x1, y1, x2, y2, cnstrain;
   int          i, px,py,px2,py2,pw,ph;
   unsigned int mask;
-  
+
   /* called on a B1 press in mainW to draw a new rectangular selection.
    * any former selection has already been removed.  holding shift down
-   * while tracking constrains selection to a square 
+   * while tracking constrains selection to a square
    */
-  
+
   active = 0;
-  
+
   x1 = ox = ev->x;  y1 = oy = ev->y;               /* nail down one corner */
   selrx = selry = selrw = selrh = 0;
   selTracking = 1;
-  
+
   while (1) {
     if (!XQueryPointer(theDisp,mainW,&rW,&cW,&rx,&ry,&x,&y,&mask)) continue;
     if (!(mask & Button1Mask)) break;      /* button released */
     cnstrain = (mask & ShiftMask);
-    
+
     if (x!=ox || y!=oy) {                  /* moved.  erase and redraw (?) */
       x2 = x;  y2 = y;
-      
+
       /* x1,y1,x2,y2 are in epic coords.  sort, convert to pic coords,
 	 and if changed, erase+redraw */
-      
+
       CoordE2P(x1, y1, &px,  &py);
       CoordE2P(x2, y2, &px2, &py2);
       if (px>px2) { i=px; px=px2; px2=i; }
@@ -1561,17 +1561,17 @@
       pw = px2-px+1;  ph=py2-py+1;
 
       /* keep px,py,pw,ph inside 'pic' */
-      
+
       if (px<0) { pw+=px;  px=0; }
       if (py<0) { ph+=py;  py=0; }
       if (px>pWIDE-1) px = pWIDE-1;
       if (py>pHIGH-1) py = pHIGH-1;
-      
+
       if (pw<0) pw=0;
       if (ph<0) ph=0;
       if (px+pw>pWIDE) pw = pWIDE - px;
       if (py+ph>pHIGH) ph = pHIGH - py;
-      
+
       if (cnstrain) {          /* make a square at smaller of w,h */
 	if      (ph>pw) { if (y2<y1) py += (ph-pw);  ph=pw; }
 	else if (pw>ph) { if (x2<x1) px += (pw-ph);  pw=ph; }
@@ -1579,12 +1579,12 @@
 
       /* put x,y,w,h -> selr{x,y,w,h}
 	 if the rectangle has changed, erase old and draw new */
-      
+
       if (px!=selrx || py!=selry || pw!=selrw || ph!=selrh) {
 	DrawSelection(0);
 	selrx = px;  selry = py;  selrw = pw;  selrh = ph;
 	DrawSelection(1);
-	
+
 	haveSel = active = (pw>0 && ph>0);
 	if (infoUp) SetSelectionString();
 	XFlush(theDisp);
@@ -1615,7 +1615,7 @@
      set, pick a new 'color' to invert the selection with */
 
   int   x,y,x1,y1,w,h;
-  
+
   if (newcol) selColor = (selColor+1) & 0x7;
 
   /* convert selr{x,y,w,h} into epic coords */
@@ -1650,7 +1650,7 @@
   if (y<0 && y+h>eHIGH && selFilled!=1)
     XDrawLine(theDisp, mainW, theGC, x, eHIGH/2, x+w, eHIGH/2);
 
-  
+
   if (selFilled==0 || selFilled == 1) {
     /* one little kludge:  if w or h == eWIDE or eHIGH, make it one smaller */
     if (x+w == eWIDE) w--;
@@ -1664,17 +1664,17 @@
       else if (w>=20 && h>=20) { hs=5;  h1=4; h2=2; }
       else if (w>= 9 && h>= 9) { hs=3;  h1=2; h2=1; }
       else hs=h1=h2=0;
-      
+
       if (hs) {
 	XFillRectangle(theDisp,mainW,theGC,x+1,     y+1,  (u_int)h1,(u_int)h1);
 	XFillRectangle(theDisp,mainW,theGC,x+w/2-h2,y+1,  (u_int)hs,(u_int)h1);
 	XFillRectangle(theDisp,mainW,theGC,x+w-h1,  y+1,  (u_int)h1,(u_int)h1);
-	
+
 	XFillRectangle(theDisp,mainW,theGC,x+1,   y+h/2-h2,
 		       (u_int)h1, (u_int)hs);
 	XFillRectangle(theDisp,mainW,theGC,x+w-h1,y+h/2-h2,
 		       (u_int)h1, (u_int)hs);
-	
+
 	XFillRectangle(theDisp,mainW,theGC,x+1,     y+h-h1,
 		       (u_int)h1,(u_int)h1);
 	XFillRectangle(theDisp,mainW,theGC,x+w/2-h2,y+h-h1,
@@ -1683,7 +1683,7 @@
 		       (u_int)h1,(u_int)h1);
       }
     }
-	
+
     if (selFilled==1) {
       XDrawLine(theDisp, mainW, theGC, x+1, y+1,   x+w-1, y+h-1);
       XDrawLine(theDisp, mainW, theGC, x+1, y+h-1, x+w-1, y+1);
@@ -1692,8 +1692,8 @@
   else if (selFilled==2) {
     XFillRectangle(theDisp, mainW, theGC, x,y,(u_int) w, (u_int) h);
   }
-  
-  
+
+
   XSetFunction(theDisp,theGC,GXcopy);
   XSetPlaneMask(theDisp, theGC, AllPlanes);
 }
@@ -1703,7 +1703,7 @@
 void MoveGrowSelection(dx,dy,dw,dh)
      int dx,dy,dw,dh;
 {
-  /* moves and/or grows the selection by the specified amount 
+  /* moves and/or grows the selection by the specified amount
      (in pic coords).  keeps the selection entirely within 'pic'.
      (called by 'CropKey()') */
 
@@ -1729,7 +1729,7 @@
   }
 }
 
-  
+
 /***********************************/
 void BlinkSelection(cnt)
      int cnt;
diff -ruN xv-3.10a/xvdflt.c xv-3.10a-bugfixes/xvdflt.c
--- xv-3.10a/xvdflt.c	1994-12-22 14:34:42.000000000 -0800
+++ xv-3.10a-bugfixes/xvdflt.c	2004-05-16 18:01:46.000000000 -0700
@@ -16,12 +16,12 @@
 #include "bits/xv_rev"
 #include "bits/xv_ver"
 #include "bits/xf_left"
-#include "bits/xf_right"
+/* #include "bits/xf_right"	not used */
 #include "bits/font5x9.h"
 
 
 #ifndef USEOLDPIC
-#  include "xvdflt.h"  
+#  include "xvdflt.h"
 #endif
 
 
@@ -100,21 +100,21 @@
   setcolor(pinfo, 252,   0,  0,  0);   /* black background for text */
 
 
-  xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
+  xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height,
 	   dfltpic, DWIDE, DHIGH, DWIDE/2+1, 203+1, 252);
-  xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
+  xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height,
 	   dfltpic, DWIDE, DHIGH, DWIDE/2,   203, 250);
 
   i = xv_ver_width + xv_rev_width + 30;
 
-  xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
+  xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height,
        dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2+1, 220+1,252);
-  xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
+  xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height,
        dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2+1, 220+1,252);
 
-  xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
+  xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height,
 	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 220, 250);
-  xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
+  xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height,
 	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 220, 250);
 
   strcpy(str,"Press <right> mouse button for menu.");
@@ -169,7 +169,7 @@
     for (i=k=0; i<DHIGH; i+=xf_left_height) {
       for (j=0; j<DWIDE; j+=xf_left_width) {
 	k++;
-	if (k&1) 
+	if (k&1)
 	  xbm2pic((byte *) xf_left_bits, xf_left_width, xf_left_height,
 		  dfltpic, DWIDE, DHIGH, j + xf_left_width/2,
 		  i + xf_left_height/2, 1);
@@ -179,29 +179,29 @@
 
 
 
-  xbm2pic((byte *) xvpic_logo_out_bits, xvpic_logo_out_width, 
+  xbm2pic((byte *) xvpic_logo_out_bits, xvpic_logo_out_width,
 	  xvpic_logo_out_height, dfltpic, DWIDE, DHIGH, DWIDE/2 + 10, 80, 103);
 
-  xbm2pic((byte *) xvpic_logo_top_bits, xvpic_logo_top_width, 
+  xbm2pic((byte *) xvpic_logo_top_bits, xvpic_logo_top_width,
 	  xvpic_logo_top_height, dfltpic, DWIDE, DHIGH, DWIDE/2 + 10, 80, 100);
 
-  xbm2pic((byte *) xvpic_logo_bot_bits, xvpic_logo_bot_width, 
+  xbm2pic((byte *) xvpic_logo_bot_bits, xvpic_logo_bot_width,
 	  xvpic_logo_bot_height, dfltpic, DWIDE, DHIGH, DWIDE/2 + 10, 80, 101);
 
 
 
-  xbm2pic((byte *) xv_jhb_bits, xv_jhb_width, xv_jhb_height, 
+  xbm2pic((byte *) xv_jhb_bits, xv_jhb_width, xv_jhb_height,
 	   dfltpic, DWIDE, DHIGH, DWIDE/2, 160, 102);
 
-  xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
+  xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height,
 	   dfltpic, DWIDE, DHIGH, DWIDE/2, 203, 102);
 
   i = xv_ver_width + xv_rev_width + 30;
 
-  xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
+  xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height,
 	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 220, 102);
 
-  xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
+  xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height,
 	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 220, 102);
 
   strcpy(str,"Press <right> mouse button for menu.");
@@ -281,7 +281,7 @@
       }
     }
   }
-}  
+}
 
 
 /*******************************************/
@@ -300,7 +300,7 @@
      byte    *dfltpic;
      PICINFO *pinfo;
 {
-  int i,j,k, dr, dg, db;
+  int i,j, dr, dg, db;
   byte *pp;
 
   pp = dfltpic;
@@ -357,7 +357,7 @@
 
   for ( ; *str; str++, cx+=6) {
     i = (byte) *str;
-    if (i >= 32 && i < 128) 
+    if (i >= 32 && i < 128)
       xbm2pic(font5x9[i - 32], 5, 9, pic, pw, ph, cx, cy, col);
   }
 }
diff -ruN xv-3.10a/xvdial.c xv-3.10a-bugfixes/xvdial.c
--- xv-3.10a/xvdial.c	1995-01-03 13:20:31.000000000 -0800
+++ xv-3.10a-bugfixes/xvdial.c	2004-05-16 18:01:57.000000000 -0700
@@ -1,11 +1,11 @@
-/* 
+/*
  * xvdial.c - DIAL handling functions
  *
  * callable functions:
  *
  *   DCreate()   -  creates a dial
  *   DSetRange() -  sets min/max/current values of control
- *   DSetVal()   -  sets value of control 
+ *   DSetVal()   -  sets value of control
  *   DSetActive() - turns dial '.active' on and off
  *   DRedraw()   -  redraws the dial
  *   DTrack()    -  called when clicked.  Operates control 'til mouseup
@@ -50,7 +50,7 @@
 
 
 /***************************************************/
-void DCreate(dp, parent, x, y, w, h, minv, maxv, curv, page, 
+void DCreate(dp, parent, x, y, w, h, minv, maxv, curv, page,
 	          fg, bg, hi, lo, title, units)
 DIAL         *dp;
 Window        parent;
@@ -60,13 +60,13 @@
 {
 
   if (!pixmaps_built) {
-    cw1Pix   = XCreatePixmapFromBitmapData(theDisp, parent, 
+    cw1Pix   = XCreatePixmapFromBitmapData(theDisp, parent,
 		(char *) dial_cw1_bits, PW, PH, fg, bg, dispDEEP);
-    ccw1Pix  = XCreatePixmapFromBitmapData(theDisp, parent, 
+    ccw1Pix  = XCreatePixmapFromBitmapData(theDisp, parent,
 	        (char *) dial_ccw1_bits, PW, PH, fg, bg, dispDEEP);
-    cw2Pix   = XCreatePixmapFromBitmapData(theDisp, parent, 
+    cw2Pix   = XCreatePixmapFromBitmapData(theDisp, parent,
                 (char *) dial_cw2_bits, PW, PH, fg, bg, dispDEEP);
-    ccw2Pix  = XCreatePixmapFromBitmapData(theDisp, parent, 
+    ccw2Pix  = XCreatePixmapFromBitmapData(theDisp, parent,
 	        (char *) dial_ccw2_bits, PW, PH, fg, bg, dispDEEP);
   }
 
@@ -126,14 +126,14 @@
   if (curv == dp->val) return;
 
   /* erase old arrow */
-  XSetForeground(theDisp, theGC, dp->bg); 
+  XSetForeground(theDisp, theGC, dp->bg);
   drawArrow(dp);
 
   dp->val = curv;
 
   /* draw new arrow and string */
   XSetForeground(theDisp, theGC, dp->fg);
-  XSetBackground(theDisp, theGC, dp->bg); 
+  XSetBackground(theDisp, theGC, dp->bg);
   drawArrow(dp);
   drawValStr(dp);
   if (!dp->active) dimDial(dp);
@@ -229,18 +229,18 @@
     case INCCW1: if (dp->val > dp->min) DSetVal(dp, dp->val-1); break;
     case INCCW2: if (dp->val > dp->min) DSetVal(dp, dp->val-dp->page); break;
     }
-    if (dp->drawobj != NULL) (dp->drawobj)();  
+    if (dp->drawobj != NULL) (dp->drawobj)();
     Timer(INC1WAIT);
     lit = 1;
   }
 
-  else { 
+  else {
     i = computeDialVal(dp, mx, my);
     DSetVal(dp, i);
-    if (dp->drawobj != NULL) (dp->drawobj)();  
+    if (dp->drawobj != NULL) (dp->drawobj)();
   }
 
-  
+
   /* loop until mouse is released */
   while (XQueryPointer(theDisp,dp->win,&rW,&cW,&rx,&ry,&x,&y,&mask)) {
     if (!(mask & Button1Mask)) break;    /* button released */
@@ -252,7 +252,7 @@
       DSetVal(dp, i);
       if (j != dp->val) {
 	/* track whatever dial controls */
-	if (dp->drawobj != NULL) (dp->drawobj)();  
+	if (dp->drawobj != NULL) (dp->drawobj)();
       }
     }
 
@@ -266,7 +266,7 @@
 
       if (lit) {
 	switch (ipos) {
-	case INCW1:  if (dp->val < dp->max) DSetVal(dp, dp->val+1); 
+	case INCW1:  if (dp->val < dp->max) DSetVal(dp, dp->val+1);
 	             break;
 	case INCW2:  if (dp->val < dp->max) DSetVal(dp, dp->val+dp->page);
                      break;
@@ -277,7 +277,7 @@
 	}
 
 	/* track whatever dial controls */
-	if (dp->drawobj != NULL) (dp->drawobj)();  
+	if (dp->drawobj != NULL) (dp->drawobj)();
 
 	Timer(INC2WAIT);
       }
@@ -305,17 +305,17 @@
 
   /* returns region * that x,y is in.  returns -1 if none */
 
-  for (i=0; i<4; i++) 
+  for (i=0; i<4; i++)
     if (PTINRECT(x,y, dp->bx[i], dp->by[i], 14, 10)) return i;
 
-  if (PTINRECT(x,y, dp->cx - dp->rad, dp->cy - dp->rad, 
+  if (PTINRECT(x,y, dp->cx - dp->rad, dp->cy - dp->rad,
 	       2*dp->rad, 2*dp->rad))
     return INDIAL;
 
   return -1;
 }
 
-	  
+
 /***************************************************/
 static void drawArrow(dp)
 DIAL *dp;
@@ -366,10 +366,10 @@
   XSetForeground(theDisp, theGC, dp->fg);
   XSetBackground(theDisp, theGC, dp->bg);
   XSetFont(theDisp, theGC, monofont);
-  XDrawImageString(theDisp, dp->win, theGC, 
+  XDrawImageString(theDisp, dp->win, theGC,
 		   dp->w/2 - XTextWidth(monofinfo, foo1, (int) strlen(foo1))/2,
 		   dp->h-14 - (monofinfo->ascent + monofinfo->descent)/2
-		                                 + monofinfo->ascent, 
+		                                 + monofinfo->ascent,
 		   foo1, (int) strlen(foo1));
   XSetFont(theDisp, theGC, mfont);
 }
@@ -431,7 +431,7 @@
   }
   else if (dx>0) angle = atan((double)  dy / (double)  dx) * RAD2DEG;
   else           angle = atan((double) -dy / (double) -dx) * RAD2DEG + 180.0;
-    
+
   /* map angle into range: -90..270, then into to value */
   if (angle > 270.0) angle -= 360.0;
   if (angle < -90.0) angle += 360.0;
diff -ruN xv-3.10a/xvdir.c xv-3.10a-bugfixes/xvdir.c
--- xv-3.10a/xvdir.c	1995-01-03 13:21:39.000000000 -0800
+++ xv-3.10a-bugfixes/xvdir.c	2005-03-20 18:38:30.000000000 -0800
@@ -1,4 +1,4 @@
-/* 
+/*
  * xvdir.c - Directory changin', file i/o dialog box
  *
  * callable functions:
@@ -50,7 +50,7 @@
 #define COLWIDE  150               /* width of colMB */
 
 /* NOTE: make sure these match up with F_* definitions in xv.h */
-static char *saveColors[] = { "Full Color", 
+static char *saveColors[] = { "Full Color",
 			      "Greyscale",
 			      "B/W Dithered",
 			      "Reduced Color" };
@@ -83,14 +83,16 @@
 static int  dnamcmp          PARM((const void *, const void *));
 static int  FNameCdable      PARM((void));
 static void loadCWD          PARM((void));
+#ifdef FOO
 static int  cd_able          PARM((char *));
+#endif
 static void scrollToFileName PARM((void));
 static void setFName         PARM((char *));
 static void showFName        PARM((void));
 static void changeSuffix     PARM((void));
 static int  autoComplete     PARM((void));
 
-static byte *handleBWandReduced   PARM((byte *, int,int,int, int, int *, 
+static byte *handleBWandReduced   PARM((byte *, int,int,int, int, int *,
 					byte **, byte **, byte **));
 static byte *handleNormSel        PARM((int *, int *, int *, int *));
 
@@ -119,7 +121,7 @@
 static char oldfname[MAXFNLEN+100];
 
 /* the name of the file actually opened.  (the temp file if we are piping) */
-static char outFName[256];  
+static char outFName[256];
 static int  dopipe;
 
 
@@ -127,48 +129,46 @@
 void CreateDirW(geom)
      char *geom;
 {
-  int w, y;
-  
   path[0] = '\0';
 
   xv_getwd(loadpath, sizeof(loadpath));
   xv_getwd(savepath, sizeof(savepath));
 
-  
+
   dirW = CreateWindow("","XVdir", geom, DIRWIDE, DIRHIGH, infofg, infobg, 0);
   if (!dirW) FatalError("couldn't create 'directory' window!");
 
-  LSCreate(&dList, dirW, 10, 5 + 3*(6+LINEHIGH) + 6, LISTWIDE, 
-	   LINEHIGH*NLINES, NLINES, fnames, numfnames, infofg, infobg, 
+  LSCreate(&dList, dirW, 10, 5 + 3*(6+LINEHIGH) + 6, LISTWIDE,
+	   LINEHIGH*NLINES, NLINES, fnames, numfnames, infofg, infobg,
 	   hicol, locol, RedrawDList, 1, 0);
 
-  dnamW = XCreateSimpleWindow(theDisp, dirW, 80, dList.y + (int) dList.h + 30, 
-			      (u_int) DNAMWIDE+6, (u_int) LINEHIGH+5, 
+  dnamW = XCreateSimpleWindow(theDisp, dirW, 80, dList.y + (int) dList.h + 30,
+			      (u_int) DNAMWIDE+6, (u_int) LINEHIGH+5,
 			      1, infofg, infobg);
   if (!dnamW) FatalError("can't create name window");
   XSelectInput(theDisp, dnamW, ExposureMask);
 
 
-  CBCreate(&browseCB,   dirW, DIRWIDE/2, dList.y + (int) dList.h + 6, 
+  CBCreate(&browseCB,   dirW, DIRWIDE/2, dList.y + (int) dList.h + 6,
 	   "Browse", infofg, infobg, hicol,locol);
 
-  CBCreate(&savenormCB, dirW, 220, dList.y + (int) dList.h + 6, 
+  CBCreate(&savenormCB, dirW, 220, dList.y + (int) dList.h + 6,
 	   "Normal Size", infofg, infobg,hicol,locol);
 
-  CBCreate(&saveselCB,  dirW, 80,        dList.y + (int) dList.h + 6, 
+  CBCreate(&saveselCB,  dirW, 80,        dList.y + (int) dList.h + 6,
            "Selected Area", infofg, infobg,hicol,locol);
 
 
   /* y-coordinates get filled in when window is opened */
-  BTCreate(&dbut[S_BOK],     dirW, 259, 0, 80, BUTTH, 
+  BTCreate(&dbut[S_BOK],     dirW, 259, 0, 80, BUTTH,
 	   "Ok",        infofg, infobg,hicol,locol);
-  BTCreate(&dbut[S_BCANC],   dirW, 259, 0, 80, BUTTH, 
+  BTCreate(&dbut[S_BCANC],   dirW, 259, 0, 80, BUTTH,
 	   "Cancel",    infofg,infobg,hicol,locol);
-  BTCreate(&dbut[S_BRESCAN], dirW, 259, 0, 80, BUTTH, 
+  BTCreate(&dbut[S_BRESCAN], dirW, 259, 0, 80, BUTTH,
 	   "Rescan",    infofg,infobg,hicol,locol);
-  BTCreate(&dbut[S_BOLDSET], dirW, 259, 0, 80, BUTTH, 
+  BTCreate(&dbut[S_BOLDSET], dirW, 259, 0, 80, BUTTH,
 	   "Prev Set",  infofg,infobg,hicol,locol);
-  BTCreate(&dbut[S_BOLDNAM], dirW, 259, 0, 80, BUTTH, 
+  BTCreate(&dbut[S_BOLDNAM], dirW, 259, 0, 80, BUTTH,
 	   "Prev Name", infofg,infobg,hicol,locol);
 
   SetDirFName("");
@@ -180,33 +180,33 @@
    * create MBUTTs *after* calling XMapSubWindows() to keep popup unmapped
    */
 
-  MBCreate(&dirMB, dirW, 50, dList.y -(LINEHIGH+6), 
+  MBCreate(&dirMB, dirW, 50, dList.y -(LINEHIGH+6),
 	   (u_int) DDWIDE, (u_int) LINEHIGH, NULL, NULL, 0,
 	   infofg,infobg,hicol,locol);
 
-  MBCreate(&fmtMB, dirW, DIRWIDE-FMTWIDE-10, 5,            
-	   (u_int) FMTWIDE, (u_int) LINEHIGH, NULL, saveFormats, F_MAXFMTS, 
+  MBCreate(&fmtMB, dirW, DIRWIDE-FMTWIDE-10, 5,
+	   (u_int) FMTWIDE, (u_int) LINEHIGH, NULL, saveFormats, F_MAXFMTS,
 	   infofg,infobg,hicol,locol);
   fmtMB.hascheck = 1;
   MBSelect(&fmtMB, 0);
 
-  MBCreate(&colMB, dirW, DIRWIDE-COLWIDE-10, 5+LINEHIGH+6, 
-	   (u_int) COLWIDE, (u_int) LINEHIGH, NULL, saveColors, F_MAXCOLORS, 
+  MBCreate(&colMB, dirW, DIRWIDE-COLWIDE-10, 5+LINEHIGH+6,
+	   (u_int) COLWIDE, (u_int) LINEHIGH, NULL, saveColors, F_MAXCOLORS,
 	   infofg,infobg,hicol,locol);
   colMB.hascheck = 1;
   MBSelect(&colMB, 0);
 
 
-  d_loadPix = XCreatePixmapFromBitmapData(theDisp, dirW, 
-                 (char *) d_load_bits, d_load_width, d_load_height, 
+  d_loadPix = XCreatePixmapFromBitmapData(theDisp, dirW,
+                 (char *) d_load_bits, d_load_width, d_load_height,
 					  infofg, infobg, dispDEEP);
 
-  d_savePix = XCreatePixmapFromBitmapData(theDisp, dirW, 
-                 (char *) d_save_bits, d_save_width, d_save_height, 
+  d_savePix = XCreatePixmapFromBitmapData(theDisp, dirW,
+                 (char *) d_save_bits, d_save_width, d_save_height,
 					  infofg, infobg, dispDEEP);
 
 }
-  
+
 
 /***************************************************/
 void DirBox(mode)
@@ -261,7 +261,7 @@
 
     BTSetActive(&dbut[S_BOLDSET], haveoldinfo);
     BTSetActive(&dbut[S_BOLDNAM], haveoldinfo);
-    
+
     CBSetActive(&saveselCB, HaveSelection());
 
     MBSetActive(&fmtMB, 1);
@@ -303,15 +303,15 @@
   if (gap>16) {
     gap = 16;
     top = dList.y + (dList.h - (nbts*BUTTH) - (ngaps*gap))/2;
-    
+
     for (i=0; i<nbts; i++) dbut[i].y = top + i*(BUTTH+gap);
   }
   else {
-    for (i=0; i<nbts; i++) 
+    for (i=0; i<nbts; i++)
       dbut[i].y = dList.y + ((dList.h-BUTTH)*i) / ngaps;
   }
 }
-    
+
 
 
 /***************************************************/
@@ -320,23 +320,22 @@
 {
   int        i, ypos, txtw;
   char       foo[30], *str;
-  XRectangle xr;
 
   if (dList.nstr==1) strcpy(foo,"1 file");
                 else sprintf(foo,"%d files",dList.nstr);
 
   ypos = dList.y + dList.h + 8 + ASCENT;
   XSetForeground(theDisp, theGC, infobg);
-  XFillRectangle(theDisp, dirW, theGC, 10, ypos-ASCENT, 
+  XFillRectangle(theDisp, dirW, theGC, 10, ypos-ASCENT,
 		 (u_int) DIRWIDE, (u_int) CHIGH);
   XSetForeground(theDisp, theGC, infofg);
   DrawString(dirW, 10, ypos, foo);
 
 
-  if (dirUp == BLOAD) str = "Load file:";  
+  if (dirUp == BLOAD) str = "Load file:";
                  else str = "Save file:";
   DrawString(dirW, 10, dList.y + (int) dList.h + 30 + 4 + ASCENT, str);
-  
+
   /* draw dividing line */
   XSetForeground(theDisp,    theGC, infofg);
   XDrawLine(theDisp, dirW,   theGC, 0, dirMB.y-6, DIRWIDE, dirMB.y-6);
@@ -346,11 +345,11 @@
     XSetForeground(theDisp,  theGC, hicol);
   }
   XDrawLine(theDisp, dirW,   theGC, 0, dirMB.y-4, DIRWIDE, dirMB.y-4);
-  
-  
-  
+
+
+
   for (i=0; i<(savemode ? S_NBUTTS : S_LOAD_NBUTTS); i++) BTRedraw(&dbut[i]);
-  
+
   MBRedraw(&dirMB);
   MBRedraw(&fmtMB);
   MBRedraw(&colMB);
@@ -362,7 +361,7 @@
   if (StringWidth(COLLABEL) > txtw) txtw = StringWidth(COLLABEL);
 
   if (!savemode) {
-    XCopyArea(theDisp, d_loadPix, dirW, theGC, 0,0,d_load_width,d_load_height, 
+    XCopyArea(theDisp, d_loadPix, dirW, theGC, 0,0,d_load_width,d_load_height,
 	      10, (dirMB.y-6)/2 - d_load_height/2);
 
     XSetFillStyle(theDisp, theGC, FillStippled);
@@ -399,18 +398,18 @@
     i = v = 0;
     if      (MBClick(&fmtMB, x,y) && (v=MBTrack(&fmtMB))>=0) i=1;
     else if (MBClick(&colMB, x,y) && (v=MBTrack(&colMB))>=0) i=2;
-    
+
     if (i) {  /* changed one of them */
       if (i==1) SetDirSaveMode(F_FORMAT, v);
            else SetDirSaveMode(F_COLORS, v);
       changeSuffix();
     }
   }
-  
-  
+
+
   if (!savemode) {  /* LOAD */
     if (CBClick(&browseCB,x,y)) CBTrack(&browseCB);
-  } 
+  }
   else {            /* SAVE */
     if      (CBClick(&savenormCB,x,y)) CBTrack(&savenormCB);
     else if (CBClick(&saveselCB,x,y))  CBTrack(&saveselCB);
@@ -482,7 +481,7 @@
       }
 
       if (oldnumnames != numnames) {  /* added some */
-	if (numnames>0) BTSetActive(&but[BDELETE],1); 
+	if (numnames>0) BTSetActive(&but[BDELETE],1);
 	windowMB.dim[WMB_TEXTVIEW] = (numnames==0);
 
 	LSNewData(&nList, dispnames, numnames);
@@ -564,7 +563,7 @@
      *  a special concealed device setup to provide a list of available
      *  disks).
      */
-    if ( ((ndirs-sel) == 2) && (strlen(tmppath) > 1) ) 
+    if ( ((ndirs-sel) == 2) && (strlen(tmppath) > 1) )
       strcat ( tmppath, "/000000" ); /* add root dir for device */
     else if  ((ndirs-sel) == 1 ) {
       strcpy ( tmppath, "/XV_Root_Device/000000" );  /* fake top level */
@@ -602,7 +601,7 @@
   xv_getwd(path, sizeof(path));
   LoadCurrentDirectory();
 }
-  
+
 
 
 /***************************************************/
@@ -621,7 +620,7 @@
 #else
   struct dirent *dp;
 #endif
-  
+
 
   /* get rid of previous file names */
   for (i=0; i<numfnames; i++) free(fnames[i]);
@@ -680,12 +679,12 @@
     strncpy(dirMBlist[j], dirs[i], stlen);
     dirMBlist[j][stlen] = '\0';
   }
-    
+
 
   lastdir = dirs[ndirs-1];
   dirMB.list = dirMBlist;
   dirMB.nlist = ndirs;
-  XClearArea(theDisp, dirMB.win, dirMB.x, dirMB.y, 
+  XClearArea(theDisp, dirMB.win, dirMB.x, dirMB.y,
 	     (u_int) dirMB.w+3, (u_int) dirMB.h+3, False);
   i = StringWidth(dirMBlist[0]) + 10;
   dirMB.x = dirMB.x + dirMB.w/2 - i/2;
@@ -704,8 +703,8 @@
 
   i=0;
   while ( (dp = readdir(dirp)) != NULL) {
-    if (strcmp(dp->d_name, ".")==0   || 
-	(strcmp(dp->d_name, "..")==0 && 
+    if (strcmp(dp->d_name, ".")==0   ||
+	(strcmp(dp->d_name, "..")==0 &&
 	 (strcmp(path,"/")==0 || strcmp(path,"//")==0)) ||
 	strcmp(dp->d_name, THUMBDIR)==0) {
       /* skip over '.' and '..' and THUMBDIR */
@@ -733,7 +732,7 @@
       /* For VMS we will default all files EXCEPT directories to avoid
 	 the high cost of the VAX C implementation of the stat function.
 	 Suggested by Kevin Oberman (OBERMAN@icdc.llnl.gov) */
- 
+
       if (xv_strstr (fnames[i]+1, ".DIR") != NULL) fnames[i][0] = C_DIR;
       if (xv_strstr (fnames[i]+1, ".EXE") != NULL) fnames[i][0] = C_EXE;
       if (xv_strstr (fnames[i]+1, ".OBJ") != NULL) fnames[i][0] = C_BLK;
@@ -784,11 +783,13 @@
 
 
 /***************************************************/
+#ifdef FOO
 static int cd_able(str)
 char *str;
 {
   return ((str[0] == C_DIR || str[0] == C_LNK));
 }
+#endif /* FOO */
 
 
 /***************************************************/
@@ -829,7 +830,7 @@
   int len;
 
   len = strlen(filename);
-  
+
   if (c>=' ' && c<'\177') {             /* printable characters */
     /* note: only allow 'piped commands' in savemode... */
 
@@ -918,19 +919,19 @@
 {
   /* called to 'auto complete' a filename being entered.  If the name that
      has been entered so far is anything but a simple filename (ie, has
-     spaces, pipe char, '/', etc) fails.  If it is a simple filename, 
+     spaces, pipe char, '/', etc) fails.  If it is a simple filename,
      looks through the name list to find something that matches what's already
      been typed.  If nothing matches, it fails.  If more than one thing
      matches, it sets the name to the longest string that the multiple
-     matches have in common, and succeeds (and beeps).  
+     matches have in common, and succeeds (and beeps).
      If only one matches, sets the string to the match and succeeds.
-     
+
      returns zero on failure, non-zero on success */
-  
+
   int i, firstmatch, slen, nummatch, cnt;
 
   /* is filename a simple filename? */
-  if (strlen(filename)==0  || 
+  if (strlen(filename)==0  ||
       ISPIPE(filename[0])  ||
       index(filename, '/') ||
       filename[0]=='~'   ) return 0;
@@ -946,7 +947,7 @@
   firstmatch = i;
 
   /* count # of matches */
-  for (i=firstmatch, nummatch=0; 
+  for (i=firstmatch, nummatch=0;
        i<dList.nstr && strncmp(filename, dList.str[i]+1, (size_t) slen)==0;
        i++, nummatch++);
 
@@ -960,14 +961,14 @@
   while (dList.str[firstmatch][slen+1]!='\0') {
     filename[slen] = dList.str[firstmatch][slen+1];
     slen++;  filename[slen] = '\0';
-    
+
     for (i=firstmatch, cnt=0;
 	 i<dList.nstr && strncmp(filename, dList.str[i]+1, (size_t) slen)==0;
 	 i++, cnt++);
 
     if (cnt != nummatch) {  slen--;  filename[slen] = '\0';  break; }
-  }  
-  
+  }
+
   XBell(theDisp, 0);
 
   return 1;
@@ -1003,7 +1004,7 @@
   i = pos - (NLINES/2);
   SCSetVal(&dList.scrl, i);
 }
-  
+
 
 /***************************************************/
 void RedrawDNamW()
@@ -1012,7 +1013,7 @@
 
   /* draw substring filename[stPos:enPos] and cursor */
 
-  Draw3dRect(dnamW, 0, 0, (u_int) DNAMWIDE+5, (u_int) LINEHIGH+4, R3D_IN, 2, 
+  Draw3dRect(dnamW, 0, 0, (u_int) DNAMWIDE+5, (u_int) LINEHIGH+4, R3D_IN, 2,
 	     hicol, locol, infobg);
 
   XSetForeground(theDisp, theGC, infofg);
@@ -1023,7 +1024,7 @@
     XDrawLine(theDisp, dnamW, theGC, 2,0,2,LINEHIGH+5);
   }
 
-  if ((size_t) enPos < strlen(filename)) { 
+  if ((size_t) enPos < strlen(filename)) {
     /* draw a "there's more over here" doowah */
     XDrawLine(theDisp, dnamW, theGC, DNAMWIDE+5,0,DNAMWIDE+5,LINEHIGH+5);
     XDrawLine(theDisp, dnamW, theGC, DNAMWIDE+4,0,DNAMWIDE+4,LINEHIGH+5);
@@ -1057,7 +1058,7 @@
   fmt = MBWhich(&fmtMB);
   col = MBWhich(&colMB);
 
-  if (fmt<0 || col<0) 
+  if (fmt<0 || col<0)
     FatalError("xv: no 'checked' format or color.  shouldn't happen!\n");
 
 
@@ -1068,19 +1069,19 @@
       dbut[S_BOK].lit = 0;  BTRedraw(&dbut[S_BOK]);
       return -1;
     }
-    
+
     for (i=0; i<numnames; i++) {
       if ((i&0x3f)==0) WaitCursor();
       if (namelist[i][0] != '/') fprintf(fp, "%s/%s\n", initdir, namelist[i]);
                             else fprintf(fp, "%s\n", namelist[i]);
     }
-    
+
     i = (ferror(fp)) ? 1 : 0;
     if (CloseOutFile(fp, fullname, i) == 0) {
       DirBox(0);
       XVCreatedFile(fullname);
     }
-    
+
     SetCursors(-1);
     dbut[S_BOK].lit = 0;  BTRedraw(&dbut[S_BOK]);
     return i;
@@ -1147,34 +1148,41 @@
     rv = WritePBM   (fp, thepic, ptype, w, h, rp,gp,bp, nc,col,1,picComments);
     break;
 
-  case F_PBMASCII: 
+  case F_PBMASCII:
     rv = WritePBM   (fp, thepic, ptype, w, h, rp,gp,bp, nc,col,0,picComments);
     break;
 
   case F_XBM:
-    rv = WriteXBM   (fp, thepic, w, h, rp, gp, bp, fullname);          break;
+    rv = WriteXBM   (fp, thepic, w, h, rp, gp, bp, fullname);
+    break;
 
   case F_SUNRAS:
-    rv = WriteSunRas(fp, thepic, ptype, w, h, rp, gp, bp, nc, col,0);  break;
+    rv = WriteSunRas(fp, thepic, ptype, w, h, rp, gp, bp, nc, col,0);
+    break;
 
   case F_BMP:
-    rv = WriteBMP   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col);    break;
+    rv = WriteBMP   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col);
+    break;
 
   case F_IRIS:
-    rv = WriteIRIS  (fp, thepic, ptype, w, h, rp, gp, bp, nc, col);    break;
-    
+    rv = WriteIRIS  (fp, thepic, ptype, w, h, rp, gp, bp, nc, col);
+    break;
+
   case F_TARGA:
-    rv = WriteTarga (fp, thepic, ptype, w, h, rp, gp, bp, nc, col);    break;
-    
+    rv = WriteTarga (fp, thepic, ptype, w, h, rp, gp, bp, nc, col);
+    break;
+
   case F_XPM:
-    rv = WriteXPM   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
-		     fullname, picComments);    
+    rv = WriteXPM   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col,
+		     fullname, picComments);
+    break;
+
   case F_FITS:
-    rv = WriteFITS  (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
-		     picComments);    
+    rv = WriteFITS  (fp, thepic, ptype, w, h, rp, gp, bp, nc, col,
+		     picComments);
     break;
   }
-  
+
 
   if (CloseOutFile(fp, fullname, rv) == 0) {
     DirBox(0);
@@ -1184,12 +1192,12 @@
     }
   }
 
-  
+
   if (pfree) free(thepic);
-  
+
   SetCursors(-1);
   dbut[S_BOK].lit = 0;  BTRedraw(&dbut[S_BOK]);
-  
+
   return rv;
 }
 
@@ -1200,6 +1208,7 @@
      char *st;
 {
   strncpy(deffname, st, (size_t) MAXFNLEN-1);
+  deffname[MAXFNLEN-1] = '\0';
   setFName(st);
 }
 
@@ -1212,7 +1221,7 @@
   filename[MAXFNLEN-1] = '\0';  /* make sure it's terminated */
   curPos = strlen(st);
   stPos = 0;  enPos = curPos;
-  
+
   showFName();
 }
 
@@ -1221,17 +1230,17 @@
 static void showFName()
 {
   int len;
-  
+
   len = strlen(filename);
-  
+
   if (curPos<stPos) stPos = curPos;
   if (curPos>enPos) enPos = curPos;
-  
+
   if (stPos>len) stPos = (len>0) ? len-1 : 0;
   if (enPos>len) enPos = (len>0) ? len-1 : 0;
-  
+
   /* while substring is shorter than window, inc enPos */
-  
+
   while (XTextWidth(mfinfo, &filename[stPos], enPos-stPos) < DNAMWIDE
 	 && enPos<len) { enPos++; }
 
@@ -1244,7 +1253,7 @@
   }
 
 
-  if (ctrlColor) XClearArea(theDisp, dnamW, 2,2, (u_int) DNAMWIDE+5-3, 
+  if (ctrlColor) XClearArea(theDisp, dnamW, 2,2, (u_int) DNAMWIDE+5-3,
 			    (u_int) LINEHIGH+4-3, False);
   else XClearWindow(theDisp, dnamW);
 
@@ -1270,7 +1279,7 @@
   else {
     strcpy(globname, filename);
     if (globname[0] == '~') Globify(globname);
-    
+
     if (globname[0] != '/') sprintf(fullname, "%s%s", path, globname);
     else strcpy(fullname, globname);
   }
@@ -1294,10 +1303,10 @@
 	MBRedraw(&fmtMB);
       }
     }
-    
+
     if (bnum>=0) MBSelect(&colMB, bnum);
   }
-  
+
 
   else if (group == F_FORMAT) {
     MBSelect(&fmtMB, bnum);
@@ -1322,10 +1331,10 @@
       colMB.dim[F_GREYSCALE] = 0;
       colMB.dim[F_BWDITHER]  = 0;
       colMB.dim[F_REDUCED]   = (picType==PIC8) ? 0 : 1;
-      if (picType!=PIC8 && MBWhich(&colMB)==F_REDUCED) 
+      if (picType!=PIC8 && MBWhich(&colMB)==F_REDUCED)
 	MBSelect(&colMB, F_FULLCOLOR);
     }
-    
+
     if (MBWhich(&fmtMB) == F_FILELIST) {
       MBSetActive(&colMB,      0);
       CBSetActive(&savenormCB, 0);
@@ -1337,12 +1346,12 @@
   }
 }
 
-  
+
 
 /***************************************/
 static void changeSuffix()
 {
-  /* see if there's a common suffix at the end of the filename.  
+  /* see if there's a common suffix at the end of the filename.
      if there is, remember what case it was (all caps or all lower), lop
      it off, and replace it with a new appropriate suffix, in the
      same case */
@@ -1356,7 +1365,7 @@
   suffix++;  /* point to first letter of the suffix */
 
   /* check for all-caposity */
-  for (sp = suffix, allcaps=1; *sp; sp++) 
+  for (sp = suffix, allcaps=1; *sp; sp++)
     if (islower(*sp)) allcaps = 0;
 
   /* copy the suffix into an all-lower-case buffer */
@@ -1401,7 +1410,7 @@
     case F_GIF:      strcpy(lowsuf,"gif");  break;
     case F_PM:       strcpy(lowsuf,"pm");   break;
     case F_PBMRAW:
-    case F_PBMASCII: if (col == F_FULLCOLOR || col == F_REDUCED) 
+    case F_PBMASCII: if (col == F_FULLCOLOR || col == F_REDUCED)
                                                   strcpy(lowsuf,"ppm");
                      else if (col == F_GREYSCALE) strcpy(lowsuf,"pgm");
                      else if (col == F_BWDITHER)  strcpy(lowsuf,"pbm");
@@ -1426,10 +1435,10 @@
     }
 
     if (allcaps) {  /* upper-caseify lowsuf */
-      for (sp=lowsuf; *sp; sp++) 
+      for (sp=lowsuf; *sp; sp++)
 	*sp = (islower(*sp)) ? toupper(*sp) : *sp;
     }
-    
+
     /* one other case:  if the original suffix started with a single
        capital letter, make the new suffix start with a single cap */
     if (isupper(suffix[0])) lowsuf[0] = toupper(lowsuf[0]);
@@ -1439,7 +1448,7 @@
   }
 
 }
-  
+
 
 /***************************************************/
 int DirCheckCD()
@@ -1462,7 +1471,7 @@
 static int FNameCdable()
 {
   /* returns '1' if filename is a directory, and goes there */
-  
+
   char newpath[1024];
   struct stat st;
   int retval = 0;
@@ -1518,7 +1527,7 @@
       retval = 1;
     }
   }
-  
+
   return retval;
 }
 
@@ -1550,7 +1559,7 @@
 
   if (*uname=='\0') { /* no name.  substitute ~ with $HOME */
     char *homedir;
-    homedir = (char *) getenv("HOME");  
+    homedir = (char *) getenv("HOME");
     if (homedir == NULL) homedir = ".";
     strcpy(tmp,homedir);
     strcat(tmp,sp);
@@ -1579,7 +1588,7 @@
   /* opens file for output.  does various error handling bits.  Returns
      an open file pointer if success, NULL if failure */
 
-  FILE *fp;
+  FILE *fp = NULL;
   struct stat st;
 
   if (!filename || filename[0] == '\0') return NULL;
@@ -1596,23 +1605,34 @@
 #else
     strcpy(outFName, "[]xvXXXXXX.lis");
 #endif
+#ifdef USE_MKSTEMP
+    fp = fdopen(mkstemp(outFName), "w");
+#else
     mktemp(outFName);
+#endif
     dopipe = 1;
   }
 
 
-  /* see if file exists (ie, we're overwriting) */
-  if (stat(outFName, &st)==0) {   /* stat succeeded, file must exist */
-    static char *foo[] = { "\nOk", "\033Cancel" };
-    char str[512];
+#ifdef USE_MKSTEMP  /* (prior) nonexistence of file is already guaranteed by */
+  if (!dopipe)      /*  mkstemp(), but now mkstemp() itself has created it */
+#endif
+    /* see if file exists (i.e., we're overwriting) */
+    if (stat(outFName, &st)==0) {   /* stat succeeded, file must exist */
+      static char *foo[] = { "\nOk", "\033Cancel" };
+      char str[512];
 
-    sprintf(str,"Overwrite existing file '%s'?", outFName);
-    if (PopUp(str, foo, 2)) return NULL;
-  }
-    
+      sprintf(str,"Overwrite existing file '%s'?", outFName);
+      if (PopUp(str, foo, 2)) return NULL;
+    }
+
+
+  /* Open file (if not already open via mkstemp()) */
+#ifdef USE_MKSTEMP
+  if (!dopipe)
+#endif
+    fp = fopen(outFName, "w");
 
-  /* Open file */
-  fp = fopen(outFName, "w");
   if (!fp) {
     char  str[512];
     sprintf(str,"Can't write file '%s'\n\n  %s.",outFName, ERRSTR(errno));
@@ -1622,7 +1642,7 @@
 
   return fp;
 }
-  
+
 
 /***************************************/
 int CloseOutFile(fp, filename, failed)
@@ -1642,9 +1662,8 @@
     return 1;
   }
 
-    
+
   if (fclose(fp) == EOF) {
-    static char *foo[] = { "\nWeird!" };
     char  str[512];
     sprintf(str,"Can't close file '%s'\n\n  %s.",outFName, ERRSTR(errno));
     ErrPopUp(str, "\nWeird!");
@@ -1666,7 +1685,7 @@
   }
 
   SetISTR(ISTR_INFO,"Successfully wrote '%s'%s", outFName, buf);
-  
+
   if (dopipe) {
     char cmd[512], str[1024];
     int  i;
@@ -1709,7 +1728,7 @@
   return 0;
 }
 
-      
+
 
 
 static byte rBW[2], gBW[2], bBW[2];
@@ -1732,7 +1751,7 @@
   bwpic = (byte *) NULL;
   *nc = numcols;  *rpp = rMap;  *gpp = gMap;  *bpp = bMap;
 
-  /* quick check:  if we're saving a 24-bit image, then none of this 
+  /* quick check:  if we're saving a 24-bit image, then none of this
      complicated 'reduced'/dithered/smoothed business comes into play.
      'reduced' is disabled, for semi-obvious reasons, in 24-bit mode,
      as is 'dithered'.  If 'smoothed', and we're saving at current
@@ -1744,32 +1763,32 @@
      if we're saving B/W DITHERED, and deal accordingly */
 
 
-  if (ptype == PIC24) {  
+  if (ptype == PIC24) {
     if (color != F_BWDITHER) return NULL;
     else {                                /* generate a bw-dithered version */
       byte *p24, *thepic;
-      
+
       thepic = pic;
       p24 = GammifyPic24(thepic, pw, ph);
       if (p24) thepic = p24;
-      
+
       /* generate a FSDithered 1-byte per pixel image */
       bwpic = FSDither(thepic, PIC24, pw, ph, NULL,NULL,NULL, 0, 1);
       if (!bwpic) FatalError("unable to malloc dithered picture (DoSave)");
-      
+
       if (p24) free(p24);  /* won't need it any more */
-      
+
       /* build a BW colormap */
       rBW[0] = gBW[0] = bBW[0] = 0;
       rBW[1] = gBW[1] = bBW[1] = 255;
-      
+
       *rpp = rBW;  *gpp = gBW;  *bpp = bBW;
       *nc = 2;
-      
+
       return bwpic;
     }
   }
-    
+
 
 
   /* ptype == PIC8 ... */
@@ -1777,7 +1796,7 @@
   *nc = numcols;  *rpp = rMap;  *gpp = gMap;  *bpp = bMap;
   if (color==F_REDUCED) { *rpp = rdisp;  *gpp = gdisp;  *bpp = bdisp; }
 
-  /* if DITHER or SMOOTH, and color==FULLCOLOR or GREY, 
+  /* if DITHER or SMOOTH, and color==FULLCOLOR or GREY,
      make color=REDUCED, so it will be written with the correct colortable  */
 
   if ((epicMode == EM_DITH || epicMode == EM_SMOOTH) && color != F_REDUCED) {
@@ -1789,7 +1808,7 @@
       *rpp = gray;  *gpp = gray;  *bpp = gray;
     }
   }
-  
+
 
 
 
@@ -1823,8 +1842,8 @@
    * and whether or not it should be freed when we're done with it.  The 'pic'
    * returned is the desired portion of 'cpic' or 'epic' if there is a
    * selection, and the saveselCB is enabled, or alternately, it's the
-   * whole cpic or epic.  
-   * 
+   * whole cpic or epic.
+   *
    * if selection does not intersect cpic/epic, returns cpic/epic
    * NEVER RETURNS NULL
    */
@@ -1837,7 +1856,7 @@
   if (savenormCB.val) { thepic = cpic;  pw = cWIDE;  ph = cHIGH; }
                  else { thepic = epic;  pw = eWIDE;  ph = eHIGH; }
 
-  *pwide = pw;  *phigh = ph;  
+  *pwide = pw;  *phigh = ph;
 
 
   if (saveselCB.active && saveselCB.val && HaveSelection()) {
@@ -1862,7 +1881,7 @@
       CoordP2E(x2,y2, &x2, &y2);
       slx = x1;  sly = y1;  slw = x2-x1;  slh = y2-y1;
       CropRect2Rect(&slx, &sly, &slw, &slh, 0,0,pw,ph);
-      
+
       if (slw<1 || slh<1) { slx = sly = 0;  slw=pw;  slh=ph; }
 
       if (slx!=0 || sly!=0 || slw!=pw || slh!=ph) {
@@ -1871,7 +1890,7 @@
       }
     }
 
-    *pwide = slw;  *phigh = slh;  
+    *pwide = slw;  *phigh = slh;
   }
 
   return thepic;
@@ -1884,11 +1903,11 @@
      byte **rmapP, **gmapP, **bmapP;
 {
   /* handles the whole ugly mess of the various save options.
-   * returns an image, of type 'ptypeP', size 'wP,hP'.  
+   * returns an image, of type 'ptypeP', size 'wP,hP'.
    * if (*ptypeP == PIC8), also returns numcols 'ncP', and the r,g,b map
    * to use rmapP, gmapP, bmapP.
    *
-   * if freeP is set, image can safely be freed after it is saved 
+   * if freeP is set, image can safely be freed after it is saved
    */
 
   byte *pic1, *pic2;
@@ -1896,9 +1915,9 @@
 
   pic1 = handleNormSel(&ptype, &w, &h, &pfree);
 
-  pic2 = handleBWandReduced(pic1, ptype, w,h, MBWhich(&colMB), 
+  pic2 = handleBWandReduced(pic1, ptype, w,h, MBWhich(&colMB),
 			      ncP, rmapP, gmapP, bmapP);
-  if (pic2) { 
+  if (pic2) {
     if (pfree) free(pic1);
     pic1  = pic2;
     pfree = 1;
@@ -1906,7 +1925,7 @@
   }
 
 
-  if (ptype == PIC24) {       
+  if (ptype == PIC24) {
     pic2 = GammifyPic24(pic1, w, h);
     if (pic2) {
       if (pfree) free(pic1);
@@ -1920,7 +1939,7 @@
   return pic1;
 }
 
-     
+
 /***************************************/
 void GetSaveSize(wP, hP)
      int *wP, *hP;
@@ -1947,7 +1966,7 @@
       CoordP2E(x2,y2, &x2, &y2);
       slx = x1;  sly = y1;  slw = x2-x1;  slh = y2-y1;
       CropRect2Rect(&slx, &sly, &slw, &slh, 0,0,eWIDE,eHIGH);
-      
+
       if (slw<1 || slh<1) { slx = sly = 0;  slw=eWIDE;  slh=eHIGH; }
     }
   }
@@ -1982,7 +2001,7 @@
 
     if (stat(namelist[curname], &origStat)==0) {
       haveStat = 1;
-      if (DEBUG) fprintf(stderr," origStat.size=%ld,  origStat.mtime=%d\n", 
+      if (DEBUG) fprintf(stderr," origStat.size=%ld,  origStat.mtime=%ld\n",
 			 origStat.st_size, origStat.st_mtime);
     }
   }
@@ -1993,7 +2012,7 @@
 int CheckPoll(del)
      int del;
 {
-  /* returns '1' if the file has been modified, and either 
+  /* returns '1' if the file has been modified, and either
       A) the file has stabilized (st = lastStat), or
       B) 'del' seconds have gone by since the file last changed size
    */
@@ -2007,14 +2026,14 @@
       (strcmp(namelist[curname], STDINSTR)!=0)) {
 
     if (stat(namelist[curname], &st)==0) {
-      if (DEBUG) fprintf(stderr," st.size=%ld,  st.mtime=%d\n", 
+      if (DEBUG) fprintf(stderr," st.size=%ld,  st.mtime=%ld\n",
 			 st.st_size, st.st_mtime);
 
       if ((st.st_size  == origStat.st_size) &&
 	  (st.st_mtime == origStat.st_mtime)) return 0;  /* no change */
 
       /* if it's changed since last looked ... */
-      if (!haveLastStat || 
+      if (!haveLastStat ||
 	  st.st_size  != lastStat.st_size  ||
 	  st.st_mtime != lastStat.st_mtime)   {
 	xvbcopy((char *) &st, (char *) &lastStat, sizeof(struct stat));
@@ -2031,7 +2050,7 @@
       }
     }
   }
-  
+
   return 0;
 }
 
@@ -2042,14 +2061,13 @@
 {
   /* called when file 'name' has been deleted.  If any of the browsers
      were showing the directory that the file was in, does a rescan() */
-  
-  int  i;
+
   char buf[MAXPATHLEN + 2], *tmp;
 
   strcpy(buf, name);
   tmp = BaseName(buf);
   *tmp = '\0';     /* truncate after last '/' */
-  
+
   if (strcmp(path, buf)==0) LoadCurrentDirectory();
 }
 
diff -ruN xv-3.10a/xvevent.c xv-3.10a-bugfixes/xvevent.c
--- xv-3.10a/xvevent.c	1995-01-23 15:20:24.000000000 -0800
+++ xv-3.10a-bugfixes/xvevent.c	2004-05-16 18:02:03.000000000 -0700
@@ -101,15 +101,15 @@
   while (!done) {
 
     if (waitsec > -1 && canstartwait && !waiting && XPending(theDisp)==0) {
-      /* we wanna wait, we can wait, we haven't started waiting yet, and 
-	 all pending events (ie, drawing the image the first time) 
+      /* we wanna wait, we can wait, we haven't started waiting yet, and
+	 all pending events (ie, drawing the image the first time)
 	 have been dealt with:  START WAITING */
       time((time_t *) &orgtime);
       waiting = 1;
     }
 
 
-    /* if there's an XEvent pending *or* we're not doing anything 
+    /* if there's an XEvent pending *or* we're not doing anything
        in real-time (polling, flashing the selection, etc.) get next event */
     if ((waitsec==-1 && !polling && !HaveSelection()) || XPending(theDisp)>0) {
       XNextEvent(theDisp, &event);
@@ -187,7 +187,7 @@
 
 #ifdef VMS
     static int borders_sized = 0;
-  
+
     if (!borders_sized  && !useroot && exp_event->window == mainW) {
       /*
        * Initial expose of main window, find the size of the ancestor
@@ -198,13 +198,13 @@
       int status, count, mwid, mhgt, x, y, w, h, b, d, mbrd;
       Window root, parent, *children, crw = exp_event->window;
       borders_sized = 1;
-      status = XGetGeometry(theDisp, crw, 
+      status = XGetGeometry(theDisp, crw,
 			    &root, &x, &y, &mwid, &mhgt, &mbrd, &d);
-      
+
       for ( parent = crw, w=mwid, h=mhgt;
 	   status && (parent != root) && (parent != vrootW); ) {
 	crw = parent;
-	status = XQueryTree ( theDisp, crw, &root, &parent, 
+	status = XQueryTree ( theDisp, crw, &root, &parent,
 			     &children, &count );
 	if ( children != NULL ) XFree ( children );
       }
@@ -221,7 +221,7 @@
     win = exp_event->window;
     x = exp_event->x;      y = exp_event->y;
     w = exp_event->width;  h = exp_event->height;
-    
+
     if (PUCheckEvent  (event)) break;   /* event has been processed */
     if (PSCheckEvent  (event)) break;   /* event has been processed */
 
@@ -238,7 +238,7 @@
     if (TextCheckEvent   (event, &retval, &done)) break;   /* event eaten */
 
     /* if the window doesn't do intelligent redraw, drop but last expose */
-    if (exp_event->count>0 && 
+    if (exp_event->count>0 &&
 	win != mainW && win != ctrlW &&	win != dirW && win != infoW) break;
 
 
@@ -301,7 +301,7 @@
 	  if (DEBUG) fprintf(stderr,"No configs pending.\n");
 	  /* if (DEBUG) XClearArea(theDisp, mainW, x,y,w,h, False); */
 	  DrawWindow(x,y,w,h);
-	    
+
 	  if (HaveSelection()) DrawSelection(0);
 
 	  canstartwait = 1;  /* finished drawing */
@@ -314,7 +314,7 @@
       else if (win == infoW)          RedrawInfo(x,y,w,h);
       else if (win == ctrlW)          RedrawCtrl(x,y,w,h);
       else if (win == dirW)           RedrawDirW(x,y,w,h);
-      
+
       XSetClipMask(theDisp, theGC, None);
       XDestroyRegion(reg);
     }
@@ -324,10 +324,10 @@
     else if (win == dList.win)      LSRedraw(&dList,0);
     else if (win == dList.scrl.win) SCRedraw(&dList.scrl);
     else if (win == dnamW)          RedrawDNamW();
-  }      
+  }
     break;
 
-    
+
 
   case ClientMessage: {
     Atom proto, delwin;
@@ -382,8 +382,8 @@
       XSizeHints hints;
 
       /*
-       * if there's a virtual window manager running (e.g. tvtwm / olvwm), 
-       * we're going to get 'cevt' values in terms of the 
+       * if there's a virtual window manager running (e.g. tvtwm / olvwm),
+       * we're going to get 'cevt' values in terms of the
        * 'real' root window (the one that is the size of the screen).
        * We'll want to translate them into values that are in terms of
        * the 'virtual' root window (the 'big' one)
@@ -392,7 +392,7 @@
       if (vrootW != rootW) {
 	int x1,y1;  Window child;
 
-	XTranslateCoordinates(theDisp, rootW, vrootW, cevt->x, cevt->y, 
+	XTranslateCoordinates(theDisp, rootW, vrootW, cevt->x, cevt->y,
 			      &x1, &y1, &child);
 	if (DEBUG) fprintf(stderr,"  CONFIG trans %d,%d root -> %d,%d vroot\n",
 			   cevt->x, cevt->y, x1, y1);
@@ -401,11 +401,11 @@
 
 #ifndef VMS
       /* read hints for this window and adjust any position hints, but
-         only if this is a 'synthetic' event sent to us by the WM 
+         only if this is a 'synthetic' event sent to us by the WM
 	 ('real' events from the server have useless x,y info, since the
 	 mainW has been reparented by the WM) */
 
-      if (cevt->send_event && 
+      if (cevt->send_event &&
 	  XGetNormalHints(theDisp, cevt->window, &hints)) {
 
 	if (DEBUG) fprintf(stderr,"  CONFIG got hints (0x%x  %d,%d)\n",
@@ -439,11 +439,11 @@
        * This sucks!
        *
        * So, if we have just loaded an image, and we get a Synthetic conf
-       * that is not the desired size (eWIDExeHIGH), ignore it, as it's 
+       * that is not the desired size (eWIDExeHIGH), ignore it, as it's
        * just the conf generated by moving the old window.  And stop
        * ignoring further config events
        *
-       * EVIL KLUDGE:  do *not* ignore configs that are <100x100.  Not 
+       * EVIL KLUDGE:  do *not* ignore configs that are <100x100.  Not
        * ignoring them won't be a big performance problem, and it'll get
        * around the 'I only got one config in the wrong size' problem when
        * initially displaying small images
@@ -453,7 +453,7 @@
 
 /* fprintf(stderr,"***mainw, ignore=%d, send_event=%d, evtSize=%d,%d, size=%d,%d\n", ignoreConfigs, cevt->send_event, cevt->width, cevt->height, eWIDE, eHIGH); */
 
-      if (ignoreConfigs==1 && cevt->send_event && 
+      if (ignoreConfigs==1 && cevt->send_event &&
 	  (cevt->width != eWIDE || cevt->height != eHIGH)) {
 	ignoreConfigs=0;        /* ignore this one only */
 	break;
@@ -470,7 +470,7 @@
 	else {
 	  XEvent xev;
 	  if (DEBUG) fprintf(stderr,"No configs pend.");
-	  
+
 	  if (cevt->width == eWIDE && cevt->height == eHIGH) {
 	    if (DEBUG) fprintf(stderr,"No redraw\n");
 	  }
@@ -478,12 +478,12 @@
 	    if (DEBUG) fprintf(stderr,"Do full redraw\n");
 
 	    Resize(cevt->width, cevt->height);
-	    
+
 	    /* eat any pending expose events and do a full redraw */
 	    while (XCheckTypedWindowEvent(theDisp, mainW, Expose, &xev)) {
 	      XExposeEvent *exp = (XExposeEvent *) &xev;
 
-	      if (DEBUG) 
+	      if (DEBUG)
 		fprintf(stderr,"  ate expose (%s) (count=%d) %d,%d %dx%d\n",
 			exp->send_event ? "synth" : "real", exp->count,
 			exp->x, exp->y, exp->width, exp->height);
@@ -508,9 +508,9 @@
 
   }
     break;
-	
 
-	
+
+
   case CirculateNotify:
   case DestroyNotify:
   case GravityNotify:       break;
@@ -554,7 +554,7 @@
 
       /* don't do it if we've just switched to a root mode */
       if ((unmap_event->window == mainW && dispMode == 0) ||
-	  (unmap_event->window == ctrlW && dispMode != 0)) {  
+	  (unmap_event->window == ctrlW && dispMode != 0)) {
 
 	if (autoclose) {
 	  if (autoclose>1) autoclose -= 2;  /* grab kludge */
@@ -586,8 +586,8 @@
     XReparentEvent *reparent_event = (XReparentEvent *) event;
 
     if (DEBUG) {
-      fprintf(stderr,"Reparent: mainW=%x ->win=%x ->ev=%x  ->parent=%x  ", 
-	      (u_int) mainW,                 (u_int) reparent_event->window, 
+      fprintf(stderr,"Reparent: mainW=%x ->win=%x ->ev=%x  ->parent=%x  ",
+	      (u_int) mainW,                 (u_int) reparent_event->window,
 	      (u_int) reparent_event->event, (u_int) reparent_event->parent);
       fprintf(stderr,"%d,%d\n", reparent_event->x, reparent_event->y);
     }
@@ -598,7 +598,7 @@
 
       p_offx = p_offy = 0;          /* topleft correction for WMs titlebar */
 
-      if (ch_offx == 0 && ch_offy == 0) {  
+      if (ch_offx == 0 && ch_offy == 0) {
 	/* looks like the user is running MWM or OLWM */
 
 	XWindowAttributes xwa;
@@ -609,8 +609,8 @@
 
 	XSync(theDisp, False);
 	XGetWindowAttributes(theDisp, mainW, &xwa);
-	
-	if (DEBUG) 
+
+	if (DEBUG)
 	  fprintf(stderr,"XGetAttr: mainW %d,%d %dx%d\n", xwa.x, xwa.y,
 		  xwa.width, xwa.height);
 
@@ -620,8 +620,8 @@
 
 	  XSync(theDisp, False);
 	  XGetWindowAttributes(theDisp, reparent_event->parent, &xwa);
-	
-	  if (DEBUG) 
+
+	  if (DEBUG)
 	    fprintf(stderr,"XGetAttr: parent %d,%d %dx%d\n", xwa.x, xwa.y,
 		    xwa.width, xwa.height);
 	}
@@ -641,42 +641,42 @@
 	p_offy = xwa.y;
       }
 
-      
+
       /* move window around a bit... */
       {
 	XWindowAttributes xwa;
 	GetWindowPos(&xwa);
 	xwa.width = eWIDE;  xwa.height = eHIGH;
-	
+
 	/* try to keep the damned thing on-screen, if possible */
 	if (xwa.x + xwa.width  > dispWIDE) xwa.x = dispWIDE - xwa.width;
 	if (xwa.y + xwa.height > dispHIGH) xwa.y = dispHIGH - xwa.height;
 	if (xwa.x < 0) xwa.x = 0;
 	if (xwa.y < 0) xwa.y = 0;
-	
+
 	SetWindowPos(&xwa);
       }
 
     }
   }
     break;
-    
+
 
   case EnterNotify:
   case LeaveNotify: {
     XCrossingEvent *cross_event = (XCrossingEvent *) event;
     if (cross_event->window == mainW || 0
 	/* (cross_event->window == gamW && cmapInGam) */ ) {
-      
+
       if (cross_event->type == EnterNotify && cross_event->window == mainW) {
 	zoomCurs(cross_event->state);
       }
 
 
-      if (cross_event->type == EnterNotify && LocalCmap && !ninstall) 
+      if (cross_event->type == EnterNotify && LocalCmap && !ninstall)
 	XInstallColormap(theDisp,LocalCmap);
 
-      if (cross_event->type == LeaveNotify && LocalCmap && !ninstall) 
+      if (cross_event->type == LeaveNotify && LocalCmap && !ninstall)
 	XUninstallColormap(theDisp,LocalCmap);
     }
   }
@@ -685,12 +685,12 @@
 
   case SelectionClear:  break;
 
-  case SelectionRequest: 
+  case SelectionRequest:
     {
       XSelectionRequestEvent *xsrevt = (XSelectionRequestEvent *) event;
       XSelectionEvent  xse;
 
-      if (xsrevt->owner     != ctrlW      || 
+      if (xsrevt->owner     != ctrlW      ||
 	  xsrevt->selection != XA_PRIMARY ||
 	  xsrevt->target    != XA_STRING) {  /* can't do it. */
 	xse.property = None;
@@ -702,7 +702,7 @@
 	if (xse.property != None) {
           xerrcode = 0;
 	  XChangeProperty(theDisp, xsrevt->requestor, xse.property,
-			  XA_STRING, 8, PropModeReplace, 
+			  XA_STRING, 8, PropModeReplace,
 			  (byte *) ((xevPriSel) ? xevPriSel           : "\0"),
 			  (int)    ((xevPriSel) ? strlen(xevPriSel)+1 : 1));
           XSync(theDisp, False);
@@ -721,9 +721,9 @@
       XSync(theDisp, False);
     }
     break;
-	
-      
-	
+
+
+
   default: break;		/* ignore unexpected events */
   }  /* switch */
 
@@ -738,7 +738,7 @@
      int i;
 {
   /* called to handle selection of a dispMB item */
-  
+
   if (i<0 || i>=DMB_MAX) return;
 
   if (dispMB.dim[i]) return;    /* disabled */
@@ -747,36 +747,36 @@
     if      (i==DMB_RAW)  epicMode = EM_RAW;
     else if (i==DMB_DITH) epicMode = EM_DITH;
     else                  epicMode = EM_SMOOTH;
-    
-    SetEpicMode();	              
+
+    SetEpicMode();
     GenerateEpic(eWIDE, eHIGH);
     DrawEpic();
     SetCursors(-1);
   }
-  
+
   else if (i==DMB_COLRW) {   /* toggle rw on/off */
     dispMB.flags[i] = !dispMB.flags[i];
     allocMode = (dispMB.flags[i]) ? AM_READWRITE : AM_READONLY;
     ChangeCmapMode(colorMapMode, 1, 0);
   }
-  
+
   else if (i>=DMB_COLNORM && i<=DMB_COLSTDC && !dispMB.flags[i]) {
     switch (i) {
-    case DMB_COLNORM:  
-      ChangeCmapMode(CM_NORMAL, 1, 0);   
-      defaultCmapMode = CM_NORMAL;    
+    case DMB_COLNORM:
+      ChangeCmapMode(CM_NORMAL, 1, 0);
+      defaultCmapMode = CM_NORMAL;
       break;
-    case DMB_COLPERF:  
+    case DMB_COLPERF:
       ChangeCmapMode(CM_PERFECT,1, 0);
-      defaultCmapMode = CM_PERFECT;   
+      defaultCmapMode = CM_PERFECT;
       break;
-    case DMB_COLOWNC:  
+    case DMB_COLOWNC:
       ChangeCmapMode(CM_OWNCMAP,1, 0);
-      defaultCmapMode = CM_OWNCMAP;   
+      defaultCmapMode = CM_OWNCMAP;
       break;
-    case DMB_COLSTDC:  
+    case DMB_COLSTDC:
       ChangeCmapMode(CM_STDCMAP,1, 0);
-      defaultCmapMode = CM_STDCMAP;   
+      defaultCmapMode = CM_STDCMAP;
       break;
     }
   }
@@ -788,17 +788,17 @@
      int i;
 {
   /* called to handle selection of a rootMB item */
-  
+
   if (i<0 || i>=RMB_MAX) return;
   if (rootMB.flags[i])   return;
   if (rootMB.dim[i])     return;
 
   dispMode = i;
-  
+
   /* move checkmark */
   for (i=RMB_WINDOW; i<RMB_MAX; i++) rootMB.flags[i] = 0;
   rootMB.flags[dispMode] = 1;
-  
+
   HandleDispMode();
 }
 
@@ -818,25 +818,25 @@
       else if (i==CONV24_24BIT && state824==1) {
 	/* went 24->8->24 */
 	char buf[512];
-	
+
 	sprintf(buf,"Warning:  You appear to have taken a 24-bit ");
 	strcat(buf, "image, turned it to an 8-bit image, and turned ");
 	strcat(buf, "it back into a 24-bit image.  Understand that ");
 	strcat(buf, "image data has probably been lost in this ");
 	strcat(buf, "transformation.  You *may* want to reload the ");
 	strcat(buf, "original image to avoid this problem.");
-	
+
 	ErrPopUp(buf, "\nI Know!");
-	
+
 	state824 = 2;   /* shut up until next image is loaded */
       }
     }
   }
-  
+
   else if (i==CONV24_LOCK) {
     conv24MB.flags[i] = !conv24MB.flags[i];
   }
-  
+
   else if (i>=CONV24_FAST && i<=CONV24_BEST) {
     conv24 = i;
     for (i=CONV24_FAST; i<=CONV24_BEST; i++) {
@@ -859,15 +859,15 @@
     else chdir(initdir);
     OpenBrowse();
     break;
-    
+
   case WMB_COLEDIT:  GamBox (!gamUp);   break;
   case WMB_INFO:     InfoBox(!infoUp);  break;
-    
-  case WMB_COMMENT:  
+
+  case WMB_COMMENT:
     if (!commentUp) OpenCommentText();
     else CloseCommentText();
     break;
-    
+
   case WMB_TEXTVIEW:  textViewCmd();  break;
   case WMB_ABOUTXV:   ShowLicense();  break;
   case WMB_KEYHELP:   ShowKeyHelp();  break;
@@ -892,19 +892,19 @@
       double r,wr,hr;
       wr = ((double) cWIDE) / maxWIDE;
       hr = ((double) cHIGH) / maxHIGH;
-      
+
       r = (wr>hr) ? wr : hr;   /* r is the max(wr,hr) */
       w = (int) ((cWIDE / r) + 0.5);
       h = (int) ((cHIGH / r) + 0.5);
     }
     else { w = cWIDE;  h = cHIGH; }
-    
+
     WResize(w, h);
     break;
 
   case SZMB_MAXPIC:   WMaximize();  break;
 
-  case SZMB_MAXPECT: 
+  case SZMB_MAXPECT:
     {
       int w1,h1;
       w1 = eWIDE;  h1 = eHIGH;
@@ -925,24 +925,24 @@
     if (h==eHIGH) h++;
     WResize(w,h);
     break;
-    
-    
+
+
   case SZMB_SETSIZE:  setSizeCmd();  break;
   case SZMB_ASPECT:   FixAspect(1, &w, &h);  WResize(w,h);  break;
 
-  case SZMB_4BY3:   
+  case SZMB_4BY3:
     w = eWIDE;  h = (w * 3) / 4;
     if (h>maxHIGH) { h = eHIGH;  w = (h*4)/3; }
     WResize(w,h);
     break;
 
-  case SZMB_INTEXP:  
+  case SZMB_INTEXP:
     {
       /* round  (eWIDE/cWIDE),(eHIGH/cHIGH) to nearest
 	 integer expansion/compression values */
-      
+
       double w,h;
-      
+
       if (eWIDE >= cWIDE) {
 	w = ((double) eWIDE) / cWIDE;
 	w = floor(w + 0.5);
@@ -961,7 +961,7 @@
 	}
 	w = pick;
       }
-      
+
       if (eHIGH >= cHIGH) {
 	h = ((double) eHIGH) / cHIGH;
 	h = floor(h + 0.5);
@@ -980,11 +980,11 @@
 	}
 	h = pick;
       }
-      
+
       WResize((int) (w*cWIDE), (int) (h*cHIGH));
     }
     break;
-    
+
   default: break;
   }
 }
@@ -998,7 +998,7 @@
   int          i;
   char         txt[512], str[PRINTCMDLEN + 10];
   static char *labels[] = { " Color", " Grayscale", " B/W", "\033Cancel" };
-  
+
   strcpy(txt, "Print:  Enter a command that will read a PostScript file ");
   strcat(txt, "from stdin and print it to the desired printer.\n\n");
 #ifndef VMS
@@ -1011,11 +1011,11 @@
   if (i == 3 || strlen(printCmd)==0) return;   /* CANCEL */
 
   if (dirUp == BLOAD) DirBox(0);
-  
+
   SetDirSaveMode(F_FORMAT, F_PS);
   SetDirSaveMode(F_COLORS, i);
 
-  if (printCmd[0] != '|' && printCmd[0] != '!') 
+  if (printCmd[0] != '|' && printCmd[0] != '!')
     sprintf(str, "| %s", printCmd);
   else strcpy(str, printCmd);
 
@@ -1090,7 +1090,7 @@
      Window win;
 {
   static char foo[16];
-  
+
   if      (win == mainW)  return "mainW";
   else if (win == rootW)  return "rootW";
   else if (win == vrootW) return "vrootW";
@@ -1106,7 +1106,7 @@
   }
 }
 
-	    
+
 /***********************************/
 static void handleButtonEvent(event, donep, retvalp)
   XEvent *event;
@@ -1127,38 +1127,36 @@
   case ButtonPress:
     /* *always* check for pop-up events, as errors can happen... */
     if (PUCheckEvent  (event)) break;
-    
+
     if (autoquit && win == mainW) Quit(0);
-    
+
     if (viewonly) break;     /* ignore all other button presses */
-    
+
     if (win == mainW && !useroot && showzoomcursor) {
       DoZoom(x, y, but_event->button);
       break;
     }
-    
+
     if (PSCheckEvent  (event)) break;
-    
+
 #ifdef HAVE_JPEG
     if (JPEGCheckEvent(event)) break;
 #endif
-    
+
 #ifdef HAVE_TIFF
     if (TIFFCheckEvent(event)) break;
 #endif
-    
+
     if (GamCheckEvent (event)) break;
     if (BrowseCheckEvent (event, &retval, &done)) break;
     if (TextCheckEvent   (event, &retval, &done)) break;
-    
+
     switch (but_event->button) {
-      
-    case Button1:  
+
+    case Button1:
       if      (win == mainW) DoSelection(but_event);
-      
+
       else if (win == ctrlW) {
-	int   w,h;
-	
 	if      (MBClick(&dispMB,   x,y)) SelectDispMB  (MBTrack(&dispMB)  );
 	else if (MBClick(&conv24MB, x,y)) Select24to8MB (MBTrack(&conv24MB));
 	else if (MBClick(&rootMB,   x,y)) SelectRootMB  (MBTrack(&rootMB)  );
@@ -1170,9 +1168,9 @@
 	  if (i>=0) DoAlg(i);
 	  break;
 	}
-	
+
 	i=ClickCtrl(x,y);
-	
+
 	switch (i) {
 	case BNEXT:   retval= NEXTPIC;  done=1;     break;
 	case BPREV:   retval= PREVPIC;  done=1;     break;
@@ -1192,21 +1190,21 @@
 	case BROTR:   Rotate(0);                    break;
 	case BFLIPH:  Flip(0);                      break;
 	case BFLIPV:  Flip(1);                      break;
-	  
+
 	case BCROP:   Crop();                       break;
 	case BUNCROP: UnCrop();                     break;
 	case BACROP:  AutoCrop();                   break;
-	  
+
 	case BPAD:
 	  {
 	    int mode, wide, high, opaque, omode;  char *str;
-	    
+
 	    while (PadPopUp(&mode, &str, &wide, &high, &opaque, &omode)==0) {
-	      if (DoPad(mode, str, wide, high, opaque, omode)) { 
+	      if (DoPad(mode, str, wide, high, opaque, omode)) {
 		done = 1;  retval = PADDED;  break;
 	      }
-	    }     
-	  }  
+	    }
+	  }
 	  break;
 
 	case BANNOT:  annotatePic();                break;
@@ -1214,27 +1212,27 @@
 	case BABOUT:  SelectWindowMB(WMB_ABOUTXV);  break;
 	case BXV:     retval = DFLTPIC;  done=1;    break;
 	case BQUIT:   retval = QUIT;     done=1;    break;
-	  
+
 	default:      break;
 	}
-	
+
 	if (i==BFLIPH || i==BFLIPV) {
 	  DrawEpic();
 	  SetCursors(-1);
 	}
       }
-      
+
       else if (win == nList.win) {
 	i=LSClick(&nList,but_event);
 	if (curname<0) ActivePrevNext();
 	if (i>=0) { done = 1;  retval = i; }
       }
-      
+
       else if (win == nList.scrl.win) SCTrack(&nList.scrl, x, y);
-      
+
       else if (win == dirW) {
 	i=ClickDirW(x,y);
-	
+
 	switch (i) {
 	case S_BOK:   if (dirUp == BLOAD) {
 	  if (!DirCheckCD()) {
@@ -1246,53 +1244,53 @@
 	  DoSave();
 	}
 	  break;
-	  
+
 	case S_BCANC: DirBox(0);  break;
-	  
+
 	case S_BRESCAN:
 	  WaitCursor();  LoadCurrentDirectory();  SetCursors(-1);
 	  break;
 	}
       }
-      
+
       else if (win == dList.win) {
 	i=LSClick(&dList,but_event);
 	SelectDir(i);
       }
-      
+
       else if (win == dList.scrl.win) SCTrack(&dList.scrl, x,y);
       else if (win == infoW)          InfoBox(0);  /* close info */
-      
+
       break;
-      
-      
-    case Button2:  
+
+
+    case Button2:
       if (win == mainW && !useroot) {
 	if (!shift && !DoSelection(but_event)) TrackPicValues(x,y);
 	else if (shift) Paint();
       }
       break;
-      
+
     case Button3:  /* if using root, MUST NOT get rid of ctrlbox. */
-      if (!shift && !useroot) CtrlBox(!ctrlUp); 
+      if (!shift && !useroot) CtrlBox(!ctrlUp);
       else if (shift) BlurPaint();
       break;
-      
+
     default:       break;
     }
   }
-  
+
   *donep = done;  *retvalp = retval;
 }
 
-	
+
 /***********************************/
 static void handleKeyEvent(event, donep, retvalp)
   XEvent *event;
   int    *donep, *retvalp;
 {
   /* handles KeyPress and KeyRelease events, called from HandleEvent */
-  
+
   XKeyEvent *key_event;
   KeySym     ks;
   char       buf[128];
@@ -1306,26 +1304,26 @@
   switch (event->type) {
   case KeyRelease:
     if (viewonly) break;     /* ignore all user input */
-    
+
     stlen = XLookupString(key_event,buf,128,&ks,(XComposeStatus *) NULL);
     dealt = 0;
-    
+
     if (key_event->window == mainW) {
       u_int foo = key_event->state;
 
-      if (ks == XK_Shift_L   || ks == XK_Shift_R)   
+      if (ks == XK_Shift_L   || ks == XK_Shift_R)
 	foo = foo & (u_int) (~ShiftMask);
-      if (ks == XK_Control_L || ks == XK_Control_R) 
+      if (ks == XK_Control_L || ks == XK_Control_R)
 	foo = foo & (u_int) (~ControlMask);
-      if (ks == XK_Meta_L    || ks == XK_Meta_R)    
+      if (ks == XK_Meta_L    || ks == XK_Meta_R)
 	foo = foo & (u_int) (~Mod1Mask);
-      if (ks == XK_Alt_L     || ks == XK_Alt_R)     
+      if (ks == XK_Alt_L     || ks == XK_Alt_R)
 	foo = foo & (u_int) (~Mod1Mask);
 
       zoomCurs(foo);
     }
     break;
-    
+
 
   case KeyPress:
     svkeystate = key_event->state;
@@ -1343,11 +1341,11 @@
     if (PUCheckEvent  (event)) break;          /* always check popups */
 
     if (autoquit && key_event->window == mainW) Quit(0);
-    
+
     if (viewonly && !frominterrupt) break;     /* ignore all user input */
-    
+
     if (PSCheckEvent  (event)) break;
-    
+
     if (key_event->window == mainW) {
       u_int foo = key_event->state;
 
@@ -1371,7 +1369,7 @@
     if (TextCheckEvent   (event, &retval, &done)) break;
 
 
-    /* check for pageup/pagedown, 'p' in main window 
+    /* check for pageup/pagedown, 'p' in main window
        (you can use shift-up or shift-down if no crop rectangle drawn)
        (for viewing multipage docs) */
 
@@ -1386,7 +1384,7 @@
 	else XBell(theDisp,0);
       }
 
-      else if (ck==CK_PAGEDOWN || 
+      else if (ck==CK_PAGEDOWN ||
 	       (ck==CK_DOWN && shift && !but[BCROP].active)) {
 	if (strlen(pageBaseName) && numPages>1) {
 	  done = 1;  retval = OP_PAGEDN;
@@ -1429,7 +1427,7 @@
 
       if (dealt) break;
     }
-	
+
 
 
     /* check for crop rect keys */
@@ -1468,7 +1466,7 @@
       if (theList == &dList && dealt) {  /* changed dir selection */
 	SelectDir(-1);  /* nothing was double-clicked */
       }
-      
+
       if (dealt) break;
     }
 
@@ -1491,7 +1489,7 @@
       else if (ks==XK_2) FakeButtonPress(&gbut[G_B2]);
       else if (ks==XK_3) FakeButtonPress(&gbut[G_B3]);
       else if (ks==XK_4) FakeButtonPress(&gbut[G_B4]);
-      else if (ks==XK_r || ks==XK_0) 
+      else if (ks==XK_r || ks==XK_0)
 	                 FakeButtonPress(&gbut[G_BRESET]);
 
       else if (ks==XK_x) FakeButtonPress(&but[BCUT]);
@@ -1521,7 +1519,7 @@
 
       else if (ks==XK_a) FakeButtonPress(&gbut[G_BAPPLY]);
 
-      else if (ks==XK_8) { 
+      else if (ks==XK_8) {
 	if (picType==PIC8) Select24to8MB(CONV24_24BIT);
 	              else Select24to8MB(CONV24_8BIT);
       }
@@ -1530,20 +1528,20 @@
 
       if (dealt) break;
     }
-    
+
     if (!stlen) break;
-    
+
     if (key_event->window == dirW) {
       if (DirKey(buf[0])) XBell(theDisp,0);
     }
     else {                               /* commands valid in any window */
       switch (buf[0]) {
-	
+
 	/* things in dispMB */
       case 'r':    SelectDispMB(DMB_RAW);           break;
       case 'd':    SelectDispMB(DMB_DITH);          break;
       case 's':    SelectDispMB(DMB_SMOOTH);        break;
-	
+
 	/* things in sizeMB */
       case 'n':    SelectSizeMB(SZMB_NORM);         break;
       case 'm':    SelectSizeMB(SZMB_MAXPIC);       break;
@@ -1556,7 +1554,7 @@
       case 'a':    SelectSizeMB(SZMB_ASPECT);       break;
       case '4':    SelectSizeMB(SZMB_4BY3);         break;
       case 'I':    SelectSizeMB(SZMB_INTEXP);       break;
-	
+
 	/* things in windowMB */
       case '\026':
       case 'V':    SelectWindowMB(WMB_BROWSE);      break;  /* ^V or V */
@@ -1565,36 +1563,36 @@
       case '\003': SelectWindowMB(WMB_COMMENT);     break;  /* ^C */
       case '\024': SelectWindowMB(WMB_TEXTVIEW);    break;  /* ^T */
       case '\001': SelectWindowMB(WMB_ABOUTXV);     break;  /* ^A */
-	
-	
-	
+
+
+
 	/* buttons in ctrlW */
       case '\t':
       case ' ':    FakeButtonPress(&but[BNEXT]);    break;
-	
+
       case '\r':
       case '\n':
 	if (nList.selected >= 0 && nList.selected < nList.nstr) {
-	  done = 1;  retval = nList.selected; 
+	  done = 1;  retval = nList.selected;
 	  if (frominterrupt) retval = RELOAD;
 	}
 	break;
-	
+
       case '\010':
       case '\177': FakeButtonPress(&but[BPREV]);    break;
-	
-	
+
+
       case '\014': FakeButtonPress(&but[BLOAD]);    break;  /* ^L */
       case '\023': FakeButtonPress(&but[BSAVE]);    break;  /* ^S */
       case '\020': FakeButtonPress(&but[BPRINT]);   break;  /* ^P */
       case '\004': FakeButtonPress(&but[BDELETE]);  break;  /* ^D */
-	
+
 	/* BCOPY, BCUT, BPASTE, BCLEAR handled in 'meta' case */
-	
+
       case '\007': FakeButtonPress(&but[BGRAB]);    break;  /* ^G */
-	
+
 	/* BUP10, BDN10 handled in sizeMB case */
-	
+
       case 'T':    FakeButtonPress(&but[BROTL]);    break;
       case 't':    FakeButtonPress(&but[BROTR]);    break;
       case 'h':    FakeButtonPress(&but[BFLIPH]);   break;
@@ -1604,24 +1602,24 @@
       case 'C':    FakeButtonPress(&but[BACROP]);   break;
       case 'P':    FakeButtonPress(&but[BPAD]);     break;
       case 'A':    FakeButtonPress(&but[BANNOT]);   break;
-	
+
 	/* BABOUT handled in windowMB case */
-	
+
       case '\021': /* ^Q */
       case 'q':    FakeButtonPress(&but[BQUIT]);    break;
-	
+
       case '?':    if (!useroot) CtrlBox(!ctrlUp);  break;
-	
+
 	/* things in color editor */
       case 'R':    FakeButtonPress(&gbut[G_BRESET]);   break;
       case 'H':    FakeButtonPress(&gbut[G_BHISTEQ]);  break;
       case 'N':    FakeButtonPress(&gbut[G_BMAXCONT]); break;
-	
+
       default:     break;
       }
     }
   }
-  
+
   *donep = done;  *retvalp = retval;
 }
 
@@ -1657,7 +1655,7 @@
   else name = namelist[i];
 
   TextView(name);
-  
+
   if (name != namelist[i]) free(name);
 }
 
@@ -1671,7 +1669,7 @@
   int   i, arg1, arg2, numargs, pct1, pct2, state, neww, newh;
   char  txt[512], buf[64], *sp, ch;
   static char *labels[] = { "\nOk", "\033Cancel" };
-  
+
   sprintf(txt, "Enter new image display size (ex. '400 x 300'),\n");
   strcat (txt, "expansion ratio (ex. '75%'),\n");
   strcat (txt, "or expansion ratios (ex. '200% x 125%'):");
@@ -1685,7 +1683,7 @@
 
 
   /* attempt to parse the string accordingly...
-   * parses strings of the type: <num> [%] [ x <num> [%] ] 
+   * parses strings of the type: <num> [%] [ x <num> [%] ]
    * (-ish.  <num> all by itself isn't legal)
    * there may be any # of spaces between items, including zero
    */
@@ -1825,7 +1823,7 @@
 
   if (theImage)
     XPutImage(theDisp,mainW,theGC,theImage,x,y,x,y, (u_int) w, (u_int) h);
-  else 
+  else
     if (DEBUG) fprintf(stderr,"Tried to DrawWindow when theImage was NULL\n");
 }
 
@@ -1872,7 +1870,7 @@
     XWindowAttributes xwa;
     xvbzero((char *) &xwa, sizeof(XWindowAttributes));
     xwa.x = xwa.y = 0;
-    xwa.width  = dispWIDE;  
+    xwa.width  = dispWIDE;
     xwa.height = dispHIGH;
     SetWindowPos(&xwa);
   }
@@ -1898,14 +1896,14 @@
     rotatesLeft++;
     XClearWindow(theDisp, mainW);  /* get rid of old bits */
     GenExpose(mainW, 0, 0, (u_int) eWIDE, (u_int) eHIGH);
-    { int ew, eh; 
+    { int ew, eh;
       ew = eWIDE;  eh = eHIGH;
       WResize(eWIDE, eHIGH);
       if (ew>maxWIDE || eh>maxHIGH) {   /* rotated pic too big, scale down */
 	double r,wr,hr;
 	wr = ((double) ew) / maxWIDE;
 	hr = ((double) eh) / maxHIGH;
-	
+
 	r = (wr>hr) ? wr : hr;   /* r is the max(wr,hr) */
 	ew = (int) ((ew / r) + 0.5);
 	eh = (int) ((eh / r) + 0.5);
@@ -1920,7 +1918,7 @@
 void WCrop(w,h,dx,dy)
      int w,h,dx,dy;
 {
-  int cx, cy, cw, ch, ex, ey;
+  int ex, ey;
   XWindowAttributes xwa;
 
   if (useroot) {
@@ -1931,7 +1929,7 @@
   else {
     /* we want to move window to old x,y + dx,dy (in pic coords) */
     GetWindowPos(&xwa);
-  
+
     if (!origcropvalid) {  /* first crop.  remember win pos */
       origcropvalid = 1;
       origcropx = xwa.x;
@@ -1939,7 +1937,7 @@
     }
 
     CoordC2E(dx, dy, &ex, &ey);
-    
+
     xwa.x += ex;  xwa.y += ey;
     xwa.width = w;  xwa.height = h;
     GenExpose(mainW, 0, 0, (u_int) eWIDE, (u_int) eHIGH);
@@ -1980,7 +1978,7 @@
     if (xwa.x<0) xwa.x = 0;
     if (xwa.y<0) xwa.y = 0;
     xwa.width = w;  xwa.height = h;
-    
+
     if (!useroot) {
       SetWindowPos(&xwa);
       GenExpose(mainW, 0, 0, (u_int) eWIDE, (u_int) eHIGH);
@@ -1995,8 +1993,8 @@
 XWindowAttributes *xwa;
 {
   Window child;
-  
-  /* returns the x,y,w,h coords of mainW.  x,y are relative to rootW 
+
+  /* returns the x,y,w,h coords of mainW.  x,y are relative to rootW
      the border is not included (x,y map to top-left pixel in window) */
 
   /* Get the window width/height */
@@ -2023,7 +2021,7 @@
 
   /* if we're less than max size in one axis, allow window manager doohickeys
      on the screen */
-  
+
   if (xwa->width  < dispWIDE && xwc.x < p_offx) xwc.x = p_offx;
   if (xwa->height < dispHIGH && xwc.y < p_offy) xwc.y = p_offy;
 
@@ -2034,9 +2032,9 @@
 #ifdef BAD_IDEA
   /* if there is a virtual window manager running, then we should translate
      the coordinates that are in terms of 'real' screen into coordinates
-     that are in terms of the 'virtual' root window 
+     that are in terms of the 'virtual' root window
      from: Daren W. Latham <dwl@mentat.udev.cdc.com> */
-  
+
   if (vrootW != rootW) { /* virtual window manager running */
     int x1,y1;
     Window child;
@@ -2045,14 +2043,14 @@
 		       xwc.x,xwc.y,x1,y1);
     xwc.x = x1;  xwc.y = y1;
   }
-#endif  
+#endif
 
 
   if (DEBUG) {
     fprintf(stderr,
 	    "SWP: xwa=%d,%d %dx%d xwc=%d,%d %dx%d off=%d,%d bw=%d klg=%d,%d\n",
 	    xwa->x, xwa->y, xwa->width, xwa->height,
-	    xwc.x, xwc.y, xwc.width, xwc.height, p_offx, p_offy, 
+	    xwc.x, xwc.y, xwc.width, xwc.height, p_offx, p_offy,
 	    xwa->border_width, kludge_offx, kludge_offy);
   }
 
@@ -2080,7 +2078,7 @@
 
   /* all non-DXWM window managers (?) */
   /* Move/Resize the window. */
-  XConfigureWindow(theDisp, mainW, 
+  XConfigureWindow(theDisp, mainW,
 		   CWX | CWY | CWWidth | CWHeight /*| CWBorderWidth*/, &xwc);
 }
 
@@ -2090,7 +2088,7 @@
 static void CropKey(dx,dy,grow,crop)
      int dx,dy,grow,crop;
 {
-  int x1,x2,y1,y2,active, ocx, ocy;
+  int ocx, ocy;
 
   if (crop) { /* chop off a pixel from the appropriate edge */
     int dealt=1;
@@ -2112,7 +2110,7 @@
     }
     return;
   }
-      
+
   if (grow) MoveGrowSelection(0,  0,  dx, dy);
        else MoveGrowSelection(dx, dy, 0,  0);
 }
@@ -2128,7 +2126,7 @@
   u_long       wh, bl;
   int          ty, w, ecol, done1;
   char         foo[128];
-  char         *str  = 
+  char         *str  =
    "8888,8888 = 123,123,123  #123456  (123,123,123 HSV)  [-2345,-2345]";
 
   ecol = 0;  wh = infobg;  bl = infofg;
@@ -2136,14 +2134,14 @@
   if (!dropper) {
     Pixmap      pix, mask;
     XColor      cfg, cbg;
-    
+
     cfg.red = cfg.green = cfg.blue = 0x0000;
     cbg.red = cbg.green = cbg.blue = 0xffff;
-    
+
     pix = MakePix1(rootW, dropper_bits,  dropper_width,  dropper_height);
     mask= MakePix1(rootW, dropperm_bits, dropperm_width, dropperm_height);
-    if (pix && mask) 
-      dropper = XCreatePixmapCursor(theDisp, pix, mask, &cfg, &cbg, 
+    if (pix && mask)
+      dropper = XCreatePixmapCursor(theDisp, pix, mask, &cfg, &cbg,
 				    dropper_x_hot, dropper_y_hot);
     if (pix)  XFreePixmap(theDisp, pix);
     if (mask) XFreePixmap(theDisp, mask);
@@ -2151,7 +2149,7 @@
 
   if (dropper) XDefineCursor(theDisp, mainW, dropper);
 
-  /* do a colormap search for black and white if LocalCmap 
+  /* do a colormap search for black and white if LocalCmap
      and use those colors instead of infobg and infofg */
 
   if (LocalCmap) {
@@ -2159,7 +2157,7 @@
 
     for (i=0; i<nfcols; i++) ctab[i].pixel = freecols[i];
     XQueryColors(theDisp,LocalCmap,ctab,nfcols);
-    
+
     /* find 'blackest' pixel */
     cval = 0x10000 * 3;
     for (i=0; i<nfcols; i++)
@@ -2176,7 +2174,7 @@
 	wh = ctab[i].pixel;
       }
   }
-  
+
 
   XSetFont(theDisp, theGC, monofont);
   w = XTextWidth(monofinfo, str, (int) strlen(str));
@@ -2185,7 +2183,7 @@
                else ty = eHIGH-(monofinfo->ascent + mfinfo->descent)-4;
 
   XSetForeground(theDisp, theGC, bl);
-  XFillRectangle(theDisp, mainW, theGC, 0, ty, (u_int) w + 8, 
+  XFillRectangle(theDisp, mainW, theGC, 0, ty, (u_int) w + 8,
 		 (u_int) (monofinfo->ascent+monofinfo->descent) + 4);
   XSetForeground(theDisp, theGC, wh);
   XSetBackground(theDisp, theGC, bl);
@@ -2198,15 +2196,15 @@
 
     if (!XQueryPointer(theDisp,mainW,&rW,&cW,&rx,&ry,&x,&y,&mask)) continue;
     if (done1 && !(mask & Button2Mask)) break;    /* button released */
-    
+
     CoordE2P(x,y, &px, &py);
-    RANGE(px,0,pWIDE-1);  
+    RANGE(px,0,pWIDE-1);
     RANGE(py,0,pHIGH-1);
-    
+
     if (px!=ox || py!=oy || !done1) {  /* moved, or firsttime.  erase & draw */
       double h1, s1, v1;
       int    rval, gval, bval;
-      
+
       if (picType == PIC8) {
 	ecol = pix = pic[py * pWIDE + px];
 	rval = rcmap[pix];  gval = gcmap[pix];  bval = bcmap[pix];
@@ -2216,7 +2214,7 @@
 	gval = pic[py * pWIDE * 3 + px * 3 + 1];
 	bval = pic[py * pWIDE * 3 + px * 3 + 2];
       }
-      
+
       clearR = rval;  clearG = gval;  clearB = bval;
 
       rgb2hsv(rval, gval, bval, &h1, &s1, &v1);
@@ -2229,8 +2227,8 @@
 	      px, py, rval, gval, bval, rval, gval, bval,
 	      (int) h1, (int) (s1 * 100), (int) (v1 * 100),
 	      px-orgx, py-orgy);
-      
-      XDrawImageString(theDisp,mainW,theGC, 4, ty + 2 + monofinfo->ascent, 
+
+      XDrawImageString(theDisp,mainW,theGC, 4, ty + 2 + monofinfo->ascent,
 		       foo, (int) strlen(foo));
       ox = px;  oy = py;
       done1 = 1;
@@ -2275,7 +2273,7 @@
 
   /* returns true if there's a config event in which mainW changes size
      in the event queue */
-  
+
   XSync(theDisp, False);
   foo = 0;
   XCheckIfEvent(theDisp, &ev, IsConfig, &foo);
@@ -2328,7 +2326,7 @@
    *    BadMatch  errors on XGetImage
    */
 
-  if ((xerrcode == BadAlloc)                                               || 
+  if ((xerrcode == BadAlloc)                                               ||
       (xerrcode == BadAccess && err->request_code==88 /* X_FreeColors */ ) ||
       (err->request_code == 113                       /* X_KillClient */ ) ||
       (xerrcode == BadLength && err->request_code==18 /* X_ChangeProp */ ) ||
@@ -2361,7 +2359,7 @@
 {
   /* but first, if any input-grabbing popups are active, we have to 'cancel'
      them. */
-  
+
   if (psUp) PSDialog(0);      /* close PS window */
 
 #ifdef HAVE_JPEG
@@ -2400,14 +2398,14 @@
   if (!pen) {
     Pixmap      pix, pmask;
     XColor      cfg, cbg;
-    
+
     cfg.red = cfg.green = cfg.blue = 0x0000;
     cbg.red = cbg.green = cbg.blue = 0xffff;
-    
+
     pix = MakePix1(rootW, pen_bits,  pen_width,  pen_height);
     pmask= MakePix1(rootW, penm_bits, penm_width, penm_height);
-    if (pix && pmask) 
-      pen = XCreatePixmapCursor(theDisp, pix, pmask, &cfg, &cbg, 
+    if (pix && pmask)
+      pen = XCreatePixmapCursor(theDisp, pix, pmask, &cfg, &cbg,
 				    pen_x_hot, pen_y_hot);
     if (pix)   XFreePixmap(theDisp, pix);
     if (pmask) XFreePixmap(theDisp, pmask);
@@ -2416,7 +2414,7 @@
   if (pen) XDefineCursor(theDisp, mainW, pen);
 
 
-  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask 
+  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask
 	       | StructureNotifyMask /* | ButtonPressMask */
 	       | KeyReleaseMask | ColormapChangeMask
 	       | EnterWindowMask | LeaveWindowMask );
@@ -2435,7 +2433,7 @@
 
     switch (state) {
     case 0:               /* initial state:  make sure we do one pixel */
-      px1 = lx = px;  py1 = ly = py;  
+      px1 = lx = px;  py1 = ly = py;
       paintPixel(px, py);
 
       if      (nmask & ShiftMask  ) state = 99;
@@ -2444,7 +2442,7 @@
       else                          state = 10;
       break;
 
-      
+
     case 1:               /* waiting for click */
       if      (nmask & ShiftMask) state = 99;
       else if ( mask & Button2Mask) {
@@ -2459,7 +2457,7 @@
       }
       break;
 
-      
+
     case 10:               /* in freehand drawing mode */
       if      (nmask & ShiftMask  ) state = 99;
       else if (nmask & Button2Mask) state = 1;
@@ -2507,11 +2505,11 @@
 	  XSync(theDisp, False);
 	  Timer(100);
 	}
-	  
+
 	if (nmask & Button2Mask) seenRelease = 1;
       }
       break;
-      
+
     case 99:              /* EXIT loop:  cleanup */
       if (line) { /* erase old xor-line */
 	paintXLine(lx, ly, px1, py1, 0);
@@ -2521,11 +2519,11 @@
       break;
     }
   }
-    
-  
+
+
   WaitCursor();
-  
-  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask 
+
+  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask
 	       | StructureNotifyMask | ButtonPressMask
 	       | KeyReleaseMask | ColormapChangeMask
 	       | EnterWindowMask | LeaveWindowMask );
@@ -2557,17 +2555,17 @@
     byte *pp = pic + (y * pWIDE + x) * 3;
     pp[0] = clearR;  pp[1] = clearG;  pp[2] = clearB;
   }
-  
+
   /* visual feedback */
   CoordP2E(x,   y,   &ex,  &ey);
   CoordP2E(x+1, y+1, &ex1, &ey1);
-  
+
   ew = ex1-ex;  eh = ey1-ey;
-  
+
   if (picType == PIC8) XSetForeground(theDisp, theGC, cols[editColor]);
   else XSetForeground(theDisp, theGC, RGBToXColor(clearR, clearG, clearB));
-  
-  if (ew>0 && eh>0) 
+
+  if (ew>0 && eh>0)
     XFillRectangle(theDisp,mainW,theGC, ex,ey, (u_int) ew, (u_int) eh);
 }
 
@@ -2577,7 +2575,7 @@
   int x,y,x1,y1;
 {
   int dx,dy,i,lx,ly,adx,ady;
-  
+
   dx = x1-x;  dy = y1-y;
   adx = abs(dx);  ady = abs(dy);
 
@@ -2598,7 +2596,7 @@
       paintPixel(lx,ly);
     }
   }
-  
+
 
 }
 
@@ -2618,14 +2616,14 @@
   CoordP2E(x+1,y+1,&tx1,&ty1);
   ex = tx + (tx1 - tx)/2;
   ey = ty + (ty1 - ty)/2;
-  
+
   CoordP2E(x1,  y1,  &tx, &ty);
   CoordP2E(x1+1,y1+1,&tx1,&ty1);
   ex1 = tx + (tx1 - tx)/2;
   ey1 = ty + (ty1 - ty)/2;
-  
+
   if (ex==ex1 && ey==ey1) return;
-  
+
   XSetPlaneMask(theDisp, theGC, xorMasks[pntxlcol]);
   XSetFunction(theDisp, theGC, GXinvert);
   XDrawLine(theDisp, mainW, theGC, ex, ey, ex1, ey1);
@@ -2638,10 +2636,8 @@
 static void BlurPaint()
 {
   Window  rW,cW;
-  int     rx,ry,ox,oy,x,y, px,py, ex,ey, ex1,ey1, ew, eh, done1, dragging;
-  int     uppedpic;
+  int     rx,ry,ox,oy,x,y, px,py, done1, dragging;
   u_int   mask;
-  byte   *pp;
 
   /* blurs pixels in either editCol (PIC8) or clear{R,G,B} (PIC24) until
      'shift' key is released.  */
@@ -2653,14 +2649,14 @@
   if (!blur) {
     Pixmap      pix, mask;
     XColor      cfg, cbg;
-    
+
     cfg.red = cfg.green = cfg.blue = 0x0000;
     cbg.red = cbg.green = cbg.blue = 0xffff;
-    
+
     pix = MakePix1(rootW, blur_bits,  blur_width,  blur_height);
     mask= MakePix1(rootW, blurm_bits, blurm_width, blurm_height);
-    if (pix && mask) 
-      blur = XCreatePixmapCursor(theDisp, pix, mask, &cfg, &cbg, 
+    if (pix && mask)
+      blur = XCreatePixmapCursor(theDisp, pix, mask, &cfg, &cbg,
 				    blur_x_hot, blur_y_hot);
     if (pix)  XFreePixmap(theDisp, pix);
     if (mask) XFreePixmap(theDisp, mask);
@@ -2669,7 +2665,7 @@
   if (blur) XDefineCursor(theDisp, mainW, blur);
 
 
-  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask 
+  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask
 	       | StructureNotifyMask /* | ButtonPressMask */
 	       | KeyReleaseMask | ColormapChangeMask
 	       | EnterWindowMask | LeaveWindowMask );
@@ -2682,12 +2678,12 @@
     if (!(mask & Button3Mask)) { dragging = 0;  continue; }
 
     CoordE2P(x,y, &px, &py);
-    
+
     if (!dragging || (dragging && (px!=ox || py!=oy))) {  /* click or drag */
       if (!dragging) blurPixel(px,py);
       else {
 	int dx,dy,i,lx,ly;
-	
+
 	dx = px-ox;  dy = py-oy;   /* at least one will be non-zero */
 	if (abs(dx) > abs(dy)) {   /* X is major axis */
 	  for (i=0; i<=abs(dx); i++) {
@@ -2707,10 +2703,10 @@
       done1 = 1;  dragging = 1;  ox = px;  oy = py;
     }
   }
-  
+
   WaitCursor();
-  
-  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask 
+
+  XSelectInput(theDisp, mainW, ExposureMask | KeyPressMask
 	       | StructureNotifyMask | ButtonPressMask
 	       | KeyReleaseMask | ColormapChangeMask
 	       | EnterWindowMask | LeaveWindowMask );
@@ -2731,9 +2727,9 @@
 {
   /* returns position of highest set bit in 'ul' as an integer (0-31),
      or -1 if none */
-  
+
   int i;  unsigned long hb;
-  
+
   hb = 0x80;  hb = hb << 24;   /* hb = 0x80000000UL */
   for (i=31; ((ul & hb) == 0) && i>=0;  i--, ul<<=1);
   return i;
@@ -2757,7 +2753,7 @@
 
     d = 3*(256*256);  j=0;
     for (i=0; i<numcols; i++) {
-      di = ((r-rMap[i]) * (r-rMap[i])) + 
+      di = ((r-rMap[i]) * (r-rMap[i])) +
 	   ((g-gMap[i]) + (g-gMap[i])) +
            ((b-bMap[i]) * (b-bMap[i]));
       if (i==0 || di<d) { j=i;  d=di; }
@@ -2771,45 +2767,45 @@
     if (theVisual->class==TrueColor || theVisual->class==DirectColor) {
       unsigned long rmask, gmask, bmask;
       int           rshift, gshift, bshift, cshift, maplen;
-      
+
       /* compute various shifting constants that we'll need... */
-      
+
       rmask = theVisual->red_mask;
       gmask = theVisual->green_mask;
       bmask = theVisual->blue_mask;
-      
+
       rshift = 7 - highbit(rmask);
       gshift = 7 - highbit(gmask);
       bshift = 7 - highbit(bmask);
-      
+
       if (theVisual->class == DirectColor) {
 	maplen = theVisual->map_entries;
 	if (maplen>256) maplen=256;
 	cshift = 7 - highbit((u_long) (maplen-1));
-	
+
 	r = (u_long) directConv[(r>>cshift) & 0xff] << cshift;
 	g = (u_long) directConv[(g>>cshift) & 0xff] << cshift;
 	b = (u_long) directConv[(b>>cshift) & 0xff] << cshift;
       }
-      
-      
+
+
       /* shift the bits around */
       if (rshift<0) r = r << (-rshift);
       else r = r >> rshift;
-      
+
       if (gshift<0) g = g << (-gshift);
       else g = g >> gshift;
-      
+
       if (bshift<0) b = b << (-bshift);
       else b = b >> bshift;
-      
+
       r = r & rmask;
       g = g & gmask;
       b = b & bmask;
-      
+
       rv =r | g | b;
     }
-    
+
     else {                          /* non-TrueColor/DirectColor visual */
       if (!ncols)
 	rv = ((r + g + b >= 128*3) ? white : black);
@@ -2820,14 +2816,14 @@
 
   return rv;
 }
-      
-    
+
+
 /***********************/
 static void blurPixel(x,y)
      int x,y;
 {
   /* blurs pixel x,y (pic coords) into pic in editColor (PIC8) or clearR,G,B
-     (PIC24) and does appropriate screen feedback.  Does a 3x3 average 
+     (PIC24) and does appropriate screen feedback.  Does a 3x3 average
      around the pixel, and replaces it with the average value (PIC24), or
      the closest existing color to the average value (PIC8) */
 
@@ -2861,7 +2857,7 @@
   if (picType == PIC8) {  /* find nearest actual color */
     d = 3*(256*256);  j=0;
     for (i=0; i<numcols; i++) {
-      di = ((ar-rMap[i]) * (ar-rMap[i])) + 
+      di = ((ar-rMap[i]) * (ar-rMap[i])) +
 	   ((ag-gMap[i]) + (ag-gMap[i])) +
            ((ab-bMap[i]) * (ab-bMap[i]));
       if (i==0 || di<d) { j=i;  d=di; }
@@ -2874,17 +2870,17 @@
     pp = pic + (y * pWIDE + x) * 3;
     pp[0] = ar;  pp[1] = ag;  pp[2] = ab;
   }
-  
+
   /* visual feedback */
   CoordP2E(x,   y,   &ex,  &ey);
   CoordP2E(x+1, y+1, &ex1, &ey1);
-  
+
   ew = ex1-ex;  eh = ey1-ey;
-  
+
   if (picType == PIC8) XSetForeground(theDisp, theGC, cols[ac]);
   else XSetForeground(theDisp, theGC, RGBToXColor(ar, ag, ab));
-  
-  if (ew>0 && eh>0) 
+
+  if (ew>0 && eh>0)
     XFillRectangle(theDisp,mainW,theGC, ex,ey, (u_int) ew, (u_int) eh);
 }
 
@@ -2901,13 +2897,13 @@
   static char  buf[256] = {'\0'};
   static char *labels[] = {"\nOk", "\033Cancel" };
 
-  sprintf(txt, "Image Annotation:\n\n%s", 
+  sprintf(txt, "Image Annotation:\n\n%s",
 	  "Enter string to be placed on image.");
-  
+
   i = GetStrPopUp(txt, labels, 2, buf, 256, "", 0);
   if (i==1 || strlen(buf)==0) return;
-  
-  
+
+
   /* build a 'cimg' array to be pasted on clipboard */
   w = strlen(buf) * 6 - 1;  h = 9;
   len = CIMG_PIC8 + w*h;
diff -ruN xv-3.10a/xvfits.c xv-3.10a-bugfixes/xvfits.c
--- xv-3.10a/xvfits.c	1994-12-27 23:43:29.000000000 -0800
+++ xv-3.10a-bugfixes/xvfits.c	2005-04-02 21:08:45.000000000 -0800
@@ -63,7 +63,7 @@
   /* returns '1' on success */
 
   FITS  fs;
-  int   i, nx, ny, nz, bitpix, np, nrd, ioerror;
+  int   i, nx, ny, nz, bitpix, nrd, ioerror, npixels, bufsize;
   byte *image;
   char *error;
   char  basename[64];
@@ -72,7 +72,7 @@
     fits_block = (char *) malloc((size_t) BLOCKSIZE);
     if (!fits_block) FatalError("Insufficient memory for FITS block buffer");
   }
-  
+
   error = ftopen3d(&fs, fname, &nx, &ny, &nz, &bitpix);
   if (error) {
     SetISTR(ISTR_WARNING, "%s", error);
@@ -80,9 +80,15 @@
   }
 
   if (quick) nz = 1;             /* only load first plane */
-  np = nx * ny * nz;
+  npixels = nx * ny;
+  bufsize = nz * npixels;
+  if (nx <= 0 || ny <= 0 || npixels/nx != ny || bufsize/nz != npixels) {
+    SetISTR(ISTR_WARNING, "FITS image dimensions out of range (%dx%dx%d)",
+      nx, ny, nz);
+    return 0;
+  }
 
-  image = (byte *) malloc((size_t) np);
+  image = (byte *) malloc((size_t) bufsize);
   if (!image) FatalError("Insufficient memory for image");
 
   /*
@@ -90,7 +96,7 @@
    * to ensure that we get that same scaling for all planes.
    */
 
-  nrd     = ftgbyte(&fs, image, np);
+  nrd     = ftgbyte(&fs, image, bufsize);
   ioerror = ferror(fs.fp);
   ftclose(&fs);
 
@@ -104,33 +110,32 @@
     return 0;
   }
 
-  else if (nrd < np) {       /* read partial image */
+  else if (nrd < bufsize) {       /* read partial image */
     if (ioerror)
       SetISTR(ISTR_WARNING, "%s", "Truncated FITS file due to I/O error");
     else
       SetISTR(ISTR_WARNING, "%s", "Truncated FITS file");
-    
+
     { byte *foo;
-      for (foo=image+nrd; foo<image+np; foo++) *foo=0x80;  /* pad with grey */
+      for (foo=image+nrd; foo<image+bufsize; foo++) *foo=0x80;  /* pad with grey */
     }
   }
 
   if (nz > 1) {
     /* how many planes do we actually have? */
-    nz = (nrd-1)/(nx*ny) + 1;
+    nz = (nrd-1)/(npixels) + 1;
 
     /* returns how many sub-files created */
     nz = splitfits(image, fs.comment, nx, ny, nz, basename);
-    np = nx * ny;
-    image = (byte *)realloc(image, (size_t) np);  /* toss all but first */
+    image = (byte *)realloc(image, (size_t) npixels);  /* toss all but first */
   }
-  
+
   /* There seems to be a convention that fits files be displayed using
    * a cartesian coordinate system. Thus the first pixel is in the lower left
    * corner. Fix this by reflecting in the line y=ny/2.
    */
   flip(image, nx, ny);
-  
+
   /* Success! */
   pinfo->pic  = image;
   pinfo->type = PIC8;
@@ -149,12 +154,12 @@
     pinfo->numpages = nz;
     strcpy(pinfo->pagebname, basename);
   }
-  
+
   return 1;
-}  
+}
+
 
 
-	  
 /*******************************************/
 int WriteFITS(fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,comment)
      FILE *fp;
@@ -164,16 +169,16 @@
      int   numcols, colorstyle;
      char *comment;
 {
-  int   i, j, np, nend;
+  int   i, j, npixels, nend;
   byte *ptr;
   char *error;
   byte  rgb[256];
-  
+
   if (!fits_block) {
     fits_block = (char *) malloc((size_t) BLOCKSIZE);
     if (!fits_block) FatalError("Insufficient memory for FITS block buffer");
   }
-  
+
   error = wrheader(fp, w, h, comment);
   if (error) {
     SetISTR(ISTR_WARNING, "%s", error);
@@ -197,12 +202,12 @@
     }
   }
 
-  np = w*h;
+  npixels = w*h;
 
   /* nend is the number of padding characters at the end of the last block */
-  nend = ((np+BLOCKSIZE-1)/BLOCKSIZE)*BLOCKSIZE - np;
+  nend = ((npixels+BLOCKSIZE-1)/BLOCKSIZE)*BLOCKSIZE - npixels;
   if (nend) for (i=0; i<nend; i++) putc('\0', fp);
-  
+
   return 0;
 }
 
@@ -216,17 +221,16 @@
      char *basename;
 {
   /*
-   * Given a 3 dimensional FITS image, this splits it up into nz 2-d files.
+   * Given a 3-dimensional FITS image, this splits it up into nz 2-d files.
    * It returns the number of files actually stored.
    * If only one file could be written, then no split files are created.
    * It returns the basename of the split files in bname.
    * If there was a problem writing files, then a error message will be set.
    */
-  
-  int   i, np=nx * ny, ioerror, nwrt;
+
+  int   i, npixels=nx * ny, nwrt;
   FILE *fp;
   char *error;
-  byte *work;
   char  filename[70];
 
 #ifndef VMS
@@ -234,8 +238,12 @@
 #else
   sprintf(basename, "Sys$Disk:[]xvpgXXXXXX");
 #endif
-  
+
+#ifdef USE_MKSTEMP
+  close(mkstemp(basename));
+#else
   mktemp(basename);
+#endif
   if (basename[0] == '\0') {
     SetISTR(ISTR_WARNING, "%s", "Unable to build temporary filename");
     return 1;
@@ -251,7 +259,7 @@
       error = "Unable to open temporary file";
       break;
     }
-    
+
     if (wrheader(fp, nx, ny, comment)) {
       error = "I/O error writing temporary file";
       fclose(fp);
@@ -259,15 +267,15 @@
       break;
     }
 
-    nwrt = fwrite(image+i*np, sizeof(byte), (size_t) np, fp);
+    nwrt = fwrite(image+i*npixels, sizeof(byte), (size_t) npixels, fp);
     fclose(fp);
 
     if (nwrt == 0) {  /* failed to write any data */
       error = "I/O error writing temporary file";
       unlink(filename);
       break;
-    } 
-    else if (nwrt < np)
+    }
+    else if (nwrt < npixels)
       error = "I/O error writing temporary file";
   }
 
@@ -291,13 +299,13 @@
      char *comment;
 {
   /* Writes a minimalist FITS file header */
-  
+
   char *block = fits_block, *bp;
-  int   i, j, wrotehist, lenhist;
+  int   i, j, lenhist;
   char  history[80];
 
   for (i=0, bp=block; i<BLOCKSIZE; i++, bp++) *bp = ' ';
-  
+
   sprintf(history, "Written by XV %s", VERSTR);
   lenhist = strlen(history);
 
@@ -309,7 +317,7 @@
   wrcard(&block[80*i++], "NAXIS2", T_INT, ny, NULL);  /* write NAXIS2 card */
 
   /* Write HISTORY keyword */
-  wrcard(&block[80*i++], "HISTORY", T_STR, lenhist, history); 
+  wrcard(&block[80*i++], "HISTORY", T_STR, lenhist, history);
 
   if (comment && *comment != '\0') {
     while (*comment == '\n') comment++;  /* Skip any blank lines */
@@ -317,7 +325,7 @@
       for (j=0; j<72; j++)
 	if (comment[j] == '\0' || comment[j] == '\n') break;
 
-      /* 
+      /*
        * Check to see if it is an xv history record; if so, then avoid
        * duplicating it.
        */
@@ -330,7 +338,7 @@
 	for (i=0, bp=block; i<BLOCKSIZE; i++, bp++) *bp = ' ';
 	i = 0;
       }
-      
+
       comment += j;
       while (*comment == '\n') comment++;  /* Skip any blank lines */
     }
@@ -358,40 +366,40 @@
    * Will return an error message if the primary data unit is not a
    * 2 or 3-dimensional array.
    */
-  
+
   FILE *fp;
   int naxis, i;
   char *error;
-  
+
   fp = xv_fopen(file, "r");
   if (!fp) return "Unable to open FITS file";
-  
+
   fs->fp     = fp;
   fs->bitpix = 0;
   fs->naxis  = 0;
   fs->cpos   = 0;
-  
+
   /* read header */
   error = rdheader(fs);
   if (error) {
     ftclose(fs);
     return error;
   }
-  
+
   naxis = fs->naxis;
-  
+
   /* get number of data */
   fs->ndata = 1;
-  for (i=0; i<naxis; i++) 
+  for (i=0; i<naxis; i++)
     fs->ndata = fs->ndata * fs->axes[i];
-  
+
   *nx = fs->axes[0];
   *ny = fs->axes[1];
   if (naxis == 2) *nz = 1;
              else *nz = fs->axes[2];
-  
+
   *bitpix = fs->bitpix;
-  
+
   return NULL;
 }
 
@@ -418,11 +426,11 @@
   char *block=fits_block, *p;
   char *error;
   long int val;         /* the value */
-  
+
   fs->comment = NULL;
   commlen     = 0;
   commsize    = 256;
-  
+
   res = fread(block, sizeof(char), (size_t) BLOCKSIZE, fs->fp);
   if (res != BLOCKSIZE) return "Error reading FITS file";
   i = 0;
@@ -464,13 +472,13 @@
       if (res != BLOCKSIZE) return "Error reading FITS file";
       i = 0;
     }
-    
+
     sprintf(name, "NAXIS%d", j+1);
     error = rdcard(&block[i*80], name, T_INT, &val);
     if (error)    return error;
     if (val < 0)  return "Bad NAXISn value in FITS file";
     if (val == 0) return "FITS file does not contain an image";
-    
+
     if (j < 3)    fs->axes[j] = val;
     else if (val != 1) return "FITS file has more than three dimensions";
     i++;
@@ -488,21 +496,21 @@
       if (res != BLOCKSIZE) return "Unexpected eof in FITS file";
       i = 0;
     }
-    
+
     p = &block[i*80];
     if (strncmp(p, "END     ", (size_t) 8) == 0) break;
-    if (strncmp(p, "HISTORY ", (size_t) 8) == 0 || 
+    if (strncmp(p, "HISTORY ", (size_t) 8) == 0 ||
 	strncmp(p, "COMMENT ", (size_t) 8) == 0) {
       p += 8;                       /* skip keyword */
       for (j=71; j >= 0; j--) if (p[j] != ' ') break;
       j++;                          /* make j length of comment */
       if (j > 0) {                  /* skip blank comment cards */
 	if (fs->comment == NULL) {
-	  fs->comment = (char *) malloc((size_t) commsize);
+	  fs->comment = (char *) malloc((size_t) commsize);  /* initially 256 */
 	  if (fs->comment == NULL)
 	    FatalError("Insufficient memory for comment buffer");
 	}
-	
+
 	if (commlen + j + 2 > commsize) { /* if too small */
 	  char *new;
 	  commsize += commsize;      /* double size of array */
@@ -515,7 +523,7 @@
 	  free(fs->comment);
 	  fs->comment = new;
 	}
-	
+
 	xvbcopy(p, &fs->comment[commlen], (size_t) j);  /* add string */
 	commlen += j;
 	fs->comment[commlen++] = '\n';       /* with trailing cr */
@@ -556,9 +564,9 @@
 
   l = strlen(name);
   if (l) xvbcopy(name, card, (size_t) l);   /* copy name */
-  
+
   if (dtype == T_NOVAL) return;
-  
+
   if (dtype == T_STR) {
     l = kvalue;
     if (l <= 0) return;
@@ -566,9 +574,9 @@
     xvbcopy(svalue, &card[8], (size_t) l);
     return;
   }
-  
+
   card[8] = '=';
-  
+
   if (dtype == T_LOG)
     card[29] = kvalue ? 'T' : 'F';
   else { /* T_INT */
@@ -599,7 +607,7 @@
   int         i, ptr;
   char        namestr[9];
   static char error[45];
-  
+
   xvbcopy(card, namestr, (size_t) 8);
 
   for (i=7; i>=0 && namestr[i] == ' '; i--);
@@ -609,24 +617,24 @@
     sprintf(error, "Keyword %s not found in FITS file", name);
     return error;
   }
-  
+
 
   /* get start of value */
   ptr = 10;
   while (ptr < 80 && card[ptr] == ' ') ptr++;
   if (ptr == 80) return "FITS file has missing keyword value"; /* no value */
-  
+
   if (dtype == T_LOG) {
     if (ptr != 29 || (card[29] != 'T' && card[29] != 'F'))
       return "Keyword has bad logical value in FITS file";
     *kvalue = (card[29] == 'T');
-  } 
+  }
 
   else {  /* an integer */
     int j;
     long int ival;
     char num[21];
-    
+
     if (ptr > 29) return "Keyword has bad integer value in FITS file";
     xvbcopy(&card[ptr], num, (size_t) (30-ptr));
     num[30-ptr] = '\0';
@@ -634,7 +642,7 @@
     if (j != 1) return "Keyword has bad integer value in FITS file";
     *kvalue = ival;
   }
-  
+
   return NULL;
 }
 
@@ -660,13 +668,13 @@
    */
 
   int res;
-  
+
   if (nelem == 0) return 0;
-  
+
   res = fread(buffer, (size_t) fs->size, (size_t) nelem, fs->fp);
   /* if failed to read all the data because at end of file */
   if (res != nelem && feof(fs->fp)) {
-    /* nblock is the number of elements in a record. 
+    /* nblock is the number of elements in a record.
        size is always a factor of BLOCKSIZE */
 
     int loffs, nblock=BLOCKSIZE/fs->size;
@@ -714,7 +722,7 @@
   byte *ptr=buffer;
 
   /*
-   * conversions. Although the data may be signed, reverse using unsigned 
+   * conversions. Although the data may be signed, reverse using unsigned
    * variables.
    * Because the native int types may be larger than the types in the file,
    * we start from the end and work backwards to avoid overwriting data
@@ -741,12 +749,12 @@
 	      ((unsigned int)ptr[2] << 8)  |
 	      ((unsigned int)ptr[3]);
   }
-  
+
   /* convert from IEE 754 single precision to native form */
   else if (fs->bitpix == -32) {
     int j, k, expo;
     static float *exps=NULL;
-    
+
     if (exps == NULL) {
       exps = (float *)malloc(256 * sizeof(float));
       if (exps == NULL) FatalError("Insufficient memory for exps store");
@@ -754,7 +762,7 @@
       for (i=151; i < 256; i++) exps[i] = 2.*exps[i-1];
       for (i=149; i >= 0; i--) exps[i] = 0.5*exps[i+1];
     }
-	      
+
     for (i=0; i < n; i++, ptr+=4) {
       k = (int)*ptr;
       j = ((int)ptr[1] << 16) | ((int)ptr[2] << 8) | (int)ptr[3];
@@ -765,13 +773,13 @@
     }
 
   }
-  
+
   /* convert from IEE 754 double precision to native form */
   else if (fs->bitpix == -64) {
     int expo, k, l;
     unsigned int j;
     static double *exps=NULL;
-    
+
     if (exps == NULL) {
       exps = (double *)malloc(2048 * sizeof(double));
       if (exps == NULL) FatalError("Insufficient memory for exps store");
@@ -779,7 +787,7 @@
       for (i=1076; i < 2048; i++) exps[i] = 2.*exps[i-1];
       for (i=1074; i >= 0; i--) exps[i] = 0.5*exps[i+1];
     }
-	      
+
     for (i=0; i < n; i++, ptr+=8) {
       k = (int)*ptr;
       j = ((unsigned int)ptr[1] << 24) | ((unsigned int)ptr[2] << 16) |
@@ -813,23 +821,36 @@
    */
 
   void *voidbuff;
-  int i, n, nrd;
+  int i, n, nrd, bufsize, overflow=0;
 
   /* if the data is byte, then read it directly */
   if (fs->bitpix == 8)
     return ftgdata(fs, cbuff, nelem);
-  
+
   /* allocate a buffer to store the image */
-  if (fs->bitpix == 16)
-    voidbuff = (void *)malloc(nelem * sizeof(short int));
-  else if (fs->bitpix == 32)
-    voidbuff = (void *)malloc(nelem * sizeof(int));
-  else
-    voidbuff = (void *)malloc(nelem * (size_t) fs->size);  /* float, double */
+  if (fs->bitpix == 16) {
+    bufsize = nelem * sizeof(short int);
+    if (bufsize/nelem != (int)sizeof(short int))
+      overflow = 1;
+  } else if (fs->bitpix == 32) {
+    bufsize = nelem * sizeof(int);
+    if (bufsize/nelem != (int)sizeof(short int))
+      overflow = 1;
+  } else {
+    bufsize = nelem * fs->size;  /* float, double */
+    if (bufsize/nelem != fs->size)
+      overflow = 1;
+  }
 
+  if (overflow) {
+    SetISTR(ISTR_WARNING, "FITS image dimensions out of range");
+    return 0;
+  }
+
+  voidbuff = (void *)malloc((size_t) bufsize);
   if (voidbuff == NULL) {
     char emess[60];
-    sprintf(emess, "Insufficient memory for raw image of %d bytes", 
+    sprintf(emess, "Insufficient memory for raw image of %d bytes",
 	    nelem*fs->size);
     FatalError(emess);
   }
@@ -843,28 +864,28 @@
     short int *buffer=voidbuff;
     int max, min, maxmin_t;
     float scale;
-    
+
     min = max = buffer[0];
     for (i=1; i < n; i++, buffer++) maxmin(*buffer, max, min);
     scale = (max == min) ? 0. : 255./(float)(max-min);
-    
+
     /* rescale and convert */
     for (i=0, buffer=voidbuff; i < n; i++)
       cbuff[i] = (byte)(scale*(float)((int)buffer[i]-min));
-    
+
     /* convert long int to byte */
-  } 
+  }
 
   else if (fs->bitpix == 32) {
     int *buffer=voidbuff;
     int max, min, maxmin_t;
     float scale, fmin;
-    
+
     min = max = buffer[0];
     for (i=1; i < n; i++, buffer++) maxmin(*buffer, max, min);
     scale = (max == min) ? 1. : 255./((double)max-(double)min);
     fmin = (float)min;
-    
+
     /* rescale and convert */
     if (scale < 255./2.1e9) /* is max-min too big for an int ? */
       for (i=0, buffer=voidbuff; i < n; i++)
@@ -872,34 +893,34 @@
     else /* use integer subtraction */
       for (i=0, buffer=voidbuff; i < n; i++)
 	cbuff[i] = (byte)(scale*(float)(buffer[i]-min));
-    
-   
-  } 
+
+
+  }
 
   /* convert float to byte */
   else if (fs->bitpix == -32) {
     float *buffer=voidbuff;
     float max, min, maxmin_t, scale;
-    
+
     min = max = buffer[0];
     for (i=1; i < n; i++, buffer++) maxmin(*buffer, max, min);
     scale = (max == min) ? 0. : 255./(max-min);
-    
+
     /* rescale and convert */
     for (i=0, buffer=voidbuff; i < n; i++)
       cbuff[i] = (byte)(scale*(buffer[i]-min));
-    
-  } 
+
+  }
 
   /* convert double to byte */
   else if (fs->bitpix == -64) {
     double *buffer=voidbuff;
     double max, min, maxmin_t, scale;
-    
+
     min = max = buffer[0];
     for (i=1; i < n; i++, buffer++) maxmin(*buffer, max, min);
     scale = (max == min) ? 0. : 255./(max-min);
-    
+
     /* rescale and convert */
     for (i=0, buffer=voidbuff; i < n; i++)
       cbuff[i] = (byte)(scale*(buffer[i]-min));
@@ -923,7 +944,7 @@
   int i;
   int j, v;
   byte *buff1, *buff2;
-  
+
   for (i=0; i < ny/2; i++) {
     buff1 = &buffer[i*nx];
     buff2 = &buffer[(ny-1-i)*nx];
diff -ruN xv-3.10a/xvgam.c xv-3.10a-bugfixes/xvgam.c
--- xv-3.10a/xvgam.c	1995-01-13 11:51:14.000000000 -0800
+++ xv-3.10a-bugfixes/xvgam.c	2004-05-16 18:02:11.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * xvgam.c
  *
  * callable functions:
@@ -87,7 +87,7 @@
 		  GRAF_STATE istate, rstate, gstate, bstate;
 		};
 
-static struct gamstate undo[MAXUNDO], preset[4], defstate; 
+static struct gamstate undo[MAXUNDO], preset[4], defstate;
 static struct gamstate *defLoadState;
 
 static int uptr, uhead, utail;
@@ -153,7 +153,7 @@
 static void dragHueDial      PARM((void));
 static void dragEditColor    PARM((void));
 
-static void HDCreate         PARM((HDIAL *, Window, int, int, int, int, 
+static void HDCreate         PARM((HDIAL *, Window, int, int, int, int,
 				   int, int, char *, u_long, u_long));
 
 static void HDRedraw         PARM((HDIAL *, int));
@@ -212,13 +212,13 @@
 {
   XSetWindowAttributes xswa;
 
-  gamW = CreateWindow("xv color editor", "XVcedit", geom, 
+  gamW = CreateWindow("xv color editor", "XVcedit", geom,
 		      GAMW, GAMH, infofg,infobg, 0);
   if (!gamW) FatalError("can't create cedit window!");
-  
+
   cmapF = XCreateSimpleWindow(theDisp,gamW, 10,   8,CMAPF_WIDE,CMAPF_HIGH,
 			      1,infofg,infobg);
-  butF  = XCreateSimpleWindow(theDisp,gamW, 10, 336,BUTF_WIDE,BUTF_HIGH, 
+  butF  = XCreateSimpleWindow(theDisp,gamW, 10, 336,BUTF_WIDE,BUTF_HIGH,
 			      1,infofg,infobg);
   modF  = XCreateSimpleWindow(theDisp,gamW, 10, 438,MODF_WIDE,MODF_HIGH,
 			      1,infofg,infobg);
@@ -227,7 +227,7 @@
   rgbF  = XCreateSimpleWindow(theDisp,gamW, 467,  8,RGBF_WIDE,RGBF_HIGH,
 			      1,infofg,infobg);
 
-  if (!cmapF || !butF || !modF || !hsvF || !rgbF) 
+  if (!cmapF || !butF || !modF || !hsvF || !rgbF)
     FatalError("couldn't create frame windows");
 
 #ifdef BACKING_STORE
@@ -251,25 +251,25 @@
   /********** COLORMAP editing doo-wahs ***********/
 
 
-  BTCreate(&gbut[G_BCOLUNDO], cmapF, 5, 165, 66, BUTTH, 
+  BTCreate(&gbut[G_BCOLUNDO], cmapF, 5, 165, 66, BUTTH,
 	   "ColUndo", infofg, infobg, hicol, locol);
-  BTCreate(&gbut[G_BCOLREV], cmapF,  5 + 66 + 1, 165, 67, BUTTH, 
+  BTCreate(&gbut[G_BCOLREV], cmapF,  5 + 66 + 1, 165, 67, BUTTH,
 	   "Revert", infofg, infobg, hicol, locol);
-  BTCreate(&gbut[G_BHSVRGB], cmapF,  5+66+67+2,  165, 66, BUTTH, 
+  BTCreate(&gbut[G_BHSVRGB], cmapF,  5+66+67+2,  165, 66, BUTTH,
 	   "RGB/HSV", infofg, infobg, hicol, locol);
 
-  BTCreate(&gbut[G_BMONO], cmapF,    5, 189, 66, BUTTH, 
+  BTCreate(&gbut[G_BMONO], cmapF,    5, 189, 66, BUTTH,
 	   "Grey", infofg, infobg, hicol, locol);
-  BTCreate(&gbut[G_BRV],   cmapF,    5 + 66 + 1, 189, 67, BUTTH, 
+  BTCreate(&gbut[G_BRV],   cmapF,    5 + 66 + 1, 189, 67, BUTTH,
 	   "RevVid", infofg, infobg, hicol, locol);
-  BTCreate(&gbut[G_BRNDCOL], cmapF,  5 + 66 + 67 + 2, 189, 66, BUTTH, 
+  BTCreate(&gbut[G_BRNDCOL], cmapF,  5 + 66 + 67 + 2, 189, 66, BUTTH,
 	   "Random", infofg, infobg, hicol, locol);
 
-  DCreate(&rhDial, cmapF, 5, 215, 66, 100,   0,360,180, 5, 
+  DCreate(&rhDial, cmapF, 5, 215, 66, 100,   0,360,180, 5,
 	  infofg, infobg, hicol, locol, "Hue", NULL);
-  DCreate(&gsDial, cmapF, 72, 215, 66, 100,  0,360,180, 5, 
+  DCreate(&gsDial, cmapF, 72, 215, 66, 100,  0,360,180, 5,
 	  infofg, infobg, hicol, locol, "Sat.", NULL);
-  DCreate(&bvDial, cmapF, 139, 215, 66, 100,   0,360,180, 5, 
+  DCreate(&bvDial, cmapF, 139, 215, 66, 100,   0,360,180, 5,
 	  infofg, infobg, hicol, locol, "Value", NULL);
 
   rhDial.drawobj = gsDial.drawobj = bvDial.drawobj = dragEditColor;
@@ -291,44 +291,44 @@
 #define BY2 (BY0 + BYSPACE*2)
 #define BY3 (BY0 + BYSPACE*3)
 
-  BTCreate(&gbut[G_BAPPLY],  butF, BX0,BY0, 52,BUTTH,"Apply", 
+  BTCreate(&gbut[G_BAPPLY],  butF, BX0,BY0, 52,BUTTH,"Apply",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_BNOGAM],  butF, BX0,BY1, 52,BUTTH,"NoMod", 
+  BTCreate(&gbut[G_BNOGAM],  butF, BX0,BY1, 52,BUTTH,"NoMod",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_BMAXCONT],butF, BX0,BY2, 52,BUTTH,"Norm",  
+  BTCreate(&gbut[G_BMAXCONT],butF, BX0,BY2, 52,BUTTH,"Norm",
 	   infofg,infobg,hicol,locol);
   BTCreate(&gbut[G_BHISTEQ], butF, BX0,BY3, 52,BUTTH,"HistEq",
 	   infofg,infobg,hicol,locol);
 
   BTCreate(&gbut[G_BUP_BR],butF, BX1,BY0, 52,BUTTH,"Brite",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_BDN_BR],butF, BX1,BY1, 52,BUTTH,"Dim",  
+  BTCreate(&gbut[G_BDN_BR],butF, BX1,BY1, 52,BUTTH,"Dim",
 	   infofg,infobg,hicol,locol);
   BTCreate(&gbut[G_BUP_CN],butF, BX1,BY2, 52,BUTTH,"Sharp",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_BDN_CN],butF, BX1,BY3, 52,BUTTH,"Dull", 
+  BTCreate(&gbut[G_BDN_CN],butF, BX1,BY3, 52,BUTTH,"Dull",
 	   infofg,infobg,hicol,locol);
 
-  BTCreate(&gbut[G_BRESET],butF, BX2,   BY0, 52,BUTTH,"Reset", 
+  BTCreate(&gbut[G_BRESET],butF, BX2,   BY0, 52,BUTTH,"Reset",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_B1],    butF, BX2,   BY1, 25,BUTTH,"1",    
+  BTCreate(&gbut[G_B1],    butF, BX2,   BY1, 25,BUTTH,"1",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_B2],    butF, BX2+26,BY1, 26,BUTTH,"2",    
+  BTCreate(&gbut[G_B2],    butF, BX2+26,BY1, 26,BUTTH,"2",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_B3],    butF, BX2,   BY2, 25,BUTTH,"3",    
+  BTCreate(&gbut[G_B3],    butF, BX2,   BY2, 25,BUTTH,"3",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_B4],    butF, BX2+26,BY2, 26,BUTTH,"4",    
+  BTCreate(&gbut[G_B4],    butF, BX2+26,BY2, 26,BUTTH,"4",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_BSET],  butF, BX2,   BY3, 52,BUTTH,"Set",  
+  BTCreate(&gbut[G_BSET],  butF, BX2,   BY3, 52,BUTTH,"Set",
 	   infofg,infobg,hicol,locol);
 
-  BTCreate(&gbut[G_BUNDO], butF, BX3, BY0, 52,BUTTH,"Undo",   
+  BTCreate(&gbut[G_BUNDO], butF, BX3, BY0, 52,BUTTH,"Undo",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_BREDO], butF, BX3, BY1, 52,BUTTH,"Redo",   
+  BTCreate(&gbut[G_BREDO], butF, BX3, BY1, 52,BUTTH,"Redo",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_BGETRES],butF,BX3, BY2, 52,BUTTH,"CutRes", 
+  BTCreate(&gbut[G_BGETRES],butF,BX3, BY2, 52,BUTTH,"CutRes",
 	   infofg,infobg,hicol,locol);
-  BTCreate(&gbut[G_BCLOSE],butF, BX3, BY3, 52,BUTTH,"Close",  
+  BTCreate(&gbut[G_BCLOSE],butF, BX3, BY3, 52,BUTTH,"Close",
 	   infofg,infobg,hicol,locol);
 
 
@@ -338,11 +338,11 @@
 
   CBCreate(&enabCB, modF,2,2,     "Display with HSV/RGB mods.",
 	   infofg,infobg,hicol,locol);
-  CBCreate(&autoCB, modF,2,2+17,  "Auto-apply HSV/RGB mods.",  
+  CBCreate(&autoCB, modF,2,2+17,  "Auto-apply HSV/RGB mods.",
 	   infofg,infobg,hicol,locol);
   CBCreate(&dragCB, modF,2,2+17*2,"Auto-apply while dragging.",
 	   infofg,infobg,hicol,locol);
-  CBCreate(&resetCB,modF,2,2+17*3,"Auto-reset on new image.",  
+  CBCreate(&resetCB,modF,2,2+17*3,"Auto-reset on new image.",
 	   infofg,infobg,hicol,locol);
 
   enabCB.val = autoCB.val = resetCB.val = dragCB.val = 1;
@@ -359,23 +359,23 @@
 
   srcHD.drawobj = dstHD.drawobj = whtHD.drawobj = dragHueDial;
 
-  DCreate(&satDial, hsvF, 100, 199, 100, 121, -100, 100, 0, 5, 
+  DCreate(&satDial, hsvF, 100, 199, 100, 121, -100, 100, 0, 5,
 	   infofg, infobg,hicol,locol, "Saturation", "%");
 
-  hueRB = RBCreate(NULL, hsvF,  7, 153, "1", 
+  hueRB = RBCreate(NULL, hsvF,  7, 153, "1",
 		   infofg, infobg,hicol,locol);
-  RBCreate        (hueRB,hsvF, 47, 153, "2", 
+  RBCreate        (hueRB,hsvF, 47, 153, "2",
 		   infofg, infobg,hicol,locol);
-  RBCreate        (hueRB,hsvF, 87, 153, "3", 
+  RBCreate        (hueRB,hsvF, 87, 153, "3",
 		   infofg, infobg,hicol,locol);
-  RBCreate        (hueRB,hsvF,  7, 170, "4", 
+  RBCreate        (hueRB,hsvF,  7, 170, "4",
 		   infofg, infobg,hicol,locol);
-  RBCreate        (hueRB,hsvF, 47, 170, "5", 
+  RBCreate        (hueRB,hsvF, 47, 170, "5",
 		   infofg, infobg,hicol,locol);
-  RBCreate        (hueRB,hsvF, 87, 170, "6", 
+  RBCreate        (hueRB,hsvF, 87, 170, "6",
 		   infofg, infobg,hicol,locol);
 
-  BTCreate(&hueclrB, hsvF, 127, 158, 70, BUTTH, "Reset", 
+  BTCreate(&hueclrB, hsvF, 127, 158, 70, BUTTH, "Reset",
 	   infofg, infobg,hicol,locol);
 
   initHmap();
@@ -394,13 +394,13 @@
 
   InitGraf(&gGraf);
   CreateGraf(&gGraf, rgbF, 10, 179, infofg, infobg, "Green");
-  
+
   InitGraf(&bGraf);
   CreateGraf(&bGraf, rgbF, 10, 338, infofg, infobg, "Blue");
 
   satDial.drawobj = dragGamma;
   intGraf.drawobj = rGraf.drawobj = gGraf.drawobj = bGraf.drawobj = dragGamma;
-  
+
   SetHSVmode();
 
   ctrls2gamstate(&defstate);
@@ -415,14 +415,14 @@
   Str2Graf(&preset[1].rstate,"L 4 : 0,0 : 127,0 : 128,255 : 255,255");
   Str2Graf(&preset[1].gstate,"L 4 : 0,0 : 127,0 : 128,255 : 255,255");
   Str2Graf(&preset[1].bstate,"L 4 : 0,0 : 127,0 : 128,255 : 255,255");
-  
+
 
   /* set up preset2 as a 'temperature' pseudo-color preset */
   ctrls2gamstate(&preset[2]);
   Str2Graf(&preset[2].rstate,"S 4 : 0,0 : 105,0 : 155,140 : 255,255");
   Str2Graf(&preset[2].gstate,"S 5 : 0,0 : 57,135 : 127,255 : 198,135 : 255,0");
   Str2Graf(&preset[2].bstate,"S 4 : 0,255 : 100,140 : 150,0 : 255,0");
-  
+
 
   /* set up preset3 as a 'map' pseudo-color preset */
   ctrls2gamstate(&preset[3]);
@@ -480,7 +480,7 @@
 
   computeHSVlinear();
 }
-  
+
 
 /***************************************************/
 int GamCheckEvent(xev)
@@ -492,14 +492,14 @@
   int rv;
 
   rv = 1;
-  
+
   if (xev->type == Expose) {
     int x,y,w,h;
     XExposeEvent *e = (XExposeEvent *) xev;
     x = e->x;  y = e->y;  w = e->width;  h = e->height;
 
     /* throw away excess redraws for 'dumb' windows */
-    if (e->count > 0 && 
+    if (e->count > 0 &&
 	(e->window == satDial.win || e->window == rhDial.win ||
 	 e->window == gsDial.win  || e->window == bvDial.win ||
 	 e->window == cmapF       || e->window == modF       ||
@@ -600,7 +600,7 @@
 
 
       else if (e->window == hsvF) {
-	if (HDClick(&srcHD, x,y) || HDClick(&dstHD, x,y)) { 
+	if (HDClick(&srcHD, x,y) || HDClick(&dstHD, x,y)) {
 	  dials2hmap();
 	  build_hremap();
 	  changedGam();
@@ -654,7 +654,7 @@
 	       e->window == gsDial.win ||
 	       e->window == bvDial.win) {
 
-	if ((e->window == rhDial.win && DTrack(&rhDial, x,y)) || 
+	if ((e->window == rhDial.win && DTrack(&rhDial, x,y)) ||
 	    (e->window == gsDial.win && DTrack(&gsDial, x,y)) ||
 	    (e->window == bvDial.win && DTrack(&bvDial, x,y))) {
 	  saveCMap(&prevcmap);
@@ -683,7 +683,7 @@
     XKeyEvent *e = (XKeyEvent *) xev;
     char buf[128];  KeySym ks;
     int stlen;
-	
+
     stlen = XLookupString(e,buf,128,&ks,(XComposeStatus *) NULL);
     buf[stlen] = '\0';
 
@@ -792,7 +792,7 @@
 int x,y;
 {
   XPoint pts[8];
-  
+
   pts[0].x = x+10;     pts[0].y = y;
   pts[1].x = x-4;      pts[1].y = y-100;
   pts[2].x = x-4;      pts[2].y = y-40;
@@ -873,11 +873,11 @@
   XSetForeground(theDisp, theGC, infofg);
 
   if (picType != PIC8) {
-    CenterString(cmapF, CMAPX + CMAPW/2, CMAPY + CMAPH/2, 
+    CenterString(cmapF, CMAPX + CMAPW/2, CMAPY + CMAPH/2,
 		 "No colormap in 24-bit mode.");
     return;
   }
-      
+
 
 
   for (i=0; i<numcols; i++) {
@@ -941,14 +941,14 @@
     if (bp->win == butF && PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h)) break;
   }
 
-  /* if 'Set' is lit, and we didn't click 'set' or 'Reset' or '1'..'4', 
+  /* if 'Set' is lit, and we didn't click 'set' or 'Reset' or '1'..'4',
      turn it off */
   if (i!=G_BSET && i!=G_B1 && i!=G_B2 && i!=G_B3 && i!=G_B4 && i!=G_BRESET
       && gbut[G_BSET].lit) {
-    gbut[G_BSET].lit = 0;  
+    gbut[G_BSET].lit = 0;
     BTRedraw(&gbut[G_BSET]);
   }
-  
+
 
   if (i<G_NBUTTS) {  /* found one */
     if (BTTrack(bp)) doCmd(i);
@@ -1003,7 +1003,7 @@
       } /* if i<numcols */
     } /* if but==1 */
 
-    
+
     else if (but==2) {   /* color smooth */
       int cellnum, delc, col1, j, delr, delg, delb;
 
@@ -1025,9 +1025,9 @@
 	    gcmap[col1 + i] = gcmap[col1] + (delg * i) / delc;
 	    bcmap[col1 + i] = bcmap[col1] + (delb * i) / delc;
 
-	    if (cellgroup[col1 + i]) { 
+	    if (cellgroup[col1 + i]) {
 	      /* propogate new color to all members of this group */
-	      for (j=0; j<numcols; j++) 
+	      for (j=0; j<numcols; j++)
 		if (cellgroup[j] == cellgroup[col1 + i]) {
 		  rcmap[j] = rcmap[col1 + i];
 		  gcmap[j] = gcmap[col1 + i];
@@ -1043,7 +1043,7 @@
 	  }
 
 	  if (i<numcols) {  /* something changed */
-	    xvbcopy((char *) &tmpcmap, (char *) &prevcmap, 
+	    xvbcopy((char *) &tmpcmap, (char *) &prevcmap,
 		    sizeof(struct cmapstate));
 	    BTSetActive(&gbut[G_BCOLUNDO],1);
 	    applyGamma(1);
@@ -1067,7 +1067,7 @@
 
 	lastcell = curcell;
 
-	j = XGrabPointer(theDisp, cmapF, False, 0, GrabModeAsync, 
+	j = XGrabPointer(theDisp, cmapF, False, 0, GrabModeAsync,
 			 GrabModeAsync, None, None, (Time) CurrentTime);
 	while (1) {
 	  Window       rW,cW;
@@ -1076,7 +1076,7 @@
 
 	  if (XQueryPointer(theDisp,cmapF,&rW,&cW,&rx,&ry,&x,&y,&mask)) {
 	    /* if button3 and shift released */
-	    if (!(mask & (Button3Mask | ShiftMask))) break;  
+	    if (!(mask & (Button3Mask | ShiftMask))) break;
 
 	    /* if user lets go of B3, reset addonly/delonly flag & lastcell */
 	    if (!(mask & Button3Mask) && (mask & ShiftMask)) {
@@ -1112,7 +1112,7 @@
 
 	if (recolor) {
 	  /* colors changed.  save to color undo area */
-	  xvbcopy((char *) &tmpcmap, (char *) &prevcmap, 
+	  xvbcopy((char *) &tmpcmap, (char *) &prevcmap,
 		  sizeof(struct cmapstate));
 	  BTSetActive(&gbut[G_BCOLUNDO],1);
 	  applyGamma(1);   /* have to regen entire image when groupings chg */
@@ -1146,12 +1146,12 @@
   /* cases:  curgroup>0, clicked on something in same group
                          remove target from group
 	     curgroup>0, clicked on something in different group
-	                 merge groups.  (target group gets 
+	                 merge groups.  (target group gets
 			 set equal to current values)
              curgroup>0, clicked on something in no group
 	                 add target to curgroup
              curgroup=0, clicked on something in a group
-	                 add editColor to target group, 
+	                 add editColor to target group,
 			 set curgroup = target group
 			 target group gets current values
 	     curgroup=0, clicked on something in no group
@@ -1185,7 +1185,7 @@
       }
     }
 
-    else if ((mode!=DELONLY) && cellgroup[cnum] != curgroup && 
+    else if ((mode!=DELONLY) && cellgroup[cnum] != curgroup &&
 	     cellgroup[cnum]>0) {
       /* merge clicked-on group into curgroup */
       mode = ADDONLY;
@@ -1196,11 +1196,11 @@
 	  selectCell(i,1);
 	  rcmap[i] = rcmap[editColor];
 	  gcmap[i] = gcmap[editColor];
-	  bcmap[i] = bcmap[editColor]; 
+	  bcmap[i] = bcmap[editColor];
 	}
       }
     }
-	    
+
     else if ((mode!=DELONLY) && cellgroup[cnum] == 0) {
       /* merge clicked-on cell into curgroup */
       mode = ADDONLY;
@@ -1209,7 +1209,7 @@
       selectCell(cnum,1);
       rcmap[cnum] = rcmap[editColor];
       gcmap[cnum] = gcmap[editColor];
-      bcmap[cnum] = bcmap[editColor]; 
+      bcmap[cnum] = bcmap[editColor];
     }
   }
 
@@ -1224,14 +1224,14 @@
 	  selectCell(i,1);
 	  rcmap[i] = rcmap[editColor];
 	  gcmap[i] = gcmap[editColor];
-	  bcmap[i] = bcmap[editColor]; 
+	  bcmap[i] = bcmap[editColor];
 	}
       }
       curgroup = cellgroup[cnum];
       cellgroup[editColor] = curgroup;
     }
-	    
-    else if ((mode!=DELONLY) && (cellgroup[cnum] == 0) 
+
+    else if ((mode!=DELONLY) && (cellgroup[cnum] == 0)
 	     && (cnum != editColor)) {
       /* create new group for these two cells (cnum and editColor) */
       mode = ADDONLY;
@@ -1247,14 +1247,14 @@
   }
 
   return rv;
-}	    
-	    
+}
+
 
 /*********************/
 void ChangeEC(num)
 int num;
 {
-  /* given a color # that is to become the new editColor, do all 
+  /* given a color # that is to become the new editColor, do all
      highlighting/unhighlighting, copy editColor's rgb values to
      the rgb/hsv dials */
 
@@ -1301,8 +1301,8 @@
     DSetVal(&bvDial, bcmap[editColor]);
   }
 }
-  
-    
+
+
 /*********************/
 void ApplyECctrls()
 {
@@ -1310,7 +1310,7 @@
 
   if (hsvmode) {
     int rv, gv, bv;
-    hsv2rgb((double) rhDial.val, ((double) gsDial.val) / 100.0, 
+    hsv2rgb((double) rhDial.val, ((double) gsDial.val) / 100.0,
 	    ((double) bvDial.val) / 100.0, &rv, &gv, &bv);
     rcmap[editColor] = rv;
     gcmap[editColor] = gv;
@@ -1330,7 +1330,7 @@
 {
   /* this function generates the Floyd-Steinberg gamma curve (fsgamcr)
 
-     This function generates a 4 point spline curve to be used as a 
+     This function generates a 4 point spline curve to be used as a
      non-linear grey 'colormap'.  Two of the points are nailed down at 0,0
      and 255,255, and can't be changed.  You specify the other two.  If
      you specify points on the line (0,0 - 255,255), you'll get the normal
@@ -1345,7 +1345,7 @@
   double yf[4];
 
   InitSpline(x, y, 4, yf);
-  
+
   for (i=0; i<256; i++) {
     j = (int) EvalSpline(x, y, yf, 4, (double) i);
     if (j<0) j=0;
@@ -1364,14 +1364,14 @@
 
   switch (cmd) {
 
-  case G_BAPPLY: 
+  case G_BAPPLY:
     if (enabCB.val != 1) { enabCB.val = 1;  CBRedraw(&enabCB); }
-    applyGamma(0);           
+    applyGamma(0);
     break;
 
   case G_BNOGAM:
     if (enabCB.val != 0) { enabCB.val = 0;  CBRedraw(&enabCB); }
-    applyGamma(0);           
+    applyGamma(0);
     break;
 
   case G_BUNDO:  gamUndo();  break;
@@ -1383,7 +1383,7 @@
 
 
 
-  case G_BDN_BR: 
+  case G_BDN_BR:
   case G_BUP_BR: GetGrafState(&intGraf, &gs);
                  for (i=0; i < gs.nhands; i++) {
 		   if (cmd==G_BUP_BR) gs.hands[i].y += 10;
@@ -1434,7 +1434,7 @@
 	       else if (cmd==G_B3)     ptr = &preset[2];
 	       else if (cmd==G_B4)     ptr = &preset[3];
 	       else if (cmd==G_BRESET) ptr = &defstate;
-                
+
 	       if (gbut[G_BSET].lit) {
 		 ctrls2gamstate(ptr);
 		 gbut[G_BSET].lit = 0;
@@ -1454,7 +1454,7 @@
     break;
 
 
-  case G_BCOLREV: 
+  case G_BCOLREV:
     {
       struct cmapstate tmp1cmap;
       int gchg;
@@ -1463,9 +1463,9 @@
       gchg = (i!=numcols);
 
       saveCMap(&tmpcmap);         /* buffer current cmapstate */
-    
+
       for (i=0; i<numcols; i++) { /* do reversion */
-	rcmap[i] = rorg[i];  
+	rcmap[i] = rorg[i];
 	gcmap[i] = gorg[i];
 	bcmap[i] = borg[i];
 	cellgroup[i] = 0;
@@ -1473,12 +1473,12 @@
       curgroup = maxgroup = 0;
 
       saveCMap(&tmp1cmap);        /* buffer current cmapstate */
-    
+
       /* prevent multiple 'Undo All's from filling Undo buffer */
-      if (xvbcmp((char *) &tmpcmap, (char *) &tmp1cmap, 
+      if (xvbcmp((char *) &tmpcmap, (char *) &tmp1cmap,
 		 sizeof(struct cmapstate))) {
 	/* the reversion changed the cmapstate */
-	xvbcopy((char *) &tmpcmap, (char *) &prevcmap, 
+	xvbcopy((char *) &tmpcmap, (char *) &prevcmap,
 		sizeof(struct cmapstate));
 	BTSetActive(&gbut[G_BCOLUNDO],1);
 
@@ -1496,7 +1496,7 @@
     BTSetActive(&gbut[G_BCOLUNDO],1);
     rndCols();
     break;
-  
+
   case G_BRV:
     saveCMap(&prevcmap);
     BTSetActive(&gbut[G_BCOLUNDO],1);
@@ -1523,7 +1523,7 @@
     ChangeEC(editColor);
     applyGamma(1);
     break;
-  
+
 
   case G_BMONO:
     saveCMap(&prevcmap);
@@ -1534,7 +1534,7 @@
     ChangeEC(editColor);
     applyGamma(1);
     break;
-  
+
 
   case G_BCOLUNDO:
     for (i=0; i<numcols && cellgroup[i]==prevcmap.cellgroup[i]; i++);
@@ -1560,7 +1560,7 @@
     rhDial.title = "Red";
     gsDial.title = "Green";
     bvDial.title = "Blue";
-		   
+
     DSetRange(&rhDial, 0, 255, rcmap[editColor], 16);
     DSetRange(&gsDial, 0, 255, gcmap[editColor], 16);
     DSetRange(&bvDial, 0, 255, bcmap[editColor], 16);
@@ -1615,12 +1615,12 @@
     GammifyColors();
 
     /* if current 'desired' colormap hasn't changed, don't DO anything */
-    if (!xvbcmp((char *) rMap, (char *) oldr, (size_t) numcols) && 
-	!xvbcmp((char *) gMap, (char *) oldg, (size_t) numcols) && 
+    if (!xvbcmp((char *) rMap, (char *) oldr, (size_t) numcols) &&
+	!xvbcmp((char *) gMap, (char *) oldg, (size_t) numcols) &&
 	!xvbcmp((char *) bMap, (char *) oldb, (size_t) numcols)) return;
 
     /* special case: if using R/W color, just modify the colors and leave */
-    if (allocMode==AM_READWRITE && rwthistime && 
+    if (allocMode==AM_READWRITE && rwthistime &&
 	(!cmapchange || nfcols==numcols)) {
       XColor ctab[256];
 
@@ -1647,10 +1647,10 @@
 	gdisp[i] = gMap[rwpc2pc[i]];
 	bdisp[i] = bMap[rwpc2pc[i]];
       }
-      
+
       return;
     }
-    
+
     FreeColors();
 
     {
@@ -1663,10 +1663,10 @@
     AllocColors();
 
 
-    if (epicMode != EM_RAW) {  
+    if (epicMode != EM_RAW) {
       /* regen image, as we'll probably want to dither differently, given
 	 new colors and such */
-      
+
       GenerateEpic(eWIDE, eHIGH);
     }
   }
@@ -1701,7 +1701,7 @@
     for (i=255; i>0 && !hist[i]; i--);
     *rmaxv = i;
   }
-  
+
   else {  /* PIC24 */
     int v,minv,maxv;
 
@@ -1724,7 +1724,7 @@
 	hist[v]++;
       }
     }
-    
+
     *rminv = minv;  *rmaxv = maxv;
   }
 
@@ -1764,13 +1764,13 @@
   int i, histeq[256], minv, maxv;
 
   calcHistEQ(histeq, &minv, &maxv);  /* ignore minv,maxv */
-    
-  for (i=0; i<256; i++) 
+
+  for (i=0; i<256; i++)
     intGraf.func[i] = histeq[i];
-    
+
   for (i=0; i< intGraf.nhands; i++)
     intGraf.hands[i].y = intGraf.func[intGraf.hands[i].x];
-    
+
   intGraf.entergamma = 0;
 
   if (gamUp) {
@@ -1797,7 +1797,7 @@
       if (v>maxv) maxv = v;
     }
   }
-  else { 
+  else {
     int histeq[256];
     calcHistEQ(histeq, &minv, &maxv);  /* ignore histeq */
   }
@@ -1833,11 +1833,11 @@
     for (i=0; i<numcols; i++) Gammify1(i);
   }
   else {
-    for (i=0; i<numcols; i++) { 
+    for (i=0; i<numcols; i++) {
       rMap[i] = rcmap[i];
       gMap[i] = gcmap[i];
       bMap[i] = bcmap[i];
-      if (!ncols) 
+      if (!ncols)
 	cols[i] = (((int)rMap[i]) + ((int)gMap[i]) + ((int)bMap[i]) >= 128*3)
 	  ? white : black;
     }
@@ -1875,7 +1875,7 @@
     if (DEBUG>1) fprintf(stderr," (v=%f)",v);
 
     if (h>=0) {
-      hi = (int) h;  
+      hi = (int) h;
       if (hi<0)    hi += 360;
       if (hi>=360) hi -= 360;
       h = (double) hremap[hi];
@@ -1884,7 +1884,7 @@
       if (whtHD.enabCB.val) {
 	h = (double) whtHD.stval;
 	s = (double) whtHD.satval / 100.0;
-	
+
 	/* special case:  if stval = satval = 0, set hue = -1 */
 	if (whtHD.stval == 0 && whtHD.satval == 0) h = -1.0;
       }
@@ -1899,13 +1899,13 @@
     if (DEBUG>1) fprintf(stderr," -> %d,%d,%d",rv,gv,bv);
   }
 
-  rMap[col] = rGraf.func[rv];  
+  rMap[col] = rGraf.func[rv];
   gMap[col] = gGraf.func[gv];
   bMap[col] = bGraf.func[bv];
 
-  if (!ncols) 
-    cols[col] = 
-      (((int)rMap[col]) + ((int)gMap[col]) + ((int)bMap[col]) >= 128*3) 
+  if (!ncols)
+    cols[col] =
+      (((int)rMap[col]) + ((int)gMap[col]) + ((int)bMap[col]) >= 128*3)
 	? white : black;
 
   if (DEBUG>1) fprintf(stderr," -> %d,%d,%d\n",rMap[col],gMap[col],bMap[col]);
@@ -2001,8 +2001,8 @@
 {
   xvbcopy((char *) hmap, (char *) gs->hmap, sizeof(hmap));
 
-  gs->wht_stval = whtHD.stval;  
-  gs->wht_satval = whtHD.satval;  
+  gs->wht_stval = whtHD.stval;
+  gs->wht_satval = whtHD.satval;
   gs->wht_enab = whtHD.enabCB.val;
 
   gs->hueRBnum = RBWhich(hueRB);
@@ -2042,7 +2042,7 @@
       srcHD.ccwise = hm->src_ccw;
       HDRedraw(&srcHD, HD_ALL | HD_CLEAR);
     }
-    
+
     if (dstHD.stval  != hm->dst_st ||
 	dstHD.enval  != hm->dst_en ||
 	dstHD.ccwise != hm->dst_ccw) {
@@ -2051,7 +2051,7 @@
       dstHD.ccwise = hm->dst_ccw;
       HDRedraw(&dstHD, HD_ALL | HD_CLEAR);
     }
-  }    
+  }
 
 
   if (whtHD.stval != gs->wht_stval || whtHD.satval != gs->wht_satval ||
@@ -2063,7 +2063,7 @@
     HDRedraw(&whtHD, HD_ALL | HD_CLEAR);
     changed++;
   }
-    
+
   if (gs->satval != satDial.val) {
     DSetVal(&satDial,gs->satval);
     changed++;
@@ -2203,7 +2203,7 @@
 }
 
 
-    
+
 
 /*********************/
 static void parseResources()
@@ -2226,7 +2226,7 @@
     if (i) { sprintf(gname,"preset%d",i);  gsp = &preset[i-1]; }
       else { sprintf(gname,"default");     gsp = &defstate; }
 
-    xvbcopy((char *) gsp, (char *) &gs, 
+    xvbcopy((char *) gsp, (char *) &gs,
 	    sizeof(struct gamstate));   /* load 'gs' with defaults */
 
     for (j=0; j<6; j++) {                       /* xv.*.huemap resources */
@@ -2239,7 +2239,7 @@
 	lower_str(def_str);
 	if (sscanf(def_str,"%d %d %s %d %d %s",
 		   &fst, &fen, fcw, &tst, &ten, tcw) != 6) {
-	  fprintf(stderr,"%s: unable to parse resource 'xv.%s: %s'\n", 
+	  fprintf(stderr,"%s: unable to parse resource 'xv.%s: %s'\n",
 		  cmd, tmp, def_str);
 	}
 	else {
@@ -2260,7 +2260,7 @@
       int wst, wsat, enab;
       if (DEBUG) fprintf(stderr,"parseResource 'xv.%s: %s'\n",tmp, def_str);
       if (sscanf(def_str,"%d %d %d", &wst, &wsat, &enab) != 3) {
-	fprintf(stderr,"%s: unable to parse resource 'xv.%s: %s'\n", 
+	fprintf(stderr,"%s: unable to parse resource 'xv.%s: %s'\n",
 		cmd, tmp, def_str);
       }
       else {                                    /* successful parse */
@@ -2276,7 +2276,7 @@
       int sat;
       if (DEBUG) fprintf(stderr,"parseResource 'xv.%s: %s'\n",tmp, def_str);
       if (sscanf(def_str,"%d", &sat) != 1) {
-	fprintf(stderr,"%s: unable to parse resource 'xv.%s: %s'\n", 
+	fprintf(stderr,"%s: unable to parse resource 'xv.%s: %s'\n",
 		cmd, tmp, def_str);
       }
       else {                                    /* successful parse */
@@ -2304,7 +2304,7 @@
 	}
       }
     }
-    
+
     /* copy (potentially) modified gs back to default/preset */
     xvbcopy((char *) &gs, (char *) gsp, sizeof(struct gamstate));
   }
@@ -2324,16 +2324,16 @@
   /* write out current state */
   ctrls2gamstate(&gstate);
   strcpy(gname, "xv.default");
-  
+
   /* write out huemap resources */
   for (i=0; i<6; i++) {
     if (1 || gstate.hmap[i].src_st  != gstate.hmap[i].dst_st ||
 	gstate.hmap[i].src_en  != gstate.hmap[i].dst_en ||
 	gstate.hmap[i].src_ccw != gstate.hmap[i].dst_ccw) {
-      sprintf(tmp, "%s.huemap%d: %3d %3d %3s %3d %3d %3s\n", gname, i+1, 
-	      gstate.hmap[i].src_st, gstate.hmap[i].src_en, 
+      sprintf(tmp, "%s.huemap%d: %3d %3d %3s %3d %3d %3s\n", gname, i+1,
+	      gstate.hmap[i].src_st, gstate.hmap[i].src_en,
 	      gstate.hmap[i].src_ccw ? "CCW" : "CW",
-	      gstate.hmap[i].dst_st, gstate.hmap[i].dst_en, 
+	      gstate.hmap[i].dst_st, gstate.hmap[i].dst_en,
 	      gstate.hmap[i].dst_ccw ? "CCW" : "CW");
       strcat(rsrc, tmp);
     }
@@ -2341,7 +2341,7 @@
 
   /* write out whtmap resource */
   if (1 || gstate.wht_stval || gstate.wht_satval || gstate.wht_enab != 1) {
-    sprintf(tmp, "%s.whtmap:  %d %d %d\n", gname, gstate.wht_stval, 
+    sprintf(tmp, "%s.whtmap:  %d %d %d\n", gname, gstate.wht_stval,
 	    gstate.wht_satval, gstate.wht_enab);
     strcat(rsrc, tmp);
   }
@@ -2372,7 +2372,7 @@
 
   NewCutBuffer(rsrc);
 }
-    
+
 
 /*****************************/
 static void dragGamma ()
@@ -2381,14 +2381,14 @@
      while gamma ctrls are being dragged
      applies change to image if dragCB.val is set
      does NOT call saveGamState() (as changedGam does) */
-  
+
   if (dragCB.val && dragCB.active) {
     hsvnonlinear = 1;   /* force HSV calculations during drag */
     applyGamma(0);
   }
 }
 
-  
+
 /*****************************/
 static void dragHueDial()
 {
@@ -2396,7 +2396,7 @@
      while hue gamma ctrls are being dragged
      applies change to image if dragCB.val is set
      does NOT call saveGamState() (as changedGam does) */
-  
+
   if (dragCB.val && dragCB.active) {
     dials2hmap();
     build_hremap();
@@ -2413,14 +2413,14 @@
      while color editor ctrls are being dragged
      applies change to image if dragCB.val is set
      does NOT call saveCMap(&prevcmap); BTSetActive(&gbut[G_BCOLUNDO],1); */
-  
+
   if (dragCB.val && dragCB.active) ApplyEditColor(0);
 }
 
 
-    
-    
-        
+
+
+
 
 /**********************************************/
 /*************  HUE wheel functions ***********/
@@ -2470,7 +2470,7 @@
     hdbpix2[HDB_ROTR]  = hdbpix1[HDB_ROTR];
   }
 
-    
+
 #define BCOLS fg,bg,hicol,locol
 
   if (hd->range) {
@@ -2526,7 +2526,7 @@
     XSetForeground(theDisp, theGC, hd->fg);
     XDrawArc(theDisp, hd->win, theGC, hd->x - HD_RADIUS, hd->y - HD_RADIUS,
 	     HD_RADIUS*2, HD_RADIUS*2, 0, 360*64);
-    
+
     for (i=0; i<6; i++) {
       int kldg;
 
@@ -2553,8 +2553,8 @@
       a = hdg2xdg(hd->stval) * DEG2RAD;
       pol2xy(hd->x, hd->y, a, HD_RADIUS - 4, &x, &y);
       XDrawLine(theDisp, hd->win, theGC, hd->x, hd->y, x,y);
-      
-      if (flags & HD_CLHNDS) 
+
+      if (flags & HD_CLHNDS)
 	XFillRectangle(theDisp, hd->win, theGC, x-2,y-2, 5,5);
       else {
 	XSetForeground(theDisp, theGC, hd->bg);
@@ -2567,8 +2567,8 @@
       a = hdg2xdg(hd->enval) * DEG2RAD;
       pol2xy(hd->x, hd->y, a, HD_RADIUS - 4, &x, &y);
       XDrawLine(theDisp, hd->win, theGC, hd->x, hd->y, x,y);
-    
-      if (flags & HD_CLHNDS) 
+
+      if (flags & HD_CLHNDS)
 	XFillRectangle(theDisp, hd->win, theGC, x-2,y-2, 5,5);
       else {
 	XSetForeground(theDisp, theGC, hd->bg);
@@ -2587,7 +2587,7 @@
       r = ((HD_RADIUS - 4) * hd->satval) / 100;
       pol2xy(hd->x, hd->y, a, r, &x, &y);
 
-      if (flags & HD_CLHNDS) 
+      if (flags & HD_CLHNDS)
 	XFillRectangle(theDisp, hd->win, theGC, x-2,y-2, 5,5);
       else {
 	XFillRectangle(theDisp, hd->win, theGC, hd->x-1, hd->y-1, 3,3);
@@ -2600,7 +2600,7 @@
       }
     }
   }
-    
+
 
 
 
@@ -2653,13 +2653,13 @@
     XSetBackground(theDisp, theGC, hd->bg);
 
     if (hd->range) {
-      sprintf(vstr,"%3d\007,%3d\007 %s", hd->stval, hd->enval, 
+      sprintf(vstr,"%3d\007,%3d\007 %s", hd->stval, hd->enval,
 	      hd->ccwise ? "CCW" : " CW");
     }
     else {
       sprintf(vstr,"%3d\007 %3d%%", hd->stval, hd->satval);
     }
-      
+
     XDrawImageString(theDisp, hd->win, theGC,
 		     hd->x - XTextWidth(monofinfo, vstr, (int) strlen(vstr))/2,
 		     hd->y + HD_RADIUS + 24, vstr, (int) strlen(vstr));
@@ -2669,7 +2669,7 @@
 
   if (flags & HD_TITLE) {
     XSetForeground(theDisp, theGC, hd->fg);
-    ULineString(hd->win, hd->x - HD_RADIUS - 15, hd->y - HD_RADIUS - 4, 
+    ULineString(hd->win, hd->x - HD_RADIUS - 15, hd->y - HD_RADIUS - 4,
 		hd->str);
   }
 
@@ -2694,7 +2694,7 @@
 }
 
 
-    
+
 /**************************************************/
 static int HDClick(hd,mx,my)
 HDIAL *hd;
@@ -2716,7 +2716,7 @@
   if (!hd->range && !hd->enabCB.val) return 0;    /* disabled */
 
 
-  if ( ((mx - hd->x) * (mx - hd->x)  +  (my - hd->y) * (my - hd->y)) 
+  if ( ((mx - hd->x) * (mx - hd->x)  +  (my - hd->y) * (my - hd->y))
       < (HD_RADIUS * HD_RADIUS)) {
     return HDTrack(hd,mx,my);
   }
@@ -2816,14 +2816,14 @@
 	      hd->satval--;  if (hd->satval<0) hd->satval = 0;
 	      HDRedraw(hd, HD_HANDS | HD_VALS);
 	    }
-	      
+
 	    else if (bnum == HDB_SAT && hd->satval<100) {
 	      HDRedraw(hd, HD_CLHNDS);
 	      hd->satval++;  if (hd->satval>100) hd->satval = 100;
 	      HDRedraw(hd, HD_HANDS | HD_VALS);
 	    }
 	  }
-	      
+
 	  break;
 	}
 
@@ -2836,7 +2836,7 @@
   }
 
   if (bp->lit) {  bp->lit = 0;  BTRedraw(bp); }
-    
+
   return 1;
 }
 
@@ -2872,7 +2872,7 @@
 
       dx = x - hd->x;  dy = y - hd->y;
       dist = sqrt(dx*dx + dy*dy);
-      
+
       newsat = (int) (dist / ((double) (HD_RADIUS - 4)) * 100);
       RANGE(newsat,0,100);
 
@@ -2899,7 +2899,7 @@
     a = hdg2xdg(hd->enval) * DEG2RAD;
     pol2xy(hd->x, hd->y, a, HD_RADIUS-4, &x,&y);
     if (PTINRECT(mx,my,x-3,y-3,7,7)) handle = 2;
-    
+
 
 
     if (!handle) {  /* not in either, rotate both */
@@ -2939,7 +2939,7 @@
       }
       rv = (origj != j);
     }
-	    
+
 
     else {  /* in one of the handles */
       if (handle==1) valp = &(hd->stval);  else valp = &(hd->enval);
@@ -2958,22 +2958,22 @@
 
 	  if (!hd->ccwise) {
 	    ddist = (hd->enval - hd->stval + 360) % 360;
-	    if (handle==1) 
+	    if (handle==1)
 	      ndist = (hd->enval - j + 360) % 360;
 	    else
 	      ndist = (j - hd->stval + 360) % 360;
 	  }
 	  else {
 	    ddist = (hd->stval - hd->enval + 360) % 360;
-	    if (handle==1) 
+	    if (handle==1)
 	      ndist = (j - hd->enval + 360) % 360;
 	    else
 	      ndist = (hd->stval - j + 360) % 360;
 	  }
 
-	  if (abs(ddist - ndist) >= 180 && ddist<180) 
+	  if (abs(ddist - ndist) >= 180 && ddist<180)
 	    hd->ccwise = !hd->ccwise;
-	  
+
 	  *valp = j;
 	  HDRedraw(hd, HD_HANDS | HD_DIR | HD_VALS);
 
@@ -2986,8 +2986,8 @@
 
   return rv;
 }
-    
-      
+
+
 
 /**************************************************/
 static int hdg2xdg(hdg)
@@ -3012,7 +3012,7 @@
   *yp = cy - (int) (sin(ang) * (double) rad);
 }
 
-  
+
 /***************************************************/
 static int computeHDval(hd, x, y)
 HDIAL *hd;
@@ -3044,7 +3044,7 @@
 
 
 
-    
+
 /****************************************************/
 static void initHmap()
 {
@@ -3117,10 +3117,10 @@
 	(hmap[i].src_en  != hmap[i].dst_en) ||
 	(hmap[i].src_ccw != hmap[i].dst_ccw)) {   /* not a 1:1 mapping */
 
-      st1  = hmap[i].src_st;  
+      st1  = hmap[i].src_st;
       en1  = hmap[i].src_en;
       if (hmap[i].src_ccw) {
-	inc1 = -1; 
+	inc1 = -1;
 	len1 = (st1 - en1 + 360) % 360;
       }
       else {
@@ -3131,7 +3131,7 @@
       st2 = hmap[i].dst_st;
       en2 = hmap[i].dst_en;
       if (hmap[i].dst_ccw) {
-	inc2 = -1; 
+	inc2 = -1;
 	len2 = (st2 - en2 + 360) % 360;
       }
       else {
@@ -3179,7 +3179,7 @@
 
   byte *pp, *op;
   int   i,j;
-  int   rv, gv, bv, vi, hi;
+  int   rv, gv, bv;
   byte *outpic;
   int   min, max, del, h, s, v;
   int   f, p, q, t, vs100, vsf10000;
@@ -3270,7 +3270,7 @@
 
       /* map near-black to black to avoid weird effects */
       if (v <= 16) s = 0;
-      
+
       /* apply intGraf.func[] function to 'v' (the intensity) */
       v = intGraf.func[v];
 
@@ -3295,7 +3295,7 @@
       if (h==NOHUE || !s) { rv = gv = bv = v; }
       else {
 	if (h==360) h = 0;
-	
+
 	h        = (h*100) / 60;    /* h is in range 000..599 (0.0 - 5.99) */
 	j        = h - (h%100);     /* j = 000, 100, 200, 300, 400, 500 */
 	f        = h - j;           /* 'fractional' part of h (00..99) */
@@ -3305,7 +3305,7 @@
 	p = v - vs100;
 	q = v - vsf10000;
 	t = v - vs100 + vsf10000;
-	
+
 	switch (j) {
 	case 000:  rv = v;  gv = t;  bv = p;  break;
 	case 100:  rv = q;  gv = v;  bv = p;  break;
@@ -3319,7 +3319,7 @@
     }   /* if hsvmod */
 
 
-    *op++ = rGraf.func[rv];  
+    *op++ = rGraf.func[rv];
     *op++ = gGraf.func[gv];
     *op++ = bGraf.func[bv];
   }
diff -ruN xv-3.10a/xvgif.c xv-3.10a-bugfixes/xvgif.c
--- xv-3.10a/xvgif.c	1995-01-10 11:54:41.000000000 -0800
+++ xv-3.10a-bugfixes/xvgif.c	2005-04-03 11:53:13.000000000 -0700
@@ -28,13 +28,14 @@
 typedef int boolean;
 
 #define NEXTBYTE (*dataptr++)
+#define SKIPBYTE (dataptr++)	/* quiet some compiler warnings */
 #define EXTENSION     0x21
 #define IMAGESEP      0x2c
 #define TRAILER       0x3b
 #define INTERLACEMASK 0x40
 #define COLORMAPMASK  0x80
 
-  
+
 
 FILE *fp;
 
@@ -82,11 +83,11 @@
 char *id89 = "GIF89a";
 
 static int EGApalette[16][3] = {
-  {0,0,0},       {0,0,128},     {0,128,0},     {0,128,128}, 
+  {0,0,0},       {0,0,128},     {0,128,0},     {0,128,128},
   {128,0,0},     {128,0,128},   {128,128,0},   {200,200,200},
   {100,100,100}, {100,100,255}, {100,255,100}, {100,255,255},
   {255,100,100}, {255,100,255}, {255,255,100}, {255,255,255} };
-  
+
 
 static int   readImage   PARM((PICINFO *));
 static int   readCode    PARM((void));
@@ -108,12 +109,13 @@
 {
   /* returns '1' if successful */
 
-  register byte  ch, ch1, *origptr;
+  register byte  ch, *origptr;
   register int   i, block;
   int            aspect, gotimage;
 
   /* initialize variables */
-  BitOffset = XC = YC = Pass = OutCount = gotimage = 0;
+  BitOffset = XC = YC = OutCount = gotimage = 0;
+  Pass = -1;
   RawGIF = Raster = pic8 = NULL;
   gif89 = 0;
 
@@ -129,16 +131,19 @@
   fseek(fp, 0L, 2);
   filesize = ftell(fp);
   fseek(fp, 0L, 0);
-  
-  /* the +256's are so we can read truncated GIF files without fear of 
+
+  if (filesize + 256 < filesize)
+    return( gifError(pinfo, "GIF file size is too large") );
+
+  /* the +256's are so we can read truncated GIF files without fear of
      segmentation violation */
   if (!(dataptr = RawGIF = (byte *) calloc((size_t) filesize+256, (size_t) 1)))
-    return( gifError(pinfo, "not enough memory to read gif file") );
-  
-  if (!(Raster = (byte *) calloc((size_t) filesize+256,(size_t) 1))) 
-    return( gifError(pinfo, "not enough memory to read gif file") );
-  
-  if (fread(dataptr, (size_t) filesize, (size_t) 1, fp) != 1) 
+    FatalError("LoadGIF: not enough memory to read GIF file");
+
+  if (!(Raster = (byte *) calloc((size_t) filesize+256,(size_t) 1)))
+    FatalError("LoadGIF: not enough memory to read GIF file");
+
+  if (fread(dataptr, (size_t) filesize, (size_t) 1, fp) != 1)
     return( gifError(pinfo, "GIF data read failed") );
 
 
@@ -147,35 +152,35 @@
   if      (strncmp((char *) dataptr, id87, (size_t) 6)==0) gif89 = 0;
   else if (strncmp((char *) dataptr, id89, (size_t) 6)==0) gif89 = 1;
   else    return( gifError(pinfo, "not a GIF file"));
-  
+
   dataptr += 6;
-  
+
   /* Get variables from the GIF screen descriptor */
-  
+
   ch = NEXTBYTE;
   RWidth = ch + 0x100 * NEXTBYTE;	/* screen dimensions... not used. */
   ch = NEXTBYTE;
   RHeight = ch + 0x100 * NEXTBYTE;
-  
+
   ch = NEXTBYTE;
   HasColormap = ((ch & COLORMAPMASK) ? True : False);
-  
+
   BitsPerPixel = (ch & 7) + 1;
   numcols = ColorMapSize = 1 << BitsPerPixel;
   BitMask = ColorMapSize - 1;
-  
+
   Background = NEXTBYTE;		/* background color... not used. */
-  
+
   aspect = NEXTBYTE;
   if (aspect) {
     if (!gif89) return(gifError(pinfo,"corrupt GIF file (screen descriptor)"));
     else normaspect = (float) (aspect + 15) / 64.0;   /* gif89 aspect ratio */
     if (DEBUG) fprintf(stderr,"GIF89 aspect = %f\n", normaspect);
   }
-  
-  
+
+
   /* Read in global colormap. */
-  
+
   if (HasColormap)
     for (i=0; i<ColorMapSize; i++) {
       pinfo->r[i] = NEXTBYTE;
@@ -221,19 +226,19 @@
 	if (blocksize == 2) {
 	  aspnum = NEXTBYTE;
 	  aspden = NEXTBYTE;
-	  if (aspden>0 && aspnum>0) 
+	  if (aspden>0 && aspnum>0)
 	    normaspect = (float) aspnum / (float) aspden;
 	  else { normaspect = 1.0;  aspnum = aspden = 1; }
 
-	  if (DEBUG) fprintf(stderr,"GIF87 aspect extension: %d:%d = %f\n\n", 
+	  if (DEBUG) fprintf(stderr,"GIF87 aspect extension: %d:%d = %f\n\n",
 			     aspnum, aspden,normaspect);
 	}
 	else {
-	  for (i=0; i<blocksize; i++) NEXTBYTE;
+	  for (i=0; i<blocksize; i++) SKIPBYTE;
 	}
 
 	while ((sbsize=NEXTBYTE)>0) {  /* eat any following data subblocks */
-	  for (i=0; i<sbsize; i++) NEXTBYTE;
+	  for (i=0; i<sbsize; i++) SKIPBYTE;
 	}
       }
 
@@ -254,9 +259,11 @@
 
 
 	if (cmtlen>0) {   /* build into one un-blocked comment */
+	  /* this can overflow iff cmtlen == 2G - 1, but then filesize
+	   * would have to be > 2GB, which was disallowed above */
 	  cmt = (byte *) malloc((size_t) (cmtlen + 1));
-	  if (!cmt) gifWarning("couldn't malloc space for comments\n");
-	  else {
+	  if (!cmt) FatalError("LoadGIF: couldn't malloc space for comments");
+	  /* else */ {
 	    sp = cmt;
 	    do {
 	      sbsize = (*ptr1++);
@@ -267,10 +274,10 @@
 	    if (pinfo->comment) {    /* have to strcat onto old comments */
 	      cmt1 = (byte *) malloc(strlen(pinfo->comment) + cmtlen + 2);
 	      if (!cmt1) {
-		gifWarning("couldn't malloc space for comments\n");
 		free(cmt);
+	        FatalError("LoadGIF: couldn't malloc space for comments");
 	      }
-	      else {
+	      /* else */ {
 		strcpy((char *) cmt1, (char *) pinfo->comment);
 		strcat((char *) cmt1, (char *) "\n");
 		strcat((char *) cmt1, (char *) cmt);
@@ -288,8 +295,8 @@
       else if (fn == 0x01) {  /* PlainText Extension */
 	int j,sbsize,ch;
 	int tgLeft, tgTop, tgWidth, tgHeight, cWidth, cHeight, fg, bg;
-      
-	SetISTR(ISTR_INFO, "%s:  %s", bname, 
+
+	SetISTR(ISTR_INFO, "%s:  %s", bname,
 		"PlainText extension found in GIF file.  Ignored.");
 
 	sbsize   = NEXTBYTE;
@@ -302,12 +309,12 @@
 	fg       = NEXTBYTE;
 	bg       = NEXTBYTE;
 	i=12;
-	for ( ; i<sbsize; i++) NEXTBYTE;   /* read rest of first subblock */
-      
+	for ( ; i<sbsize; i++) SKIPBYTE;   /* read rest of first subblock */
+
 	if (DEBUG) fprintf(stderr,
 	   "PlainText: tgrid=%d,%d %dx%d  cell=%dx%d  col=%d,%d\n",
 	   tgLeft, tgTop, tgWidth, tgHeight, cWidth, cHeight, fg, bg);
-	
+
 	/* read (and ignore) data sub-blocks */
 	do {
 	  j = 0;
@@ -326,16 +333,16 @@
 
 	if (DEBUG) fprintf(stderr,"Graphic Control extension\n\n");
 
-	SetISTR(ISTR_INFO, "%s:  %s", bname, 
+	SetISTR(ISTR_INFO, "%s:  %s", bname,
 		"Graphic Control Extension in GIF file.  Ignored.");
-	
+
 	/* read (and ignore) data sub-blocks */
 	do {
 	  j = 0; sbsize = NEXTBYTE;
-	  while (j<sbsize) { NEXTBYTE;  j++; }
+	  while (j<sbsize) { SKIPBYTE;  j++; }
 	} while (sbsize);
       }
-      
+
 
       else if (fn == 0xFF) {  /* Application Extension */
 	int j, sbsize;
@@ -345,10 +352,10 @@
 	/* read (and ignore) data sub-blocks */
 	do {
 	  j = 0; sbsize = NEXTBYTE;
-	  while (j<sbsize) { NEXTBYTE;  j++; }
+	  while (j<sbsize) { SKIPBYTE;  j++; }
 	} while (sbsize);
       }
-      
+
 
       else { /* unknown extension */
 	int j, sbsize;
@@ -358,11 +365,11 @@
 	SetISTR(ISTR_INFO,
 		"%s:  Unknown extension 0x%02x in GIF file.  Ignored.",
 		bname, fn);
-	
+
 	/* read (and ignore) data sub-blocks */
 	do {
 	  j = 0; sbsize = NEXTBYTE;
-	  while (j<sbsize) { NEXTBYTE;  j++; }
+	  while (j<sbsize) { SKIPBYTE;  j++; }
 	} while (sbsize);
       }
     }
@@ -370,36 +377,36 @@
 
     else if (block == IMAGESEP) {
       if (DEBUG) fprintf(stderr,"imagesep (got=%d)  ",gotimage);
-      if (DEBUG) fprintf(stderr,"  at start: offset=0x%lx\n",dataptr-RawGIF);
+      if (DEBUG) fprintf(stderr,"  at start: offset=0x%x\n",dataptr-RawGIF);
 
       if (gotimage) {   /* just skip over remaining images */
 	int i,misc,ch,ch1;
 
 	/* skip image header */
-	NEXTBYTE;  NEXTBYTE;  /* left position */
-	NEXTBYTE;  NEXTBYTE;  /* top position */
-	NEXTBYTE;  NEXTBYTE;  /* width */
-	NEXTBYTE;  NEXTBYTE;  /* height */
+	SKIPBYTE;  SKIPBYTE;  /* left position */
+	SKIPBYTE;  SKIPBYTE;  /* top position */
+	SKIPBYTE;  SKIPBYTE;  /* width */
+	SKIPBYTE;  SKIPBYTE;  /* height */
 	misc = NEXTBYTE;      /* misc. bits */
 
 	if (misc & 0x80) {    /* image has local colormap.  skip it */
 	  for (i=0; i< 1 << ((misc&7)+1);  i++) {
-	    NEXTBYTE;  NEXTBYTE;  NEXTBYTE;
+	    SKIPBYTE;  SKIPBYTE;  SKIPBYTE;
 	  }
 	}
 
-	NEXTBYTE;       /* minimum code size */
+	SKIPBYTE;       /* minimum code size */
 
 	/* skip image data sub-blocks */
 	do {
 	  ch = ch1 = NEXTBYTE;
-	  while (ch--) NEXTBYTE;
+	  while (ch--) SKIPBYTE;
 	  if ((dataptr - RawGIF) > filesize) break;      /* EOF */
 	} while(ch1);
       }
 
       else if (readImage(pinfo)) gotimage = 1;
-      if (DEBUG) fprintf(stderr,"  at end:   dataptr=0x%lx\n",dataptr-RawGIF);
+      if (DEBUG) fprintf(stderr,"  at end:   dataptr=0x%x\n",dataptr-RawGIF);
     }
 
 
@@ -415,7 +422,7 @@
 
       /* don't mention bad block if file was trunc'd, as it's all bogus */
       if ((dataptr - origptr) < filesize) {
-	sprintf(str, "Unknown block type (0x%02x) at offset 0x%lx",
+	sprintf(str, "Unknown block type (0x%02x) at offset 0x%x",
 		block, (dataptr - origptr) - 1);
 
 	if (!gotimage) return gifError(pinfo, str);
@@ -431,7 +438,7 @@
   free(RawGIF);	 RawGIF = NULL;
   free(Raster);  Raster = NULL;
 
-  if (!gotimage) 
+  if (!gotimage)
      return( gifError(pinfo, "no image data found in GIF file") );
 
   return 1;
@@ -448,7 +455,7 @@
   npixels = maxpixels = 0;
 
   /* read in values from the image descriptor */
-  
+
   ch = NEXTBYTE;
   LeftOfs = ch + 0x100 * NEXTBYTE;
   ch = NEXTBYTE;
@@ -472,33 +479,33 @@
 
   if (!HasColormap && !(Misc&0x80)) {
     /* no global or local colormap */
-    SetISTR(ISTR_WARNING, "%s:  %s", bname, 
+    SetISTR(ISTR_WARNING, "%s:  %s", bname,
 	    "No colormap in this GIF file.  Assuming EGA colors.");
   }
-    
 
-  
+
+
   /* Start reading the raster data. First we get the intial code size
    * and compute decompressor constant values, based on this code size.
    */
-  
+
   CodeSize = NEXTBYTE;
 
   ClearCode = (1 << CodeSize);
   EOFCode = ClearCode + 1;
   FreeCode = FirstFree = ClearCode + 2;
-  
+
   /* The GIF spec has it that the code size is the code size used to
    * compute the above values is the code size given in the file, but the
    * code size used in compression/decompression is the code size given in
    * the file plus one. (thus the ++).
    */
-  
+
   CodeSize++;
   InitCodeSize = CodeSize;
   MaxCode = (1 << CodeSize);
   ReadMask = MaxCode - 1;
-  
+
 
 
   /* UNBLOCK:
@@ -506,7 +513,7 @@
    * to the Raster array, turning it from a series of blocks into one long
    * data stream, which makes life much easier for readCode().
    */
-  
+
   ptr1 = Raster;
   do {
     ch = ch1 = NEXTBYTE;
@@ -525,18 +532,21 @@
     fprintf(stderr,"xv: LoadGIF() - picture is %dx%d, %d bits, %sinterlaced\n",
 	    Width, Height, BitsPerPixel, Interlace ? "" : "non-");
   }
-  
+
 
   /* Allocate the 'pic' */
-  maxpixels = Width*Height;
+  maxpixels = Width*Height;  /* 65535*65535 max (but everything is int) */
+  if (Width <= 0 || Height <= 0 || maxpixels/Width != Height)
+    return( gifError(pinfo, "image dimensions out of range") );
   picptr = pic8 = (byte *) malloc((size_t) maxpixels);
-  if (!pic8) return( gifError(pinfo, "couldn't malloc 'pic8'") );
+  if (!pic8) FatalError("LoadGIF: couldn't malloc 'pic8'");
+	        
+
 
-  
   /* Decompress the file, continuing until you see the GIF EOF code.
    * One obvious enhancement is to add checking for corrupt files here.
    */
-  
+
   Code = readCode();
   while (Code != EOFCode) {
     /* Clear code sets everything back to its initial value, then reads the
@@ -563,58 +573,58 @@
 			    break; }
 
       CurCode = InCode = Code;
-      
+
       /* If greater or equal to FreeCode, not in the hash table yet;
        * repeat the last character decoded
        */
-      
+
       if (CurCode >= FreeCode) {
 	CurCode = OldCode;
 	if (OutCount > 4096) {  /* printf("outcount1 blew up\n"); */ break; }
 	OutCode[OutCount++] = FinChar;
       }
-      
+
       /* Unless this code is raw data, pursue the chain pointed to by CurCode
        * through the hash table to its end; each code in the chain puts its
        * associated output code on the output queue.
        */
-      
+
       while (CurCode > BitMask) {
 	if (OutCount > 4096) break;   /* corrupt file */
 	OutCode[OutCount++] = Suffix[CurCode];
 	CurCode = Prefix[CurCode];
       }
-      
+
       if (OutCount > 4096) { /* printf("outcount blew up\n"); */ break; }
-      
+
       /* The last code in the chain is treated as raw data. */
-      
+
       FinChar = CurCode & BitMask;
       OutCode[OutCount++] = FinChar;
-      
+
       /* Now we put the data out to the Output routine.
        * It's been stacked LIFO, so deal with it that way...
        */
 
       /* safety thing:  prevent exceeding range of 'pic8' */
       if (npixels + OutCount > maxpixels) OutCount = maxpixels-npixels;
-	
+
       npixels += OutCount;
       if (!Interlace) for (i=OutCount-1; i>=0; i--) *picptr++ = OutCode[i];
                 else  for (i=OutCount-1; i>=0; i--) doInterlace(OutCode[i]);
       OutCount = 0;
 
       /* Build the hash table on-the-fly. No table is stored in the file. */
-      
+
       Prefix[FreeCode] = OldCode;
       Suffix[FreeCode] = FinChar;
       OldCode = InCode;
-      
+
       /* Point to the next slot in the table.  If we exceed the current
        * MaxCode value, increment the code size unless it's already 12.  If it
        * is, do nothing: the next code decompressed better be CLEAR
        */
-      
+
       FreeCode++;
       if (FreeCode >= MaxCode) {
 	if (CodeSize < 12) {
@@ -627,7 +637,7 @@
     Code = readCode();
     if (npixels >= maxpixels) break;
   }
-  
+
   if (npixels != maxpixels) {
     SetISTR(ISTR_WARNING,"%s:  %s", bname,
 	    "This GIF file seems to be truncated.  Winging it.");
@@ -640,7 +650,7 @@
   /* fill in the PICINFO structure */
 
   pinfo->pic     = pic8;
-  pinfo->w       = Width;           
+  pinfo->w       = Width;
   pinfo->h       = Height;
   pinfo->type    = PIC8;
   pinfo->frmType = F_GIF;
@@ -650,8 +660,8 @@
 
   sprintf(pinfo->fullInfo,
 	  "GIF%s, %d bit%s per pixel, %sinterlaced.  (%d bytes)",
- 	  (gif89) ? "89" : "87", BitsPerPixel, 
-	  (BitsPerPixel==1) ? "" : "s", 
+ 	  (gif89) ? "89" : "87", BitsPerPixel,
+	  (BitsPerPixel==1) ? "" : "s",
  	  Interlace ? "" : "non-", filesize);
 
   sprintf(pinfo->shrtInfo, "%dx%d GIF%s.",Width,Height,(gif89) ? "89" : "87");
@@ -668,13 +678,13 @@
  * maintain our location in the Raster array as a BIT Offset.  We compute
  * the byte Offset into the raster array by dividing this by 8, pick up
  * three bytes, compute the bit Offset into our 24-bit chunk, shift to
- * bring the desired code to the bottom, then mask it off and return it. 
+ * bring the desired code to the bottom, then mask it off and return it.
  */
 
 static int readCode()
 {
   int RawCode, ByteOffset;
-  
+
   ByteOffset = BitOffset / 8;
   RawCode = Raster[ByteOffset] + (Raster[ByteOffset + 1] << 8);
   if (CodeSize >= 8)
@@ -692,42 +702,47 @@
 {
   static byte *ptr = NULL;
   static int   oldYC = -1;
-  
+
+  if (Pass == -1) {  /* first time through - init stuff */
+    oldYC = -1;
+    Pass = 0;
+  }
+
   if (oldYC != YC) {  ptr = pic8 + YC * Width;  oldYC = YC; }
-  
+
   if (YC<Height)
     *ptr++ = Index;
-  
+
   /* Update the X-coordinate, and if it overflows, update the Y-coordinate */
-  
+
   if (++XC == Width) {
-    
+
     /* deal with the interlace as described in the GIF
      * spec.  Put the decoded scan line out to the screen if we haven't gone
      * past the bottom of it
      */
-    
+
     XC = 0;
-    
+
     switch (Pass) {
     case 0:
       YC += 8;
       if (YC >= Height) { Pass++; YC = 4; }
       break;
-      
+
     case 1:
       YC += 8;
       if (YC >= Height) { Pass++; YC = 2; }
       break;
-      
+
     case 2:
       YC += 4;
       if (YC >= Height) { Pass++; YC = 1; }
       break;
-      
+
     case 3:
       YC += 2;  break;
-      
+
     default:
       break;
     }
@@ -735,7 +750,7 @@
 }
 
 
-      
+
 /*****************************/
 static int gifError(pinfo, st)
      PICINFO *pinfo;
diff -ruN xv-3.10a/xvgifwr.c xv-3.10a-bugfixes/xvgifwr.c
--- xv-3.10a/xvgifwr.c	1995-01-03 13:22:21.000000000 -0800
+++ xv-3.10a-bugfixes/xvgifwr.c	2004-05-16 18:03:27.000000000 -0700
@@ -2,11 +2,11 @@
  * xvgifwr.c  -  handles writing of GIF files.  based on flgife.c and
  *               flgifc.c from the FBM Library, by Michael Maudlin
  *
- * Contains: 
+ * Contains:
  *   WriteGIF(fp, pic, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle,
  *            comment)
  *
- * Note: slightly brain-damaged, in that it'll only write non-interlaced 
+ * Note: slightly brain-damaged, in that it'll only write non-interlaced
  *       GIF files (in the interests of speed, or something)
  *
  */
@@ -34,7 +34,7 @@
  *	James A. Woods          (decvax!ihnp4!ames!jaw)
  *	Joe Orost               (decvax!vax135!petsd!joe)
  *****************************************************************/
- 
+
 
 #include "xv.h"
 
@@ -44,7 +44,6 @@
 static int  curx, cury;
 static long CountDown;
 static int  Interlace;
-static byte bw[2] = {0, 0xff};
 
 static void putword     PARM((int, FILE *));
 static void compress    PARM((int, FILE *, byte *, int));
@@ -97,7 +96,7 @@
   for (i=0; i<numcols; i++) {
     /* see if color #i is already used */
     for (j=0; j<i; j++) {
-      if (rmap[i] == rmap[j] && gmap[i] == gmap[j] && 
+      if (rmap[i] == rmap[j] && gmap[i] == gmap[j] &&
 	  bmap[i] == bmap[j]) break;
     }
 
@@ -115,15 +114,15 @@
   /* figure out 'BitsPerPixel' */
   for (i=1; i<8; i++)
     if ( (1<<i) >= nc) break;
-  
+
   BitsPerPixel = i;
 
   ColorMapSize = 1 << BitsPerPixel;
-	
+
   RWidth  = Width  = w;
   RHeight = Height = h;
   LeftOfs = TopOfs = 0;
-	
+
   CountDown = w * h;    /* # of pixels we'll be doing */
 
   if (BitsPerPixel <= 1) InitCodeSize = 2;
@@ -137,7 +136,7 @@
     return (1);
   }
 
-  if (DEBUG) 
+  if (DEBUG)
     fprintf(stderr,"WrGIF: pic=%lx, w,h=%dx%d, numcols=%d, Bits%d,Cmap=%d\n",
 	    (u_long) pic8, w,h,numcols,BitsPerPixel,ColorMapSize);
 
@@ -152,7 +151,7 @@
   i = 0x80;	                 /* Yes, there is a color map */
   i |= (8-1)<<4;                 /* OR in the color resolution (hardwired 8) */
   i |= (BitsPerPixel - 1);       /* OR in the # of bits per pixel */
-  fputc(i,fp);          
+  fputc(i,fp);
 
   fputc(Background, fp);         /* background color */
 
@@ -290,7 +289,7 @@
 /*
  * compress stdin to stdout
  *
- * Algorithm:  use open addressing double hashing (no chaining) on the 
+ * Algorithm:  use open addressing double hashing (no chaining) on the
  * prefix code / next character combination.  We do a variant of Knuth's
  * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
  * secondary probe.  Here, the modular division first probe is gives way
@@ -370,7 +369,7 @@
   cl_hash( (count_int) hsize_reg);            /* clear hash table */
 
   output(ClearCode);
-    
+
   while (len) {
     c = pc2nc[*data++];  len--;
     in_count++;
@@ -399,7 +398,7 @@
       continue;
     }
 
-    if ( (long)HashTabOf (i) >= 0 ) 
+    if ( (long)HashTabOf (i) >= 0 )
       goto probe;
 
 nomatch:
@@ -454,7 +453,7 @@
     cur_accum |= ((long)code << cur_bits);
   else
     cur_accum = code;
-	
+
   cur_bits += n_bits;
 
   while( cur_bits >= 8 ) {
@@ -482,7 +481,7 @@
 	maxcode = MAXCODE(n_bits);
     }
   }
-	
+
   if( code == EOFCode ) {
     /* At EOF, write the rest of the buffer */
     while( cur_bits > 0 ) {
@@ -492,11 +491,11 @@
     }
 
     flush_char();
-	
+
     fflush( g_outfile );
 
 #ifdef FOO
-    if( ferror( g_outfile ) ) 
+    if( ferror( g_outfile ) )
       FatalError("unable to write GIF file");
 #endif
   }
@@ -582,7 +581,7 @@
 int c;
 {
   accum[ a_count++ ] = c;
-  if( a_count >= 254 ) 
+  if( a_count >= 254 )
     flush_char();
 }
 
@@ -596,4 +595,4 @@
     fwrite(accum, (size_t) 1, (size_t) a_count, g_outfile );
     a_count = 0;
   }
-}	
+}
diff -ruN xv-3.10a/xvgrab.c xv-3.10a-bugfixes/xvgrab.c
--- xv-3.10a/xvgrab.c	1994-12-22 14:34:47.000000000 -0800
+++ xv-3.10a-bugfixes/xvgrab.c	2004-05-16 18:03:30.000000000 -0700
@@ -6,7 +6,7 @@
  *  Contains:
  *     int Grab()             - handles the GRAB command
  *     int LoadGrab();        - 'loads' the pic from the last succesful Grab
- *            
+ *
  */
 
 #include "copyright.h"
@@ -14,29 +14,54 @@
 #define NEEDSTIME
 #include "xv.h"
 
-static byte *grabPic = (byte *) NULL;
-static int  gbits;                              /* either '8' or '24' */
-static byte grabmapR[256], grabmapG[256], grabmapB[256];  /* colormap */
-static int  gWIDE,gHIGH;
-static int  grabInProgress=0;
-static int  hidewins = 0;
-static GC   rootGC;
-
-static void   flashrect       PARM((int, int, int, int, int));
-static void   startflash      PARM((void));
-static void   endflash        PARM((void));
-static int    grabImage       PARM((Window, int, int, int, int));
-static void   ungrabX         PARM((void));
-static int    convertImage    PARM((XImage *, XColor *, int, 
-				    XWindowAttributes *));
-
-static int    lowbitnum       PARM((unsigned long));
-static int    getxcolors      PARM((XWindowAttributes *, XColor **));
-static Window xvClientWindow  PARM((Display *, Window));
+
+union swapun {
+  CARD32 l;
+  CARD16 s;
+  CARD8  b[sizeof(CARD32)];
+};
 
 
+struct rectlist {
+  int x,y,w,h;
+  struct rectlist *next;
+};
 
 
+static byte            *grabPic = (byte *) NULL;
+static int              gptype;
+static byte             grabmapR[256], grabmapG[256], grabmapB[256];
+static int              gXOFF, gYOFF, gWIDE,gHIGH;
+static int              grabInProgress=0;
+static int              hidewins = 0;
+static GC               rootGC;
+static struct rectlist *regrabList;
+
+
+static void   flashrect           PARM((int, int, int, int, int));
+static void   startflash          PARM((void));
+static void   endflash            PARM((void));
+static void   ungrabX             PARM((void));
+static int    lowbitnum           PARM((unsigned long));
+static int    getxcolors          PARM((XWindowAttributes *, XColor **));
+
+static void   printWinTree        PARM((Window, int));
+static void   errSpace            PARM((int));
+
+static int    grabRootRegion      PARM((int, int, int, int));
+static int    grabWinImage        PARM((Window, VisualID, Colormap, int));
+static int    convertImageAndStuff PARM((XImage *, XColor *, int,
+					 XWindowAttributes *,
+					 int,int,int,int));
+
+static int    RectIntersect       PARM((int,int,int,int, int,int,int,int));
+
+static int    CountColors24       PARM((byte *, int, int,
+					int, int, int, int));
+
+static int    Trivial24to8        PARM((byte *, int, int, byte *,
+					byte *, byte *, byte *, int));
+
 /***********************************/
 int Grab()
 {
@@ -45,8 +70,7 @@
 
   int          i, x, y, x1, y1, x2, y2, ix, iy, iw, ih, rv;
   int          rx, ry, pretendGotB1, autograb;
-  int          oldaclose;
-  Window       rW, cW, clickWin, tmpwin;
+  Window       rW, cW, clickWin;
   unsigned int mask;
   XColor       fc, bc;
 
@@ -75,7 +99,7 @@
     grabInProgress = 1; /* guard against recursive grabs during delay */
     time(&startT);
     while (1) {
-      time(&t);  
+      time(&t);
       if (t >= startT + grabDelay) break;
       if (XPending(theDisp)>0) {
 	XEvent evt;
@@ -91,25 +115,25 @@
     grabInProgress = 0;
   }
 
-  
+
   rootGC   = DefaultGC(theDisp, theScreen);
-  
+
   if (grabPic) {  /* throw away previous 'grabbed' pic, if there is one */
     free(grabPic);  grabPic = (byte *) NULL;
   }
 
 
   fc.flags = bc.flags = DoRed | DoGreen | DoBlue;
-  fc.red = fc.green = fc.blue = 0xffff;  
+  fc.red = fc.green = fc.blue = 0xffff;
   bc.red = bc.green = bc.blue = 0x0000;
   XRecolorCursor(theDisp, tcross, &fc, &bc);
 
 
   XBell(theDisp, 0);		/* beep once at start of grab */
 
-  if (!autograb) XGrabButton(theDisp, (u_int) AnyButton, 0, rootW, False, 0, 
+  if (!autograb) XGrabButton(theDisp, (u_int) AnyButton, 0, rootW, False, 0,
 			     GrabModeAsync, GrabModeSync, None, tcross);
-  
+
   if (autograb) {
     XGrabServer(theDisp);	 /* until we've done the grabImage */
     if (!XQueryPointer(theDisp,rootW,&rW,&cW,&rx,&ry,&x1,&y1,&mask)) {
@@ -136,7 +160,7 @@
       XNextEvent(theDisp, &evt);
       i = HandleEvent(&evt, &done);
       if (done) {                    /* only 'new image' cmd accepted=quit */
-	if (i==QUIT) { 
+	if (i==QUIT) {
 	  XUngrabButton(theDisp, (u_int) AnyButton, 0, rootW);
 	  Quit(0);
 	}
@@ -145,12 +169,12 @@
 
     }
   }
-  
-  
+
+
   /***
    ***  got button click (or pretending we did, if autograb)
    ***/
-  
+
 
   if (mask & Button3Mask || rW!=rootW) {        /* Button3: CANCEL GRAB */
     while (1) {      /* wait for button to be released */
@@ -158,7 +182,7 @@
 	if (!(mask & Button3Mask)) break;
       }
     }
-    
+
     XUngrabButton(theDisp, (u_int) AnyButton, 0, rootW);
     XBell(theDisp, 0);
     XBell(theDisp, 0);
@@ -175,69 +199,40 @@
 	if (!(mask & Button1Mask)) break;
       }
     }
-    
-    if (!cW || cW == rootW) clickWin = rootW;
-    else {
-      int xr, yr;    Window chwin;
-      XTranslateCoordinates(theDisp, rW, cW, rx, ry, &xr, &yr, &chwin);
-      if (chwin != None) {
-	XWindowAttributes clickxwa, parentxwa;
-
-	clickWin = xvClientWindow(theDisp, chwin);
-
-	/* decide if we want to just grab clickWin, or cW.
-	   basically, if they're different in any important way 
-	   (depth, visual, colormap), grab 'clickWin' only, 
-	   as it's the important part */
-
-	if (!clickWin || 
-	    (XGetWindowAttributes(theDisp, clickWin, &clickxwa)  &&
-	     XGetWindowAttributes(theDisp, cW,       &parentxwa) &&
-	     clickxwa.visual->class == parentxwa.visual->class   &&
-	     clickxwa.colormap      == parentxwa.colormap        &&
-	     clickxwa.depth         == parentxwa.depth)
-	    )
-	  clickWin = cW;   	  /* close enough! */
-      }
-      else clickWin = cW;
-      
-      if (DEBUG) 
-	fprintf(stderr, "rW = %x, cW = %x, chwin = %x, clickWin = %x\n",
-		(u_int) rW, (u_int) cW, (u_int) chwin, (u_int) clickWin);
-    }
-    
-    
+
+    clickWin = (cW) ? cW : rootW;
+
     if (clickWin == rootW) {   /* grab entire screen */
       if (DEBUG) fprintf(stderr,"Grab: clicked on root window.\n");
       ix = iy = 0;  iw = dispWIDE;  ih = dispHIGH;
     }
     else {
       int x,y;  Window win;   unsigned int rw,rh,rb,rd;
-      
+
       if (XGetGeometry(theDisp,clickWin,&rW, &x, &y, &rw, &rh, &rb, &rd)) {
 	iw = (int) rw;  ih = (int) rh;
-	
+
 	XTranslateCoordinates(theDisp, clickWin, rootW, 0, 0, &ix,&iy, &win);
-	
-	if (DEBUG) fprintf(stderr,"clickWin=0x%x: %d,%d %dx%d depth=%ud\n", 
-			   (u_int) clickWin, ix, iy, iw, ih, rd);    
+
+	if (DEBUG) fprintf(stderr,"clickWin=0x%x: %d,%d %dx%d depth=%ud\n",
+			   (u_int) clickWin, ix, iy, iw, ih, rd);
       }
       else {
 	ix = iy = 0;  iw = dispWIDE;  ih = dispHIGH;  clickWin = rootW;
 	if (DEBUG) fprintf(stderr,"XGetGeometry failed? (using root win)\n");
       }
     }
-    
-    
+
+
     /* range checking:  keep rectangle fully on-screen */
     if (ix<0) { iw += ix;  ix = 0; }
     if (iy<0) { ih += iy;  iy = 0; }
     if (ix+iw>dispWIDE) iw = dispWIDE-ix;
     if (iy+ih>dispHIGH) ih = dispHIGH-iy;
-    
-    
+
+
     if (DEBUG) fprintf(stderr,"using %d,%d (%dx%d)\n", ix, iy, iw, ih);
-    
+
     /* flash the rectangle a bit... */
     startflash();
     for (i=0; i<5; i++) {
@@ -252,13 +247,12 @@
 
   else {  /* Button2:  TRACK A RECTANGLE */
     int    origrx, origry;
-    Window origcW;
 
-    clickWin = rootW;  origcW = cW;
+    clickWin = rootW;
     origrx = ix = x2 = rx;
     origry = iy = y2 = ry;
     iw = ih = 0;
-    
+
     XGrabServer(theDisp);
     startflash();
 
@@ -276,51 +270,36 @@
 	iw = abs(rx - x1);  ih = abs(ry - y1);
 	x2 = rx;  y2 = ry;
       }
-      
+
       if (iw>1 && ih>1) flashrect(ix,iy,iw,ih,1);  /* turn on rect */
     }
 
     flashrect(ix, iy, iw, ih, 0);                  /* turn off rect */
+
+    /* flash the rectangle a bit... */
+    for (i=0; i<5; i++) {
+      flashrect(ix, iy, iw, ih, 1);
+      XFlush(theDisp);  Timer(100);
+      flashrect(ix, iy, iw, ih, 0);
+      XFlush(theDisp);  Timer(100);
+    }
     endflash();
-    
+
     XUngrabServer(theDisp);
-    
-    
-    if (origcW == cW) {  /* maybe it's entirely in one window??? */
-      if (cW) {    /* will be 0 if clicked in rootW */
-	Window stwin, enwin, stwin1, enwin1;
-	if (DEBUG) fprintf(stderr,"origcW=%x cW=%x   ", 
-			   (u_int) origcW, (u_int) cW);
-	XTranslateCoordinates(theDisp,rootW,cW, origrx,origry,&x,&y,&stwin);
-	XTranslateCoordinates(theDisp,rootW,cW, rx,    ry,    &x,&y,&enwin);
-	
-	if (DEBUG) fprintf(stderr,"stwin=%x enwin=%x   ", 
-			   (u_int) stwin, (u_int) enwin);
-	if (stwin == enwin && stwin != None) {
-	  stwin1 = xvClientWindow(theDisp, stwin);
-	  enwin1 = xvClientWindow(theDisp, enwin);
-	  if (DEBUG) fprintf(stderr,"stwin1=%x enwin1=%x   ", 
-			     (u_int) stwin1, (u_int) enwin1);
-	  
-	  if (stwin1 == enwin1 && stwin1) clickWin = stwin1;
-	  else clickWin = stwin;
-	}
-	if (DEBUG) fprintf(stderr,"\n");
-      }
-      else clickWin = rootW;
-    }
   }
-  
+
 
   /***
-   ***  now that clickWin,ix,iy,iw,ih are known, try to grab the bits...
+   ***  grab screen area (ix,iy,iw,ih)
    ***/
 
 
+  if (DEBUG>1) printWinTree(clickWin, 0);
+
   WaitCursor();
 
   if (!autograb) XGrabServer(theDisp);	 /* until we've done the grabImage */
-  rv = grabImage(clickWin,ix,iy,iw,ih);  /* ungrabs the server & button */
+  rv = grabRootRegion(ix, iy, iw, ih);   /* ungrabs the server & button */
 
   SetCursors(-1);
 
@@ -337,25 +316,25 @@
 
       if (DEBUG) fprintf(stderr,"==remapped mainW.  waiting for Config.\n");
 
-      /* sit here until we see a MapNotify on mainW followed by a 
+      /* sit here until we see a MapNotify on mainW followed by a
 	 ConfigureNotify on mainW */
 
       state = 0;
-      while (1) {
+      while (state != 3) {
 	XEvent event;
 	XNextEvent(theDisp, &event);
 	HandleEvent(&event, &i);
 
-	if (state==0 && event.type == MapNotify &&
-	    event.xmap.window == mainW) state = 1;
+	if (!(state&1) && event.type == MapNotify &&
+	    event.xmap.window == mainW) state |= 1;
 
-	if (state==1 && event.type == ConfigureNotify && 
-	    event.xconfigure.window == mainW) break;
+	if (!(state&2) && event.type == ConfigureNotify &&
+	    event.xconfigure.window == mainW) state |= 2;
       }
 
       if (DEBUG) fprintf(stderr,"==after remapping mainW, GOT Config.\n");
     }
-      
+
     else if (ctrlW) CtrlBox(1);
   }
 
@@ -364,6 +343,45 @@
 
 
 /***********************************/
+int LoadGrab(pinfo)
+     PICINFO *pinfo;
+{
+  /* loads up (into XV structures) last image successfully grabbed.
+     returns '0' on failure, '1' on success */
+
+  int   i;
+
+  if (!grabPic) return 0;   /* no image to use */
+
+  pinfo->type = gptype;
+  if (pinfo->type == PIC8) {
+    for (i=0; i<256; i++) {
+      pinfo->r[i] = grabmapR[i];
+      pinfo->g[i] = grabmapG[i];
+      pinfo->b[i] = grabmapB[i];
+    }
+  }
+
+  pinfo->pic     = grabPic;
+  pinfo->normw   = pinfo->w   = gWIDE;
+  pinfo->normh   = pinfo->h   = gHIGH;
+  pinfo->frmType = -1;
+  pinfo->colType = -1;
+
+  sprintf(pinfo->fullInfo,"<%s internal>",
+	  (pinfo->type == PIC8) ? "8-bit" : "24-bit");
+
+  sprintf(pinfo->shrtInfo,"%dx%d image.",gWIDE, gHIGH);
+
+  pinfo->comment = (char *) NULL;
+
+  grabPic = (byte *) NULL;
+
+  return 1;
+}
+
+
+/***********************************/
 static void flashrect(x,y,w,h,show)
      int x,y,w,h,show;
 {
@@ -373,7 +391,7 @@
   XSetPlaneMask(theDisp, rootGC, xorMasks[maskno]);
 
   if (!show) {     /* turn off rectangle */
-    if (isvis) 
+    if (isvis)
       XDrawRectangle(theDisp, rootW, rootGC, x, y, (u_int) w-1, (u_int) h-1);
 
     isvis = 0;
@@ -391,15 +409,16 @@
 
 /***********************************/
 static void startflash()
-{  
+{
   /* set up for drawing a flashing rectangle */
   XSetFunction(theDisp, rootGC, GXinvert);
   XSetSubwindowMode(theDisp, rootGC, IncludeInferiors);
 }
 
+
 /***********************************/
 static void endflash()
-{  
+{
   XSetFunction(theDisp, rootGC, GXcopy);
   XSetSubwindowMode(theDisp, rootGC, ClipByChildren);
   XSetPlaneMask(theDisp, rootGC, AllPlanes);
@@ -408,21 +427,157 @@
 
 
 /***********************************/
-static int grabImage(clickWin, x, y, w, h)
-     Window clickWin;
+static void ungrabX()
+{
+  XUngrabServer(theDisp);
+  XUngrabButton(theDisp, (u_int) AnyButton, 0, rootW);
+}
+
+
+/**************************************/
+static int lowbitnum(ul)
+     unsigned long ul;
+{
+  /* returns position of lowest set bit in 'ul' as an integer (0-31),
+   or -1 if none */
+
+  int i;
+  for (i=0; ((ul&1) == 0) && i<32;  i++, ul>>=1);
+  if (i==32) i = -1;
+  return i;
+}
+
+
+
+/**********************************************/
+/* getxcolors() function snarfed from 'xwd.c' */
+/**********************************************/
+
+#define lowbit(x) ((x) & (~(x) + 1))
+
+static int getxcolors(win_info, colors)
+     XWindowAttributes *win_info;
+     XColor **colors;
+{
+  int i, ncolors;
+
+  *colors = (XColor *) NULL;
+
+  if (win_info->visual->class == TrueColor) {
+    if (DEBUG>1) fprintf(stderr,"TrueColor visual:  no colormap needed\n");
+    return 0;
+  }
+
+  else if (!win_info->colormap) {
+    if (DEBUG>1) fprintf(stderr,"no colormap associated with window\n");
+    return 0;
+  }
+
+  ncolors = win_info->visual->map_entries;
+  if (DEBUG>1) fprintf(stderr,"%d entries in colormap\n", ncolors);
+
+  if (!(*colors = (XColor *) malloc (sizeof(XColor) * ncolors)))
+    FatalError("malloc failed in getxcolors()");
+
+
+  if (win_info->visual->class == DirectColor) {
+    Pixel red, green, blue, red1, green1, blue1;
+
+    if (DEBUG>1) fprintf(stderr,"DirectColor visual\n");
+
+    red = green = blue = 0;
+    red1   = lowbit(win_info->visual->red_mask);
+    green1 = lowbit(win_info->visual->green_mask);
+    blue1  = lowbit(win_info->visual->blue_mask);
+    for (i=0; i<ncolors; i++) {
+      (*colors)[i].pixel = red|green|blue;
+      (*colors)[i].pad = 0;
+      red += red1;
+      if (red > win_info->visual->red_mask)     red = 0;
+      green += green1;
+      if (green > win_info->visual->green_mask) green = 0;
+      blue += blue1;
+      if (blue > win_info->visual->blue_mask)   blue = 0;
+    }
+  }
+  else {
+    for (i=0; i<ncolors; i++) {
+      (*colors)[i].pixel = i;
+      (*colors)[i].pad = 0;
+    }
+  }
+
+  XQueryColors(theDisp, win_info->colormap, *colors, ncolors);
+
+  return(ncolors);
+}
+
+
+
+/*******************************************/
+static void printWinTree(win,tab)
+     Window win;
+     int    tab;
+{
+  u_int             i, nchildren;
+  Window            root, parent, *children, chwin;
+  XWindowAttributes xwa;
+  int               xr, yr;
+
+  if (!XGetWindowAttributes(theDisp, win, &xwa)) {
+    errSpace(tab);
+    fprintf(stderr,"pWT: can't XGetWindowAttributes(%08x)\n", (u_int) win);
+    return;
+  }
+
+  XTranslateCoordinates(theDisp, win, rootW, 0,0, &xr,&yr, &chwin);
+  if (xwa.map_state==IsViewable) {
+    errSpace(tab);
+    fprintf(stderr,"%08x: %4d,%4d %4dx%4d vis: %02x  cm=%x  %s\n",
+	    (u_int) win, xr,yr, xwa.width, xwa.height,
+	    (u_int) XVisualIDFromVisual(xwa.visual),
+	    (u_int) xwa.colormap,
+	    ((xwa.map_state==IsUnmapped)      ? "unmapped  "  :
+	     (xwa.map_state==IsUnviewable)    ? "unviewable"  :
+	     (xwa.map_state==IsViewable)      ? "viewable  "  :
+	     "<unknown> ")       );
+
+    if (!XQueryTree(theDisp, win, &root, &parent, &children, &nchildren)) {
+      errSpace(tab);
+      fprintf(stderr,"pWT: XQueryTree(%08x) failed\n", (u_int) win);
+      if (children) XFree((char *)children);
+      return;
+    }
+
+    for (i=0; i<nchildren; i++) printWinTree(children[i], tab+1);
+    if (children) XFree((char *)children);
+  }
+
+  return;
+}
+
+
+/***********************************/
+static void errSpace(n)
+     int n;
+{
+  for ( ; n>0; n--) putc(' ', stderr);
+}
+
+
+
+
+/***********************************/
+static int grabRootRegion(x, y, w, h)
      int    x, y, w, h;
 {
   /* attempts to grab the specified rectangle of the root window
-     returns '1' on success.  clickWin is used to figure out the depth
-     and colormap to use */
+     returns '1' on success */
 
-  XImage *image;
-  XWindowAttributes xwa;
-  XColor *colors;
-  int ncolors, i, ix, iy;
-  char str[256];
-  Window win;
+  XWindowAttributes  xwa;
+  int                i;
 
+  regrabList = (struct rectlist *) NULL;
 
   /* range checking */
   if (x<0) { w += x;  x = 0; }
@@ -430,86 +585,246 @@
   if (x+w>dispWIDE) w = dispWIDE-x;
   if (y+h>dispHIGH) h = dispHIGH-y;
 
-  if (w==0 || h==0) {  /* selected nothing */
+  if (w<=0 || h<=0) {  /* selected nothing */
     ungrabX();
     return 0;
   }
 
-  if (!XGetWindowAttributes(theDisp, clickWin, &xwa)) {
-    sprintf(str,"Unable to get window attributes for clicked-on window\n");
+
+  /* grab this region, using the default (root's) visual */
+
+  /* now for all top-level windows (children of root), in bottom->top order
+     if they intersect the grabregion
+       are they drawn entirely (including children) using default visual+cmap?
+       yes: if they intersect 'regrab' list, grab'em - else skip'em
+       no:  grab them, add their rectangle to 'regrab' list
+   */
+
+
+  /* make a 24bit grabPic */
+  gptype = PIC24;
+  gXOFF = x;  gYOFF = y;  gWIDE = w;  gHIGH = h;
+  grabPic = (byte *) malloc((size_t) gWIDE * gHIGH * 3);
+  if (!grabPic) {
     ungrabX();
-    ErrPopUp(str, "\nThat Sucks!");
+    ErrPopUp("Unable to malloc() space for grabbed image!", "\nBite Me!");
     return 0;
   }
 
-
-  XTranslateCoordinates(theDisp, rootW, clickWin, x, y, &ix, &iy, &win);
-
-  xerrcode = 0;
-  image = XGetImage(theDisp, clickWin, ix, iy, (u_int) w, (u_int) h, 
-		    AllPlanes, ZPixmap);
-  if (xerrcode || !image || !image->data) {
-    sprintf(str, "Unable to get image (%d,%d %dx%d) from display", ix,iy,w,h);
+  if (!XGetWindowAttributes(theDisp, rootW, &xwa)) {
     ungrabX();
-    ErrPopUp(str, "\nThat Sucks!");
+    ErrPopUp("Can't get window attributes for root window!", "\nBite Me!");
     return 0;
   }
 
-  ncolors = getxcolors(&xwa, &colors);
+  i = grabWinImage(rootW, XVisualIDFromVisual(xwa.visual), xwa.colormap,0);
 
   ungrabX();
 
-  if (ncolors && DEBUG) {
-    fprintf(stderr, "Colormap:\n");
-    for (i=0; i<ncolors; i++)
-      fprintf(stderr,"%02x%02x%02x  ",colors[i].red>>8, colors[i].green>>8,
-	      colors[i].blue>>8);
-    fprintf(stderr,"\n");
-  }
-
-
   XBell(theDisp, 0);    /* beep twice at end of grab */
   XBell(theDisp, 0);
 
-  i = convertImage(image, colors, ncolors, &xwa);
+  { /* free regrabList */
+    struct rectlist *rr, *tmprr;
+    rr = regrabList;
+    while (rr) {
+      tmprr = rr->next;
+      free((char *) rr);
+      rr = tmprr;
+    }
+    regrabList = (struct rectlist *) NULL;
+  }
+
+  if (i) {
+    ErrPopUp("Warning: Problems occurred during grab.","\nWYSInWYG!");
+    return 0;
+  }
 
-  /* DO *NOT* use xvDestroyImage(), as the 'data' field was alloc'd by X, not
-     necessarily through 'malloc() / free()' */
-  XDestroyImage(image);   
-  
-  if (colors) free((char *) colors);
 
-  return i;
+  /* if 256 or fewer colors in grabPic, make it a PIC8 */
+  i = CountColors24(grabPic, gWIDE, gHIGH, 0,0,gWIDE,gHIGH);
+  if (i<=256) {
+    byte *pic8;
+    pic8 = (byte *) malloc((size_t) (gWIDE * gHIGH));
+    if (pic8) {
+      if (Trivial24to8(grabPic, gWIDE,gHIGH, pic8,
+		       grabmapR,grabmapG,grabmapB,256)) {
+	free((char *) grabPic);
+	grabPic = pic8;
+	gptype = PIC8;
+      }
+    }
+  }
+
+  return 1;  /* full success */
 }
 
 
-static void ungrabX()
+/***********************************/
+static int grabWinImage(win, parentVid, parentCmap, toplevel)
+     Window win;
+     VisualID           parentVid;
+     Colormap           parentCmap;
+     int                toplevel;
 {
-  XUngrabServer(theDisp);
-  XUngrabButton(theDisp, (u_int) AnyButton, 0, rootW);
-}
+  /* grabs area of window (and its children) that intersects
+   * grab region (root coords: gXOFF,gYOFF,gWIDE,gHIGH), and stuffs
+   * relevant bits into the grabPic (a gWIDE*gHIGH PIC24)
+   *
+   * Note: special kludge for toplevel windows (children of root):
+   * since that's the only case where a window can be obscuring something
+   * that isn't its parent
+   *
+   * returns 0 if okay, 1 if problems occurred
+   */
+
+
+  int               i, rv, dograb;
+  int               wx, wy, ww, wh;      /* root coords of window */
+  int               gx, gy, gw, gh;      /* root coords of grab region of win*/
+  Window            chwin;               /* unused */
+  u_int             nchildren;
+  Window            root, parent, *children;
+  XWindowAttributes xwa;
 
+  /* first, quick checks to avoid recursing down useless branches */
 
+  if (!XGetWindowAttributes(theDisp, win, &xwa)) {
+    if (DEBUG) fprintf(stderr,"gWI: can't get win attr (%08x)\n", (u_int) win);
+    return 1;
+  }
 
+  if (xwa.class == InputOnly || xwa.map_state != IsViewable) return 0;
 
+  rv     = 0;
+  dograb = 1;
+  wx = 0;  wy = 0;  ww = (int) xwa.width;  wh = (int) xwa.height;
+
+  /* if this window doesn't intersect, none of its children will, either */
+  XTranslateCoordinates(theDisp, win, rootW, 0,0, &wx, &wy, &chwin);
+  if (!RectIntersect(wx,wy,ww,wh, gXOFF,gYOFF,gWIDE,gHIGH)) return 0;
+
+  gx = wx;  gy = wy;  gw = ww;  gh = wh;
+  CropRect2Rect(&gx,&gy,&gw,&gh, gXOFF,gYOFF,gWIDE,gHIGH);
+
+  if (win==rootW) {
+    /* always grab */
+  }
+
+  else if (XVisualIDFromVisual(xwa.visual) == parentVid &&
+	   ((xwa.visual->class==TrueColor) || xwa.colormap == parentCmap)) {
+
+    /* note: if both visuals are TrueColor, don't compare cmaps */
+
+    /* normally, if the vis/cmap info of a window is the same as its parent,
+       no need to regrab window.  special case if this is a toplevel
+       window, as it can be obscuring windows that *aren't* its parent */
+
+    if (toplevel) {
+      /* we probably already have this region.  Check it against regrabList
+	 If it intersects none, no need to grab.
+	 If it intersects one,  crop to that rectangle and grab
+	 if it intersects >1,   don't crop, just grab gx,gy,gw,gh */
+
+      struct rectlist *rr, *cr;
+
+      i=0; cr=rr=regrabList;
+      while (rr) {
+	if (RectIntersect(gx,gy,gw,gh, rr->x,rr->y,rr->w,rr->h)) {
+	  i++;  cr = rr;
+	}
+	rr = rr->next;
+      }
+
+      if (i==0) dograb=0;   /* no need to grab */
+
+      if (i==1) CropRect2Rect(&gx,&gy,&gw,&gh, cr->x,cr->y,cr->w,cr->h);
+    }
+    else dograb = 0;
+  }
+
+  else {
+    /* different vis/cmap from parent:
+       add to regrab list, if not already fully contained in list */
+    struct rectlist *rr;
+
+    /* check to see if fully contained... */
+    rr=regrabList;
+    while (rr && RectIntersect(gx,gy,gw,gh, rr->x,rr->y,rr->w,rr->h)!=2)
+      rr = rr->next;
+
+    if (!rr) {   /* add to list */
+      if (DEBUG)
+	fprintf(stderr,"added to regrabList: %d,%d %dx%d\n",gx,gy,gw,gh);
+
+      rr = (struct rectlist *) malloc(sizeof(struct rectlist));
+      if (!rr) return 1;
+      else {
+	rr->x = gx;  rr->y = gy;  rr->w = gw;  rr->h = gh;
+	rr->next = regrabList;
+	regrabList = rr;
+      }
+    }
+  }
+
+  /* at this point, we have to grab gx,gy,gw,gh from 'win' */
+
+  if (dograb) {
+    int     ix, iy, ncolors;
+    XColor *colors;
+    XImage *image;
+
+    XTranslateCoordinates(theDisp, rootW, win, gx, gy, &ix, &iy, &chwin);
+
+    if (DEBUG)
+      fprintf(stderr,"Grabbing win (%08x) %d,%d %dx%d\n",
+	      (u_int) win, gx,gy,gw,gh);
+
+    WaitCursor();
+
+    xerrcode = 0;
+    image = XGetImage(theDisp, win, ix, iy, (u_int) gw, (u_int) gh,
+		      AllPlanes, ZPixmap);
+    if (xerrcode || !image || !image->data) return 1;
+
+    ncolors = getxcolors(&xwa, &colors);
+    rv = convertImageAndStuff(image, colors, ncolors, &xwa,
+			      gx - gXOFF, gy - gYOFF, gw, gh);
+    XDestroyImage(image);   /* can't use xvDestroyImage: alloc'd by X! */
+    if (colors) free((char *) colors);
+  }
+
+
+  /* recurse into children to see if any of them are 'different'... */
+
+  if (!XQueryTree(theDisp, win, &root, &parent, &children, &nchildren)) {
+    if (DEBUG) fprintf(stderr,"XQueryTree(%08x) failed\n", (u_int) win);
+    if (children) XFree((char *)children);
+    return rv+1;
+  }
+
+  for (i=0; i<nchildren; i++) {
+    rv += grabWinImage(children[i], XVisualIDFromVisual(xwa.visual),
+		       xwa.colormap, (win==rootW));
+  }
+  if (children) XFree((char *)children);
+
+  return rv;
+}
 
-union swapun {
-  CARD32 l;
-  CARD16 s;
-  CARD8  b[sizeof(CARD32)];
-};
 
 
 /**************************************/
-static int convertImage(image, colors, ncolors, xwap)
+static int convertImageAndStuff(image, colors, ncolors, xwap, gx,gy,gw,gh)
      XImage *image;
      XColor *colors;
      int     ncolors;
      XWindowAttributes *xwap;
+     int     gx,gy,gw,gh;      /* position within grabPic (guaranteed OK) */
 {
-  /* attempts to conver the image from whatever weird-ass format it might
-     be in into something E-Z to deal with (either an 8-bit colormapped
-     image, or a 24-bit image).  Returns '1' on success. */
+  /* attempts to convert the image from whatever weird-ass format it might
+     be in into a 24-bit RGB image, and stuff it into grabPic
+     Returns 0 on success, 1 on failure */
 
   /* this code owes a lot to 'xwdtopnm.c', part of the pbmplus package,
      written by Jef Poskanzer */
@@ -528,7 +843,6 @@
   int            isLsbMachine, flipBytes;
   Visual         *visual;
   char            errstr[256];
-  static char    *foo[] = { "\nThat Sucks!" };
 
 
   /* quiet compiler warnings */
@@ -538,20 +852,20 @@
   pixvalue  = 0;
   rmask  = gmask  = bmask = 0;
   rshift = gshift = bshift = 0;
-
+  r8shift = g8shift = b8shift = 0;
 
   /* determine byte order of the machine we're running on */
   sw.l = 1;
   isLsbMachine = (sw.b[0]) ? 1 : 0;
 
-  if (xwap && xwap->visual) visual = xwap->visual;
-                       else visual = theVisual;
+  visual = xwap->visual;
+
 
-  if (DEBUG) {
+  if (DEBUG>1) {
     fprintf(stderr,"convertImage:\n");
     fprintf(stderr,"  %dx%d (offset %d), %s\n",
-	    image->width, image->height, image->xoffset, 
-	    (image->format == XYBitmap || image->format == XYPixmap) 
+	    image->width, image->height, image->xoffset,
+	    (image->format == XYBitmap || image->format == XYPixmap)
 	    ? "XYPixmap" : "ZPixmap");
 
     fprintf(stderr,"byte_order = %s, bitmap_bit_order = %s, unit=%d, pad=%d\n",
@@ -575,41 +889,17 @@
     sprintf(errstr, "%s\nReturned image bitmap_unit (%d) non-standard.",
 	    "Can't deal with this display.", image->bitmap_unit);
     ErrPopUp(errstr, "\nThat Sucks!");
-    return 0;
+    return 1;
   }
 
   if (!ncolors && visual->class != TrueColor) {
     sprintf(errstr, "%s\nOnly TrueColor displays can have no colormap.",
 	    "Can't deal with this display.");
     ErrPopUp(errstr, "\nThat Sucks!");
-    return 0;
+    return 1;
   }
 
 
-  /* build the 'global' grabPic stuff */
-  gWIDE = image->width;  gHIGH = image->height;
-
-  if (visual->class == TrueColor || visual->class == DirectColor ||
-      ncolors > 256) {
-    grabPic = (byte *) malloc((size_t) gWIDE * gHIGH * 3);
-    gbits = 24;
-  }
-  else {
-    grabPic = (byte *) malloc((size_t) gWIDE * gHIGH);
-    gbits = 8;
-
-    /* load up the colormap */
-    for (i=0; i<ncolors; i++) {
-      grabmapR[i] = colors[i].red   >> 8;
-      grabmapG[i] = colors[i].green >> 8;
-      grabmapB[i] = colors[i].blue  >> 8;
-    }
-  }
-  
-  if (!grabPic) FatalError("unable to malloc grabPic in convertImage()");
-  pptr = grabPic;
-
-
   if (visual->class == TrueColor || visual->class == DirectColor) {
     unsigned int tmp;
 
@@ -634,16 +924,35 @@
     while (tmp >= 256) { tmp >>= 1;  b8shift -= 1; }
     while (tmp < 128)  { tmp <<= 1;  b8shift += 1; }
 
-    if (DEBUG)
+    if (DEBUG>1)
       fprintf(stderr,"True/DirectColor: shifts=%d,%d,%d  8shifts=%d,%d,%d\n",
 	      rshift, gshift, bshift, r8shift, g8shift, b8shift);
   }
 
 
-  bits_per_item = image->bitmap_unit;
-  bits_used = bits_per_item;
+  bits_per_item  = image->bitmap_unit;
   bits_per_pixel = image->bits_per_pixel;
 
+
+  /* add code for freako 'exceed' server, where bitmapunit = 8
+     and bitsperpix = 32 (and depth=24)... */
+
+  if (bits_per_item < bits_per_pixel) {
+    bits_per_item = bits_per_pixel;
+
+    /* round bits_per_item up to next legal value, if necc */
+    if      (bits_per_item <  8) bits_per_item = 8;
+    else if (bits_per_item < 16) bits_per_item = 16;
+    else                         bits_per_item = 32;
+  }
+
+
+  /* which raises the question:  how (can?) you ever have a 24 bits per pix,
+     (ie, 3 bytes, no alpha/padding) */
+
+
+  bits_used = bits_per_item;  /* so it will get a new item first time */
+
   if (bits_per_pixel == 32) pixmask = 0xffffffff;
   else pixmask = (((CARD32) 1) << bits_per_pixel) - 1;
 
@@ -652,14 +961,15 @@
 
   /* if we're on an lsbfirst machine, or the image came from an lsbfirst
      machine, we should flip the bytes around.  NOTE:  if we're on an
-     lsbfirst machine *and* the image came from an lsbfirst machine, 
+     lsbfirst machine *and* the image came from an lsbfirst machine,
      *don't* flip bytes, as it should work out */
 
-  /* pity we don't have a logical exclusive-or */
   flipBytes = ( isLsbMachine && byte_order != LSBFirst) ||
               (!isLsbMachine && byte_order == LSBFirst);
 
   for (i=0; i<image->height; i++) {
+    pptr = grabPic + ((i+gy) * gWIDE + gx) * 3;
+
     lineptr = (byte *) image->data + (i * image->bytes_per_line);
     bptr = ((CARD8  *) lineptr) - 1;
     sptr = ((CARD16 *) lineptr) - 1;
@@ -667,35 +977,39 @@
     bits_used = bits_per_item;
 
     for (j=0; j<image->width; j++) {
-      
       /* get the next pixel value from the image data */
 
       if (bits_used == bits_per_item) {  /* time to move on to next b/s/l */
 	switch (bits_per_item) {
-	case 8:  bptr++;  break;
-	case 16: sptr++;  sval = *sptr;
-	         if (flipBytes) {   /* swap CARD16 */
-		   sw.s = sval;
-		   tmpbyte = sw.b[0];
-		   sw.b[0] = sw.b[1];
-		   sw.b[1] = tmpbyte;
-		   sval = sw.s;
-		 }
-	         break;
-	case 32: lptr++;  lval = *lptr;
-	         if (flipBytes) {   /* swap CARD32 */
-		   sw.l = lval;
-		   tmpbyte = sw.b[0];
-		   sw.b[0] = sw.b[3];
-		   sw.b[3] = tmpbyte;
-		   tmpbyte = sw.b[1];
-		   sw.b[1] = sw.b[2];
-		   sw.b[2] = tmpbyte;
-		   lval = sw.l;
-		 }
-	         break;
+	case 8:
+	  bptr++;  break;
+
+	case 16:
+	  sptr++;  sval = *sptr;
+	  if (flipBytes) {   /* swap CARD16 */
+	    sw.s = sval;
+	    tmpbyte = sw.b[0];
+	    sw.b[0] = sw.b[1];
+	    sw.b[1] = tmpbyte;
+	    sval = sw.s;
+	  }
+	  break;
+
+	case 32:
+	  lptr++;  lval = *lptr;
+	  if (flipBytes) {   /* swap CARD32 */
+	    sw.l = lval;
+	    tmpbyte = sw.b[0];
+	    sw.b[0] = sw.b[3];
+	    sw.b[3] = tmpbyte;
+	    tmpbyte = sw.b[1];
+	    sw.b[1] = sw.b[2];
+	    sw.b[2] = tmpbyte;
+	    lval = sw.l;
+	  }
+	  break;
 	}
-		   
+
 	bits_used = 0;
 	if (bit_order == MSBFirst) bit_shift = bits_per_item - bits_per_pixel;
 	                      else bit_shift = 0;
@@ -711,11 +1025,11 @@
                             else bit_shift += bits_per_pixel;
       bits_used += bits_per_pixel;
 
-      
+
       /* okay, we've got the next pixel value in 'pixvalue' */
-      
+
       if (visual->class == TrueColor || visual->class == DirectColor) {
-	/* in either case, we have to take the pixvalue and 
+	/* in either case, we have to take the pixvalue and
 	   break it out into individual r,g,b components */
 	rval = (pixvalue & rmask) >> rshift;
 	gval = (pixvalue & gmask) >> gshift;
@@ -741,212 +1055,169 @@
 	/* use pixel value as an index into colors array */
 
 	if (pixvalue >= ncolors) {
-	  FatalError("convertImage(): pixvalue >= ncolors");
-	}
-
-	if (gbits == 24) {   /* too many colors for 8-bit colormap */
-	  *pptr++ = (colors[pixvalue].red)   >> 8;
-	  *pptr++ = (colors[pixvalue].green) >> 8;
-	  *pptr++ = (colors[pixvalue].blue)  >> 8;
+	  fprintf(stderr, "WARNING: convertImage(): pixvalue >= ncolors\n");
+	  return 1;
 	}
-	else *pptr++ = pixvalue & 0xff;
 
+	*pptr++ = (colors[pixvalue].red)   >> 8;
+	*pptr++ = (colors[pixvalue].green) >> 8;
+	*pptr++ = (colors[pixvalue].blue)  >> 8;
       }
     }
   }
 
-  return 1;
+  return 0;
 }
 
 
 
-/**************************************/
-static int lowbitnum(ul)
-     unsigned long ul;
+/***********************************/
+static int RectIntersect(ax,ay,aw,ah, bx,by,bw,bh)
+     int ax,ay,aw,ah, bx,by,bw,bh;
 {
-  /* returns position of lowest set bit in 'ul' as an integer (0-31),
-   or -1 if none */
-
-  int i;
-  for (i=0; ((ul&1) == 0) && i<32;  i++, ul>>=1);
-  if (i==32) i = -1;
-  return i;
-}
+  /* returns 0 if rectangles A and B do not intersect
+     returns 1 if A partially intersects B
+     returns 2 if rectangle A is fully enclosed by B */
 
+  int ax1,ay1, bx1,by1;
 
+  ax1 = ax+aw-1;  ay1 = ay+ah-1;
+  bx1 = bx+bw-1;  by1 = by+bh-1;
 
-/**************************************/
-/* following code snarfed from 'xwd.c' */
-/**************************************/
+  if (ax1<bx || ax>bx1 || ay1<by || ay>by1) return 0;
 
-#define lowbit(x) ((x) & (~(x) + 1))
+  if (ax>=bx && ax1<=bx1 && ay>=by && ay1<=by) return 2;
 
+  return 1;
+}
 
-static int getxcolors(win_info, colors)
-     XWindowAttributes *win_info;
-     XColor **colors;
-{
-  int i, ncolors;
-  Colormap cmap;
-
-  *colors = (XColor *) NULL;
-
-  if (win_info->visual->class == TrueColor) {
-    if (DEBUG) fprintf(stderr,"TrueColor visual:  no colormap needed\n");
-    return 0;
-  }
 
-  else if (!win_info->colormap) {
-    if (DEBUG) fprintf(stderr,"no colormap associated with window\n");
-    return 0;
-  }
 
-  ncolors = win_info->visual->map_entries;
-  if (DEBUG) fprintf(stderr,"%d entries in colormap\n", ncolors);
 
-  if (!(*colors = (XColor *) malloc (sizeof(XColor) * ncolors)))
-    FatalError("malloc failed in getxcolors()");
 
+/** stuff needed to make new xvgrab work in 3.10a. **/
 
-  if (win_info->visual->class == DirectColor) {
-    Pixel red, green, blue, red1, green1, blue1;
+/********************************************/
+static int CountColors24(pic, pwide, phigh, x, y, w, h)
+     byte *pic;
+     int   pwide, phigh, x,y,w,h;
+{
+  /* counts the # of unique colors in a selected rect of a PIC24
+     returns '0-256' or >256 */
 
-    if (DEBUG) fprintf(stderr,"DirectColor visual\n");
+  int    i, j, nc;
+  int    low, high, mid;
+  u_int  colors[257], col;
+  byte   *pp;
+
+  nc = 0;
+
+  for (i=y; nc<257 && i<y+h; i++) {
+    pp = pic + (i*pwide + x)*3;
+
+    for (j=x; nc<257 && j<x+w; j++, pp+=3) {
+      col = (((u_int) pp[0])<<16) + (((u_int) pp[1])<<8) + pp[2];
+
+      /* binary search the 'colors' array to see if it's in there */
+      low = 0;  high = nc-1;
+      while (low <= high) {
+	mid = (low+high)/2;
+	if      (col < colors[mid]) high = mid - 1;
+	else if (col > colors[mid]) low  = mid + 1;
+	else break;
+      }
 
-    red = green = blue = 0;
-    red1   = lowbit(win_info->visual->red_mask);
-    green1 = lowbit(win_info->visual->green_mask);
-    blue1  = lowbit(win_info->visual->blue_mask);
-    for (i=0; i<ncolors; i++) {
-      (*colors)[i].pixel = red|green|blue;
-      (*colors)[i].pad = 0;
-      red += red1;
-      if (red > win_info->visual->red_mask)     red = 0;
-      green += green1;
-      if (green > win_info->visual->green_mask) green = 0;
-      blue += blue1;
-      if (blue > win_info->visual->blue_mask)   blue = 0;
-    }
-  }
-  else {
-    for (i=0; i<ncolors; i++) {
-      (*colors)[i].pixel = i;
-      (*colors)[i].pad = 0;
+      if (high < low) { /* didn't find color in list, add it. */
+	xvbcopy((char *) &colors[low], (char *) &colors[low+1],
+		(nc - low) * sizeof(u_int));
+	colors[low] = col;
+	nc++;
+      }
     }
   }
 
-  XQueryColors(theDisp, win_info->colormap, *colors, ncolors);
-
-  return(ncolors);
+  return nc;
 }
-    
 
 
-
-
-/***********************************/
-int LoadGrab(pinfo)
-     PICINFO *pinfo;
+/****************************/
+static int Trivial24to8(pic24, w,h, pic8, rmap,gmap,bmap, maxcol)
+     byte *pic24, *pic8, *rmap, *gmap, *bmap;
+     int   w,h,maxcol;
 {
-  /* loads up (into XV structures) last image successfully grabbed.
-     returns '0' on failure, '1' on success */
-
-  int   i;
-
-  if (!grabPic) return 0;   /* no image to use */
-
-  if (gbits == 24) pinfo->type = PIC24;
-  else {
-    pinfo->type = PIC8;
+  /* scans picture until it finds more than 'maxcol' different colors.  If it
+     finds more than 'maxcol' colors, it returns '0'.  If it DOESN'T, it does
+     the 24-to-8 conversion by simply sticking the colors it found into
+     a colormap, and changing instances of a color in pic24 into colormap
+     indicies (in pic8) */
+
+  unsigned long colors[256],col;
+  int           i, nc, low, high, mid;
+  byte         *p, *pix;
+
+  if (maxcol>256) maxcol = 256;
+
+  /* put the first color in the table by hand */
+  nc = 0;  mid = 0;
+
+  for (i=w*h,p=pic24; i; i--) {
+    col  = (((u_long) *p++) << 16);
+    col += (((u_long) *p++) << 8);
+    col +=  *p++;
+
+    /* binary search the 'colors' array to see if it's in there */
+    low = 0;  high = nc-1;
+    while (low <= high) {
+      mid = (low+high)/2;
+      if      (col < colors[mid]) high = mid - 1;
+      else if (col > colors[mid]) low  = mid + 1;
+      else break;
+    }
 
-    for (i=0; i<256; i++) {
-      pinfo->r[i] = grabmapR[i];
-      pinfo->g[i] = grabmapG[i];
-      pinfo->b[i] = grabmapB[i];
+    if (high < low) { /* didn't find color in list, add it. */
+      if (nc>=maxcol) return 0;
+      xvbcopy((char *) &colors[low], (char *) &colors[low+1],
+	      (nc - low) * sizeof(u_long));
+      colors[low] = col;
+      nc++;
     }
   }
 
-  pinfo->pic     = grabPic;
-  pinfo->normw   = pinfo->w   = gWIDE;
-  pinfo->normh   = pinfo->h   = gHIGH;
-  pinfo->frmType = -1;
-  pinfo->colType = -1;
-
-  sprintf(pinfo->fullInfo,"<%s internal>", 
-	  (pinfo->type == PIC8) ? "8-bit" : "24-bit");
-  
-  sprintf(pinfo->shrtInfo,"%dx%d image.",gWIDE, gHIGH);
-  
-  pinfo->comment = (char *) NULL;
-
-  grabPic = (byte *) NULL;
-
-  return 1;
-}
-
-
-
-
-
-#include <X11/Xlib.h>
-#include <X11/Xatom.h>
-
-static Window TryChildren PARM((Display *, Window, Atom));
 
-/* Find a window with WM_STATE, else return '0' */
+  /* run through the data a second time, this time mapping pixel values in
+     pic24 into colormap offsets into 'colors' */
 
-static Window xvClientWindow (dpy, win)
-    Display *dpy;
-    Window win;
-{
-    Atom WM_STATE;
-    Atom type = None;
-    int format;
-    unsigned long nitems, after;
-    unsigned char *data;
-    Window inf;
-
-    WM_STATE = XInternAtom(dpy, "WM_STATE", True);
-    if (!WM_STATE) return win;
+  for (i=w*h,p=pic24, pix=pic8; i; i--,pix++) {
+    col  = (((u_long) *p++) << 16);
+    col += (((u_long) *p++) << 8);
+    col +=  *p++;
+
+    /* binary search the 'colors' array.  It *IS* in there */
+    low = 0;  high = nc-1;
+    while (low <= high) {
+      mid = (low+high)/2;
+      if      (col < colors[mid]) high = mid - 1;
+      else if (col > colors[mid]) low  = mid + 1;
+      else break;
+    }
 
-    XGetWindowProperty(dpy, win, WM_STATE, 0L, 0L, False, AnyPropertyType,
-		       &type, &format, &nitems, &after, &data);
-    if (type) return win;
+    if (high < low) {
+      fprintf(stderr,"Trivial24to8:  impossible situation!\n");
+      exit(1);
+    }
+    *pix = mid;
+  }
 
-    inf = TryChildren(dpy, win, WM_STATE);
+  /* and load up the 'desired colormap' */
+  for (i=0; i<nc; i++) {
+    rmap[i] =  colors[i]>>16;
+    gmap[i] = (colors[i]>>8) & 0xff;
+    bmap[i] =  colors[i]     & 0xff;
+  }
 
-    return inf;
+  return 1;
 }
 
-static Window TryChildren (dpy, win, WM_STATE)
-    Display *dpy;
-    Window win;
-    Atom WM_STATE;
-{
-    Window root, parent;
-    Window *children;
-    unsigned int nchildren;
-    unsigned int i;
-    Atom type = None;
-    int format;
-    unsigned long nitems, after;
-    unsigned char *data;
-    Window inf = 0;
-
-    if (!XQueryTree(dpy, win, &root, &parent, &children, &nchildren))
-	return 0;
 
-    for (i = 0; !inf && (i < nchildren); i++) {
-	XGetWindowProperty(dpy, children[i], WM_STATE, 0L, 0L, False,
-			   AnyPropertyType, &type, &format, &nitems,
-			   &after, &data);
-	if (type)
-	  inf = children[i];
-    }
 
-    for (i = 0; !inf && (i < nchildren); i++)
-      inf = TryChildren(dpy, children[i], WM_STATE);
 
-    if (children) XFree((char *)children);
-    return inf;
-}
diff -ruN xv-3.10a/xvgraf.c xv-3.10a-bugfixes/xvgraf.c
--- xv-3.10a/xvgraf.c	1994-12-22 14:34:42.000000000 -0800
+++ xv-3.10a-bugfixes/xvgraf.c	2004-05-16 18:03:34.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * xvgraf.c - GRAF window handling functions
  *
  * callable functions:
@@ -88,7 +88,7 @@
   gp->win = XCreateSimpleWindow(theDisp, parent, x,y, GWIDE, GHIGH, 1, fg,bg);
   if (!gp->win) FatalError("can't create graph (main) window");
 
-  gp->gwin = XCreateSimpleWindow(theDisp, gp->win, 2, GHIGH-132, 
+  gp->gwin = XCreateSimpleWindow(theDisp, gp->win, 2, GHIGH-132,
 				 128, 128, 1, fg,bg);
   if (!gp->gwin) FatalError("can't create graph (sub) window");
 
@@ -96,7 +96,7 @@
     BTCreate(&gp->butts[i], gp->win, GWIDE-GBWIDE-2, 1+i * (GBHIGH + 1),
 	     GBWIDE, GBHIGH, (char *) NULL, fg, bg, hicol, locol);
     gp->butts[i].pix = gfbpix[i];
-    gp->butts[i].pw = PW;  
+    gp->butts[i].pw = PW;
     gp->butts[i].ph = PH;
   }
 
@@ -132,7 +132,7 @@
 
   gp->gammamode = 0;     gp->gamma = 1.0;
 }
-  
+
 
 /***************************************************/
 void RedrawGraf(gp, gwin)
@@ -148,7 +148,7 @@
   else {
     Draw3dRect(gp->win, 0,0, GWIDE-1, GHIGH-1, R3D_OUT, 1, hicol, locol,
 	       gp->bg);
-    
+
     XSetForeground(theDisp, theGC, gp->fg);
     XSetBackground(theDisp, theGC, gp->bg);
     DrawString(gp->win, 2, 1+ASCENT, gp->str);
@@ -165,7 +165,7 @@
 {
   int i,x,y;
   XPoint  pts[129], *pt;
-  
+
 
   if (gp->entergamma) {
     char *str1 = "Enter gamma";
@@ -181,15 +181,15 @@
     x = 10 + StringWidth(str2) + 8;
     y = 30 + ASCENT + CHIGH + 3;
     i = StringWidth(gp->gvstr);
-    if (gp->entergamma < 0 && strlen(gp->gvstr)) { 
+    if (gp->entergamma < 0 && strlen(gp->gvstr)) {
       /* show string highlited */
       XFillRectangle(theDisp, gp->gwin, theGC, x-1, y-ASCENT-1,
 		     (u_int) i+2, (u_int) CHIGH+2);
       XSetForeground(theDisp, theGC, gp->bg);
     }
-    else 
+    else
       XDrawLine(theDisp, gp->gwin, theGC, x+i, y-ASCENT, x+i, y+DESCENT);
-      
+
     DrawString(gp->gwin, x,y, gp->gvstr);
 
     return;
@@ -267,7 +267,7 @@
     if (i<N_GFB) {  /* found one */
       if (BTTrack(bp)) {  /* it was selected */
 	switch (i) {
-	case GFB_SPLINE: 
+	case GFB_SPLINE:
 	case GFB_LINE:
 	  gp->gammamode = 0;
 
@@ -312,7 +312,7 @@
 	  if (gp->nhands < MAX_GHANDS) {
 	    /* find largest x-gap in handles, put new handle in mid */
 	    int lgap, lpos, x, y;
-	    
+
 	    lgap = gp->hands[1].x - gp->hands[0].x;
 	    lpos = 1;
 	    for (j=1; j<gp->nhands-1; j++)
@@ -320,11 +320,11 @@
 		lgap = gp->hands[j+1].x - gp->hands[j].x;
 		lpos = j+1;
 	      }
-	  
+
 	    /* open up position in hands[] array */
-	    xvbcopy((char *) &gp->hands[lpos], (char *) &gp->hands[lpos+1], 
+	    xvbcopy((char *) &gp->hands[lpos], (char *) &gp->hands[lpos+1],
 		    (gp->nhands - lpos) * sizeof(XPoint));
-	  
+
 	    x = gp->hands[lpos-1].x + lgap/2;
 	    y = gp->func[x];
 	    gp->hands[lpos].x = x;
@@ -343,7 +343,7 @@
 	      BTSetActive(&gp->butts[GFB_DELH], 1);
 	  }
 	  break;
-		       
+
 	case GFB_DELH:
 	  if (gp->nhands > 2) {
 	    /* find (middle) point whose x-distance to previous
@@ -361,9 +361,9 @@
 		mdist = dist;  mpos = j;
 	      }
 	    }
-		       
+
 	    /* delete position 'mpos' in hands[] array */
-	    xvbcopy((char *) &gp->hands[mpos+1], (char *) &gp->hands[mpos], 
+	    xvbcopy((char *) &gp->hands[mpos+1], (char *) &gp->hands[mpos],
 		    (gp->nhands-mpos-1) * sizeof(XPoint));
 
 	    gp->nhands--;
@@ -408,16 +408,16 @@
 
 	/* keep original mouse position in 'mx,my', and warp mouse to center
 	   of screen */
-	grab = !XGrabPointer(theDisp, gp->gwin, False, 0, GrabModeAsync, 
+	grab = !XGrabPointer(theDisp, gp->gwin, False, 0, GrabModeAsync,
 			  GrabModeAsync, None, inviso, (Time) CurrentTime);
-	XWarpPointer(theDisp, None, rootW, 0,0,0,0, 
+	XWarpPointer(theDisp, None, rootW, 0,0,0,0,
 		     (int) dispWIDE/2, (int) dispHIGH/2);
 
-	origx = dispWIDE/2;  origy = dispHIGH/2;  
+	origx = dispWIDE/2;  origy = dispHIGH/2;
 	orighx = gp->hands[h].x;  orighy = gp->hands[h].y;
 
 	gp->gammamode = 0;
-	offx = gp->hands[h].x - origx;  
+	offx = gp->hands[h].x - origx;
 	offy = gp->hands[h].y - origy;
 
 	vertonly = (h==0 || h==(gp->nhands-1));
@@ -434,7 +434,7 @@
 
 	  dx = x - origx;  dy = origy - y;   /* flip y axis */
 
-	  /* new (virt) position of handle is (desired) 
+	  /* new (virt) position of handle is (desired)
 	     orighx + dx, orighy + dy */
 
 	  if (!vertonly) { /* keep this handle between its neighbors */
@@ -448,7 +448,7 @@
 	  if (newx != gp->hands[h].x || newy != gp->hands[h].y) {
 	    /* this handle has moved... */
 	    XSetForeground(theDisp, theGC, gp->bg);
-	    XFillRectangle(theDisp, gp->gwin, theGC, 
+	    XFillRectangle(theDisp, gp->gwin, theGC,
 		     (gp->hands[h].x/2)-3, ((255-gp->hands[h].y)/2)-3, 7,7);
 
 	    gp->hands[h].x = newx;  gp->hands[h].y = newy;
@@ -464,7 +464,7 @@
 	}
 
 	drawHandPos(gp, -1);
-	XWarpPointer(theDisp, None, gp->gwin, 0,0,0,0, 
+	XWarpPointer(theDisp, None, gp->gwin, 0,0,0,0,
 		     gp->hands[h].x/2, (255-gp->hands[h].y)/2);
 	if (grab) XUngrabPointer(theDisp, (Time) CurrentTime);
       }
@@ -481,9 +481,9 @@
 {
   int w;
   char *tstr = "888,888";
-  
+
   /* if hnum < 0, clears the text area */
-  
+
   XSetFont(theDisp, theGC, monofont);
   w = XTextWidth(monofinfo, tstr, (int) strlen(tstr));
 
@@ -492,12 +492,12 @@
 
   XSetForeground(theDisp, theGC, gp->fg);
   XSetBackground(theDisp, theGC, gp->bg);
-  XDrawImageString(theDisp, gp->win, theGC, 130-w, 1+ASCENT, 
+  XDrawImageString(theDisp, gp->win, theGC, 130-w, 1+ASCENT,
 		   str, (int) strlen(str));
 
   XSetFont(theDisp, theGC, mfont);
 }
-  
+
 
 /***************************************************/
 int GrafKey(gp,str)
@@ -518,7 +518,7 @@
   }
 
   while (*str) {
-    if (gp->entergamma == -1 && 
+    if (gp->entergamma == -1 &&
 	(*str != '\012' && *str != '\015' && *str != '\033')) {
       gp->entergamma = 1;
       gp->gvstr[0] = '\0';
@@ -529,7 +529,7 @@
     len = strlen(gp->gvstr);
 
     if (*str>= '0' && *str <= '9') {
-      if (len < GVMAX) { 
+      if (len < GVMAX) {
 	gp->gvstr[len++] = *str;
   	gp->gvstr[len] = '\0';
 	ok = 1;
@@ -607,18 +607,18 @@
 
   /* do sanity check.  (x-coords must be sorted (strictly increasing)) */
 
-  for (i=0; i<gp->nhands; i++) { 
-    RANGE(gp->hands[i].x, 0, 255); 
+  for (i=0; i<gp->nhands; i++) {
+    RANGE(gp->hands[i].x, 0, 255);
     RANGE(gp->hands[i].y, 0, 255);
   }
 
   gp->hands[0].x = 0;  gp->hands[gp->nhands-1].x = 255;
   for (i=1; i<gp->nhands-1; i++) {
     if (gp->hands[i].x < i)  gp->hands[i].x = i;
-    if (gp->hands[i].x > 256-gp->nhands+i)  
+    if (gp->hands[i].x > 256-gp->nhands+i)
         gp->hands[i].x = 256-gp->nhands+i;
 
-    if (gp->hands[i].x <= gp->hands[i-1].x) 
+    if (gp->hands[i].x <= gp->hands[i-1].x)
       gp->hands[i].x = gp->hands[i-1].x + 1;
   }
 
@@ -647,17 +647,17 @@
     else {   /* gp->gamma == 0.0 */
       for (i=0; i<256; i++) gp->func[i] = 0;
     }
-      
-    
+
+
     for (i=0; i<gp->nhands; i++) {
       gp->hands[i].y = gp->func[gp->hands[i].x];
     }
   }
-   
+
   else if (!gp->spline) {  /* do linear interpolation */
       int y,x1,y1,x2,y2;
       double yd;
-      
+
       for (i=0; i<gp->nhands-1; i++) {
 	x1 = gp->hands[ i ].x;  y1 = gp->hands[ i ].y;
 	x2 = gp->hands[i+1].x;  y2 = gp->hands[i+1].y;
@@ -676,12 +676,12 @@
     double yf[MAX_GHANDS];
     double yd;
 
-    for (i=0; i<gp->nhands; i++) { 
+    for (i=0; i<gp->nhands; i++) {
       x[i] = gp->hands[i].x;  y[i] = gp->hands[i].y;
     }
-    
+
     InitSpline(x, y, gp->nhands, yf);
-  
+
     for (i=0; i<256; i++) {
       yd = EvalSpline(x, y, yf, gp->nhands, (double) i);
       j = (int) floor(yd + 0.5);
@@ -750,7 +750,7 @@
   if (!str) return 1;  /* NULL strings don't parse well! */
 
   /* first, strip all pesky whitespace from str */
-  for (sp=str, dp=tstr; *sp; sp++) 
+  for (sp=str, dp=tstr; *sp; sp++)
     if (*sp > ' ') { *dp = *sp;  dp++; }
   *dp = '\0';
 
@@ -764,7 +764,7 @@
       }
     else return 1;
   }
-    
+
   /* read Spline, or Line (S/L) character */
   sp = tstr;
   if      (*sp == 'S' || *sp == 's') spline = 1;
@@ -784,7 +784,7 @@
     while (*sp && *sp != ':') {*dp = *sp;  dp++;  sp++; }
     *dp++ = '\0';
     if (sscanf(tstr1,"%d,%d",&x, &y) != 2) return 1;
-    if (x < 0 || x > 255 || 
+    if (x < 0 || x > 255 ||
 	y < 0 || y > 255) return 1;  /* out of range */
     coords[i].x = x;  coords[i].y = y;
   }
@@ -837,7 +837,7 @@
   IFSET(gp->gamma,      gsp->gamma);
   IFSET(gp->nhands,     gsp->nhands);
 
-  if (strcmp(gp->gvstr, gsp->gvstr)) 
+  if (strcmp(gp->gvstr, gsp->gvstr))
     { strcpy(gp->gvstr, gsp->gvstr);  rv++; }
 
   for (i=0; i<gp->nhands; i++) {
@@ -880,7 +880,7 @@
     sig = ((double) x[i]-x[i-1]) / ((double) x[i+1] - x[i-1]);
     p = sig * y2[i-1] + 2.0;
     y2[i] = (sig-1.0) / p;
-    u[i] = (((double) y[i+1]-y[i]) / (x[i+1]-x[i])) - 
+    u[i] = (((double) y[i+1]-y[i]) / (x[i+1]-x[i])) -
            (((double) y[i]-y[i-1]) / (x[i]-x[i-1]));
     u[i] = (6.0 * u[i]/(x[i+1]-x[i-1]) - sig*u[i-1]) / p;
   }
@@ -912,9 +912,9 @@
   if (h==0.0) FatalError("bad xvalues in splint\n");
   a = (xa[khi]-x)/h;
   b = (x-xa[klo])/h;
-  return (a*ya[klo] + b*ya[khi] + ((a*a*a-a)*y2a[klo] +(b*b*b-b)*y2a[khi]) 
+  return (a*ya[klo] + b*ya[khi] + ((a*a*a-a)*y2a[klo] +(b*b*b-b)*y2a[khi])
 	  * (h*h) / 6.0);
 }
-    
+
 
 
diff -ruN xv-3.10a/xviff.c xv-3.10a-bugfixes/xviff.c
--- xv-3.10a/xviff.c	1995-01-13 11:54:54.000000000 -0800
+++ xv-3.10a-bugfixes/xviff.c	2005-04-03 11:57:56.000000000 -0700
@@ -39,7 +39,7 @@
 
 static long filesize;
 
-static int           readID       PARM((FILE *, char *));
+/* static int           readID       PARM((FILE *, char *));  DOES NOT EXIST */
 static int           iffError     PARM((char *, char *));
 static void          decomprle    PARM((byte *, byte *, long, long));
 static unsigned int  iff_getword  PARM((byte *));
@@ -65,16 +65,16 @@
 /*******************************************/
 {
   /* returns '1' on success */
-  
+
   register byte bitmsk, rval, gval, bval;
   register long col, colbit;
   FILE          *fp;
   int           rv;
-  int           BMHDok, CMAPok, CAMGok, BODYok;
+  int           BMHDok, CMAPok, CAMGok;
   int           bmhd_width, bmhd_height, bmhd_bitplanes, bmhd_transcol;
   int           i, j, k, lineskip, colors, fmt;
   byte          bmhd_masking, bmhd_compression;
-  long          chunkLen, camg_viewmode, decomp_bufsize;
+  long          chunkLen, camg_viewmode;
   byte          *databuf, *dataptr, *cmapptr, *picptr, *pic, *bodyptr;
   byte          *workptr, *workptr2, *workptr3, *decomp_mem;
 
@@ -138,6 +138,7 @@
      BODY chunk was found or dataptr ran over end of file */
 
   while ((rv<0) && (dataptr < (databuf + filesize))) {
+    int npixels = 0;
     chunkLen = (iff_getlong(dataptr + 4) + 1) & 0xfffffffe; /* make even */
 
     if (strncmp((char *) dataptr, "BMHD", (size_t) 4)==0) { /* BMHD chunk? */
@@ -149,25 +150,30 @@
       bmhd_transcol    = iff_getword(dataptr + 8 + 12);
       BMHDok = 1;                                       /* got BMHD */
       dataptr += 8 + chunkLen;                          /* to next chunk */
+
+      npixels = bmhd_width * bmhd_height;  /* 65535*65535 max */
+      if (bmhd_width <= 0 || bmhd_height <= 0
+          || npixels/bmhd_width != bmhd_height)
+        return (iffError(bname, "xviff: image dimensions out of range"));
     }
 
 
     else if (strncmp((char *) dataptr, "CMAP", (size_t) 4)==0) { /* CMAP ? */
       cmapptr = dataptr + 8;
       colors = chunkLen / 3;                            /* calc no of colors */
-      
+
       /* copy colors to color map */
       for (i=0; i < colors; i++) {
 	pinfo->r[i] = *cmapptr++;
 	pinfo->g[i] = *cmapptr++;
 	pinfo->b[i] = *cmapptr++;
       }
-      
+
       CMAPok = 1;                                       /* got CMAP */
       dataptr += 8 + chunkLen;                          /* to next chunk */
     }
 
-    
+
     else if (strncmp((char *) dataptr, "CAMG", (size_t) 4)==0) {  /* CAMG ? */
       camg_viewmode = iff_getlong(dataptr + 8);             /* get viewmodes */
       CAMGok = 1;                                       /* got CAMG */
@@ -176,19 +182,28 @@
 
 
     else if (strncmp((char *) dataptr, "BODY", (size_t) 4)==0) { /* BODY ? */
+      int byte_width = (((bmhd_width + 15) >> 4) << 1);  /* 8192 max */
+
       bodyptr = dataptr + 8;                            /* -> BODY data */
-      
+
       if (BMHDok) {                                     /* BMHD found? */
 	/* if BODY is compressed, allocate buffer for decrunched BODY and
 	   decompress it (run length encoding) */
-	
+
 	if (bmhd_compression == 1) {
 	  /* calc size of decrunch buffer - (size of the actual picture
 	     decompressed in interleaved Amiga bitplane format) */
 
-	  decomp_bufsize = (((bmhd_width + 15) >> 4) << 1) 
-  	                       * bmhd_height * bmhd_bitplanes;
-	  
+	  int bytes_per_bitplane = byte_width * bmhd_height; /* 536862720 max */
+          long decomp_bufsize = bytes_per_bitplane * bmhd_bitplanes;
+
+	  if (byte_width <= 0 || bmhd_height <= 0 ||
+	      bytes_per_bitplane/byte_width != bmhd_height ||
+	      decomp_bufsize/bytes_per_bitplane != bmhd_bitplanes)
+	  {
+	    return (iffError(bname, "xviff: image dimensions out of range"));
+	  }
+
 	  if ((decomp_mem = (byte *)malloc((size_t) decomp_bufsize)) != NULL) {
 	    decomprle(dataptr + 8, decomp_mem, chunkLen, decomp_bufsize);
 	    bodyptr = decomp_mem;                 /* -> uncompressed BODY */
@@ -200,12 +215,13 @@
 	    FatalError("xviff: cannot malloc() decrunch buffer");
 	  }
 	}
-	
+
 
 	/* the following determines the type of the ILBM file.
 	   it's either NORMAL, EHB, HAM, HAM8 or 24BIT */
-	
+
 	fmt = ILBM_NORMAL;                        /* assume normal ILBM */
+	/* FIXME:  does ILBM_NORMAL really support up to 255 bitplanes? */
 
 	if      (bmhd_bitplanes == 24) fmt = ILBM_24BIT;
 	else if (bmhd_bitplanes == 8) {
@@ -216,7 +232,7 @@
 	  if (camg_viewmode & 0x80) fmt = ILBM_EHB;
 	  else if (camg_viewmode & 0x800) fmt = ILBM_HAM;
 	}
-	
+
 
 	if (DEBUG) {
 	  fprintf(stderr, "LoadIFF: %s %dx%d, planes=%d (%d cols), comp=%d\n",
@@ -225,9 +241,9 @@
 		  (fmt==ILBM_HAM8)   ? "HAM8 ILBM" :
 		  (fmt==ILBM_EHB)    ? "EHB ILBM" :
 		  (fmt==ILBM_24BIT)  ? "24BIT ILBM" : "unknown ILBM",
-		  bmhd_width, bmhd_height, bmhd_bitplanes, 
+		  bmhd_width, bmhd_height, bmhd_bitplanes,
 		  1<<bmhd_bitplanes, bmhd_compression);
-	}	  
+	}
 
 
 	if ((fmt==ILBM_NORMAL) || (fmt==ILBM_EHB) || (fmt==ILBM_HAM)) {
@@ -248,8 +264,14 @@
 
 
 	if ((fmt == ILBM_HAM) || (fmt == ILBM_HAM8) || (fmt == ILBM_24BIT)) {
-	  if ((picptr=(byte *) malloc((size_t)bmhd_width*bmhd_height*3))
-	      ==NULL) {
+	  int bufsize = 3 * npixels;
+
+	  if (bufsize/3 != npixels) {
+	    if (databuf)    free(databuf);
+	    if (decomp_mem) free(decomp_mem);
+	    return (iffError(bname, "xviff: image dimensions out of range"));
+	  }
+	  if ((picptr=(byte *) malloc((size_t) bufsize)) == NULL) {
 	    if (databuf)    free(databuf);
 	    if (decomp_mem) free(decomp_mem);
 	    return (iffError(bname, "xviff: no memory for decoded picture"));
@@ -258,8 +280,8 @@
 	  else {
 	    pic = picptr;
 	    workptr = bodyptr;
-	    lineskip = ((bmhd_width + 15) >> 4) << 1;
-	    
+	    lineskip = byte_width;
+
 	    for (i=0; i<bmhd_height; i++) {
 	      bitmsk = 0x80;
 	      workptr2 = workptr;
@@ -338,28 +360,28 @@
 
 
 	else if ((fmt == ILBM_NORMAL) || (fmt == ILBM_EHB)) {
-	  if ((picptr = (byte *) malloc((size_t) bmhd_width * bmhd_height))
-	      == NULL) {
+	  /* if bmhd_width and bmhd_height are OK (checked in BMHD block
+	   * above; guaranteed by BMHDok), then npixels is OK, too */
+	  if ((picptr = (byte *) malloc((size_t) npixels)) == NULL) {
 	    if (databuf) free(databuf);
 	    if (decomp_mem) free(decomp_mem);
 	    return (iffError(bname, "xviff: no memory for decoded picture"));
 	  }
-	  
+
 	  else if (fmt == ILBM_EHB) {
 	    if (DEBUG) fprintf(stderr,"Doubling CMAP for EHB mode\n");
-	    
+
 	    for (i=0; i<32; i++) {
 	      pinfo->r[i + colors] = pinfo->r[i] >> 1;
 	      pinfo->g[i + colors] = pinfo->g[i] >> 1;
 	      pinfo->b[i + colors] = pinfo->b[i] >> 1;
 	    }
 	  }
-	  
+
 	  pic = picptr;             /* ptr to chunky buffer */
 	  workptr = bodyptr;        /* ptr to uncmp'd pic, planar format */
-	  
-	  lineskip = ((bmhd_width + 15) >> 4) << 1;  /* # of bytes/line */
-	  
+	  lineskip = byte_width;
+
 	  for (i=0; i<bmhd_height; i++) {
 	    bitmsk = 0x80;                      /* left most bit (mask) */
 	    workptr2 = workptr;                 /* work ptr to source */
@@ -367,14 +389,14 @@
 	      col = 0;
 	      colbit = 1;
 	      workptr3 = workptr2;              /* ptr to byte in 1st pln */
-	      
+
 	      for (k=0; k<bmhd_bitplanes; k++) {
 		if (*workptr3 & bitmsk)          /* if bit set in this pln */
 		  col = col + colbit;           /* add bit to chunky byte */
 		workptr3 += lineskip;           /* go to next line */
 		colbit <<= 1;                   /* shift color bit */
 	      }
-	      
+
 	      *pic++ = col;                     /* write to chunky buffer */
 	      bitmsk = bitmsk >> 1;             /* shift mask to next bit */
 	      if (bitmsk == 0) {                /* if mask is zero */
@@ -382,7 +404,7 @@
 		workptr2++;                     /* mv ptr to next byte */
 	      }
 	    }  /* for j ... */
-	    
+
 	    workptr += lineskip * bmhd_bitplanes;  /* to next line */
 	  }  /* for i ... */
 
@@ -399,7 +421,7 @@
 	pinfo->colType = F_FULLCOLOR;
 	pinfo->frmType = -1;
 
-	sprintf(pinfo->fullInfo, "%s (%ld bytes)", 
+	sprintf(pinfo->fullInfo, "%s (%ld bytes)",
 		(fmt==ILBM_NORMAL) ? "IFF ILBM" :
 		(fmt==ILBM_HAM)    ? "HAM ILBM" :
 		(fmt==ILBM_HAM8)   ? "HAM8 ILBM" :
@@ -414,7 +436,8 @@
       }  /* if BMHDok */
 
       else rv = 0;                   /* didn't get BMHD header */
-    }
+
+    }  /* "BODY" chunk */
 
     else {
       if (DEBUG)
@@ -440,10 +463,10 @@
 
 /**************************************************************************
   void decomprle(source, destination, source length, buffer size)
-  
+
   Decompress run-length encoded data from source to destination. Terminates
   when source is decoded completely or destination buffer is full.
-  
+
   The decruncher is as optimized as I could make it, without risking
   safety in case of corrupt BODY chunks.
 ***************************************************************************/
@@ -455,12 +478,12 @@
      register long slen, dlen;
 {
   register byte codeByte, dataByte;
-  
+
   while ((slen > 0) && (dlen > 0)) {
-    
+
     /* read control byte */
     codeByte = *sptr++;
-    
+
     if (codeByte < 0x80) {
       codeByte++;
       if ((slen > (long) codeByte) && (dlen >= (long) codeByte)) {
diff -ruN xv-3.10a/xvimage.c xv-3.10a-bugfixes/xvimage.c
--- xv-3.10a/xvimage.c	1995-01-13 16:11:36.000000000 -0800
+++ xv-3.10a-bugfixes/xvimage.c	2005-03-31 07:23:39.000000000 -0800
@@ -34,7 +34,7 @@
 static void do_pan_calc       PARM((int, int, int *, int *));
 static void crop1             PARM((int, int, int, int, int));
 static int  doAutoCrop24      PARM((void));
-static void floydDitherize1   PARM((XImage *, byte *, int, int, int, 
+static void floydDitherize1   PARM((XImage *, byte *, int, int, int,
 				    byte *, byte *,byte *));
 static int  highbit           PARM((unsigned long));
 
@@ -74,7 +74,7 @@
   GenerateEpic(w,h);
   CreateXImage();
 }
-                
+
 
 
 /********************************************/
@@ -90,15 +90,15 @@
 
   cp = cpic;
   bperpix = (picType == PIC8) ? 1 : 3;
-  
+
   for (i=0; i<cHIGH; i++) {
     if ((i&63)==0) WaitCursor();
     pp = pic + (i+cYOFF) * (pWIDE*bperpix) + (cXOFF * bperpix);
-    for (j=0; j<cWIDE*bperpix; j++) 
+    for (j=0; j<cWIDE*bperpix; j++)
       *cp++ = *pp++;
   }
 }
-  
+
 
 
 /***********************************/
@@ -112,10 +112,10 @@
   clptr = NULL;  cxarrp = NULL;  cy = 0;  /* shut up compiler */
 
   SetISTR(ISTR_EXPAND, "%.5g%% x %.5g%%  (%d x %d)",
-	  100.0 * ((float) w) / cWIDE, 
+	  100.0 * ((float) w) / cWIDE,
 	  100.0 * ((float) h) / cHIGH, w, h);
 
-  if (DEBUG) 
+  if (DEBUG)
     fprintf(stderr,"GenerateEpic(%d,%d) eSIZE=%d,%d cSIZE=%d,%d epicode=%d\n",
 		     w,h,eWIDE,eHIGH,cWIDE,cHIGH, epicMode);
 
@@ -124,7 +124,7 @@
   eWIDE = w;  eHIGH = h;
 
 
-  if (epicMode == EM_SMOOTH) {  
+  if (epicMode == EM_SMOOTH) {
     if (picType == PIC8) {
       epic = SmoothResize(cpic, cWIDE, cHIGH, eWIDE, eHIGH,
 			  rMap,gMap,bMap, rdisp,gdisp,bdisp, numcols);
@@ -143,7 +143,7 @@
 
 
   /* generate a 'raw' epic, as we'll need it for ColorDither if EM_DITH */
-    
+
   if (eWIDE==cWIDE && eHIGH==cHIGH) {  /* 1:1 expansion.  point epic at cpic */
     epic = cpic;
   }
@@ -163,13 +163,13 @@
     /* the scaling routine.  not really all that scary after all... */
 
     /* OPTIMIZATON:  Malloc an eWIDE array of ints which will hold the
-       values of the equation px = (pWIDE * ex) / eWIDE.  Faster than doing 
+       values of the equation px = (pWIDE * ex) / eWIDE.  Faster than doing
        a mul and a div for every point in picture */
 
     cxarr = (int *) malloc(eWIDE * sizeof(int));
     if (!cxarr) FatalError("unable to allocate cxarr");
 
-    for (ex=0; ex<eWIDE; ex++) 
+    for (ex=0; ex<eWIDE; ex++)
       cxarr[ex] = bperpix * ((cWIDE * ex) / eWIDE);
 
     elptr = epptr = epic;
@@ -182,7 +182,7 @@
       clptr = cpic + (cy * cWIDE * bperpix);
 
       if (bperpix == 1) {
-	for (ex=0, cxarrp = cxarr;  ex<eWIDE;  ex++, epptr++) 
+	for (ex=0, cxarrp = cxarr;  ex<eWIDE;  ex++, epptr++)
 	  *epptr = clptr[*cxarrp++];
       }
       else {
@@ -190,7 +190,7 @@
 
 	for (ex=0, cxarrp = cxarr; ex<eWIDE; ex++,cxarrp++) {
 	  cp = clptr + *cxarrp;
-	  for (j=0; j<bperpix; j++) 
+	  for (j=0; j<bperpix; j++)
 	    *epptr++ = *cp++;
 	}
       }
@@ -203,7 +203,7 @@
   if (picType == PIC8 && epicMode == EM_DITH) {
     byte *tmp;
 
-    tmp = DoColorDither(NULL, epic, eWIDE, eHIGH, rMap,gMap,bMap, 
+    tmp = DoColorDither(NULL, epic, eWIDE, eHIGH, rMap,gMap,bMap,
 			rdisp,gdisp,bdisp, numcols);
     if (tmp) {  /* success */
       FreeEpic();
@@ -214,7 +214,7 @@
     }
   }
 }
-                
+
 
 
 /***********************************/
@@ -233,7 +233,7 @@
 static void do_zoom(mx,my)
      int mx,my;
 {
-  int i,w,h,x,y,x2,y2;
+  int i;
   int rx,ry,rx2,ry2, orx, ory, orw, orh;
   int px,py,pw,ph,opx,opy,opw,oph,m;
   Window rW, cW;  unsigned int mask;  int rtx, rty;
@@ -254,10 +254,10 @@
   while (1) {
     if (!XQueryPointer(theDisp,mainW,&rW,&cW,&rtx,&rty,
 		       &mx,&my,&mask)) continue;
-    
+
     if (!(mask & ControlMask)) break;
     if (!(mask & Button1Mask)) break;  /* button released */
-    
+
     compute_zoom_rect(mx, my, &px, &py, &pw, &ph);
     if (px!=opx || py!=opy) {
       XDrawRectangle(theDisp,mainW,theGC, orx,ory, (u_int)orw, (u_int)orh);
@@ -283,7 +283,7 @@
     XSetPlaneMask(theDisp, theGC, AllPlanes);
     return;
   }
-    
+
 
   for (i=0; i<4; i++) {
     XDrawRectangle(theDisp, mainW, theGC, orx, ory, (u_int) orw, (u_int) orh);
@@ -297,7 +297,7 @@
   /* if rectangle is *completely* outside epic, don't zoom */
   if (orx+orw<0 || ory+orh<0 || orx>=eWIDE || ory>=eHIGH) return;
 
-  
+
   crop1(opx, opy, opw, oph, DO_ZOOM);
 }
 
@@ -306,15 +306,15 @@
 static void compute_zoom_rect(x, y, px, py, pw, ph)
      int x, y, *px, *py, *pw, *ph;
 {
-  /* given a mouse pos (in epic coords), return x,y,w,h PIC coords for 
-     a 'zoom in by 2x' rectangle to be tracked.  The rectangle stays 
+  /* given a mouse pos (in epic coords), return x,y,w,h PIC coords for
+     a 'zoom in by 2x' rectangle to be tracked.  The rectangle stays
      completely within 'pic' boundaries, and moves in 'pic' increments */
 
   CoordE2P(x, y, px, py);
-  *pw = (cWIDE+1)/2;  
+  *pw = (cWIDE+1)/2;
   *ph = (cHIGH+1)/2;
 
-  *px = *px - (*pw)/2;  
+  *px = *px - (*pw)/2;
   *py = *py - (*ph)/2;
 
   RANGE(*px, 0, pWIDE - *pw);
@@ -327,7 +327,7 @@
 {
   int x,y,w,h, x2,y2, ex,ey,ew,eh;
 
-  /* compute a cropping rectangle (in pic coordinates) that's twice 
+  /* compute a cropping rectangle (in pic coordinates) that's twice
      the size of eWIDE,eHIGH, centered around eWIDE/2, eHIGH/2, but no
      larger than pWIDE,PHIGH */
 
@@ -362,7 +362,7 @@
   int i, ox,oy,offx,offy, rw,rh, px, py, dx, dy,m;
   Window rW, cW;  unsigned int mask;  int rx, ry;
 
-  offx = ox = mx;  
+  offx = ox = mx;
   offy = oy = my;
   rw = eWIDE-1;  rh = eHIGH-1;
   m = 0;
@@ -374,50 +374,50 @@
 
   /* track until Button2 is released */
   while (1) {
-    if (!XQueryPointer(theDisp, mainW, &rW, &cW, &rx, &ry, 
+    if (!XQueryPointer(theDisp, mainW, &rW, &cW, &rx, &ry,
 		       &mx, &my, &mask)) continue;
     if (!(mask & ControlMask)) break;  /* cancelled */
     if (!(mask & Button2Mask)) break;  /* button released */
-    
+
     if (mask & ShiftMask) {    /* constrain mx,my to horiz or vertical */
       if (abs(mx-offx) > abs(my-offy)) my = offy;
       else mx = offx;
     }
-    
+
     do_pan_calc(offx, offy, &mx, &my);
-    
+
     if (mx!=ox || my!=oy) {
-      XDrawRectangle(theDisp, mainW, theGC, ox-offx, oy-offy, 
+      XDrawRectangle(theDisp, mainW, theGC, ox-offx, oy-offy,
 		     (u_int) rw, (u_int) rh);
-      XDrawRectangle(theDisp, mainW, theGC, mx-offx, my-offy, 
+      XDrawRectangle(theDisp, mainW, theGC, mx-offx, my-offy,
 		     (u_int) rw, (u_int) rh);
       ox = mx;  oy = my;
     }
     else {
-      XDrawRectangle(theDisp, mainW, theGC, ox-offx, oy-offy, 
+      XDrawRectangle(theDisp, mainW, theGC, ox-offx, oy-offy,
 		     (u_int) rw, (u_int) rh);
       m = (m+1)&7;
       XSetPlaneMask(theDisp, theGC, xorMasks[m]);
-      XDrawRectangle(theDisp, mainW, theGC, ox-offx, oy-offy, 
+      XDrawRectangle(theDisp, mainW, theGC, ox-offx, oy-offy,
 		     (u_int) rw, (u_int) rh);
       XFlush(theDisp);
       Timer(100);
     }
   }
-      
+
   mx = ox;  my = oy;  /* in case mx,my changed on button release */
 
   if (!(mask & ControlMask)) {  /* cancelled */
-    XDrawRectangle(theDisp, mainW, theGC, mx-offx, my-offy, 
+    XDrawRectangle(theDisp, mainW, theGC, mx-offx, my-offy,
 		   (u_int) rw, (u_int) rh);
     XSetFunction(theDisp, theGC, GXcopy);
     XSetPlaneMask(theDisp, theGC, AllPlanes);
     return;
   }
-    
+
 
   for (i=0; i<4; i++) {
-    XDrawRectangle(theDisp, mainW, theGC, mx-offx, my-offy, 
+    XDrawRectangle(theDisp, mainW, theGC, mx-offx, my-offy,
 		   (u_int) rw, (u_int) rh);
     XFlush(theDisp);
     Timer(100);
@@ -430,7 +430,7 @@
   dx = px - cXOFF;  dy = py - cYOFF;
 
   if (dx==0 && dy==0) {  /* didn't pan anywhere */
-    XDrawRectangle(theDisp, mainW, theGC, mx-offx, my-offy, 
+    XDrawRectangle(theDisp, mainW, theGC, mx-offx, my-offy,
 		   (u_int) rw, (u_int) rh);
     XSetFunction(theDisp, theGC, GXcopy);
     XSetPlaneMask(theDisp, theGC, AllPlanes);
@@ -485,7 +485,7 @@
 /***********************************/
 void Crop()
 {
-  int i, x, y, w, h;
+  int x, y, w, h;
 
   if (!HaveSelection()) return;
 
@@ -499,8 +499,7 @@
 static void crop1(x,y,w,h,zm)
      int x,y,w,h,zm;
 {
-  int   i,j,oldew,oldeh,oldcx,oldcy;
-  byte *cp, *pp;
+  int   oldew,oldeh,oldcx,oldcy;
 
   oldcx = cXOFF;  oldcy = cYOFF;
   oldew = eWIDE;  oldeh = eHIGH;
@@ -529,7 +528,7 @@
   if (cpic == pic) return;     /* not cropped */
 
   BTSetActive(&but[BUNCROP],0);
-  
+
   if (epicMode == EM_SMOOTH) {   /* turn off smoothing */
     epicMode = EM_RAW;  SetEpicMode();
   }
@@ -538,7 +537,7 @@
   FreeEpic();
   if (cpic && cpic !=  pic) free(cpic);
   cpic = NULL;
-  
+
 
   w = (pWIDE * eWIDE) / cWIDE;   h = (pHIGH * eHIGH) / cHIGH;
   if (w>maxWIDE || h>maxHIGH) {
@@ -566,7 +565,7 @@
   WUnCrop();
   SetCropString();
 }
-  
+
 
 /***********************************/
 void AutoCrop()
@@ -583,7 +582,7 @@
       WCrop(eWIDE, eHIGH, cXOFF-oldcx, cYOFF-oldcy);
     }
   }
-  
+
   SetCursors(-1);
 }
 
@@ -650,7 +649,7 @@
 
   /* do the actual cropping */
   if (cleft || ctop || cbot || cright) {
-    DoCrop(cXOFF+cleft, cYOFF+ctop, 
+    DoCrop(cXOFF+cleft, cYOFF+ctop,
 	    cWIDE-(cleft+cright), cHIGH-(ctop+cbot));
     return 1;
   }
@@ -673,7 +672,7 @@
 # define NEIGHBOR 16		/* within 6% of neighboring pixels */
 # define MISSPCT 6		/* and up to 6% that don't match */
 # define inabsrange(a,n) ( (a) < n && (a) > -n )
-  
+
 
   if (cHIGH<3 || cWIDE<3) return 0;
 
@@ -739,7 +738,7 @@
   while (cleft + 1 < cWIDE) {  /* see if we can delete this line */
     oldr = bgR; oldg = bgG; oldb = bgB;
 
-    for (i=0, misses=0, cp1=cp; i<cHIGH && misses<maxmiss; 
+    for (i=0, misses=0, cp1=cp; i<cHIGH && misses<maxmiss;
 	 i++, cp1 += (cWIDE * 3)) {
       r=cp1[0]-bgR;  g=cp1[1]-bgG;  b=cp1[2]-bgB;
       R=cp1[0]-oldr; G=cp1[1]-oldg; B=cp1[2]-oldb;
@@ -763,7 +762,7 @@
   while (cleft + cright + 1 < cWIDE) {  /* see if we can delete this line */
     oldr = bgR; oldg = bgG; oldb = bgB;
 
-    for (i=0, misses=0, cp1=cp; i<cHIGH && misses<maxmiss; 
+    for (i=0, misses=0, cp1=cp; i<cHIGH && misses<maxmiss;
 	 i++, cp1 += (cWIDE*3)) {
       r=cp1[0]-bgR;  g=cp1[1]-bgG;  b=cp1[2]-bgB;
       R=cp1[0]-oldr; G=cp1[1]-oldg; B=cp1[2]-oldb;
@@ -784,8 +783,8 @@
   if (cleft || ctop || cbot || cright) {
     if (cWIDE - (cleft + cright) < 1 ||
 	cHIGH - (ctop  + cbot  ) < 1) return 0;    /* sanity check */
-    
-    DoCrop(cXOFF+cleft, cYOFF+ctop, 
+
+    DoCrop(cXOFF+cleft, cYOFF+ctop,
 	   cWIDE-(cleft+cright), cHIGH-(ctop+cbot));
     return 1;
   }
@@ -802,7 +801,7 @@
      and sticks likely values into eWIDE,eHIGH, assuming you wanted to
      crop.  epic is not regnerated (but is freed) */
 
-  int     i, j, k, bperpix;
+  int     i, j, bperpix;
   byte   *cp, *pp;
   double  expw, exph;
 
@@ -837,7 +836,7 @@
   else {
     /* at this point, we want to generate cpic, which will contain a
        cWIDE*cHIGH subsection of 'pic', top-left at cXOFF,cYOFF */
-    
+
     cpic = (byte *) malloc((size_t) (cWIDE * cHIGH * bperpix));
 
     if (cpic == NULL) {
@@ -852,7 +851,7 @@
     cp = cpic;
     for (i=0; i<cHIGH; i++) {
       pp = pic + (i+cYOFF) * (pWIDE*bperpix) + (cXOFF * bperpix);
-      for (j=0; j<cWIDE*bperpix; j++) 
+      for (j=0; j<cWIDE*bperpix; j++)
 	*cp++ = *pp++;
     }
   }
@@ -861,7 +860,7 @@
   SetCropString();
   BTSetActive(&but[BUNCROP], (cpic!=pic));
 
-  eWIDE = (int) (cWIDE * expw);  
+  eWIDE = (int) (cWIDE * expw);
   eHIGH = (int) (cHIGH * exph);
 
   if (eWIDE>maxWIDE || eHIGH>maxHIGH) {  /* make 'normal' size */
@@ -869,7 +868,7 @@
       double r,wr,hr;
       wr = ((double) cWIDE) / maxWIDE;
       hr = ((double) cHIGH) / maxHIGH;
-      
+
       r = (wr>hr) ? wr : hr;   /* r is the max(wr,hr) */
       eWIDE = (int) ((cWIDE / r) + 0.5);
       eHIGH = (int) ((cHIGH / r) + 0.5);
@@ -906,12 +905,12 @@
      int dir;
 {
   int i;
-  
+
   /* dir=0: 90 degrees clockwise, else 90 degrees counter-clockwise */
   WaitCursor();
-  
+
   RotatePic(pic, picType, &pWIDE, &pHIGH, dir);
-  
+
   /* rotate clipped version and modify 'clip' coords */
   if (cpic != pic && cpic != NULL) {
     if (!dir) {
@@ -928,7 +927,7 @@
     RotatePic(cpic, picType, &cWIDE, &cHIGH,dir);
   }
   else { cWIDE = pWIDE;  cHIGH = pHIGH; }
-  
+
   /* rotate expanded version */
   if (epic != cpic && epic != NULL) {
     WaitCursor();
@@ -940,7 +939,7 @@
   SetISTR(ISTR_RES,"%d x %d",pWIDE,pHIGH);
 
   SetISTR(ISTR_EXPAND, "%.5g%% x %.5g%%  (%d x %d)",
-	  100.0 * ((float) eWIDE) / cWIDE, 
+	  100.0 * ((float) eWIDE) / cWIDE,
 	  100.0 * ((float) eHIGH) / cHIGH, eWIDE, eHIGH);
 }
 
@@ -951,7 +950,7 @@
      int  *wp, *hp;
      int   ptype, dir;
 {
-  /* rotates a w*h array of bytes 90 deg clockwise (dir=0) 
+  /* rotates a w*h array of bytes 90 deg clockwise (dir=0)
      or counter-clockwise (dir != 0).  swaps w and h */
 
   byte        *pic1, *pix1, *pix;
@@ -960,7 +959,7 @@
 
   bperpix = (ptype == PIC8) ? 1 : 3;
 
-  w = *wp;  h = *hp;  
+  w = *wp;  h = *hp;
   pix1 = pic1 = (byte *) malloc((size_t) (w*h*bperpix));
   if (!pic1) FatalError("Not enough memory to rotate!");
 
@@ -968,15 +967,15 @@
   if (dir==0) {
     for (i=0; i<w; i++) {       /* CW */
       if (bperpix == 1) {
-	for (j=h-1, pix=pic+(h-1)*w + i;  j>=0;  j--, pix1++, pix-=w) 
+	for (j=h-1, pix=pic+(h-1)*w + i;  j>=0;  j--, pix1++, pix-=w)
 	  *pix1 = *pix;
       }
       else {
 	int bperlin = w*bperpix;
 	int k;
-	
-	for (j=h-1, pix=pic+(h-1)*w*bperpix + i*bperpix;  
-	     j>=0;  j--, pix -= bperlin) 
+
+	for (j=h-1, pix=pic+(h-1)*w*bperpix + i*bperpix;
+	     j>=0;  j--, pix -= bperlin)
 	  for (k=0; k<bperpix; k++) *pix1++ = pix[k];
       }
     }
@@ -984,25 +983,25 @@
   else {
     for (i=w-1; i>=0; i--) {    /* CCW */
       if (bperpix == 1) {
-	for (j=0, pix=pic+i; j<h; j++, pix1++, pix+=w) 
+	for (j=0, pix=pic+i; j<h; j++, pix1++, pix+=w)
 	  *pix1 = *pix;
       }
       else {
 	int k;
 	int bperlin = w*bperpix;
-	
-	for (j=0, pix=pic+i*bperpix; j<h; j++, pix+=bperlin) 
+
+	for (j=0, pix=pic+i*bperpix; j<h; j++, pix+=bperlin)
 	  for (k=0; k<bperpix; k++) *pix1++ = pix[k];
       }
     }
   }
-  
-  
+
+
   /* copy the rotated buffer into the original buffer */
   xvbcopy((char *) pic1, (char *) pic, (size_t) (w*h*bperpix));
-  
+
   free(pic1);
-  
+
   /* swap w and h */
   *wp = h;  *hp = w;
 }
@@ -1017,7 +1016,7 @@
    *
    * Note:  flips pic, cpic, and epic.  Doesn't touch Ximage, nor does it draw
    */
-  
+
   WaitCursor();
 
   if (HaveSelection()) {            /* only flip selection region */
@@ -1026,7 +1025,7 @@
   }
 
   FlipPic(pic, pWIDE, pHIGH, dir);
-  
+
   /* flip clipped version */
   if (cpic && cpic != pic) {
     WaitCursor();
@@ -1048,21 +1047,21 @@
      int dir;
 {
   /* flips a w*h array of bytes horizontally (dir=0) or vertically (dir!=0) */
-  
+
   byte *plin;
   int   i,j,k,l,bperpix,bperlin;
-  
+
   bperpix = (picType == PIC8) ? 1 : 3;
   bperlin = w * bperpix;
-  
+
   if (dir==0) {                /* horizontal flip */
     byte *leftp, *rightp;
-    
+
     for (i=0; i<h; i++) {
       plin   = pic + i*bperlin;
       leftp  = plin;
       rightp = plin + (w-1)*bperpix;
-      
+
       for (j=0; j<w/2; j++, rightp -= (2*bperpix)) {
 	for (l=0; l<bperpix; l++, leftp++, rightp++) {
 	  k = *leftp;  *leftp = *rightp;  *rightp = k;
@@ -1070,14 +1069,14 @@
       }
     }
   }
-  
+
   else {                      /* vertical flip */
     byte *topp, *botp;
-    
+
     for (i=0; i<w; i++) {
       topp = pic + i*bperpix;
       botp = pic + (h-1)*bperlin + i*bperpix;
-      
+
       for (j=0; j<h/2; j++, topp+=(w-1)*bperpix, botp-=(w+1)*bperpix) {
 	for (l=0; l<bperpix; l++, topp++, botp++) {
 	  k = *topp;  *topp = *botp;  *botp = k;
@@ -1093,26 +1092,26 @@
      int dir;
 {
   /* flips selected area in 'pic', regens cpic and epic appropriately */
-  
+
   int   x,y,w,h;
   byte *plin;
   int   i,j,k,l,bperpix;
-  
+
   GetSelRCoords(&x,&y,&w,&h);
   CropRect2Rect(&x,&y,&w,&h, 0,0,pWIDE,pHIGH);
   if (w<1) w=1;
   if (h<1) h=1;
-  
+
   bperpix = (picType == PIC8) ? 1 : 3;
-  
+
   if (dir==0) {                /* horizontal flip */
     byte *leftp, *rightp;
-    
+
     for (i=y; i<y+h; i++) {
       plin   = pic + (i*pWIDE + x) * bperpix;
       leftp  = plin;
       rightp = plin + (w-1)*bperpix;
-      
+
       for (j=0; j<w/2; j++, rightp -= (2*bperpix)) {
 	for (l=0; l<bperpix; l++, leftp++, rightp++) {
 	  k = *leftp;  *leftp = *rightp;  *rightp = k;
@@ -1120,14 +1119,14 @@
       }
     }
   }
-  
+
   else {                      /* vertical flip */
     byte *topp, *botp;
-    
+
     for (i=x; i<x+w; i++) {
       topp = pic + ( y      * pWIDE + i) * bperpix;
       botp = pic + ((y+h-1) * pWIDE + i) * bperpix;
-      
+
       for (j=0; j<h/2; j++, topp+=(pWIDE-1)*bperpix, botp-=(pWIDE+1)*bperpix) {
 	for (l=0; l<bperpix; l++, topp++, botp++) {
 	  k = *topp;  *topp = *botp;  *botp = k;
@@ -1139,22 +1138,22 @@
   GenerateCpic();
   GenerateEpic(eWIDE,eHIGH);
 }
-    
+
 
 /************************/
 void InstallNewPic()
 {
   /* given a new pic and colormap, (or new 24-bit pic) installs everything,
      regens cpic and epic, and redraws image */
-  
+
   /* toss old cpic and epic, if any */
   FreeEpic();
   if (cpic && cpic != pic) free(cpic);
   cpic = NULL;
-  
+
   /* toss old colors, and allocate new ones */
   NewPicGetColors(0,0);
-  
+
   /* generate cpic,epic,theImage from new 'pic' */
   crop1(cXOFF, cYOFF, cWIDE, cHIGH, DO_ZOOM);
   HandleDispMode();
@@ -1166,15 +1165,15 @@
 void DrawEpic()
 {
   /* given an 'epic', builds a new Ximage, and draws it.  Basically
-     called whenever epic is changed, or whenever color allocation 
-     changes (ie, the created X image will look different for the 
+     called whenever epic is changed, or whenever color allocation
+     changes (ie, the created X image will look different for the
      same epic) */
-  
+
   CreateXImage();
 
   if (useroot) MakeRootPic();
   else DrawWindow(0,0,eWIDE,eHIGH);
-  
+
   if (HaveSelection()) DrawSelection(0);
 }
 
@@ -1189,7 +1188,7 @@
   if (pic) free(pic);
   xvDestroyImage(theImage);   theImage = NULL;
   pic = egampic = epic = cpic = NULL;
-  
+
   if (picComments) free(picComments);
   picComments = (char *) NULL;
   ChangeCommentText();
@@ -1203,7 +1202,7 @@
      byte   *pic824, *rmap, *gmap, *bmap;
      int     ptype, wide, high;
 {
-  /* does floyd-steinberg ditherizing algorithm.  
+  /* does floyd-steinberg ditherizing algorithm.
    *
    * takes a wide*high input image, of type 'ptype' (PIC8, PIC24)
    *     (if PIC8, colormap is specified by rmap,gmap,bmap)
@@ -1212,14 +1211,14 @@
    *
    * Note: this algorithm is *only* used when running on a 1-bit display
    */
-  
+
   register byte   pix8, bit;
   int            *thisline, *nextline;
   int            *thisptr, *nextptr, *tmpptr;
   int             i, j, err, bperpix, bperln, order;
   byte           *pp, *image, w1, b1, w8, b8, rgb[256];
-  
-  
+
+
   if (ptype == PIC8) {   /* monoify colormap */
     for (i=0; i<256; i++)
       rgb[i] = MONO(rmap[i], gmap[i], bmap[i]);
@@ -1234,7 +1233,7 @@
 
   thisline = (int *) malloc(wide * sizeof(int));
   nextline = (int *) malloc(wide * sizeof(int));
-  if (!thisline || !nextline) 
+  if (!thisline || !nextline)
     FatalError("ran out of memory in floydDitherize1()\n");
 
 
@@ -1249,10 +1248,10 @@
       *tmpptr++ = fsgamcr[rgb[*pp]];
   }
 
-      
+
   w1 = white&0x1;  b1=black&0x1;
   w8 = w1<<7;  b8 = b1<<7;        /* b/w bit in high bit */
-  
+
 
   for (i=0; i<high; i++) {
     if ((i&0x3f) == 0) WaitCursor();
@@ -1326,7 +1325,7 @@
 
 
 /************************/
-byte *FSDither(inpic, intype, w, h, rmap, gmap, bmap, 
+byte *FSDither(inpic, intype, w, h, rmap, gmap, bmap,
 	      bval, wval)
      byte *inpic, *rmap, *gmap, *bmap;
      int   w,h, intype, bval, wval;
@@ -1338,14 +1337,21 @@
    * and 'wval' as the 'black' and 'white' pixel values, respectively
    */
 
-  int    i, j, err, w1, h1;
+  int    i, j, err, w1, h1, npixels, linebufsize;
   byte  *pp, *outpic, rgb[256];
   int   *thisline, *nextline, *thisptr, *nextptr, *tmpptr;
 
 
-  outpic = (byte *) malloc((size_t) (w * h));
+  npixels = w * h;
+  linebufsize = w * sizeof(int);
+  if (w <= 0 || h <= 0 || npixels/w != h || linebufsize/w != sizeof(int)) {
+    SetISTR(ISTR_WARNING, "Invalid image dimensions for dithering");
+    return (byte *)NULL;
+  }
+  
+  outpic = (byte *) malloc((size_t) npixels);
   if (!outpic) return outpic;
-    
+
 
   if (intype == PIC8) {       /* monoify colormap */
     for (i=0; i<256; i++)
@@ -1353,9 +1359,9 @@
   }
 
 
-  thisline = (int *) malloc(w * sizeof(int));
-  nextline = (int *) malloc(w * sizeof(int));
-  if (!thisline || !nextline) 
+  thisline = (int *) malloc(linebufsize);
+  nextline = (int *) malloc(linebufsize);
+  if (!thisline || !nextline)
     FatalError("ran out of memory in FSDither()\n");
 
 
@@ -1394,13 +1400,13 @@
     pp  = outpic + i * w;
     thisptr = thisline;  nextptr = nextline;
 
-    if (i&1 == 0) {  /* go right */
+    if ((i&1) == 0) {  /* go right */
       for (j=0; j<w; j++, pp++, thisptr++, nextptr++) {
 	if (*thisptr<128) { err = *thisptr;     *pp = (byte) bval; }
 	             else { err = *thisptr-255; *pp = (byte) wval; }
-	
+
 	if (j<w1) thisptr[1] += ((err*7)/16);
-	
+
 	if (i<h1) {
 	  nextptr[0] += ((err*5)/16);
 	  if (j>0)  nextptr[-1] += ((err*3)/16);
@@ -1414,9 +1420,9 @@
       for (j=w-1; j>=0; j--, pp--, thisptr--, nextptr--) {
 	if (*thisptr<128) { err = *thisptr;     *pp = (byte) bval; }
 	             else { err = *thisptr-255; *pp = (byte) wval; }
-	
+
 	if (j>0) thisptr[-1] += ((err*7)/16);
-	
+
 	if (i<h1) {
 	  nextptr[0] += ((err*5)/16);
 	  if (j>0)  nextptr[-1] += (err/16);
@@ -1449,8 +1455,8 @@
   }
 
 
-  if (picType == PIC8) 
-    theImage = Pic8ToXImage(epic,     (u_int) eWIDE, (u_int) eHIGH, 
+  if (picType == PIC8)
+    theImage = Pic8ToXImage(epic,     (u_int) eWIDE, (u_int) eHIGH,
 			    cols, rMap, gMap, bMap);
   else if (picType == PIC24)
     theImage = Pic24ToXImage(egampic, (u_int) eWIDE, (u_int) eHIGH);
@@ -1482,7 +1488,7 @@
 
   if (!pic8) return xim;  /* shouldn't happen */
 
-  if (DEBUG > 1) 
+  if (DEBUG > 1)
     fprintf(stderr,"Pic8ToXImage(): creating a %dx%d Ximage, %d bits deep\n",
 	    wide, high, dispDEEP);
 
@@ -1491,7 +1497,7 @@
   if (dispDEEP == 1) {
     byte  *imagedata;
 
-    xim = XCreateImage(theDisp, theVisual, dispDEEP, XYPixmap, 0, NULL, 
+    xim = XCreateImage(theDisp, theVisual, dispDEEP, XYPixmap, 0, NULL,
 		       wide, high, 32, 0);
     if (!xim) FatalError("couldn't create xim!");
 
@@ -1506,11 +1512,11 @@
 
   /* if ncols==0, do a 'black' and 'white' dither */
   if (ncols == 0) {
-    /* note that if dispDEEP > 8, dithpic will just have '0' and '1' instead 
+    /* note that if dispDEEP > 8, dithpic will just have '0' and '1' instead
        of 'black' and 'white' */
 
     dithpic = FSDither(pic8, PIC8, (int) wide, (int) high, rmap, gmap, bmap,
-		       (int) ((dispDEEP <= 8) ? black : 0), 
+		       (int) ((dispDEEP <= 8) ? black : 0),
 		       (int) ((dispDEEP <= 8) ? white : 1));
   }
 
@@ -1521,14 +1527,14 @@
   case 8: {
     byte  *imagedata, *ip, *pp;
     int   j, imWIDE, nullCount;
-  
+
     nullCount = (4 - (wide % 4)) & 0x03;  /* # of padding bytes per line */
     imWIDE = wide + nullCount;
- 
+
     /* Now create the image data - pad each scanline as necessary */
     imagedata = (byte *) malloc((size_t) (imWIDE * high));
     if (!imagedata) FatalError("couldn't malloc imagedata");
-    
+
     pp = (dithpic) ? dithpic : pic8;
 
     for (i=0, ip=imagedata; i<high; i++) {
@@ -1543,9 +1549,9 @@
 
       for (j=0; j<nullCount; j++, ip++) *ip = 0;
     }
-      
+
     xim = XCreateImage(theDisp,theVisual,dispDEEP,ZPixmap,0,
-		       (char *) imagedata,  wide,  high, 
+		       (char *) imagedata,  wide,  high,
 		       32, imWIDE);
     if (!xim) FatalError("couldn't create xim!");
   }
@@ -1554,13 +1560,13 @@
 
 
     /*********************************/
-      
+
   case 4: {
     byte  *imagedata, *ip, *pp;
     byte *lip;
     int  bperline, half, j;
 
-    xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL, 
+    xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL,
 		        wide,  high, 8, 0);
     if (!xim) FatalError("couldn't create xim!");
 
@@ -1569,7 +1575,7 @@
     if (!imagedata) FatalError("couldn't malloc imagedata");
     xim->data = (char *) imagedata;
 
-    
+
     pp = (dithpic) ? dithpic : pic8;
 
     if (xim->bits_per_pixel == 4) {
@@ -1601,20 +1607,20 @@
     else FatalError("This display's too bizarre.  Can't create XImage.");
   }
     break;
-      
+
 
     /*********************************/
-      
+
   case 2: {  /* by M.Kossa@frec.bull.fr (Marc Kossa) */
              /* MSBFirst mods added by dale@ntg.com (Dale Luck) */
-             /* additional fixes by  evol@infko.uni-koblenz.de 
+             /* additional fixes by  evol@infko.uni-koblenz.de
 		(Randolf Werner) for NeXT 2bit grayscale with MouseX */
 
     byte  *imagedata, *ip, *pp;
     byte *lip;
     int  bperline, half, j;
 
-    xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL, 
+    xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL,
 		        wide,  high, 8, 0);
     if (!xim) FatalError("couldn't create xim!");
 
@@ -1674,11 +1680,11 @@
 	*ip = (dithpic) ? *pp : (byte) xcolors[*pp];
       }
     }
-      
+
     else FatalError("This display's too bizarre.  Can't create XImage.");
   }
     break;
-      
+
 
   /*********************************/
 
@@ -1686,8 +1692,8 @@
   case 6: {
     byte  *imagedata, *ip, *pp;
     int  bperline;
-    
-    xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL, 
+
+    xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL,
 		        wide,  high, 8, 0);
     if (!xim) FatalError("couldn't create xim!");
 
@@ -1707,17 +1713,16 @@
     }
   }
     break;
-      
+
 
   /*********************************/
 
   case 12:
   case 15:
   case 16: {
-    unsigned short  *imagedata, *ip;
-    byte  *pp;
+    byte  *imagedata, *ip, *pp;
 
-    imagedata = (unsigned short *) malloc((size_t) (2*wide*high));
+    imagedata = (byte *) malloc((size_t) (2*wide*high));
     if (!imagedata) FatalError("couldn't malloc imagedata");
 
     xim = XCreateImage(theDisp,theVisual,dispDEEP,ZPixmap,0,
@@ -1736,10 +1741,12 @@
     if (xim->byte_order == MSBFirst) {
       for (i=wide*high, ip=imagedata; i>0; i--,pp++) {
 	if (((i+1)&0x1ffff) == 0) WaitCursor();
-	if (dithpic) {
-	  *ip++ = ((*pp) ? white : black) & 0xffff;
-	}
-	else *ip++ = xcolors[*pp] & 0xffff;
+
+	if (dithpic) xcol = ((*pp) ? white : black) & 0xffff;
+		else xcol = xcolors[*pp] & 0xffff;
+
+	*ip++ = (xcol>>8) & 0xff;
+	*ip++ = (xcol) & 0xff;
       }
     }
     else {   /* LSBFirst */
@@ -1749,14 +1756,14 @@
 	if (dithpic) xcol = ((*pp) ? white : black) & 0xffff;
 	        else xcol = xcolors[*pp];
 
-	/*  WAS *ip++ = ((xcol>>8) & 0xff) | ((xcol&0xff) << 8);  */
-	*ip++ = (unsigned short) (xcol);
+	*ip++ = (xcol) & 0xff;
+	*ip++ = (xcol>>8) & 0xff;
       }
     }
   }
     break;
 
-      
+
     /*********************************/
 
   case 24:
@@ -1766,7 +1773,7 @@
 
     imagedata = (byte *) malloc((size_t) (4*wide*high));
     if (!imagedata) FatalError("couldn't malloc imagedata");
-      
+
     xim = XCreateImage(theDisp,theVisual,dispDEEP,ZPixmap,0,
 		       (char *) imagedata,  wide,  high, 32, 0);
     if (!xim) FatalError("couldn't create xim!");
@@ -1774,7 +1781,7 @@
     do32 = (xim->bits_per_pixel == 32);
 
     pp = (dithpic) ? dithpic : pic8;
-      
+
     if (xim->byte_order == MSBFirst) {
       for (i=0, ip=imagedata; i<high; i++) {
 	if (((i+1)&0x7f) == 0) WaitCursor();
@@ -1809,8 +1816,8 @@
 
 
     /*********************************/
-    
-  default: 
+
+  default:
     sprintf(str,"no code to handle this display type (%d bits deep)",
 	    dispDEEP);
     FatalError(str);
@@ -1823,7 +1830,7 @@
   return(xim);
 }
 
-static int foo = 0;
+
 
 /***********************************/
 XImage *Pic24ToXImage(pic24, wide, high)
@@ -1840,8 +1847,8 @@
    * variation of RGB the X device in question wants.  No color allocation
    * is involved.
    *
-   * Alternately, if we're on a PseudoColor, GrayScale, StaticColor or 
-   * StaticGray display, we're going to continue to operate in an 8-bit 
+   * Alternately, if we're on a PseudoColor, GrayScale, StaticColor or
+   * StaticGray display, we're going to continue to operate in an 8-bit
    * mode.  (In that by this point, a 3/3/2 standard colormap has been
    * created for our use (though all 256 colors may not be unique...), and
    * we're just going to display the 24-bit picture by dithering with those
@@ -1861,7 +1868,7 @@
   if (dispDEEP == 1) {
     byte  *imagedata;
 
-    xim = XCreateImage(theDisp, theVisual, dispDEEP, XYPixmap, 0, NULL, 
+    xim = XCreateImage(theDisp, theVisual, dispDEEP, XYPixmap, 0, NULL,
 		        wide,  high, 32, 0);
     if (!xim) FatalError("couldn't create xim!");
 
@@ -1929,8 +1936,8 @@
       for (j=0, ip=lip; j<wide; j++) {
 	r = *pp++;  g = *pp++;  b = *pp++;
 
-	/* shift r,g,b so that high bit of 8-bit color specification is 
-	 * aligned with high bit of r,g,b-mask in visual, 
+	/* shift r,g,b so that high bit of 8-bit color specification is
+	 * aligned with high bit of r,g,b-mask in visual,
 	 * AND each component with its mask,
 	 * and OR the three components together
 	 */
@@ -1945,7 +1952,7 @@
 	/* shift the bits around */
 	if (rshift<0) r = r << (-rshift);
 	         else r = r >> rshift;
-	
+
 	if (gshift<0) g = g << (-gshift);
 	         else g = g >> gshift;
 
@@ -2019,17 +2026,17 @@
     bwdith = 0;
 
     if (ncols == 0 && dispDEEP != 1) {   /* do 'black' and 'white' dither */
-      /* note that if dispDEEP > 8, pic8 will just have '0' and '1' instead 
+      /* note that if dispDEEP > 8, pic8 will just have '0' and '1' instead
 	 of 'black' and 'white' */
 
-      pic8 = FSDither(pic24, PIC24, (int) wide, (int) high, NULL, NULL, NULL, 
-		      (int) ((dispDEEP <= 8) ? black : 0), 
+      pic8 = FSDither(pic24, PIC24, (int) wide, (int) high, NULL, NULL, NULL,
+		      (int) ((dispDEEP <= 8) ? black : 0),
 		      (int) ((dispDEEP <= 8) ? white : 1));
       bwdith = 1;
     }
 
     else {                               /* do color dither using stdcmap */
-      pic8 = Do332ColorDither(pic24, NULL, (int) wide, (int) high, 
+      pic8 = Do332ColorDither(pic24, NULL, (int) wide, (int) high,
 			      NULL, NULL, NULL,
 			      stdrdisp, stdgdisp, stdbdisp, 256);
     }
@@ -2046,14 +2053,14 @@
     case 8: {
       byte  *imagedata, *ip, *pp;
       int   j, imWIDE, nullCount;
-  
+
       nullCount = (4 - (wide % 4)) & 0x03;  /* # of padding bytes per line */
       imWIDE = wide + nullCount;
- 
+
       /* Now create the image data - pad each scanline as necessary */
       imagedata = (byte *) malloc((size_t) (imWIDE * high));
       if (!imagedata) FatalError("couldn't malloc imagedata");
-      
+
       for (i=0, pp=pic8, ip=imagedata; i<high; i++) {
 	if (((i+1)&0x7f) == 0) WaitCursor();
 
@@ -2066,7 +2073,7 @@
       }
 
       xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0,
-			 (char *) imagedata,  wide,  high, 
+			 (char *) imagedata,  wide,  high,
 			 32, imWIDE);
       if (!xim) FatalError("couldn't create xim!");
     }
@@ -2074,14 +2081,14 @@
 
 
       /*********************************/
-      
+
     case 4: {
       byte         *imagedata, *ip, *pp;
       byte         *lip;
       int           bperline, half, j;
       unsigned long xcol;
-      
-      xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL, 
+
+      xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL,
 			  wide,  high, 32, 0);
       if (!xim) FatalError("couldn't create xim!");
 
@@ -2123,14 +2130,14 @@
       else FatalError("This display's too bizarre.  Can't create XImage.");
     }
       break;
-      
+
 
 
       /*********************************/
-      
+
     case 2: {  /* by M.Kossa@frec.bull.fr (Marc Kossa) */
                /* MSBFirst mods added by dale@ntg.com (Dale Luck) */
-               /* additional fixes by  evol@infko.uni-koblenz.de 
+               /* additional fixes by  evol@infko.uni-koblenz.de
 		  (Randolf Werner) for NeXT 2bit grayscale with MouseX */
 
       byte  *imagedata, *ip, *pp;
@@ -2138,7 +2145,7 @@
       int  bperline, half, j;
       unsigned long xcol;
 
-      xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL, 
+      xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL,
 			  wide,  high, 32, 0);
       if (!xim) FatalError("couldn't create xim!");
 
@@ -2201,22 +2208,22 @@
 	  }
 	}
       }
-      
+
       else FatalError("This display's too bizarre.  Can't create XImage.");
     }
       break;
-      
+
 
       /*********************************/
-    
+
     case 6: {
       byte  *imagedata, *lip, *ip, *pp;
       int  bperline;
-    
-      xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL, 
+
+      xim = XCreateImage(theDisp, theVisual, dispDEEP, ZPixmap, 0, NULL,
 			  wide,  high, 32, 0);
       if (!xim) FatalError("couldn't create xim!");
-      
+
       if (xim->bits_per_pixel != 8)
 	FatalError("This display's too bizarre.  Can't create XImage.");
 
@@ -2238,7 +2245,7 @@
     }
       break;
 
-      
+
       /*********************************/
 
     case 15:
@@ -2282,7 +2289,7 @@
     }
       break;
 
-      
+
       /*********************************/
 
       /* this wouldn't seem likely to happen, but what the heck... */
@@ -2295,7 +2302,7 @@
 
       imagedata = (byte *) malloc((size_t) (4*wide*high));
       if (!imagedata) FatalError("couldn't malloc imagedata");
-      
+
       xim = XCreateImage(theDisp,theVisual,dispDEEP,ZPixmap,0,
 			 (char *) imagedata, wide, high, 32, 0);
       if (!xim) FatalError("couldn't create xim!");
@@ -2303,7 +2310,7 @@
       bperpix = xim->bits_per_pixel;
 
       pp = pic8;
-      
+
       if (xim->byte_order == MSBFirst) {
 	for (i=wide*high, ip=imagedata; i>0; i--,pp++) {
 	  if (((i+1)&0x1ffff) == 0) WaitCursor();
@@ -2327,7 +2334,7 @@
 	  if (bperpix == 32) *ip++ = 0;
 	}
       }
-    }     
+    }
       break;
 
     }   /* end of the switch */
@@ -2346,7 +2353,7 @@
      int mode;
 {
   /* move checkmark */
-  conv24MB.flags[CONV24_8BIT]  = (mode==PIC8);  
+  conv24MB.flags[CONV24_8BIT]  = (mode==PIC8);
   conv24MB.flags[CONV24_24BIT] = (mode==PIC24);
 
   if (mode == PIC24) {
@@ -2383,15 +2390,13 @@
 void Change824Mode(mode)
      int mode;
 {
-  static int oldcmapmode = -1;
-
   if (mode == picType) return;   /* same mode, do nothing */
 
   Set824Menus(mode);
 
   if (!pic) {  /* done all we wanna do when there's no pic */
     picType = mode;
-    return;  
+    return;
   }
 
   /* should probably actually *do* something involving colors, regenrating
@@ -2474,7 +2479,7 @@
      int   ptype, w,h, sx,sy,sw,sh;
 {
   /* mallocs and returns the selected subimage (sx,sy,sw,sh) of pic.
-     selection is guaranteed to be within pic boundaries.  
+     selection is guaranteed to be within pic boundaries.
      NEVER RETURNS NULL */
 
   byte *rpic, *sp, *dp;
@@ -2520,7 +2525,6 @@
      installs the new pic and all that...  Returns '0' on failure */
 
   int   rv;
-  char  loadName[256];
 
   if (padPic)      free(padPic);
   if (holdcomment) free(holdcomment);
@@ -2530,8 +2534,8 @@
 
   rv = 1;
 
-  if ((mode != PAD_LOAD) && (wide == pWIDE && high == pHIGH && opaque==100)) {
-    ErrPopUp("Padding to same size as pic while fully opaque has no effect.", 
+  if ((mode != PAD_LOAD) && (wide == cWIDE && high == cHIGH && opaque==100)) {
+    ErrPopUp("Padding to same size as pic while fully opaque has no effect.",
 	     "\nI see");
     return 0;
   }
@@ -2539,8 +2543,8 @@
   WaitCursor();
 
   if      (mode == PAD_SOLID) rv = doPadSolid(str, wide, high, opaque,omode);
-  else if (mode == PAD_BGGEN) rv = doPadBggen(str, wide, high, opaque,omode); 
-  else if (mode == PAD_LOAD)  rv = doPadLoad (str, wide, high, opaque,omode); 
+  else if (mode == PAD_BGGEN) rv = doPadBggen(str, wide, high, opaque,omode);
+  else if (mode == PAD_LOAD)  rv = doPadLoad (str, wide, high, opaque,omode);
 
   SetCursors(-1);
 
@@ -2556,7 +2560,7 @@
 
   return 1;
 }
-	      
+
 
 /***********************************/
 int LoadPad(pinfo, fname)
@@ -2645,7 +2649,7 @@
       return 0;
     }
   }
-  
+
 
 
   pic24 = (byte *) malloc(wide * high * 3 * sizeof(byte));
@@ -2656,7 +2660,7 @@
     return 0;
   }
 
-  
+
   /* fill pic24 with solidRGB */
   for (i=0,pp=pic24; i<wide*high; i++, pp+=3) {
     pp[0] = (solidRGB>>16) & 0xff;
@@ -2697,7 +2701,11 @@
 #else
   strcpy(fname, "Sys$Disk:[]xvuXXXXXX");
 #endif
+#ifdef USE_MKSTEMP
+  close(mkstemp(fname));
+#else
   mktemp(fname);
+#endif
 
   /* run bggen to generate the background */
   sprintf(syscmd, "bggen -g %dx%d %s > %s", wide, high, str, fname);
@@ -2713,7 +2721,7 @@
     ErrPopUp(errstr, "\nDoh!");
     return 0;
   }
-    
+
 
   /* read the file that's been created */
   if (!ReadImageFile1(fname, &pinfo)) {
@@ -2791,7 +2799,7 @@
      int   wide, high, opaque,omode;
 {
   /* copies 'pic' onto the given 24-bit background image, converts back to
-     8-bit (if necessary), and loads up pad* variables.  
+     8-bit (if necessary), and loads up pad* variables.
      frees pic24 if necessary */
 
   byte *pp, *p24;
@@ -2806,30 +2814,30 @@
 
   /* copy 'pic' centered onto pic24.  */
 
-  sx = (wide - pWIDE) / 2;
-  sy = (high - pHIGH) / 2;
-  
-  for (py = 0; py<pHIGH; py++) {
-    ProgressMeter(0, pHIGH-1, py, "Pad");
+  sx = (wide - cWIDE) / 2;
+  sy = (high - cHIGH) / 2;
+
+  for (py = 0; py<cHIGH; py++) {
+    ProgressMeter(0, cHIGH-1, py, "Pad");
     if ((py & 0x1f)==0) WaitCursor();
 
     p24y = sy + py;
     if (p24y >= 0 && p24y < high) {
-      for (px=0; px<pWIDE; px++) {
+      for (px=0; px<cWIDE; px++) {
 	p24x = sx + px;
 	if (p24x >= 0 && p24x < wide) {
 	  p24 = pic24 + (p24y*wide  + p24x)*3;
-	  
-	  
+
+
 	  if (picType == PIC24) {                       /* src is PIC24 */
-	    pp  = pic + (py * pWIDE + px)  *3;
+	    pp  = cpic + (py * cWIDE + px)  *3;
 	    r = pp[0];  g = pp[1];  b = pp[2];
 	  }
 	  else {                                        /* src is PIC8 */
-	    pp  = pic + (py*pWIDE + px);
+	    pp  = cpic + (py*cWIDE + px);
 	    r = rMap[*pp];  g = gMap[*pp];  b = bMap[*pp];
 	  }
-	  
+
 	  if (omode == PAD_ORGB) {
 	    rval = (r * fg) / 100 + ((int) p24[0] * bg) / 100;
 	    gval = (g * fg) / 100 + ((int) p24[1] * bg) / 100;
@@ -2845,7 +2853,7 @@
 
 	    if (omode == PAD_OINT) {
 	      h = fh;
-	      s = fs;  
+	      s = fs;
 	      /* v = (fv * fg) / 100.0 + (bv * bg) / 100.0; */
 	      v = (fv * bv * bw) + (fv * fw);
 	    }
@@ -2855,18 +2863,18 @@
 	      h = fh;
 	      /* s = (fs * fg) / 100.0 + (bs * bg) / 100.0; */
 	      s = (fs * bs * bw) + (fs * fw);
-	      v = fv;  
+	      v = fv;
 	    }
 	    else if (omode == PAD_OHUE) {   /* the hard one! */
-	      int fdeg,bdeg,len1,len2;
-		
+	      int fdeg,bdeg;
+
 	      fdeg = (fh<0) ? -1 : (int) floor(fh + 0.5);
 	      bdeg = (bh<0) ? -1 : (int) floor(bh + 0.5);
 
 	      if (fdeg>=0 && bdeg>=0) {           /* both are colors */
 		/* convert H,S onto x,y coordinates on the colorwheel for
 		   constant V */
-		
+
 		double fx,fy, bx,by, ox,oy;
 
 		if (fg == 100 || bg == 100) {   /* E-Z special case */
@@ -2874,17 +2882,17 @@
 		  else         { h = bh;  s = fs;  v=fv; }
 		}
 		else {  /* general case */
-		  
+
 		  fh *= (3.14159 / 180.0);    /* -> radians */
 		  bh *= (3.14159 / 180.0);
-		  
+
 		  fx = fs * cos(fh);  fy = fs * sin(fh);
 		  bx = bs * cos(bh);  by = bs * sin(bh);
-		  
+
 		  /* compute pt. on line between fx,fy and bx,by */
 		  ox = (fx * (fg/100.0)) + (bx * (bg/100.0));
 		  oy = (fy * (fg/100.0)) + (by * (bg/100.0));
-		  
+
 		  /* convert ox,oy back into hue,sat */
 		  s = sqrt((ox * ox) + (oy * oy));
 		  if (ox == 0.0) {
@@ -2897,7 +2905,7 @@
 		    while (h<0.0) h += 360.0;
 		    while (h>=360.0) h -= 360.0;
 		  }
-		  
+
 		  v = fv;
 		}
 	      }
@@ -2924,7 +2932,7 @@
 	    v = (fv * bv * bw) + (fv * fw);
 	    hsv2rgb(h,s,v, &rval,&gval,&bval);
 	  }
-	  
+
 	  RANGE(rval, 0, 255);  RANGE(gval, 0, 255);  RANGE(bval, 0, 255);
 	  *p24++ = rval;  *p24++ = gval;  *p24++ = bval;
 	}
@@ -2958,12 +2966,15 @@
 
 
 /*******************************/
-static int ReadImageFile1(name, pinfo) 
+static int ReadImageFile1(name, pinfo)
      char    *name;
      PICINFO *pinfo;
 {
   int  i, ftype;
-  char basefname[128], uncompname[128], errstr[256], *uncName, *readname;
+  char uncompname[128], errstr[256], *uncName, *readname;
+#ifdef VMS
+  char basefname[128];
+#endif
 
   ftype = ReadFileType(name);
 
@@ -2976,7 +2987,7 @@
 #else
     uncName = name;
 #endif
-    
+
     if (UncompressFile(uncName, uncompname)) {
       ftype = ReadFileType(uncompname);
       readname = uncompname;
@@ -3004,7 +3015,7 @@
     KillPageFiles(pinfo->pagebname, pinfo->numpages);
 
     if (!i || (i && (pinfo->w<=0 || pinfo->h<=0))) {
-      if (i) { 
+      if (i) {
 	if (pinfo->pic)     free(pinfo->pic);
 	if (pinfo->comment) free(pinfo->comment);
       }
@@ -3021,6 +3032,6 @@
 
 
 
-    
+
 
 
diff -ruN xv-3.10a/xvinfo.c xv-3.10a-bugfixes/xvinfo.c
--- xv-3.10a/xvinfo.c	1994-12-22 14:34:41.000000000 -0800
+++ xv-3.10a-bugfixes/xvinfo.c	2004-05-16 18:03:43.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * xvinfo.c - 'Info' box handling functions
  *
  * callable functions:
@@ -8,7 +8,7 @@
  *                             maps/unmaps window, etc.
  *   RedrawInfo(x,y,w,h)    -  called by 'expose' events
  *   SetInfoMode(mode)      -  changes amount of info Info window shows
- *   SetISTR(st, fmt, args) - sprintf's into ISTR #st.  Redraws it in window 
+ *   SetISTR(st, fmt, args) - sprintf's into ISTR #st.  Redraws it in window
  *   char *GetISTR(st)      - returns pointer to ISTR #st, or NULL if st bogus
  */
 
@@ -45,18 +45,18 @@
 void CreateInfo(geom)
 char *geom;
 {
-  infoW = CreateWindow("xv info", "XVinfo", geom, INFOWIDE, INFOHIGH, 
+  infoW = CreateWindow("xv info", "XVinfo", geom, INFOWIDE, INFOHIGH,
 		       infofg, infobg, 0);
   if (!infoW) FatalError("can't create info window!");
-  
-  pennPix = XCreatePixmapFromBitmapData(theDisp, infoW, 
+
+  pennPix = XCreatePixmapFromBitmapData(theDisp, infoW,
 	(char *) penn_bits, penn_width, penn_height, infofg, infobg, dispDEEP);
 
   pnetPix = XCreatePixmapFromBitmapData(theDisp,infoW,
-	(char *) pennnet_bits, pennnet_width, pennnet_height, 
+	(char *) pennnet_bits, pennnet_width, pennnet_height,
 	infofg, infobg, dispDEEP);
 }
-  
+
 
 /***************************************************/
 void InfoBox(vis)
@@ -64,7 +64,7 @@
 {
   if (vis) XMapRaised(theDisp, infoW);
   else     XUnmapWindow(theDisp, infoW);
-  
+
   infoUp = vis;
 }
 
@@ -74,15 +74,15 @@
      int x,y,w,h;
 {
   int  i;
-  
+
   XSetForeground(theDisp, theGC, infofg);
   XSetBackground(theDisp, theGC, infobg);
 
   /* draw the two icons */
   XCopyArea(theDisp, pennPix, infoW, theGC, 0, 0, penn_width, penn_height,
 	    36 - penn_width/2, 36 - penn_height/2);
-  XCopyArea(theDisp, pnetPix, infoW, theGC, 0, 0, pennnet_width, 
-	    pennnet_height, INFOWIDE - 36 - pennnet_width/2, 
+  XCopyArea(theDisp, pnetPix, infoW, theGC, 0, 0, pennnet_width,
+	    pennnet_height, INFOWIDE - 36 - pennnet_width/2,
 	    36 - pennnet_height/2);
 
   /* draw the credits */
@@ -90,7 +90,7 @@
   CenterString(infoW, INFOWIDE/2, 36-LINEHIGH, str);
   CenterString(infoW, INFOWIDE/2, 36,
 	       "by John Bradley  (bradley@dccs.upenn.edu)");
-  CenterString(infoW, INFOWIDE/2, 36+LINEHIGH, 
+  CenterString(infoW, INFOWIDE/2, 36+LINEHIGH,
 	       "Copyright 1994, John Bradley  -  All Rights Reserved");
 
 
@@ -139,8 +139,8 @@
 
   if (infoMode == INF_NONE || infoMode == INF_STR) return;
   if (infoMode == INF_PART && fnum>=3) return;
-  
-  XDrawString(theDisp, infoW, theGC, 10, TOPBASE + fnum*LINEHIGH, 
+
+  XDrawString(theDisp, infoW, theGC, 10, TOPBASE + fnum*LINEHIGH,
 	      fname[fnum], (int) strlen(fname[fnum]));
 }
 
@@ -150,7 +150,7 @@
      int st;
 {
   /* erase area of string, and draw it with new contents */
-  
+
   if (infoMode == INF_NONE) return;
   if (infoMode == INF_STR && st > ISTR_WARNING) return;
   if (infoMode == INF_PART && st > ISTR_RES) return;
@@ -170,12 +170,12 @@
   }
   else {
     XSetForeground(theDisp, theGC, infobg);
-    XFillRectangle(theDisp, infoW, theGC, 
-		   STLEFT, TOPBASE - ASCENT + (st-ISTR_FILENAME)*LINEHIGH, 
+    XFillRectangle(theDisp, infoW, theGC,
+		   STLEFT, TOPBASE - ASCENT + (st-ISTR_FILENAME)*LINEHIGH,
 		   (u_int) INFOWIDE-STLEFT, (u_int) LINEHIGH);
     XSetForeground(theDisp, theGC, infofg);
     XDrawString(theDisp, infoW, theGC, STLEFT,
-		TOPBASE	+ (st-ISTR_FILENAME)*LINEHIGH,	istrs[st], 
+		TOPBASE	+ (st-ISTR_FILENAME)*LINEHIGH,	istrs[st],
 		(int) strlen(istrs[st]));
   }
 }
@@ -187,21 +187,21 @@
      int mode;
 {
   int y1, y2;
-  
+
   infoMode = mode;
   if (infoUp) {   /* only do this if window is mapped */
     y1 = TOPBASE - ASCENT;
     y2 = INFOHIGH-43;
-    
+
     XSetForeground(theDisp, theGC, infobg);
-    
-    XFillRectangle(theDisp,infoW,theGC,0,y1, 
+
+    XFillRectangle(theDisp,infoW,theGC,0,y1,
 		   (u_int) INFOWIDE, (u_int) y2-y1);
-    XFillRectangle(theDisp,infoW,theGC,0,INFOHIGH-39, 
+    XFillRectangle(theDisp,infoW,theGC,0,INFOHIGH-39,
 		   (u_int) INFOWIDE, (u_int) 17);
-    XFillRectangle(theDisp,infoW,theGC,0,INFOHIGH-19, 
+    XFillRectangle(theDisp,infoW,theGC,0,INFOHIGH-19,
 		   (u_int) INFOWIDE, (u_int) 17);
-    
+
     drawStrings();
   }
 }
@@ -237,9 +237,9 @@
     else istrs[stnum][0] = '\0';
   }
   va_end(args);
-  
+
   if (stnum == ISTR_COLOR) {
-    sprintf(istrs[ISTR_INFO], "%s  %s  %s", formatStr, 
+    sprintf(istrs[ISTR_INFO], "%s  %s  %s", formatStr,
 	    (picType==PIC8) ? "8-bit mode." : "24-bit mode.",
 	    istrs[ISTR_COLOR]);
   }
@@ -250,19 +250,19 @@
     XFlush(theDisp);
   }
 
-  if (ctrlUp && (stnum == ISTR_INFO || stnum == ISTR_WARNING || 
+  if (ctrlUp && (stnum == ISTR_INFO || stnum == ISTR_WARNING ||
 		 stnum == ISTR_COLOR)) {
     DrawCtrlStr();
     XFlush(theDisp);
   }
 
-  if (anyBrowUp && (stnum == ISTR_WARNING || stnum == ISTR_INFO) 
+  if (anyBrowUp && (stnum == ISTR_WARNING || stnum == ISTR_INFO)
       && strlen(istrs[stnum])) {
     SetBrowStr(istrs[stnum]);
     XFlush(theDisp);
   }
 
-  if (stnum == ISTR_WARNING && !ctrlUp && !infoUp && !anyBrowUp && 
+  if (stnum == ISTR_WARNING && !ctrlUp && !infoUp && !anyBrowUp &&
       strlen(istrs[stnum])) {
     OpenAlert(istrs[stnum]);
     sleep(3);
diff -ruN xv-3.10a/xviris.c xv-3.10a-bugfixes/xviris.c
--- xv-3.10a/xviris.c	1994-12-22 14:34:47.000000000 -0800
+++ xv-3.10a-bugfixes/xviris.c	2005-04-03 12:08:03.000000000 -0700
@@ -14,7 +14,7 @@
  *
  *      This code should work on machines with any byte order.
  *
- *	Could someone make this run real fast using multiple processors 
+ *	Could someone make this run real fast using multiple processors
  *	or how about using memory mapped files to speed it up?
  *
  *				Paul Haeberli - 1991
@@ -44,7 +44,7 @@
     u_short 	zsize;
     u_long 	min;
     u_long 	max;
-    u_long	wastebytes;	
+    u_long	wastebytes;
     char 	name[80];
     u_long	colormap;
 
@@ -112,7 +112,8 @@
   IMAGE   img;
   byte   *rawdata, *rptr;
   byte   *pic824,  *bptr;
-  int     trunc, i, j;
+  int     trunc, i, npixels, bufsize;
+  u_short ii, jj;
   long    filesize;
 
   trunc = 0;
@@ -133,11 +134,11 @@
   img.imagic = getshort(fp);
   img.type   = getshort(fp);
   img.dim    = getshort(fp);
-  img.xsize  = getshort(fp);
+  img.xsize  = getshort(fp);  /* u_short */
   img.ysize  = getshort(fp);
   img.zsize  = getshort(fp);
 
-  if (FERROR(fp)) {
+  if (FERROR(fp) || img.xsize == 0 || img.ysize == 0 || img.zsize == 0) {
     fclose(fp);
     return irisError(bname, "error in header info");
   }
@@ -148,7 +149,7 @@
   }
 
   rawdata = getimagedata(fp, &img);
-  if (!rawdata) {   
+  if (!rawdata) {
     fclose(fp);
     if (loaderr) irisError(bname, loaderr);
     return 0;
@@ -162,18 +163,22 @@
   /* got the raw image data.  Convert to an XV image (1,3 bytes / pix) */
 
 
+  npixels = img.xsize * img.ysize;  /* 65535*65535 = (2^32 - 131071) max */
+  if (npixels/img.xsize != img.ysize)
+    return irisError(bname, "IRIS image dimensions out of range");
+
   if (img.zsize < 3) {  /* grayscale */
-    pic824 = (byte *) malloc((size_t) img.xsize * img.ysize);
+    pic824 = (byte *) malloc((size_t) npixels);
     if (!pic824) FatalError("couldn't malloc pic824 in LoadIRIS()");
 
     /* copy plane 3 from rawdata into pic824, inverting pic vertically */
-    for (i=0, bptr=pic824; i<(int) img.ysize; i++) {
-      rptr = rawdata + 3 + ((img.ysize - 1) - i) * (img.xsize * 4);
-      for (j=0; j<(int) img.xsize; j++, bptr++, rptr+=4) *bptr = *rptr;
+    for (ii=0, bptr=pic824; ii<img.ysize; ii++) {
+      rptr = rawdata + 3 + ((img.ysize - 1) - ii) * (img.xsize * 4);
+      for (jj=0; jj<img.xsize; jj++, bptr++, rptr+=4) *bptr = *rptr;
     }
 
 
-    for (i=0; i<256; i++) 
+    for (i=0; i<256; i++)
       pinfo->r[i] = pinfo->g[i] = pinfo->b[i] = i;
 
     pinfo->pic  = pic824;
@@ -188,13 +193,17 @@
   }
 
   else {  /* truecolor */
-    pic824 = (byte *) malloc((size_t) img.xsize * img.ysize * 3);
+    bufsize = 3 * npixels;
+    if (npixels/img.xsize != img.ysize || bufsize/3 != npixels) {
+      return irisError(bname, "IRIS image dimensions out of range");
+    }
+    pic824 = (byte *) malloc((size_t) bufsize);
     if (!pic824) FatalError("couldn't malloc pic824 in LoadIRIS()");
-    
+
     /* copy plane 3 from rawdata into pic824, inverting pic vertically */
-    for (i=0, bptr=pic824; i<(int) img.ysize; i++) {
-      rptr = rawdata + ((img.ysize - 1) - i) * (img.xsize * 4);
-      for (j=0; j<(int) img.xsize; j++, rptr+=4) {
+    for (ii=0, bptr=pic824; ii<img.ysize; ii++) {
+      rptr = rawdata + ((img.ysize - 1) - ii) * (img.xsize * 4);
+      for (jj=0; jj<img.xsize; jj++, rptr+=4) {
 	*bptr++ = rptr[3];
 	*bptr++ = rptr[2];
 	*bptr++ = rptr[1];
@@ -220,7 +229,7 @@
   pinfo->comment = (char *) NULL;
 
   return 1;
-}     
+}
 
 
 /*******************************************/
@@ -237,15 +246,15 @@
      FILE  *fp;
      IMAGE *img;
 {
-  /* read in a B/W RGB or RGBA iris image file and return a 
+  /* read in a B/W RGB or RGBA iris image file and return a
      pointer to an array of 4-byte pixels, arranged ABGR, NULL on error */
 
   byte   *base, *lptr;
   byte   *verdat;
-  int     y, z, pos, len, tablen;
+  int     y, z, tablen;
   int     xsize, ysize, zsize;
   int     bpp, rle, cur, badorder;
-  int     rlebuflen;
+  int     rlebuflen, npixels, bufsize;
 
 
   rle     = ISRLE(img->type);
@@ -257,21 +266,33 @@
     return (byte *) NULL;
   }
 
-  xsize = img->xsize;
+  xsize = img->xsize;   /* all three are > 0 (checked by caller), <= 65535 */
   ysize = img->ysize;
   zsize = img->zsize;
+  npixels = xsize * ysize;  /* 65535*65535 = (2^32 - 131071) max */
+  if (npixels/xsize != ysize) {
+    loaderr = "IRIS image dimensions out of range";
+    return (byte *) NULL;
+  }
 
   if (rle) {
     byte *rledat;
     u_long *starttab, *lengthtab;
 
-    rlebuflen = 2 * xsize + 10;
+    rlebuflen = 2 * xsize + 10;  /* 10 <= rlebuflen <= 131080 */
     tablen    = ysize * zsize;
-    starttab  = (u_long *) malloc((size_t) tablen * sizeof(long));
-    lengthtab = (u_long *) malloc((size_t) tablen * sizeof(long));
+    bufsize   = tablen * sizeof(long);
+
+    if (tablen/ysize != zsize || bufsize/tablen != sizeof(long)) {
+      loaderr = "IRIS image dimensions out of range";
+      return (byte *)NULL;
+    }
+
+    starttab  = (u_long *) malloc((size_t) bufsize);
+    lengthtab = (u_long *) malloc((size_t) bufsize);
     rledat    = (byte *)   malloc((size_t) rlebuflen);
 
-    if (!starttab || !lengthtab || !rledat) 
+    if (!starttab || !lengthtab || !rledat)
       FatalError("out of memory in LoadIRIS()");
 
     fseek(fp, 512L, 0);
@@ -298,7 +319,13 @@
     fseek(fp, (long) (512 + 2*tablen*4), 0);
     cur = 512 + 2*tablen*4;
 
-    base = (byte *) malloc((size_t) (xsize*ysize+TAGLEN) * 4);
+    bufsize = 4 * (npixels+TAGLEN);
+    if (bufsize/4 != (npixels+TAGLEN)) {
+      loaderr = "Bogus IRIS File!";
+      free(starttab);  free(lengthtab);  free(rledat);
+      return (byte *)NULL;
+    }
+    base = (byte *) malloc((size_t) bufsize);
     if (!base) FatalError("out of memory in LoadIRIS()");
 
     addimgtag(base,xsize,ysize);
@@ -349,12 +376,17 @@
   }      /* end of RLE case */
 
   else {  /* not RLE */
+    bufsize = 4 * (npixels+TAGLEN);
+    if (bufsize/4 != (npixels+TAGLEN)) {
+      loaderr = "Bogus IRIS File!";
+      return (byte *)NULL;
+    }
+    base   = (byte *) malloc((size_t) bufsize);
     verdat = (byte *) malloc((size_t) xsize);
-    base   = (byte *) malloc((size_t) (xsize*ysize+TAGLEN) * 4);
     if (!base || !verdat) FatalError("out of memory in LoadIRIS()");
 
     addimgtag(base,xsize,ysize);
-    
+
     fseek(fp,512L,0);
 
     for (z=0; z<zsize; z++) {
@@ -457,7 +489,7 @@
      byte *dptr;
      int   xsize, ysize;
 {
-  /* this is used to extract image data from core dumps. 
+  /* this is used to extract image data from core dumps.
      I doubt this is necessary...  --jhb */
 
   dptr    = dptr + (xsize * ysize * 4);
@@ -499,26 +531,31 @@
      int   ptype, w, h, numcols, colorstyle;
 {
   /* writes a greyscale or 24-bit RGB IRIS file to the already open
-     stream, rle compressed */
+     stream, RLE-compressed; returns 0 on success, -1 on minor error */
 
   IMAGE img;
-  int     i, j, pos, len, tablen, rlebuflen, zsize;
+  int     i, j, pos, len, tablen, rlebuflen, zsize, npixels, bufsize;
   u_long *starttab, *lengthtab;
   byte   *rlebuf, *pptr;
   byte   *lumbuf, *lptr, *longpic;
 
   xvbzero((char *) &img, sizeof(IMAGE));
-  
+
   /* write header information */
   fwrite(&img, sizeof(IMAGE), (size_t) 1, fp);
   fseek(fp, 0L, 0);
 
+  if (w <= 0 || h <= 0 || w > 65535 || h > 65535) {
+    SetISTR(ISTR_WARNING, "image dimensions too large for IRIS format");
+    return -1;
+  }
+
   /* load up header */
   img.imagic = IMAGIC;
   img.type   = ITYPE_RLE | (1 & BPPMASK);   /* RLE, 1 byteperpix */
   img.dim    = (colorstyle == F_FULLCOLOR) ? 3 : 2;
-  img.xsize  = w;
-  img.ysize  = h;
+  img.xsize  = (u_short)w;
+  img.ysize  = (u_short)h;
   img.zsize  = zsize = (colorstyle == F_FULLCOLOR) ? 3 : 1;
   img.min    = 0;
   img.max    = 255;
@@ -537,22 +574,33 @@
   if (ferror(fp)) { fclose(fp);  return -1; }
 
   /* allocate RLE compression tables & stuff */
-  rlebuflen = 2*w + 10;
-  tablen    = h * zsize;
+  rlebuflen = 2*w + 10;   /* 10 <= rlebuflen <= 131080 */
+  tablen    = h * zsize;  /*  1 <= tablen    <= 196605 */
 
+  /* no overflow is possible with any of these (given check on w,h above): */
   starttab  = (u_long *) malloc((size_t) tablen * sizeof(long));
   lengthtab = (u_long *) malloc((size_t) tablen * sizeof(long));
   rlebuf    = (byte *)   malloc((size_t) rlebuflen);
-  lumbuf    = (byte *)   malloc((size_t) w * 4);
+  lumbuf    = (byte *)   malloc((size_t) w * 4);   /* 262140 max */
 
-  if (!starttab || !lengthtab || !rlebuf || !lumbuf) 
+  if (!starttab || !lengthtab || !rlebuf || !lumbuf)
     FatalError("out of memory in WriteIRIS()");
 
   pos = 512 + 2 * (tablen * 4);
   fseek(fp, (long) pos, 0);
 
   /* convert image into 4-byte per pix image that the compress routines want */
-  longpic = (byte *) malloc((size_t) w * h * 4);
+  npixels = w * h;
+  bufsize = 4 * npixels;
+  if (npixels/w != h || bufsize/4 != npixels) {
+    SetISTR(ISTR_WARNING, "can't malloc longpic in WriteIRIS()");
+    free(starttab);
+    free(lengthtab);
+    free(rlebuf);
+    free(lumbuf);
+    return -1;
+  }
+  longpic = (byte *) malloc((size_t) bufsize);
   if (!longpic) FatalError("couldn't malloc longpic in WriteIRIS()");
 
   for (i=0, pptr=pic; i<h; i++) {
@@ -574,7 +622,7 @@
       }
     }
   }
-      
+
 
 
   /* compress and write the data */
@@ -584,12 +632,13 @@
       if (zsize == 1) {
 	lumrow(lptr, lumbuf, w);
 	len = compressrow(lumbuf, rlebuf, CHANOFFSET(j), w);
-      } 
+      }
       else {
 	len = compressrow(lptr, rlebuf, CHANOFFSET(j), w);
       }
 
       if (len > rlebuflen) {
+	/* this condition shouldn't kill XV, just abort writing the image */
 	FatalError("WriteIRIS: rlebuf is too small");
 	exit(1);
       }
@@ -618,10 +667,10 @@
 
   return 0;
 }
-  
+
 
 /*************************************/
-static void lumrow(rgbptr, lumptr, n) 
+static void lumrow(rgbptr, lumptr, n)
      byte *rgbptr, *lumptr;
      int n;
 {
@@ -640,7 +689,7 @@
      int   z, cnt;
 {
   byte *iptr, *ibufend, *sptr, *optr;
-  short todo, cc;							
+  short todo, cc;
   long  count;
 
   lbuf    += z;
@@ -685,7 +734,7 @@
     cc = *iptr;
     iptr += 4;
     while ((iptr<ibufend) && (*iptr == cc))  iptr += 4;
-    
+
     count = (iptr-sptr)/4;
     while (count) {
       todo = count>126 ? 126:count;
@@ -694,7 +743,7 @@
       *optr++ = cc;
     }
   }
-  
+
   *optr++ = 0;
   return (optr - rlebuf);
 }
diff -ruN xv-3.10a/xvjpeg.c xv-3.10a-bugfixes/xvjpeg.c
--- xv-3.10a/xvjpeg.c	1995-01-05 00:17:13.000000000 -0800
+++ xv-3.10a-bugfixes/xvjpeg.c	2005-03-27 16:23:06.000000000 -0800
@@ -35,7 +35,7 @@
    This is currently hardcoded to be twice the size of a schnauzer icon, as
    the schnauzer's the only thing that does a quick load... */
 
-#define QUICKWIDE 160    
+#define QUICKWIDE 160
 #define QUICKHIGH 120
 
 struct my_error_mgr {
@@ -80,28 +80,26 @@
 /***************************************************/
 void CreateJPEGW()
 {
-  XClassHint classh;
-
   jpegW = CreateWindow("xv jpeg","XVjpeg",NULL,JWIDE,JHIGH,infofg,infobg,0);
   if (!jpegW) FatalError("can't create jpeg window!");
-  
+
   XSelectInput(theDisp, jpegW, ExposureMask | ButtonPressMask | KeyPressMask);
-  
-  DCreate(&qDial, jpegW, 10, 10, 80, 100, 1, 100, 75, 5, 
+
+  DCreate(&qDial, jpegW, 10, 10, 80, 100, 1, 100, 75, 5,
 	  infofg, infobg, hicol, locol, "Quality", "%");
-  
-  DCreate(&smDial, jpegW, 120, 10, 80, 100, 0, 100, 0, 5, 
+
+  DCreate(&smDial, jpegW, 120, 10, 80, 100, 0, 100, 0, 5,
 	  infofg, infobg, hicol, locol, "Smoothing", "%");
-  
-  BTCreate(&jbut[J_BOK], jpegW, JWIDE-180-1, JHIGH-10-BUTTH-1, 80, BUTTH, 
+
+  BTCreate(&jbut[J_BOK], jpegW, JWIDE-180-1, JHIGH-10-BUTTH-1, 80, BUTTH,
 	   "Ok", infofg, infobg, hicol, locol);
-  
-  BTCreate(&jbut[J_BCANC], jpegW, JWIDE-90-1, JHIGH-10-BUTTH-1, 80, BUTTH, 
+
+  BTCreate(&jbut[J_BCANC], jpegW, JWIDE-90-1, JHIGH-10-BUTTH-1, 80, BUTTH,
 	   "Cancel", infofg, infobg, hicol, locol);
-  
+
   XMapSubwindows(theDisp, jpegW);
 }
-  
+
 
 /***************************************************/
 void JPEGDialog(vis)
@@ -122,32 +120,32 @@
 {
   /* check event to see if it's for one of our subwindows.  If it is,
      deal accordingly, and return '1'.  Otherwise, return '0' */
-  
+
   int rv;
   rv = 1;
-  
+
   if (!jpegUp) return 0;
-  
+
   if (xev->type == Expose) {
     int x,y,w,h;
     XExposeEvent *e = (XExposeEvent *) xev;
     x = e->x;  y = e->y;  w = e->width;  h = e->height;
-    
+
     /* throw away excess expose events for 'dumb' windows */
-    if (e->count > 0 && (e->window == qDial.win || 
+    if (e->count > 0 && (e->window == qDial.win ||
 			 e->window == smDial.win)) {}
-    
+
     else if (e->window == jpegW)       drawJD(x, y, w, h);
     else if (e->window == qDial.win)   DRedraw(&qDial);
     else if (e->window == smDial.win)  DRedraw(&smDial);
     else rv = 0;
   }
-  
+
   else if (xev->type == ButtonPress) {
     XButtonEvent *e = (XButtonEvent *) xev;
     int x,y;
     x = e->x;  y = e->y;
-    
+
     if (e->button == Button1) {
       if      (e->window == jpegW)      clickJD(x,y);
       else if (e->window == qDial.win)  DTrack(&qDial,  x,y);
@@ -156,18 +154,18 @@
     }  /* button1 */
     else rv = 0;
   }  /* button press */
-  
-  
+
+
   else if (xev->type == KeyPress) {
     XKeyEvent *e = (XKeyEvent *) xev;
     char buf[128];  KeySym ks;
     int stlen;
-    
+
     stlen = XLookupString(e,buf,128,&ks,(XComposeStatus *) NULL);
     buf[stlen] = '\0';
-    
+
     RemapKeyCheck(ks, buf, &stlen);
-    
+
     if (e->window == jpegW) {
       if (stlen) {
 	if (buf[0] == '\r' || buf[0] == '\n') { /* enter */
@@ -181,12 +179,12 @@
     else rv = 0;
   }
   else rv = 0;
-  
+
   if (rv==0 && (xev->type == ButtonPress || xev->type == KeyPress)) {
     XBell(theDisp, 50);
     rv = 1;   /* eat it */
   }
-  
+
   return rv;
 }
 
@@ -211,17 +209,17 @@
   char *title3 = "quality = bigger file.";
   char *title4 = "Use smoothing if saving";
   char *title5 = "an 8-bit image (eg, a GIF).";
-  
+
   char *qtitle1 = "Default = 75.";
   char *qtitle2 = "Useful range";
   char *qtitle3 = "is 5-95.";
   char *smtitle1 = "Default = 0 (none).";
   char *smtitle2 = "10-30 is enough";
   char *smtitle3 = "for typical GIFs.";
-  
+
   int  i;
   XRectangle xr;
-  
+
   xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
   XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
 
@@ -240,11 +238,11 @@
   DrawString(jpegW,  15, 10+100+10+ASCENT,            qtitle1);
   DrawString(jpegW,  15, 10+100+10+ASCENT+LINEHIGH,   qtitle2);
   DrawString(jpegW,  15, 10+100+10+ASCENT+LINEHIGH*2, qtitle3);
-  
+
   DrawString(jpegW, 115, 10+100+10+ASCENT+LINEHIGH*0, smtitle1);
   DrawString(jpegW, 115, 10+100+10+ASCENT+LINEHIGH*1, smtitle2);
   DrawString(jpegW, 115, 10+100+10+ASCENT+LINEHIGH*2, smtitle3);
-  
+
   XSetClipMask(theDisp, theGC, None);
 }
 
@@ -255,14 +253,14 @@
 {
   int i;
   BUTT *bp;
-  
+
   /* check BUTTs */
-  
+
   for (i=0; i<J_NBUTTS; i++) {
     bp = &jbut[i];
     if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h)) break;
   }
-  
+
   if (i<J_NBUTTS) {  /* found one */
     if (BTTrack(bp)) doCmd(i);
   }
@@ -281,7 +279,7 @@
 
     writeJPEG();
     JPEGDialog(0);
-    
+
     fullname = GetDirFullName();
     if (!ISPIPE(fullname[0])) {
       XVCreatedFile(fullname);
@@ -304,7 +302,7 @@
 static void writeJPEG()
 {
   FILE          *fp;
-  int            i, nc, rv, w, h, ptype, pfree;
+  int            i, nc, rv, w, h, npixels, ptype, pfree;
   register byte *ip, *ep;
   byte          *inpix, *rmap, *gmap, *bmap;
   byte          *image8, *image24;
@@ -322,6 +320,14 @@
   WaitCursor();
   inpix = GenSavePic(&ptype, &w, &h, &pfree, &nc, &rmap, &gmap, &bmap);
 
+  /* this case may not be possible to trigger, but not totally clear, so... */
+  npixels = w*h;
+  if (w <= 0 || h <= 0 || npixels/w < h) {
+    SetISTR(ISTR_WARNING, "%s:  image dimensions too large (%dx%d)",
+            fbasename, w, h);
+    return;
+  }
+
   image8 = image24 = (byte *) NULL;
 
 
@@ -332,37 +338,46 @@
       if (i==nc) colorType = F_GREYSCALE;    /* made it all the way through */
     }
     else {  /* PIC24 */
-      for (i=0,ip=inpix; i<w*h && ip[0]==ip[1] && ip[1]==ip[2]; i++,ip+=3);
-      if (i==w*h) colorType = F_GREYSCALE;  /* all the way through */
+      for (i=0,ip=inpix; i<npixels && ip[0]==ip[1] && ip[1]==ip[2]; i++,ip+=3);
+      if (i==npixels) colorType = F_GREYSCALE;  /* all the way through */
     }
   }
-  
-  
+
+
   /* first thing to do is build an 8/24-bit Greyscale/TrueColor image
      (meaning: non-colormapped) */
-  
+
   if (colorType == F_GREYSCALE) {   /* build an 8-bit Greyscale image */
-    image8 = (byte *) malloc((size_t) w * h);
+    image8 = (byte *) malloc((size_t) npixels);
     if (!image8) FatalError("writeJPEG: unable to malloc image8\n");
-    
+
     if (ptype == PIC8) {
-      for (i=0,ip=image8,ep=inpix; i<w * h; i++, ip++, ep++)
+      for (i=0,ip=image8,ep=inpix; i<npixels; i++, ip++, ep++)
 	*ip = MONO(rmap[*ep], gmap[*ep], bmap[*ep]);
     }
     else {  /* PIC24 */
-      for (i=0,ip=image8,ep=inpix; i<w*h; i++, ip++, ep+=3)
+      for (i=0,ip=image8,ep=inpix; i<npixels; i++, ip++, ep+=3)
 	*ip = MONO(ep[0],ep[1],ep[2]);
     }
   }
 
   else {    /* *not* F_GREYSCALE */
     if (ptype == PIC8) {
-      image24 = (byte *) malloc((size_t) w * h * 3);
+      int count = 3*npixels;
+
+      /* already know npixels > 0 (above) */
+      if (count/3 < npixels) {
+        SetISTR(ISTR_WARNING, "%s:  image dimensions too large (%dx%d)",
+                fbasename, w, h);
+        return;
+      }
+
+      image24 = (byte *) malloc((size_t) count);
       if (!image24) {  /* this simply isn't going to work */
 	FatalError("writeJPEG: unable to malloc image24\n");
       }
 
-      for (i=0, ip=image24, ep=inpix; i<w*h; i++, ep++) {
+      for (i=0, ip=image24, ep=inpix; i<npixels; i++, ep++) {
 	*ip++ = rmap[*ep];
 	*ip++ = gmap[*ep];
 	*ip++ = bmap[*ep];
@@ -374,16 +389,16 @@
     }
   }
 
-  
+
   /* in any event, we've got some valid image.  Do the JPEG Thing */
   rv = writeJFIF(fp, (colorType==F_GREYSCALE) ? image8 : image24,
 		 w, h, colorType);
-  
+
   if      (colorType == F_GREYSCALE) free(image8);
   else if (ptype == PIC8)            free(image24);
 
   if (pfree) free(inpix);
-  
+
   if (CloseOutFile(fp, filename, rv) == 0) DirBox(0);
   SetCursors(-1);
 }
@@ -400,7 +415,7 @@
 
 
 /**************************************************/
-METHODDEF void xv_error_exit(cinfo) 
+METHODDEF void xv_error_exit(cinfo)
      j_common_ptr cinfo;
 {
   my_error_ptr myerr;
@@ -412,7 +427,7 @@
 
 
 /**************************************************/
-METHODDEF void xv_error_output(cinfo) 
+METHODDEF void xv_error_output(cinfo)
      j_common_ptr cinfo;
 {
   my_error_ptr myerr;
@@ -464,7 +479,7 @@
   FILE                            *fp;
   static byte                     *pic;
   long                             filesize;
-  int                              i,w,h,bperpix;
+  int                              i,w,h,bperpix,bperline,count;
 
 
   fbasename = BaseName(fname);
@@ -546,16 +561,16 @@
   if (cinfo.jpeg_color_space == JCS_GRAYSCALE) {
     cinfo.out_color_space = JCS_GRAYSCALE;
     cinfo.quantize_colors = FALSE;
-    
+
     SetISTR(ISTR_INFO,"Loading %dx%d Greyscale JPEG (%ld bytes)...",
 	    w,h,filesize);
-    
+
     for (i=0; i<256; i++) pinfo->r[i] = pinfo->g[i] = pinfo->b[i] = i;
   }
   else {
     cinfo.out_color_space = JCS_RGB;
     cinfo.quantize_colors = FALSE;     /* default: give 24-bit image to XV */
-    
+
     if (!quick && picType==PIC8 && conv24MB.flags[CONV24_LOCK] == 1) {
       /*
        * we're locked into 8-bit mode:
@@ -563,23 +578,23 @@
        *   if CONV24_SLOW, use JPEG's two-pass quantizer
        *   if CONV24_BEST, or other, ask for 24-bit image and hand it to XV
        */
-      
+
       cinfo.desired_number_of_colors = 256;
-      
+
       if (conv24 == CONV24_FAST || conv24 == CONV24_SLOW) {
 	cinfo.quantize_colors = TRUE;
 	state824=1;              /* image was converted from 24 to 8 bits */
-	
+
 	cinfo.two_pass_quantize = (conv24 == CONV24_SLOW);
       }
     }
-    
+
     SetISTR(ISTR_INFO,"Loading %dx%d Color JPEG (%ld bytes)...",
 	    w,h,filesize);
   }
-  
+
   jpeg_calc_output_dimensions(&cinfo);   /* note colorspace changes... */
-    
+
 
   if (cinfo.output_components != 1 && cinfo.output_components != 3) {
     SetISTR(ISTR_WARNING, "%s:  can't read %d-plane JPEG file!",
@@ -594,7 +609,18 @@
   bperpix = cinfo.output_components;
   pinfo->type = (bperpix == 1) ? PIC8 : PIC24;
 
-  pic = (byte *) malloc((size_t) (w * h * bperpix));
+  bperline = w * bperpix;
+  count = h * bperline;
+  if (w <= 0 || h <= 0 || bperline/w < bperpix || count/h < bperline) {
+    SetISTR(ISTR_WARNING, "%s:  image dimensions too large (%dx%d)",
+            fbasename, w, h);
+    jpeg_destroy_decompress(&cinfo);
+    fclose(fp);
+    if (comment) free(comment);
+    return 0;
+  }
+
+  pic = (byte *) malloc((size_t) count);
   if (!pic) {
     SetISTR(ISTR_WARNING, "%s:  can't read JPEG file - out of memory",
 	    fbasename);
@@ -603,15 +629,24 @@
     if (comment) free(comment);
     return 0;
   }
-  
+
   jpeg_start_decompress(&cinfo);
 
   while (cinfo.output_scanline < cinfo.output_height) {
+    if (cinfo.output_scanline < 0) {   /* should never happen, but... */
+      SetISTR(ISTR_WARNING, "%s:  invalid negative scanline (%d)",
+              fbasename, cinfo.output_scanline);
+      jpeg_destroy_decompress(&cinfo);
+      fclose(fp);
+      if (comment) free(comment);
+      free(pic);
+      return 0;
+    }
     rowptr[0] = (JSAMPROW) &pic[cinfo.output_scanline * w * bperpix];
     (void) jpeg_read_scanlines(&cinfo, rowptr, (JDIMENSION) 1);
   }
 
-  
+
 
   /* return 'PICINFO' structure to XV */
 
@@ -623,7 +658,7 @@
   if (cinfo.out_color_space == JCS_GRAYSCALE) {
     sprintf(pinfo->fullInfo, "Greyscale JPEG. (%ld bytes)", filesize);
     pinfo->colType = F_GREYSCALE;
-    
+
     for (i=0; i<256; i++) pinfo->r[i] = pinfo->g[i] = pinfo->b[i] = i;
   }
   else {
@@ -638,10 +673,10 @@
       }
     }
   }
-  
-  sprintf(pinfo->shrtInfo, "%dx%d %s JPEG. ", w,h, 
+
+  sprintf(pinfo->shrtInfo, "%dx%d %s JPEG. ", w,h,
 	  (cinfo.out_color_space == JCS_GRAYSCALE) ? "Greyscale " : "Color ");
-  
+
   pinfo->comment = comment;
 
   jpeg_finish_decompress(&cinfo);
@@ -651,8 +686,8 @@
   comment = (char *) NULL;
   return 1;
 }
-  
-  
+
+
 
 
 /**************************************************/
@@ -660,7 +695,7 @@
      j_decompress_ptr cinfo;
 {
   struct jpeg_source_mgr *datasrc = cinfo->src;
-  
+
   if (datasrc->bytes_in_buffer == 0) {
     if (! (*datasrc->fill_input_buffer) (cinfo))
       ERREXIT(cinfo, JERR_CANT_SUSPEND);
@@ -688,7 +723,7 @@
   }
   else comment = (char *) realloc(comment, strlen(comment) + length + 1);
   if (!comment) FatalError("out of memory in xv_process_comment");
-  
+
   oldsp = sp = comment + strlen(comment);
   hasnull = 0;
 
@@ -770,19 +805,19 @@
 
   sprintf(xvcmt, "%sXV %s  Quality = %d, Smoothing = %d\n",
 	  CREATOR_STR, REVDATE, qDial.val, smDial.val);
-  
+
   if (picComments) {   /* append XV comment */
     char *sp, *sp1;  int done;
 
     i   = strlen(picComments);
     comment = (char *) malloc(i + strlen(xvcmt) + 2 + 1);
     if (!comment) FatalError("out of memory in writeJFIF()");
-    
+
     strcpy(comment, picComments);
-    
+
     /* see if there's a line that starts with 'CREATOR: ' in the
        comments.  If there is, rip it out. */
-    
+
     sp = comment;  done = 0;
     while (!done && *sp) {
       if (strncmp(sp, CREATOR_STR, strlen(CREATOR_STR)) == 0) {
@@ -801,7 +836,7 @@
       }
     }
 
-    /* count # of \n's at end of comment.  
+    /* count # of \n's at end of comment.
        If none, add 2.   If one, add 1.  If two or more, add none. */
 
     sp = comment + strlen(comment);
@@ -814,15 +849,15 @@
     strcat(comment, xvcmt);
   }
   else comment = xvcmt;
-  
-  
+
+
   jpeg_write_marker(&cinfo,JPEG_COM,(byte *) comment,(u_int) strlen(comment));
-  
+
   while (cinfo.next_scanline < cinfo.image_height) {
     rowptr[0] = (JSAMPROW) &pic[cinfo.next_scanline * w * bperpix];
     (void) jpeg_write_scanlines(&cinfo, rowptr, (JDIMENSION) 1);
   }
-  
+
   jpeg_finish_compress(&cinfo);
   jpeg_destroy_compress(&cinfo);
   return 0;
diff -ruN xv-3.10a/xvmisc.c xv-3.10a-bugfixes/xvmisc.c
--- xv-3.10a/xvmisc.c	1995-01-13 15:41:34.000000000 -0800
+++ xv-3.10a-bugfixes/xvmisc.c	2005-03-20 22:47:06.000000000 -0800
@@ -28,6 +28,8 @@
  *     int    xvbcmp (s1,  s2,  length)
  *     void   xvbzero(s, length)
  *     char  *xv_strstr(s1, s2)
+ *     FILE  *xv_fopen(str, str)
+ *     void   xv_mktemp(str)
  *     void   Timer(milliseconds)
  */
 
@@ -36,6 +38,10 @@
 #define NEEDSTIME
 #include "xv.h"
 
+#ifdef __linux__	/* probably others, too, but being conservative */
+#  include <unistd.h>	/* getwd() */
+#endif
+
 #include "bits/fc_left"
 #include "bits/fc_leftm"
 #include "bits/fc_left1"
@@ -61,12 +67,12 @@
 
   /* the following fakes 'XSetWMProtocols(theDisp, win, &atom_DELWIN, 1);' */
 
-  if (! atom_PROTOCOLS) 
+  if (! atom_PROTOCOLS)
     atom_PROTOCOLS = XInternAtom (theDisp, "WM_PROTOCOLS", False);
 
   if (atom_PROTOCOLS == None) return;
 
-  XChangeProperty(theDisp, win, atom_PROTOCOLS, XA_ATOM, 32, 
+  XChangeProperty(theDisp, win, atom_PROTOCOLS, XA_ATOM, 32,
 		  PropModeReplace, (unsigned char *) &atom_DELWIN, 1);
 }
 
@@ -91,9 +97,9 @@
   x = y = 1;
   i = XParseGeometry(geom,&x,&y, (unsigned int *) &w, (unsigned int *) &h);
 
-  if ((i&XValue || i&YValue)) hints.flags = USPosition;  
+  if ((i&XValue || i&YValue)) hints.flags = USPosition;
                          else hints.flags = PPosition;
-  
+
   if (!usesize || !(i&WidthValue))  w = defw;
   if (!usesize || !(i&HeightValue)) h = defh;
 
@@ -130,7 +136,7 @@
   xswamask = CWBackPixel | CWBorderPixel | CWColormap;
   if (!usesize) xswamask |= CWBitGravity;
 
-  win = XCreateWindow(theDisp, rootW, x, y, (u_int) w, (u_int) h, 
+  win = XCreateWindow(theDisp, rootW, x, y, (u_int) w, (u_int) h,
 		      (u_int) bwidth, (int) dispDEEP, InputOutput,
 		      theVisual, xswamask, &xswa);
   if (!win) return(win);   /* leave immediately if couldn't create */
@@ -152,7 +158,7 @@
 
   return(win);
 }
-  
+
 
 
 /**************************************************/
@@ -164,7 +170,7 @@
   XDrawString(theDisp, win, theGC, x, y, str, (int) strlen(str));
 }
 
-  
+
 /**************************************************/
 void CenterString(win,x,y,str)
      Window win;
@@ -174,7 +180,7 @@
   DrawString(win, CENTERX(mfinfo, x, str), CENTERY(mfinfo, y), str);
 }
 
-  
+
 /**************************************************/
 void ULineString(win,x,y,str)
      Window win;
@@ -182,11 +188,11 @@
      char *str;
 {
   DrawString(win, x, y, str);
-  XDrawLine(theDisp, win, theGC, x, y+DESCENT-1, 
+  XDrawLine(theDisp, win, theGC, x, y+DESCENT-1,
 	    x+StringWidth(str), y+DESCENT-1);
 }
 
-  
+
 /**************************************************/
 int StringWidth(str)
      char *str;
@@ -194,13 +200,13 @@
   return(XTextWidth(mfinfo, str, (int) strlen(str)));
 }
 
-  
+
 /**************************************************/
 int CursorKey(ks, shift, dotrans)
      KeySym ks;
      int    shift, dotrans;
 {
-  /* called by the KeyPress/KeyRelease event handler to determine if a 
+  /* called by the KeyPress/KeyRelease event handler to determine if a
      given keypress is a cursor key.  More complex than you'd think, since
      certain Sun Keyboards generate a variety of odd keycodes, and not all
      keyboards *have* all these keys.  Note that 'shifted' arrow keys
@@ -225,16 +231,16 @@
 
   int  i = CK_NONE;
 
-  if      (ks==XK_Up    || ks==XK_KP_Up    || 
+  if      (ks==XK_Up    || ks==XK_KP_Up    ||
 	   ks==XK_KP_8  || ks==XK_F28)             i=CK_UP;
 
-  else if (ks==XK_Down  || ks==XK_KP_Down  || 
+  else if (ks==XK_Down  || ks==XK_KP_Down  ||
 	   ks==XK_KP_2  || ks==XK_F34)             i=CK_DOWN;
 
-  else if (ks==XK_Left  || ks==XK_KP_Left  || 
+  else if (ks==XK_Left  || ks==XK_KP_Left  ||
 	   ks==XK_KP_4  || ks==XK_F30)             i=CK_LEFT;
 
-  else if (ks==XK_Right || ks==XK_KP_Right || 
+  else if (ks==XK_Right || ks==XK_KP_Right ||
 	   ks==XK_KP_6  || ks==XK_F32)             i=CK_RIGHT;
 
   else if (ks==XK_Prior || ks==XK_KP_Prior ||
@@ -257,7 +263,7 @@
     else if (i==CK_UP)       i=CK_PAGEUP;
     else if (i==CK_DOWN)     i=CK_PAGEDOWN;
   }
-  
+
   return i;
 }
 
@@ -334,9 +340,9 @@
   ev.window = win;
   ev.x = x;  ev.y = y;  ev.width = w;  ev.height = h;
   ev.count = 0;
-  
+
   XSendEvent(theDisp, win, False, NoEventMask, (XEvent *) &ev);
-}    
+}
 
 
 /***********************************/
@@ -381,7 +387,7 @@
      u_int  w, h;
      u_long bg;
 {
-  /* stipple a rectangular region by drawing 'bg' where there's 1's 
+  /* stipple a rectangular region by drawing 'bg' where there's 1's
      in the stipple pattern */
 
   XSetFillStyle (theDisp, theGC, FillStippled);
@@ -400,7 +406,7 @@
      unsigned int  w,h;
      unsigned long hi, lo, bg;
 {
-  int i,r,x1,y1;
+  int i, x1, y1;
 
   x1 = x + (int) w;
   y1 = y + (int) h;
@@ -413,7 +419,7 @@
       XDrawLine(theDisp, win, theGC, x+i, y1-i, x+i,  y+i);
       XDrawLine(theDisp, win, theGC, x+i, y+i,  x1-i, y+i);
     }
-    
+
     /* draw bot-right */
     XSetForeground(theDisp, theGC, (inout==R3D_OUT) ? lo : hi);
 
@@ -431,18 +437,18 @@
     }
   }
 }
-    
+
 
 
 /**************************************************/
 void SetCropString()
 {
   /* sets the crop string in the info box to be correct.  should
-     be called whenever 'but[BCROP].active', cXOFF,cYOFF,cWIDE,cHIGH 
+     be called whenever 'but[BCROP].active', cXOFF,cYOFF,cWIDE,cHIGH
      are changed */
 
-  if (cpic != pic) 
-    SetISTR(ISTR_CROP, "%dx%d rectangle starting at %d,%d",  
+  if (cpic != pic)
+    SetISTR(ISTR_CROP, "%dx%d rectangle starting at %d,%d",
 	    cWIDE, cHIGH, cXOFF, cYOFF);
   else SetISTR(ISTR_CROP, "<none>");
 }
@@ -469,7 +475,7 @@
   char *st;
 
   /* give 'em time to read message */
-  if (infoUp || ctrlUp || anyBrowUp) sleep(3); 
+  if (infoUp || ctrlUp || anyBrowUp) sleep(3);
   else {
     st = GetISTR(ISTR_INFO);
     OpenAlert(st);
@@ -477,7 +483,7 @@
     CloseAlert();
   }
 }
-    
+
 
 /***********************************/
 void FatalError (identifier)
@@ -491,7 +497,7 @@
 /***********************************/
 void Quit(i)
      int i;
-{ 
+{
   /* called when the program exits.  frees everything explictly created
      EXCEPT allocated colors.  This is used when 'useroot' is in operation,
      as we have to keep the alloc'd colors around, but we don't want anything
@@ -521,9 +527,9 @@
 #endif
 
     /* if NOT using stdcmap for images, free stdcmap */
-    if (colorMapMode != CM_STDCMAP) { 
+    if (colorMapMode != CM_STDCMAP) {
       int j;
-      for (j=0; j<stdnfcols; j++) 
+      for (j=0; j<stdnfcols; j++)
 	xvFreeColors(theDisp, theCmap, &stdfreecols[j], 1, 0L);
     }
 
@@ -543,13 +549,13 @@
       if (origlist[j][0] != '/') {  /* relative path, prepend 'initdir' */
 	sprintf(str,"%s/%s", initdir, origlist[j]);
 	if (unlink(str)) {
-	  fprintf(stderr,"%s: can't delete '%s' - %s\n", 
+	  fprintf(stderr,"%s: can't delete '%s' - %s\n",
 		  cmd, str, ERRSTR(errno));
 	}
       }
       else {
 	if (unlink(origlist[j])) {
-	  fprintf(stderr,"%s: can't delete '%s' - %s\n", 
+	  fprintf(stderr,"%s: can't delete '%s' - %s\n",
 		  cmd, origlist[j], ERRSTR(errno));
 	}
       }
@@ -567,7 +573,7 @@
 void LoadFishCursors()
 {
 #define fc_w 16
-#define fc_h 16 
+#define fc_h 16
 
   Pixmap flpix,flmpix,fmpix,fmmpix,frpix,frmpix;
   Pixmap fl1pix, fl1mpix, fr1pix, fr1mpix;
@@ -592,7 +598,7 @@
 
   fr1pix = XCreatePixmapFromBitmapData(theDisp, ctrlW, (char *) fc_right1_bits,
 	     fc_w, fc_h, 1L, 0L, 1);
-  fr1mpix = XCreatePixmapFromBitmapData(theDisp, ctrlW, 
+  fr1mpix = XCreatePixmapFromBitmapData(theDisp, ctrlW,
 					(char *) fc_right1m_bits,
 	     fc_w, fc_h, 1L, 0L, 1);
 
@@ -613,7 +619,7 @@
   fr1curs= XCreatePixmapCursor(theDisp, fr1pix,fr1mpix,&fg, &bg, 8,8);
   frcurs = XCreatePixmapCursor(theDisp, frpix, frmpix, &fg, &bg, 8,8);
 
-  if (!flcurs || !fmcurs || !frcurs || !fl1curs || !fr1curs) 
+  if (!flcurs || !fmcurs || !frcurs || !fl1curs || !fr1curs)
     { flcurs = fmcurs = frcurs = (Cursor) NULL; }
 }
 
@@ -633,8 +639,8 @@
     time(&lastwaittime);
     waiting=1;
     xwmh.input       = True;
-    xwmh.icon_pixmap = riconPix;  
-    xwmh.icon_mask   = riconmask;  
+    xwmh.icon_pixmap = riconPix;
+    xwmh.icon_mask   = riconmask;
     xwmh.flags = (InputHint | IconPixmapHint | IconMaskHint) ;
     if (!useroot && mainW) XSetWMHints(theDisp, mainW, &xwmh);
     if ( useroot && ctrlW) XSetWMHints(theDisp, ctrlW, &xwmh);
@@ -665,8 +671,8 @@
     if (waiting) {
       waiting=0;
       xwmh.input       = True;
-      xwmh.icon_pixmap = iconPix;  
-      xwmh.icon_mask   = iconmask;  
+      xwmh.icon_pixmap = iconPix;
+      xwmh.icon_mask   = iconmask;
       xwmh.flags = (InputHint | IconPixmapHint | IconMaskHint) ;
       if (!useroot && mainW) XSetWMHints(theDisp, mainW, &xwmh);
       if ( useroot && ctrlW) XSetWMHints(theDisp, ctrlW, &xwmh);
@@ -694,11 +700,11 @@
 
   XFlush(theDisp);
 }
-  
+
 
 static void set_cursors(mainc, otherc)
      Cursor mainc, otherc;
-{    
+{
   if (!useroot && mainW) XDefineCursor(theDisp, mainW, mainc);
   if (infoW) XDefineCursor(theDisp, infoW, otherc);
   if (ctrlW) XDefineCursor(theDisp, ctrlW, otherc);
@@ -708,11 +714,11 @@
 
   SetBrowseCursor(otherc);
   SetTextCursor(otherc);
-  
+
 #ifdef HAVE_JPEG
   if (jpegW) XDefineCursor(theDisp, jpegW, otherc);
 #endif
-  
+
 #ifdef HAVE_TIFF
   if (tiffW) XDefineCursor(theDisp, tiffW, otherc);
 #endif
@@ -725,7 +731,7 @@
 {
   char *basname;
 
-  /* given a complete path name ('/foo/bar/weenie.gif'), returns just the 
+  /* given a complete path name ('/foo/bar/weenie.gif'), returns just the
      'simple' name ('weenie.gif').  Note that it does not make a copy of
      the name, so don't be modifying it... */
 
@@ -736,7 +742,7 @@
   return basname;
 }
 
-  
+
 /***************************************************/
 void DrawTempGauge(win, x,y,w,h, ratio, fg,bg,hi,lo, str)
      Window win;
@@ -773,14 +779,14 @@
     if (numchars) {      /* do string */
       if (barwide < maxwide) {
 	XSetForeground(theDisp, theGC, bg);
-	XFillRectangle(theDisp, win, theGC, x+3+barwide, y+3, 
+	XFillRectangle(theDisp, win, theGC, x+3+barwide, y+3,
 		       (u_int) (maxwide-barwide), (u_int) (h-5));
       }
-	
+
       XSetFunction(theDisp, theGC, GXinvert);
       XSetPlaneMask(theDisp, theGC, fg ^ bg);
 
-      XDrawString(theDisp, win, theGC, CENTERX(mfinfo, (x+w/2), str), 
+      XDrawString(theDisp, win, theGC, CENTERX(mfinfo, (x+w/2), str),
 		  CENTERY(mfinfo, (y+h/2)), str, numchars);
 
       XSetFunction(theDisp, theGC, GXcopy);
@@ -789,18 +795,18 @@
 
     else if (barwide < maxwide) {
       XDrawLine(theDisp,win,theGC,x+3+barwide, y+h/2 + 0, x+w-3, y+h/2 + 0);
-      
+
       XSetForeground(theDisp, theGC, lo);
       XDrawLine(theDisp,win,theGC,x+3+barwide, y+h/2 + 1, x+w-3, y+h/2 + 1);
-      
+
       XSetForeground(theDisp, theGC, hi);
       XDrawLine(theDisp,win,theGC,x+3+barwide, y+h/2 + 2, x+w-3, y+h/2 + 2);
-      
+
       XSetForeground(theDisp, theGC, bg);
-      XFillRectangle(theDisp, win, theGC, x+3+barwide, y+3, 
+      XFillRectangle(theDisp, win, theGC, x+3+barwide, y+3,
 		     (u_int) (maxwide-barwide), (u_int) (h/2 - 3));
-      
-      XFillRectangle(theDisp, win, theGC, x+3+barwide, y+h/2 + 3, 
+
+      XFillRectangle(theDisp, win, theGC, x+3+barwide, y+h/2 + 3,
 		     (u_int) (maxwide-barwide),(u_int)((h-3) - (h/2+3)) + 1);
     }
   }
@@ -815,35 +821,35 @@
     if (numchars) {
       if (barwide < maxwide) {
 	XSetForeground(theDisp, theGC, bg);
-	XFillRectangle(theDisp, win, theGC, x+1+barwide, y+1, 
+	XFillRectangle(theDisp, win, theGC, x+1+barwide, y+1,
 		       (u_int) (maxwide-barwide), (u_int) (h-1));
       }
-      
+
       XSetFunction(theDisp, theGC, GXinvert);
       XSetPlaneMask(theDisp, theGC, fg ^ bg);
 
-      XDrawString(theDisp, win, theGC, CENTERX(mfinfo, (x+w/2), str), 
+      XDrawString(theDisp, win, theGC, CENTERX(mfinfo, (x+w/2), str),
 		  CENTERY(mfinfo, (y+h/2)), str, numchars);
 
       XSetFunction(theDisp, theGC, GXcopy);
       XSetPlaneMask(theDisp, theGC, AllPlanes);
     }
-    
+
     else if (barwide < maxwide) {
       XDrawLine(theDisp, win, theGC, x+1+barwide, y+h/2, x+w-1, y+h/2);
-      
+
       XSetForeground(theDisp, theGC, bg);
-      XFillRectangle(theDisp, win, theGC, x+1+barwide, y+1, 
+      XFillRectangle(theDisp, win, theGC, x+1+barwide, y+1,
 		     (u_int) (maxwide-barwide), (u_int) (h/2 - 1));
-      
-      XFillRectangle(theDisp, win, theGC, x+1+barwide, y+h/2 + 1, 
+
+      XFillRectangle(theDisp, win, theGC, x+1+barwide, y+h/2 + 1,
 		     (u_int)(maxwide-barwide),(u_int)(((h-1) - (h/2+1))+1));
     }
   }
 
   XFlush(theDisp);
 }
-    
+
 
 
 /***************************************************/
@@ -852,7 +858,7 @@
      char *str;
 {
   /* called during 'long' operations (algorithms, smoothing, etc.) to
-     give some indication that the program will ever finish.  Draws a 
+     give some indication that the program will ever finish.  Draws a
      temperature gauge in either mainW (if not useRoot), or ctrlW.
      Tries to be clever:  only draws gauge if it looks like the operation is
      going to take more than a few seconds.  Calling with val == max removes
@@ -887,7 +893,7 @@
   if (!waiting) {     /* not waiting (or not waiting any longer) */
     if (nowTime == lastTime && val<max) return;  /* max one draw per second */
     lastTime = nowTime;
-    DrawTempGauge(win, xpos, ypos, 100,19, doneness, 
+    DrawTempGauge(win, xpos, ypos, 100,19, doneness,
 		    infofg,infobg,hicol,locol,str);
 
     if (val >= max) {            /* remove temp gauge */
@@ -945,7 +951,7 @@
    */
 
   if (src==dst || len<=0) return;    /* nothin' to do */
-  
+
   if (src<dst && src+len>dst) {  /* do a backward copy */
     src = src + len - 1;
     dst = dst + len - 1;
@@ -957,7 +963,7 @@
     for ( ; len>0; len--, src++, dst++) *dst = *src;
   }
 }
-    
+
 
 /***************************************************/
 int xvbcmp (s1, s2, len)
@@ -987,7 +993,7 @@
 {
   /* gets the current working directory.  No trailing '/' */
 
-  char *rv; 
+  char *rv;
 
 #ifdef USE_GETCWD
   rv = (char *) getcwd(buf, buflen);
@@ -996,7 +1002,7 @@
 #endif
 
   if (!rv || strlen(rv)==0) {
-    if (((rv=(char *) getenv("PWD"))==NULL) && 
+    if (((rv=(char *) getenv("PWD"))==NULL) &&
 	((rv=(char *) getenv("cwd"))==NULL)) rv = "./";
     strcpy(buf, rv);
   }
@@ -1006,7 +1012,7 @@
 
 /***************************************************/
 
-/* 
+/*
  *	Source code for the "strstr" library routine.
  *
  * Copyright 1988 Regents of the University of California
@@ -1066,6 +1072,22 @@
 }
 
 
+/***************************************************/
+/* GRR 20050320:  added actual mk[s]temp() call... */
+void xv_mktemp(buf, fname)
+     char *buf, *fname;
+{
+#ifndef VMS
+  sprintf(buf, "%s/%s", tmpdir, fname);
+#else
+  sprintf(buf, "Sys$Disk:[]%s", fname);
+#endif
+#ifdef USE_MKSTEMP
+  close(mkstemp(buf));
+#else
+  mktemp(buf);
+#endif
+}
 
 
 /*******/
@@ -1124,7 +1146,7 @@
   {
     /* default Timer() method now uses 'select()', which probably works
 	on all systems *anyhow* (except for VMS...) */
-    
+
     struct timeval time;
 
     time.tv_sec = usec / 1000000L;
diff -ruN xv-3.10a/xvpbm.c xv-3.10a-bugfixes/xvpbm.c
--- xv-3.10a/xvpbm.c	1995-01-03 13:23:44.000000000 -0800
+++ xv-3.10a-bugfixes/xvpbm.c	2005-04-03 14:25:28.000000000 -0700
@@ -115,7 +115,7 @@
   }
 
   return rv;
-}  
+}
 
 
 
@@ -127,15 +127,21 @@
 {
   byte *pic8;
   byte *pix;
-  int   i,j,bit,w,h;
+  int   i,j,bit,w,h,npixels;
+
+  w = pinfo->w;
+  h = pinfo->h;
 
-  w = pinfo->w;  h = pinfo->h;
-  pic8 = (byte *) calloc((size_t) w * h, (size_t) 1);
-  if (!pic8) return pbmError(bname, "couldn't malloc 'pic8'");
+  npixels = w * h;
+  if (w <= 0 || h <= 0 || npixels/w != h)
+    return pbmError(bname, "image dimensions too large");
+
+  pic8 = (byte *) calloc((size_t) npixels, (size_t) 1);
+  if (!pic8) FatalError("couldn't malloc 'pic8' for PBM");
 
   pinfo->pic  = pic8;
   pinfo->type = PIC8;
-  sprintf(pinfo->fullInfo, "PBM, %s format.  (%ld bytes)", 
+  sprintf(pinfo->fullInfo, "PBM, %s format.  (%ld bytes)",
 	  (raw) ? "raw" : "ascii", filesize);
   sprintf(pinfo->shrtInfo, "%dx%d PBM.", w, h);
   pinfo->colType = F_BWDITHER;
@@ -153,7 +159,7 @@
       for (j=0; j<w; j++, pix++) *pix = getbit(fp, pinfo);
     }
 
-    if (numgot != w*h) pbmError(bname, TRUNCSTR);
+    if (numgot != npixels) pbmError(bname, TRUNCSTR);
     if (garbage) {
       return(pbmError(bname, "Garbage characters in image data."));
     }
@@ -192,17 +198,23 @@
      int      raw, maxv;
 {
   byte *pix, *pic8;
-  int   i,j,bitshift,w,h, holdmaxv;
+  int   i,j,bitshift,w,h,npixels, holdmaxv;
+
 
+  w = pinfo->w;
+  h = pinfo->h;
 
-  w = pinfo->w;  h = pinfo->h;
-  pic8 = (byte *) calloc((size_t) w*h, (size_t) 1);
-  if (!pic8) return(pbmError(bname, "couldn't malloc 'pic8'"));
+  npixels = w * h;
+  if (w <= 0 || h <= 0 || npixels/w != h)
+    return pbmError(bname, "image dimensions too large");
+
+  pic8 = (byte *) calloc((size_t) npixels, (size_t) 1);
+  if (!pic8) FatalError("couldn't malloc 'pic8' for PGM");
 
 
   pinfo->pic  = pic8;
   pinfo->type = PIC8;
-  sprintf(pinfo->fullInfo, "PGM, %s format.  (%ld bytes)", 
+  sprintf(pinfo->fullInfo, "PGM, %s format.  (%ld bytes)",
 	  (raw) ? "raw" : "ascii", filesize);
   sprintf(pinfo->shrtInfo, "%dx%d PGM.", pinfo->w, pinfo->h);
   pinfo->colType = F_GREYSCALE;
@@ -236,11 +248,11 @@
       }
     }
     else {
-      numgot = fread(pic8, (size_t) 1, (size_t) w*h, fp);  /* read raw data */
+      numgot = fread(pic8, (size_t)1, (size_t)npixels, fp);  /* read raw data */
     }
   }
 
-  if (numgot != w*h) pbmError(bname, TRUNCSTR);   /* warning only */
+  if (numgot != npixels) pbmError(bname, TRUNCSTR);   /* warning only */
 
   if (garbage) {
     return (pbmError(bname, "Garbage characters in image data."));
@@ -256,18 +268,24 @@
      PICINFO *pinfo;
      int      raw, maxv;
 {
-  byte *pix, *pic24, scale[256], *pic8;
-  int   i,j,bitshift, w, h, holdmaxv;
+  byte *pix, *pic24, scale[256];
+  int   i,j,bitshift, w, h, npixels, bufsize, holdmaxv;
+
+  w = pinfo->w;
+  h = pinfo->h;
 
-  w = pinfo->w;  h = pinfo->h;
+  npixels = w * h;
+  bufsize = 3*npixels;
+  if (w <= 0 || h <= 0 || npixels/w != h || bufsize/3 != npixels)
+    return pbmError(bname, "image dimensions too large");
 
   /* allocate 24-bit image */
-  pic24 = (byte *) calloc((size_t) w*h*3, (size_t) 1);
-  if (!pic24) FatalError("couldn't malloc 'pic24'");
+  pic24 = (byte *) calloc((size_t) bufsize, (size_t) 1);
+  if (!pic24) FatalError("couldn't malloc 'pic24' for PPM");
 
   pinfo->pic  = pic24;
   pinfo->type = PIC24;
-  sprintf(pinfo->fullInfo, "PPM, %s format.  (%ld bytes)", 
+  sprintf(pinfo->fullInfo, "PPM, %s format.  (%ld bytes)",
 	  (raw) ? "raw" : "ascii", filesize);
   sprintf(pinfo->shrtInfo, "%dx%d PPM.", w, h);
   pinfo->colType = F_FULLCOLOR;
@@ -297,20 +315,20 @@
       }
     }
     else {
-      numgot = fread(pic24, (size_t) 1, (size_t) w*h*3, fp);  /* read data */
+      numgot = fread(pic24, (size_t) 1, (size_t) bufsize, fp);  /* read data */
     }
   }
-  
-  if (numgot != w*h*3) pbmError(bname, TRUNCSTR);
+
+  if (numgot != bufsize) pbmError(bname, TRUNCSTR);
 
   if (garbage)
     return(pbmError(bname, "Garbage characters in image data."));
 
 
-  /* have to scale all RGB values up (Conv24to8 expects RGB values to
-     range from 0-255 */
+  /* have to scale up all RGB values (Conv24to8 expects RGB values to
+     range from 0-255) */
 
-  if (maxv<255) { 
+  if (maxv<255) {
     for (i=0; i<=maxv; i++) scale[i] = (i * 255) / maxv;
 
     for (i=0, pix=pic24; i<h; i++) {
@@ -360,8 +378,8 @@
 	  pinfo->comment[0] = '\0';
 	}
 	else {
-	  tmpptr = (char *) realloc(pinfo->comment, 
-		      strlen(pinfo->comment) + strlen(cmt) + 1); 
+	  tmpptr = (char *) realloc(pinfo->comment,
+		      strlen(pinfo->comment) + strlen(cmt) + 1);
 	  if (!tmpptr) FatalError("realloc failure in xvpbm.c getint");
 	  pinfo->comment = tmpptr;
 	}
@@ -445,8 +463,8 @@
 	  pinfo->comment[0] = '\0';
 	}
 	else {
-	  tmpptr = (char *) realloc(pinfo->comment, 
-		      strlen(pinfo->comment) + strlen(cmt) + 1); 
+	  tmpptr = (char *) realloc(pinfo->comment,
+		      strlen(pinfo->comment) + strlen(cmt) + 1);
 	  if (!tmpptr) FatalError("realloc failure in xvpbm.c getint");
 	  pinfo->comment = tmpptr;
 	}
@@ -490,7 +508,7 @@
      char *comment;
 {
   /* writes a PBM/PGM/PPM file to the already open stream
-     if (raw), writes as RAW bytes, otherwise writes as ASCII 
+     if (raw), writes as RAW bytes, otherwise writes as ASCII
      'colorstyle' single-handedly determines the type of file written
      if colorstyle==0, (Full Color) a PPM file is written
      if colorstyle==1, (Greyscale)  a PGM file is written
@@ -546,7 +564,7 @@
 	  }
 	}
 	else {
-	  if (ptype==PIC8) 
+	  if (ptype==PIC8)
 	    fprintf(fp,"%3d %3d %3d ",rmap[*pix], gmap[*pix], bmap[*pix]);
 	  else
 	    fprintf(fp,"%3d %3d %3d ",pix[0], pix[1], pix[2]);
@@ -554,7 +572,7 @@
 	  len+=12;
 	  if (len>58) { fprintf(fp,"\n");  len=0; }
 	}
-	
+
 	pix += (ptype==PIC24) ? 3 : 1;
       }
     }
@@ -626,10 +644,3 @@
 
   return 0;
 }
-
-
-	  
-	  
-
-
-
diff -ruN xv-3.10a/xvpcx.c xv-3.10a-bugfixes/xvpcx.c
--- xv-3.10a/xvpcx.c	1995-01-10 15:06:37.000000000 -0800
+++ xv-3.10a-bugfixes/xvpcx.c	2005-03-25 08:10:03.000000000 -0800
@@ -29,7 +29,7 @@
 #define PCX_YMAXH   11
                           /* hres (12,13) and vres (14,15) not used */
 #define PCX_CMAP    16    /* start of 16*3 colormap data */
-#define PCX_PLANES  65 
+#define PCX_PLANES  65
 #define PCX_BPRL    66
 #define PCX_BPRH    67
 
@@ -51,8 +51,8 @@
 {
   FILE  *fp;
   long   filesize;
-  char  *bname, *errstr;
-  byte   hdr[128], *image;
+  char  *bname;
+  byte   hdr[128];
   int    i, colors, gray, fullcolor;
 
   pinfo->type = PIC8;
@@ -64,7 +64,7 @@
   /* open the stream */
   fp = xv_fopen(fname,"r");
   if (!fp) return (pcxError(bname, "unable to open file"));
-  
+
 
   /* figure out the file size */
   fseek(fp, 0L, 2);
@@ -84,10 +84,10 @@
     return pcxError(bname,"unrecognized magic number");
   }
 
-  pinfo->w = (hdr[PCX_XMAXL] + ((int) hdr[PCX_XMAXH]<<8)) 
+  pinfo->w = (hdr[PCX_XMAXL] + ((int) hdr[PCX_XMAXH]<<8))
            - (hdr[PCX_XMINL] + ((int) hdr[PCX_XMINH]<<8));
 
-  pinfo->h = (hdr[PCX_YMAXL] + ((int) hdr[PCX_YMAXH]<<8)) 
+  pinfo->h = (hdr[PCX_YMAXL] + ((int) hdr[PCX_YMAXH]<<8))
            - (hdr[PCX_YMINL] + ((int) hdr[PCX_YMINH]<<8));
 
   pinfo->w++;  pinfo->h++;
@@ -96,10 +96,10 @@
   fullcolor = (hdr[PCX_BPP] == 8 && hdr[PCX_PLANES] == 3);
 
   if (DEBUG) {
-    fprintf(stderr,"PCX: %dx%d image, version=%d, encoding=%d\n", 
+    fprintf(stderr,"PCX: %dx%d image, version=%d, encoding=%d\n",
 	    pinfo->w, pinfo->h, hdr[PCX_VER], hdr[PCX_ENC]);
     fprintf(stderr,"   BitsPerPixel=%d, planes=%d, BytePerRow=%d, colors=%d\n",
-	    hdr[PCX_BPP], hdr[PCX_PLANES], 
+	    hdr[PCX_BPP], hdr[PCX_PLANES],
 	    hdr[PCX_BPRL] + ((int) hdr[PCX_BPRH]<<8),
 	    colors);
   }
@@ -190,9 +190,9 @@
 
   if (colors > 2 || (colors==2 && !gray)) {  /* grayscale or PseudoColor */
     pinfo->colType = (gray) ? F_GREYSCALE : F_FULLCOLOR;
-    sprintf(pinfo->fullInfo, 
-	    "%s PCX, %d plane%s, %d bit%s per pixel.  (%ld bytes)", 
-	    (gray) ? "Greyscale" : "Color", 
+    sprintf(pinfo->fullInfo,
+	    "%s PCX, %d plane%s, %d bit%s per pixel.  (%ld bytes)",
+	    (gray) ? "Greyscale" : "Color",
 	    hdr[PCX_PLANES], (hdr[PCX_PLANES]==1) ? "" : "s",
 	    hdr[PCX_BPP],    (hdr[PCX_BPP]==1) ? "" : "s",
 	    filesize);
@@ -218,15 +218,21 @@
      byte    *hdr;
 {
   /* load an image with at most 8 bits per pixel */
-  
+
   byte *image;
-  
+  int count;
+
   /* note:  overallocation to make life easier... */
-  image = (byte *) malloc((size_t) (pinfo->h + 1) * pinfo->w + 16);
+  count = (pinfo->h + 1) * pinfo->w + 16;  /* up to 65537*65536+16 (~ 65552) */
+  if (pinfo->w <= 0 || pinfo->h <= 0 || count/pinfo->w < pinfo->h) {
+    pcxError(fname, "Bogus 8-bit PCX file!!");
+    return (0);
+  }
+  image = (byte *) malloc((size_t) count);
   if (!image) FatalError("Can't alloc 'image' in pcxLoadImage8()");
-  
-  xvbzero((char *) image, (size_t) ((pinfo->h+1) * pinfo->w + 16));
-  
+
+  xvbzero((char *) image, (size_t) count);
+
   switch (hdr[PCX_BPP]) {
   case 1:   pcxLoadRaster(fp, image, 1, hdr, pinfo->w, pinfo->h);   break;
   case 8:   pcxLoadRaster(fp, image, 8, hdr, pinfo->w, pinfo->h);   break;
@@ -249,25 +255,33 @@
      byte *hdr;
 {
   byte *pix, *pic24, scale[256];
-  int   c, i, j, w, h, maxv, cnt, planes, bperlin, nbytes;
-  
+  int   c, i, j, w, h, maxv, cnt, planes, bperlin, nbytes, count;
+
   w = pinfo->w;  h = pinfo->h;
-  
-  planes = (int) hdr[PCX_PLANES];
-  bperlin = hdr[PCX_BPRL] + ((int) hdr[PCX_BPRH]<<8);
-  
+
+  planes = (int) hdr[PCX_PLANES];  /* 255 max, but can't get here unless = 3 */
+  bperlin = hdr[PCX_BPRL] + ((int) hdr[PCX_BPRH]<<8);  /* 65535 max */
+
+  j = h*planes;          /* w and h are limited to 65536, planes to 3 */
+  count = w*j;           /* ...so this could wrap up to 3 times */
+  nbytes = bperlin*j;    /* ...and this almost 3 times */
+  if (w <= 0 || h <= 0 || planes <= 0 || bperlin <= 0 ||
+      j/h < planes || count/w < j || nbytes/bperlin < j) {
+    pcxError(fname, "Bogus 24-bit PCX file!!");
+    return (0);
+  }
+
   /* allocate 24-bit image */
-  pic24 = (byte *) malloc((size_t) w*h*planes);
-  if (!pic24) FatalError("couldn't malloc 'pic24'");
-  
-  xvbzero((char *) pic24, (size_t) w*h*planes);
-  
+  pic24 = (byte *) malloc((size_t) count);
+  if (!pic24) FatalError("Can't malloc 'pic24' in pcxLoadImage24()");
+
+  xvbzero((char *) pic24, (size_t) count);
+
   maxv = 0;
   pix = pinfo->pic = pic24;
   i = 0;      /* planes, in this while loop */
   j = 0;      /* bytes per line, in this while loop */
-  nbytes = bperlin*h*planes;
- 
+
   while (nbytes > 0 && (c = getc(fp)) != EOF) {
     if ((c & 0xC0) == 0xC0) {   /* have a rep. count */
       cnt = c & 0x3F;
@@ -275,9 +289,9 @@
       if (c == EOF) { getc(fp); break; }
     }
     else cnt = 1;
-    
+
     if (c > maxv)  maxv = c;
-    
+
     while (cnt-- > 0) {
       if (j < w) {
 	*pix = c;
@@ -297,19 +311,19 @@
       }
     }
   }
-  
-  
+
+
   /* scale all RGB to range 0-255, if they aren't */
 
-  if (maxv<255) { 
+  if (maxv<255) {
     for (i=0; i<=maxv; i++) scale[i] = (i * 255) / maxv;
-    
+
     for (i=0, pix=pic24; i<h; i++) {
       if ((i&0x3f)==0) WaitCursor();
       for (j=0; j<w*planes; j++, pix++) *pix = scale[*pix];
     }
   }
-  
+
   return 1;
 }
 
@@ -321,13 +335,13 @@
      byte    *image, *hdr;
      int      depth,w,h;
 {
-  /* supported:  8 bits per pixel, 1 plane, or 1 bit per pixel, 1-8 planes */
+  /* supported:  8 bits per pixel, 1 plane; or 1 bit per pixel, 1-8 planes */
 
   int row, bcnt, bperlin, pad;
   int i, j, b, cnt, mask, plane, pmask;
   byte *oldimage;
 
-  bperlin = hdr[PCX_BPRL] + ((int) hdr[PCX_BPRH]<<8);
+  bperlin = hdr[PCX_BPRL] + ((int) hdr[PCX_BPRH]<<8);  /* 65535 max */
   if (depth == 1) pad = (bperlin * 8) - w;
              else pad = bperlin - w;
 
@@ -342,7 +356,7 @@
       if (b == EOF) { getc(fp); return; }
     }
     else cnt = 1;
-    
+
     for (i=0; i<cnt; i++) {
       if (depth == 1) {
 	for (j=0, mask=0x80; j<8; j++) {
@@ -351,12 +365,12 @@
 	}
       }
       else *image++ = (byte) b;
-      
+
       bcnt++;
-	
+
       if (bcnt == bperlin) {     /* end of a line reached */
 	bcnt = 0;
-	plane++;  
+	plane++;
 
 	if (plane >= (int) hdr[PCX_PLANES]) {   /* moved to next row */
 	  plane = 0;
@@ -367,13 +381,13 @@
 	}
 	else {   /* next plane, same row */
 	  image = oldimage;
-	}	
+	}
 
 	pmask = 1 << plane;
       }
     }
   }
-}    
+}
 
 
 
diff -ruN xv-3.10a/xvpds.c xv-3.10a-bugfixes/xvpds.c
--- xv-3.10a/xvpds.c	1995-01-03 13:25:52.000000000 -0800
+++ xv-3.10a-bugfixes/xvpds.c	2005-04-03 11:31:30.000000000 -0700
@@ -22,23 +22,23 @@
    Choice of algorithm for 16->8 bit conversion--linear or histogram stretch.
     (adds CONV24_HIST item in "24/8 bit" pull-down menu.)
    Uses any "palette.tab" file in cwd to color PDS/VICAR image.
- 
+
  * 9-2-91    began integration.	 Much of this code is lifted from vicar.c,
  	     which I wrote for xloadimage.  This is a little simpler, though.
- 
+
  * 10-17-91  pdsuncomp is called with system(), which typically feeds the
  	     commandline to sh.  Make sure that your .profile adds wherever
  	     you have pdsuncomp to the PATH, like
- 
+
  		PATH=$PATH:/usr/local/bin
- 
+
  * 11-15-91  substituted vdcomp from Viking CD's for pdsuncomp. I added
              recognition of - and shut off various messages
- 
+
  * 1-5-92    merged into xv rel 2
- 
+
  * 3-11-92   cleaned up some comments
- 
+
  * 3-24-92   Got some new CD's from NASA of mosics and other processed Viking
              stuff.  There are actually records terminated with CRNLCR in
              these images, as well as ones that identify the spacecraft name
@@ -46,14 +46,14 @@
              yet further to deal with these.  There's a Sun 4 XView binary for
              an image display program on these discs, but it's nowhere near as
              neat as the good Mr. Bradley's XV.
- 
- 
+
+
  * Sources of these CD's:
  *
  *  National Space Science Data Center
  *  Goddard Space Flight Center
  *  Code 933.4
- *  Greenbelt, Maryland  
+ *  Greenbelt, Maryland
  *  (301) 286-6695
  *   or call
  *  (301) 286-9000 (300,1200,2400 bps)
@@ -91,10 +91,10 @@
  * Copyright 1989, 1990 by Anthony A. Datri
  *
  * Permission to use, copy, and distribute for non-commercial purposes,
- * is hereby granted without fee, providing that the above copyright   
+ * is hereby granted without fee, providing that the above copyright
  * notice appear in all copies, that both the copyright notice and this
  * permission notice appear in supporting documentation.
- * 
+ *
  * In exception to the above, permission to John Bradley is hereby granted to
  * distribute this code as he sees fit within the context of his "xv" image
  * viewer.
@@ -132,8 +132,8 @@
 
 
 static int	lastwasinote = FALSE;
-static char	scanbuff         [MAX_SIZE], 
-                rtbuff         [RTBUFFSIZE], 
+static char	scanbuff         [MAX_SIZE],
+                rtbuff         [RTBUFFSIZE],
 		inote	   [20*COMMENTSIZE],
                 infobuff      [COMMENTSIZE],
 		spacecraft    [COMMENTSIZE],
@@ -203,10 +203,10 @@
 		  }
                 return(count);
 
-    case EOF:	*bp='\0';  return(count);		    
-    
+    case EOF:	*bp='\0';  return(count);
+
     case '\0':  return(count);
-    
+
     default:	count++;  *bp++ = c;
     }
   }
@@ -242,7 +242,7 @@
  * disc seem to leave off the first two bytes.  Sigh.  This may sometimes be
  * a distinction between the fixed and variable-record files.
  */
-            
+
 /*******************************************/
 int LoadPDS(fname, pinfo)
      char    *fname;
@@ -250,11 +250,11 @@
 {
   /* returns '1' on success, '0' on failure */
 
-  int tempnum;
+  int tempnum, bytewidth, bufsize;
   FILE	*zf;
   static int isfixed,teco,i,j,itype,vaxbyte,
              recsize,hrecsize,irecsize,isimage,labelrecs,labelsofar,
-             x,y,lpsize,lssize,samplesize,returnp,labelsize,yy;
+             w,h,lpsize,lssize,samplesize,returnp,labelsize,yy;
   char	*tmp;
   char  *ftypstr;
   unsigned long filesize;
@@ -265,7 +265,7 @@
   returnp = isimage = FALSE;
   itype   = PDSTRASH;
 
-  teco = i = j = recsize = hrecsize = irecsize = labelrecs = x = y = 0;
+  teco = i = j = recsize = hrecsize = irecsize = labelrecs = w = h = 0;
   lpsize = lssize = samplesize = labelsize = labelsofar = 0;
 
   (*pdsuncompfname) = (*iname) = (*target) = (*filtname) = (*garbage) = '\0';
@@ -363,7 +363,7 @@
 	 * length indicator. If the length indicator is odd, then a pad byte
 	 * is appended to the end of the record so that all records contain
 	 * an even number of bytes." */
-	                                                                    
+
 	i=getc(zf);
 	j=getc(zf);
 	if (j == EOF) {
@@ -371,7 +371,7 @@
 	  fclose(zf);
 	  return 0;
 	}
-	
+
 	teco = i + (j << 8);
 	if (teco % 2) teco++;
 
@@ -380,7 +380,7 @@
 	  fclose(zf);
 	  return 0;
 	}
-	
+
 	scanbuff[teco]='\0';
       }
 
@@ -429,11 +429,11 @@
 		 (sscanf(scanbuff," LABEL_RECORDS = %d", &labelrecs) == 1)) {
 	lastwasinote=FALSE;
 	continue;
-      } else if (sscanf(scanbuff," IMAGE_LINES = %d",&y) == 1) {
+      } else if (sscanf(scanbuff," IMAGE_LINES = %d",&h) == 1) {
 	isimage=TRUE; lastwasinote=FALSE; continue;
-      } else if (sscanf(scanbuff," LINE_SAMPLES = %d",&x) == 1) {
+      } else if (sscanf(scanbuff," LINE_SAMPLES = %d",&w) == 1) {
 	lastwasinote=FALSE; continue;
-      } else if (sscanf(scanbuff," LINES = %d",&y) == 1) {
+      } else if (sscanf(scanbuff," LINES = %d",&h) == 1) {
 	isimage=TRUE; lastwasinote=FALSE; continue;
       } else if (sscanf(scanbuff," HEADER_RECORD_BYTES = %d",&hrecsize)==1) {
 	lastwasinote=FALSE; continue;
@@ -472,7 +472,7 @@
 
       } else if (sscanf(scanbuff," INSTRUMENT_GAIN_STATE = %s",gainmode)==1) {
 	lastwasinote=FALSE; continue;
-	
+
       } else if (sscanf(scanbuff," EDIT_MODE_ID = %s", editmode) == 1) {
 	lastwasinote=FALSE; continue;
 
@@ -531,11 +531,11 @@
 	 *     get my hands on the clown who designed this format...
 	 *                             What we basically assume here
 	 *        is that a NOTE record that doesn't end with a " is
-	 *    followed by some number of continuations, one of which 
+	 *    followed by some number of continuations, one of which
 	 *   will have a " in it.  If this turns out to not be true,
 	 *          well, we'll segmentation fault real soon. We use
 	 * lastwasinote as a semaphore to indicate that the previous
-	 *       record was an unfinished NOTE record.  We clear the	  
+	 *       record was an unfinished NOTE record.  We clear the
 	 *      flag in each of the above record types for potential
 	 *   error recovery, although it really breaks up the beauty
 	 * of the cascading sscanfs.  Dykstra'd love me for this one */
@@ -568,10 +568,10 @@
       fclose(zf);
       return 0;
     }
-    
+
     vaxbyte = strncmp(sampletype, "VAX_", (size_t) 4) == 0 ||
       strncmp(sampletype, "LSB_", (size_t) 4) == 0;
-    
+
   } else if (itype == VICAR) {
     /* we've got a VICAR file.  Let's find out how big the puppy is */
     ungetc(' ', zf);
@@ -582,8 +582,8 @@
 	SetISTR(ISTR_WARNING,"LoadPDS: bad NL in VICAR\n");
 	returnp=TRUE;
       }
-      
-      if (sscanf(tmp," NL = %d",&y) != 1) {
+
+      if (sscanf(tmp," NL = %d",&h) != 1) {
 	SetISTR(ISTR_WARNING,"LoadPDS: bad scan NL in VICAR\n");
 	returnp=TRUE;
       }
@@ -593,7 +593,7 @@
 	returnp=TRUE;
       }
 
-      if (sscanf(tmp, " NS = %d",&x) != 1) {
+      if (sscanf(tmp, " NS = %d",&w) != 1) {
 	SetISTR(ISTR_WARNING,"LoadPDS: bad scan NS in VICAR\n");
 	returnp=TRUE;
       }
@@ -625,6 +625,13 @@
     returnp=TRUE;
   }
 
+  /* samplesize can be arbitrarily large (up to int limit) in non-VICAR files */
+  if (samplesize != 8 && samplesize != 16) {
+    SetISTR(ISTR_WARNING,"LoadPDS: %d bits per pixel not supported",
+      samplesize);
+    returnp=TRUE;
+  }
+
   if (returnp) {
     fclose(zf);
     return 0;
@@ -689,11 +696,19 @@
 
 #ifndef VMS
     sprintf(pdsuncompfname,"%s/xvhuffXXXXXX", tmpdir);
-    mktemp(pdsuncompfname);
-    sprintf(scanbuff,"%s %s - 4 >%s",PDSUNCOMP,fname,pdsuncompfname);
 #else
     strcpy(pdsuncompfname,"sys$disk:[]xvhuffXXXXXX");
+#endif
+
+#ifdef USE_MKSTEMP
+    close(mkstemp(pdsuncompfname));
+#else
     mktemp(pdsuncompfname);
+#endif
+
+#ifndef VMS
+    sprintf(scanbuff,"%s %s - 4 >%s",PDSUNCOMP,fname,pdsuncompfname);
+#else
     sprintf(scanbuff,"%s %s %s 4",PDSUNCOMP,fname,pdsuncompfname);
 #endif
 
@@ -727,63 +742,72 @@
     fread(scanbuff, (size_t) labelsize, (size_t) 1, zf);
   }
 
-  x *= samplesize/8;
+  /* samplesize is bits per pixel; guaranteed at this point to be 8 or 16 */
+  bytewidth = w * (samplesize/8);
+  bufsize = bytewidth * h;
+  if (w <= 0 || h <= 0 || bytewidth/w != (samplesize/8) ||
+      bufsize/bytewidth != h)
+  {
+    SetISTR(ISTR_WARNING,"LoadPDS: image dimensions out of range (%dx%dx%d)",
+      w, h, samplesize/8);
+    fclose(zf);
+    return 0;
+  }
 
-  image = (byte *) malloc((size_t) x*y);
+  image = (byte *) malloc((size_t) bufsize);
   if (image == NULL) {
-    SetISTR(ISTR_WARNING,"LoadPDS: couldn't malloc %d",x*y);
     fclose(zf);
     if (isfixed == FALSE)
       unlink(pdsuncompfname);
-    exit(1);
+    FatalError("LoadPDS: can't malloc image buffer");
   }
 
   if ((lssize || lpsize) &&
        ((itype == PDSFIXED) || (itype == VIKINGFIXED) || (itype == VICAR)) ) {
     /* ARrrrgh.  Some of these images have crud intermixed with the image, */
     /* preventing us from freading in one fell swoop */
-    /* (whatever a fell swoop is */
+    /* (whatever a fell swoop is) */
 
-    for (yy=0; yy<y; yy++) {
-      if (lpsize && 
-	  ((teco=(fread(scanbuff,(size_t) lpsize,(size_t) 1,zf))) != 1)) {
+    for (yy=0; yy<h; yy++) {
+      if (lpsize &&
+	  (teco=fread(scanbuff,(size_t) lpsize,(size_t) 1,zf)) != 1) {
 	SetISTR(ISTR_WARNING, "LoadPDS: unexpected EOF reading prefix");
 	fclose(zf);
 	return 0;
       }
-      
-      if ((teco=(fread(image+(yy*x), (size_t) x, (size_t) 1,zf))) != 1) {
+
+      teco = fread(image+(yy*bytewidth), (size_t) bytewidth, (size_t) 1,zf);
+      if (teco != 1) {
 	SetISTR(ISTR_WARNING, "LoadPDS: unexpected EOF reading line %d",yy);
 	fclose(zf);
 	return 0;
       }
 
-      if (lssize && 
-	  ((teco=(fread(scanbuff,(size_t) lssize,(size_t) 1,zf))) != 1)) {
+      if (lssize &&
+	  (teco=fread(scanbuff,(size_t) lssize,(size_t) 1,zf)) != 1) {
 	SetISTR(ISTR_WARNING, "LoadPDS: unexpected EOF reading suffix");
 	fclose(zf);
 	return 0;
       }
     }
 
-  } else if ((yy=fread(image, (size_t) x*y, (size_t) 1, zf)) != 1) {
+  } else if ((yy=fread(image, (size_t) bytewidth*h, (size_t) 1, zf)) != 1) {
     SetISTR(ISTR_WARNING,"LoadPDS: error reading image data");
     fclose(zf);
     if (itype==PDSVARIABLE || itype==VIKINGVARIABLE)
       unlink(pdsuncompfname);
-
     return 0;
   }
 
-    fclose(zf);
+  fclose(zf);
 
 
   if (isfixed == FALSE)
     unlink(pdsuncompfname);
 
   pinfo->pic = image;
-  pinfo->w   = x;
-  pinfo->h    = y;
+  pinfo->w   = w;   /* true pixel-width now (no longer bytewidth!) */
+  pinfo->h   = h;
 
   if (samplesize == 16)
      if (Convert16BitImage(fname, pinfo,
@@ -798,25 +822,25 @@
   if (pinfo->comment) {
     char tmp[256];
     *(pinfo->comment) = '\0';
-    
+
     sprintf(tmp, "Spacecraft: %-28sTarget: %-32s\n", spacecraft, target);
     strcat(pinfo->comment, tmp);
-    
+
     sprintf(tmp, "Filter: %-32sMission phase: %-24s\n", filtname, mphase);
     strcat(pinfo->comment, tmp);
-    
+
     sprintf(tmp, "Image time: %-28sGain mode: %-29s\n", itime, gainmode);
     strcat(pinfo->comment, tmp);
-    
+
     sprintf(tmp, "Edit mode: %-29sScan mode: %-29s\n", editmode, scanmode);
     strcat(pinfo->comment, tmp);
-    
+
     sprintf(tmp, "Exposure: %-30sShutter mode: %-25s\n", exposure,shuttermode);
     strcat(pinfo->comment, tmp);
-    
+
     sprintf(tmp, "Instrument: %-28sImage time: %-28s\n", iname, itime);
     strcat(pinfo->comment, tmp);
-    
+
     sprintf(tmp, "Image Note: %-28s", inote);
     strcat(pinfo->comment, tmp);
   }
@@ -868,23 +892,20 @@
   m = 65536 * sizeof(byte);
   lut = (byte *) malloc(m);
   if (lut == NULL) {
-    SetISTR(ISTR_WARNING,"LoadPDS: couldn't malloc %d", m);
-    return 0;
+    FatalError("LoadPDS: can't malloc LUT buffer");
   }
-  pinfo->w /= 2;
 
   /* allocate histogram table */
   m = 65536 * sizeof(long);
   hist = (long *) malloc(m);
   if (hist == NULL) {
-    SetISTR(ISTR_WARNING,"LoadPDS: couldn't malloc %d", m);
     free(lut);
-    return 0;
+    FatalError("LoadPDS: can't malloc histogram buffer");
   }
 
   /* check whether histogram file exists */
 #ifdef VMS
-  c = (char *) rindex(strcpy(name, 
+  c = (char *) rindex(strcpy(name,
 			     (c = (char *) rindex(fname, ':')) ? c+1 : fname),
 		      ']');
 #else
@@ -947,14 +968,20 @@
     }
   }
 
-  /* allocate new 8-bit image */
   free(hist);
+
+  /* allocate new 8-bit image */
   n = pinfo->w * pinfo->h;
+  if (pinfo->w <= 0 || pinfo->h <= 0 || n/pinfo->w != pinfo->h) {
+    SetISTR(ISTR_WARNING,"LoadPDS: image dimensions out of range (%dx%d)",
+      pinfo->w, pinfo->h);
+    free(lut);
+    return 0;
+  }
   pPix8 = (byte *)malloc(n*sizeof(byte));
   if (pPix8 == NULL) {
-    SetISTR(ISTR_WARNING,"LoadPDS: couldn't malloc %d", n*sizeof(byte));
     free(lut);
-    return 0;
+    FatalError("LoadPDS: can't malloc 16-to-8-bit conversion buffer");
   }
 
   /* convert the 16-bit image to 8-bit */
@@ -979,16 +1006,16 @@
   FILE    *fp;
   char    name[1024], buf[256], *c;
   int     i, n, r, g, b;
-  
+
 #ifdef VMS
-  c = (char *) rindex(strcpy(name, 
+  c = (char *) rindex(strcpy(name,
 			     (c = (char *) rindex(fname, ':')) ? c+1 : fname),
 		      ']');
 #else
   c = (char *) rindex(strcpy(name, fname), '/');
 #endif /* VMS */
   (void)strcpy(c ? c+1 : name, "palette.tab");
-  
+
   if ((fp = xv_fopen(name, "r")) == NULL)
     return 0;
   for (i = 0; i < 256; i++) {
@@ -1014,7 +1041,3 @@
 
 
 #endif /* HAVE_PDS */
-
-
-
-
diff -ruN xv-3.10a/xvpictoppm.c xv-3.10a-bugfixes/xvpictoppm.c
--- xv-3.10a/xvpictoppm.c	1995-01-13 11:57:14.000000000 -0800
+++ xv-3.10a-bugfixes/xvpictoppm.c	2005-04-10 09:36:04.000000000 -0700
@@ -77,7 +77,7 @@
   FILE *fp;
   byte  *icon8, *pic24, *ip, *pp;
   char  buf[256];
-  int   i, builtin, w, h, mv;
+  int   i, builtin, w, h, maxval, npixels, p24sz;
 
   fp = stdin;
   builtin = 0;
@@ -88,42 +88,45 @@
   /* read comments until we see '#END_OF_COMMENTS', or hit EOF */
   while (1) {
     if (!fgets(buf, 256, fp)) errexit();
-    
+
     if (!strncmp(buf, "#END_OF_COMMENTS", (size_t) 16)) break;
 
     else if (!strncmp(buf, "#BUILTIN:",   (size_t)  9)) {
       builtin = 1;
-      fprintf(stderr,"Built-In icon:  no image to convert!\n");
+      fprintf(stderr, "Built-in icon:  no image to convert\n");
       exit(1);
     }
   }
 
 
   /* read width, height, maxval */
-  if (!fgets(buf, 256, fp) || sscanf(buf, "%d %d %d", &w, &h, &mv) != 3) 
+  if (!fgets(buf, 256, fp) || sscanf(buf, "%d %d %d", &w, &h, &maxval) != 3)
     errexit();
 
+  npixels = w * h;
+  p24sz = 3 * npixels;
 
-  if (w<1 || h<1 || mv != 255) {
-    fprintf(stderr,"Bogus thumbnail file!\n");
+  if (w <= 0 || h <= 0 || maxval != 255 || npixels/w != h || p24sz/3 != npixels)
+  {
+    fprintf(stderr, "Thumbnail dimensions out of range\n");
     exit(1);
   }
 
 
   /* read binary data */
-  icon8 = (byte *) malloc((size_t) w * h);
+  icon8 = (byte *) malloc((size_t) npixels);
   if (!icon8) errexit();
 
-  i = fread(icon8, (size_t) 1, (size_t) w*h, fp);
-  if (i != w*h) errexit();
+  i = fread(icon8, (size_t) 1, (size_t) npixels, fp);
+  if (i != npixels) errexit();
+
 
-  
   /* make 24-bit version of icon */
-  pic24 = (byte *) malloc((size_t) w * h * 3);
+  pic24 = (byte *) malloc((size_t) p24sz);
   if (!pic24) errexit();
 
   /* convert icon from 332 to 24-bit image */
-  for (i=0, ip=icon8, pp=pic24;  i<w*h;  i++, ip++, pp+=3) {
+  for (i=0, ip=icon8, pp=pic24;  i<npixels;  i++, ip++, pp+=3) {
     pp[0] = ( ((int) ((*ip >> 5) & 0x07)) * 255) / 7;
     pp[1] = ( ((int) ((*ip >> 2) & 0x07)) * 255) / 7;
     pp[2] = ( ((int) ((*ip >> 0) & 0x03)) * 255) / 3;
@@ -160,10 +163,3 @@
 
   if (ferror(fp)) errexit();
 }
-
-
-	  
-	  
-
-
-
diff -ruN xv-3.10a/xvpm.c xv-3.10a-bugfixes/xvpm.c
--- xv-3.10a/xvpm.c	1994-12-22 14:34:40.000000000 -0800
+++ xv-3.10a-bugfixes/xvpm.c	2005-03-29 08:30:12.000000000 -0800
@@ -60,7 +60,7 @@
 
   FILE  *fp;
   byte  *pic8;
-  int    isize,i,flipit,w,h;
+  int    isize,i,flipit,w,h,npixels,nRGBbytes;
   char  *bname;
 
   bname = BaseName(fname);
@@ -103,10 +103,11 @@
     thePic.pm_cmtsize = flip4(thePic.pm_cmtsize);
     }
 
-  w = thePic.pm_ncol;  h = thePic.pm_nrow;
+  w = thePic.pm_ncol;
+  h = thePic.pm_nrow;
 
   /* make sure that the input picture can be dealt with */
-  if ( thePic.pm_nband!=1 || 
+  if ( thePic.pm_nband!=1 ||
       (thePic.pm_form!=PM_I && thePic.pm_form!=PM_C) ||
       (thePic.pm_form==PM_I && thePic.pm_np>1) ||
       (thePic.pm_form==PM_C && (thePic.pm_np==2 || thePic.pm_np>4)) ) {
@@ -114,20 +115,27 @@
     fprintf(stderr,"(ie, 1-plane PM_I, or 1-, 3-, or 4-plane PM_C)\n");
 
     return pmError(bname, "PM file in unsupported format");
-  }	
+  }
 
 
   isize = pm_isize(&thePic);
+  npixels = w*h;
+  nRGBbytes = 3*npixels;
+
+  /* make sure image is more-or-less valid (and no overflows) */
+  if (isize <= 0 || w <= 0 || h <= 0 || npixels/w < h ||
+      nRGBbytes/3 < npixels || thePic.pm_cmtsize < 0)
+    return pmError(bname, "Bogus PM file!!");
 
-  if (DEBUG) 
+  if (DEBUG)
     fprintf(stderr,"%s: LoadPM() - loading a %dx%d %s pic, %d planes\n",
-	    cmd, w, h, (thePic.pm_form==PM_I) ? "PM_I" : "PM_C", 
+	    cmd, w, h, (thePic.pm_form==PM_I) ? "PM_I" : "PM_C",
 	    thePic.pm_np);
 
-	      
+
   /* allocate memory for picture and read it in */
   thePic.pm_image = (char *) malloc((size_t) isize);
-  if (thePic.pm_image == NULL) 
+  if (thePic.pm_image == NULL)
     return( pmError(bname, "unable to malloc PM picture") );
 
   if (fread(thePic.pm_image, (size_t) isize, (size_t) 1, fp) != 1)   {
@@ -147,7 +155,7 @@
       }
     }
   }
-   
+
   fclose(fp);
 
 
@@ -155,11 +163,11 @@
     int  *intptr;
     byte *pic24, *picptr;
 
-    if ((pic24 = (byte *) malloc((size_t) w*h*3))==NULL) {
+    if ((pic24 = (byte *) malloc((size_t) nRGBbytes))==NULL) {
       if (thePic.pm_cmt) free(thePic.pm_cmt);
       return( pmError(bname, "unable to malloc 24-bit picture") );
     }
-      
+
     intptr = (int *) thePic.pm_image;
     picptr = pic24;
 
@@ -190,7 +198,7 @@
   else if (thePic.pm_form == PM_C && thePic.pm_np>1) {
     byte *pic24, *picptr, *rptr, *gptr, *bptr;
 
-    if ((pic24 = (byte *) malloc((size_t) w*h*3))==NULL) {
+    if ((pic24 = (byte *) malloc((size_t) nRGBbytes))==NULL) {
       if (thePic.pm_cmt) free(thePic.pm_cmt);
       return( pmError(bname, "unable to malloc 24-bit picture") );
     }
@@ -210,12 +218,12 @@
     pinfo->pic  = pic24;
     pinfo->type = PIC24;
   }
-  
+
 
   else if (thePic.pm_form == PM_C && thePic.pm_np==1) {
     /* don't have to convert, just point pic at thePic.pm_image */
     pic8 = (byte *) thePic.pm_image;
-    for (i=0; i<256; i++) 
+    for (i=0; i<256; i++)
       pinfo->r[i] = pinfo->g[i] = pinfo->b[i] = i;  /* build mono cmap */
 
     pinfo->pic  = pic8;
@@ -228,10 +236,10 @@
   pinfo->normw = pinfo->w;   pinfo->normh = pinfo->h;
 
   pinfo->frmType = F_PM;
-  pinfo->colType = (thePic.pm_form==PM_I || thePic.pm_np>1) 
+  pinfo->colType = (thePic.pm_form==PM_I || thePic.pm_np>1)
                          ? F_FULLCOLOR : F_GREYSCALE;
-  sprintf(pinfo->fullInfo,"PM, %s.  (%d plane %s)  (%ld bytes)",
-	  (thePic.pm_form==PM_I || thePic.pm_np>1) 
+  sprintf(pinfo->fullInfo,"PM, %s.  (%d plane %s)  (%d bytes)",
+	  (thePic.pm_form==PM_I || thePic.pm_np>1)
 	        ? "24-bit color" : "8-bit greyscale",
 	  thePic.pm_np, (thePic.pm_form==PM_I) ? "PM_I" : "PM_C",
 	  isize + PM_IOHDR_SIZE + thePic.pm_cmtsize);
@@ -313,7 +321,7 @@
 
   else if (colorstyle == 1) {    /* GreyScale: 8 bits per pixel */
     byte rgb[256];
-    
+
     if (ptype == PIC8) {
       for (i=0; i<numcols; i++) rgb[i] = MONO(rmap[i],gmap[i],bmap[i]);
       for (i=0, p=pic; i<w*h; i++, p++) {
diff -ruN xv-3.10a/xvpopup.c xv-3.10a-bugfixes/xvpopup.c
--- xv-3.10a/xvpopup.c	1995-01-19 10:09:31.000000000 -0800
+++ xv-3.10a-bugfixes/xvpopup.c	2004-05-16 18:04:13.000000000 -0700
@@ -1,5 +1,5 @@
-/* 
- * xvpopup.c - popup "Are you sure?  Yes/No/Maybe" sort of dialog box
+/*
+ * xvpopup.c - pop up "Are you sure?  Yes/No/Maybe" sort of dialog box
  *
  * callable functions:
  *
@@ -20,7 +20,8 @@
 
 #include "xv.h"
 
-#include "bits/icon"
+#define OMIT_ICON_BITS
+#include "bits/icon"   /* icon_bits[] not used, but icon_width/height are */
 
 #define PUWIDE 400
 #define PUHIGH 170
@@ -86,8 +87,8 @@
 static char  *padMthdNames[] = { "Solid Fill", "Run 'bggen'", "Load Image" };
 
 static int    padColDefLen = 9;
-static char  *padColDefNames[] = { "black", "red",  "yellow", "green", 
-				   "cyan",  "blue", "magenta", "white", 
+static char  *padColDefNames[] = { "black", "red",  "yellow", "green",
+				   "cyan",  "blue", "magenta", "white",
 				   "50% gray" };
 
 static char  *padColDefVals[]  = { "black", "red", "yellow", "green",
@@ -105,8 +106,8 @@
   "Red Balls",
   "Red+Yellow Diamonds" };
 
-static char  *padBgDefVals[]  = { 
-  "black white", 
+static char  *padBgDefVals[]  = {
+  "black white",
   "100 100 255  50 50 150",
   "red green blue",
   "black red yellow green blue purple black",
@@ -150,11 +151,11 @@
     if (wy + h > dispHIGH) wy = dispHIGH - h;
   }
 
-  
+
   if (winCtrPosKludge) {
     wx -= (p_offx + ch_offx);
     wy -= (p_offy + ch_offy);
-  } 
+  }
   else {
     wx -= (ch_offx);
     wy -= (ch_offy);
@@ -197,7 +198,7 @@
   /* attach controls to popW, now that it exists */
   if      (poptyp==ISGRAB) ahideCB.win = popW;
   else if (poptyp == ISPAD) {
-    
+
     if (!padHaveDooDads) {
       DCreate(&padWDial, popW, 16,      puhigh-16-100-1,75,100,
 	      1, 2048, pWIDE, 10,
@@ -230,8 +231,8 @@
     XMapWindow(theDisp, padWDial.win);
     XMapWindow(theDisp, padHDial.win);
     XMapWindow(theDisp, padODial.win);
-  }      
-  
+  }
+
 
   XResizeWindow(theDisp, popW, (u_int) puwide, (u_int) puhigh);
   XStoreName   (theDisp, popW, wname);
@@ -257,9 +258,9 @@
   }
   else if (poptyp == ISPAD) {
     BTSetActive(&bts[0], (int) strlen(gsBuf));
-    i = pWIDE * 3;  RANGE(i,2048,9999);  
+    i = pWIDE * 3;  RANGE(i,2048,9999);
     DSetRange(&padWDial, 1, i, padWDial.val, 10);
-    i = pHIGH * 3;  RANGE(i,2048,9999);  
+    i = pHIGH * 3;  RANGE(i,2048,9999);
     DSetRange(&padHDial, 1, i, padHDial.val, 10);
 
     DSetActive(&padWDial, (padMode!=PAD_LOAD));  /* DSetRange activates dial */
@@ -283,14 +284,14 @@
     }
   }
 
-  /* center first button in window around mouse position, with constraint that 
+  /* center first button in window around mouse position, with constraint that
      window be fully on the screen */
 
   CenterMapWindow(popW, 40 + bts[0].x, BUTTH/2 + bts[0].y, puwide, puhigh);
   popUp = poptyp;
 
   /* MUST wait for VisibilityNotify event to come in, else we run the risk
-     of UnMapping the window *before* the Map request completed.  This 
+     of UnMapping the window *before* the Map request completed.  This
      appears to be bad, (It leaves an empty window frame up.) though it
      generally only happens on slow servers.  Better safe than screwed... */
 
@@ -338,10 +339,10 @@
      button labels have 1-character accellerators at the front, same
      as in PopUp().  Note that it would be suboptimal to make any
      of the 1-character accellerators be the same character as one of
-     the edit-text command keys 
+     the edit-text command keys
 
      Also note that the filter string should only contain normal printable
-     characters (' ' through '\177'), as ctrl chars are pre-filtered 
+     characters (' ' through '\177'), as ctrl chars are pre-filtered
      (ie, interpreted as emacs-like commands) */
 
   gsBuf = buf;        gsBufLen = buflen;
@@ -358,7 +359,7 @@
     gsy = PUHIGH - 10 - BUTTH - 10 - gsh - 20;
 
   gsw = PUWIDE - gsx - 10;
-  
+
   changedGSBuf();      /* careful!  popW doesn't exist yet! */
 
   return doPopUp(txt, labels, n, ISGETSTR, "xv prompt");
@@ -390,7 +391,7 @@
   changedGSBuf();      /* careful!  popW doesn't exist yet! */
 
   /* window value gets filled in in doPopUp() */
-  CBCreate(&ahideCB, (Window) NULL, 
+  CBCreate(&ahideCB, (Window) NULL,
 	   PUWIDE-10-18-StringWidth(HIDESTR),
 	   gsy+2, HIDESTR, infofg, infobg, hicol, locol);
   ahideCB.val = *pHide;
@@ -464,8 +465,8 @@
 
   changedGSBuf();      /* careful!  popW doesn't exist yet! */
 
-  if (padHaveDooDads) { 
-    oldW = padWDial.val;  
+  if (padHaveDooDads) {
+    oldW = padWDial.val;
     oldH = padHDial.val;
     oldO = padODial.val;
   }
@@ -496,8 +497,8 @@
   XUnmapWindow(theDisp, padODial.win);
 
   /* load up return values */
-  *pMode   = padMode;  
-  *pStr    = padBuf;  
+  *pMode   = padMode;
+  *pStr    = padBuf;
   *pWide   = padWDial.val;
   *pHigh   = padHDial.val;
   *pOpaque = padODial.val;
@@ -513,8 +514,6 @@
   /* generates padCol* and padBg* lists used in 'Defaults' MBUTT.  Grabs
      all the X resources values it can, and adds appropriate defaults */
 
-  int  i;
-
   rd_str_cl("foo", "", 1);                    /* rebuild database */
 
   build1PadList("color", padColVals, padColNames, &padColLen,
@@ -526,15 +525,15 @@
   build1PadList("load", padLoadVals, padLoadNames, &padLoadLen,
 		(char **) NULL, (char **) NULL, 0);
 }
-	
-      
+
+
 /***************************************************/
 static void build1PadList(typstr, vals, nams, lenp, dvals, dnams, dlen)
      char *typstr, **vals, **nams, **dvals, **dnams;
      int  *lenp, dlen;
 {
   int i;
-  char resname[128], name[256], value[256];
+  char resname[128];
 
   for (i=0; i<*lenp; i++) {   /* kill old lists */
     free(nams[i]);
@@ -548,7 +547,7 @@
       vals[*lenp] = (char *) malloc(strlen(def_str)+1);
       if (!vals[*lenp]) continue;
       strcpy(vals[*lenp], def_str);
-      
+
       sprintf(resname, "pad.%s.name%d", typstr, i);
       if (rd_str_cl(resname, "Dialog.Menu.Slot",0)) {  /* and it has a name! */
 	nams[*lenp] = (char *) malloc(strlen(def_str)+1);
@@ -560,13 +559,14 @@
 	nams[*lenp] = (char *) malloc((size_t) 32);
 	if (!nams[*lenp]) { free(vals[*lenp]); continue; }
 	strncpy(nams[*lenp], vals[*lenp], (size_t) 31);
+	nams[*lenp][31] = '\0';
       }
-      
+
       if (strlen(nams[*lenp]) > (size_t) 20) {   /* fix long names */
 	char *sp = nams[*lenp] + 18;
 	*sp++ = '.';  *sp++ = '.';  *sp++ = '.';  *sp++ = '\0';
       }
-	
+
       *lenp = (*lenp) + 1;
     }
   }
@@ -583,7 +583,7 @@
     strcpy(nams[*lenp], dnams[i]);
     *lenp = (*lenp) + 1;
   }
-}    
+}
 
 
 
@@ -605,7 +605,7 @@
 void OpenAlert(txt)
      char *txt;
 {
-  /* pops up a window with txt displayed in it (*no buttons*).  
+  /* pops up a window with txt displayed in it (*no buttons*).
      returns immediately.  window is closed by 'CloseAlert()'.
      No 'PopUp()' calls are allowed while an Alert is displayed. */
 
@@ -624,14 +624,14 @@
   puwide = PUWIDE;  puhigh = PUHIGH;
   XResizeWindow(theDisp, popW, (u_int) puwide, (u_int) puhigh);
 
-  /* center last button in window around mouse position, with constraint that 
+  /* center last button in window around mouse position, with constraint that
      window be fully on the screen */
 
   CenterMapWindow(popW, puwide/2, puhigh/2, puwide, puhigh);
   popUp = ISALERT;
 
   /* MUST wait for VisibilityNotify event to come in, else we run the risk
-     of UnMapping the window *before* the Map request completed.  This 
+     of UnMapping the window *before* the Map request completed.  This
      appears to be bad, (It leaves an empty window frame up.) though it
      generally only happens on slow servers.  Better safe than screwed... */
 
@@ -695,7 +695,7 @@
     XKeyEvent *e = (XKeyEvent *) xev;
     char buf[128];  KeySym ks;
     int stlen, i, shift, ck;
-	
+
     stlen = XLookupString(e,buf,128,&ks,(XComposeStatus *) NULL);
     shift = e->state & ShiftMask;
     ck = CursorKey(ks, shift, 0);
@@ -725,7 +725,7 @@
 	rv = 1;
       }
 
-      if (!rv && (popUp==ISGETSTR || popUp==ISGRAB || popUp==ISPAD)) { 
+      if (!rv && (popUp==ISGETSTR || popUp==ISGRAB || popUp==ISPAD)) {
 	if (e->window == popW) { doGetStrKey(buf[0]);  rv = 1; }
       }
     }
@@ -775,10 +775,10 @@
   int   i, inbreak, lineno, top, hardcr, maxln, len[TR_MAXLN];
 
   XSetForeground(theDisp, theGC, fg);
-  
+
   sp = txt;  lineno = hardcr = 0;
 
-  maxln = h / LINEHIGH;  
+  maxln = h / LINEHIGH;
   RANGE(maxln,0,TR_MAXLN);
   while (*sp && lineno<maxln) {
 
@@ -797,7 +797,7 @@
     while (XTextWidth(mfinfo, sp, (int)(ep-sp))<= w && *ep && *ep!='\n') ep++;
     if (*ep=='\n') { ep++;  hardcr=1; }   /* eat newline */
 
-    /* if we got too wide, back off until we find a break position 
+    /* if we got too wide, back off until we find a break position
        (last char before a space or a '/') */
 
     if (XTextWidth(mfinfo, sp, (int)(ep-sp)) > w) {
@@ -812,7 +812,7 @@
     }
 
     start[lineno] = sp;  len[lineno] = ep-sp;
-    
+
     /* make sure we don't print a trailing '\n' character! */
     if (len[lineno] > 0) {
       while (sp[len[lineno]-1] == '\n') len[lineno] = len[lineno] - 1;
@@ -835,7 +835,7 @@
 /***************************************************/
 static void createPUD()
 {
-  popW = CreateWindow("xv confirm", "XVconfirm", "+0+0", 
+  popW = CreateWindow("xv confirm", "XVconfirm", "+0+0",
 		      PUWIDE, PUHIGH, infofg, infobg, 0);
   if (!popW) FatalError("can't create popup window!");
 
@@ -847,7 +847,7 @@
   bts = (BUTT *) NULL;
   nbts = selected = firsttime = 0;
 }
-  
+
 
 /***************************************************/
 static void attachPUD()
@@ -913,24 +913,24 @@
       XDrawLine(theDisp, popW, theGC, 16+1+75+75+5, puhigh-140 + 6+8,
 		16+1+75+75+5, puhigh-10-4);
     }
-      
+
 
     XSetForeground(theDisp, theGC, infofg);
-    XDrawRectangle(theDisp, popW, theGC, 268, puhigh-140, 
+    XDrawRectangle(theDisp, popW, theGC, 268, puhigh-140,
 		   (u_int) puwide - 10 - 268, 130-BUTTH-10);
-    Draw3dRect(popW, 268+1, puhigh-140+1, (u_int) puwide -10-268-2, 
+    Draw3dRect(popW, 268+1, puhigh-140+1, (u_int) puwide -10-268-2,
 	       130-2 - BUTTH-10, R3D_IN,2,hicol,locol,infobg);
-    
-    TextRect(popW,padInst,268+5, puhigh-140+3, puwide-10-268-10, 
+
+    TextRect(popW,padInst,268+5, puhigh-140+3, puwide-10-268-10,
 	     130-6 - BUTTH-10, infofg);
   }
 
   else {
     XCopyPlane(theDisp, iconPix, popW, theGC, 0,0, icon_width, icon_height,
 	       10,10+(puhigh-30-BUTTH-icon_height)/2, 1L);
-    
+
     xt = 10+icon_width+20;  yt = 10;
-    
+
     if (popUp == ISGETSTR) {
       TextRect(popW, text, xt, yt, puwide-10-xt, gsy-20, infofg);
       drawGSBuf();
@@ -947,22 +947,22 @@
 /***************************************************/
 static void drawPadOMStr()
 {
-  CenterString(popW, padODial.x + (padODial.w - 13)/2, 
+  CenterString(popW, padODial.x + (padODial.w - 13)/2,
 	       puhigh-16-100-12, padOMStr[padOMode]);
 }
-  
+
 /***************************************************/
 static void clickPUD(x,y)
      int x,y;
 {
   int i;
   BUTT *bp;
-  
+
   for (i=0; i<nbts; i++) {
     bp = &bts[i];
     if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h)) break;
   }
-  
+
   if (i<nbts && BTTrack(bp)) {
     popUp = 0;  selected = i;  return;
   }
@@ -1017,11 +1017,11 @@
       gsCurPos = strlen(gsBuf);
       gsStPos = gsEnPos = 0;
       changedGSBuf();
-      if (ctrlColor) 
-	XClearArea(theDisp, popW, gsx+3,gsy+3, 
+      if (ctrlColor)
+	XClearArea(theDisp, popW, gsx+3,gsy+3,
 		   (u_int)gsw-5, (u_int)gsh-5, False);
       else
-	XClearArea(theDisp, popW, gsx+1,gsy+1, 
+	XClearArea(theDisp, popW, gsx+1,gsy+1,
 		   (u_int)gsw-1, (u_int)gsh-1, False);
       drawGSBuf();
 
@@ -1032,7 +1032,7 @@
       DSetActive (&padWDial,  (i!=PAD_LOAD));
       DSetActive (&padHDial,  (i!=PAD_LOAD));
 
-      XClearArea(theDisp, popW, 184+5, puhigh-140+3, 
+      XClearArea(theDisp, popW, 184+5, puhigh-140+3,
 		 (u_int) puwide-10-184-10, 130-6 - BUTTH-10, True);
 
       padMode = i;
@@ -1049,11 +1049,11 @@
       gsCurPos = strlen(gsBuf);
       gsStPos = gsEnPos = 0;
       changedGSBuf();
-      if (ctrlColor) 
-	XClearArea(theDisp, popW, gsx+3,gsy+3, 
+      if (ctrlColor)
+	XClearArea(theDisp, popW, gsx+3,gsy+3,
 		   (u_int)gsw-5, (u_int)gsh-5, False);
       else
-	XClearArea(theDisp, popW, gsx+1,gsy+1, 
+	XClearArea(theDisp, popW, gsx+1,gsy+1,
 		   (u_int)gsw-1, (u_int)gsh-1, False);
       drawGSBuf();
 
@@ -1079,8 +1079,8 @@
   /* handle characters typed at GetStrPopUp window.  Button accel. keys
      have already been checked for elsewhere.  Practical upshot is that
      we don't have to do anything with ESC or Return (as these will normally
-     be Cancel and Ok buttons) 
- 
+     be Cancel and Ok buttons)
+
      Normally returns '0'.  Returns '1' if character wasn't accepted, for
      whatever reason. */
 
@@ -1089,7 +1089,7 @@
   len = strlen(gsBuf);
   if (gsFilter) flen = strlen(gsFilter);
            else flen = 0;
-  
+
 
   if (c>=' ' && c<'\177') {              /* 'NORMAL' CHARACTERS */
     if (flen) {                          /* check filter string */
@@ -1097,7 +1097,7 @@
       if (!gsAllow && i< flen) return 1;    /* found in 'disallow' filter */
       if ( gsAllow && i==flen) return 1;    /* not found in 'allow' filter */
     }
-    
+
     if (len >= gsBufLen-1) return 1;     /* at max length */
 
     xvbcopy(&gsBuf[gsCurPos], &gsBuf[gsCurPos+1], (size_t) len-gsCurPos+1);
@@ -1147,7 +1147,7 @@
 
   changedGSBuf();      /* compute gsEnPos, gsStPos */
 
-  if (ctrlColor) 
+  if (ctrlColor)
     XClearArea(theDisp, popW, gsx+3,gsy+3, (u_int)gsw-5, (u_int)gsh-5, False);
   else
     XClearArea(theDisp, popW, gsx+1,gsy+1, (u_int)gsw-1, (u_int)gsh-1, False);
@@ -1175,7 +1175,7 @@
 /***************************************************/
 static void changedGSBuf()
 {
-  /* cursor position (or whatever) may have changed.  adjust displayed 
+  /* cursor position (or whatever) may have changed.  adjust displayed
      portion of gsBuf */
 
   int len;
@@ -1212,7 +1212,7 @@
 
   XSetForeground(theDisp, theGC, infofg);
   XDrawRectangle(theDisp, popW, theGC, gsx, gsy, (u_int) gsw, (u_int) gsh);
-  Draw3dRect(popW, gsx+1, gsy+1, (u_int) gsw-2, (u_int) gsh-2, 
+  Draw3dRect(popW, gsx+1, gsy+1, (u_int) gsw-2, (u_int) gsh-2,
 	     R3D_IN, 2, hicol,locol,infobg);
 
   XSetForeground(theDisp, theGC, infofg);
diff -ruN xv-3.10a/xvps.c xv-3.10a-bugfixes/xvps.c
--- xv-3.10a/xvps.c	1994-12-22 14:34:42.000000000 -0800
+++ xv-3.10a-bugfixes/xvps.c	2005-03-30 08:18:17.000000000 -0800
@@ -1,4 +1,4 @@
-/* 
+/*
  * xvps.c - Postscript dialog box, file output functions
  *
  * callable functions:
@@ -71,10 +71,13 @@
 static void psColorImage   PARM((FILE *));
 static void psColorMap     PARM((FILE *fp, int, int, byte *, byte *, byte *));
 static void psRleCmapImage PARM((FILE *, int));
-static void epsPreview     PARM((FILE *, byte *, int, int, int, int, 
+static void epsPreview     PARM((FILE *, byte *, int, int, int, int,
 				 byte *, byte *, byte *, int));
 static int  writeBWStip    PARM((FILE *, byte *, char *, int, int, int));
 
+#ifdef GS_PATH
+static void buildCmdStr    PARM((char *, char *, char *, int, int));
+#endif
 
 
 /* local variables */
@@ -123,7 +126,7 @@
 void CreatePSD(geom)
 char *geom;
 {
-  psW = CreateWindow("xv postscript", "XVps", geom, 
+  psW = CreateWindow("xv postscript", "XVps", geom,
 		     PSWIDE, PSHIGH, infofg, infobg, 0);
   if (!psW) FatalError("can't create postscript window!");
 
@@ -139,9 +142,9 @@
   CBCreate(&encapsCB, psW, 240, 7, "preview", infofg, infobg, hicol, locol);
   CBCreate(&pscompCB, psW, 331, 7, "compress", infofg, infobg, hicol, locol);
 
-  DCreate(&xsDial, psW, 240, 30, 80, 100, 10, 800, 100, 5, 
+  DCreate(&xsDial, psW, 240, 30, 80, 100, 10, 800, 100, 5,
 	  infofg, infobg, hicol, locol, "Width", "%");
-  DCreate(&ysDial, psW, 331, 30, 80, 100, 10, 800, 100, 5, 
+  DCreate(&ysDial, psW, 331, 30, 80, 100, 10, 800, 100, 5,
 	  infofg, infobg, hicol, locol, "Height", "%");
   xsDial.drawobj = changedScale;
   ysDial.drawobj = changedScale;
@@ -154,38 +157,38 @@
   RBCreate(orientRB, psW, 36+80, 240+18, "Landscape", infofg, infobg,
 	   hicol, locol);
 
-  paperRB = RBCreate(NULL, psW,36, 240+18+36, "8.5\"x11\"", 
+  paperRB = RBCreate(NULL, psW,36, 240+18+36, "8.5\"x11\"",
 		     infofg, infobg, hicol, locol);
   RBCreate(paperRB, psW, 36+80,    240+18+36, "A4",
 	   infofg, infobg, hicol, locol);
-  RBCreate(paperRB, psW, 36+122,   240+18+36, "B5",         
+  RBCreate(paperRB, psW, 36+122,   240+18+36, "B5",
 	   infofg, infobg, hicol, locol);
-  RBCreate(paperRB, psW, 36+164,   240+18+36, "A3",         
+  RBCreate(paperRB, psW, 36+164,   240+18+36, "A3",
 	   infofg, infobg, hicol, locol);
   RBCreate(paperRB, psW, 36,       240+36+36, "8.5\"x14\"",
 	   infofg, infobg, hicol, locol);
-  RBCreate(paperRB, psW, 36+80,    240+36+36, "11\"x17\"",  
+  RBCreate(paperRB, psW, 36+80,    240+36+36, "11\"x17\"",
 	   infofg, infobg, hicol, locol);
-  RBCreate(paperRB, psW, 36,       240+54+36, "4\"x5\"",    
+  RBCreate(paperRB, psW, 36,       240+54+36, "4\"x5\"",
 	   infofg, infobg, hicol, locol);
-  RBCreate(paperRB, psW, 36+80,    240+54+36, "35mm slide", 
+  RBCreate(paperRB, psW, 36+80,    240+54+36, "35mm slide",
 	   infofg, infobg, hicol, locol);
 
-  BTCreate(&psbut[PS_BOK], psW, PSWIDE-180, PSHIGH-10-BUTTH, 80, BUTTH, 
+  BTCreate(&psbut[PS_BOK], psW, PSWIDE-180, PSHIGH-10-BUTTH, 80, BUTTH,
 	   "Ok", infofg, infobg, hicol, locol);
-  BTCreate(&psbut[PS_BCANC], psW, PSWIDE-90, PSHIGH-10-BUTTH, 80, BUTTH, 
+  BTCreate(&psbut[PS_BCANC], psW, PSWIDE-90, PSHIGH-10-BUTTH, 80, BUTTH,
 	   "Cancel", infofg, infobg, hicol, locol);
 
-  BTCreate(&psbut[PS_BCENT], psW, 240, 154, 55, BUTTH-2, 
+  BTCreate(&psbut[PS_BCENT], psW, 240, 154, 55, BUTTH-2,
 	   "Center", infofg, infobg, hicol, locol);
-  BTCreate(&psbut[PS_BORG], psW,  298, 154, 55, BUTTH-2, 
+  BTCreate(&psbut[PS_BORG], psW,  298, 154, 55, BUTTH-2,
 	   "Origin", infofg, infobg, hicol, locol);
-  BTCreate(&psbut[PS_BMAX], psW,  356, 154, 55, BUTTH-2, 
+  BTCreate(&psbut[PS_BMAX], psW,  356, 154, 55, BUTTH-2,
 	   "Max",    infofg, infobg, hicol, locol);
 
-  BTCreate(&psbut[PS_BPOSX], psW, 256-14, 190+13-8, 8,8, "", 
+  BTCreate(&psbut[PS_BPOSX], psW, 256-14, 190+13-8, 8,8, "",
 	   infofg, infobg, hicol, locol);
-  BTCreate(&psbut[PS_BPOSY], psW, 256-14, 190+26-8, 8,8, "", 
+  BTCreate(&psbut[PS_BPOSY], psW, 256-14, 190+26-8, 8,8, "",
 	   infofg, infobg, hicol, locol);
 
   posxType = posyType = 0;
@@ -246,7 +249,7 @@
 
   XMapSubwindows(theDisp, psW);
 }
-  
+
 
 /***************************************************/
 void PSDialog(vis)
@@ -289,7 +292,7 @@
     x = e->x;  y = e->y;  w = e->width;  h = e->height;
 
     /* throw away excess expose events for 'dumb' windows */
-    if (e->count > 0 && 
+    if (e->count > 0 &&
 	(e->window == xsDial.win || e->window == ysDial.win ||
 	 e->window == pageF)) {}
 
@@ -332,7 +335,7 @@
     XKeyEvent *e = (XKeyEvent *) xev;
     char buf[128];  KeySym ks;
     int  stlen, shift, ck;
-	
+
     stlen = XLookupString(e,buf,128,&ks,(XComposeStatus *) NULL);
     shift = e->state & ShiftMask;
     ck    = CursorKey(ks, shift, 0);
@@ -497,7 +500,7 @@
   XSetFont(theDisp, theGC, mfont);
 }
 
-  
+
 /***************************************************/
 static void drawSizeStr()
 {
@@ -522,7 +525,7 @@
   XSetFont(theDisp, theGC, mfont);
 }
 
-  
+
 /***************************************************/
 static void drawResStr()
 {
@@ -540,9 +543,9 @@
   XSetFont(theDisp, theGC, mfont);
 }
 
-  
-  
-  
+
+
+
 /***************************************************/
 static void drawPage()
 {
@@ -554,7 +557,7 @@
   XSetForeground(theDisp, theGC, infofg);
   XDrawRectangle(theDisp, pageF, theGC, pageRect.x, pageRect.y,
 		 (u_int) pageRect.width, (u_int) pageRect.height);
-  
+
   drawIRect(1);
 }
 
@@ -611,7 +614,7 @@
   unsigned int mask;
   double       offx, offy, newx, newy;
 
-  /* compute offset (in inches) between 'drag point' and 
+  /* compute offset (in inches) between 'drag point' and
      the top-left corner of the image */
 
   offx = ((mx - pageRect.x) / in2pix) - pos_inx;
@@ -642,7 +645,7 @@
   char *fullname;
 
   switch (cmd) {
-  case PS_BOK:    writePS();    
+  case PS_BOK:    writePS();
                   PSDialog(0);
                   fullname = GetDirFullName();
                   if (!ISPIPE(fullname[0])) {
@@ -721,15 +724,15 @@
 
   GetSaveSize(&w, &h);
 
-  sz_inx = (double) w / PIX2INCH * (xsDial.val / 100.0);  
-  sz_iny = (double) h / PIX2INCH * (ysDial.val / 100.0);  
+  sz_inx = (double) w / PIX2INCH * (xsDial.val / 100.0);
+  sz_iny = (double) h / PIX2INCH * (ysDial.val / 100.0);
 
   /* round to integer .001ths of an inch */
   sz_inx = floor(sz_inx * 1000.0 + 0.5) / 1000.0;
   sz_iny = floor(sz_iny * 1000.0 + 0.5) / 1000.0;
 
-  dpix = (int) (PIX2INCH / (xsDial.val / 100.0));  
-  dpiy = (int) (PIX2INCH / (ysDial.val / 100.0));  
+  dpix = (int) (PIX2INCH / (xsDial.val / 100.0));
+  dpiy = (int) (PIX2INCH / (ysDial.val / 100.0));
 
   /* make sure 'center' of image is still on page */
   hsx = sz_inx/2;  hsy = sz_iny/2;
@@ -783,20 +786,20 @@
 {
   int x,y,w,h;
   XRectangle xr;
-  
+
   x = pageRect.x + (int) (pos_inx * in2pix);
   y = pageRect.y + (int) (pos_iny * in2pix);
   w = sz_inx * in2pix;
   h = sz_iny * in2pix;
-  
+
   xr.x = pageRect.x + 1;
   xr.y = pageRect.y + 1;
   xr.width  = pageRect.width - 1;
   xr.height = pageRect.height - 1;
-  
+
   if (draw) XSetForeground(theDisp, theGC, infofg);
        else XSetForeground(theDisp, theGC, infobg);
-  
+
   XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
   XDrawRectangle(theDisp, pageF, theGC, x, y, (u_int) w, (u_int) h);
   XDrawLine(theDisp, pageF, theGC, x, y, x+w, y+h);
@@ -839,15 +842,15 @@
   DSetVal(&xsDial, (int) ((100 * (sz_inx * PIX2INCH) / w) + .5));
   DSetVal(&ysDial, xsDial.val);
 
-  sz_inx = (double) w / PIX2INCH * (xsDial.val / 100.0);  
-  sz_iny = (double) h / PIX2INCH * (ysDial.val / 100.0);  
+  sz_inx = (double) w / PIX2INCH * (xsDial.val / 100.0);
+  sz_iny = (double) h / PIX2INCH * (ysDial.val / 100.0);
 
   /* round to integer .001ths of an inch */
   sz_inx = floor(sz_inx * 1000.0 + 0.5) / 1000.0;
   sz_iny = floor(sz_iny * 1000.0 + 0.5) / 1000.0;
 
-  dpix = (int) (PIX2INCH / (xsDial.val / 100.0));  
-  dpiy = (int) (PIX2INCH / (ysDial.val / 100.0));  
+  dpix = (int) (PIX2INCH / (xsDial.val / 100.0));
+  dpiy = (int) (PIX2INCH / (ysDial.val / 100.0));
 
   pos_inx = psizex/2 - sz_inx/2;
   pos_iny = psizey/2 - sz_iny/2;
@@ -888,7 +891,7 @@
 static void writePS()
 {
   FILE *fp;
-  int   i, j, q, err, rpix, gpix, bpix, nc, ptype;
+  int   i, j, err, rpix, gpix, bpix, nc, ptype;
   int   iw, ih, ox, oy, slen, lwidth, bits, colorps, w, h, pfree;
   double iwf, ihf;
   byte *inpix, *rmap, *gmap, *bmap;
@@ -900,13 +903,19 @@
   if (!fp) return;
 
   WaitCursor();
-  
+
   inpix = GenSavePic(&ptype, &w, &h, &pfree, &nc, &rmap, &gmap, &bmap);
 
-    
+  if (w <= 0 || h <= 0 || w*2 < w) {
+    SetISTR(ISTR_WARNING,"%s:  Image dimensions out of range", filename);
+    CloseOutFile(fp, filename, 1);
+    return;
+  }
+
+
   /* printed image will have size iw,ih (in picas) */
   iw = (int) (sz_inx * 72.0 + 0.5);
-  ih = (int) (sz_iny * 72.0 + 0.5);   
+  ih = (int) (sz_iny * 72.0 + 0.5);
   iwf = sz_inx * 72.0;
   ihf = sz_iny * 72.0;
 
@@ -923,12 +932,12 @@
   fprintf(fp,"%%%%Creator: XV %s  -  by John Bradley\n",REVDATE);
 
   if (RBWhich(orientRB)==ORNT_LAND)   /* Landscape mode */
-    fprintf(fp,"%%%%BoundingBox: %d %d %d %d\n", 
+    fprintf(fp,"%%%%BoundingBox: %d %d %d %d\n",
 	    (int) (pos_iny * 72.0 + 0.5),
 	    (int) (pos_inx * 72.0 + 0.5),
 	    (int) (pos_iny * 72.0 + 0.5) + ih,
 	    (int) (pos_inx * 72.0 + 0.5) + iw);
-  else 
+  else
     fprintf(fp,"%%%%BoundingBox: %d %d %d %d\n", ox, oy, ox+iw, oy+ih);
 
   fprintf(fp,"%%%%Pages: 1\n");
@@ -943,9 +952,9 @@
   case F_BWDITHER:  slen = (w+7)/8;  bits = 1;  colorps = 0;  break;
   default:  FatalError("unknown colorType in writePS()");   break;
   }
-  
+
   if (encapsCB.val) epsPreview(fp, inpix, ptype, colorType, w, h,
-			       rmap,gmap,bmap, 
+			       rmap,gmap,bmap,
 			       (RBWhich(orientRB)==ORNT_LAND) );
 
   fprintf(fp,"%%%%EndProlog\n\n");
@@ -978,7 +987,7 @@
     fprintf(fp,"%% print in landscape mode\n");
     fprintf(fp,"90 rotate 0 %d translate\n\n",(int) (-psizey*72.0));
   }
-    
+
   if (RBWhich(paperRB) == PSZ_4BY5 ||
       RBWhich(paperRB) == PSZ_35MM) {
     fprintf(fp,"%% we're going to a 4x5 or a 35mm film recorder.\n");
@@ -1083,12 +1092,12 @@
 	    gpix = inpix[1];
 	    bpix = inpix[2];
 	  }
-	  
-	  if (colorps) { 
+
+	  if (colorps) {
 	    err = fprintf(fp,"%02x%02x%02x",rpix,gpix,bpix);
 	    lwidth+=6;
 	  }
-      
+
 	  else {  /* greyscale */
 	    err = fprintf(fp,"%02x", MONO(rpix,gpix,bpix));
 	    lwidth+=2;
@@ -1106,7 +1115,7 @@
       fprintf(fp,"\n\n");
       fprintf(fp,"%%\n");
       fprintf(fp,"%% Compression made this file %.2f%% %s\n",
-	      100.0 * ((double) outbytes) / 
+	      100.0 * ((double) outbytes) /
 	      ((double) eWIDE * eHIGH * ((colorps) ? 3 : 1)),
 	      "of the uncompressed size.");
       fprintf(fp,"%%\n");
@@ -1147,10 +1156,10 @@
    *
    * returns length of the rleline vector
    */
-  
+
   int  i, j, blocklen, isrun, rlen;
   byte block[256], pix;
-  
+
   blocklen = isrun = rlen = 0;
 
   for (i=0; i<wide; i++) {
@@ -1186,7 +1195,7 @@
 	}
       }
     }
-	
+
     else {   /* not a run */
       if (pix == block[blocklen-1]) {   /* case 3:  non-run, prev==cur */
 	if (blocklen>1) {               /*  have a non-run block to flush */
@@ -1215,7 +1224,7 @@
 
       else {
 	rleline[rlen++] = (blocklen-1) | 0x80;
-	for (j=0; j<blocklen; j++) 
+	for (j=0; j<blocklen; j++)
 	  rleline[rlen++] = block[j];
       }
 
@@ -1231,15 +1240,15 @@
 
     else {
       rleline[rlen++] = (blocklen-1) | 0x80;
-      for (j=0; j<blocklen; j++) 
+      for (j=0; j<blocklen; j++)
 	rleline[rlen++] = block[j];
     }
   }
 
   return rlen;
 }
-	  
-	    
+
+
 /**********************************************/
 static void psColorImage(fp)
 FILE *fp;
@@ -1276,7 +1285,7 @@
   fprintf(fp,"    %% Utility procedure for colorimage operator.\n");
   fprintf(fp,"    %% This procedure takes two procedures off the\n");
   fprintf(fp,"    %% stack and merges them into a single procedure.\n\n");
-  
+
   fprintf(fp,"    /mergeprocs { %% def\n");
   fprintf(fp,"      dup length\n");
   fprintf(fp,"      3 -1 roll\n");
@@ -1326,12 +1335,12 @@
   for (i=0; i<nc; i++) {
     if (color) fprintf(fp,"%02x%02x%02x ", rmap[i],gmap[i],bmap[i]);
     else fprintf(fp,"%02x ", MONO(rmap[i],gmap[i],bmap[i]));
-    
+
     if ((i%10) == 9) fprintf(fp,"\n");
   }
   if (i%10) fprintf(fp,"\n");
   fprintf(fp,"pop pop   %% lose return values from readhexstring\n\n\n");
-		 
+
 }
 
 
@@ -1407,7 +1416,7 @@
 
 
 /**********************************************/
-static void epsPreview(fp, pic, ptype, colorType, w, h, rmap,gmap,bmap, 
+static void epsPreview(fp, pic, ptype, colorType, w, h, rmap,gmap,bmap,
 		       landscape)
      FILE *fp;
      byte *pic;
@@ -1420,21 +1429,37 @@
 
 
   if (landscape) {  /* generate a rotated version of the pic */
-    int bperpix;
+    int npixels, bufsize;
     byte *lpic;
 
-    bperpix = (ptype == PIC8) ? 1 : 3;
-    lpic = (byte *) malloc((size_t) w * h * bperpix);
+    npixels = w * h;
+    if (w <= 0 || h <= 0 || npixels/w != h) {
+      SetISTR(ISTR_WARNING,"%s:  Image dimensions out of range", filename);
+/*    CloseOutFile(fp, filename, 1);  can't do since caller still writing */
+      return;
+    }
+    if (ptype == PIC8)
+      bufsize = npixels;
+    else {
+      bufsize = 3*npixels;
+      if (bufsize/3 != npixels) {
+        SetISTR(ISTR_WARNING,"%s:  Image dimensions out of range", filename);
+/*      CloseOutFile(fp, filename, 1);  can't do since caller still writing */
+        return;
+      }
+    }
+
+    lpic = (byte *) malloc((size_t) bufsize);
     if (!lpic) FatalError("can't alloc mem to rotate image in epsPreview");
 
-    xvbcopy((char *) pic, (char *) lpic, (size_t) w * h * bperpix);
+    xvbcopy((char *) pic, (char *) lpic, (size_t) bufsize);
     RotatePic(lpic, ptype, &w, &h, 0);
     pic = lpic;
   }
-    
+
 
   /* put in an EPSI preview */
-  
+
   if (colorType != F_BWDITHER) { /* have to generate a preview */
     prev = FSDither(pic, ptype, w, h, rmap,gmap,bmap, 0, 1);
 
@@ -1451,8 +1476,8 @@
     flipbw = (MONO(rmap[0],gmap[0],bmap[0]) > MONO(rmap[1],gmap[1],bmap[1]));
   }
 
- 
-  fprintf(fp,"%%%%BeginPreview: %d %d %d %d\n", w, h, 1, 
+
+  fprintf(fp,"%%%%BeginPreview: %d %d %d %d\n", w, h, 1,
 	  (w/(72*4) + 1) * h);
 
   writeBWStip(fp, prev, "% ", w, h, !flipbw);
@@ -1471,7 +1496,7 @@
      char *prompt;
      int  w, h, flipbw;
 {
-  /* write the given 'pic' (B/W stippled, 1 byte per pixel, 0=blk,1=wht) 
+  /* write the given 'pic' (B/W stippled, 1 byte per pixel, 0=blk,1=wht)
      out as hexadecimal, max of 72 hex chars per line.
 
      if 'flipbw', then 0=white, 1=black
@@ -1535,25 +1560,32 @@
      document is multiple pages, a series of PNM files are created, and
      the first one is loaded (but not deleted) */
 
-
-  char tmp[512], tmp1[512], tmpname[64];
-  int  gsresult, nump, i, filetype;
+#ifdef GS_PATH
+  char tmp[512], gscmd[512], cmdstr[512], tmpname[64];
+  int  gsresult, nump, i, filetype, doalert, epsf;
   char *rld;
+#endif
 
   pinfo->pic     = (byte *) NULL;
   pinfo->comment = (char *) NULL;
 
-
 #ifdef GS_PATH
 
+  doalert = (!quick && !ctrlUp && !infoUp);  /* open alert if no info wins */
+  epsf    = 0;
+
 #ifndef VMS
   sprintf(tmpname, "%s/xvpgXXXXXX", tmpdir);
 #else
   sprintf(tmpname, "Sys$Scratch:xvpgXXXXXX");
 #endif
 
+#ifdef USE_MKSTEMP
+  close(mkstemp(tmpname));
+#else
   mktemp(tmpname);
-  if (tmpname[0] == '\0') {   /* mktemp() blew up */
+#endif
+  if (tmpname[0] == '\0') {   /* mktemp() or mkstemp() blew up */
     sprintf(str,"LoadPS: Unable to create temporary filename???");
     ErrPopUp(str, "\nHow unlikely!");
     return 0;
@@ -1561,13 +1593,13 @@
   strcat(tmpname,".");
 
 
-  /* build command string */
+  /* build 'gscmd' string */
 
 #ifndef VMS  /* VMS needs quotes around mixed case command lines */
-  sprintf(tmp, "%s -sDEVICE=%s -r%d -q -dNOPAUSE -sOutputFile=%s%%d ",
+  sprintf(gscmd, "%s -sDEVICE=%s -r%d -q -dNOPAUSE -sOutputFile=%s%%d ",
 	  GS_PATH, gsDev, gsRes, tmpname);
 #else
-  sprintf(tmp, 
+  sprintf(gscmd,
 	  "%s \"-sDEVICE=%s\" -r%d -q \"-dNOPAUSE\" \"-sOutputFile=%s%%d\" ",
 	  GS_PATH, gsDev, gsRes, tmpname);
 #endif
@@ -1575,74 +1607,60 @@
 
 #ifdef GS_LIB
 #  ifndef VMS
-     sprintf(tmp1, "-I%s ", GS_LIB);
+     sprintf(tmp, "-I%s ", GS_LIB);
 #  else
-     sprintf(tmp1, "\"-I%s\"", GS_LIB);
+     sprintf(tmp, "\"-I%s\" ", GS_LIB);
 #  endif
-   strcat(tmp, tmp1);
+   strcat(gscmd, tmp);
 #endif
 
-  if (gsGeomStr) {
-    sprintf(tmp1, "-g%s ", gsGeomStr);
-    strcat(tmp, tmp1);
-  }
-
-  /* if 'quick' is set, stop processing after first page by tacking
-     some PostScript commands that break the 'showpage' operator onto
-     the front of the stream passed to the ghostscript interpreter */
 
+   /* prevent some potential naughtiness... */
 #ifndef VMS
-  if (quick) {
-    sprintf(tmp1, "echo '%s' | cat - %s | %s -",
-	    "/showpage { showpage quit } bind def",   /* mk showpage exit */
-	    fname,  tmp);
-    strcpy(tmp, tmp1);
-  }
-  else {
-    strcat(tmp, " -- ");
-    strcat(tmp, fname);
-  }
-#else /* VMS */
-  /* VMS doesn't have pipes or an 'echo' command and GS doesn't like
-     Unix-style file names as input files in the VMS version */
-  strcat(tmp, " -- ");
-  rld = strrchr(fname, '/');     /* Pointer to last '/' */
-  if (rld) rld++;                /* Pointer to filename */
-      else rld = fname;          /* No path - use original string */
-  strcat(tmp, rld);
+   strcat(gscmd, "-dSAFER ");
+#else
+   strcat(gscmd, "\"-dSAFER\" ");
 #endif
 
 
+  if (gsGeomStr) {
+    sprintf(tmp, "-g%s ", gsGeomStr);
+    strcat(gscmd, tmp);
+  }
 
 
-  WaitCursor();
-
-  if (DEBUG) fprintf(stderr,"LoadPS:  executing command '%s'\n", tmp);
-  SetISTR(ISTR_INFO, "Running '%s'...", GS_PATH);
+  do {
+    buildCmdStr(cmdstr, gscmd, fname, quick, epsf);
 
-  sprintf(tmp1, "Running %s", tmp);
-  if (!quick && !ctrlUp && !infoUp) OpenAlert(tmp1);
+    if (DEBUG) fprintf(stderr,"LoadPS:  executing command '%s'\n", cmdstr);
+    SetISTR(ISTR_INFO, "Running '%s'...", GS_PATH);
+    sprintf(tmp, "Running %s", cmdstr);
+    if (doalert && epsf==0) OpenAlert(tmp);  /* open alert first time only */
 
-#ifndef VMS
-  gsresult = system(tmp);
-#else
-  gsresult = !system(tmp);
+    WaitCursor();
+    gsresult = system(cmdstr);
+    WaitCursor();
+#ifdef VMS
+    gsresult = !gsresult;   /* VMS returns non-zero if OK */
 #endif
 
-  WaitCursor();
+    /* count # of files produced... */
+    for (i=1; i<1000; i++) {
+      struct stat st;
+      sprintf(tmp, "%s%d", tmpname, i);
+      if (stat(tmp, &st)!=0) break;
+    }
+    nump = i-1;
+    WaitCursor();
 
-  if (!quick && !ctrlUp && !infoUp) CloseAlert();
+    /* EPSF hack:  if gsresult==0 (OK) and 0 pages produced,
+       try tacking a 'showpage' onto the end of the file, do it again... */
+
+    if (!gsresult && !nump && !epsf) epsf++;
+  } while (!gsresult && !nump && epsf<2);
+
+  if (doalert) CloseAlert();
 
-  /* figure out how many page files were created, by stating files. 
-     breaks out on first failure, assuming there won't be any more after
-     that, and it would complicate matters too much anyhow... */
-
-  for (i=1; i<1000; i++) {
-    struct stat st;
-    sprintf(tmp, "%s%d", tmpname, i);
-    if (stat(tmp, &st)!=0) break;
-  }
-  nump = i-1;
 
   WaitCursor();
 
@@ -1664,7 +1682,7 @@
       return 0;
     }
 
-    SetISTR(ISTR_INFO, "Running '%s'...  Done.  (%d page%s)", 
+    SetISTR(ISTR_INFO, "Running '%s'...  Done.  (%d page%s)",
 	    GS_PATH, nump, (nump==1) ? "" : "s");
   }
 
@@ -1677,8 +1695,8 @@
 
   sprintf(tmp, "%s%d", tmpname, 1);
   filetype = ReadFileType(tmp);
-  
-  if (filetype == RFT_ERROR || filetype == RFT_UNKNOWN || 
+
+  if (filetype == RFT_ERROR || filetype == RFT_UNKNOWN ||
       filetype == RFT_COMPRESS) {  /* shouldn't happen */
     SetISTR(ISTR_WARNING, "Couldn't load first page '%s'", tmp);
     KillPageFiles(tmpname, nump);
@@ -1695,7 +1713,7 @@
     KillPageFiles(tmpname, nump);
     SetCursors(-1);
     return 0;
-  }    
+  }
 
 
   /* SUCCESS! */
@@ -1712,3 +1730,38 @@
 		 we don't have 'gs' package */
 }
 
+
+
+/******************************************************************/
+#ifdef GS_PATH
+void buildCmdStr(str, gscmd, fname, quick, epsf)
+     char *str, *gscmd, *fname;
+     int   quick, epsf;
+{
+  /* note 'epsf' set only on files that don't have a showpage cmd */
+
+#ifndef VMS
+
+  if      (epsf)  sprintf(str, "echo '\n showpage ' | cat '%s' - | %s -",
+			  fname, gscmd);
+
+  else if (quick) sprintf(str, "echo '%s' | cat - '%s' | %s -",
+			  "/showpage { showpage quit } bind def",
+			  fname,  gscmd);
+
+  else            sprintf(str, "%s -- %s", gscmd, fname);
+
+#else /* VMS */
+  /* VMS doesn't have pipes or an 'echo' command and GS doesn't like
+     Unix-style file names as input files in the VMS version */
+  strcat(tmp, " -- ");
+  rld = strrchr(fname, '/');     /* Pointer to last '/' */
+  if (rld) rld++;                /* Pointer to filename */
+  else rld = fname;              /* No path - use original string */
+  strcat(tmp, rld);
+#endif  /* VMS */
+}
+#endif  /* GS_PATH */
+
+
+
diff -ruN xv-3.10a/xvrle.c xv-3.10a-bugfixes/xvrle.c
--- xv-3.10a/xvrle.c	1995-01-19 09:27:47.000000000 -0800
+++ xv-3.10a-bugfixes/xvrle.c	2005-03-29 23:29:14.000000000 -0800
@@ -43,8 +43,8 @@
   byte   bgcol[256];
   byte   maps[3][256];
   int    xpos, ypos, w, h, flags, ncolors, pixelbits, ncmap, cmaplen;
-  int    cmtlen;
-  byte  *img, *pic8;
+  int    cmtlen, npixels, bufsize=0;
+  byte  *img;
   long filesize;
   char  *bname, *errstr;
 
@@ -57,7 +57,7 @@
   /* open the stream */
   fp = xv_fopen(fname,"r");
   if (!fp) return (rleError(bname, "unable to open file"));
-  
+
 
   /* figure out the file size */
   fseek(fp, 0L, 2);
@@ -85,7 +85,7 @@
   if (DEBUG) {
     fprintf(stderr,"RLE: %dx%d image at %d,%d\n", w, h, xpos, ypos);
     fprintf(stderr,"flags: 0x%02x  (%s%s%s%s)\n",
-	    flags, 
+	    flags,
 	    (flags & H_CLEARFIRST)    ? "CLEARFIRST " : "",
 	    (flags & H_NO_BACKGROUND) ? "NO_BG " : "",
 	    (flags & H_ALPHA)         ? "ALPHA " : "",
@@ -93,7 +93,7 @@
 
     fprintf(stderr, "%d bands, %d pixelbits, %d cmap bands, %d cmap entries\n",
 	    ncolors, pixelbits, ncmap, cmaplen);
-  }  
+  }
 
   if (!(flags & H_NO_BACKGROUND)) {
     if (DEBUG) fprintf(stderr, "background value: ");
@@ -176,32 +176,44 @@
 
   errstr = NULL;
   if (ncolors == 0 || ncolors == 2)
-    errstr = "Unsupt. # of channels in RLE file.\n";
+    errstr = "Unsupported number of channels in RLE file";
 
   if (pixelbits != 8)
-    errstr = "Only 8-bit pixels supported in RLE files.\n";
+    errstr = "Only 8-bit pixels supported in RLE files";
 
   if (ncmap==0 || ncmap==1 || ncmap == 3 || ncmap == ncolors) { /* ok */ }
-  else errstr = "Invalid # of colormap channels in RLE file.\n";
+  else errstr = "Invalid number of colormap channels in RLE file";
 
-  if (w<1 || h<1)
-    errstr = "Bogus size in RLE header.\n";
+  npixels = w * h;
+  if (w <= 0 || h <= 0 || npixels/w != h)
+    errstr = "RLE image dimensions out of range";
 
 
   if (errstr) {
     fclose(fp);
-    if (pinfo->comment) free(pinfo->comment);  pinfo->comment = (char *) NULL;
+    if (pinfo->comment)
+      free(pinfo->comment);
+    pinfo->comment = (char *) NULL;
     return rleError(bname, errstr);
   }
 
 
   /* allocate image memory */
-  if (ncolors == 1) img = (byte *) calloc((size_t) w * h,     (size_t) 1);
-               else img = (byte *) calloc((size_t) w * h * 3, (size_t) 1);
+  if (ncolors == 1)
+    img = (byte *) calloc((size_t) npixels, (size_t) 1);
+  else {
+    bufsize = 3*npixels;
+    if (bufsize/3 != npixels)
+      return rleError(bname, "RLE image dimensions out of range");
+    img = (byte *) calloc((size_t) bufsize, (size_t) 1);
+  }
+
   if (!img) {
     fclose(fp);
-    if (pinfo->comment) free(pinfo->comment);  pinfo->comment = (char *) NULL;
-    return rleError(bname, "unable to allocate image data.\n");
+    if (pinfo->comment)
+      free(pinfo->comment);
+    pinfo->comment = (char *) NULL;
+    return rleError(bname, "Unable to allocate RLE image data");
   }
 
 
@@ -209,10 +221,10 @@
   if ((flags & H_CLEARFIRST) && !(flags & H_NO_BACKGROUND)) {
     byte *ip;
     if (ncolors == 1) {
-      for (i=0, ip=img; i<w*h; i++, ip++) *ip = bgcol[0];
+      for (i=0, ip=img; i<npixels; i++, ip++) *ip = bgcol[0];
     }
     else {
-      for (i=0, ip=img; i<w*h; i++) 
+      for (i=0, ip=img; i<npixels; i++)
 	for (j=0; j<3; j++, ip++) *ip = bgcol[j];
     }
   }
@@ -230,7 +242,7 @@
   if (ncmap) {
     byte *ip;
     int   imagelen, cmask;
-    imagelen = (ncolors==1) ? w*h : w*h*3;
+    imagelen = (ncolors==1) ? npixels : bufsize;
     cmask = (cmaplen-1);
 
     if (ncmap == 1) {   /* single gamma curve */
@@ -238,7 +250,7 @@
     }
 
     else if (ncmap >= 3 && ncolors >=3) {   /* one curve per band */
-      for (i=0, ip=img; i<w*h; i++) {
+      for (i=0, ip=img; i<npixels; i++) {
 	*ip = maps[0][*ip & cmask];   ip++;
 	*ip = maps[1][*ip & cmask];   ip++;
 	*ip = maps[2][*ip & cmask];   ip++;
@@ -250,7 +262,7 @@
   /* finally, convert into XV internal format */
 
   pinfo->pic = img;
-  pinfo->w   = w;  
+  pinfo->w   = w;
   pinfo->h   = h;
   pinfo->normw = pinfo->w;   pinfo->normh = pinfo->h;
   pinfo->frmType = -1;    /* no default format to save in */
@@ -260,7 +272,7 @@
     if (ncmap == 0 || ncmap == 1) {   /* grey, or grey with gamma curve */
       pinfo->colType = F_GREYSCALE;
       sprintf(pinfo->fullInfo, "Greyscale RLE.  (%ld bytes)", filesize);
-      for (i=0; i<256; i++) 
+      for (i=0; i<256; i++)
 	pinfo->r[i] = pinfo->g[i] = pinfo->b[i] = i;
     }
     else {
@@ -272,7 +284,7 @@
 	pinfo->b[i] = maps[2][i];
       }
     }
-    
+
     sprintf(pinfo->shrtInfo, "%dx%d RLE.",w, h);
   }
 
@@ -294,7 +306,7 @@
      int   w, h, ncolors, ncmap;
 {
   int posx, posy, plane, bperpix, i, pixval, skipcalls;
-  int opcode, operand, done, c, c1;    
+  int opcode, operand, done, c, c1;
   byte *ip;
 
   posx = posy = plane = done = skipcalls = 0;
@@ -324,7 +336,7 @@
     case RSkipPixelsOp:
       if (opcode & LONG_OP) { getc(fp);  operand = GETINT(fp); }
       else operand = getc(fp);
-      
+
       posx += operand;
       break;
 
@@ -340,7 +352,7 @@
 	c = getc(fp);
 	if (plane<ncolors && posy<h && (posx+i < w)) *ip = c;
       }
-      
+
       if (operand & 1) getc(fp);  /* word boundary */
       posx += operand;
       break;
@@ -358,7 +370,7 @@
       for (i=0; i<operand; i++, ip+=bperpix) {
 	if (plane<ncolors && posy<h && (posx+i < w)) *ip = pixval;
       }
-      
+
       /*  if (operand & 1) getc(fp); */  /* word boundary */
       posx += operand;
       break;
diff -ruN xv-3.10a/xvroot.c xv-3.10a-bugfixes/xvroot.c
--- xv-3.10a/xvroot.c	1994-12-22 14:34:42.000000000 -0800
+++ xv-3.10a-bugfixes/xvroot.c	2004-05-16 18:04:21.000000000 -0700
@@ -22,7 +22,7 @@
 /***********************************/
 void MakeRootPic()
 {
-  /* called after 'epic' has been generated (if we're using root).  
+  /* called after 'epic' has been generated (if we're using root).
      creates the XImage and the pixmap, sets the root to the new
      pixmap, and refreshes the display */
 
@@ -67,32 +67,32 @@
 
 
   if (rmode == RM_NORMAL || rmode == RM_TILE) {
-    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 0,0, 
+    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 0,0,
 	      (u_int) eWIDE, (u_int) eHIGH);
   }
 
   else if (rmode == RM_MIRROR || rmode == RM_IMIRROR) {
     /* quadrant 2 */
-    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 0,0, 
+    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 0,0,
 	      (u_int) eWIDE, (u_int) eHIGH);
     if (epic == NULL) FatalError("epic == NULL in RM_MIRROR code...\n");
 
     /* quadrant 1 */
     FlipPic(epic, eWIDE, eHIGH, 0);   /* flip horizontally */
     CreateXImage();
-    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, eWIDE,0, 
+    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, eWIDE,0,
 	      (u_int) eWIDE, (u_int) eHIGH);
 
     /* quadrant 4 */
     FlipPic(epic, eWIDE, eHIGH, 1);   /* flip vertically */
     CreateXImage();
-    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, eWIDE,eHIGH, 
+    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, eWIDE,eHIGH,
 	      (u_int) eWIDE, (u_int) eHIGH);
 
     /* quadrant 3 */
     FlipPic(epic, eWIDE, eHIGH, 0);   /* flip horizontally */
     CreateXImage();
-    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 0,eHIGH, 
+    XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 0,eHIGH,
 	      (u_int) eWIDE, (u_int) eHIGH);
 
     FlipPic(epic, eWIDE, eHIGH, 1);   /* flip vertically  (back to orig) */
@@ -122,15 +122,15 @@
       for (i=ay; i < (int) eHIGH; i+=h) {
 	for (j=ax; j < (int) eWIDE; j+=w) {
 	  /* if image goes off tmpPix, only draw subimage */
-	  
+
 	  x = j;  y = i;  w1 = w;  h1 = h;  offx = offy = 0;
 	  if (x<0)           { offx = -x;  w1 -= offx;  x = 0; }
 	  if (x+w1>eWIDE) { w1 = (eWIDE-x); }
 
 	  if (y<0)           { offy = -y;  h1 -= offy;  y = 0; }
 	  if (y+h1>eHIGH)    { h1 = (eHIGH-y); }
-	  
-	  XPutImage(theDisp, tmpPix, theGC, theImage, offx, offy, 
+
+	  XPutImage(theDisp, tmpPix, theGC, theImage, offx, offy,
 		    x, y, (u_int) w1, (u_int) h1);
 	}
       }
@@ -140,7 +140,7 @@
 
     else if (rmode == RM_CWARP) {          /* warp effect */
       XSetForeground(theDisp, theGC, rootfg);
-      for (i=0; i<=dispWIDE; i+=8) 
+      for (i=0; i<=dispWIDE; i+=8)
 	XDrawLine(theDisp,tmpPix,theGC, i,0, (int) dispWIDE-i,(int) dispHIGH);
       for (i=0; i<=dispHIGH; i+=8)
 	XDrawLine(theDisp,tmpPix,theGC, 0,i, (int) dispWIDE, (int) dispHIGH-i);
@@ -150,16 +150,16 @@
       XSetForeground(theDisp, theGC, rootfg);
       for (i=k=0; i<dispHIGH; i+=20,k++) {
 	XDrawLine(theDisp, tmpPix, theGC, 0, i, (int) dispWIDE, i);
-	for (j=(k&1) * 20 + 10; j<dispWIDE; j+=40) 
+	for (j=(k&1) * 20 + 10; j<dispWIDE; j+=40)
 	  XDrawLine(theDisp, tmpPix, theGC, j,i,j,i+20);
       }
     }
 
 
     /* draw the image centered on top of the background */
-    if (rmode != RM_CENTILE) 
-      XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 
-		((int) dispWIDE-eWIDE)/2, ((int) dispHIGH-eHIGH)/2, 
+    if (rmode != RM_CENTILE)
+      XPutImage(theDisp, tmpPix, theGC, theImage, 0,0,
+		((int) dispWIDE-eWIDE)/2, ((int) dispHIGH-eHIGH)/2,
 		(u_int) eWIDE, (u_int) eHIGH);
   }
 
@@ -172,7 +172,7 @@
     if (dispWIDE == eWIDE) {
       /* horizontal center line */
       int y, ay;
-      
+
       y = eHIGH - ((dispHIGH/2)%eHIGH); /* Starting point in picture to copy */
       ay = 0;    /* Vertical anchor point */
       while (ay < dispHIGH) {
@@ -189,7 +189,7 @@
     else if (dispHIGH == eHIGH) {
       /* vertical centerline */
       int x, ax;
-      
+
       x = eWIDE - ((dispWIDE/2)%eWIDE); /* Starting point in picture to copy */
       ax = 0;    /* Horizontal anchor point */
       while (ax < dispWIDE) {
@@ -206,10 +206,10 @@
     else {
       /* vertical and horizontal centerlines */
       int x,y, ax,ay;
-      
+
       y = eHIGH - ((dispHIGH/2)%eHIGH); /* Starting point in picture to copy */
       ay = 0;    /* Vertical anchor point */
-      
+
       while (ay < dispHIGH) {
 	x = eWIDE - ((dispWIDE/2)%eWIDE);/* Starting point in picture to cpy */
 	ax = 0;    /* Horizontal anchor point */
@@ -276,8 +276,8 @@
     gc_init.foreground = BlackPixel(theDisp, theScreen);
     gc_init.background = WhitePixel(theDisp, theScreen);
     gc = XCreateGC(theDisp, vrootW, GCForeground|GCBackground, &gc_init);
-    pix = XCreatePixmap(theDisp, vrootW, root_weave_width, 
-			root_weave_height, 
+    pix = XCreatePixmap(theDisp, vrootW, root_weave_width,
+			root_weave_height,
 			(unsigned int) DefaultDepth(theDisp, theScreen));
 
     XCopyPlane(theDisp, bitmap, pix, gc, 0,0, root_weave_width,
@@ -333,8 +333,8 @@
   prop = XInternAtom(theDisp, "_XSETROOT_ID", True);
   if (prop == None) return;    /* no old pixmap to kill */
 
-  if (XGetWindowProperty(theDisp, vrootW, prop, 0L, 1L, True, 
-			 AnyPropertyType, &type, &format, &length, 
+  if (XGetWindowProperty(theDisp, vrootW, prop, 0L, 1L, True,
+			 AnyPropertyType, &type, &format, &length,
 			 &after, &data) == Success) {
 
     if (type==XA_PIXMAP && format==32 && length==1 && after==0 && data) {
@@ -348,4 +348,4 @@
 
 
 
-    
+
diff -ruN xv-3.10a/xvscrl.c xv-3.10a-bugfixes/xvscrl.c
--- xv-3.10a/xvscrl.c	1994-12-22 14:34:41.000000000 -0800
+++ xv-3.10a-bugfixes/xvscrl.c	2004-05-16 18:04:25.000000000 -0700
@@ -1,4 +1,4 @@
-/* 
+/*
  * xvscrl.c - Scroll Bar handling functions
  *
  * callable functions:
@@ -6,7 +6,7 @@
  *   SCCreate()   -  creates the Scroll Bar window.
  *   SCChange()   -  resize/repositions the Scroll Bar window.
  *   SCSetRange() -  sets min/max/current values of control
- *   SCSetVal()   -  sets value of control 
+ *   SCSetVal()   -  sets value of control
  *   SCRedraw()   -  redraws scroll bar
  *   SCTrack()    -  called when clicked.  Operates control 'til mouseup
  */
@@ -50,7 +50,7 @@
 
 
 /***************************************************/
-void SCCreate(sp, parent, x, y, vert, len, minv, maxv, curv, page, 
+void SCCreate(sp, parent, x, y, vert, len, minv, maxv, curv, page,
 	          fg, bg, hi, lo, func)
 SCRL         *sp;
 Window        parent;
@@ -71,7 +71,7 @@
     downhPix = MakePix1(parent, downh_bits,  downh_width,  downh_height);
     uph1Pix  = MakePix1(parent, uph1_bits,   uph1_width,   uph1_height);
     downh1Pix= MakePix1(parent, downh1_bits, downh1_width, downh1_height);
-    
+
     sgray    = XCreatePixmapFromBitmapData(theDisp, parent,
 		(char *) scrlgray_bits, scrlgray_width, scrlgray_height,
 					   fg,bg,dispDEEP);
@@ -124,7 +124,7 @@
   sp->len  = len;
   sp->uplit = sp->dnlit = 0;
 
-  if (vert) XMoveResizeWindow(theDisp, sp->win, x,y, 
+  if (vert) XMoveResizeWindow(theDisp, sp->win, x,y,
 			      (u_int) sp->tsize,(u_int) len);
   else      XMoveResizeWindow(theDisp, sp->win, x,y,
 			      (u_int) len, (u_int) sp->tsize);
@@ -144,7 +144,7 @@
   if (maxv<minv) maxv=minv;
   sp->min = minv;    sp->max = maxv;    sp->page = page;
   sp->active =  (minv < maxv);
-  
+
   /* adjust scroll bar background */
   if (sp->active) {
     if (ctrlColor) XSetWindowBackground(theDisp, sp->win, sp->lo);
@@ -174,7 +174,7 @@
 
   sp->val = curv;
 
-  if (sp->active) 
+  if (sp->active)
     sp->tpos = sp->tmin + ((sp->tmax - sp->tmin)*(curv - sp->min))
                / (sp->max - sp->min);
 
@@ -194,20 +194,20 @@
   XSetBackground(theDisp, theGC, sp->bg);
 
   XClearWindow(theDisp, sp->win);
-  
+
   drawArrow(sp,UPLINE);      /* draw up/down arrows */
   drawArrow(sp,DNLINE);
 
   XSetForeground(theDisp, theGC, sp->fg);
 
-  if (sp->vert) {    
+  if (sp->vert) {
     XDrawLine(theDisp, sp->win, theGC, 0, sp->tsize, sp->tsize, sp->tsize);
-    XDrawLine(theDisp, sp->win, theGC, 0, sp->len-sp->tsize-1, 
+    XDrawLine(theDisp, sp->win, theGC, 0, sp->len-sp->tsize-1,
 	      sp->tsize, sp->len-sp->tsize-1);
   }
   else {                       /* horizontal version */
     XDrawLine(theDisp, sp->win, theGC, sp->tsize, 0, sp->tsize, sp->tsize);
-    XDrawLine(theDisp, sp->win, theGC, sp->len - sp->tsize-1, 0, 
+    XDrawLine(theDisp, sp->win, theGC, sp->len - sp->tsize-1, 0,
 	      sp->len - sp->tsize-1, sp->tsize);
   }
 
@@ -225,7 +225,7 @@
 
   if (arr == UPLINE) {
     XSetForeground(theDisp, theGC, sp->bg);
-    XFillRectangle(theDisp, sp->win, theGC, 0, 0, 
+    XFillRectangle(theDisp, sp->win, theGC, 0, 0,
 		   (u_int) sp->tsize, (u_int) sp->tsize);
 
     if (sp->vert) butpix = (sp->uplit) ? up1Pix  : upPix;
@@ -235,14 +235,14 @@
     XSetBackground(theDisp, theGC, sp->bg);
     XCopyPlane(theDisp, butpix, sp->win, theGC, 0, 0, up_width,up_height,
 	       3,3, 1L);
-    Draw3dRect(sp->win, 0,0, (u_int) sp->tsize-1, (u_int) sp->tsize-1, 
+    Draw3dRect(sp->win, 0,0, (u_int) sp->tsize-1, (u_int) sp->tsize-1,
 	       (sp->uplit) ? R3D_IN : R3D_OUT, 2, sp->hi, sp->lo, sp->bg);
   }
 
   else if (arr == DNLINE) {
     if (sp->vert) {
       XSetForeground(theDisp, theGC, sp->bg);
-      XFillRectangle(theDisp, sp->win, theGC, 0, sp->len - sp->tsize, 
+      XFillRectangle(theDisp, sp->win, theGC, 0, sp->len - sp->tsize,
 		     (u_int) sp->tsize, (u_int) sp->tsize);
       butpix = (sp->dnlit) ? down1Pix : downPix;
 
@@ -251,8 +251,8 @@
       XCopyPlane(theDisp, butpix, sp->win, theGC, 0, 0, up_width,up_height,
 		 3, sp->len - 3 - up_height, 1L);
 
-      Draw3dRect(sp->win, 0, sp->len - sp->tsize, 
-		 (u_int) sp->tsize-1, (u_int) sp->tsize-1, 
+      Draw3dRect(sp->win, 0, sp->len - sp->tsize,
+		 (u_int) sp->tsize-1, (u_int) sp->tsize-1,
 		 (sp->dnlit) ? R3D_IN : R3D_OUT, 2, sp->hi, sp->lo, sp->bg);
     }
 
@@ -267,8 +267,8 @@
       XCopyPlane(theDisp, butpix, sp->win, theGC, 0, 0, up_width,up_height,
 		 sp->len - 3 - up_width, 3, 1L);
 
-      Draw3dRect(sp->win, sp->len - sp->tsize, 0, 
-		 (u_int) sp->tsize-1, (u_int) sp->tsize-1, 
+      Draw3dRect(sp->win, sp->len - sp->tsize, 0,
+		 (u_int) sp->tsize-1, (u_int) sp->tsize-1,
 		 (sp->dnlit) ? R3D_IN : R3D_OUT, 2, sp->hi, sp->lo, sp->bg);
     }
   }
@@ -283,17 +283,17 @@
 {
   if (sp->vert) {
     /* clear out thumb area with background color */
-    XClearArea(theDisp, sp->win, 0, sp->tsize+1, (u_int) sp->tsize, 
+    XClearArea(theDisp, sp->win, 0, sp->tsize+1, (u_int) sp->tsize,
 	       (u_int) ((sp->len-sp->tsize-1)-(sp->tsize+1)), False);
 
     if (sp->active) {  /* a thumb is necessary */
 
       XSetForeground(theDisp, theGC, sp->bg);
-      XFillRectangle(theDisp, sp->win, theGC, 1, sp->tpos+1, 
+      XFillRectangle(theDisp, sp->win, theGC, 1, sp->tpos+1,
 		     (u_int) (sp->tsize-2), (u_int) (sp->tsize-2));
 
       XSetForeground(theDisp, theGC, sp->fg);
-      XDrawRectangle(theDisp, sp->win, theGC, 0, sp->tpos, 
+      XDrawRectangle(theDisp, sp->win, theGC, 0, sp->tpos,
 		     (u_int) (sp->tsize-1), (u_int) (sp->tsize-1));
 
       XDrawLine(theDisp, sp->win, theGC, 9-3, sp->tpos+6, 9+3, sp->tpos+6);
@@ -301,7 +301,7 @@
       XDrawLine(theDisp, sp->win, theGC, 9-3, sp->tpos+10,9+3, sp->tpos+10);
       XDrawLine(theDisp, sp->win, theGC, 9-3, sp->tpos+12,9+3, sp->tpos+12);
 
-      Draw3dRect(sp->win, 1, sp->tpos+1, 
+      Draw3dRect(sp->win, 1, sp->tpos+1,
 		 (u_int) sp->tsize-3, (u_int) sp->tsize-3, R3D_OUT,2,
 		 sp->hi, sp->lo, sp->bg);
     }
@@ -309,17 +309,17 @@
 
   else {   /* horizontal */
     /* clear out thumb area with background color */
-    XClearArea(theDisp, sp->win, sp->tsize+1, 0, 
-	       (u_int) ((sp->len-sp->tsize-1)-(sp->tsize+1)), 
+    XClearArea(theDisp, sp->win, sp->tsize+1, 0,
+	       (u_int) ((sp->len-sp->tsize-1)-(sp->tsize+1)),
 	       (u_int) sp->tsize, False);
 
     if (sp->active) {  /* a thumb is necessary */
       XSetForeground(theDisp, theGC, sp->bg);
-      XFillRectangle(theDisp, sp->win, theGC, sp->tpos+1, 1, 
+      XFillRectangle(theDisp, sp->win, theGC, sp->tpos+1, 1,
 		     (u_int) (sp->tsize-2), (u_int) (sp->tsize-2));
 
       XSetForeground(theDisp, theGC, sp->fg);
-      XDrawRectangle(theDisp, sp->win, theGC, sp->tpos, 0, 
+      XDrawRectangle(theDisp, sp->win, theGC, sp->tpos, 0,
 		     (u_int) (sp->tsize-1), (u_int) (sp->tsize-1));
 
       XDrawLine(theDisp, sp->win, theGC, sp->tpos+6, 9-3, sp->tpos+6, 9+3);
@@ -327,7 +327,7 @@
       XDrawLine(theDisp, sp->win, theGC, sp->tpos+10,9-3, sp->tpos+10,9+3);
       XDrawLine(theDisp, sp->win, theGC, sp->tpos+12,9-3, sp->tpos+12,9+3);
 
-      Draw3dRect(sp->win, sp->tpos+1, 1, 
+      Draw3dRect(sp->win, sp->tpos+1, 1,
 		 (u_int) sp->tsize-3, (u_int) sp->tsize-3, R3D_OUT,2,
 		 sp->hi, sp->lo, sp->bg);
     }
@@ -450,8 +450,8 @@
     case DNLINE:                     /* arrows */
       pos = whereInScrl(sp,x,y);
       if (pos == ipos) {
-	if (!lit) { 
-	  lit = 1; 
+	if (!lit) {
+	  lit = 1;
 	  if (ipos == UPLINE) { sp->uplit = 1;  drawArrow(sp,UPLINE); }
 	                 else { sp->dnlit = 1;  drawArrow(sp,DNLINE); }
 	}
@@ -467,16 +467,16 @@
 	  }
 	}
       }
-      
+
       else {
-	if (lit) { 
-	  lit = 0; 
+	if (lit) {
+	  lit = 0;
 	  if (ipos == UPLINE) { sp->uplit = 0;  drawArrow(sp,UPLINE); }
 	                 else { sp->dnlit = 0;  drawArrow(sp,DNLINE); }
 	}
       }
       break;
-      
+
     }
   }
 
diff -ruN xv-3.10a/xvsmooth.c xv-3.10a-bugfixes/xvsmooth.c
--- xv-3.10a/xvsmooth.c	1994-12-22 14:34:42.000000000 -0800
+++ xv-3.10a-bugfixes/xvsmooth.c	2004-05-16 18:04:28.000000000 -0700
@@ -4,11 +4,11 @@
  *  Contains:
  *            byte *SmoothResize(src8, swide, shigh, dwide, dhigh,
  *                               rmap, gmap, bmap, rdmap, gdmap, bdmap, maplen)
- *            byte *Smooth24(pic824, is24, swide, shigh, dwide, dhigh, 
+ *            byte *Smooth24(pic824, is24, swide, shigh, dwide, dhigh,
  *                               rmap, gmap, bmap)
- *            byte *DoColorDither(pic24, pic8, w, h, rmap,gmap,bmap, 
+ *            byte *DoColorDither(pic24, pic8, w, h, rmap,gmap,bmap,
  *                                rdisp, gdisp, bdisp, maplen)
- *            byte *Do332ColorDither(pic24, pic8, w, h, rmap,gmap,bmap, 
+ *            byte *Do332ColorDither(pic24, pic8, w, h, rmap,gmap,bmap,
  *                                rdisp, gdisp, bdisp, maplen)
  */
 
@@ -18,21 +18,21 @@
 
 static int smoothX  PARM((byte *, byte *, int, int, int, int, int,
 			  byte *, byte *, byte *));
-static int smoothY  PARM((byte *, byte *, int, int, int, int, int, 
+static int smoothY  PARM((byte *, byte *, int, int, int, int, int,
 			  byte *, byte *, byte *));
 static int smoothXY PARM((byte *, byte *, int, int, int, int, int,
 			  byte *, byte *, byte *));
 
 
 /***************************************************/
-byte *SmoothResize(srcpic8, swide, shigh, dwide, dhigh, 
+byte *SmoothResize(srcpic8, swide, shigh, dwide, dhigh,
 		   rmap, gmap, bmap, rdmap, gdmap, bdmap, maplen)
      byte *srcpic8, *rmap, *gmap, *bmap, *rdmap, *gdmap, *bdmap;
      int   swide, shigh, dwide, dhigh, maplen;
 {
-  /* generic interface to Smooth and ColorDither code.  
-     given an 8-bit-per, swide * shigh image with colormap rmap,gmap,bmap, 
-     will generate a new 8-bit-per, dwide * dhigh image, which is dithered 
+  /* generic interface to Smooth and ColorDither code.
+     given an 8-bit-per, swide * shigh image with colormap rmap,gmap,bmap,
+     will generate a new 8-bit-per, dwide * dhigh image, which is dithered
      using colors found in rdmap, gdmap, bdmap arrays */
 
   /* returns ptr to a dwide*dhigh array of bytes, or NULL on failure */
@@ -50,7 +50,7 @@
 
   return (byte *) NULL;
 }
-    
+
 
 
 /***************************************************/
@@ -83,23 +83,23 @@
   bperpix = (is24) ? 3 : 1;
 
   /* decide which smoothing routine to use based on type of expansion */
-  if      (dwide <  swide && dhigh <  shigh) 
+  if      (dwide <  swide && dhigh <  shigh)
     retval = smoothXY(pic24, pic824, is24, swide, shigh, dwide, dhigh,
 		      rmap, gmap, bmap);
 
-  else if (dwide <  swide && dhigh >= shigh) 
+  else if (dwide <  swide && dhigh >= shigh)
     retval = smoothX (pic24, pic824, is24, swide, shigh, dwide, dhigh,
 		      rmap, gmap, bmap);
 
-  else if (dwide >= swide && dhigh <  shigh) 
+  else if (dwide >= swide && dhigh <  shigh)
     retval = smoothY (pic24, pic824, is24, swide, shigh, dwide, dhigh,
 		      rmap, gmap, bmap);
 
   else {
     /* dwide >= swide && dhigh >= shigh */
 
-    /* cx,cy = original pixel in pic824.  px,py = relative position 
-       of pixel ex,ey inside of cx,cy as percentages +-50%, +-50%.  
+    /* cx,cy = original pixel in pic824.  px,py = relative position
+       of pixel ex,ey inside of cx,cy as percentages +-50%, +-50%.
        0,0 = middle of pixel */
 
     /* we can save a lot of time by precomputing cxtab[] and pxtab[], both
@@ -115,10 +115,10 @@
 
     for (ex=0; ex<dwide; ex++) {
       cxtab[ex] = (ex * swide) / dwide;
-      pxtab[ex] = (((ex * swide)* 100) / dwide) 
+      pxtab[ex] = (((ex * swide)* 100) / dwide)
 	           - (cxtab[ex] * 100) - 50;
     }
-    
+
     for (ey=0; ey<dhigh; ey++) {
       byte *pptr, rA, gA, bA, rB, gB, bB, rC, gC, bC, rD, gD, bD;
 
@@ -162,7 +162,7 @@
 	  cC = pic824[cyOff + x1];   /* left/right center pixel */
 	  cD = pic824[cyOff + cx];   /* center pixel */
 	}
-	 
+
 	/* quick check */
 	if (!is24 && cA == cB && cB == cC && cC == cD) {
 	  /* set this pixel to the same color as in pic8 */
@@ -178,30 +178,30 @@
 	  pD = 100 - (pA + pB + pC);
 
 	  if (is24) {
-	    *pp++ = ((int) (pA * rA))/100 + ((int) (pB * rB))/100 + 
+	    *pp++ = ((int) (pA * rA))/100 + ((int) (pB * rB))/100 +
 	            ((int) (pC * rC))/100 + ((int) (pD * rD))/100;
 
-	    *pp++ = ((int) (pA * gA))/100 + ((int) (pB * gB))/100 + 
+	    *pp++ = ((int) (pA * gA))/100 + ((int) (pB * gB))/100 +
 	            ((int) (pC * gC))/100 + ((int) (pD * gD))/100;
 
-	    *pp++ = ((int) (pA * bA))/100 + ((int) (pB * bB))/100 + 
+	    *pp++ = ((int) (pA * bA))/100 + ((int) (pB * bB))/100 +
 	            ((int) (pC * bC))/100 + ((int) (pD * bD))/100;
 	  }
 	  else {  /* 8-bit pic */
-	    *pp++ = ((int) (pA * rmap[cA]))/100 + ((int)(pB * rmap[cB]))/100 + 
+	    *pp++ = ((int) (pA * rmap[cA]))/100 + ((int)(pB * rmap[cB]))/100 +
 	            ((int) (pC * rmap[cC]))/100 + ((int)(pD * rmap[cD]))/100;
 
-	    *pp++ = ((int) (pA * gmap[cA]))/100 + ((int)(pB * gmap[cB]))/100 + 
+	    *pp++ = ((int) (pA * gmap[cA]))/100 + ((int)(pB * gmap[cB]))/100 +
 	            ((int) (pC * gmap[cC]))/100 + ((int)(pD * gmap[cD]))/100;
 
-	    *pp++ = ((int)(pA * bmap[cA]))/100 + ((int)(pB * bmap[cB]))/100 + 
+	    *pp++ = ((int)(pA * bmap[cA]))/100 + ((int)(pB * bmap[cB]))/100 +
   	            ((int)(pC * bmap[cC]))/100 + ((int)(pD * bmap[cD]))/100;
 	  }
 	}
       }
     }
 
-    free(cxtab);  
+    free(cxtab);
     free(pxtab);
     retval = 0;    /* okay */
   }
@@ -218,7 +218,7 @@
 
 
 /***************************************************/
-static int smoothX(pic24, pic824, is24, swide, shigh, dwide, dhigh, 
+static int smoothX(pic24, pic824, is24, swide, shigh, dwide, dhigh,
 		   rmap, gmap, bmap)
 byte *pic24, *pic824, *rmap, *gmap, *bmap;
 int   is24, swide, shigh, dwide, dhigh;
@@ -253,7 +253,7 @@
 
   bperpix = (is24) ? 3 : 1;
 
-  for (j=0; j<=swide; j++) 
+  for (j=0; j<=swide; j++)
     pixarr[j] = (j*dwide + (15*swide)/16) / swide;
 
   cptr = pic824;  cptr1 = cptr + swide * bperpix;
@@ -280,7 +280,7 @@
 	lbufG[j] = ((int) ((*cptr++ * pcnt0) + (*cptr1++ * pcnt1))) >> 6;
 	lbufB[j] = ((int) ((*cptr++ * pcnt0) + (*cptr1++ * pcnt1))) >> 6;
       }
-    } 
+    }
     else {  /* 8-bit input pic */
       for (j=0; j<swide; j++, cptr++, cptr1++) {
 	lbufR[j] = ((int)((rmap[*cptr]* pcnt0) + (rmap[*cptr1]* pcnt1))) >> 6;
@@ -314,8 +314,8 @@
   return 0;
 }
 
-	
-      
+
+
 
 
 
@@ -405,7 +405,7 @@
 	lbufB[j] += ((int)((bmap[*cptr]*pct0[j])+(bmap[*cptr1]*pct1[j]))) >> 6;
       }
     }
-   
+
     linecnt++;
   }
 
@@ -421,13 +421,13 @@
   return retval;
 }
 
-	
-      
+
+
 
 
 
 /***************************************************/
-static int smoothXY(pic24, pic824, is24, swide, shigh, dwide, dhigh, 
+static int smoothXY(pic24, pic824, is24, swide, shigh, dwide, dhigh,
 		    rmap, gmap, bmap)
 byte *pic24, *pic824, *rmap, *gmap, *bmap;
 int   is24, swide, shigh, dwide, dhigh;
@@ -462,7 +462,7 @@
 
   bperpix = (is24) ? 3 : 1;
 
-  for (j=0; j<=swide; j++) 
+  for (j=0; j<=swide; j++)
     pixarr[j] = (j*dwide + (15*swide)/16) / swide;
 
   lastline = linecnt = pixR = pixG = pixB = 0;
@@ -526,20 +526,20 @@
   return 0;
 }
 
-	
-      
+
+
 
 /********************************************/
-byte *DoColorDither(pic24, pic8, w, h, rmap, gmap, bmap, 
+byte *DoColorDither(pic24, pic8, w, h, rmap, gmap, bmap,
 		    rdisp, gdisp, bdisp, maplen)
      byte *pic24, *pic8, *rmap, *gmap, *bmap, *rdisp, *gdisp, *bdisp;
      int   w, h, maplen;
 {
   /* takes a 24 bit picture, of size w*h, dithers with the colors in
      rdisp, gdisp, bdisp (which have already been allocated),
-     and generates an 8-bit w*h image, which it returns.  
+     and generates an 8-bit w*h image, which it returns.
      ignores input value 'pic8'
-     returns NULL on error 
+     returns NULL on error
 
      note: the rdisp,gdisp,bdisp arrays should be the 'displayed' colors,
      not the 'desired' colors
@@ -547,7 +547,7 @@
      if pic24 is NULL, uses the passed-in pic8 (an 8-bit image) as
      the source, and the rmap,gmap,bmap arrays as the desired colors */
 
-  byte *np, *ep, *newpic; 
+  byte *np, *ep, *newpic;
   short *cache;
   int r2, g2, b2;
   int *thisline, *nextline, *thisptr, *nextptr, *tmpptr;
@@ -558,11 +558,11 @@
   int fserrmap[512];   /* -255 .. 0 .. +255 */
 
   /* compute somewhat non-linear floyd-steinberg error mapping table */
-  for (i=j=0; i<=0x40; i++,j++) 
+  for (i=j=0; i<=0x40; i++,j++)
     { fserrmap[256+i] = j;  fserrmap[256-i] = -j; }
-  for (     ; i<0x80; i++, j += !(i&1) ? 1 : 0) 
+  for (     ; i<0x80; i++, j += !(i&1) ? 1 : 0)
     { fserrmap[256+i] = j;  fserrmap[256-i] = -j; }
-  for (     ; i<=0xff; i++) 
+  for (     ; i<=0xff; i++)
     { fserrmap[256+i] = j;  fserrmap[256-i] = -j; }
 
 
@@ -575,7 +575,7 @@
   cache  = (short *) calloc((size_t) (2<<14), sizeof(short));
   thisline = (int *) malloc(pwide3 * sizeof(int));
   nextline = (int *) malloc(pwide3 * sizeof(int));
-  if (!cache || !newpic || !thisline || !nextline) { 
+  if (!cache || !newpic || !thisline || !nextline) {
     if (newpic)   free(newpic);
     if (cache)    free(cache);
     if (thisline) free(thisline);
@@ -624,30 +624,30 @@
 
       r2 = *thisptr++;  g2 = *thisptr++;  b2 = *thisptr++;
 
-      /* map r2,g2,b2 components (could be outside 0..255 range) 
+      /* map r2,g2,b2 components (could be outside 0..255 range)
 	 into 0..255 range */
-      
+
       if (r2<0 || g2<0 || b2<0) {   /* are there any negatives in RGB? */
 	if (r2<g2) { if (r2<b2) k = 0; else k = 2; }
 	else { if (g2<b2) k = 1; else k = 2; }
 
 	switch (k) {
 	case 0:  g2 -= r2;  b2 -= r2;  d = (abs(r2) * 3) / 2;    /* RED */
-	         r2 = 0;  
+	         r2 = 0;
 	         g2 = (g2>d) ? g2 - d : 0;
 	         b2 = (b2>d) ? b2 - d : 0;
 	         break;
 
 	case 1:  r2 -= g2;  b2 -= g2;  d = (abs(g2) * 3) / 2;    /* GREEN */
 	         r2 = (r2>d) ? r2 - d : 0;
-	         g2 = 0;  
+	         g2 = 0;
 	         b2 = (b2>d) ? b2 - d : 0;
 	         break;
 
 	case 2:  r2 -= b2;  g2 -= b2;  d = (abs(b2) * 3) / 2;    /* BLUE */
 	         r2 = (r2>d) ? r2 - d : 0;
 	         g2 = (g2>d) ? g2 - d : 0;
-	         b2 = 0;  
+	         b2 = 0;
 	         break;
 	}
       }
@@ -674,7 +674,7 @@
         mind = 10000;
 	for (k=closest=0; k<maplen && mind>7; k++) {
 	  d = abs(r2 - rdisp[k])
-	    + abs(g2 - gdisp[k]) 
+	    + abs(g2 - gdisp[k])
 	    + abs(b2 - bdisp[k]);
 	  if (d<mind) { mind = d;  closest = k; }
 	}
@@ -703,7 +703,7 @@
 	thisptr[1] += (gerr*7)/16;
 	thisptr[2] += (berr*7)/16;
       }
-      
+
       if (i!=imax) {	/* do BOTTOM pixel */
 	nextptr[0] += (rerr*5)/16;
 	nextptr[1] += (gerr*5)/16;
@@ -735,7 +735,7 @@
 
 
 /********************************************/
-byte *Do332ColorDither(pic24, pic8, w, h, rmap, gmap, bmap, 
+byte *Do332ColorDither(pic24, pic8, w, h, rmap, gmap, bmap,
 		    rdisp, gdisp, bdisp, maplen)
      byte *pic24, *pic8, *rmap, *gmap, *bmap, *rdisp, *gdisp, *bdisp;
      int   w, h, maplen;
@@ -744,9 +744,9 @@
 
   /* takes a 24 bit picture, of size w*h, dithers with the colors in
      rdisp, gdisp, bdisp (which have already been allocated),
-     and generates an 8-bit w*h image, which it returns.  
+     and generates an 8-bit w*h image, which it returns.
      ignores input value 'pic8'
-     returns NULL on error 
+     returns NULL on error
 
      note: the rdisp,gdisp,bdisp arrays should be the 'displayed' colors,
      not the 'desired' colors
@@ -754,7 +754,7 @@
      if pic24 is NULL, uses the passed-in pic8 (an 8-bit image) as
      the source, and the rmap,gmap,bmap arrays as the desired colors */
 
-  byte *np, *ep, *newpic; 
+  byte *np, *ep, *newpic;
   int r2, g2, b2;
   int *thisline, *nextline, *thisptr, *nextptr, *tmpptr;
   int  i, j, rerr, gerr, berr, pwide3;
@@ -763,11 +763,11 @@
   int  fserrmap[512];   /* -255 .. 0 .. +255 */
 
   /* compute somewhat non-linear floyd-steinberg error mapping table */
-  for (i=j=0; i<=0x40; i++,j++) 
+  for (i=j=0; i<=0x40; i++,j++)
     { fserrmap[256+i] = j;  fserrmap[256-i] = -j; }
-  for (     ; i<0x80; i++, j += !(i&1) ? 1 : 0) 
+  for (     ; i<0x80; i++, j += !(i&1) ? 1 : 0)
     { fserrmap[256+i] = j;  fserrmap[256-i] = -j; }
-  for (     ; i<=0xff; i++) 
+  for (     ; i<=0xff; i++)
     { fserrmap[256+i] = j;  fserrmap[256-i] = -j; }
 
 
@@ -778,7 +778,7 @@
   newpic   = (byte *) malloc((size_t) (w * h));
   thisline = (int *)  malloc(pwide3 * sizeof(int));
   nextline = (int *)  malloc(pwide3 * sizeof(int));
-  if (!newpic || !thisline || !nextline) { 
+  if (!newpic || !thisline || !nextline) {
     if (newpic)   free(newpic);
     if (thisline) free(thisline);
     if (nextline) free(nextline);
@@ -830,7 +830,7 @@
 
 
     for (j=0; j<w; j++) {
-      int k, d, mind, closest, rb,gb,bb;
+      int rb,gb,bb;
 
       r2 = *thisptr++;  g2 = *thisptr++;  b2 = *thisptr++;
       if (i&1) thisptr -= 6;  /* move left */
@@ -846,7 +846,7 @@
       bb = (b2 + 0x20);    /* round 2 bits */
       RANGE(bb,0,255);
       bb = bb & 0xc0;
-      
+
 
       *np = rb | (gb>>3) | (bb>>6);
 
diff -ruN xv-3.10a/xvsunras.c xv-3.10a-bugfixes/xvsunras.c
--- xv-3.10a/xvsunras.c	1994-12-22 14:34:42.000000000 -0800
+++ xv-3.10a-bugfixes/xvsunras.c	2005-04-02 18:04:20.000000000 -0800
@@ -54,8 +54,8 @@
      PICINFO *pinfo;
 {
   FILE	*fp;
-  int	 linesize,lsize,csize,isize,i,w,h,d;
-  byte	 *image, *line, *pic8;
+  int	 linesize,lsize,csize,isize,i,w,h,d,npixels,nbytes;
+  byte	 *image, *line;
   struct rasterfile sunheader;
   char   *bname;
 
@@ -85,7 +85,7 @@
       sunheader.ras_depth != 8 &&
       sunheader.ras_depth != 24 &&
       sunheader.ras_depth != 32) {
-    fprintf (stderr, "Sun rasterfile image has depth %d\n", 
+    fprintf (stderr, "Sun rasterfile image has depth %d\n",
 	     sunheader.ras_depth);
     fprintf (stderr, "Depths supported are 1, 8, 24, and 32\n");
     fclose(fp);
@@ -115,26 +115,59 @@
 
   w = sunheader.ras_width;
   h = sunheader.ras_height;
-  d = sunheader.ras_depth;
-  isize = sunheader.ras_length ?
-	  sunheader.ras_length :
-	  (w * h * d) / 8;
+  d = sunheader.ras_depth;  /* 1, 8, 24, or 32 (above) */
+  npixels = w * h;
+  if (w <= 0 || h <= 0 || npixels/w != h) {
+    fprintf (stderr, "Sun rasterfile image has invalid dimensions (%dx%d)\n",
+	     w, h);
+    fclose(fp);
+    return 0;
+  }
+  if (d == 1)
+    nbytes = npixels/8;     /* should round up here, but used only for printf */
+  else {
+    nbytes = npixels * (d/8);
+/*
+    [nbytes (isize) used only in printfs; don't really care about overflows]
+    if (nbytes/npixels != (d/8)) {
+      fprintf (stderr, "Sun rasterfile has invalid dimensions (%dx%dx%d)\n",
+	       w, h, d);
+      fclose(fp);
+      return 0;
+    }
+ */
+  }
+  isize = sunheader.ras_length ? sunheader.ras_length : nbytes;
   csize = (sunheader.ras_maptype == RMT_NONE) ? 0 : sunheader.ras_maplength;
 
 
-  /* compute length of the output (xv-format) image */
-  lsize = w * h;     
-  if (d == 24 || d == 32) lsize = lsize * 3;
+  /* length of the output (xv-format) image */
+  lsize = npixels;
+  if (d == 24 || d == 32) {
+    lsize *= 3;
+    if (lsize/3 != npixels) {
+      fprintf (stderr, "Sun rasterfile has invalid dimensions (%dx%dx%d)\n",
+	       w, h, d);
+      fclose(fp);
+      return 0;
+    }
+  }
 
 
   linesize = w * d;
+  if (linesize/w != d || linesize + 15 < linesize) {
+    fprintf (stderr, "Sun rasterfile has invalid dimensions (%dx%dx%d)\n",
+	     w, h, d);
+    fclose(fp);
+    return 0;
+  }
   if (linesize % 16) linesize += (16 - (linesize % 16));
   linesize /= 8;
 
   if (DEBUG) {
     fprintf(stderr,"%s: LoadSunRas() - loading a %dx%d pic, %d planes\n",
 	    cmd, w, h, d);
-    fprintf (stderr, 
+    fprintf (stderr,
 	  "type %d, maptype %d, isize %d, csize %d, lsize %d, linesize %d\n",
 	     sunheader.ras_type, sunheader.ras_maptype,
 	     isize, csize, lsize, linesize);
@@ -188,13 +221,13 @@
     }
 
     switch (d) {
-    case 1:  sunRas1to8 (image + w * i, line, w);	                
+    case 1:  sunRas1to8 (image + w * i, line, w);
              break;
     case 8:  xvbcopy((char *) line, (char *) image + w * i, (size_t) w);
              break;
     case 24: xvbcopy((char *) line, (char *) image + w * i * 3, (size_t) w*3);
              break;
-      
+
     case 32:
       {
 	int k;
@@ -202,7 +235,7 @@
 	ip = line;
 	op = (byte *) (image + w * i * 3);
 	for (k = 0; k<w; k++) {
-	  *ip++;           /* skip 'alpha' */
+	  ip++;            /* skip 'alpha' */
 	  *op++ = *ip++;   /* red   */
 	  *op++ = *ip++;   /* green */
 	  *op++ = *ip++;   /* blue  */
@@ -210,9 +243,9 @@
       }
     }
   }
-  
+
   free(line);
-  
+
   if (DEBUG) fprintf(stderr,"Sun ras: image loaded!\n");
 
 
@@ -224,7 +257,7 @@
   else pinfo->type = PIC8;
 
   pinfo->pic = image;
-  pinfo->w = w;  
+  pinfo->w = w;
   pinfo->h = h;
   pinfo->normw = pinfo->w;   pinfo->normh = pinfo->h;
   pinfo->frmType = F_SUNRAS;
@@ -364,10 +397,15 @@
 
   /* special case: if PIC24 and writing GREYSCALE, write 8-bit file */
   if (ptype == PIC24  && colorstyle == F_GREYSCALE) {
-    graypic = (byte *) malloc((size_t) w*h);
+    int npixels = w * h;
+    if (w <= 0 || h <= 0 || npixels/w != h) {
+      SetISTR(ISTR_WARNING, "Image is too large (%dx%d)", w, h);
+      return (2);
+    }
+    graypic = (byte *) malloc((size_t) npixels);
     if (!graypic) FatalError("unable to malloc in WriteSunRas()");
-    
-    for (i=0,sp=pic,dp=graypic; i<w*h; i++,sp+=3,dp++) {
+
+    for (i=0,sp=pic,dp=graypic; i<npixels; i++,sp+=3,dp++) {
       *dp = MONO(sp[0],sp[1],sp[2]);
     }
 
@@ -379,9 +417,18 @@
   }
 
 
-  if      (ptype==PIC24)    { d = 24;  linesize = w * 3; }
-  else if (colorstyle != F_BWDITHER) { d = 8;   linesize = w;     }
-  else { 
+  if (ptype==PIC24) {
+    d = 24;
+    linesize = w * 3;
+    if (linesize/w != 3) {
+      SetISTR(ISTR_WARNING, "Image is too wide (%d)", w);
+      if (graypic) free(graypic);
+      return (2);
+    }
+  } else if (colorstyle != F_BWDITHER) {
+    d = 8;
+    linesize = w;
+  } else {
     d = 1;
     linesize = w;
     if (linesize % 8) linesize += (8 - linesize % 8);
@@ -391,6 +438,11 @@
 
 
   if (linesize % 2) linesize++;
+  if (linesize == 0) {
+    SetISTR(ISTR_WARNING, "Image is too wide (%d)", w);
+    if (graypic) free(graypic);
+    return (2);
+  }
   line = (byte *) malloc((size_t) linesize);
   if (!line) {
     SetISTR(ISTR_WARNING, "Can't allocate memory for save!\n");
@@ -428,7 +480,7 @@
   write_sun_long (sunheader.ras_maplength, fp);
 
   /* write the colormap */
-  if (d == 8)
+  if (d == 8) {
     if (colorstyle == 1)  /* grayscale */
       for (color=0; color<3; color++)
 	for (i=0; i<numcols; i++)
@@ -438,6 +490,7 @@
       fwrite (gmap, sizeof(byte), (size_t) numcols, fp);
       fwrite (bmap, sizeof(byte), (size_t) numcols, fp);
     }
+  }
 
 
   /* write the image */
diff -ruN xv-3.10a/xvtarga.c xv-3.10a-bugfixes/xvtarga.c
--- xv-3.10a/xvtarga.c	1994-12-22 14:34:55.000000000 -0800
+++ xv-3.10a-bugfixes/xvtarga.c	2005-03-31 07:33:07.000000000 -0800
@@ -17,8 +17,8 @@
  *   0:
  *   1: colormap type
  *   2: image type  (1=colmap RGB, 2=uncomp RGB, 3=uncomp gray)
- *   3: 
- *   4: 
+ *   3:
+ *   4:
  *   5: colormap_length, low byte
  *   6: colormap_length, high byte
  *   7: bits per cmap entry     (8, 24, 32)
@@ -28,7 +28,7 @@
  *  14: height, low byte
  *  15: height, high byte
  *  16: bits per pixel (8, 24)
- *  17: flags  
+ *  17: flags
  */
 
 
@@ -48,7 +48,7 @@
   /* returns '1' on success */
 
   FILE  *fp;
-  int    i, row, c, c1, w, h, r, g, b, flags, intlace, topleft, trunc;
+  int    i, row, c, c1, w, h, npixels, bufsize, flags, intlace, topleft, trunc;
   byte *pic24, *pp;
 
   bname = BaseName(fname);
@@ -88,7 +88,9 @@
   c=getc(fp); c1=getc(fp);
   h = c1*256 + c;
 
-  if (w<1 || h<1) {
+  npixels = w * h;
+  bufsize = 3 * npixels;
+  if (w <= 0 || h <= 0 || npixels/w != h || bufsize/3 != npixels) {
     fclose(fp);
     SetISTR(ISTR_WARNING,"%s:  error in Targa header (bad image size)", bname);
     return 0;
@@ -115,7 +117,7 @@
 #endif
 
 
-  pic24 = (byte *) calloc((size_t) w*h*3, (size_t) 1);
+  pic24 = (byte *) calloc((size_t) bufsize, (size_t) 1);
   if (!pic24) FatalError("couldn't malloc 'pic24'");
 
 
@@ -134,7 +136,7 @@
       if      (i < h / 2) row = 2 * i;
       else                row = 2 * (i - h/2) + 1;
     }
-    
+
     else row = i;              /* no interlace */
 
 
@@ -150,7 +152,7 @@
 
 
   /* swap R,B values (file is in BGR, pic24 should be in RGB) */
-  for (i=0, pp=pic24; i<w*h; i++, pp+=3) {
+  for (i=0, pp=pic24; i<npixels; i++, pp+=3) {
     c = pp[0];  pp[0] = pp[2];  pp[2] = c;
   }
 
@@ -185,7 +187,7 @@
 
   /* write the header */
   for (i=0; i<12; i++) putc( (i==2) ? 2 : 0, fp);
-  
+
   putc(w&0xff,     fp);
   putc((w>>8)&0xff,fp);
   putc(h&0xff,     fp);
diff -ruN xv-3.10a/xvtext.c xv-3.10a-bugfixes/xvtext.c
--- xv-3.10a/xvtext.c	1995-01-13 15:46:28.000000000 -0800
+++ xv-3.10a-bugfixes/xvtext.c	2004-05-16 18:04:38.000000000 -0700
@@ -1,6 +1,6 @@
 /*
  *  xvtext.c  -  text file display window routines
- * 
+ *
  *  includes:
  *      void CreateTextWins(geom, cmtgeom);
  *      void OpenTextView(text, textlen, title, freeonclose);
@@ -98,8 +98,7 @@
   XSizeHints            hints;
   XSetWindowAttributes  xswa;
   TVINFO               *tv;
-  int                   gx,gy,gw,gh,gset,gx1,gy1;
-  
+
 
   mfwide = monofinfo->max_bounds.width;
   mfhigh = monofinfo->ascent + monofinfo->descent;
@@ -120,10 +119,10 @@
     tv = &tinfo[i];
 
     tv->win = CreateWindow((i<CMTWIN) ? "xv text viewer" : "xv image comments",
-			   "XVtextview", 
-			   (i<CMTWIN) ? geom : cmtgeom, 
-			   defwide, 
-			   (i<CMTWIN) ? defhigh : cmthigh, 
+			   "XVtextview",
+			   (i<CMTWIN) ? geom : cmtgeom,
+			   defwide,
+			   (i<CMTWIN) ? defhigh : cmthigh,
 			   infofg, infobg, 1);
     if (!tv->win) FatalError("can't create textview window!");
 
@@ -135,17 +134,17 @@
 
     /* note: everything is sized and positioned in resizeText() */
 
-    tv->textW = XCreateSimpleWindow(theDisp, tv->win, 1,1, 100,100, 
+    tv->textW = XCreateSimpleWindow(theDisp, tv->win, 1,1, 100,100,
 				     1,infofg,infobg);
     if (!tv->textW) FatalError("can't create textview text window!");
 
-    SCCreate(&(tv->vscrl), tv->win, 0,0, 1,100, 0,0,0,0, 
+    SCCreate(&(tv->vscrl), tv->win, 0,0, 1,100, 0,0,0,0,
 	     infofg, infobg, hicol, locol, drawTextW);
 
-    SCCreate(&(tv->hscrl), tv->win, 0,0, 0,100, 0,0,0,0, 
+    SCCreate(&(tv->hscrl), tv->win, 0,0, 0,100, 0,0,0,0,
 	     infofg, infobg, hicol, locol, drawTextW);
 
-    if (XGetNormalHints(theDisp, tv->win, &hints)) 
+    if (XGetNormalHints(theDisp, tv->win, &hints))
       hints.flags |= PMinSize;
     else
       hints.flags = PMinSize;
@@ -162,7 +161,7 @@
 
     XSelectInput(theDisp, tv->textW, ExposureMask | ButtonPressMask);
 
-    
+
     BTCreate(&(tv->but[TV_ASCII]), tv->win, 0,0,BUTTW,BUTTH,
 	     "Ascii",infofg,infobg,hicol,locol);
     BTCreate(&(tv->but[TV_HEX]), tv->win, 0,0,BUTTW,BUTTH,
@@ -185,7 +184,7 @@
   for (i=0; i<MAXTVWIN; i++) {
     resizeText(&tinfo[i], defwide, (i<CMTWIN) ? defhigh : cmthigh);
 
-    XSelectInput(theDisp, tinfo[i].win, ExposureMask | ButtonPressMask | 
+    XSelectInput(theDisp, tinfo[i].win, ExposureMask | ButtonPressMask |
 		 KeyPressMask | StructureNotifyMask);
   }
 
@@ -200,7 +199,6 @@
 {
   /* given a filename, attempts to read in the file and open a textview win */
 
-  int   i;
   long  textlen;
   char *text, buf[512], title[128], rfname[MAXPATHLEN+1];
   char *basefname[128];  /* just current fname, no path */
@@ -222,7 +220,7 @@
     if (!UncompressFile(basefname, rfname)) return;/* failed to uncompress */
 #endif
   }
-      
+
 
 
   fp = fopen(rfname, "r");
@@ -246,7 +244,7 @@
 
   text = (char *) malloc((size_t) textlen);
   if (!text) {
-    sprintf(buf, "Couldn't malloc %ld bytes to read file '%s'", 
+    sprintf(buf, "Couldn't malloc %ld bytes to read file '%s'",
 	    textlen, rfname);
     ErrPopUp(buf, "\nSo what!");
     fclose(fp);
@@ -267,8 +265,8 @@
   /* note:  text gets freed when window gets closed */
 }
 
-    
-    
+
+
 /***************************************************************/
 void OpenTextView(text, len, title, freeonclose)
      char *text, *title;
@@ -276,7 +274,6 @@
 {
   /* opens up a textview window */
 
-  int     i, oldone;
   TVINFO *tv;
 
   tv = &tinfo[0];
@@ -293,6 +290,7 @@
   tv->textlen     = len;
   tv->freeonclose = freeonclose;
   strncpy(tv->title, title, (size_t) TITLELEN-1);
+  tv->title[TITLELEN-1] = '\0';
 
   computeText(tv);      /* compute # lines and linestarts array */
 
@@ -316,7 +314,6 @@
 {
   /* opens up the reserved 'comment' textview window */
 
-  int     i;
   TVINFO *tv;
 
   tv = &tinfo[CMTWIN];
@@ -351,9 +348,9 @@
   tv->textlen     = (tv->text) ? strlen(tv->text) : 0;
   tv->freeonclose = 0;
 
-  if (strlen(fullfname)) 
+  if (strlen(fullfname))
     sprintf(tv->title, "File: '%s'", BaseName(fullfname));
-  else 
+  else
     sprintf(tv->title, "<no file loaded>");
 
   computeText(tv);      /* compute # lines and linestarts array */
@@ -504,7 +501,7 @@
   if (tv->freeonclose && tv->text)  free(tv->text);
   if (tv->lines) free(tv->lines);
 
-  tv->text  = (char *) NULL;  
+  tv->text  = (char *) NULL;
   tv->lines = (char **) NULL;
   tv->numlines = tv->textlen = tv->hexmode = 0;
 }
@@ -518,7 +515,7 @@
   /* checks event to see if it's a text-window related thing.  If it
      is, it eats the event and returns '1', otherwise '0'. */
 
-  int i, rv;
+  int rv;
 
   rv = 1;
 
@@ -560,7 +557,7 @@
 	count++;
       } while (XCheckWindowEvent(theDisp, evt.xexpose.window,
 				 ExposureMask, &evt));
-      
+
       XClipBox(reg, &rect);  /* bounding box of region */
       XSetRegion(theDisp, theGC, reg);
 
@@ -570,7 +567,7 @@
 	fprintf(stderr,"grouped %d expose events into %d,%d %dx%d rect\n",
 		count, rect.x, rect.y, rect.width, rect.height);
       }
-      
+
       if      (e->window == tv->win)   drawTextView(tv);
       else if (e->window == tv->textW) drawTextW(0, &(tv->vscrl));
 
@@ -584,7 +581,7 @@
 
   else if (xev->type == ButtonPress) {
     XButtonEvent *e = (XButtonEvent *) xev;
-    int i,x,y;
+    int x,y;
     x = e->x;  y = e->y;
 
     if (e->button == Button1) {
@@ -615,7 +612,7 @@
 
       if (tv->wide != e->width || tv->high != e->height) {
 	if (DEBUG) fprintf(stderr,"Forcing a redraw!  (from configure)\n");
-	XClearArea(theDisp, tv->win, 0, 0, 
+	XClearArea(theDisp, tv->win, 0, 0,
 		   (u_int) e->width, (u_int) e->height, True);
 	resizeText(tv, e->width, e->height);
       }
@@ -633,7 +630,7 @@
      TVINFO *tv;
      int     w,h;
 {
-  int        i, maxw, maxh, hmax, hpage, vmax, vpage;
+  int        i, maxw, maxh;
   XSizeHints hints;
 
   if (tv->wide == w && tv->high == h) return;  /* no change in size */
@@ -657,7 +654,7 @@
   tv->twWide = tv->chwide * mfwide + 6;
   tv->twHigh = tv->chhigh * mfhigh + 6;
 
-  XMoveResizeWindow(theDisp, tv->textW, LRMARGINS, TOPMARGIN, 
+  XMoveResizeWindow(theDisp, tv->textW, LRMARGINS, TOPMARGIN,
 		    (u_int) tv->twWide, (u_int) tv->twHigh);
 
   for (i=0; i<TV_NBUTTS; i++) {
@@ -692,8 +689,8 @@
   hpag = tv->chwide / 4;
   vpag = tv->chhigh - 1;
 
-  
-  SCChange(&tv->vscrl, LRMARGINS + tv->twWide+1, TOPMARGIN, 
+
+  SCChange(&tv->vscrl, LRMARGINS + tv->twWide+1, TOPMARGIN,
 	   1, tv->twHigh, 0, vmax, tv->vscrl.val, vpag);
 
   SCChange(&tv->hscrl, LRMARGINS, TOPMARGIN + tv->twHigh + 1,
@@ -731,11 +728,11 @@
     y = 5;
 
     XSetForeground(theDisp, theGC, infobg);
-    XFillRectangle(theDisp, tv->win, theGC, 5+1, y+1, 
+    XFillRectangle(theDisp, tv->win, theGC, 5+1, y+1,
 		   (u_int) StringWidth(tv->title)+6, (u_int) CHIGH+4);
 
     XSetForeground(theDisp, theGC, infofg);
-    XDrawRectangle(theDisp, tv->win, theGC, 5, y, 
+    XDrawRectangle(theDisp, tv->win, theGC, 5, y,
 		   (u_int) StringWidth(tv->title)+7, (u_int) CHIGH+5);
 
     Draw3dRect(tv->win, 5+1, y+1, (u_int) StringWidth(tv->title)+5,
@@ -763,15 +760,15 @@
 
   if (tv->hexmode) nl = tv->hexlines;
   else {
-    if (tv->numlines>0 && 
-	tv->lines[tv->numlines-1] - tv->lines[tv->numlines-2] == 1) 
+    if (tv->numlines>0 &&
+	tv->lines[tv->numlines-1] - tv->lines[tv->numlines-2] == 1)
       nl = tv->numlines - 2;      /* line after last \n has zero length */
     else nl = tv->numlines - 1;
   }
   if (nl<0) nl = 0;
 
-  sprintf(tmpstr, "%d byte%s, %d line%s", 
-	  tv->textlen, (tv->textlen!=1) ? "s" : "", 
+  sprintf(tmpstr, "%d byte%s, %d line%s",
+	  tv->textlen, (tv->textlen!=1) ? "s" : "",
 	  nl, (nl!=1) ? "s" : "");
 
   w = StringWidth(tmpstr) + 7;  /* width of frame */
@@ -779,13 +776,13 @@
   y = 6;
 
   XSetForeground(theDisp, theGC, infobg);
-  XFillRectangle(theDisp, tv->win, theGC, (x-w)+1, y+1, 
+  XFillRectangle(theDisp, tv->win, theGC, (x-w)+1, y+1,
 		 (u_int) (w-1), (u_int) CHIGH+4);
 
   XSetForeground(theDisp, theGC, infofg);
   XDrawRectangle(theDisp, tv->win, theGC, x-w, y, (u_int) w, (u_int) CHIGH+5);
 
-  Draw3dRect(tv->win, (x-w)+1, y+1, (u_int) (w-2), (u_int) CHIGH+3, 
+  Draw3dRect(tv->win, (x-w)+1, y+1, (u_int) (w-2), (u_int) CHIGH+3,
 	     R3D_IN,2,hicol,locol,infobg);
 
   XSetForeground(theDisp, theGC, infofg);
@@ -800,10 +797,10 @@
   int x, y, w, nl;
   char tmpstr[64];
 
-  nl = (tv->hexmode) ? tv->hexlines : tv->numlines-1;                 
+  nl = (tv->hexmode) ? tv->hexlines : tv->numlines-1;
 
-  sprintf(tmpstr, "%d byte%s, %d line%s", 
-	  tv->textlen, (tv->textlen>1) ? "s" : "", 
+  sprintf(tmpstr, "%d byte%s, %d line%s",
+	  tv->textlen, (tv->textlen>1) ? "s" : "",
 	  nl, (nl>1) ? "s" : "");
 
   w = StringWidth(tmpstr) + 7;  /* width of frame */
@@ -825,14 +822,14 @@
   u_char  *sp, *ep, *lp;
 
   /* figure out TVINFO pointer from SCRL pointer */
-  for (i=0; i<MAXTVWIN && sptr != &tinfo[i].vscrl 
+  for (i=0; i<MAXTVWIN && sptr != &tinfo[i].vscrl
        && sptr != &tinfo[i].hscrl; i++);
   if (i==MAXTVWIN) return;   /* didn't find one */
 
   tv = &tinfo[i];
 
   /* make sure we've been sized.  Necessary, as creating/modifying the
-     scrollbar calls this routine directly, rather than through 
+     scrollbar calls this routine directly, rather than through
      TextCheckEvent() */
 
   if (!hasBeenSized) return;
@@ -849,7 +846,7 @@
     for (i=0; i<tv->chhigh; i++) {    /* draw each line */
       lnum = i + tv->vscrl.val;
       if (lnum < tv->numlines-1) {
-	
+
 	/* find start of displayed portion of line.  This is *wildly*
 	   complicated by the ctrl-character and tab expansion... */
 
@@ -902,7 +899,7 @@
 	      if      (extrach == 2) *lp = '^';
 	      else if (extrach == 1) *lp = *sp + 64;
 	    }
-      
+
 	    else if (*sp > 127) {
 	      if (!extrach) extrach = 4;
 	      if      (extrach == 4) *lp = '\\';
@@ -926,7 +923,7 @@
       }
 
       /* draw the line */
-      XDrawImageString(theDisp, tv->textW, theGC, 
+      XDrawImageString(theDisp, tv->textW, theGC,
 		       3, i*mfhigh + 3 + mfascent, linestr, lwide);
     }  /* for i ... */
   }  /* if hexmode */
@@ -936,7 +933,7 @@
     for (i=0; i<tv->chhigh; i++) {    /* draw each line */
       lnum = i + tv->vscrl.val;
       if (lnum < tv->hexlines) {
-	
+
 	char hexstr[80], tmpstr[16];
 
 	/* generate hex for this line */
@@ -972,7 +969,7 @@
 	   now build 'linestr', which is going to have hexstr shifted
 	   and/or padded with blanks  (ie, the displayed portion or hexstr) */
 
-	/* skip obscured beginning of line, if any */ 
+	/* skip obscured beginning of line, if any */
 	for (cpos=0, sp=(byte *) hexstr; cpos<hpos && *sp;  cpos++, sp++);
 
 	for (cpos=0, lp=(byte *)linestr;  cpos<lwide; cpos++, lp++) {
@@ -985,16 +982,16 @@
       }
 
       /* draw the line */
-      XDrawImageString(theDisp, tv->textW, theGC, 
+      XDrawImageString(theDisp, tv->textW, theGC,
 		       3, i*mfhigh + 3 + mfascent, linestr, lwide);
     }  /* for i ... */
   }  /* else hexmode */
-    
+
 
 
   XSetFont(theDisp, theGC, mfont);
 
-  Draw3dRect(tv->textW, 0, 0, (u_int) (tv->twWide-1), (u_int) (tv->twHigh-1), 
+  Draw3dRect(tv->textW, 0, 0, (u_int) (tv->twWide-1), (u_int) (tv->twHigh-1),
 	     R3D_IN, 2, hicol, locol, infobg);
 }
 
@@ -1033,7 +1030,7 @@
   stlen = XLookupString(kevt, buf, 128, &ks, (XComposeStatus *) NULL);
   shift = kevt->state & ShiftMask;
   ck    = CursorKey(ks, shift, 1);
-  dealt = 1;  
+  dealt = 1;
 
   RemapKeyCheck(ks, buf, &stlen);
 
@@ -1060,8 +1057,6 @@
      TVINFO *tv;
      int     key;
 {
-  int i,j;
-
   if (!tv->textlen) return;
 
   /* an arrow key (or something like that) was pressed in icon window.
@@ -1108,7 +1103,7 @@
   else {  /* switch to ascii mode */
     pos = oldvscrl * 16;
     for (i=0; i<tv->numlines-1; i++) {
-      if (tv->lines[i+1] - tv->text > pos && 
+      if (tv->lines[i+1] - tv->text > pos &&
 	  tv->lines[i]   - tv->text <= pos) break;
     }
     if (i<tv->numlines-1) SCSetVal(&tv->vscrl, i);
@@ -1127,9 +1122,9 @@
   int   i,j,wide,maxwide,space;
   byte *sp;
 
-  if (!tv->text) { 
-    tv->numlines = tv->hexlines = 0;  
-    tv->lines = (char **) NULL; 
+  if (!tv->text) {
+    tv->numlines = tv->hexlines = 0;
+    tv->lines = (char **) NULL;
     return;
   }
 
@@ -1153,8 +1148,8 @@
 
   tv->lines[tv->numlines - 1] = tv->text + tv->textlen + 1;
 
-  /* each line has a trailing '\n' character, except for the last line, 
-     which has a trailing '\0' character.  In any case, all lines can 
+  /* each line has a trailing '\n' character, except for the last line,
+     which has a trailing '\0' character.  In any case, all lines can
      be printed by printing ((lines[n+1] - lines[n]) - 1) characters,
      starting with lines[n].
 
@@ -1164,13 +1159,13 @@
 
   /* compute length of longest line, when shown in 'ascii' mode.  Takes
      into account the fact that non-printing chars (<32 or >127) will be
-     shown in an 'expanded' form.  (<32 chars will be shown as '^A' 
+     shown in an 'expanded' form.  (<32 chars will be shown as '^A'
      (or whatever), and >127 chars will be shown as octal '\275') */
 
   maxwide = 0;
   for (i=0; i<tv->numlines-1; i++) {
     /* compute displayed width of line #i */
-    for (sp=(byte *) tv->lines[i], wide=0; sp<(byte *) tv->lines[i+1]-1; 
+    for (sp=(byte *) tv->lines[i], wide=0; sp<(byte *) tv->lines[i+1]-1;
 	 sp++) {
       if (*sp == '\011') {   /* tab to next multiple of 8 */
 	space = ((wide+8) & (~7)) - wide;
diff -ruN xv-3.10a/xvtiff.c xv-3.10a-bugfixes/xvtiff.c
--- xv-3.10a/xvtiff.c	1995-01-13 11:53:34.000000000 -0800
+++ xv-3.10a-bugfixes/xvtiff.c	2005-03-27 17:25:31.000000000 -0800
@@ -1,7 +1,7 @@
 /*
  * xvtiff.c - load routine for 'TIFF' format pictures
  *
- * LoadTIFF(fname, numcols)  -  load a TIFF file
+ * LoadTIFF(fname, numcols, quick)  -  load a TIFF file
  */
 
 #ifndef va_start
@@ -15,6 +15,35 @@
 #include "tiffio.h"     /* has to be after xv.h, as it needs varargs/stdarg */
 
 
+/* Portions fall under the following copyright:
+ *
+ * Copyright (c) 1992, 1993, 1994 Sam Leffler
+ * Copyright (c) 1992, 1993, 1994 Silicon Graphics, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that (i) the above copyright notices and this permission notice appear in
+ * all copies of the software and related documentation, and (ii) the names of
+ * Sam Leffler and Silicon Graphics may not be used in any advertising or
+ * publicity relating to the software without the specific, prior written
+ * permission of Sam Leffler and Silicon Graphics.
+ *
+ * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
+ * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+ * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+ * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
+ * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+
+static int   copyTiff    PARM((TIFF *, char *));
+static int   cpStrips    PARM((TIFF *, TIFF *));
+static int   cpTiles     PARM((TIFF *, TIFF *));
 static byte *loadPalette PARM((TIFF *, uint32, uint32, int, int, PICINFO *));
 static byte *loadColor   PARM((TIFF *, uint32, uint32, int, int, PICINFO *));
 static int   loadImage   PARM((TIFF *, uint32, uint32, byte *, int));
@@ -28,19 +57,23 @@
 static int   error_occurred;
 
 /*******************************************/
-int LoadTIFF(fname, pinfo)
-     char *fname;
+int LoadTIFF(fname, pinfo, quick)
+     char    *fname;
      PICINFO *pinfo;
+     int      quick;
 /*******************************************/
 {
   /* returns '1' on success, '0' on failure */
 
   TIFF  *tif;
   uint32 w, h;
+  float  xres, yres;
   short	 bps, spp, photo, orient;
   FILE  *fp;
   byte  *pic8;
   char  *desc, oldpath[MAXPATHLEN+1], tmppath[MAXPATHLEN+1], *sp;
+  char   tmp[256], tmpname[256];
+  int    i, nump;
 
   error_occurred = 0;
 
@@ -60,6 +93,8 @@
   filesize = ftell(fp);
   fclose(fp);
 
+
+
   rmap = pinfo->r;  gmap = pinfo->g;  bmap = pinfo->b;
 
   /* a kludge:  temporarily cd to the directory that the file is in (if
@@ -80,10 +115,61 @@
       else filename = BaseName(fname);
     }
   }
-      
-    
 
-  tif=TIFFOpen(filename,"r");
+
+  nump = 1;
+
+  if (!quick) {
+    /* see if there's more than 1 image in tiff file, to determine if we
+       should do multi-page thing... */
+
+    tif = TIFFOpen(filename,"r");
+    if (!tif) return 0;
+    while (TIFFReadDirectory(tif)) nump++;
+    TIFFClose(tif);
+    if (DEBUG)
+      fprintf(stderr,"LoadTIFF: %d page%s found\n", nump, nump==1 ? "" : "s");
+
+
+    /* if there are multiple images, copy them out to multiple tmp files,
+       and load the first one... */
+
+    /* GRR 20050320:  converted this fake mktemp() to use mktemp()/mkstemp()
+       internally (formerly it simply prepended tmpdir to the string and
+       returned immediately) */
+    xv_mktemp(tmpname, "xvpgXXXXXX");
+
+    if (tmpname[0] == '\0') {   /* mktemp() or mkstemp() blew up */
+      sprintf(str,"LoadTIFF: Unable to create temporary filename???");
+      ErrPopUp(str, "\nHow unlikely!");
+      return 0;
+    }
+
+    if (nump>1) {
+      TIFF *in;
+
+      in = TIFFOpen(filename, "r");
+      if (!in) return 0;
+      for (i=1; i<=nump; i++) {
+	sprintf(tmp, "%s%d", tmpname, i);
+	if (!copyTiff(in, tmp)) {
+	  SetISTR(ISTR_WARNING, "LoadTIFF:  Error writing page files!");
+	  break;
+	}
+
+	if (!TIFFReadDirectory(in)) break;
+      }
+      if (DEBUG)
+	fprintf(stderr,"LoadTIFF: %d page%s written\n",
+		i-1, (i-1)==1 ? "" : "s");
+
+      sprintf(tmp, "%s%d", tmpname, 1);           /* open page #1 */
+      filename = tmp;
+    }
+  }  /* if (!quick) ... */
+
+
+  tif = TIFFOpen(filename,"r");
   if (!tif) return 0;
 
   /* flip orientation so that image comes in X order */
@@ -107,6 +193,11 @@
   TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);
   TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photo);
   TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);
+  if ((TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) == 1) &&
+      (TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) == 1)) {
+    normaspect = yres / xres;
+    if (DEBUG) fprintf(stderr,"TIFF aspect = %f\n", normaspect);
+  }
 
   if (spp == 1) {
       pic8 = loadPalette(tif, w, h, photo, bps, pinfo);
@@ -116,19 +207,19 @@
 
   /* try to get comments, if any */
   pinfo->comment = (char *) NULL;
-  
+
   desc = (char *) NULL;
 
   TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &desc);
   if (desc && strlen(desc) > (size_t) 0) {
     /* kludge:  tiff library seems to return bizarre comments */
-    if (strlen(desc)==4 && strcmp(desc, "\367\377\353\370")==0) {} 
+    if (strlen(desc)==4 && strcmp(desc, "\367\377\353\370")==0) {}
     else {
       pinfo->comment = (char *) malloc(strlen(desc) + 1);
       if (pinfo->comment) strcpy(pinfo->comment, desc);
     }
   }
-    
+
   TIFFClose(tif);
 
   /* un-kludge */
@@ -139,6 +230,8 @@
     if (pic8) free(pic8);
     if (pinfo->comment) free(pinfo->comment);
     pinfo->comment = (char *) NULL;
+    if (!quick && nump>1) KillPageFiles(tmpname, nump);
+    SetCursors(-1);
     return 0;
   }
 
@@ -148,15 +241,168 @@
   pinfo->normw = pinfo->w;   pinfo->normh = pinfo->h;
   pinfo->frmType = F_TIFF;
 
+  if (nump>1) strcpy(pinfo->pagebname, tmpname);
+  pinfo->numpages = nump;
 
   if (pinfo->pic) return 1;
 
+
   /* failed.  if we malloc'd a comment, free it */
   if (pinfo->comment) free(pinfo->comment);
   pinfo->comment = (char *) NULL;
 
+  if (!quick && nump>1) KillPageFiles(tmpname, nump);
+  SetCursors(-1);
+
   return 0;
-}  
+}
+
+
+
+
+/*******************************************/
+
+#define CopyField(tag, v) \
+  if (TIFFGetField(in, tag, &v))            TIFFSetField(out, tag, v)
+#define CopyField2(tag, v1, v2) \
+  if (TIFFGetField(in, tag, &v1, &v2))      TIFFSetField(out, tag, v1, v2)
+#define CopyField3(tag, v1, v2, v3) \
+  if (TIFFGetField(in, tag, &v1, &v2, &v3)) TIFFSetField(out, tag, v1, v2, v3)
+
+
+/*******************************************/
+static int copyTiff(in, fname)
+     TIFF *in;
+     char *fname;
+{
+  /* copies tiff (sub)image to given filename.  (Used only for multipage
+     images.)  Returns 0 on error */
+
+  TIFF   *out;
+  short   bitspersample, samplesperpixel, shortv, *shortav;
+  uint32  w, l;
+  float   floatv;
+  char   *stringv;
+  uint32  longv;
+  uint16 *red, *green, *blue, shortv2;
+  int     rv;
+
+  out = TIFFOpen(fname, "w");
+  if (!out) return 0;
+
+  CopyField (TIFFTAG_SUBFILETYPE,     longv);
+  CopyField (TIFFTAG_TILEWIDTH,       w);
+  CopyField (TIFFTAG_TILELENGTH,      l);
+  CopyField (TIFFTAG_IMAGEWIDTH,      w);
+  CopyField (TIFFTAG_IMAGELENGTH,     l);
+  CopyField (TIFFTAG_BITSPERSAMPLE,   bitspersample);
+  CopyField (TIFFTAG_COMPRESSION,     shortv);
+  CopyField (TIFFTAG_PREDICTOR,       shortv);
+  CopyField (TIFFTAG_PHOTOMETRIC,     shortv);
+  CopyField (TIFFTAG_THRESHHOLDING,   shortv);
+  CopyField (TIFFTAG_FILLORDER,       shortv);
+  CopyField (TIFFTAG_ORIENTATION,     shortv);
+  CopyField (TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);
+  CopyField (TIFFTAG_MINSAMPLEVALUE,  shortv);
+  CopyField (TIFFTAG_MAXSAMPLEVALUE,  shortv);
+  CopyField (TIFFTAG_XRESOLUTION,     floatv);
+  CopyField (TIFFTAG_YRESOLUTION,     floatv);
+  CopyField (TIFFTAG_GROUP3OPTIONS,   longv);
+  CopyField (TIFFTAG_GROUP4OPTIONS,   longv);
+  CopyField (TIFFTAG_RESOLUTIONUNIT,  shortv);
+  CopyField (TIFFTAG_PLANARCONFIG,    shortv);
+  CopyField (TIFFTAG_ROWSPERSTRIP,    longv);
+  CopyField (TIFFTAG_XPOSITION,       floatv);
+  CopyField (TIFFTAG_YPOSITION,       floatv);
+  CopyField (TIFFTAG_IMAGEDEPTH,      longv);
+  CopyField (TIFFTAG_TILEDEPTH,       longv);
+  CopyField2(TIFFTAG_EXTRASAMPLES,    shortv, shortav);
+  CopyField3(TIFFTAG_COLORMAP,        red, green, blue);
+  CopyField2(TIFFTAG_PAGENUMBER,      shortv, shortv2);
+  CopyField (TIFFTAG_ARTIST,          stringv);
+  CopyField (TIFFTAG_IMAGEDESCRIPTION,stringv);
+  CopyField (TIFFTAG_MAKE,            stringv);
+  CopyField (TIFFTAG_MODEL,           stringv);
+  CopyField (TIFFTAG_SOFTWARE,        stringv);
+  CopyField (TIFFTAG_DATETIME,        stringv);
+  CopyField (TIFFTAG_HOSTCOMPUTER,    stringv);
+  CopyField (TIFFTAG_PAGENAME,        stringv);
+  CopyField (TIFFTAG_DOCUMENTNAME,    stringv);
+
+  if (TIFFIsTiled(in)) rv = cpTiles (in, out);
+                  else rv = cpStrips(in, out);
+
+  TIFFClose(out);
+  return rv;
+}
+
+
+/*******************************************/
+static int cpStrips(in, out)
+     TIFF *in, *out;
+{
+  tsize_t bufsize;
+  byte *buf;
+
+  bufsize = TIFFStripSize(in);
+  if (bufsize <= 0) return 0;  /* tsize_t is signed */
+  buf = (byte *) malloc((size_t) bufsize);
+  if (buf) {
+    tstrip_t s, ns = TIFFNumberOfStrips(in);
+    uint32 *bytecounts;
+
+    TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);
+    for (s = 0; s < ns; s++) {
+      if (bytecounts[s] > bufsize) {
+	buf = (unsigned char *) realloc(buf, (size_t) bytecounts[s]);
+	if (!buf) return (0);
+	bufsize = bytecounts[s];
+      }
+      if (TIFFReadRawStrip (in,  s, buf, (tsize_t) bytecounts[s]) < 0 ||
+	  TIFFWriteRawStrip(out, s, buf, (tsize_t) bytecounts[s]) < 0) {
+	free(buf);
+	return 0;
+      }
+    }
+    free(buf);
+    return 1;
+  }
+  return 0;
+}
+
+
+/*******************************/
+static int cpTiles(in, out)
+     TIFF *in, *out;
+{
+  tsize_t bufsize;
+  byte   *buf;
+
+  bufsize = TIFFTileSize(in);
+  if (bufsize <= 0) return 0;  /* tsize_t is signed */
+  buf = (unsigned char *) malloc((size_t) bufsize);
+  if (buf) {
+    ttile_t t, nt = TIFFNumberOfTiles(in);
+    uint32 *bytecounts;
+
+    TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);
+    for (t = 0; t < nt; t++) {
+      if (bytecounts[t] > bufsize) {
+	buf = (unsigned char *)realloc(buf, (size_t) bytecounts[t]);
+	if (!buf) return (0);
+	bufsize = bytecounts[t];
+      }
+      if (TIFFReadRawTile (in,  t, buf, (tsize_t) bytecounts[t]) < 0 ||
+	  TIFFWriteRawTile(out, t, buf, (tsize_t) bytecounts[t]) < 0) {
+	free(buf);
+	return 0;
+      }
+    }
+    free(buf);
+    return 1;
+  }
+  return 0;
+}
 
 
 /*******************************************/
@@ -167,6 +413,7 @@
      PICINFO *pinfo;
 {
   byte *pic8;
+  uint32 npixels;
 
   switch (photo) {
   case PHOTOMETRIC_PALETTE:
@@ -178,7 +425,7 @@
   case PHOTOMETRIC_MINISWHITE:
   case PHOTOMETRIC_MINISBLACK:
     pinfo->colType = (bps==1) ? F_BWDITHER : F_GREYSCALE;
-    sprintf(pinfo->fullInfo,"TIFF, %u-bit, %s format.  (%ld bytes)", 
+    sprintf(pinfo->fullInfo,"TIFF, %u-bit, %s format.  (%ld bytes)",
 	    bps,
 	    photo == PHOTOMETRIC_MINISWHITE ? "min-is-white" :
 	    "min-is-black",
@@ -186,9 +433,16 @@
     break;
   }
 
-  sprintf(pinfo->shrtInfo, "%ux%u TIFF.",w,h);
+  sprintf(pinfo->shrtInfo, "%ux%u TIFF.",(u_int) w, (u_int) h);
+
+  npixels = w*h;
+  if (npixels/w != h) {
+    /* SetISTR(ISTR_WARNING, "loadPalette() - image dimensions too large"); */
+    TIFFError(filename, "Image dimensions too large");
+    return (byte *) NULL;
+  }
 
-  pic8 = (byte *) malloc((size_t) w*h);
+  pic8 = (byte *) malloc((size_t) npixels);
   if (!pic8) FatalError("loadPalette() - couldn't malloc 'pic8'");
 
   if (loadImage(tif, w, h, pic8, 0)) return pic8;
@@ -205,19 +459,28 @@
      PICINFO *pinfo;
 {
   byte *pic24, *pic8;
+  uint32 npixels, count;
 
   pinfo->colType = F_FULLCOLOR;
-  sprintf(pinfo->fullInfo, "TIFF, %u-bit, %s format.  (%ld bytes)", 
+  sprintf(pinfo->fullInfo, "TIFF, %u-bit, %s format.  (%ld bytes)",
 	  bps,
 	  (photo == PHOTOMETRIC_RGB ?	"RGB" :
 	   photo == PHOTOMETRIC_YCBCR ?	"YCbCr" :
 	   "???"),
 	  filesize);
 
-  sprintf(pinfo->shrtInfo, "%ux%u TIFF.",w,h);
+  sprintf(pinfo->shrtInfo, "%ux%u TIFF.",(u_int) w, (u_int) h);
+
+  npixels = w*h;
+  count = 3*npixels;
+  if (npixels/w != h || count/3 != npixels) {
+    /* SetISTR(ISTR_WARNING, "loadPalette() - image dimensions too large"); */
+    TIFFError(filename, "Image dimensions too large");
+    return (byte *) NULL;
+  }
 
   /* allocate 24-bit image */
-  pic24 = (byte *) malloc((size_t) w*h*3);
+  pic24 = (byte *) malloc((size_t) count);
   if (!pic24) FatalError("loadColor() - couldn't malloc 'pic24'");
 
   pic8 = (byte *) NULL;
@@ -301,10 +564,10 @@
 static	byte **BWmap;
 static	byte **PALmap;
 
-typedef void (*tileContigRoutine)   PARM((byte*, u_char*, RGBvalue*, 
+typedef void (*tileContigRoutine)   PARM((byte*, u_char*, RGBvalue*,
 					  uint32, uint32, int, int));
 
-typedef void (*tileSeparateRoutine) PARM((byte*, u_char*, u_char*, u_char*, 
+typedef void (*tileSeparateRoutine) PARM((byte*, u_char*, u_char*, u_char*,
                                          RGBvalue*, uint32, uint32, int, int));
 
 
@@ -312,13 +575,13 @@
 
 static int    gt                       PARM((TIFF *, uint32, uint32, byte *));
 static uint32 setorientation           PARM((TIFF *, uint32));
-static int    gtTileContig             PARM((TIFF *, byte *, RGBvalue *, 
+static int    gtTileContig             PARM((TIFF *, byte *, RGBvalue *,
 					     uint32, uint32, int));
-static int    gtTileSeparate           PARM((TIFF *, byte *, RGBvalue *, 
+static int    gtTileSeparate           PARM((TIFF *, byte *, RGBvalue *,
 					     uint32, uint32, int));
-static int    gtStripContig            PARM((TIFF *, byte *, RGBvalue *, 
+static int    gtStripContig            PARM((TIFF *, byte *, RGBvalue *,
 					     uint32, uint32, int));
-static int    gtStripSeparate          PARM((TIFF *, byte *, RGBvalue *, 
+static int    gtStripSeparate          PARM((TIFF *, byte *, RGBvalue *,
 					     uint32, uint32, int));
 
 static int    makebwmap                PARM((void));
@@ -349,18 +612,18 @@
 static void   putRGBcontig16bittile    PARM((byte *, u_short *, RGBvalue *,
 					     uint32, uint32, int, int));
 
-static void   putRGBseparate8bittile   PARM((byte *, u_char *, u_char *, 
-					     u_char *, RGBvalue *, 
+static void   putRGBseparate8bittile   PARM((byte *, u_char *, u_char *,
+					     u_char *, RGBvalue *,
 					     uint32, uint32, int, int));
 
-static void   putRGBseparate16bittile  PARM((byte *, u_short *, u_short *, 
-					    u_short *, RGBvalue *, 
+static void   putRGBseparate16bittile  PARM((byte *, u_short *, u_short *,
+					    u_short *, RGBvalue *,
 					    uint32, uint32, int, int));
 
 
 static void   initYCbCrConversion     PARM((void));
 
-static void   putRGBContigYCbCrClump  PARM((byte *, u_char *, int, int, 
+static void   putRGBContigYCbCrClump  PARM((byte *, u_char *, int, int,
 					    uint32, int, int, int));
 
 static void   putcontig8bitYCbCrtile  PARM((byte *, u_char *, RGBvalue *,
@@ -382,10 +645,10 @@
 
   TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);
   switch (bitspersample) {
-  case 1: 
-  case 2: 
+  case 1:
+  case 2:
   case 4:
-  case 8: 
+  case 8:
   case 16:  break;
 
   default:
@@ -397,8 +660,8 @@
 
   TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);
   switch (samplesperpixel) {
-  case 1: 
-  case 3: 
+  case 1:
+  case 3:
   case 4:  break;
 
   default:
@@ -470,7 +733,7 @@
   TIFFGetFieldDefaulted(tif, TIFFTAG_MINSAMPLEVALUE, &minsamplevalue);
   TIFFGetFieldDefaulted(tif, TIFFTAG_MAXSAMPLEVALUE, &maxsamplevalue);
   Map = NULL;
-  
+
   switch (photometric) {
   case PHOTOMETRIC_YCBCR:
     TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRCOEFFICIENTS,
@@ -481,12 +744,12 @@
 			  &refBlackWhite);
     initYCbCrConversion();
     /* fall thru... */
-	
+
   case PHOTOMETRIC_RGB:
     bpp *= 3;
     if (minsamplevalue == 0 && maxsamplevalue == 255)
       break;
-	
+
     /* fall thru... */
   case PHOTOMETRIC_MINISBLACK:
   case PHOTOMETRIC_MINISWHITE:
@@ -509,7 +772,7 @@
     if (range<256) {
       for (x=0; x<=range; x++) rmap[x] = gmap[x] = bmap[x] = Map[x];
     } else {
-      for (x=0; x<256; x++) 
+      for (x=0; x<256; x++)
 	rmap[x] = gmap[x] = bmap[x] = Map[(range*x)/255];
     }
 
@@ -590,6 +853,8 @@
      TIFF *tif;
      uint32 h;
 {
+  /* note that orientation was flipped in LoadTIFF() (near line 175) */
+
   uint32 y;
 
   TIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &orientation);
@@ -613,6 +878,11 @@
     orientation = ORIENTATION_TOPLEFT;
     /* fall thru... */
   case ORIENTATION_TOPLEFT:
+    /* GRR 20050319:  This may be wrong for tiled images (also stripped?);
+     *   looks like we want to return th-1 instead of h-1 in at least some
+     *   cases.  For now, just added quick hack (USE_TILED_TIFF_BOTLEFT_FIX)
+     *   to gtTileContig().  (Note that, as of libtiff 3.7.1, tiffcp still
+     *   has exactly the same bug.) */
     y = h-1;
     break;
   }
@@ -623,11 +893,11 @@
 
 
 /*
- * Get an tile-organized image that has
+ * Get a tile-organized image that has
  *	PlanarConfiguration contiguous if SamplesPerPixel > 1
  * or
  *	SamplesPerPixel == 1
- */	
+ */
 /*******************************************/
 static int gtTileContig(tif, raster, Map, h, w, bpp)
      TIFF *tif;
@@ -642,11 +912,14 @@
   int fromskew, toskew;
   u_int nrow;
   tileContigRoutine put;
+  tsize_t bufsize;
 
   put = pickTileContigCase(Map);
   if (put == 0) return (0);
 
-  buf = (u_char *) malloc((size_t) TIFFTileSize(tif));
+  bufsize = TIFFTileSize(tif);
+  if (bufsize <= 0) return 0;  /* tsize_t is signed */
+  buf = (u_char *) malloc((size_t) bufsize);
   if (buf == 0) {
     TIFFError(filename, "No space for tile buffer");
     return (0);
@@ -655,12 +928,27 @@
   TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);
   TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);
   y = setorientation(tif, h);
+#ifdef USE_TILED_TIFF_BOTLEFT_FIX  /* image _originally_ ORIENTATION_BOTLEFT */
+  /* this fix causes tiles as a whole to be placed starting at the top,
+   * regardless of orientation; the only difference is what happens within
+   * a given tile (see toskew, below) */
+  /* GRR FIXME:  apply globally in setorientation()? */
+  if (orientation == ORIENTATION_TOPLEFT)
+    y = th-1;
+#endif
+  /* toskew causes individual tiles to copy from bottom to top for
+   * ORIENTATION_TOPLEFT and from top to bottom otherwise */
   toskew = (orientation == ORIENTATION_TOPLEFT ? -tw + -w : -tw + w);
 
   for (row = 0; row < h; row += th) {
     nrow = (row + th > h ? h - row : th);
     for (col = 0; col < w; col += tw) {
-      if (TIFFReadTile(tif,buf,(uint32)col, (uint32)row, 0, 0) < 0
+      /*
+       * This reads the tile at (col,row) into buf.  "The data placed in buf
+       * are returned decompressed and, typically, in the native byte- and
+       * bit-ordering, but are otherwise packed."
+       */
+      if (TIFFReadTile(tif, buf, (uint32)col, (uint32)row, 0, 0) < 0
 	  && stoponerr) break;
 
       if (col + tw > w) {
@@ -670,14 +958,18 @@
 	 */
 	uint32 npix = w - col;
 	fromskew = tw - npix;
-	(*put)(raster + (y*w + col)*bpp, buf, Map,   npix, (uint32) nrow,
-	       fromskew, (int) ((toskew + fromskew)*bpp));
+	(*put)(raster + (y*w + col)*bpp, buf, Map, npix, (uint32) nrow,
+	       fromskew, (int) ((toskew + fromskew)*bpp) );
       } else
-	(*put)(raster + (y*w + col)*bpp, buf, Map,   tw,   (uint32) nrow,
+	(*put)(raster + (y*w + col)*bpp, buf, Map, tw,   (uint32) nrow,
 	       0, (int) (toskew*bpp));
     }
 
+#ifdef USE_TILED_TIFF_BOTLEFT_FIX  /* image _originally_ ORIENTATION_BOTLEFT */
+    y += nrow;
+#else
     y += (orientation == ORIENTATION_TOPLEFT ? -nrow : nrow);
+#endif
   }
   free(buf);
   return (1);
@@ -687,11 +979,11 @@
 
 
 /*
- * Get an tile-organized image that has
+ * Get a tile-organized image that has
  *	 SamplesPerPixel > 1
  *	 PlanarConfiguration separated
  * We assume that all such images are RGB.
- */	
+ */
 
 /*******************************************/
 static int gtTileSeparate(tif, raster, Map, h, w, bpp)
@@ -701,20 +993,26 @@
      uint32 h, w;
      int bpp;
 {
-  uint32 col, row, y;
   uint32 tw, th;
+  uint32 col, row, y;
   u_char *buf;
   u_char *r, *g, *b;
-  int tilesize;
+  tsize_t tilesize;
+  uint32 bufsize;
   int fromskew, toskew;
   u_int nrow;
   tileSeparateRoutine put;
-  
+
   put = pickTileSeparateCase(Map);
   if (put == 0) return (0);
 
   tilesize = TIFFTileSize(tif);
-  buf = (u_char *)malloc((size_t) (3*tilesize));
+  bufsize = 3*tilesize;
+  if (tilesize <= 0 || bufsize/3 != tilesize) {  /* tsize_t is signed */
+    TIFFError(filename, "Image dimensions too large");
+    return 0;
+  }
+  buf = (u_char *) malloc((size_t) bufsize);
   if (buf == 0) {
     TIFFError(filename, "No space for tile buffer");
     return (0);
@@ -751,10 +1049,10 @@
 	 */
 	uint32 npix = w - col;
 	fromskew = tw - npix;
-	(*put)(raster + (y*w + col)*bpp, r, g, b, Map, npix, (uint32) nrow, 
+	(*put)(raster + (y*w + col)*bpp, r, g, b, Map, npix, (uint32) nrow,
 	       fromskew, (int) ((toskew + fromskew)*bpp));
       } else
-	(*put)(raster + (y*w + col)*bpp, r, g, b, Map, tw, (uint32) nrow, 
+	(*put)(raster + (y*w + col)*bpp, r, g, b, Map, tw, (uint32) nrow,
 	       0, (int) (toskew*bpp));
     }
     y += (orientation == ORIENTATION_TOPLEFT ? -nrow : nrow);
@@ -768,7 +1066,7 @@
  *	PlanarConfiguration contiguous if SamplesPerPixel > 1
  * or
  *	SamplesPerPixel == 1
- */	
+ */
 /*******************************************/
 static int gtStripContig(tif, raster, Map, h, w, bpp)
      TIFF *tif;
@@ -784,11 +1082,15 @@
   uint32 imagewidth;
   int scanline;
   int fromskew, toskew;
-  
+  tsize_t bufsize;
+
   put = pickTileContigCase(Map);
   if (put == 0)
     return (0);
-  buf = (u_char *) malloc((size_t) TIFFStripSize(tif));
+
+  bufsize = TIFFStripSize(tif);
+  if (bufsize <= 0) return 0;  /* tsize_t is signed */
+  buf = (u_char *) malloc((size_t) bufsize);
   if (buf == 0) {
     TIFFError(filename, "No space for strip buffer");
     return (0);
@@ -828,20 +1130,29 @@
      uint32 h, w;
      int bpp;
 {
+  uint32 nrow, row, y;
   u_char *buf;
   u_char *r, *g, *b;
-  uint32 row, y, nrow;
+  tsize_t stripsize;
+  uint32 bufsize;
+  int fromskew, toskew;
   int scanline;
   tileSeparateRoutine put;
   uint32 rowsperstrip;
   uint32 imagewidth;
-  u_int stripsize;
-  int fromskew, toskew;
-  
+
   stripsize = TIFFStripSize(tif);
-  r = buf = (u_char *) malloc((size_t) 3*stripsize);
-  if (buf == 0)
+  bufsize = 3*stripsize;
+  if (stripsize <= 0 || bufsize/3 != stripsize) {  /* tsize_t is signed */
+    TIFFError(filename, "Image dimensions too large");
+    return 0;
+  }
+  buf = (u_char *) malloc((size_t) bufsize);
+  if (buf == 0) {
+    TIFFError(filename, "No space for strip buffer");
     return (0);
+  }
+  r = buf;
   g = r + stripsize;
   b = g + stripsize;
   put = pickTileSeparateCase(Map);
@@ -861,7 +1172,7 @@
     nrow = (row + rowsperstrip > h ? h - row : rowsperstrip);
     band = 0;
     if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, (uint32) row, band),
-			     (tdata_t) r, (tsize_t)(nrow*scanline)) < 0 
+			     (tdata_t) r, (tsize_t)(nrow*scanline)) < 0
 	&& stoponerr) break;
 
     band = 1;
@@ -871,7 +1182,7 @@
 
     band = 2;
     if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, (uint32) row, band),
-			     (tdata_t) b, (tsize_t)(nrow*scanline)) < 0 
+			     (tdata_t) b, (tsize_t)(nrow*scanline)) < 0
 	&& stoponerr) break;
 
     (*put)(raster + y*w*bpp, r, g, b, Map, w, nrow, fromskew, toskew*bpp);
@@ -895,7 +1206,7 @@
   register int i;
   int nsamples = 8 / bitspersample;
   register byte *p;
-  
+
   BWmap = (byte **)malloc(
 			  256*sizeof (byte *)+(256*nsamples*sizeof(byte)));
   if (BWmap == NULL) {
@@ -949,7 +1260,7 @@
   register int i;
   int nsamples = 8 / bitspersample;
   register byte *p;
-  
+
   PALmap = (byte **)malloc(
 			   256*sizeof (byte *)+(256*nsamples*sizeof(byte)));
   if (PALmap == NULL) {
@@ -1014,7 +1325,7 @@
 #define	CASE4(x,op)	switch (x) { case 3: op; case 2: op; case 1: op; }
 
 #define	UNROLL8(w, op1, op2) {		\
-	uint32 x;		        \
+	uint32 x;	                \
 	for (x = w; x >= 8; x -= 8) {	\
 		op1;			\
 		REPEAT8(op2);		\
@@ -1026,7 +1337,7 @@
 }
 
 #define	UNROLL4(w, op1, op2) {		\
-	register uint32 x;		\
+	uint32 x;		        \
 	for (x = w; x >= 4; x -= 4) {	\
 		op1;			\
 		REPEAT4(op2);		\
@@ -1038,7 +1349,7 @@
 }
 
 #define	UNROLL2(w, op1, op2) {		\
-	register uint32 x;		\
+	uint32 x;		        \
 	for (x = w; x >= 2; x -= 2) {	\
 		op1;			\
 		REPEAT2(op2);		\
@@ -1048,7 +1359,7 @@
 		op2;			\
 	}				\
 }
-			
+
 
 #define	SKEW(r,g,b,skew)	{ r += skew; g += skew; b += skew; }
 
@@ -1065,7 +1376,7 @@
      int fromskew, toskew;
 {
   while (h-- > 0) {
-    UNROLL8(w,0, *cp++ = PALmap[*pp++][0]);
+    UNROLL8(w, , *cp++ = PALmap[*pp++][0])
     cp += toskew;
     pp += fromskew;
   }
@@ -1082,7 +1393,7 @@
      int       fromskew, toskew;
 {
   register byte *bw;
-  
+
   fromskew /= 2;
   while (h-- > 0) {
     UNROLL2(w, bw = PALmap[*pp++], *cp++ = *bw++);
@@ -1103,7 +1414,7 @@
      int       fromskew, toskew;
 {
   register byte *bw;
-  
+
   fromskew /= 4;
   while (h-- > 0) {
     UNROLL4(w, bw = PALmap[*pp++], *cp++ = *bw++);
@@ -1123,10 +1434,10 @@
 	int       fromskew, toskew;
 {
   register byte *bw;
-  
+
   fromskew /= 8;
   while (h-- > 0) {
-    UNROLL8(w, bw = PALmap[*pp++], *cp++ = *bw++);
+    UNROLL8(w, bw = PALmap[*pp++], *cp++ = *bw++)
     cp += toskew;
     pp += fromskew;
   }
@@ -1164,10 +1475,10 @@
      int fromskew, toskew;
 {
   register byte *bw;
-  
+
   fromskew /= 8;
   while (h-- > 0) {
-    UNROLL8(w, bw = BWmap[*pp++], *cp++ = *bw++);
+    UNROLL8(w, bw = BWmap[*pp++], *cp++ = *bw++)
     cp += toskew;
     pp += fromskew;
   }
@@ -1184,7 +1495,7 @@
      int fromskew, toskew;
 {
   register byte *bw;
-  
+
   fromskew /= 4;
   while (h-- > 0) {
     UNROLL4(w, bw = BWmap[*pp++], *cp++ = *bw++);
@@ -1204,7 +1515,7 @@
      int fromskew, toskew;
 {
   register byte *bw;
-  
+
   fromskew /= 2;
   while (h-- > 0) {
     UNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);
@@ -1224,7 +1535,7 @@
      int fromskew, toskew;
 {
   register uint32   x;
-  
+
   while (h-- > 0) {
     for (x=w; x>0; x--) {
       *cp++ = Map[(pp[0] << 8) + pp[1]];
@@ -1262,11 +1573,11 @@
     }
   } else {
     while (h-- > 0) {
-      UNROLL8(w,0,
+      UNROLL8(w, ,
 	      *cp++ = pp[0];
 	      *cp++ = pp[1];
 	      *cp++ = pp[2];
-	      pp += samplesperpixel);
+	      pp += samplesperpixel)
       cp += toskew;
       pp += fromskew;
     }
@@ -1284,7 +1595,7 @@
      int fromskew, toskew;
 {
   register u_int x;
-  
+
   fromskew *= samplesperpixel;
   if (Map) {
     while (h-- > 0) {
@@ -1320,7 +1631,7 @@
      RGBvalue *Map;
      uint32 w, h;
      int fromskew, toskew;
-     
+
 {
   if (Map) {
     while (h-- > 0) {
@@ -1335,11 +1646,11 @@
     }
   } else {
     while (h-- > 0) {
-      UNROLL8(w,0,
+      UNROLL8(w, ,
 	      *cp++ = *r++;
 	      *cp++ = *g++;
 	      *cp++ = *b++;
-	      );
+	      )
       SKEW(r, g, b, fromskew);
       cp += toskew;
     }
@@ -1357,7 +1668,7 @@
      int fromskew, toskew;
 {
   uint32 x;
-  
+
   if (Map) {
     while (h-- > 0) {
       for (x = w; x > 0; x--) {
@@ -1381,7 +1692,7 @@
   }
 }
 
-#define Code2V(c, RB, RW, CR)  ((((c)-(int)RB)*(float)CR)/(float)(RW-RB))
+#define Code2V(c, RB, RW, CR)  (((((int)c)-(int)RB)*(float)CR)/(float)(RW-RB))
 
 #define	CLAMP(f,min,max) \
     (int)((f)+.5 < (min) ? (min) : (f)+.5 > (max) ? (max) : (f)+.5)
@@ -1391,16 +1702,32 @@
 #define	LumaBlue	YCbCrCoeffs[2]
 
 static	float D1, D2;
-static	float D3, D4, D5;
+static	float D3, D4 /*, D5 */;
 
 
 static void initYCbCrConversion()
 {
+  /*
+   * Old, broken version (goes back at least to 19920426; made worse 19941222):
+   *   YCbCrCoeffs[] = {0.299, 0.587, 0.114}
+   *     D1 = 1.402
+   *     D2 = 0.714136
+   *     D3 = 1.772
+   *     D4 = 0.138691  <-- bogus
+   *     D5 = 1.70358   <-- unnecessary
+   *
+   * New, fixed version (GRR 20050319):
+   *   YCbCrCoeffs[] = {0.299, 0.587, 0.114}
+   *     D1 = 1.402
+   *     D2 = 0.714136
+   *     D3 = 1.772
+   *     D4 = 0.344136
+   */
   D1 = 2 - 2*LumaRed;
   D2 = D1*LumaRed / LumaGreen;
   D3 = 2 - 2*LumaBlue;
-  D4 = D2*LumaBlue / LumaGreen;
-  D5 = 1.0 / LumaGreen;
+  D4 = D3*LumaBlue / LumaGreen;  /* ARGH, used to be D2*LumaBlue/LumaGreen ! */
+/* D5 = 1.0 / LumaGreen; */      /* unnecessary */
 }
 
 static void putRGBContigYCbCrClump(cp, pp, cw, ch, w, n, fromskew, toskew)
@@ -1412,7 +1739,7 @@
 {
   float Cb, Cr;
   int j, k;
-  
+
   Cb = Code2V(pp[n],   refBlackWhite[2], refBlackWhite[3], 127);
   Cr = Code2V(pp[n+1], refBlackWhite[4], refBlackWhite[5], 127);
   for (j = 0; j < ch; j++) {
@@ -1421,8 +1748,24 @@
       Y = Code2V(*pp++,
 		 refBlackWhite[0], refBlackWhite[1], 255);
       R = Y + Cr*D1;
+/*    G = Y*D5 - Cb*D4 - Cr*D2;  highly bogus! */
+      G = Y - Cb*D4 - Cr*D2;
       B = Y + Cb*D3;
-      G = Y*D5 - Cb*D4 - Cr*D2;
+      /*
+       * These are what the JPEG/JFIF equations--which aren't _necessarily_
+       * what JPEG/TIFF uses but which seem close enough--are supposed to be,
+       * according to Avery Lee (e.g., see http://www.fourcc.org/fccyvrgb.php):
+       *
+       *     R = Y + 1.402 (Cr-128)
+       *     G = Y - 0.34414 (Cb-128) - 0.71414 (Cr-128)
+       *     B = Y + 1.772 (Cb-128)
+       *
+       * Translated into xvtiff.c notation:
+       *
+       *     R = Y + Cr*D1
+       *     G = Y - Cb*D4' - Cr*D2   (i.e., omit D5 and fix D4)
+       *     B = Y + Cb*D3
+       */
       cp[3*k+0] = CLAMP(R,0,255);
       cp[3*k+1] = CLAMP(G,0,255);
       cp[3*k+2] = CLAMP(B,0,255);
@@ -1452,7 +1795,7 @@
   u_int Coff = YCbCrVertSampling * YCbCrHorizSampling;
   byte *tp;
   uint32 x;
-  
+
   /* XXX adjust fromskew */
   while (h >= YCbCrVertSampling) {
     tp = cp;
@@ -1481,7 +1824,7 @@
       pp += Coff+2;
     }
     if (x > 0)
-      putRGBContigYCbCrClump(tp, pp, (int) x, (int) h, w, 
+      putRGBContigYCbCrClump(tp, pp, (int) x, (int) h, w,
 			     (int)Coff, (int)(YCbCrHorizSampling-x),toskew);
   }
 }
@@ -1493,7 +1836,7 @@
      RGBvalue* Map;
 {
   tileContigRoutine put = 0;
-  
+
   switch (photometric) {
   case PHOTOMETRIC_RGB:
     switch (bitspersample) {
@@ -1501,7 +1844,7 @@
     case 16: put = (tileContigRoutine) putRGBcontig16bittile;  break;
     }
     break;
-    
+
   case PHOTOMETRIC_PALETTE:
     switch (bitspersample) {
     case 8: put = put8bitcmaptile; break;
@@ -1544,7 +1887,7 @@
      RGBvalue* Map;
 {
   tileSeparateRoutine put = 0;
-  
+
   switch (photometric) {
   case PHOTOMETRIC_RGB:
     switch (bitspersample) {
diff -ruN xv-3.10a/xvtiffwr.c xv-3.10a-bugfixes/xvtiffwr.c
--- xv-3.10a/xvtiffwr.c	1995-01-03 13:28:13.000000000 -0800
+++ xv-3.10a-bugfixes/xvtiffwr.c	2005-03-28 08:39:52.000000000 -0800
@@ -9,15 +9,15 @@
 
 #ifdef HAVE_TIFF
 
-#include "tiffio.h"    /* has to be after xv.h, as it needs varargs/stdarg */
+#include <tiffio.h>    /* has to be after xv.h, as it needs varargs/stdarg */
 
 
 #define ALLOW_JPEG 0  /* set to '1' to allow 'JPEG' choice in dialog box */
 
 
 static void setupColormap   PARM((TIFF *, byte *, byte *, byte *));
-static int  WriteTIFF       PARM((FILE *, byte *, int, int, int, 
-				  byte *, byte *, byte *, int, int, 
+static int  WriteTIFF       PARM((FILE *, byte *, int, int, int,
+				  byte *, byte *, byte *, int, int,
 				  char *, int, char *));
 
 
@@ -29,7 +29,7 @@
 {
   short red[256], green[256], blue[256];
   int i;
-  
+
   /* convert 8-bit colormap to 16-bit */
   for (i=0; i<256; i++) {
 #define	SCALE(x)	((((int)x)*((1L<<16)-1))/255)
@@ -43,6 +43,7 @@
 
 
 /*******************************************/
+/* Returns '0' if successful. */
 static int WriteTIFF(fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,
 		     fname,comp,comment)
      FILE *fp;
@@ -55,6 +56,13 @@
   TIFF *tif;
   byte *pix;
   int   i,j;
+  int   npixels = w*h;
+
+  if (w <= 0 || h <= 0 || npixels/w != h) {
+    SetISTR(ISTR_WARNING, "%s: image dimensions too large", fname);
+    /* TIFFError(fname, "Image dimensions too large"); */
+    return -1;
+  }
 
 #ifndef VMS
   tif = TIFFOpen(fname, "w");
@@ -62,7 +70,7 @@
   tif = TIFFFdOpen(dup(fileno(fp)), fname, "w");
 #endif
 
-  if (!tif) return 0;
+  if (!tif) return -1;   /* GRR:  was 0 */
 
   WaitCursor();
 
@@ -84,19 +92,27 @@
   TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, h);
 
   TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, (int)2);
-  TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)1200.0);
-  TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)1200.0);
+  TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float) 72.0);
+  TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float) 72.0);
 
 
   /* write the image data */
 
   if (ptype == PIC24) {  /* only have to deal with FULLCOLOR or GREYSCALE */
     if (colorstyle == F_FULLCOLOR) {
+      int count = 3*npixels;
+
+      if (count/3 != npixels) {  /* already know w, h, npixels > 0 */
+        /* SetISTR(ISTR_WARNING, "%s: image dimensions too large", fname); */
+        TIFFError(fname, "Image dimensions too large");
+        return -1;
+      }
+
       TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);
       TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,   8);
       TIFFSetField(tif, TIFFTAG_PHOTOMETRIC,     PHOTOMETRIC_RGB);
-      
-      TIFFWriteEncodedStrip(tif, 0, pic, w*h*3);
+
+      TIFFWriteEncodedStrip(tif, 0, pic, count);
     }
 
     else {  /* colorstyle == F_GREYSCALE */
@@ -106,13 +122,13 @@
       TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,   8);
       TIFFSetField(tif, TIFFTAG_PHOTOMETRIC,    PHOTOMETRIC_MINISBLACK);
 
-      tpic = (byte *) malloc((size_t) w*h);
+      tpic = (byte *) malloc((size_t) npixels);
       if (!tpic) FatalError("unable to malloc in WriteTIFF()");
 
-      for (i=0, tp=tpic, sp=pic; i<w*h; i++, sp+=3) 
+      for (i=0, tp=tpic, sp=pic; i<npixels; i++, sp+=3)
 	*tp++ = MONO(sp[0],sp[1],sp[2]);
-      
-      TIFFWriteEncodedStrip(tif, 0, tpic, w*h);
+
+      TIFFWriteEncodedStrip(tif, 0, tpic, npixels);
 
       free(tpic);
     }
@@ -123,32 +139,42 @@
       TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);
       TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);
       setupColormap(tif, rmap, gmap, bmap);
-      TIFFWriteEncodedStrip(tif, 0, pic, w*h);
+      TIFFWriteEncodedStrip(tif, 0, pic, npixels);
     }
 
     else if (colorstyle == F_GREYSCALE) {             /* 8-bit greyscale */
       byte rgb[256];
-      byte *tpic = (byte *) malloc((size_t) w*h);
+      byte *tpic = (byte *) malloc((size_t) npixels);
       byte *tp = tpic;
       TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);
       TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
       for (i=0; i<numcols; i++) rgb[i] = MONO(rmap[i],gmap[i],bmap[i]);
-      for (i=0, pix=pic; i<w*h; i++,pix++) {
+      for (i=0, pix=pic; i<npixels; i++,pix++) {
 	if ((i&0x7fff)==0) WaitCursor();
 	*tp++ = rgb[*pix];
       }
-      TIFFWriteEncodedStrip(tif, 0, tpic, w*h);
+      TIFFWriteEncodedStrip(tif, 0, tpic, npixels);
       free(tpic);
     }
 
     else if (colorstyle == F_BWDITHER) {             /* 1-bit B/W stipple */
       int bit,k,flipbw;
       byte *tpic, *tp;
+      tsize_t stripsize;  /* signed */
 
       flipbw = (MONO(rmap[0],gmap[0],bmap[0]) > MONO(rmap[1],gmap[1],bmap[1]));
       TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 1);
       TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
-      tpic = (byte *) malloc((size_t) TIFFStripSize(tif));
+      stripsize = TIFFStripSize(tif);
+      if (stripsize <= 0) {
+        TIFFError(fname, "Image dimensions too large");
+        return -1;
+      }
+      tpic = (byte *) malloc((size_t) stripsize);
+      if (tpic == 0) {
+        TIFFError(fname, "No space for strip buffer");
+        return -1;
+      }
       tp = tpic;
       for (i=0, pix=pic; i<h; i++) {
 	if ((i&15)==0) WaitCursor();
@@ -167,7 +193,7 @@
 	  *tp++ = (byte) (k & 0xff);
 	}
       }
-      TIFFWriteEncodedStrip(tif, 0, tpic, TIFFStripSize(tif));
+      TIFFWriteEncodedStrip(tif, 0, tpic, stripsize);
       free(tpic);
     }
   }
@@ -209,16 +235,16 @@
 {
   int	     y;
 
-  tiffW = CreateWindow("xv tiff", "XVtiff", NULL, 
+  tiffW = CreateWindow("xv tiff", "XVtiff", NULL,
 		       TWIDE, THIGH, infofg, infobg, 0);
   if (!tiffW) FatalError("can't create tiff window!");
 
   XSelectInput(theDisp, tiffW, ExposureMask | ButtonPressMask | KeyPressMask);
 
-  BTCreate(&tbut[T_BOK], tiffW, TWIDE-140-1, THIGH-10-BUTTH-1, 60, BUTTH, 
+  BTCreate(&tbut[T_BOK], tiffW, TWIDE-140-1, THIGH-10-BUTTH-1, 60, BUTTH,
 	   "Ok", infofg, infobg, hicol, locol);
 
-  BTCreate(&tbut[T_BCANC], tiffW, TWIDE-70-1, THIGH-10-BUTTH-1, 60, BUTTH, 
+  BTCreate(&tbut[T_BCANC], tiffW, TWIDE-70-1, THIGH-10-BUTTH-1, 60, BUTTH,
 	   "Cancel", infofg, infobg, hicol, locol);
 
   y = 55;
@@ -237,7 +263,7 @@
 
   XMapSubwindows(theDisp, tiffW);
 }
-  
+
 
 /***************************************************/
 void TIFFDialog(vis)
@@ -288,9 +314,9 @@
 
   else if (xev->type == KeyPress) {
     XKeyEvent *e = (XKeyEvent *) xev;
-    char buf[128];  KeySym ks;  XComposeStatus status;  
+    char buf[128];  KeySym ks;  XComposeStatus status;
     int stlen;
-	
+
     stlen = XLookupString(e,buf,128,&ks,&status);
     buf[stlen] = '\0';
 
@@ -381,7 +407,7 @@
   /* check BUTTs */
 
   /* check the RBUTTS first, since they don't DO anything */
-  if ( (i=RBClick(compRB, x,y)) >= 0) { 
+  if ( (i=RBClick(compRB, x,y)) >= 0) {
     (void) RBTrack(compRB, i);
     return;
   }
@@ -417,7 +443,7 @@
     }
   }
     break;
-    
+
   case T_BCANC:	TIFFDialog(0);   break;
 
   default:	break;
diff -ruN xv-3.10a/xvxbm.c xv-3.10a-bugfixes/xvxbm.c
--- xv-3.10a/xvxbm.c	1994-12-22 14:34:41.000000000 -0800
+++ xv-3.10a-bugfixes/xvxbm.c	2005-03-28 22:06:50.000000000 -0800
@@ -25,7 +25,7 @@
  *   move forward to next occurence of '0x'
  *   repeat
  */
- 
+
 
 static int xbmError PARM((char *, char *));
 
@@ -59,7 +59,7 @@
 
   /* read width:  skip lines until we hit a #define */
   while (1) {
-    if (!fgets(line,256,fp)) 
+    if (!fgets(line,256,fp))
       return(xbmError(bname, "EOF reached in header info."));
 
     if (strncmp(line,"#define",    (size_t) 7)==0 &&
@@ -70,9 +70,9 @@
 
   /* read height:  skip lines until we hit another #define */
   while (1) {
-    if (!fgets(line,256,fp)) 
+    if (!fgets(line,256,fp))
       return(xbmError(bname, "EOF reached in header info."));
-    
+
     if (strncmp(line,"#define",    (size_t) 7)==0 &&
 	sscanf(line,"#define %s %d", name, &h)==2 &&
 	xv_strstr(name, "_height") != NULL) break;
@@ -84,18 +84,18 @@
   c = getc(fp);  c1 = getc(fp);
   while (c1!=EOF && !(c=='0' && c1=='x') ) { c = c1;  c1 = getc(fp); }
 
-  if (c1==EOF) 
+  if (c1==EOF)
     return(xbmError(bname, "No bitmap data found"));
 
-  if (w<1 || h<1 || w>10000 || h>10000) 
+  if (w<1 || h<1 || w>10000 || h>10000)
     return(xbmError(bname, "not an XBM file"));
-  
-  pic8 = (byte *) calloc((size_t) w*h, (size_t) 1);
+
+  pic8 = (byte *) calloc((size_t) w*h, (size_t) 1);  /* safe (10^8 max) */
   if (!pic8) return(xbmError(bname, "couldn't malloc 'pic8'"));
 
   /* load up the pinfo structure */
   pinfo->pic = pic8;
-  pinfo->w = w;     
+  pinfo->w = w;
   pinfo->h = h;
   pinfo->normw = pinfo->w;   pinfo->normh = pinfo->h;
   pinfo->type = PIC8;
@@ -125,13 +125,13 @@
       if (!bit) {
 	/* get next byte from file.  we're already positioned at it */
 	c = getc(fp);  c1 = getc(fp);
-	if (c<0 || c1<0) { 
-	  /* EOF: break out of loop */	  
+	if (c<0 || c1<0) {
+	  /* EOF: break out of loop */
 	  c=c1='0'; i=h; j=w;
 	  xbmError(bname, "The file would appear to be truncated.");
 	}
 
-	if (hex[c1] == 255) {  
+	if (hex[c1] == 255) {
 	  if (hex[c] == 255) k = 0;   /* no digits after the '0x' ... */
 	  else k = hex[c];
 	}
@@ -149,7 +149,7 @@
   fclose(fp);
 
   return 1;
-}  
+}
 
 
 
@@ -172,7 +172,7 @@
 {
   /* pic is expected to be an array of w*h bytes, each of which is either
      '0' or '1'.
-     The 'darker' of {rmap,gmap,bmap}[0] and {rmap,gmap,bmap}[1] is 
+     The 'darker' of {rmap,gmap,bmap}[0] and {rmap,gmap,bmap}[1] is
      considered black, and the other one, white.
      Some sort of stippling algorithm should've
      been called already to produce pic, otherwise the output won't be at all
@@ -188,7 +188,7 @@
   foo = (char *) index(name,'.');
   if (foo) *foo='\0';                 /* truncated name at first '.' */
 
-  fprintf(fp,"#define %s_width %d\n",name,w);  
+  fprintf(fp,"#define %s_width %d\n",name,w);
   fprintf(fp,"#define %s_height %d\n",name,h);
   fprintf(fp,"static char %s_bits[] = {\n",name);
 
diff -ruN xv-3.10a/xvxpm.c xv-3.10a-bugfixes/xvxpm.c
--- xv-3.10a/xvxpm.c	1994-12-22 14:34:42.000000000 -0800
+++ xv-3.10a-bugfixes/xvxpm.c	2005-03-28 22:22:50.000000000 -0800
@@ -10,7 +10,7 @@
  * format images.
  *
  * Thanks go to Sam Yates (syates@spam.maths.adelaide.edu.au) for
- * provideing inspiration.
+ * providing inspiration.
  */
 
 #define VALUES_LEN	80	/* Max length of values line */
@@ -63,7 +63,7 @@
      PICINFO *pinfo;
 {
   /* returns '1' on success */
-  
+
   FILE    *fp;
   hentry   item;
   int      c;
@@ -73,100 +73,110 @@
   byte    *i_sptr;		/* image search pointer */
   long     filesize;
   int      w, h, nc, cpp, line_pos;
+  int      npixels;
   short    i, j, k;		/* for() loop indexes */
   hentry  *clmp;		/* colormap hash-table */
   hentry  *c_sptr;		/* cmap hash-table search pointer*/
   XColor   col;
-  
+
   bname = BaseName(fname);
   fp = fopen(fname, "r");
   if (!fp)
     return (XpmLoadError(bname, "couldn't open file"));
-  
+
   if (DEBUG)
     printf("LoadXPM(): Loading xpm from %s\n", fname);
-  
+
   fseek(fp, 0L, 2);
   filesize = ftell(fp);
   fseek(fp, 0L, 0);
-  
+
   bufchar = -2;
   in_quote = FALSE;
-  
+
   /* Read in the values line.  It is the first string in the
    * xpm, and contains four numbers.  w, h, num_colors, and
    * chars_per_pixel. */
-  
+
   /* First, get to the first string */
   while (((c = XpmGetc(fp))!=EOF) && (c != '"')) ;
   line_pos = 0;
-  
+
   /* Now, read in the string */
   while (((c = XpmGetc(fp))!=EOF) && (line_pos < VALUES_LEN) && (c != '"')) {
     values[line_pos++] = c;
   }
   if (c != '"')
     return (XpmLoadError(bname, "error parsing values line"));
-  
+
   values[line_pos] = '\0';
   sscanf(values, "%d%d%d%d", &w, &h, &nc, &cpp);
   if (nc <= 0 || cpp <= 0)
     return (XpmLoadError(bname, "No colours in Xpm?"));
-  
+
+  npixels = w * h;
+  if (w <= 0 || h <= 0 || npixels/w != h)
+    return (XpmLoadError(bname, "Image dimensions out of range"));
+
   if (nc > 256)
     pinfo->type = PIC24;
   else
     pinfo->type = PIC8;
-  
+
   if (DEBUG)
     printf("LoadXPM(): reading a %dx%d image (%d colors)\n", w, h, nc);
-  
+
   /* We got this far... */
   WaitCursor();
-  
+
   if (!hash_init(nc))
     return (XpmLoadError(bname, "Not enough memory to hash colormap"));
-  
+
   clmp = (hentry *) malloc(nc * sizeof(hentry)); /* Holds the colormap */
-  if (pinfo->type == PIC8) pic = (byte *) malloc((size_t) (w*h));
-                      else pic = (byte *) malloc((size_t) (w*h*3));
-  
+  if (pinfo->type == PIC8)
+    pic = (byte *) malloc((size_t) npixels);
+  else {
+    int bufsize = 3*npixels;
+    if (bufsize/3 != npixels)
+      return (XpmLoadError(bname, "Image dimensions out of range"));
+    pic = (byte *) malloc((size_t) bufsize);
+  }
+
   if (!clmp || !pic)
     return (XpmLoadError(bname, "Not enough memory to load pixmap"));
-  
+
   c_sptr = clmp;
   i_sptr = pic;
-  
+
   /* initialize the 'hex' array for zippy ASCII-hex -> int conversion */
-  
+
   for (i = 0 ; i < 256 ; i++)   hex[i] = 0;
   for (i = '0'; i <= '9' ; i++) hex[i] = i - '0';
   for (i = 'a'; i <= 'f' ; i++) hex[i] = i - 'a' + 10;
   for (i = 'A'; i <= 'F' ; i++) hex[i] = i - 'A' + 10;
-  
+
   /* Again, we've made progress. */
   WaitCursor();
-  
+
   /* Now, we need to read the colormap. */
   pinfo->colType = F_BWDITHER;
   for (i = 0 ; i < nc ; i++) {
     while (((c = XpmGetc(fp))!=EOF) && (c != '"')) ;
     if (c != '"')
       return (XpmLoadError(bname, "Error reading colormap"));
-    
+
     for (j = 0 ; j < cpp ; j++)
       c_sptr->token[j] = XpmGetc(fp);
     c_sptr->token[j] = '\0';
-    
+
     while (((c = XpmGetc(fp))!=EOF) && ((c == ' ') || (c == '\t'))) ;
     if (c == EOF)		/* The failure condition of getc() */
       return (XpmLoadError(bname, "Error parsing colormap line"));
-    
+
     do {
       char  key[3];
       char  color[40];	/* Need to figure a good size for this... */
-      short hd;		/* Hex digits per R, G, or B */
-      
+
       for (j=0; j<2 && (c != ' ') && (c != '\t') && (c != EOF); j++) {
 	key[j] = c;
 	c = XpmGetc(fp);
@@ -185,14 +195,14 @@
 
       while ((c == ' ') || (c == '\t'))
 	c = XpmGetc(fp);
-      
+
       if (DEBUG > 1)
 	printf("LoadXPM(): Got color key '%s', color '%s'\n",
 	       key, color);
-      
+
       if (key[0] == 's')	/* Don't find a color for a symbolic name */
 	continue;
-      
+
       if (XParseColor(theDisp,theCmap,color,&col)) {
 	if (pinfo->type == PIC8) {
 	  pinfo->r[i] = col.red >> 8;
@@ -201,8 +211,8 @@
 	  c_sptr->cv_index = i;
 
 	  /* Is there a better way to do this? */
-	  if (pinfo->colType != F_FULLCOLOR)
-	    if (pinfo->colType == F_GREYSCALE)
+	  if (pinfo->colType != F_FULLCOLOR) {
+	    if (pinfo->colType == F_GREYSCALE) {
 	      if (pinfo->r[i] == pinfo->g[i] &&
 		  pinfo->g[i] == pinfo->b[i])
 		/* Still greyscale... */
@@ -210,9 +220,9 @@
 	      else
 		/* It's color */
 		pinfo->colType = F_FULLCOLOR;
-	    else
+	    } else {
 	      if (pinfo->r[i] == pinfo->g[i] &&
-		  pinfo->g[i] == pinfo->b[i])
+		  pinfo->g[i] == pinfo->b[i]) {
 		if ((pinfo->r[i] == 0 || pinfo->r[i] == 0xff) &&
 		    (pinfo->g[i] == 0 || pinfo->g[i] == 0xff) &&
 		    (pinfo->b[i] == 0 || pinfo->b[i] == 0xff))
@@ -221,10 +231,12 @@
 		else
 		  /* It's greyscale */
 		  pinfo->colType = F_GREYSCALE;
-	      else
+	      } else
 		/* It's color */
 		pinfo->colType = F_FULLCOLOR;
-	  
+	    }
+	  }
+
 	}
 	else {   /* PIC24 */
 	  c_sptr->cv_rgb[0] = col.red >> 8;
@@ -242,7 +254,7 @@
 	  Timer(1000);
 	  rgb = 0x808080;
 	}
-	
+
 	if (pinfo->type == PIC8) {
 	  pinfo->r[i] = (rgb>>16) & 0xff;
 	  pinfo->g[i] = (rgb>> 8) & 0xff;
@@ -256,39 +268,39 @@
 	}
       }
 
-      
+
       xvbcopy((char *) c_sptr, (char *) &item, sizeof(item));
       hash_insert(&item);
-      
-      if (DEBUG > 1) 
+
+      if (DEBUG > 1)
 	printf("LoadXPM():  Cmap entry %d, 0x%02x 0x%02x 0x%02x, token '%s'\n",
 	       i, pinfo->r[i], pinfo->g[i], pinfo->b[i], c_sptr->token);
-      
+
       if (*key == 'c') {	/* This is the color entry, keep it. */
 	while (c!='"' && c!=EOF) c = XpmGetc(fp);
 	break;
       }
-      
+
     } while (c != '"');
     c_sptr++;
 
     if (!(i%13)) WaitCursor();
   } /* for */
-  
+
 
   if (DEBUG)
     printf("LoadXPM(): Read and stored colormap.\n");
-  
+
   /* Now, read the pixmap. */
   for (i = 0 ; i < h ; i++) {
     while (((c = XpmGetc(fp))!=EOF) && (c != '"')) ;
     if (c != '"')
       return (XpmLoadError(bname, "Error reading colormap"));
-    
+
     for (j = 0 ; j < w ; j++) {
       char pixel[TOKEN_LEN];
       hentry *mapentry;
-      
+
       for (k = 0 ; k < cpp ; k++)
 	pixel[k] = XpmGetc(fp);
       pixel[k] = '\0';
@@ -300,7 +312,7 @@
 		 pixel);
 	return (XpmLoadError(bname, "Can't map resolve into colormap"));
       }
-      
+
       if (pinfo->type == PIC8)
 	*i_sptr++ = mapentry->cv_index;
       else {
@@ -310,27 +322,27 @@
       }
     }  /* for ( j < w ) */
     (void)XpmGetc(fp);		/* Throw away the close " */
-  
+
     if (!(i%7)) WaitCursor();
   }  /* for ( i < h ) */
-  
+
   pinfo->pic = pic;
   pinfo->normw = pinfo->w = w;
   pinfo->normh = pinfo->h = h;
   pinfo->frmType = F_XPM;
 
   if (DEBUG) printf("LoadXPM(): pinfo->colType is %d\n", pinfo->colType);
-  
+
   sprintf(pinfo->fullInfo, "Xpm v3 Pixmap (%ld bytes)", filesize);
   sprintf(pinfo->shrtInfo, "%dx%d Xpm.", w, h);
   pinfo->comment = (char *)NULL;
-  
+
   hash_destroy();
   free(clmp);
-  
+
   if (fp != stdin)
     fclose(fp);
-  
+
   return(1);
 }
 
@@ -349,17 +361,17 @@
      FILE *f;
 {
   int	c, d, lastc;
-  
+
   if (bufchar != -2) {
     /* The last invocation of this routine read the character... */
     c = bufchar;
     bufchar = -2;
     return(c);
   }
-  
+
   if ((c = getc(f)) == EOF)
     return(EOF);
-  
+
   if (c == '"')
     in_quote = !in_quote;
   else if (!in_quote && c == '/') {	/* might be a C-style comment */
@@ -389,14 +401,14 @@
 
 
 /***************************************/
-static int hash(token) 
+static int hash(token)
      char *token;
 {
   int i, sum;
 
   for (i=sum=0; token[i] != '\0'; i++)
     sum += token[i];
-  
+
   sum = sum % hash_len;
   return (sum);
 }
@@ -414,7 +426,7 @@
    */
 
   int i;
-  
+
   hash_len = 257;
 
   hashtab = (hentry **) malloc(sizeof(hentry *) * hash_len);
@@ -425,7 +437,7 @@
 
   for (i = 0 ; i < hash_len ; i++)
     hashtab[i] = NULL;
-  
+
   return 1;
 }
 
@@ -436,22 +448,22 @@
 {
   int     key;
   hentry *tmp;
-  
+
   key = hash(entry->token);
-  
+
   tmp = (hentry *) malloc(sizeof(hentry));
   if (!tmp) {
     SetISTR(ISTR_WARNING, "Couldn't malloc hash entry in LoadXPM()!\n");
     return 0;
   }
-  
+
   xvbcopy((char *)entry, (char *)tmp, sizeof(hentry));
-  
+
   if (hashtab[key]) tmp->next = hashtab[key];
                else tmp->next = NULL;
-  
+
   hashtab[key] = tmp;
-  
+
   return 1;
 }
 
@@ -462,9 +474,9 @@
 {
   int     key;
   hentry *tmp;
-  
+
   key = hash(token);
-  
+
   tmp = hashtab[key];
   while (tmp && strcmp(token, tmp->token)) {
     tmp = tmp->next;
@@ -479,7 +491,7 @@
 {
   int     i;
   hentry *tmp;
-  
+
   for (i=0; i<hash_len; i++) {
     while (hashtab[i]) {
       tmp = hashtab[i]->next;
@@ -487,7 +499,7 @@
       hashtab[i] = tmp;
     }
   }
-  
+
   free(hashtab);
   return;
 }
@@ -508,10 +520,10 @@
   /* Note here, that tokenchars is assumed to contain 64 valid token */
   /* characters.  It's hardcoded to assume this for benefit of generating */
   /* tokens, when there are more than 64^2 colors. */
-  
+
   short	i, imax, j;	/* for() loop indices */
   short	cpp = 0;
-  char	*tokenchars = 
+  char	*tokenchars =
             ".#abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
   char	*tokens;
   char	image_name[256], *foo;
@@ -523,20 +535,21 @@
   long	li;		/* for() loop index */
   int	numcol;
 #endif
-  
-  if (DEBUG)
+
+  if (DEBUG) {
     if (ptype == PIC8)
       printf("WriteXPM(): Write a %d color, colortype %d, PIC8 image.\n",
 	     nc, col);
     else
       printf("WriteXPM(): Write a colortype %d, PIC24 image.\n", col);
-  
+  }
+
   foo = BaseName(name);
   strcpy(image_name, foo);
   foo = (char *)strchr(image_name, '.');
   if (foo)
     *foo = '\0';		/* Truncate name at first '.' */
-  
+
 #ifdef USE_UNFINISHED_24BIT_WRITING_CODE
   if (ptype == PIC24)
     return -1;
@@ -547,15 +560,15 @@
   /* 'packed'.  Code in here to do that should be removed if       */
   /* Conv24to8 is "fixed" to do this...                            */
   /*    Chris P. Ross (cross@eng.umd.edu)  28-Sept-94              */
-  
+
   numcol = 0;
-  
+
   if (ptype == PIC24) {
     /* Reduce to an 8-bit image.  Would be nice to actually write */
     /* the 24-bit image.  I'll have to code that someday...       */
     pic8 = Conv24to8(pic, w, h, 256, rtemp, gtemp, btemp);
     if (!pic8) {
-      SetISTR(ISTR_WARNING, 
+      SetISTR(ISTR_WARNING,
 	      "%s:  Unable to convert to 8-bit image in WriteXPM()",
 	      image_name);
       return 1;
@@ -594,7 +607,7 @@
   }
 #endif
 
-  
+
 #ifdef USE_UNFINISHED_24BIT_WRITING_CODE
   if (ptype == PIC24) cpp = 4;
   else if (numcol > 64) cpp = 2;
@@ -609,7 +622,7 @@
   fprintf(fp, "/* width height num_colors chars_per_pixel */\n");
   fprintf(fp, "\"   %3d   %3d   %6d            %1d\",\n", w, h, numcol, cpp);
   fprintf(fp, "/* colors */\n");
-  
+
   switch (cpp) {
 
   case 1:			/* <= 64 colors; index into tokenchars */
@@ -681,12 +694,12 @@
 
   case 4:
     /* Generate a colormap */
-    
+
     break;
   default:
     break;
   }
-  
+
   if (fprintf(fp, "\"\n};\n") == EOF) {
     return 1;
   } else
diff -ruN xv-3.10a/xvxwd.c xv-3.10a-bugfixes/xvxwd.c
--- xv-3.10a/xvxwd.c	1994-12-22 14:34:40.000000000 -0800
+++ xv-3.10a-bugfixes/xvxwd.c	2005-03-28 22:37:07.000000000 -0800
@@ -1,10 +1,10 @@
-/* 
+/*
  ** Based on xwdtopnm.c - read and write an X11 or X10 window dump file
  **
  ** Modified heavily by Markus Baur (mbaur@ira.uka.de) for use as a part
  ** of xv-2.21, 12/30/92
  **
- ** Hacked up again to support xv-3.00 and XWDs from 64bit machines 
+ ** Hacked up again to support xv-3.00 and XWDs from 64bit machines
  ** (e.g. DEC Alphas), 04/10/94
  **
  ** Copyright (C) 1989, 1991 by Jef Poskanzer.
@@ -19,47 +19,53 @@
  */
 
 #include "xv.h"
+#include <limits.h>             /* for CHAR_BIT */
+
+/* SJT: just in case ... */
+#ifndef CHAR_BIT
+#  define CHAR_BIT 8
+#endif
 
 
 /***************************** x11wd.h *****************************/
 #define X11WD_FILE_VERSION 7
 typedef struct {
-    CARD32 header_size;         /* Size of the entire file header (bytes). */
-    CARD32 file_version;        /* X11WD_FILE_VERSION */
-    CARD32 pixmap_format;       /* Pixmap format */
-    CARD32 pixmap_depth;        /* Pixmap depth */
-    CARD32 pixmap_width;        /* Pixmap width */
-    CARD32 pixmap_height;       /* Pixmap height */
-    CARD32 xoffset;             /* Bitmap x offset */
-    CARD32 byte_order;          /* MSBFirst, LSBFirst */
-    CARD32 bitmap_unit;         /* Bitmap unit */
-    CARD32 bitmap_bit_order;    /* MSBFirst, LSBFirst */
-    CARD32 bitmap_pad;          /* Bitmap scanline pad */
-    CARD32 bits_per_pixel;      /* Bits per pixel */
-    CARD32 bytes_per_line;      /* Bytes per scanline */
-    CARD32 visual_class;        /* Class of colormap */
-    CARD32 red_mask;            /* Z red mask */
-    CARD32 green_mask;          /* Z green mask */
-    CARD32 blue_mask;           /* Z blue mask */
-    CARD32 bits_per_rgb;        /* Log base 2 of distinct color values */
-    CARD32 colormap_entries;    /* Number of entries in colormap */
-    CARD32 ncolors;             /* Number of Color structures */
-    CARD32 window_width;        /* Window width */
-    CARD32 window_height;       /* Window height */
-    CARD32 window_x;            /* Window upper left X coordinate */
-    CARD32 window_y;            /* Window upper left Y coordinate */
-    CARD32 window_bdrwidth;     /* Window border width */
+  CARD32 header_size;         /* Size of the entire file header (bytes). */
+  CARD32 file_version;        /* X11WD_FILE_VERSION */
+  CARD32 pixmap_format;       /* Pixmap format */
+  CARD32 pixmap_depth;        /* Pixmap depth */
+  CARD32 pixmap_width;        /* Pixmap width */
+  CARD32 pixmap_height;       /* Pixmap height */
+  CARD32 xoffset;             /* Bitmap x offset */
+  CARD32 byte_order;          /* MSBFirst, LSBFirst */
+  CARD32 bitmap_unit;         /* Bitmap unit */
+  CARD32 bitmap_bit_order;    /* MSBFirst, LSBFirst */
+  CARD32 bitmap_pad;          /* Bitmap scanline pad */
+  CARD32 bits_per_pixel;      /* Bits per pixel */
+  CARD32 bytes_per_line;      /* Bytes per scanline */
+  CARD32 visual_class;        /* Class of colormap */
+  CARD32 red_mask;            /* Z red mask */
+  CARD32 grn_mask;            /* Z green mask */
+  CARD32 blu_mask;            /* Z blue mask */
+  CARD32 bits_per_rgb;        /* Log base 2 of distinct color values */
+  CARD32 colormap_entries;    /* Number of entries in colormap */
+  CARD32 ncolors;             /* Number of Color structures */
+  CARD32 window_width;        /* Window width */
+  CARD32 window_height;       /* Window height */
+  CARD32 window_x;            /* Window upper left X coordinate */
+  CARD32 window_y;            /* Window upper left Y coordinate */
+  CARD32 window_bdrwidth;     /* Window border width */
 #ifdef WORD64
-    CARD32 header_pad;
+  CARD32 header_pad;
 #endif
-  } X11WDFileHeader;
+} X11WDFileHeader;
 
 typedef struct {
   CARD32 num;
   CARD16 red, green, blue;
-  CARD8  flags;                 /* do_red, do_green, do_blue */
+  CARD8  flags;               /* do_red, do_green, do_blue */
   CARD8  pad;
-  } X11XColor;
+} X11XColor;
 
 
 /*-------------------------------------------------------------------------*/
@@ -67,7 +73,7 @@
 typedef byte pixel;
 
 /* local functions */
-static int    getinit         PARM((FILE *, int*, int*, int*, CARD32 *, 
+static int    getinit         PARM((FILE *, int*, int*, int*, CARD32 *,
 			                          CARD32, PICINFO *));
 static CARD32 getpixnum       PARM((FILE *));
 static int    xwdError        PARM((char *));
@@ -78,19 +84,27 @@
 static int    readbiglong     PARM((FILE *, CARD32 *));
 static int    readlittleshort PARM((FILE *, CARD16 *));
 static int    readlittlelong  PARM((FILE *, CARD32 *));
+#if 0 /* NOTUSED */
 static int    writebigshort   PARM((FILE *, int));
 static int    writebiglong    PARM((FILE *, CARD32));
+#endif
+
+static void   getcolorshift   PARM((CARD32, int *, int *)); /* SJT */
 
+/* SJT: for 16bpp and 24bpp shifts */
+static int    red_shift_right, red_justify_left,
+              grn_shift_right, grn_justify_left,
+              blu_shift_right, blu_justify_left;
 static byte  *pic8, *pic24;
-static CARD32 red_mask, green_mask, blue_mask;
-static int    bits_per_item, bits_used, bit_shift, bits_per_pixel;
+static CARD32 red_mask, grn_mask, blu_mask;
+static int    bits_per_item, bits_used, bit_shift,
+              bits_per_pixel, bits_per_rgb;
 static char   buf[4];
 static char   *byteP;
 static CARD16 *shortP;
 static CARD32 *longP;
 static CARD32 pixel_mask;
 static int    byte_swap, byte_order, bit_order, filesize;
-static byte   bw[2] = {0, 0xff};
 
 static char  *bname;
 
@@ -105,7 +119,7 @@
 
   pixel *xP;
   int    col;
-  int    rows, cols, padright, row;
+  int    rows, cols, padright, row, npixels, bufsize;
   CARD32 maxval, visualclass;
   FILE  *ifp;
 
@@ -116,22 +130,28 @@
 
   ifp = xv_fopen(fname, "r");
   if (!ifp) return (xwdError("can't open file"));
-  
+
   /* figure out the file size (used to check colormap size) */
   fseek(ifp, 0L, 2);
   filesize = ftell(ifp);
   fseek(ifp, 0L, 0);
-  
+
 
   if (getinit(ifp, &cols, &rows, &padright, &visualclass, maxval, pinfo))
     return 0;
 
+  npixels = cols * rows;
+  if (cols <= 0 || rows <= 0 || npixels/cols != rows) {
+    xwdError("Image dimensions out of range");
+    return 0;
+  }
+
 
   switch (visualclass) {
   case StaticGray:
   case GrayScale:
     pinfo->colType = F_GREYSCALE;
-    pic8 = (byte *) calloc((size_t) cols*rows, (size_t) 1);
+    pic8 = (byte *) calloc((size_t) npixels, (size_t) 1);
     if (!pic8) {
       xwdError("couldn't malloc 'pic'");
       return 0;
@@ -140,18 +160,18 @@
     for (row=0; row<rows; row++) {
       for (col=0, xP=pic8+(row*cols); col<cols; col++, xP++)
 	*xP = getpixnum(ifp);
-      
+
       for (col=0; col<padright; col++) getpixnum(ifp);
     }
 
     pinfo->type = PIC8;
     pinfo->pic  = pic8;
-    break;      
+    break;
 
   case StaticColor:
   case PseudoColor:
     pinfo->colType = F_FULLCOLOR;
-    pic8 = (byte *) calloc((size_t) cols*rows, (size_t) 1);
+    pic8 = (byte *) calloc((size_t) npixels, (size_t) 1);
     if (!pic8) {
       xwdError("couldn't malloc 'pic'");
       return 0;
@@ -162,15 +182,20 @@
 	*xP = getpixnum(ifp);
       for (col=0; col<padright; col++) getpixnum(ifp);
     }
-    
+
     pinfo->type = PIC8;
     pinfo->pic  = pic8;
-    break;      
+    break;
 
   case TrueColor:
   case DirectColor:
     pinfo->colType = F_FULLCOLOR;
-    pic24 = (byte *) calloc((size_t) cols*rows*3, (size_t) 1);
+    bufsize = 3*npixels;
+    if (bufsize/3 != npixels) {
+      xwdError("Image dimensions out of range");
+      return 0;
+    }
+    pic24 = (byte *) calloc((size_t) bufsize, (size_t) 1);
     if (!pic24) {
       xwdError("couldn't malloc 'pic24'");
       return 0;
@@ -179,42 +204,44 @@
     for (row=0; row<rows; row++) {
       for (col=0, xP=pic24+(row*cols*3); col<cols; col++) {
 	CARD32 ul;
-	
+
 	ul = getpixnum(ifp);
 	switch (bits_per_pixel) {
-	case 16:
-	  *xP++ = ((ul & red_mask)   >> 0);
-	  *xP++ = ((ul & green_mask) >> 5);
-	  *xP++ = ((ul & blue_mask)  >> 10);
-	  break;
-	  
-	case 24:
-	case 32:
-	  *xP++ = (ul    ) & 0xff;
-	  *xP++ = (ul>> 8) & 0xff;
-	  *xP++ = (ul>>16) & 0xff;
-	  break;
-	  
+        case 16:
+        case 24:
+        case 32:
+          /* SJT: shift all the way to the right and then shift left. The
+             pairs of shifts could be combined. There will be two right and
+             one left shift, but it's unknown which will be which. It seems
+             easier to do the shifts (which might be 0) separately than to
+             have a complex set of tests. I believe this is independent of
+             byte order but I have no way to test.
+           */
+          *xP++ = ((ul & red_mask) >> red_shift_right) << red_justify_left;
+          *xP++ = ((ul & grn_mask) >> grn_shift_right) << grn_justify_left;
+          *xP++ = ((ul & blu_mask) >> blu_shift_right) << blu_justify_left;
+          break;
+
 	default:
-	  xwdError("True/Direct only supports 16, 24, and 32 bits");
+	  xwdError("True/Direct supports only 16, 24, and 32 bits");
 	  return 0;
 	}
       }
 
       for (col=0; col<padright; col++) getpixnum(ifp);
     }
-    
+
     pinfo->type = PIC24;
     pinfo->pic  = pic24;
     break;
-    
+
   default:
     xwdError("unknown visual class");
     return 0;
   }
 
   sprintf(pinfo->fullInfo, "XWD, %d-bit %s.  (%d bytes)",
-	  bits_per_pixel, 
+	  bits_per_pixel,
 	  ((visualclass == StaticGray ) ? "StaticGray"  :
 	   (visualclass == GrayScale  ) ? "GrayScale"   :
 	   (visualclass == StaticColor) ? "StaticColor" :
@@ -258,10 +285,10 @@
   maxv = 255L;
 
   h11P = (X11WDFileHeader*) header;
-  
+
   if (fread(&header[0], sizeof(*h11P), (size_t) 1, file) != 1)
     return(xwdError("couldn't read X11 XWD file header"));
-  
+
   if (h11P->file_version != X11WD_FILE_VERSION) {
     byte_swap = 1;
     h11P->header_size      = bs_long(h11P->header_size);
@@ -279,8 +306,8 @@
     h11P->bytes_per_line   = bs_long(h11P->bytes_per_line);
     h11P->visual_class     = bs_long(h11P->visual_class);
     h11P->red_mask         = bs_long(h11P->red_mask);
-    h11P->green_mask       = bs_long(h11P->green_mask);
-    h11P->blue_mask        = bs_long(h11P->blue_mask);
+    h11P->grn_mask         = bs_long(h11P->grn_mask);
+    h11P->blu_mask         = bs_long(h11P->blu_mask);
     h11P->bits_per_rgb     = bs_long(h11P->bits_per_rgb);
     h11P->colormap_entries = bs_long(h11P->colormap_entries);
     h11P->ncolors          = bs_long(h11P->ncolors);
@@ -294,7 +321,7 @@
   for (i=0; i<h11P->header_size - sizeof(*h11P); i++)
     if (getc(file) == EOF)
       return(xwdError("couldn't read rest of X11 XWD file header"));
-      
+
   /* Check whether we can handle this dump. */
   if (h11P->pixmap_depth > 24)
     return(xwdError("can't handle X11 pixmap_depth > 24"));
@@ -303,27 +330,31 @@
     return(xwdError("can't handle X11 bits_per_rgb > 24"));
 
   if (h11P->pixmap_format != ZPixmap && h11P->pixmap_depth != 1)  {
-    sprintf(errstr, "can't handle X11 pixmap_format %d with depth != 1",
+    sprintf(errstr, "can't handle X11 pixmap_format %ld with depth != 1",
 	    h11P->pixmap_format);
     return(xwdError(errstr));
   }
 
   if (h11P->bitmap_unit != 8 && h11P->bitmap_unit != 16 &&
       h11P->bitmap_unit != 32)  {
-    sprintf(errstr, "X11 bitmap_unit (%d) is non-standard - can't handle",
+    sprintf(errstr, "X11 bitmap_unit (%ld) is non-standard - can't handle",
 	    h11P->bitmap_unit);
     return(xwdError(errstr));
   }
-  
+
   grayscale = 1;
   if (h11P->ncolors > 0) {      /* Read X11 colormap. */
-    x11colors = (X11XColor*) malloc(h11P->ncolors * sizeof(X11XColor));
+    int bufsize = h11P->ncolors * sizeof(X11XColor);
+
+    if (bufsize/sizeof(X11XColor) != h11P->ncolors)
+      return(xwdError("too many colors"));
+    x11colors = (X11XColor*) malloc(bufsize);
     if (!x11colors) return(xwdError("out of memory"));
-    
-    if (h11P->header_size + h11P->ncolors * sizeof(X11XColor) 
+
+    if (h11P->header_size + bufsize
 	+ h11P->pixmap_height * h11P->bytes_per_line + h11P->ncolors * 4
 	== filesize ) word64 = 1;
-    
+
     if (word64) {
       for (i = 0; i < h11P->ncolors; ++i) {
 	if (fread(&pad, sizeof(pad), (size_t) 1, file ) != 1)
@@ -334,11 +365,11 @@
       }
     }
     else {
-      if (fread(x11colors, sizeof(X11XColor), (size_t) h11P->ncolors, file) 
+      if (fread(x11colors, sizeof(X11XColor), (size_t) h11P->ncolors, file)
 	  != h11P->ncolors)
 	return(xwdError("couldn't read X11 XWD colormap"));
     }
-    
+
     for (i = 0; i < h11P->ncolors; ++i) {
       if (byte_swap) {
 	x11colors[i].red   = (CARD16) bs_short(x11colors[i].red);
@@ -356,8 +387,11 @@
 	grayscale = 0;
     }
   }
-  
+
   *visualclassP = h11P->visual_class;
+  /* SJT: FIXME. If bits_per_pixel == 16 maxv could be either 31 or 63.
+     It doesn't matter, though, because maxv is never used beyond here.
+   */
   if (*visualclassP == TrueColor || *visualclassP == DirectColor) {
     if (h11P->bits_per_pixel == 16) maxv = 31;
     else maxv = 255;
@@ -389,24 +423,48 @@
       }
     }
   }
-      
+
   *colsP = h11P->pixmap_width;
   *rowsP = h11P->pixmap_height;
   *padrightP = h11P->bytes_per_line * 8 / h11P->bits_per_pixel -
     h11P->pixmap_width;
-  
+
   bits_per_item  = h11P->bitmap_unit;
-  bits_used      = bits_per_item;
   bits_per_pixel = h11P->bits_per_pixel;
   byte_order     = h11P->byte_order;
   bit_order      = h11P->bitmap_bit_order;
-  
+  bits_per_rgb   = h11P->bits_per_rgb;
+
+
+  /* add sanity-code for freako 'exceed' server, where bitmapunit = 8
+     and bitsperpix = 32 (and depth=24)... */
+
+  if (bits_per_item < bits_per_pixel) {
+    bits_per_item = bits_per_pixel;
+
+    /* round bits_per_item up to next legal value, if necc */
+    if      (bits_per_item <  8) bits_per_item = 8;
+    else if (bits_per_item < 16) bits_per_item = 16;
+    else                         bits_per_item = 32;
+  }
+
+
+  /* which raises the question:  how (can?) you ever have a 24 bits per pix,
+     (ie, 3 bytes, no alpha/padding) */
+
+
+  bits_used      = bits_per_item;
+
   if (bits_per_pixel == sizeof(pixel_mask) * 8)  pixel_mask = (CARD32) -1;
   else pixel_mask = (1 << bits_per_pixel) - 1;
-  
-  red_mask   = h11P->red_mask;
-  green_mask = h11P->green_mask;
-  blue_mask  = h11P->blue_mask;
+
+  red_mask = h11P->red_mask;
+  grn_mask = h11P->grn_mask;
+  blu_mask = h11P->blu_mask;
+
+  getcolorshift(red_mask, &red_shift_right, &red_justify_left);
+  getcolorshift(grn_mask, &grn_shift_right, &grn_justify_left);
+  getcolorshift(blu_mask, &blu_shift_right, &blu_justify_left);
 
   byteP  = (char   *) buf;
   shortP = (CARD16 *) buf;
@@ -416,18 +474,57 @@
 }
 
 
+/* SJT: figure out the proper shifts */
+static void getcolorshift (CARD32 mask, int *rightshift, int *leftshift)
+{
+  int lshift, rshift;
+  unsigned int uu;
+
+  if (mask == 0)
+  {
+    *rightshift = *leftshift = 0;
+    return;
+  }
+
+  uu = mask;
+  lshift = rshift = 0;
+  while ((uu & 0xf) == 0)
+  {
+      rshift += 4;
+      uu >>= 4;
+  }
+  while ((uu & 1) == 0)
+  {
+      rshift++;
+      uu >>= 1;
+  }
+
+  while (uu != 0)
+  {
+      if (uu & 1)
+      {
+          lshift++;
+          uu >>= 1;
+      }
+  }
+  *rightshift = rshift;
+  *leftshift = CHAR_BIT * sizeof(pixel) - lshift;
+  return;
+}
+
+
 /******************************/
 static CARD32 getpixnum(file)
      FILE* file;
 {
   int n;
-  
+
   if (bits_used == bits_per_item) {
     switch (bits_per_item) {
     case 8:
       *byteP = getc(file);
       break;
-      
+
     case 16:
       if (byte_order == MSBFirst) {
 	if (readbigshort(file, shortP) == -1)
@@ -438,7 +535,7 @@
 	  xwdWarning("unexpected EOF");
       }
       break;
-      
+
     case 32:
       if (byte_order == MSBFirst) {
 	if (readbiglong(file, longP) == -1)
@@ -449,41 +546,41 @@
 	  xwdWarning("unexpected EOF");
       }
       break;
-      
+
     default:
       xwdWarning("can't happen");
     }
     bits_used = 0;
-    
+
     if (bit_order == MSBFirst)
       bit_shift = bits_per_item - bits_per_pixel;
     else
       bit_shift = 0;
   }
-  
+
   switch (bits_per_item) {
   case 8:
     n = (*byteP >> bit_shift) & pixel_mask;
     break;
-    
+
   case 16:
     n = (*shortP >> bit_shift) & pixel_mask;
     break;
-    
+
   case 32:
     n = (*longP >> bit_shift) & pixel_mask;
     break;
-    
+
   default:
     n = 0;
     xwdWarning("can't happen");
   }
-  
+
   if (bit_order == MSBFirst) bit_shift -= bits_per_pixel;
                         else bit_shift += bits_per_pixel;
 
   bits_used += bits_per_pixel;
-  
+
   return n;
 }
 
@@ -511,7 +608,7 @@
 
 
 
-/* 
+/*
  * Byte-swapping junk.
  */
 
@@ -537,7 +634,7 @@
 {
   union cheat u;
   unsigned char t;
-  
+
   u.l = l;
   t = u.c[0];  u.c[0] = u.c[3];  u.c[3] = t;
   t = u.c[1];  u.c[1] = u.c[2];  u.c[2] = t;
@@ -549,7 +646,7 @@
 
 
 
-/* 
+/*
  * Endian I/O.
  */
 
@@ -584,7 +681,7 @@
 {
   *sP  =  getc(in) & 0xff;
   *sP |= (getc(in) & 0xff) << 8;
-  
+
   if (ferror(in)) return -1;
   return 0;
 }
@@ -604,6 +701,7 @@
 }
 
 
+#if 0 /* NOTUSED */
 static int writebiglong(out, l)
      FILE* out;
      CARD32 l;
@@ -624,3 +722,4 @@
   putc(s&0xff, out);
   return 0;
 }
+#endif /* 0 (NOTUSED) */
