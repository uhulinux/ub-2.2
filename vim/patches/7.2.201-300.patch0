To: vim-dev@vim.org
Subject: Patch 7.2.201
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.201
Problem:    Cannot copy/paste HTML to/from Firefox via the clipboard.
Solution:   Implement this for GTK.  Add the "html" value to 'clipboard'.
Files:	    runtime/doc/options.txt, src/globals.h, src/gui_gtk_x11.c,
	    src/mbyte.c, src/proto/mbyte.pro, src/option.c


*** ../vim-7.2.200/runtime/doc/options.txt	2009-02-21 20:27:00.000000000 +0100
--- runtime/doc/options.txt	2009-06-12 22:25:22.000000000 +0200
***************
*** 1443,1448 ****
--- 1444,1457 ----
  	autoselectml	Like "autoselect", but for the modeless selection
  			only.  Compare to the 'A' flag in 'guioptions'.
  
+ 	html		When the clipboard contains HTML, use this when
+ 			pasting.  When putting text on the clipboard, mark it
+ 			as HTML.  This works to copy rendered HTML from
+ 			Firefox, paste it as raw HTML in Vim, select the HTML
+ 			in Vim and paste it in a rich edit box in Firefox.
+ 			Only supported for GTK version 2 and later.
+ 			Only available with the |+multi_byte| feature.
+ 
  	exclude:{pattern}
  			Defines a pattern that is matched against the name of
  			the terminal 'term'.  If there is a match, no
*** ../vim-7.2.200/src/globals.h	2009-06-16 15:12:11.000000000 +0200
--- src/globals.h	2009-06-12 21:10:30.000000000 +0200
***************
*** 509,514 ****
--- 509,515 ----
  EXTERN int	clip_unnamed INIT(= FALSE);
  EXTERN int	clip_autoselect INIT(= FALSE);
  EXTERN int	clip_autoselectml INIT(= FALSE);
+ EXTERN int	clip_html INIT(= FALSE);
  EXTERN regprog_T *clip_exclude_prog INIT(= NULL);
  #endif
  
*** ../vim-7.2.200/src/gui_gtk_x11.c	2009-06-16 15:12:11.000000000 +0200
--- src/gui_gtk_x11.c	2009-06-16 14:44:19.000000000 +0200
***************
*** 107,112 ****
--- 107,113 ----
      TARGET_UTF8_STRING,
      TARGET_STRING,
      TARGET_COMPOUND_TEXT,
+     TARGET_HTML,
      TARGET_TEXT,
      TARGET_TEXT_URI_LIST,
      TARGET_TEXT_PLAIN,
***************
*** 123,128 ****
--- 124,130 ----
      {VIMENC_ATOM_NAME,	0, TARGET_VIMENC},
      {VIM_ATOM_NAME,	0, TARGET_VIM},
  #ifdef FEAT_MBYTE
+     {"text/html",	0, TARGET_HTML},
      {"UTF8_STRING",	0, TARGET_UTF8_STRING},
  #endif
      {"COMPOUND_TEXT",	0, TARGET_COMPOUND_TEXT},
***************
*** 140,145 ****
--- 142,148 ----
  {
      {"text/uri-list",	0, TARGET_TEXT_URI_LIST},
  # ifdef FEAT_MBYTE
+     {"text/html",	0, TARGET_HTML},
      {"UTF8_STRING",	0, TARGET_UTF8_STRING},
  # endif
      {"STRING",		0, TARGET_STRING},
***************
*** 178,183 ****
--- 181,187 ----
   * Atoms used to control/reference X11 selections.
   */
  #ifdef FEAT_MBYTE
+ static GdkAtom html_atom = GDK_NONE;
  static GdkAtom utf8_string_atom = GDK_NONE;
  #endif
  #ifndef HAVE_GTK2
***************
*** 1364,1369 ****
--- 1368,1391 ----
  	    else
  		text = tmpbuf_utf8;
  	}
+ 	else if (len >= 2 && text[0] == 0xff && text[1] == 0xfe)
+ 	{
+ 	    vimconv_T conv;
+ 
+ 	    /* UTF-16, we get this for HTML */
+ 	    conv.vc_type = CONV_NONE;
+ 	    convert_setup_ext(&conv, (char_u *)"utf-16le", FALSE, p_enc, TRUE);
+ 
+ 	    if (conv.vc_type != CONV_NONE)
+ 	    {
+ 		text += 2;
+ 		len -= 2;
+ 		tmpbuf = string_convert(&conv, text, &len);
+ 		convert_setup(&conv, NULL, NULL);
+ 	    }
+ 	    if (tmpbuf != NULL)
+ 		text = tmpbuf;
+ 	}
      }
  #else /* !HAVE_GTK2 */
  # ifdef FEAT_MBYTE
***************
*** 1451,1456 ****
--- 1473,1479 ----
  
      if (info != (guint)TARGET_STRING
  #ifdef FEAT_MBYTE
+ 	    && (!clip_html || info != (guint)TARGET_HTML)
  	    && info != (guint)TARGET_UTF8_STRING
  	    && info != (guint)TARGET_VIMENC
  #endif
***************
*** 1486,1491 ****
--- 1509,1548 ----
      }
  
  #ifdef FEAT_MBYTE
+     else if (info == (guint)TARGET_HTML)
+     {
+ 	vimconv_T conv;
+ 
+ 	/* Since we get utf-16, we probably should set it as well. */
+ 	conv.vc_type = CONV_NONE;
+ 	convert_setup_ext(&conv, p_enc, TRUE, (char_u *)"utf-16le", FALSE);
+ 	if (conv.vc_type != CONV_NONE)
+ 	{
+ 	    tmpbuf = string_convert(&conv, string, &length);
+ 	    convert_setup(&conv, NULL, NULL);
+ 	    vim_free(string);
+ 	    string = tmpbuf;
+ 	}
+ 
+ 	/* Prepend the BOM: "fffe" */
+ 	if (string != NULL)
+ 	{
+ 	    tmpbuf = alloc(length + 2);
+ 	    tmpbuf[0] = 0xff;
+ 	    tmpbuf[1] = 0xfe;
+ 	    mch_memmove(tmpbuf + 2, string, (size_t)length);
+ 	    vim_free(string);
+ 	    string = tmpbuf;
+ 	    length += 2;
+ 
+ 	    selection_data->type = selection_data->target;
+ 	    selection_data->format = 16;	/* 16 bits per char */
+ 	    gtk_selection_data_set(selection_data, html_atom, 16,
+ 							      string, length);
+ 	    vim_free(string);
+ 	}
+ 	return;
+     }
      else if (info == (guint)TARGET_VIMENC)
      {
  	int l = STRLEN(p_enc);
***************
*** 3464,3469 ****
--- 3521,3527 ----
  
      /* Initialise atoms */
  #ifdef FEAT_MBYTE
+     html_atom = gdk_atom_intern("text/html", FALSE);
      utf8_string_atom = gdk_atom_intern("UTF8_STRING", FALSE);
  #endif
  #ifndef HAVE_GTK2
***************
*** 6665,6670 ****
--- 6723,6732 ----
  
      for (i = 0; i < N_SELECTION_TARGETS; ++i)
      {
+ #ifdef FEAT_MBYTE
+ 	if (!clip_html && selection_targets[i].info == TARGET_HTML)
+ 	    continue;
+ #endif
  	received_selection = RS_NONE;
  	target = gdk_atom_intern(selection_targets[i].target, FALSE);
  
*** ../vim-7.2.200/src/mbyte.c	2009-06-16 15:12:11.000000000 +0200
--- src/mbyte.c	2009-06-16 15:01:30.000000000 +0200
***************
*** 3265,3271 ****
  
  # if defined(USE_ICONV) || defined(PROTO)
  
! static char_u *iconv_string __ARGS((vimconv_T *vcp, char_u *str, int slen, int *unconvlenp));
  
  /*
   * Call iconv_open() with a check if iconv() works properly (there are broken
--- 3265,3271 ----
  
  # if defined(USE_ICONV) || defined(PROTO)
  
! static char_u *iconv_string __ARGS((vimconv_T *vcp, char_u *str, int slen, int *unconvlenp, int *resultlenp));
  
  /*
   * Call iconv_open() with a check if iconv() works properly (there are broken
***************
*** 3326,3338 ****
   * If "unconvlenp" is not NULL handle the string ending in an incomplete
   * sequence and set "*unconvlenp" to the length of it.
   * Returns the converted string in allocated memory.  NULL for an error.
   */
      static char_u *
! iconv_string(vcp, str, slen, unconvlenp)
      vimconv_T	*vcp;
      char_u	*str;
      int		slen;
      int		*unconvlenp;
  {
      const char	*from;
      size_t	fromlen;
--- 3326,3340 ----
   * If "unconvlenp" is not NULL handle the string ending in an incomplete
   * sequence and set "*unconvlenp" to the length of it.
   * Returns the converted string in allocated memory.  NULL for an error.
+  * If resultlenp is not NULL, sets it to the result length in bytes.
   */
      static char_u *
! iconv_string(vcp, str, slen, unconvlenp, resultlenp)
      vimconv_T	*vcp;
      char_u	*str;
      int		slen;
      int		*unconvlenp;
+     int		*resultlenp;
  {
      const char	*from;
      size_t	fromlen;
***************
*** 3418,3423 ****
--- 3420,3428 ----
  	/* Not enough room or skipping illegal sequence. */
  	done = to - (char *)result;
      }
+ 
+     if (resultlenp != NULL)
+ 	*resultlenp = (int)(to - (char *)result);
      return result;
  }
  
***************
*** 5837,5844 ****
--- 5842,5866 ----
      char_u	*from;
      char_u	*to;
  {
+     return convert_setup_ext(vcp, from, TRUE, to, TRUE);
+ }
+ 
+ /*
+  * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all
+  * "from" unicode charsets be considered utf-8.  Same for "to".
+  */
+     int
+ convert_setup_ext(vcp, from, from_unicode_is_utf8, to, to_unicode_is_utf8)
+     vimconv_T	*vcp;
+     char_u	*from;
+     int		from_unicode_is_utf8;
+     char_u	*to;
+     int		to_unicode_is_utf8;
+ {
      int		from_prop;
      int		to_prop;
+     int		from_is_utf8;
+     int		to_is_utf8;
  
      /* Reset to no conversion. */
  # ifdef USE_ICONV
***************
*** 5856,5892 ****
  
      from_prop = enc_canon_props(from);
      to_prop = enc_canon_props(to);
!     if ((from_prop & ENC_LATIN1) && (to_prop & ENC_UNICODE))
      {
  	/* Internal latin1 -> utf-8 conversion. */
  	vcp->vc_type = CONV_TO_UTF8;
  	vcp->vc_factor = 2;	/* up to twice as long */
      }
!     else if ((from_prop & ENC_LATIN9) && (to_prop & ENC_UNICODE))
      {
  	/* Internal latin9 -> utf-8 conversion. */
  	vcp->vc_type = CONV_9_TO_UTF8;
  	vcp->vc_factor = 3;	/* up to three as long (euro sign) */
      }
!     else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_LATIN1))
      {
  	/* Internal utf-8 -> latin1 conversion. */
  	vcp->vc_type = CONV_TO_LATIN1;
      }
!     else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_LATIN9))
      {
  	/* Internal utf-8 -> latin9 conversion. */
  	vcp->vc_type = CONV_TO_LATIN9;
      }
  #ifdef WIN3264
      /* Win32-specific codepage <-> codepage conversion without iconv. */
!     else if (((from_prop & ENC_UNICODE) || encname2codepage(from) > 0)
! 	    && ((to_prop & ENC_UNICODE) || encname2codepage(to) > 0))
      {
  	vcp->vc_type = CONV_CODEPAGE;
  	vcp->vc_factor = 2;	/* up to twice as long */
! 	vcp->vc_cpfrom = (from_prop & ENC_UNICODE) ? 0 : encname2codepage(from);
! 	vcp->vc_cpto = (to_prop & ENC_UNICODE) ? 0 : encname2codepage(to);
      }
  #endif
  #ifdef MACOS_X
--- 5878,5923 ----
  
      from_prop = enc_canon_props(from);
      to_prop = enc_canon_props(to);
!     if (from_unicode_is_utf8)
! 	from_is_utf8 = from_prop & ENC_UNICODE;
!     else
! 	from_is_utf8 = from_prop == ENC_UNICODE;
!     if (to_unicode_is_utf8)
! 	to_is_utf8 = to_prop & ENC_UNICODE;
!     else
! 	to_is_utf8 = to_prop == ENC_UNICODE;
! 
!     if ((from_prop & ENC_LATIN1) && to_is_utf8)
      {
  	/* Internal latin1 -> utf-8 conversion. */
  	vcp->vc_type = CONV_TO_UTF8;
  	vcp->vc_factor = 2;	/* up to twice as long */
      }
!     else if ((from_prop & ENC_LATIN9) && to_is_utf8)
      {
  	/* Internal latin9 -> utf-8 conversion. */
  	vcp->vc_type = CONV_9_TO_UTF8;
  	vcp->vc_factor = 3;	/* up to three as long (euro sign) */
      }
!     else if (from_is_utf8 && (to_prop & ENC_LATIN1))
      {
  	/* Internal utf-8 -> latin1 conversion. */
  	vcp->vc_type = CONV_TO_LATIN1;
      }
!     else if (from_is_utf8 && (to_prop & ENC_LATIN9))
      {
  	/* Internal utf-8 -> latin9 conversion. */
  	vcp->vc_type = CONV_TO_LATIN9;
      }
  #ifdef WIN3264
      /* Win32-specific codepage <-> codepage conversion without iconv. */
!     else if ((from_is_utf8 || encname2codepage(from) > 0)
! 	    && (to_is_utf8 || encname2codepage(to) > 0))
      {
  	vcp->vc_type = CONV_CODEPAGE;
  	vcp->vc_factor = 2;	/* up to twice as long */
! 	vcp->vc_cpfrom = from_is_utf8 ? 0 : encname2codepage(from);
! 	vcp->vc_cpto = to_is_utf8 ? 0 : encname2codepage(to);
      }
  #endif
  #ifdef MACOS_X
***************
*** 5894,5900 ****
      {
  	vcp->vc_type = CONV_MAC_LATIN1;
      }
!     else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_UNICODE))
      {
  	vcp->vc_type = CONV_MAC_UTF8;
  	vcp->vc_factor = 2;	/* up to twice as long */
--- 5925,5931 ----
      {
  	vcp->vc_type = CONV_MAC_LATIN1;
      }
!     else if ((from_prop & ENC_MACROMAN) && to_is_utf8)
      {
  	vcp->vc_type = CONV_MAC_UTF8;
  	vcp->vc_factor = 2;	/* up to twice as long */
***************
*** 5903,5909 ****
      {
  	vcp->vc_type = CONV_LATIN1_MAC;
      }
!     else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_MACROMAN))
      {
  	vcp->vc_type = CONV_UTF8_MAC;
      }
--- 5934,5940 ----
      {
  	vcp->vc_type = CONV_LATIN1_MAC;
      }
!     else if (from_is_utf8 && (to_prop & ENC_MACROMAN))
      {
  	vcp->vc_type = CONV_UTF8_MAC;
      }
***************
*** 5913,5920 ****
      {
  	/* Use iconv() for conversion. */
  	vcp->vc_fd = (iconv_t)my_iconv_open(
! 		(to_prop & ENC_UNICODE) ? (char_u *)"utf-8" : to,
! 		(from_prop & ENC_UNICODE) ? (char_u *)"utf-8" : from);
  	if (vcp->vc_fd != (iconv_t)-1)
  	{
  	    vcp->vc_type = CONV_ICONV;
--- 5944,5951 ----
      {
  	/* Use iconv() for conversion. */
  	vcp->vc_fd = (iconv_t)my_iconv_open(
! 		to_is_utf8 ? (char_u *)"utf-8" : to,
! 		from_is_utf8 ? (char_u *)"utf-8" : from);
  	if (vcp->vc_fd != (iconv_t)-1)
  	{
  	    vcp->vc_type = CONV_ICONV;
***************
*** 6170,6178 ****
  
  # ifdef USE_ICONV
  	case CONV_ICONV:	/* conversion with output_conv.vc_fd */
! 	    retval = iconv_string(vcp, ptr, len, unconvlenp);
! 	    if (retval != NULL && lenp != NULL)
! 		*lenp = (int)STRLEN(retval);
  	    break;
  # endif
  # ifdef WIN3264
--- 6201,6207 ----
  
  # ifdef USE_ICONV
  	case CONV_ICONV:	/* conversion with output_conv.vc_fd */
! 	    retval = iconv_string(vcp, ptr, len, unconvlenp, lenp);
  	    break;
  # endif
  # ifdef WIN3264
*** ../vim-7.2.200/src/option.c	2009-05-17 13:30:58.000000000 +0200
--- src/option.c	2009-06-12 21:09:51.000000000 +0200
***************
*** 7024,7029 ****
--- 7024,7030 ----
      int		new_unnamed = FALSE;
      int		new_autoselect = FALSE;
      int		new_autoselectml = FALSE;
+     int		new_html = FALSE;
      regprog_T	*new_exclude_prog = NULL;
      char_u	*errmsg = NULL;
      char_u	*p;
***************
*** 7047,7052 ****
--- 7048,7058 ----
  	    new_autoselectml = TRUE;
  	    p += 12;
  	}
+ 	else if (STRNCMP(p, "html", 4) == 0 && (p[4] == ',' || p[4] == NUL))
+ 	{
+ 	    new_html = TRUE;
+ 	    p += 4;
+ 	}
  	else if (STRNCMP(p, "exclude:", 8) == 0 && new_exclude_prog == NULL)
  	{
  	    p += 8;
***************
*** 7068,7073 ****
--- 7074,7080 ----
  	clip_unnamed = new_unnamed;
  	clip_autoselect = new_autoselect;
  	clip_autoselectml = new_autoselectml;
+ 	clip_html = new_html;
  	vim_free(clip_exclude_prog);
  	clip_exclude_prog = new_exclude_prog;
      }
*** ../vim-7.2.200/src/version.c	2009-06-16 15:12:11.000000000 +0200
--- src/version.c	2009-06-16 15:14:02.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     201,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
13. Go to a poetry recital and ask why the poems don't rhyme.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.202
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.202
Problem:    BufWipeout autocommand that edits another buffer causes problems.
Solution:   Check for the situation, give an error and quit the operation.
Files:	    src/fileio.c


*** ../vim-7.2.201/src/fileio.c	2009-05-16 17:29:37.000000000 +0200
--- src/fileio.c	2009-06-11 21:22:37.000000000 +0200
***************
*** 4824,4829 ****
--- 4824,4831 ----
      char_u	*sfname;
  {
  #ifdef FEAT_AUTOCMD
+     buf_T	*buf = curbuf;
+ 
      /* It's like the unnamed buffer is deleted.... */
      if (curbuf->b_p_bl)
  	apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);
***************
*** 4832,4837 ****
--- 4834,4845 ----
      if (aborting())	    /* autocmds may abort script processing */
  	return FAIL;
  # endif
+     if (curbuf != buf)
+     {
+ 	/* We are in another buffer now, don't do the renaming. */
+ 	EMSG(_(e_auchangedbuf));
+ 	return FAIL;
+     }
  #endif
  
      if (setfname(curbuf, fname, sfname, FALSE) == OK)
*** ../vim-7.2.201/src/version.c	2009-06-16 15:23:07.000000000 +0200
--- src/version.c	2009-06-16 15:28:31.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     202,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
14. Put mosquito netting around your work area. Play a tape of jungle
    sounds all day.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.203
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.203
Problem:    When reloading a buffer or doing anything else with a buffer that
	    is not displayed in a visible window, autocommands may be applied
	    to the current window, folds messed up, etc.
Solution:   Instead of using the current window for the hidden buffer use a
	    special window, splitting the current one temporarily.
Files:	    src/fileio.c, src/globals.h, src/gui.c, src/if_perl.xs,
	    src/proto/gui.pro, src/proto/window.pro, src/screen.c,
	    src/structs.h, src/window.c


*** ../vim-7.2.202/src/fileio.c	2009-06-16 15:35:46.000000000 +0200
--- src/fileio.c	2009-06-11 21:22:37.000000000 +0200
***************
*** 8365,8371 ****
  
  	    /* Execute the modeline settings, but don't set window-local
  	     * options if we are using the current window for another buffer. */
! 	    do_modelines(aco.save_curwin == NULL ? OPT_NOWIN : 0);
  
  	    /* restore the current window */
  	    aucmd_restbuf(&aco);
--- 8365,8371 ----
  
  	    /* Execute the modeline settings, but don't set window-local
  	     * options if we are using the current window for another buffer. */
! 	    do_modelines(curwin == aucmd_win ? OPT_NOWIN : 0);
  
  	    /* restore the current window */
  	    aucmd_restbuf(&aco);
***************
*** 8381,8388 ****
  
  /*
   * Prepare for executing autocommands for (hidden) buffer "buf".
!  * Search a window for the current buffer.  Save the cursor position and
!  * screen offset.
   * Set "curbuf" and "curwin" to match "buf".
   * When FEAT_AUTOCMD is not defined another version is used, see below.
   */
--- 8381,8388 ----
  
  /*
   * Prepare for executing autocommands for (hidden) buffer "buf".
!  * Search for a visible window containing the current buffer.  If there isn't
!  * one then use "aucmd_win".
   * Set "curbuf" and "curwin" to match "buf".
   * When FEAT_AUTOCMD is not defined another version is used, see below.
   */
***************
*** 8392,8399 ****
      buf_T	*buf;		/* new curbuf */
  {
      win_T	*win;
! 
!     aco->new_curbuf = buf;
  
      /* Find a window that is for the new buffer */
      if (buf == curbuf)		/* be quick when buf is curbuf */
--- 8392,8400 ----
      buf_T	*buf;		/* new curbuf */
  {
      win_T	*win;
! #ifdef FEAT_WINDOWS
!     int		save_ea;
! #endif
  
      /* Find a window that is for the new buffer */
      if (buf == curbuf)		/* be quick when buf is curbuf */
***************
*** 8407,8448 ****
  	win = NULL;
  #endif
  
!     /*
!      * Prefer to use an existing window for the buffer, it has the least side
!      * effects (esp. if "buf" is curbuf).
!      * Otherwise, use curwin for "buf".  It might make some items in the
!      * window invalid.  At least save the cursor and topline.
!      */
      if (win != NULL)
      {
! 	/* there is a window for "buf", make it the curwin */
! 	aco->save_curwin = curwin;
  	curwin = win;
- 	aco->save_buf = win->w_buffer;
- 	aco->new_curwin = win;
      }
      else
      {
! 	/* there is no window for "buf", use curwin */
! 	aco->save_curwin = NULL;
! 	aco->save_buf = curbuf;
! 	--curbuf->b_nwindows;
  	curwin->w_buffer = buf;
  	++buf->b_nwindows;
  
! 	/* save cursor and topline, set them to safe values */
! 	aco->save_cursor = curwin->w_cursor;
! 	curwin->w_cursor.lnum = 1;
! 	curwin->w_cursor.col = 0;
! 	aco->save_topline = curwin->w_topline;
! 	curwin->w_topline = 1;
! #ifdef FEAT_DIFF
! 	aco->save_topfill = curwin->w_topfill;
! 	curwin->w_topfill = 0;
  #endif
      }
- 
      curbuf = buf;
  }
  
  /*
--- 8408,8460 ----
  	win = NULL;
  #endif
  
!     /* Allocate "aucmd_win" when needed.  If this fails (out of memory) fall
!      * back to using the current window. */
!     if (win == NULL && aucmd_win == NULL)
!     {
! 	win_alloc_aucmd_win();
! 	if (aucmd_win == NULL)
! 	    win = curwin;
!     }
! 
!     aco->save_curwin = curwin;
!     aco->save_curbuf = curbuf;
      if (win != NULL)
      {
! 	/* There is a window for "buf" in the current tab page, make it the
! 	 * curwin.  This is preferred, it has the least side effects (esp. if
! 	 * "buf" is curbuf). */
  	curwin = win;
      }
      else
      {
! 	/* There is no window for "buf", use "aucmd_win".  To minimize the side
! 	 * effects, insert it in a the current tab page.
! 	 * Anything related to a window (e.g., setting folds) may have
! 	 * unexpected results. */
! 	curwin = aucmd_win;
  	curwin->w_buffer = buf;
  	++buf->b_nwindows;
  
! #ifdef FEAT_WINDOWS
! 	/* Split the current window, put the aucmd_win in the upper half. */
! 	make_snapshot(SNAP_AUCMD_IDX);
! 	save_ea = p_ea;
! 	p_ea = FALSE;
! 	(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);
! 	(void)win_comp_pos();   /* recompute window positions */
! 	p_ea = save_ea;
! #endif
! 	/* set cursor and topline to safe values */
! 	curwin_init();
! #ifdef FEAT_VERTSPLIT
! 	curwin->w_wincol = 0;
! 	curwin->w_width = Columns;
  #endif
      }
      curbuf = buf;
+     aco->new_curwin = curwin;
+     aco->new_curbuf = curbuf;
  }
  
  /*
***************
*** 8454,8474 ****
  aucmd_restbuf(aco)
      aco_save_T	*aco;		/* structure holding saved values */
  {
!     if (aco->save_curwin != NULL)
      {
  	/* restore curwin */
  #ifdef FEAT_WINDOWS
  	if (win_valid(aco->save_curwin))
  #endif
  	{
! 	    /* restore the buffer which was previously edited by curwin, if
! 	     * it's still the same window and it's valid */
  	    if (curwin == aco->new_curwin
! 		    && buf_valid(aco->save_buf)
! 		    && aco->save_buf->b_ml.ml_mfp != NULL)
  	    {
  		--curbuf->b_nwindows;
! 		curbuf = aco->save_buf;
  		curwin->w_buffer = curbuf;
  		++curbuf->b_nwindows;
  	    }
--- 8466,8551 ----
  aucmd_restbuf(aco)
      aco_save_T	*aco;		/* structure holding saved values */
  {
! #ifdef FEAT_WINDOWS
!     int dummy;
! #endif
! 
!     if (aco->new_curwin == aucmd_win)
!     {
! 	--curbuf->b_nwindows;
! #ifdef FEAT_WINDOWS
! 	/* Find "aucmd_win", it can't be closed, but it may be in another tab
! 	 * page. */
! 	if (curwin != aucmd_win)
! 	{
! 	    tabpage_T	*tp;
! 	    win_T	*wp;
! 
! 	    FOR_ALL_TAB_WINDOWS(tp, wp)
! 	    {
! 		if (wp == aucmd_win)
! 		{
! 		    if (tp != curtab)
! 			goto_tabpage_tp(tp);
! 		    win_goto(aucmd_win);
! 		    break;
! 		}
! 	    }
! 	}
! 
! 	/* Remove the window and frame from the tree of frames. */
! 	(void)winframe_remove(curwin, &dummy, NULL);
! 	win_remove(curwin, NULL);
! 	last_status(FALSE);	    /* may need to remove last status line */
! 	restore_snapshot(SNAP_AUCMD_IDX, FALSE);
! 	(void)win_comp_pos();   /* recompute window positions */
! 
! 	if (win_valid(aco->save_curwin))
! 	    curwin = aco->save_curwin;
! 	else
! 	    /* Hmm, original window disappeared.  Just use the first one. */
! 	    curwin = firstwin;
! # ifdef FEAT_EVAL
! 	vars_clear(&aucmd_win->w_vars.dv_hashtab);  /* free all w: variables */
! # endif
! #else
! 	curwin = aco->save_curwin;
! #endif
! 	curbuf = curwin->w_buffer;
! 
! 	/* the buffer contents may have changed */
! 	check_cursor();
! 	if (curwin->w_topline > curbuf->b_ml.ml_line_count)
! 	{
! 	    curwin->w_topline = curbuf->b_ml.ml_line_count;
! #ifdef FEAT_DIFF
! 	    curwin->w_topfill = 0;
! #endif
! 	}
! #if defined(FEAT_GUI)
! 	/* Hide the scrollbars from the aucmd_win and update. */
! 	gui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_LEFT], FALSE);
! 	gui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_RIGHT], FALSE);
! 	gui_may_update_scrollbars();
! #endif
!     }
!     else
      {
  	/* restore curwin */
  #ifdef FEAT_WINDOWS
  	if (win_valid(aco->save_curwin))
  #endif
  	{
! 	    /* Restore the buffer which was previously edited by curwin, if
! 	     * it was chagned, we are still the same window and the buffer is
! 	     * valid. */
  	    if (curwin == aco->new_curwin
! 		    && curbuf != aco->new_curbuf
! 		    && buf_valid(aco->new_curbuf)
! 		    && aco->new_curbuf->b_ml.ml_mfp != NULL)
  	    {
  		--curbuf->b_nwindows;
! 		curbuf = aco->new_curbuf;
  		curwin->w_buffer = curbuf;
  		++curbuf->b_nwindows;
  	    }
***************
*** 8477,8510 ****
  	    curbuf = curwin->w_buffer;
  	}
      }
-     else
-     {
- 	/* restore buffer for curwin if it still exists and is loaded */
- 	if (buf_valid(aco->save_buf) && aco->save_buf->b_ml.ml_mfp != NULL)
- 	{
- 	    --curbuf->b_nwindows;
- 	    curbuf = aco->save_buf;
- 	    curwin->w_buffer = curbuf;
- 	    ++curbuf->b_nwindows;
- 	    curwin->w_cursor = aco->save_cursor;
- 	    check_cursor();
- 	    /* check topline < line_count, in case lines got deleted */
- 	    if (aco->save_topline <= curbuf->b_ml.ml_line_count)
- 	    {
- 		curwin->w_topline = aco->save_topline;
- #ifdef FEAT_DIFF
- 		curwin->w_topfill = aco->save_topfill;
- #endif
- 	    }
- 	    else
- 	    {
- 		curwin->w_topline = curbuf->b_ml.ml_line_count;
- #ifdef FEAT_DIFF
- 		curwin->w_topfill = 0;
- #endif
- 	    }
- 	}
-     }
  }
  
  static int	autocmd_nested = FALSE;
--- 8554,8559 ----
***************
*** 9419,9427 ****
      aco_save_T	*aco;		/* structure to save values in */
      buf_T	*buf;		/* new curbuf */
  {
!     aco->save_buf = curbuf;
      curbuf = buf;
      curwin->w_buffer = buf;
  }
  
  /*
--- 9468,9478 ----
      aco_save_T	*aco;		/* structure to save values in */
      buf_T	*buf;		/* new curbuf */
  {
!     aco->save_curbuf = curbuf;
!     --curbuf->b_nwindows;
      curbuf = buf;
      curwin->w_buffer = buf;
+     ++curbuf->b_nwindows;
  }
  
  /*
***************
*** 9432,9439 ****
  aucmd_restbuf(aco)
      aco_save_T	*aco;		/* structure holding saved values */
  {
!     curbuf = aco->save_buf;
      curwin->w_buffer = curbuf;
  }
  
  #endif	/* FEAT_AUTOCMD */
--- 9483,9492 ----
  aucmd_restbuf(aco)
      aco_save_T	*aco;		/* structure holding saved values */
  {
!     --curbuf->b_nwindows;
!     curbuf = aco->save_curbuf;
      curwin->w_buffer = curbuf;
+     ++curbuf->b_nwindows;
  }
  
  #endif	/* FEAT_AUTOCMD */
*** ../vim-7.2.202/src/globals.h	2009-06-16 15:23:07.000000000 +0200
--- src/globals.h	2009-06-12 21:10:30.000000000 +0200
***************
*** 539,544 ****
--- 539,548 ----
  
  EXTERN win_T	*curwin;	/* currently active window */
  
+ #ifdef FEAT_AUTOCMD
+ EXTERN win_T	*aucmd_win;	/* window used in aucmd_prepbuf() */
+ #endif
+ 
  /*
   * The window layout is kept in a tree of frames.  topframe points to the top
   * of the tree.
*** ../vim-7.2.202/src/gui.c	2009-05-21 23:25:38.000000000 +0200
--- src/gui.c	2009-06-11 20:58:05.000000000 +0200
***************
*** 3879,3884 ****
--- 3879,3899 ----
   * Scrollbar stuff:
   */
  
+ /*
+  * Called when something in the window layout has changed.
+  */
+     void
+ gui_may_update_scrollbars()
+ {
+     if (gui.in_use && starting == 0)
+     {
+ 	out_flush();
+ 	gui_init_which_components(NULL);
+ 	gui_update_scrollbars(TRUE);
+     }
+     need_mouse_correct = TRUE;
+ }
+ 
      void
  gui_update_scrollbars(force)
      int		force;	    /* Force all scrollbars to get updated */
*** ../vim-7.2.202/src/if_perl.xs	2008-12-03 13:18:16.000000000 +0100
--- src/if_perl.xs	2009-06-03 17:52:51.000000000 +0200
***************
*** 1234,1240 ****
  		    {
  			ml_delete(lnum, 0);
  			deleted_lines_mark(lnum, 1L);
! 			if (aco.save_buf == curbuf)
  			    check_cursor();
  		    }
  
--- 1236,1242 ----
  		    {
  			ml_delete(lnum, 0);
  			deleted_lines_mark(lnum, 1L);
! 			if (aco.save_curbuf == curbuf)
  			    check_cursor();
  		    }
  
*** ../vim-7.2.202/src/proto/gui.pro	2007-05-05 19:42:19.000000000 +0200
--- src/proto/gui.pro	2009-06-11 20:58:08.000000000 +0200
***************
*** 43,48 ****
--- 43,49 ----
  void gui_create_scrollbar __ARGS((scrollbar_T *sb, int type, win_T *wp));
  scrollbar_T *gui_find_scrollbar __ARGS((long ident));
  void gui_drag_scrollbar __ARGS((scrollbar_T *sb, long value, int still_dragging));
+ void gui_may_update_scrollbars __ARGS((void));
  void gui_update_scrollbars __ARGS((int force));
  int gui_do_scroll __ARGS((void));
  int gui_do_horiz_scroll __ARGS((void));
*** ../vim-7.2.202/src/proto/window.pro	2007-07-26 22:57:45.000000000 +0200
--- src/proto/window.pro	2009-06-10 21:20:39.000000000 +0200
***************
*** 1,6 ****
--- 1,7 ----
  /* window.c */
  void do_window __ARGS((int nchar, long Prenum, int xchar));
  int win_split __ARGS((int size, int flags));
+ int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
  int win_valid __ARGS((win_T *win));
  int win_count __ARGS((void));
  int make_windows __ARGS((int count, int vertical));
***************
*** 10,18 ****
--- 11,21 ----
  void win_close __ARGS((win_T *win, int free_buf));
  void win_close_othertab __ARGS((win_T *win, int free_buf, tabpage_T *tp));
  void win_free_all __ARGS((void));
+ win_T *winframe_remove __ARGS((win_T *win, int *dirp, tabpage_T *tp));
  void close_others __ARGS((int message, int forceit));
  void curwin_init __ARGS((void));
  int win_alloc_first __ARGS((void));
+ void win_alloc_aucmd_win __ARGS((void));
  void win_init_size __ARGS((void));
  void free_tabpage __ARGS((tabpage_T *tp));
  int win_new_tabpage __ARGS((int after));
***************
*** 30,35 ****
--- 33,40 ----
  void win_enter __ARGS((win_T *wp, int undo_sync));
  win_T *buf_jump_open_win __ARGS((buf_T *buf));
  win_T *buf_jump_open_tab __ARGS((buf_T *buf));
+ void win_append __ARGS((win_T *after, win_T *wp));
+ void win_remove __ARGS((win_T *wp, tabpage_T *tp));
  int win_alloc_lines __ARGS((win_T *wp));
  void win_free_lsize __ARGS((win_T *wp));
  void shell_new_rows __ARGS((void));
***************
*** 58,63 ****
--- 63,70 ----
  int min_rows __ARGS((void));
  int only_one_window __ARGS((void));
  void check_lnums __ARGS((int do_curwin));
+ void make_snapshot __ARGS((int idx));
+ void restore_snapshot __ARGS((int idx, int close_curwin));
  int win_hasvertsplit __ARGS((void));
  int match_add __ARGS((win_T *wp, char_u *grp, char_u *pat, int prio, int id));
  int match_delete __ARGS((win_T *wp, int id, int perr));
*** ../vim-7.2.202/src/screen.c	2009-05-17 13:30:58.000000000 +0200
--- src/screen.c	2009-06-10 16:41:45.000000000 +0200
***************
*** 7495,7500 ****
--- 7495,7504 ----
  #endif
  	}
      }
+ #ifdef FEAT_AUTOCMD
+     if (aucmd_win != NULL && win_alloc_lines(aucmd_win) == FAIL)
+ 	outofmem = TRUE;
+ #endif
  #ifdef FEAT_WINDOWS
  give_up:
  #endif
*** ../vim-7.2.202/src/structs.h	2009-05-16 16:36:25.000000000 +0200
--- src/structs.h	2009-06-13 12:51:56.000000000 +0200
***************
*** 1621,1626 ****
--- 1621,1634 ----
  };
  #endif
  
+ #define SNAP_HELP_IDX	0
+ #ifdef FEAT_AUTOCMD
+ # define SNAP_AUCMD_IDX 1
+ # define SNAP_COUNT	2
+ #else
+ # define SNAP_COUNT	1
+ #endif
+ 
  /*
   * Tab pages point to the top frame of each tab page.
   * Note: Most values are NOT valid for the current tab page!  Use "curwin",
***************
*** 1649,1655 ****
      buf_T	    *(tp_diffbuf[DB_COUNT]);
      int		    tp_diff_invalid;	/* list of diffs is outdated */
  #endif
!     frame_T	    *tp_snapshot;    /* window layout snapshot */
  #ifdef FEAT_EVAL
      dictitem_T	    tp_winvar;	    /* variable for "t:" Dictionary */
      dict_T	    tp_vars;	    /* internal variables, local to tab page */
--- 1657,1663 ----
      buf_T	    *(tp_diffbuf[DB_COUNT]);
      int		    tp_diff_invalid;	/* list of diffs is outdated */
  #endif
!     frame_T	    *(tp_snapshot[SNAP_COUNT]);  /* window layout snapshots */
  #ifdef FEAT_EVAL
      dictitem_T	    tp_winvar;	    /* variable for "t:" Dictionary */
      dict_T	    tp_vars;	    /* internal variables, local to tab page */
***************
*** 2276,2291 ****
   */
  typedef struct
  {
!     buf_T	*save_buf;	/* saved curbuf */
  #ifdef FEAT_AUTOCMD
!     buf_T	*new_curbuf;	/* buffer to be used */
!     win_T	*save_curwin;	/* saved curwin, NULL if it didn't change */
!     win_T	*new_curwin;	/* new curwin if save_curwin != NULL */
!     pos_T	save_cursor;	/* saved cursor pos of save_curwin */
!     linenr_T	save_topline;	/* saved topline of save_curwin */
! # ifdef FEAT_DIFF
!     int		save_topfill;	/* saved topfill of save_curwin */
! # endif
  #endif
  } aco_save_T;
  
--- 2284,2294 ----
   */
  typedef struct
  {
!     buf_T	*save_curbuf;	/* saved curbuf */
  #ifdef FEAT_AUTOCMD
!     win_T	*save_curwin;	/* saved curwin */
!     win_T	*new_curwin;	/* new curwin */
!     buf_T	*new_curbuf;	/* new curbuf */
  #endif
  } aco_save_T;
  
*** ../vim-7.2.202/src/window.c	2009-05-21 23:25:38.000000000 +0200
--- src/window.c	2009-06-12 22:29:33.000000000 +0200
***************
*** 11,18 ****
  
  static int path_is_url __ARGS((char_u *p));
  #if defined(FEAT_WINDOWS) || defined(PROTO)
- static int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
  static void win_init __ARGS((win_T *newp, win_T *oldp, int flags));
  static void frame_comp_pos __ARGS((frame_T *topfrp, int *row, int *col));
  static void frame_setheight __ARGS((frame_T *curfrp, int height));
  #ifdef FEAT_VERTSPLIT
--- 11,18 ----
  
  static int path_is_url __ARGS((char_u *p));
  #if defined(FEAT_WINDOWS) || defined(PROTO)
  static void win_init __ARGS((win_T *newp, win_T *oldp, int flags));
+ static void win_init_some __ARGS((win_T *newp, win_T *oldp));
  static void frame_comp_pos __ARGS((frame_T *topfrp, int *row, int *col));
  static void frame_setheight __ARGS((frame_T *curfrp, int height));
  #ifdef FEAT_VERTSPLIT
***************
*** 23,30 ****
  static void win_totop __ARGS((int size, int flags));
  static void win_equal_rec __ARGS((win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height));
  static int last_window __ARGS((void));
  static win_T *win_free_mem __ARGS((win_T *win, int *dirp, tabpage_T *tp));
- static win_T *winframe_remove __ARGS((win_T *win, int *dirp, tabpage_T *tp));
  static frame_T *win_altframe __ARGS((win_T *win, tabpage_T *tp));
  static tabpage_T *alt_tabpage __ARGS((void));
  static win_T *frame2win __ARGS((frame_T *frp));
--- 23,30 ----
  static void win_totop __ARGS((int size, int flags));
  static void win_equal_rec __ARGS((win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height));
  static int last_window __ARGS((void));
+ static int one_window __ARGS((void));
  static win_T *win_free_mem __ARGS((win_T *win, int *dirp, tabpage_T *tp));
  static frame_T *win_altframe __ARGS((win_T *win, tabpage_T *tp));
  static tabpage_T *alt_tabpage __ARGS((void));
  static win_T *frame2win __ARGS((frame_T *frp));
***************
*** 41,46 ****
--- 41,47 ----
  #endif
  #endif
  static int win_alloc_firstwin __ARGS((win_T *oldwin));
+ static void new_frame __ARGS((win_T *wp));
  #if defined(FEAT_WINDOWS) || defined(PROTO)
  static tabpage_T *alloc_tabpage __ARGS((void));
  static int leave_tabpage __ARGS((buf_T *new_curbuf));
***************
*** 49,56 ****
  static int frame_minheight __ARGS((frame_T *topfrp, win_T *next_curwin));
  static void win_enter_ext __ARGS((win_T *wp, int undo_sync, int no_curwin));
  static void win_free __ARGS((win_T *wp, tabpage_T *tp));
- static void win_append __ARGS((win_T *, win_T *));
- static void win_remove __ARGS((win_T *, tabpage_T *tp));
  static void frame_append __ARGS((frame_T *after, frame_T *frp));
  static void frame_insert __ARGS((frame_T *before, frame_T *frp));
  static void frame_remove __ARGS((frame_T *frp));
--- 50,55 ----
***************
*** 62,78 ****
  static void frame_add_height __ARGS((frame_T *frp, int n));
  static void last_status_rec __ARGS((frame_T *fr, int statusline));
  
- static void make_snapshot __ARGS((void));
  static void make_snapshot_rec __ARGS((frame_T *fr, frame_T **frp));
! static void clear_snapshot __ARGS((tabpage_T *tp));
  static void clear_snapshot_rec __ARGS((frame_T *fr));
- static void restore_snapshot __ARGS((int close_curwin));
  static int check_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
  static win_T *restore_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
  
  #endif /* FEAT_WINDOWS */
  
! static win_T *win_alloc __ARGS((win_T *after));
  static void win_new_height __ARGS((win_T *, int));
  
  #define URL_SLASH	1		/* path_is_url() has found "://" */
--- 61,75 ----
  static void frame_add_height __ARGS((frame_T *frp, int n));
  static void last_status_rec __ARGS((frame_T *fr, int statusline));
  
  static void make_snapshot_rec __ARGS((frame_T *fr, frame_T **frp));
! static void clear_snapshot __ARGS((tabpage_T *tp, int idx));
  static void clear_snapshot_rec __ARGS((frame_T *fr));
  static int check_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
  static win_T *restore_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
  
  #endif /* FEAT_WINDOWS */
  
! static win_T *win_alloc __ARGS((win_T *after, int hidden));
  static void win_new_height __ARGS((win_T *, int));
  
  #define URL_SLASH	1		/* path_is_url() has found "://" */
***************
*** 259,265 ****
  /* cursor to previous window with wrap around */
      case 'W':
  		CHECK_CMDWIN
! 		if (lastwin == firstwin && Prenum != 1)	/* just one window */
  		    beep_flush();
  		else
  		{
--- 256,262 ----
  /* cursor to previous window with wrap around */
      case 'W':
  		CHECK_CMDWIN
! 		if (firstwin == lastwin && Prenum != 1)	/* just one window */
  		    beep_flush();
  		else
  		{
***************
*** 343,349 ****
  
  /* move window to new tab page */
      case 'T':
! 		if (firstwin == lastwin)
  		    MSG(_(m_onlyone));
  		else
  		{
--- 340,346 ----
  
  /* move window to new tab page */
      case 'T':
! 		if (one_window())
  		    MSG(_(m_onlyone));
  		else
  		{
***************
*** 679,687 ****
      /* When creating the help window make a snapshot of the window layout.
       * Otherwise clear the snapshot, it's now invalid. */
      if (flags & WSP_HELP)
! 	make_snapshot();
      else
! 	clear_snapshot(curtab);
  
      return win_split_ins(size, flags, NULL, 0);
  }
--- 676,684 ----
      /* When creating the help window make a snapshot of the window layout.
       * Otherwise clear the snapshot, it's now invalid. */
      if (flags & WSP_HELP)
! 	make_snapshot(SNAP_HELP_IDX);
      else
! 	clear_snapshot(curtab, SNAP_HELP_IDX);
  
      return win_split_ins(size, flags, NULL, 0);
  }
***************
*** 692,698 ****
   * top/left/right/bottom.
   * return FAIL for failure, OK otherwise
   */
!     static int
  win_split_ins(size, flags, newwin, dir)
      int		size;
      int		flags;
--- 689,695 ----
   * top/left/right/bottom.
   * return FAIL for failure, OK otherwise
   */
!     int
  win_split_ins(size, flags, newwin, dir)
      int		size;
      int		flags;
***************
*** 893,906 ****
      {
  	/* new window below/right of current one */
  	if (newwin == NULL)
! 	    wp = win_alloc(oldwin);
  	else
  	    win_append(oldwin, wp);
      }
      else
      {
  	if (newwin == NULL)
! 	    wp = win_alloc(oldwin->w_prev);
  	else
  	    win_append(oldwin->w_prev, wp);
      }
--- 890,903 ----
      {
  	/* new window below/right of current one */
  	if (newwin == NULL)
! 	    wp = win_alloc(oldwin, FALSE);
  	else
  	    win_append(oldwin, wp);
      }
      else
      {
  	if (newwin == NULL)
! 	    wp = win_alloc(oldwin->w_prev, FALSE);
  	else
  	    win_append(oldwin->w_prev, wp);
      }
***************
*** 910,915 ****
--- 907,919 ----
  	if (wp == NULL)
  	    return FAIL;
  
+ 	new_frame(wp);
+ 	if (wp->w_frame == NULL)
+ 	{
+ 	    win_free(wp, NULL);
+ 	    return FAIL;
+ 	}
+ 
  	/* make the contents of the new window the same as the current one */
  	win_init(wp, curwin, flags);
      }
***************
*** 970,982 ****
      }
  
      if (newwin == NULL)
!     {
! 	/* Create a frame for the new window. */
! 	frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
! 	frp->fr_layout = FR_LEAF;
! 	frp->fr_win = wp;
! 	wp->w_frame = frp;
!     }
      else
  	frp = newwin->w_frame;
      frp->fr_parent = curfrp->fr_parent;
--- 974,980 ----
      }
  
      if (newwin == NULL)
! 	frp = wp->w_frame;
      else
  	frp = newwin->w_frame;
      frp->fr_parent = curfrp->fr_parent;
***************
*** 1156,1161 ****
--- 1154,1160 ----
      return OK;
  }
  
+ 
  /*
   * Initialize window "newp" from window "oldp".
   * Used when splitting a window and when creating a new tab page.
***************
*** 1204,1217 ****
      if (oldp->w_localdir != NULL)
  	newp->w_localdir = vim_strsave(oldp->w_localdir);
  
!     /* Use the same argument list. */
!     newp->w_alist = oldp->w_alist;
!     ++newp->w_alist->al_refcount;
!     newp->w_arg_idx = oldp->w_arg_idx;
! 
!     /*
!      * copy tagstack and options from existing window
!      */
      for (i = 0; i < oldp->w_tagstacklen; i++)
      {
  	newp->w_tagstack[i] = oldp->w_tagstack[i];
--- 1203,1209 ----
      if (oldp->w_localdir != NULL)
  	newp->w_localdir = vim_strsave(oldp->w_localdir);
  
!     /* copy tagstack and folds */
      for (i = 0; i < oldp->w_tagstacklen; i++)
      {
  	newp->w_tagstack[i] = oldp->w_tagstack[i];
***************
*** 1221,1230 ****
      }
      newp->w_tagstackidx = oldp->w_tagstackidx;
      newp->w_tagstacklen = oldp->w_tagstacklen;
-     win_copy_options(oldp, newp);
  # ifdef FEAT_FOLDING
      copyFoldingState(oldp, newp);
  # endif
  }
  
  #endif /* FEAT_WINDOWS */
--- 1213,1241 ----
      }
      newp->w_tagstackidx = oldp->w_tagstackidx;
      newp->w_tagstacklen = oldp->w_tagstacklen;
  # ifdef FEAT_FOLDING
      copyFoldingState(oldp, newp);
  # endif
+ 
+     win_init_some(newp, oldp);
+ }
+ 
+ /*
+  * Initialize window "newp" from window"old".
+  * Only the essential things are copied.
+  */
+     static void
+ win_init_some(newp, oldp)
+     win_T	*newp;
+     win_T	*oldp;
+ {
+     /* Use the same argument list. */
+     newp->w_alist = oldp->w_alist;
+     ++newp->w_alist->al_refcount;
+     newp->w_arg_idx = oldp->w_arg_idx;
+ 
+     /* copy options from existing window */
+     win_copy_options(oldp, newp);
  }
  
  #endif /* FEAT_WINDOWS */
***************
*** 1565,1579 ****
  #if defined(FEAT_GUI) && defined(FEAT_VERTSPLIT)
      /* When 'guioptions' includes 'L' or 'R' may have to remove or add
       * scrollbars.  Have to update them anyway. */
!     if (gui.in_use)
!     {
! 	out_flush();
! 	gui_init_which_components(NULL);
! 	gui_update_scrollbars(TRUE);
!     }
!     need_mouse_correct = TRUE;
  #endif
- 
  }
  
  /*
--- 1576,1583 ----
  #if defined(FEAT_GUI) && defined(FEAT_VERTSPLIT)
      /* When 'guioptions' includes 'L' or 'R' may have to remove or add
       * scrollbars.  Have to update them anyway. */
!     gui_may_update_scrollbars();
  #endif
  }
  
  /*
***************
*** 2048,2060 ****
  }
  
  /*
!  * Return TRUE if the current window is the only window that exists.
   * Returns FALSE if there is a window, possibly in another tab page.
   */
      static int
  last_window()
  {
!     return (lastwin == firstwin && first_tabpage->tp_next == NULL);
  }
  
  /*
--- 2052,2091 ----
  }
  
  /*
!  * Return TRUE if the current window is the only window that exists (ignoring
!  * "aucmd_win").
   * Returns FALSE if there is a window, possibly in another tab page.
   */
      static int
  last_window()
  {
!     return (one_window() && first_tabpage->tp_next == NULL);
! }
! 
! /*
!  * Return TRUE if there is only one window other than "aucmd_win" in the
!  * current tab page.
!  */
!     static int
! one_window()
! {
! #ifdef FEAT_AUTOCMD
!     win_T	*wp;
!     int		seen_one = FALSE;
! 
!     FOR_ALL_WINDOWS(wp)
!     {
! 	if (wp != aucmd_win)
! 	{
! 	    if (seen_one)
! 		return FALSE;
! 	    seen_one = TRUE;
! 	}
!     }
!     return TRUE;
! #else
!     return firstwin == lastwin;
! #endif
  }
  
  /*
***************
*** 2083,2088 ****
--- 2114,2132 ----
  	return;
      }
  
+ #ifdef FEAT_AUTOCMD
+     if (win == aucmd_win)
+     {
+ 	EMSG(_("E813: Cannot close autocmd window"));
+ 	return;
+     }
+     if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())
+     {
+ 	EMSG(_("E814: Cannot close window, only autocmd window would remain"));
+ 	return;
+     }
+ #endif
+ 
      /*
       * When closing the last window in a tab page first go to another tab
       * page and then close the window and the tab page.  This avoids that
***************
*** 2112,2118 ****
      if (win->w_buffer->b_help)
  	help_window = TRUE;
      else
! 	clear_snapshot(curtab);
  
  #ifdef FEAT_AUTOCMD
      if (win == curwin)
--- 2156,2162 ----
      if (win->w_buffer->b_help)
  	help_window = TRUE;
      else
! 	clear_snapshot(curtab, SNAP_HELP_IDX);
  
  #ifdef FEAT_AUTOCMD
      if (win == curwin)
***************
*** 2229,2235 ****
      /* After closing the help window, try restoring the window layout from
       * before it was opened. */
      if (help_window)
! 	restore_snapshot(close_curwin);
  
  #if defined(FEAT_GUI) && defined(FEAT_VERTSPLIT)
      /* When 'guioptions' includes 'L' or 'R' may have to remove scrollbars. */
--- 2273,2279 ----
      /* After closing the help window, try restoring the window layout from
       * before it was opened. */
      if (help_window)
! 	restore_snapshot(SNAP_HELP_IDX, close_curwin);
  
  #if defined(FEAT_GUI) && defined(FEAT_VERTSPLIT)
      /* When 'guioptions' includes 'L' or 'R' may have to remove scrollbars. */
***************
*** 2344,2349 ****
--- 2388,2401 ----
  
      while (firstwin != NULL)
  	(void)win_free_mem(firstwin, &dummy, NULL);
+ 
+ # ifdef FEAT_AUTOCMD
+     if (aucmd_win != NULL)
+     {
+ 	(void)win_free_mem(aucmd_win, &dummy, NULL);
+ 	aucmd_win = NULL;
+     }
+ # endif
  }
  #endif
  
***************
*** 2351,2357 ****
   * Remove a window and its frame from the tree of frames.
   * Returns a pointer to the window that got the freed up space.
   */
!     static win_T *
  winframe_remove(win, dirp, tp)
      win_T	*win;
      int		*dirp UNUSED;	/* set to 'v' or 'h' for direction if 'ea' */
--- 2403,2409 ----
   * Remove a window and its frame from the tree of frames.
   * Returns a pointer to the window that got the freed up space.
   */
!     win_T *
  winframe_remove(win, dirp, tp)
      win_T	*win;
      int		*dirp UNUSED;	/* set to 'v' or 'h' for direction if 'ea' */
***************
*** 3090,3096 ****
      win_T	*nextwp;
      int		r;
  
!     if (lastwin == firstwin)
      {
  	if (message
  #ifdef FEAT_AUTOCMD
--- 3142,3148 ----
      win_T	*nextwp;
      int		r;
  
!     if (one_window())
      {
  	if (message
  #ifdef FEAT_AUTOCMD
***************
*** 3194,3202 ****
--- 3246,3275 ----
      first_tabpage->tp_topframe = topframe;
      curtab = first_tabpage;
  #endif
+ 
      return OK;
  }
  
+ #if defined(FEAT_AUTOCMD) || defined(PROTO)
+ /*
+  * Init "aucmd_win".  This can only be done after the first
+  * window is fully initialized, thus it can't be in win_alloc_first().
+  */
+     void
+ win_alloc_aucmd_win()
+ {
+     aucmd_win = win_alloc(NULL, TRUE);
+     if (aucmd_win != NULL)
+     {
+ 	win_init_some(aucmd_win, curwin);
+ # ifdef FEAT_SCROLLBIND
+ 	aucmd_win->w_p_scb = FALSE;
+ # endif
+ 	new_frame(aucmd_win);
+     }
+ }
+ #endif
+ 
  /*
   * Allocate the first window or the first window in a new tab page.
   * When "oldwin" is NULL create an empty buffer for it.
***************
*** 3208,3214 ****
  win_alloc_firstwin(oldwin)
      win_T	*oldwin;
  {
!     curwin = win_alloc(NULL);
      if (oldwin == NULL)
      {
  	/* Very first window, need to create an empty buffer for it and
--- 3281,3287 ----
  win_alloc_firstwin(oldwin)
      win_T	*oldwin;
  {
!     curwin = win_alloc(NULL, FALSE);
      if (oldwin == NULL)
      {
  	/* Very first window, need to create an empty buffer for it and
***************
*** 3236,3256 ****
      }
  #endif
  
!     topframe = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
!     if (topframe == NULL)
  	return FAIL;
!     topframe->fr_layout = FR_LEAF;
  #ifdef FEAT_VERTSPLIT
      topframe->fr_width = Columns;
  #endif
      topframe->fr_height = Rows - p_ch;
      topframe->fr_win = curwin;
-     curwin->w_frame = topframe;
  
      return OK;
  }
  
  /*
   * Initialize the window and frame size to the maximum.
   */
      void
--- 3309,3344 ----
      }
  #endif
  
!     new_frame(curwin);
!     if (curwin->w_frame == NULL)
  	return FAIL;
!     topframe = curwin->w_frame;
  #ifdef FEAT_VERTSPLIT
      topframe->fr_width = Columns;
  #endif
      topframe->fr_height = Rows - p_ch;
      topframe->fr_win = curwin;
  
      return OK;
  }
  
  /*
+  * Create a frame for window "wp".
+  */
+     static void
+ new_frame(win_T *wp)
+ {
+     frame_T *frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
+ 
+     wp->w_frame = frp;
+     if (frp != NULL)
+     {
+ 	frp->fr_layout = FR_LEAF;
+ 	frp->fr_win = wp;
+     }
+ }
+ 
+ /*
   * Initialize the window and frame size to the maximum.
   */
      void
***************
*** 3300,3309 ****
  free_tabpage(tp)
      tabpage_T	*tp;
  {
  # ifdef FEAT_DIFF
      diff_clear(tp);
  # endif
!     clear_snapshot(tp);
  #ifdef FEAT_EVAL
      vars_clear(&tp->tp_vars.dv_hashtab);	/* free all t: variables */
  #endif
--- 3388,3400 ----
  free_tabpage(tp)
      tabpage_T	*tp;
  {
+     int idx;
+ 
  # ifdef FEAT_DIFF
      diff_clear(tp);
  # endif
!     for (idx = 0; idx < SNAP_COUNT; ++idx)
! 	clear_snapshot(tp, idx);
  #ifdef FEAT_EVAL
      vars_clear(&tp->tp_vars.dv_hashtab);	/* free all t: variables */
  #endif
***************
*** 3370,3381 ****
  #if defined(FEAT_GUI)
  	/* When 'guioptions' includes 'L' or 'R' may have to remove or add
  	 * scrollbars.  Have to update them anyway. */
! 	if (gui.in_use && starting == 0)
! 	{
! 	    gui_init_which_components(NULL);
! 	    gui_update_scrollbars(TRUE);
! 	}
! 	need_mouse_correct = TRUE;
  #endif
  
  	redraw_all_later(CLEAR);
--- 3461,3467 ----
  #if defined(FEAT_GUI)
  	/* When 'guioptions' includes 'L' or 'R' may have to remove or add
  	 * scrollbars.  Have to update them anyway. */
! 	gui_may_update_scrollbars();
  #endif
  
  	redraw_all_later(CLEAR);
***************
*** 3593,3604 ****
  #if defined(FEAT_GUI)
      /* When 'guioptions' includes 'L' or 'R' may have to remove or add
       * scrollbars.  Have to update them anyway. */
!     if (gui.in_use && starting == 0)
!     {
! 	gui_init_which_components(NULL);
! 	gui_update_scrollbars(TRUE);
!     }
!     need_mouse_correct = TRUE;
  #endif
  
      redraw_all_later(CLEAR);
--- 3679,3685 ----
  #if defined(FEAT_GUI)
      /* When 'guioptions' includes 'L' or 'R' may have to remove or add
       * scrollbars.  Have to update them anyway. */
!     gui_may_update_scrollbars();
  #endif
  
      redraw_all_later(CLEAR);
***************
*** 4150,4160 ****
  #endif
  
  /*
!  * allocate a window structure and link it in the window list
   */
      static win_T *
! win_alloc(after)
      win_T	*after UNUSED;
  {
      win_T	*newwin;
  
--- 4231,4243 ----
  #endif
  
  /*
!  * Allocate a window structure and link it in the window list when "hidden" is
!  * FALSE.
   */
      static win_T *
! win_alloc(after, hidden)
      win_T	*after UNUSED;
+     int		hidden UNUSED;
  {
      win_T	*newwin;
  
***************
*** 4180,4186 ****
  	 * link the window in the window list
  	 */
  #ifdef FEAT_WINDOWS
! 	win_append(after, newwin);
  #endif
  #ifdef FEAT_VERTSPLIT
  	newwin->w_wincol = 0;
--- 4263,4270 ----
  	 * link the window in the window list
  	 */
  #ifdef FEAT_WINDOWS
! 	if (!hidden)
! 	    win_append(after, newwin);
  #endif
  #ifdef FEAT_VERTSPLIT
  	newwin->w_wincol = 0;
***************
*** 4314,4320 ****
  /*
   * Append window "wp" in the window list after window "after".
   */
!     static void
  win_append(after, wp)
      win_T	*after, *wp;
  {
--- 4398,4404 ----
  /*
   * Append window "wp" in the window list after window "after".
   */
!     void
  win_append(after, wp)
      win_T	*after, *wp;
  {
***************
*** 4340,4346 ****
  /*
   * Remove a window from the window list.
   */
!     static void
  win_remove(wp, tp)
      win_T	*wp;
      tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
--- 4424,4430 ----
  /*
   * Remove a window from the window list.
   */
!     void
  win_remove(wp, tp)
      win_T	*wp;
      tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
***************
*** 6040,6045 ****
--- 6124,6130 ----
  /*
   * Return TRUE if there is only one window (in the current tab page), not
   * counting a help or preview window, unless it is the current window.
+  * Does not count "aucmd_win".
   */
      int
  only_one_window()
***************
*** 6053,6063 ****
  	return FALSE;
  
      for (wp = firstwin; wp != NULL; wp = wp->w_next)
! 	if (!((wp->w_buffer->b_help && !curbuf->b_help)
  # ifdef FEAT_QUICKFIX
  		    || wp->w_p_pvw
  # endif
  	     ) || wp == curwin)
  	    ++count;
      return (count <= 1);
  #else
--- 6138,6152 ----
  	return FALSE;
  
      for (wp = firstwin; wp != NULL; wp = wp->w_next)
! 	if ((!((wp->w_buffer->b_help && !curbuf->b_help)
  # ifdef FEAT_QUICKFIX
  		    || wp->w_p_pvw
  # endif
  	     ) || wp == curwin)
+ # ifdef FEAT_AUTOCMD
+ 		&& wp != aucmd_win
+ # endif
+ 	   )
  	    ++count;
      return (count <= 1);
  #else
***************
*** 6112,6122 ****
  /*
   * Create a snapshot of the current frame sizes.
   */
!     static void
! make_snapshot()
  {
!     clear_snapshot(curtab);
!     make_snapshot_rec(topframe, &curtab->tp_snapshot);
  }
  
      static void
--- 6201,6212 ----
  /*
   * Create a snapshot of the current frame sizes.
   */
!     void
! make_snapshot(idx)
!     int idx;
  {
!     clear_snapshot(curtab, idx);
!     make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);
  }
  
      static void
***************
*** 6144,6154 ****
   * Remove any existing snapshot.
   */
      static void
! clear_snapshot(tp)
      tabpage_T	*tp;
  {
!     clear_snapshot_rec(tp->tp_snapshot);
!     tp->tp_snapshot = NULL;
  }
  
      static void
--- 6234,6245 ----
   * Remove any existing snapshot.
   */
      static void
! clear_snapshot(tp, idx)
      tabpage_T	*tp;
+     int		idx;
  {
!     clear_snapshot_rec(tp->tp_snapshot[idx]);
!     tp->tp_snapshot[idx] = NULL;
  }
  
      static void
***************
*** 6168,6193 ****
   * This is only done if the screen size didn't change and the window layout is
   * still the same.
   */
!     static void
! restore_snapshot(close_curwin)
      int		close_curwin;	    /* closing current window */
  {
      win_T	*wp;
  
!     if (curtab->tp_snapshot != NULL
  # ifdef FEAT_VERTSPLIT
! 	    && curtab->tp_snapshot->fr_width == topframe->fr_width
  # endif
! 	    && curtab->tp_snapshot->fr_height == topframe->fr_height
! 	    && check_snapshot_rec(curtab->tp_snapshot, topframe) == OK)
      {
! 	wp = restore_snapshot_rec(curtab->tp_snapshot, topframe);
  	win_comp_pos();
  	if (wp != NULL && close_curwin)
  	    win_goto(wp);
  	redraw_all_later(CLEAR);
      }
!     clear_snapshot(curtab);
  }
  
  /*
--- 6259,6285 ----
   * This is only done if the screen size didn't change and the window layout is
   * still the same.
   */
!     void
! restore_snapshot(idx, close_curwin)
!     int		idx;
      int		close_curwin;	    /* closing current window */
  {
      win_T	*wp;
  
!     if (curtab->tp_snapshot[idx] != NULL
  # ifdef FEAT_VERTSPLIT
! 	    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width
  # endif
! 	    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height
! 	    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)
      {
! 	wp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);
  	win_comp_pos();
  	if (wp != NULL && close_curwin)
  	    win_goto(wp);
  	redraw_all_later(CLEAR);
      }
!     clear_snapshot(curtab, idx);
  }
  
  /*
*** ../vim-7.2.202/src/version.c	2009-06-16 15:35:46.000000000 +0200
--- src/version.c	2009-06-16 15:37:16.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     203,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
15. Five days in advance, tell your friends you can't attend their
    party because you're not in the mood.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.204 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.204 (extra)
Problem:    Win32: Can't build with Visual Studio 2010 beta 1.
Solution:   Fix the makefile. (George Reilly)
Files:	    src/Make_mvc.mak


*** ../vim-7.2.203/src/Make_mvc.mak	2009-05-26 22:58:43.000000000 +0200
--- src/Make_mvc.mak	2009-06-16 16:27:59.000000000 +0200
***************
*** 1,18 ****
  # Makefile for Vim on Win32 (Windows NT/2000/XP/2003 and Windows 95/98/Me)
  # and Win64, using the Microsoft Visual C++ compilers. Known to work with
  # VC5, VC6 (VS98), VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005),
! # and VC9 (VS2008).
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
  # This makefile can build the console, GUI, OLE-enable, Perl-enabled and
! # Python-enabled versions of vim for Win32 platforms.
  #
! # The basic command line to build vim is:
  #
  #	nmake -f Make_mvc.mak
  #
! # This will build the console version of vim with no additional interfaces.
  # To add features, define any of the following:
  #
  #	!!!!  After changing features do "nmake clean" first  !!!!
--- 1,18 ----
  # Makefile for Vim on Win32 (Windows NT/2000/XP/2003 and Windows 95/98/Me)
  # and Win64, using the Microsoft Visual C++ compilers. Known to work with
  # VC5, VC6 (VS98), VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005),
! # VC9 (VS2008), and VC10 (VS2010).
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
  # This makefile can build the console, GUI, OLE-enable, Perl-enabled and
! # Python-enabled versions of Vim for Win32 platforms.
  #
! # The basic command line to build Vim is:
  #
  #	nmake -f Make_mvc.mak
  #
! # This will build the console version of Vim with no additional interfaces.
  # To add features, define any of the following:
  #
  #	!!!!  After changing features do "nmake clean" first  !!!!
***************
*** 358,363 ****
--- 358,366 ----
  !if "$(_NMAKE_VER)" == "9.00.30729.01"
  MSVCVER = 9.0
  !endif
+ !if "$(_NMAKE_VER)" == "10.00.20506.01"
+ MSVCVER = 10.0
+ !endif
  !endif
  
  # Abort bulding VIM if version of VC is unrecognised.
***************
*** 372,378 ****
  !endif
  
  # Convert processor ID to MVC-compatible number
! !if ("$(MSVCVER)" != "8.0") && ("$(MSVCVER)" != "9.0")
  !if "$(CPUNR)" == "i386"
  CPUARG = /G3
  !elseif "$(CPUNR)" == "i486"
--- 375,381 ----
  !endif
  
  # Convert processor ID to MVC-compatible number
! !if ("$(MSVCVER)" != "8.0") && ("$(MSVCVER)" != "9.0") && ("$(MSVCVER)" != "10.0")
  !if "$(CPUNR)" == "i386"
  CPUARG = /G3
  !elseif "$(CPUNR)" == "i486"
***************
*** 405,411 ****
  !else # MAXSPEED
  OPTFLAG = /Ox
  !endif
! !if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0")
  # Use link time code generation if not worried about size
  !if "$(OPTIMIZE)" != "SPACE"
  OPTFLAG = $(OPTFLAG) /GL
--- 408,414 ----
  !else # MAXSPEED
  OPTFLAG = /Ox
  !endif
! !if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0") || ("$(MSVCVER)" == "10.0")
  # Use link time code generation if not worried about size
  !if "$(OPTIMIZE)" != "SPACE"
  OPTFLAG = $(OPTFLAG) /GL
***************
*** 793,799 ****
  
  # Report link time code generation progress if used. 
  !ifdef NODEBUG
! !if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0")
  !if "$(OPTIMIZE)" != "SPACE"
  LINKARGS1 = $(LINKARGS1) /LTCG:STATUS
  !endif
--- 796,802 ----
  
  # Report link time code generation progress if used. 
  !ifdef NODEBUG
! !if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0") || ("$(MSVCVER)" == "10.0")
  !if "$(OPTIMIZE)" != "SPACE"
  LINKARGS1 = $(LINKARGS1) /LTCG:STATUS
  !endif
*** ../vim-7.2.203/src/version.c	2009-06-16 16:01:34.000000000 +0200
--- src/version.c	2009-06-16 16:32:41.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     204,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
16. Have your coworkers address you by your wrestling name, Rock Hard Kim.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.205 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.205 (extra)
Problem:    Win32: No support for High DPI awarenes.
Solution:   Fix the manifest file. (George Reilly)
Files:	    src/Make_mvc.mak, src/gvim.exe.mnf


*** ../vim-7.2.204/src/Make_mvc.mak	2009-06-16 16:34:12.000000000 +0200
--- src/Make_mvc.mak	2009-06-16 16:36:32.000000000 +0200
***************
*** 1040,1046 ****
  $(OUTDIR)/xpm_w32.obj: $(OUTDIR) xpm_w32.c
  	$(CC) $(CFLAGS) $(XPM_INC) xpm_w32.c
  
! $(OUTDIR)/vim.res:	$(OUTDIR) vim.rc version.h tools.bmp tearoff.bmp \
  		vim.ico vim_error.ico vim_alert.ico vim_info.ico vim_quest.ico
  	$(RC) /l 0x409 /Fo$(OUTDIR)/vim.res $(RCFLAGS) vim.rc
  
--- 1040,1046 ----
  $(OUTDIR)/xpm_w32.obj: $(OUTDIR) xpm_w32.c
  	$(CC) $(CFLAGS) $(XPM_INC) xpm_w32.c
  
! $(OUTDIR)/vim.res:	$(OUTDIR) vim.rc gvim.exe.mnf version.h tools.bmp tearoff.bmp \
  		vim.ico vim_error.ico vim_alert.ico vim_info.ico vim_quest.ico
  	$(RC) /l 0x409 /Fo$(OUTDIR)/vim.res $(RCFLAGS) vim.rc
  
*** ../vim-7.2.204/src/gvim.exe.mnf	2008-08-09 19:37:29.000000000 +0200
--- src/gvim.exe.mnf	2009-06-16 16:36:32.000000000 +0200
***************
*** 1,5 ****
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
! <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
    <assemblyIdentity
      processorArchitecture="*"
      version="7.2.0.0"
--- 1,5 ----
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
! <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
    <assemblyIdentity
      processorArchitecture="*"
      version="7.2.0.0"
***************
*** 29,32 ****
--- 29,38 ----
        </requestedPrivileges>
      </security>
    </trustInfo>
+   <!-- Vista High DPI aware -->
+   <asmv3:application>
+     <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
+       <dpiAware>true</dpiAware>
+     </asmv3:windowsSettings>
+   </asmv3:application>
  </assembly>
*** ../vim-7.2.204/src/version.c	2009-06-16 16:34:12.000000000 +0200
--- src/version.c	2009-06-16 16:43:04.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     205,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
17. When the money comes out the ATM, scream "I won!, I won! 3rd
    time this week!!!!!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.206
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.206
Problem:    Win32: Can't build netbeans interface with Visual Studio 2010.
Solution:   Undefine ECONNREFUSED. (George Reilly)
Files:	    src/netbeans.c


*** ../vim-7.2.205/src/netbeans.c	2009-05-17 23:25:16.000000000 +0200
--- src/netbeans.c	2009-06-16 16:39:17.000000000 +0200
***************
*** 32,37 ****
--- 32,38 ----
  /* WinSock API is separated from C API, thus we can't use read(), write(),
   * errno... */
  # define sock_errno WSAGetLastError()
+ # undef ECONNREFUSED
  # define ECONNREFUSED WSAECONNREFUSED
  # ifdef EINTR
  #  undef EINTR
*** ../vim-7.2.205/src/version.c	2009-06-16 16:45:14.000000000 +0200
--- src/version.c	2009-06-16 16:57:45.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     206,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
18. When leaving the zoo, start running towards the parking lot,
    yelling "run for your lives, they're loose!!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.207
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.207
Problem:    Using freed memory with ":redrawstatus" when it works recursively.
Solution:   Prevent recursively updating the status line. (partly by Dominique
	    Pelle)
Files:	    src/screen.c


*** ../vim-7.2.206/src/screen.c	2009-06-16 16:01:34.000000000 +0200
--- src/screen.c	2009-06-16 17:04:53.000000000 +0200
***************
*** 5743,5748 ****
--- 5743,5755 ----
      int		fillchar;
      int		attr;
      int		this_ru_col;
+     static int  busy = FALSE;
+ 
+     /* It's possible to get here recursively when 'statusline' (indirectly)
+      * invokes ":redrawstatus".  Simply ignore the call then. */
+     if (busy)
+ 	return;
+     busy = TRUE;
  
      wp->w_redr_status = FALSE;
      if (wp->w_status_height == 0)
***************
*** 5881,5886 ****
--- 5888,5894 ----
  									attr);
      }
  #endif
+     busy = FALSE;
  }
  
  #ifdef FEAT_STL_OPT
*** ../vim-7.2.206/src/version.c	2009-06-16 16:57:53.000000000 +0200
--- src/version.c	2009-06-16 17:21:56.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     207,
  /**/

-- 
In many of the more relaxed civilizations on the Outer Eastern Rim of the
Galaxy, "The Hitchhiker's Guide to the Galaxy" has already supplanted the
great "Encyclopedia Galactica" as the standard repository of all knowledge
and wisdom, for though it has many omissions and contains much that is
apocryphal, or at least wildly inaccurate, it scores over the older, more
pedestrian work in two important respects.
First, it is slightly cheaper; and second, it has the words "DON'T PANIC"
inscribed in large friendly letters on its cover.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.208
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.208
Problem:    "set novice" gives an error message, it should be ignored.
Solution:   Don't see "no" in "novice" as unsetting an option.  (Patrick
	    Texier)
Files:	    src/option.c


*** ../vim-7.2.207/src/option.c	2009-06-16 15:23:07.000000000 +0200
--- src/option.c	2009-06-16 17:35:08.000000000 +0200
***************
*** 4006,4012 ****
  	else
  	{
  	    prefix = 1;
! 	    if (STRNCMP(arg, "no", 2) == 0)
  	    {
  		prefix = 0;
  		arg += 2;
--- 4006,4012 ----
  	else
  	{
  	    prefix = 1;
! 	    if (STRNCMP(arg, "no", 2) == 0 && STRNCMP(arg, "novice", 6) != 0)
  	    {
  		prefix = 0;
  		arg += 2;
***************
*** 9757,9763 ****
  	}
  	--p;
      }
!     if (STRNCMP(p, "no", 2) == 0)
      {
  	xp->xp_context = EXPAND_BOOL_SETTINGS;
  	p += 2;
--- 9757,9763 ----
  	}
  	--p;
      }
!     if (STRNCMP(p, "no", 2) == 0 && STRNCMP(p, "novice", 6) != 0)
      {
  	xp->xp_context = EXPAND_BOOL_SETTINGS;
  	p += 2;
*** ../vim-7.2.207/src/version.c	2009-06-16 17:22:38.000000000 +0200
--- src/version.c	2009-06-16 17:50:33.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     208,
  /**/

-- 
Now it is such a bizarrely improbable coincidence that anything as
mind-bogglingly useful as the Babel fish could have evolved purely by chance
that some thinkers have chosen to see it as a final and clinching proof of the
NON-existence of God.
The argument goes something like this: 'I refuse to prove that I exist,' says
God, 'for proof denies faith, and without faith I am nothing.'
'But,' says Man, 'the Babel fish is a dead giveaway, isn't it?  It could not
have evolved by chance.  It proves you exist, and so therefore, by your own
arguments, you don't.  QED.'
'Oh dear,' says God, 'I hadn't thought of that,' and promptly vanishes in a
puff of logic.
'Oh, that was easy,' says Man, and for an encore goes on to prove that black
is white and gets himself killed on the next pedestrian crossing.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.209
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.209
Problem:    For xxd setmode() is undefined on Cygwin.
Solution:   Include io.h. (Dominique Pelle)
Files:	    src/xxd/xxd.c


*** ../vim-7.2.208/src/xxd/xxd.c	2007-12-03 21:32:21.000000000 +0100
--- src/xxd/xxd.c	2009-06-16 18:03:14.000000000 +0200
***************
*** 64,69 ****
--- 64,72 ----
  # define _CRT_SECURE_NO_DEPRECATE
  # define _CRT_NONSTDC_NO_DEPRECATE
  #endif
+ #if !defined(CYGWIN) && (defined(CYGWIN32) || defined(__CYGWIN__) || defined(__CYGWIN32__))
+ # define CYGWIN
+ #endif
  
  #include <stdio.h>
  #ifdef VAXC
***************
*** 77,83 ****
  #if !defined(OS2) && defined(__EMX__)
  # define OS2
  #endif
! #if defined(MSDOS) || defined(WIN32) || defined(OS2) || defined(__BORLANDC__)
  # include <io.h>	/* for setmode() */
  #else
  # ifdef UNIX
--- 80,87 ----
  #if !defined(OS2) && defined(__EMX__)
  # define OS2
  #endif
! #if defined(MSDOS) || defined(WIN32) || defined(OS2) || defined(__BORLANDC__) \
!   || defined(CYGWIN)
  # include <io.h>	/* for setmode() */
  #else
  # ifdef UNIX
***************
*** 150,158 ****
  # endif
  #endif
  
- #if !defined(CYGWIN) && (defined(CYGWIN32) || defined(__CYGWIN__) || defined(__CYGWIN32__))
- # define CYGWIN
- #endif
  #if defined(MSDOS) || defined(WIN32) || defined(OS2)
  # define BIN_READ(yes)  ((yes) ? "rb" : "rt")
  # define BIN_WRITE(yes) ((yes) ? "wb" : "wt")
--- 154,159 ----
*** ../vim-7.2.208/src/version.c	2009-06-16 17:50:56.000000000 +0200
--- src/version.c	2009-06-16 18:16:08.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     209,
  /**/

-- 
"So this is it," said Arthur, "we are going to die."
"Yes," said Ford, "except...no!  Wait a minute!"  He suddenly lunged across
the chamber at something behind Arthur's line of vision.  "What's this
switch?" he cried.
"What?   Where?" cried Arthur, twisting around.
"No, I was only fooling," said Ford, "we are going to die after all."
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.210
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.210
Problem:    When a file that is being edited has its timestamp updated outside
	    of Vim and ":checktime" is used still get a warning when writing
	    the file. (Matt Mueller)
Solution:   Store the timestamp in b_mtime_read when the timestamp is the only
	    thing that changed.
Files:	    src/fileio.c


*** ../vim-7.2.209/src/fileio.c	2009-06-16 16:01:34.000000000 +0200
--- src/fileio.c	2009-06-20 13:29:41.000000000 +0200
***************
*** 6627,6633 ****
  			mesg = _("W16: Warning: Mode of file \"%s\" has changed since editing started");
  			mesg2 = _("See \":help W16\" for more info.");
  		    }
! 		    /* Else: only timestamp changed, ignored */
  		}
  	    }
  	}
--- 6627,6636 ----
  			mesg = _("W16: Warning: Mode of file \"%s\" has changed since editing started");
  			mesg2 = _("See \":help W16\" for more info.");
  		    }
! 		    else
! 			/* Only timestamp changed, store it to avoid a warning
! 			 * in check_mtime() later. */
! 			buf->b_mtime_read = buf->b_mtime;
  		}
  	    }
  	}
*** ../vim-7.2.209/src/version.c	2009-06-16 18:29:37.000000000 +0200
--- src/version.c	2009-06-24 11:57:08.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     210,
  /**/

-- 
Have you heard about the new Beowulf cluster? It's so fast, it executes
an infinite loop in 6 seconds.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.211
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.211
Problem:    Memory leak when expanding a series of file names.
Solution:   Use ga_clear_strings() instead of ga_clear().
Files:	    src/misc1.c


*** ../vim-7.2.210/src/misc1.c	2009-05-17 13:30:58.000000000 +0200
--- src/misc1.c	2009-06-24 16:16:17.000000000 +0200
***************
*** 9193,9199 ****
  		else if (vim_strpbrk(p, (char_u *)"$~") != NULL)
  		{
  		    vim_free(p);
! 		    ga_clear(&ga);
  		    i = mch_expand_wildcards(num_pat, pat, num_file, file,
  								       flags);
  		    recursive = FALSE;
--- 9193,9199 ----
  		else if (vim_strpbrk(p, (char_u *)"$~") != NULL)
  		{
  		    vim_free(p);
! 		    ga_clear_strings(&ga);
  		    i = mch_expand_wildcards(num_pat, pat, num_file, file,
  								       flags);
  		    recursive = FALSE;
*** ../vim-7.2.210/src/version.c	2009-06-24 11:57:53.000000000 +0200
--- src/version.c	2009-06-24 16:24:32.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     211,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
34. You laugh at people with 14400 baud modems.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.212 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.212 (extra)
Problem:    Warnings for redefining SIG macros.
Solution:   Don't define them if already defined. (Bjorn Winckler)
Files:	    src/os_mac.h


*** ../vim-7.2.211/src/os_mac.h	2008-06-24 22:27:34.000000000 +0200
--- src/os_mac.h	2009-06-19 21:21:57.000000000 +0200
***************
*** 268,276 ****
   */
  
  #ifdef MACOS_X_UNIX
! # define SIGPROTOARG	(int)
! # define SIGDEFARG(s)	(s) int s;
! # define SIGDUMMYARG	0
  # undef  HAVE_AVAIL_MEM
  # ifndef HAVE_CONFIG_H
  #  define RETSIGTYPE void
--- 268,282 ----
   */
  
  #ifdef MACOS_X_UNIX
! # ifndef SIGPROTOARG
! #  define SIGPROTOARG	(int)
! # endif
! # ifndef SIGDEFARG
! #  define SIGDEFARG(s)	(s) int s UNUSED;
! # endif
! # ifndef SIGDUMMYARG
! #  define SIGDUMMYARG	0
! # endif
  # undef  HAVE_AVAIL_MEM
  # ifndef HAVE_CONFIG_H
  #  define RETSIGTYPE void
*** ../vim-7.2.211/src/version.c	2009-06-24 16:25:23.000000000 +0200
--- src/version.c	2009-06-24 16:40:18.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     212,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
37. You start looking for hot HTML addresses in public restrooms.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.213
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.213
Problem:    Warning for using vsprintf().
Solution:   Use vim_vsnprintf().
Files:	    src/netbeans.c


*** ../vim-7.2.212/src/netbeans.c	2009-06-16 16:57:53.000000000 +0200
--- src/netbeans.c	2009-06-24 11:26:43.000000000 +0200
***************
*** 2586,2592 ****
      va_list ap;
  
      va_start(ap, cmd);
!     vsprintf(buf, cmd, ap);
      va_end(ap);
  
      nbdebug(("    COLONCMD %s\n", buf));
--- 2586,2592 ----
      va_list ap;
  
      va_start(ap, cmd);
!     vim_vsnprintf(buf, sizeof(buf), cmd, ap, NULL);
      va_end(ap);
  
      nbdebug(("    COLONCMD %s\n", buf));
*** ../vim-7.2.212/src/version.c	2009-06-24 16:41:01.000000000 +0200
--- src/version.c	2009-06-24 16:49:06.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     213,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
38. You wake up at 3 a.m. to go to the bathroom and stop and check your e-mail
    on the way back to bed.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.214
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.214
Problem:    Crash with complete function for user command. (Andy Wokula)
Solution:   Avoid using a NULL pointer (Dominique Pelle)
Files:	    src/ex_getln.c


*** ../vim-7.2.213/src/ex_getln.c	2009-05-16 17:29:37.000000000 +0200
--- src/ex_getln.c	2009-06-24 16:57:28.000000000 +0200
***************
*** 4874,4887 ****
      /* Loop over the items in the list. */
      for (li = retlist->lv_first; li != NULL; li = li->li_next)
      {
! 	if (li->li_tv.v_type != VAR_STRING)
! 	    continue;  /* Skip non-string items */
  
  	if (ga_grow(&ga, 1) == FAIL)
  	    break;
  
  	((char_u **)ga.ga_data)[ga.ga_len] =
! 	    vim_strsave(li->li_tv.vval.v_string);
  	++ga.ga_len;
      }
      list_unref(retlist);
--- 4874,4887 ----
      /* Loop over the items in the list. */
      for (li = retlist->lv_first; li != NULL; li = li->li_next)
      {
! 	if (li->li_tv.v_type != VAR_STRING || li->li_tv.vval.v_string == NULL)
! 	    continue;  /* Skip non-string items and empty strings */
  
  	if (ga_grow(&ga, 1) == FAIL)
  	    break;
  
  	((char_u **)ga.ga_data)[ga.ga_len] =
! 					 vim_strsave(li->li_tv.vval.v_string);
  	++ga.ga_len;
      }
      list_unref(retlist);
*** ../vim-7.2.213/src/version.c	2009-06-24 16:49:50.000000000 +0200
--- src/version.c	2009-06-24 17:03:58.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     214,
  /**/

-- 
He who laughs last, thinks slowest.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.215
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.215
Problem:    ml_get error when using ":vimgrep".
Solution:   Load the memfile for the hidden buffer before putting it in a
	    window.  Correct the order of splitting the window and filling
	    the window and buffer with data.
Files:	    src/fileio.c, src/proto/window.pro, src/quickfix.c, src/window.c


*** ../vim-7.2.214/src/fileio.c	2009-06-24 11:57:53.000000000 +0200
--- src/fileio.c	2009-06-24 12:53:19.000000000 +0200
***************
*** 710,716 ****
  #endif
  #ifdef UNIX
  	/* Set swap file protection bits after creating it. */
! 	if (swap_mode > 0 && curbuf->b_ml.ml_mfp->mf_fname != NULL)
  	    (void)mch_setperm(curbuf->b_ml.ml_mfp->mf_fname, (long)swap_mode);
  #endif
      }
--- 710,717 ----
  #endif
  #ifdef UNIX
  	/* Set swap file protection bits after creating it. */
! 	if (swap_mode > 0 && curbuf->b_ml.ml_mfp != NULL
! 			  && curbuf->b_ml.ml_mfp->mf_fname != NULL)
  	    (void)mch_setperm(curbuf->b_ml.ml_mfp->mf_fname, (long)swap_mode);
  #endif
      }
***************
*** 8435,8443 ****
  	 * effects, insert it in a the current tab page.
  	 * Anything related to a window (e.g., setting folds) may have
  	 * unexpected results. */
! 	curwin = aucmd_win;
! 	curwin->w_buffer = buf;
  	++buf->b_nwindows;
  
  #ifdef FEAT_WINDOWS
  	/* Split the current window, put the aucmd_win in the upper half. */
--- 8436,8444 ----
  	 * effects, insert it in a the current tab page.
  	 * Anything related to a window (e.g., setting folds) may have
  	 * unexpected results. */
! 	aucmd_win->w_buffer = buf;
  	++buf->b_nwindows;
+ 	win_init_empty(aucmd_win); /* set cursor and topline to safe values */
  
  #ifdef FEAT_WINDOWS
  	/* Split the current window, put the aucmd_win in the upper half. */
***************
*** 8448,8459 ****
  	(void)win_comp_pos();   /* recompute window positions */
  	p_ea = save_ea;
  #endif
! 	/* set cursor and topline to safe values */
! 	curwin_init();
! #ifdef FEAT_VERTSPLIT
! 	curwin->w_wincol = 0;
! 	curwin->w_width = Columns;
! #endif
      }
      curbuf = buf;
      aco->new_curwin = curwin;
--- 8449,8455 ----
  	(void)win_comp_pos();   /* recompute window positions */
  	p_ea = save_ea;
  #endif
! 	curwin = aucmd_win;
      }
      curbuf = buf;
      aco->new_curwin = curwin;
*** ../vim-7.2.214/src/proto/window.pro	2009-06-16 16:01:34.000000000 +0200
--- src/proto/window.pro	2009-06-24 12:53:13.000000000 +0200
***************
*** 14,19 ****
--- 14,20 ----
  win_T *winframe_remove __ARGS((win_T *win, int *dirp, tabpage_T *tp));
  void close_others __ARGS((int message, int forceit));
  void curwin_init __ARGS((void));
+ void win_init_empty __ARGS((win_T *wp));
  int win_alloc_first __ARGS((void));
  void win_alloc_aucmd_win __ARGS((void));
  void win_init_size __ARGS((void));
*** ../vim-7.2.214/src/quickfix.c	2009-05-17 13:30:58.000000000 +0200
--- src/quickfix.c	2009-06-24 15:30:06.000000000 +0200
***************
*** 3411,3424 ****
      /* Init the options. */
      buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);
  
!     /* set curwin/curbuf to buf and save a few things */
!     aucmd_prepbuf(&aco, newbuf);
  
!     /* Need to set the filename for autocommands. */
!     (void)setfname(curbuf, fname, NULL, FALSE);
  
-     if (ml_open(curbuf) == OK)
-     {
  	/* Create swap file now to avoid the ATTENTION message. */
  	check_need_swap(TRUE);
  
--- 3411,3425 ----
      /* Init the options. */
      buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);
  
!     /* need to open the memfile before putting the buffer in a window */
!     if (ml_open(newbuf) == OK)
!     {
! 	/* set curwin/curbuf to buf and save a few things */
! 	aucmd_prepbuf(&aco, newbuf);
  
! 	/* Need to set the filename for autocommands. */
! 	(void)setfname(curbuf, fname, NULL, FALSE);
  
  	/* Create swap file now to avoid the ATTENTION message. */
  	check_need_swap(TRUE);
  
***************
*** 3441,3450 ****
  		newbuf = curbuf;
  	    }
  	}
-     }
  
!     /* restore curwin/curbuf and a few other things */
!     aucmd_restbuf(&aco);
  
      if (!buf_valid(newbuf))
  	return NULL;
--- 3442,3451 ----
  		newbuf = curbuf;
  	    }
  	}
  
! 	/* restore curwin/curbuf and a few other things */
! 	aucmd_restbuf(&aco);
!     }
  
      if (!buf_valid(newbuf))
  	return NULL;
*** ../vim-7.2.214/src/window.c	2009-06-16 16:01:34.000000000 +0200
--- src/window.c	2009-06-24 14:35:16.000000000 +0200
***************
*** 2354,2366 ****
      frame_T	*frp;
      win_T	*wp;
  
- #ifdef FEAT_FOLDING
-     clearFolding(win);
- #endif
- 
-     /* reduce the reference count to the argument list. */
-     alist_unlink(win->w_alist);
- 
      /* Remove the window and its frame from the tree of frames. */
      frp = win->w_frame;
      wp = winframe_remove(win, dirp, tp);
--- 2354,2359 ----
***************
*** 2386,2394 ****
  	tabpage_close(TRUE);
  # endif
  
-     while (firstwin != NULL)
- 	(void)win_free_mem(firstwin, &dummy, NULL);
- 
  # ifdef FEAT_AUTOCMD
      if (aucmd_win != NULL)
      {
--- 2379,2384 ----
***************
*** 2396,2401 ****
--- 2386,2394 ----
  	aucmd_win = NULL;
      }
  # endif
+ 
+     while (firstwin != NULL)
+ 	(void)win_free_mem(firstwin, &dummy, NULL);
  }
  #endif
  
***************
*** 3204,3230 ****
      void
  curwin_init()
  {
!     redraw_win_later(curwin, NOT_VALID);
!     curwin->w_lines_valid = 0;
!     curwin->w_cursor.lnum = 1;
!     curwin->w_curswant = curwin->w_cursor.col = 0;
  #ifdef FEAT_VIRTUALEDIT
!     curwin->w_cursor.coladd = 0;
  #endif
!     curwin->w_pcmark.lnum = 1;	/* pcmark not cleared but set to line 1 */
!     curwin->w_pcmark.col = 0;
!     curwin->w_prev_pcmark.lnum = 0;
!     curwin->w_prev_pcmark.col = 0;
!     curwin->w_topline = 1;
  #ifdef FEAT_DIFF
!     curwin->w_topfill = 0;
  #endif
!     curwin->w_botline = 2;
  #ifdef FEAT_FKMAP
!     if (curwin->w_p_rl)
! 	curwin->w_farsi = W_CONV + W_R_L;
      else
! 	curwin->w_farsi = W_CONV;
  #endif
  }
  
--- 3197,3230 ----
      void
  curwin_init()
  {
!     win_init_empty(curwin);
! }
! 
!     void
! win_init_empty(wp)
!     win_T *wp;
! {
!     redraw_win_later(wp, NOT_VALID);
!     wp->w_lines_valid = 0;
!     wp->w_cursor.lnum = 1;
!     wp->w_curswant = wp->w_cursor.col = 0;
  #ifdef FEAT_VIRTUALEDIT
!     wp->w_cursor.coladd = 0;
  #endif
!     wp->w_pcmark.lnum = 1;	/* pcmark not cleared but set to line 1 */
!     wp->w_pcmark.col = 0;
!     wp->w_prev_pcmark.lnum = 0;
!     wp->w_prev_pcmark.col = 0;
!     wp->w_topline = 1;
  #ifdef FEAT_DIFF
!     wp->w_topfill = 0;
  #endif
!     wp->w_botline = 2;
  #ifdef FEAT_FKMAP
!     if (wp->w_p_rl)
! 	wp->w_farsi = W_CONV + W_R_L;
      else
! 	wp->w_farsi = W_CONV;
  #endif
  }
  
***************
*** 4325,4330 ****
--- 4325,4337 ----
  {
      int		i;
  
+ #ifdef FEAT_FOLDING
+     clearFolding(wp);
+ #endif
+ 
+     /* reduce the reference count to the argument list. */
+     alist_unlink(wp->w_alist);
+ 
  #ifdef FEAT_AUTOCMD
      /* Don't execute autocommands while the window is halfway being deleted.
       * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */
***************
*** 4387,4393 ****
      }
  #endif /* FEAT_GUI */
  
!     win_remove(wp, tp);
      vim_free(wp);
  
  #ifdef FEAT_AUTOCMD
--- 4394,4403 ----
      }
  #endif /* FEAT_GUI */
  
! #ifdef FEAT_AUTOCMD
!     if (wp != aucmd_win)
! #endif
! 	win_remove(wp, tp);
      vim_free(wp);
  
  #ifdef FEAT_AUTOCMD
*** ../vim-7.2.214/src/version.c	2009-06-24 17:04:40.000000000 +0200
--- src/version.c	2009-06-24 17:27:38.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     215,
  /**/

-- 
Micro$oft: where do you want to go today?
    Linux: where do you want to go tomorrow?
  FreeBSD: are you guys coming, or what?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.216
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.216
Problem:    Two error messages have the same number E812.
Solution:   Give one message a different number.
Files:	    runtime/doc/autocmd.txt, runtime/doc/if_mzsch.txt, src/if_mzsch.c


*** ../vim-7.2.215/runtime/doc/autocmd.txt	2008-08-09 19:36:46.000000000 +0200
--- runtime/doc/autocmd.txt	2009-06-24 17:49:04.000000000 +0200
***************
*** 335,340 ****
--- 335,342 ----
  				NOTE: When this autocommand is executed, the
  				current buffer "%" may be different from the
  				buffer being deleted "<afile>" and "<abuf>".
+ 				Don't change to another buffer, it will cause
+ 				problems.
  							*BufEnter*
  BufEnter			After entering a buffer.  Useful for setting
  				options for a file type.  Also executed when
***************
*** 397,402 ****
--- 399,406 ----
  				NOTE: When this autocommand is executed, the
  				current buffer "%" may be different from the
  				buffer being unloaded "<afile>".
+ 				Don't change to another buffer, it will cause
+ 				problems.
  							*BufWinEnter*
  BufWinEnter			After a buffer is displayed in a window.  This
  				can be when the buffer is loaded (after
***************
*** 428,433 ****
--- 432,439 ----
  				NOTE: When this autocommand is executed, the
  				current buffer "%" may be different from the
  				buffer being deleted "<afile>".
+ 				Don't change to another buffer, it will cause
+ 				problems.
  						*BufWrite* *BufWritePre*
  BufWrite or BufWritePre		Before writing the whole buffer to a file.
  							*BufWriteCmd*
***************
*** 748,755 ****
  					'a'	abort, like hitting CTRL-C
  				When set to an empty string the user will be
  				asked, as if there was no SwapExists autocmd.
! 				Note: Do not try to change the buffer, the
! 				results are unpredictable.
  							*Syntax*
  Syntax				When the 'syntax' option has been set.  The
  				pattern is matched against the syntax name.
--- 754,763 ----
  					'a'	abort, like hitting CTRL-C
  				When set to an empty string the user will be
  				asked, as if there was no SwapExists autocmd.
! 							*E812*
! 				It is not allowed to change to another buffer,
! 				change a buffer name or change directory
! 				here.
  							*Syntax*
  Syntax				When the 'syntax' option has been set.  The
  				pattern is matched against the syntax name.
*** ../vim-7.2.215/runtime/doc/if_mzsch.txt	2009-05-26 22:58:43.000000000 +0200
--- runtime/doc/if_mzsch.txt	2009-06-24 12:08:20.000000000 +0200
***************
*** 1,4 ****
! *if_mzsch.txt*  For Vim version 7.2.  Last change: 2009 May 26
  
  
  		  VIM REFERENCE MANUAL    by Sergey Khorev
--- 1,4 ----
! *if_mzsch.txt*  For Vim version 7.2.  Last change: 2009 Jun 24
  
  
  		  VIM REFERENCE MANUAL    by Sergey Khorev
***************
*** 231,237 ****
      (set-cursor (line . col) [window])  Set cursor position.
  
  ==============================================================================
! 5. Dynamic loading				    *mzscheme-dynamic* *E812*
  
  On MS-Windows the MzScheme libraries can be loaded dynamically. The |:version|
  output then includes |+mzscheme/dyn|.
--- 231,237 ----
      (set-cursor (line . col) [window])  Set cursor position.
  
  ==============================================================================
! 5. Dynamic loading				    *mzscheme-dynamic* *E815*
  
  On MS-Windows the MzScheme libraries can be loaded dynamically. The |:version|
  output then includes |+mzscheme/dyn|.
*** ../vim-7.2.215/src/if_mzsch.c	2009-05-26 22:58:43.000000000 +0200
--- src/if_mzsch.c	2009-06-24 12:08:23.000000000 +0200
***************
*** 1040,1046 ****
  #ifdef DYNAMIC_MZSCHEME
  	if (!mzscheme_enabled(TRUE))
  	{
! 	    EMSG(_("E812: Sorry, this command is disabled, the MzScheme libraries could not be loaded."));
  	    return -1;
  	}
  #endif
--- 1040,1046 ----
  #ifdef DYNAMIC_MZSCHEME
  	if (!mzscheme_enabled(TRUE))
  	{
! 	    EMSG(_("E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded."));
  	    return -1;
  	}
  #endif
*** ../vim-7.2.215/src/version.c	2009-06-24 17:31:27.000000000 +0200
--- src/version.c	2009-06-24 17:46:56.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     216,
  /**/

-- 
Everyone has a photographic memory. Some don't have film.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.217
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.217
Problem:    Running tests with valgrind doesn't work as advertised.
Solution:   Fix the line in the Makefile.
Files:	    src/testdir/Makefile


*** ../vim-7.2.216/src/testdir/Makefile	2009-03-11 16:26:01.000000000 +0100
--- src/testdir/Makefile	2009-06-24 14:59:42.000000000 +0200
***************
*** 4,12 ****
  
  VIMPROG = ../vim
  
! # Uncomment this line for using valgrind.
! # The output goes into a file "valgrind.$PID" (sorry, no test number).
! # VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=15 --logfile=valgrind
  
  SCRIPTS = test1.out test2.out test3.out test4.out test5.out test6.out \
  		test7.out test8.out test9.out test10.out test11.out \
--- 4,14 ----
  
  VIMPROG = ../vim
  
! # Uncomment this line to use valgrind for memory leaks and extra warnings.
! #   The output goes into a file "valgrind.testN"
! #   Vim should be compiled with EXITFREE to avoid false warnings.
! #   This will make testing about 10 times as slow.
! # VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=15 --log-file=valgrind.$*
  
  SCRIPTS = test1.out test2.out test3.out test4.out test5.out test6.out \
  		test7.out test8.out test9.out test10.out test11.out \
*** ../vim-7.2.216/src/version.c	2009-06-24 17:51:01.000000000 +0200
--- src/version.c	2009-06-24 18:07:07.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     217,
  /**/

-- 
A day without sunshine is like, well, night.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.218
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.218
Problem:    Cannot build GTK with hangul_input feature. (Dominique Pelle)
Solution:   Adjuste #ifdef.  (SungHyun Nam)
Files:	    src/gui.c


*** ../vim-7.2.217/src/gui.c	2009-06-16 16:01:34.000000000 +0200
--- src/gui.c	2009-06-24 17:45:01.000000000 +0200
***************
*** 959,965 ****
  		guicolor_T fg, bg;
  
  		if (
! # ifdef HAVE_GTK2
  			preedit_get_status()
  # else
  			im_get_status()
--- 959,965 ----
  		guicolor_T fg, bg;
  
  		if (
! # if defined(HAVE_GTK2) && !defined(FEAT_HANGULIN)
  			preedit_get_status()
  # else
  			im_get_status()
*** ../vim-7.2.217/src/version.c	2009-06-24 18:07:55.000000000 +0200
--- src/version.c	2009-06-24 18:31:06.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     218,
  /**/

-- 
The users that I support would double-click on a landmine to find out
what happens.				-- A system administrator

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.219 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.219 (extra)
Problem:    Photon GUI is outdated.
Solution:   Updates for QNX 6.4.0. (Sean Boudreau)
Files:	    src/gui_photon.c


*** ../vim-7.2.218/src/gui_photon.c	2007-05-10 20:23:35.000000000 +0200
--- src/gui_photon.c	2009-07-01 16:08:36.000000000 +0200
***************
*** 838,844 ****
--- 838,849 ----
      static void
  gui_ph_draw_start( void )
  {
+     PhGC_t *gc;
+ 
+     gc = PgGetGC();
      PgSetRegion( PtWidgetRid( PtFindDisjoint( gui.vimTextArea ) ) );
+     PgClearClippingsCx( gc );
+     PgClearTranslationCx( gc );
  
      PtWidgetOffset( gui.vimTextArea, &gui_ph_raw_offset );
      PhTranslatePoint( &gui_ph_raw_offset, PtWidgetPos( gui.vimTextArea, NULL ) );
***************
*** 2970,2976 ****
      if( vim_font_name == NULL )
      {
  	/* Default font */
! 	vim_font_name = "PC Term";
      }
  
      if( STRCMP( vim_font_name, "*" ) == 0 )
--- 2975,2981 ----
      if( vim_font_name == NULL )
      {
  	/* Default font */
! 	vim_font_name = "PC Terminal";
      }
  
      if( STRCMP( vim_font_name, "*" ) == 0 )
*** ../vim-7.2.218/src/version.c	2009-06-24 18:31:36.000000000 +0200
--- src/version.c	2009-07-01 16:11:34.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     219,
  /**/

-- 
"Oh, no!  NOT the Spanish Inquisition!"
"NOBODY expects the Spanish Inquisition!!!"
				-- Monty Python sketch --
"Oh, no!  NOT another option!"
"EVERYBODY expects another option!!!"
				-- Discussion in vim-dev mailing list --

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.220
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.220 (after 7.2.215)
Problem:    a BufEnter autocommand that changes directory causes problems.
	    (Ajit Thakkar)
Solution:   Disable autocommands when opening a hidden buffer in a window.
Files:	    src/fileio.c


*** ../vim-7.2.219/src/fileio.c	2009-06-24 17:31:27.000000000 +0200
--- src/fileio.c	2009-07-01 17:02:46.000000000 +0200
***************
*** 8441,8453 ****
  	win_init_empty(aucmd_win); /* set cursor and topline to safe values */
  
  #ifdef FEAT_WINDOWS
! 	/* Split the current window, put the aucmd_win in the upper half. */
  	make_snapshot(SNAP_AUCMD_IDX);
  	save_ea = p_ea;
  	p_ea = FALSE;
  	(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);
  	(void)win_comp_pos();   /* recompute window positions */
  	p_ea = save_ea;
  #endif
  	curwin = aucmd_win;
      }
--- 8441,8456 ----
  	win_init_empty(aucmd_win); /* set cursor and topline to safe values */
  
  #ifdef FEAT_WINDOWS
! 	/* Split the current window, put the aucmd_win in the upper half.
! 	 * We don't want the BufEnter or WinEnter autocommands. */
! 	block_autocmds();
  	make_snapshot(SNAP_AUCMD_IDX);
  	save_ea = p_ea;
  	p_ea = FALSE;
  	(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);
  	(void)win_comp_pos();   /* recompute window positions */
  	p_ea = save_ea;
+ 	unblock_autocmds();
  #endif
  	curwin = aucmd_win;
      }
***************
*** 8474,8480 ****
  	--curbuf->b_nwindows;
  #ifdef FEAT_WINDOWS
  	/* Find "aucmd_win", it can't be closed, but it may be in another tab
! 	 * page. */
  	if (curwin != aucmd_win)
  	{
  	    tabpage_T	*tp;
--- 8477,8484 ----
  	--curbuf->b_nwindows;
  #ifdef FEAT_WINDOWS
  	/* Find "aucmd_win", it can't be closed, but it may be in another tab
! 	 * page. Do not trigger autocommands here. */
! 	block_autocmds();
  	if (curwin != aucmd_win)
  	{
  	    tabpage_T	*tp;
***************
*** 8498,8503 ****
--- 8502,8508 ----
  	last_status(FALSE);	    /* may need to remove last status line */
  	restore_snapshot(SNAP_AUCMD_IDX, FALSE);
  	(void)win_comp_pos();   /* recompute window positions */
+ 	unblock_autocmds();
  
  	if (win_valid(aco->save_curwin))
  	    curwin = aco->save_curwin;
*** ../vim-7.2.219/src/version.c	2009-07-01 16:12:54.000000000 +0200
--- src/version.c	2009-07-01 17:10:22.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     220,
  /**/

-- 
Microsoft is to software what McDonalds is to gourmet cooking

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.221
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.221
Problem:    X cut_buffer0 text is used as-is, it may be in the wrong encoding.
Solution:   Convert between 'enc' and latin1. (James Vega)
Files:	    src/gui_gtk_x11.c, src/message.c, src/ops.c, src/proto/ui.pro,
	    src/ui.c


*** ../vim-7.2.220/src/gui_gtk_x11.c	2009-06-16 15:23:07.000000000 +0200
--- src/gui_gtk_x11.c	2009-07-01 11:55:34.000000000 +0200
***************
*** 6717,6724 ****
  {
      GdkAtom	target;
      unsigned	i;
-     int		nbytes;
-     char_u	*buffer;
      time_t	start;
  
      for (i = 0; i < N_SELECTION_TARGETS; ++i)
--- 6717,6722 ----
***************
*** 6746,6767 ****
      }
  
      /* Final fallback position - use the X CUT_BUFFER0 store */
!     nbytes = 0;
!     buffer = (char_u *)XFetchBuffer(GDK_WINDOW_XDISPLAY(gui.mainwin->window),
! 				    &nbytes, 0);
!     if (nbytes > 0)
!     {
! 	/* Got something */
! 	clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
! 	if (p_verbose > 0)
! 	{
! 	    verbose_enter();
! 	    smsg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
! 	    verbose_leave();
! 	}
!     }
!     if (buffer != NULL)
! 	XFree(buffer);
  }
  
  /*
--- 6744,6750 ----
      }
  
      /* Final fallback position - use the X CUT_BUFFER0 store */
!     yank_cut_buffer0(GDK_WINDOW_XDISPLAY(gui.mainwin->window), cbd);
  }
  
  /*
*** ../vim-7.2.220/src/message.c	2009-05-17 13:30:58.000000000 +0200
--- src/message.c	2009-07-01 16:43:08.000000000 +0200
***************
*** 107,113 ****
  }
  
  #if defined(FEAT_EVAL) || defined(FEAT_X11) || defined(USE_XSMP) \
!     || defined(PROTO)
  /*
   * Like msg() but keep it silent when 'verbosefile' is set.
   */
--- 107,113 ----
  }
  
  #if defined(FEAT_EVAL) || defined(FEAT_X11) || defined(USE_XSMP) \
!     || defined(FEAT_GUI_GTK) || defined(PROTO)
  /*
   * Like msg() but keep it silent when 'verbosefile' is set.
   */
*** ../vim-7.2.220/src/ops.c	2009-05-26 18:12:13.000000000 +0200
--- src/ops.c	2009-07-01 12:15:31.000000000 +0200
***************
*** 5591,5596 ****
--- 5591,5619 ----
      if (dpy != NULL && str != NULL && motion_type >= 0
  					       && len < 1024*1024 && len > 0)
      {
+ #ifdef FEAT_MBYTE
+ 	/* The CUT_BUFFER0 is supposed to always contain latin1.  Convert from
+ 	 * 'enc' when it is a multi-byte encoding.  When 'enc' is an 8-bit
+ 	 * encoding conversion usually doesn't work, so keep the text as-is.
+ 	 */
+ 	if (has_mbyte)
+ 	{
+ 	    char_u	*conv_str = str;
+ 	    vimconv_T	vc;
+ 
+ 	    vc.vc_type = CONV_NONE;
+ 	    if (convert_setup(&vc, p_enc, (char_u *)"latin1") == OK)
+ 	    {
+ 		conv_str = string_convert(&vc, str, (int*)&len);
+ 		if (conv_str != NULL)
+ 		{
+ 		    vim_free(str);
+ 		    str = conv_str;
+ 		}
+ 		convert_setup(&vc, NULL, NULL);
+ 	    }
+ 	}
+ #endif
  	XStoreBuffer(dpy, (char *)str, (int)len, 0);
  	XFlush(dpy);
      }
*** ../vim-7.2.220/src/proto/ui.pro	2007-05-05 19:58:49.000000000 +0200
--- src/proto/ui.pro	2009-07-01 11:48:11.000000000 +0200
***************
*** 48,53 ****
--- 48,54 ----
  void open_app_context __ARGS((void));
  void x11_setup_atoms __ARGS((Display *dpy));
  void clip_x11_request_selection __ARGS((Widget myShell, Display *dpy, VimClipboard *cbd));
+ void yank_cut_buffer0 __ARGS((Display *dpy, VimClipboard *cbd));
  void clip_x11_lose_selection __ARGS((Widget myShell, VimClipboard *cbd));
  int clip_x11_own_selection __ARGS((Widget myShell, VimClipboard *cbd));
  void clip_x11_set_selection __ARGS((VimClipboard *cbd));
*** ../vim-7.2.220/src/ui.c	2009-05-17 13:30:58.000000000 +0200
--- src/ui.c	2009-07-01 15:44:07.000000000 +0200
***************
*** 2104,2111 ****
      Atom	type;
      static int	success;
      int		i;
-     int		nbytes = 0;
-     char_u	*buffer;
      time_t	start_time;
      int		timed_out = FALSE;
  
--- 2104,2109 ----
***************
*** 2185,2199 ****
      }
  
      /* Final fallback position - use the X CUT_BUFFER0 store */
!     buffer = (char_u *)XFetchBuffer(dpy, &nbytes, 0);
!     if (nbytes > 0)
!     {
! 	/* Got something */
! 	clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
! 	XFree((void *)buffer);
! 	if (p_verbose > 0)
! 	    verb_msg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
!     }
  }
  
  static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
--- 2183,2189 ----
      }
  
      /* Final fallback position - use the X CUT_BUFFER0 store */
!     yank_cut_buffer0(dpy, cbd);
  }
  
  static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
***************
*** 2369,2374 ****
--- 2359,2418 ----
  }
  #endif
  
+ #if defined(FEAT_XCLIPBOARD) || defined(FEAT_GUI_X11) \
+     || defined(FEAT_GUI_GTK) || defined(PROTO)
+ /*
+  * Get the contents of the X CUT_BUFFER0 and put it in "cbd".
+  */
+     void
+ yank_cut_buffer0(dpy, cbd)
+     Display		*dpy;
+     VimClipboard	*cbd;
+ {
+     int		nbytes = 0;
+     char_u	*buffer = (char_u *)XFetchBuffer(dpy, &nbytes, 0);
+ 
+     if (nbytes > 0)
+     {
+ #ifdef FEAT_MBYTE
+ 	int  done = FALSE;
+ 
+ 	/* CUT_BUFFER0 is supposed to be always latin1.  Convert to 'enc' when
+ 	 * using a multi-byte encoding.  Conversion between two 8-bit
+ 	 * character sets usually fails and the text might actually be in
+ 	 * 'enc' anyway. */
+ 	if (has_mbyte)
+ 	{
+ 	    char_u	*conv_buf = buffer;
+ 	    vimconv_T	vc;
+ 
+ 	    vc.vc_type = CONV_NONE;
+ 	    if (convert_setup(&vc, (char_u *)"latin1", p_enc) == OK)
+ 	    {
+ 		conv_buf = string_convert(&vc, buffer, &nbytes);
+ 		if (conv_buf != NULL)
+ 		{
+ 		    clip_yank_selection(MCHAR, conv_buf, (long)nbytes, cbd);
+ 		    vim_free(conv_buf);
+ 		    done = TRUE;
+ 		}
+ 		convert_setup(&vc, NULL, NULL);
+ 	    }
+ 	}
+ 	if (!done)  /* use the text without conversion */
+ #endif
+ 	    clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
+ 	XFree((void *)buffer);
+ 	if (p_verbose > 0)
+ 	{
+ 	    verbose_enter();
+ 	    verb_msg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
+ 	    verbose_leave();
+ 	}
+     }
+ }
+ #endif
+ 
  #if defined(FEAT_MOUSE) || defined(PROTO)
  
  /*
*** ../vim-7.2.220/src/version.c	2009-07-01 17:11:40.000000000 +0200
--- src/version.c	2009-07-01 17:56:02.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     221,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
40. You tell the cab driver you live at
    http://123.elm.street/house/bluetrim.html
41. You actually try that 123.elm.street address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.222
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.222
Problem:   ":mksession" doesn't work properly with 'acd' set. 
Solution:   Make it work. (Yakov Lerner)
Files:	    src/ex_docmd.c


*** ../vim-7.2.221/src/ex_docmd.c	2009-05-16 17:29:37.000000000 +0200
--- src/ex_docmd.c	2009-07-01 20:18:22.000000000 +0200
***************
*** 8686,8691 ****
--- 8693,8700 ----
      }
  
  #ifdef FEAT_SESSION
+     /* Use the short file name until ":lcd" is used.  We also don't use the
+      * short file name when 'acd' is set, that is checked later. */
      did_lcd = FALSE;
  
      /* ":mkview" or ":mkview 9": generate file name with 'viewdir' */
***************
*** 10573,10578 ****
--- 10582,10590 ----
      if (buf->b_sfname != NULL
  	    && flagp == &ssop_flags
  	    && (ssop_flags & (SSOP_CURDIR | SSOP_SESDIR))
+ #ifdef FEAT_AUTOCHDIR
+ 	    && !p_acd
+ #endif
  	    && !did_lcd)
  	name = buf->b_sfname;
      else
*** ../vim-7.2.221/src/version.c	2009-07-01 18:04:30.000000000 +0200
--- src/version.c	2009-07-01 20:16:19.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     222,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
43. You tell the kids they can't use the computer because "Daddy's got work to
    do" and you don't even have a job.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.223
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.223
Problem:    When a script is run with ":silent" it is not able to give warning
	    messages.
Solution:   Add the ":unsilent" command.
Files:	    runtime/doc/various.txt, src/ex_cmds.h, src/ex_docmd.c


*** ../vim-7.2.222/runtime/doc/various.txt	2008-08-09 19:36:54.000000000 +0200
--- runtime/doc/various.txt	2009-07-09 15:52:54.000000000 +0200
***************
*** 508,513 ****
--- 508,524 ----
  			messages though.  Use ":silent" in the command itself
  			to avoid that: ":silent menu .... :silent command".
  
+ 						*:uns* *:unsilent*
+ :uns[ilent] {command}	Execute {command} not silently.  Only makes a
+ 			difference when |:silent| was used to get to this
+ 			command.
+ 			Use this for giving a message even when |:silent| was
+ 			used.  In this example |:silent| is used to avoid the
+ 			message about reading the file and |:unsilent| to be
+ 			able to list the first line of each file. >
+     		:silent argdo unsilent echo expand('%') . ": " . getline(1)
+ <
+ 
  						*:verb* *:verbose*
  :[count]verb[ose] {command}
  			Execute {command} with 'verbose' set to [count].  If
*** ../vim-7.2.222/src/ex_cmds.h	2008-11-09 13:43:25.000000000 +0100
--- src/ex_cmds.h	2009-07-01 18:12:55.000000000 +0200
***************
*** 991,996 ****
--- 991,998 ----
  			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
  EX(CMD_unmenu,		"unmenu",	ex_menu,
  			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
+ EX(CMD_unsilent,	"unsilent",	ex_wrongmodifier,
+ 			NEEDARG|EXTRA|NOTRLCOM|SBOXOK|CMDWIN),
  EX(CMD_update,		"update",	ex_update,
  			RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR),
  EX(CMD_vglobal,		"vglobal",	ex_global,
*** ../vim-7.2.222/src/ex_docmd.c	2009-07-01 20:18:43.000000000 +0200
--- src/ex_docmd.c	2009-07-09 15:24:03.000000000 +0200
***************
*** 1677,1684 ****
      char_u		*errormsg = NULL;	/* error message */
      exarg_T		ea;			/* Ex command arguments */
      long		verbose_save = -1;
!     int			save_msg_scroll = 0;
!     int			did_silent = 0;
      int			did_esilent = 0;
  #ifdef HAVE_SANDBOX
      int			did_sandbox = FALSE;
--- 1677,1684 ----
      char_u		*errormsg = NULL;	/* error message */
      exarg_T		ea;			/* Ex command arguments */
      long		verbose_save = -1;
!     int			save_msg_scroll = msg_scroll;
!     int			save_msg_silent = -1;
      int			did_esilent = 0;
  #ifdef HAVE_SANDBOX
      int			did_sandbox = FALSE;
***************
*** 1856,1864 ****
  			}
  			if (!checkforcmd(&ea.cmd, "silent", 3))
  			    break;
! 			++did_silent;
  			++msg_silent;
- 			save_msg_scroll = msg_scroll;
  			if (*ea.cmd == '!' && !vim_iswhite(ea.cmd[-1]))
  			{
  			    /* ":silent!", but not "silent !cmd" */
--- 1856,1864 ----
  			}
  			if (!checkforcmd(&ea.cmd, "silent", 3))
  			    break;
! 			if (save_msg_silent == -1)
! 			    save_msg_silent = msg_silent;
  			++msg_silent;
  			if (*ea.cmd == '!' && !vim_iswhite(ea.cmd[-1]))
  			{
  			    /* ":silent!", but not "silent !cmd" */
***************
*** 1886,1891 ****
--- 1886,1898 ----
  #endif
  			continue;
  
+ 	    case 'u':	if (!checkforcmd(&ea.cmd, "unsilent", 3))
+ 			    break;
+ 			if (save_msg_silent == -1)
+ 			    save_msg_silent = msg_silent;
+ 			msg_silent = 0;
+ 			continue;
+ 
  	    case 'v':	if (checkforcmd(&ea.cmd, "vertical", 4))
  			{
  #ifdef FEAT_VERTSPLIT
***************
*** 2684,2696 ****
  
      cmdmod = save_cmdmod;
  
!     if (did_silent > 0)
      {
  	/* messages could be enabled for a serious error, need to check if the
  	 * counters don't become negative */
! 	msg_silent -= did_silent;
! 	if (msg_silent < 0)
! 	    msg_silent = 0;
  	emsg_silent -= did_esilent;
  	if (emsg_silent < 0)
  	    emsg_silent = 0;
--- 2691,2702 ----
  
      cmdmod = save_cmdmod;
  
!     if (save_msg_silent != -1)
      {
  	/* messages could be enabled for a serious error, need to check if the
  	 * counters don't become negative */
! 	if (!did_emsg)
! 	    msg_silent = save_msg_silent;
  	emsg_silent -= did_esilent;
  	if (emsg_silent < 0)
  	    emsg_silent = 0;
***************
*** 2987,2992 ****
--- 2993,2999 ----
      {"silent", 3, FALSE},
      {"tab", 3, TRUE},
      {"topleft", 2, FALSE},
+     {"unsilent", 3, FALSE},
      {"verbose", 4, TRUE},
      {"vertical", 4, FALSE},
  };
*** ../vim-7.2.222/src/version.c	2009-07-01 20:18:43.000000000 +0200
--- src/version.c	2009-07-09 15:53:05.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     223,
  /**/

-- 
Q: How many legs does a giraffe have?
A: Eight: two in front, two behind, two on the left and two on the right

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.224
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.224
Problem:    Crash when using 'completefunc'. (Ingo Karkat)
Solution:   Disallow entering edit() recursively when doing completion.
Files:	    src/edit.c


*** ../vim-7.2.223/src/edit.c	2009-05-26 11:01:43.000000000 +0200
--- src/edit.c	2009-07-09 18:01:49.000000000 +0200
***************
*** 114,119 ****
--- 114,123 ----
   * FALSE the word to be completed must be located. */
  static int	  compl_started = FALSE;
  
+ /* Set when doing something for completion that may call edit() recursively,
+  * which is not allowed. */
+ static int	  compl_busy = FALSE;
+ 
  static int	  compl_matches = 0;
  static char_u	  *compl_pattern = NULL;
  static int	  compl_direction = FORWARD;
***************
*** 346,352 ****
  
  #ifdef FEAT_INS_EXPAND
      /* Don't allow recursive insert mode when busy with completion. */
!     if (compl_started || pum_visible())
      {
  	EMSG(_(e_secure));
  	return FALSE;
--- 350,356 ----
  
  #ifdef FEAT_INS_EXPAND
      /* Don't allow recursive insert mode when busy with completion. */
!     if (compl_started || compl_busy || pum_visible())
      {
  	EMSG(_(e_secure));
  	return FALSE;
***************
*** 1340,1347 ****
--- 1344,1353 ----
  		goto normalchar;
  
  docomplete:
+ 	    compl_busy = TRUE;
  	    if (ins_complete(c) == FAIL)
  		compl_cont_status = 0;
+ 	    compl_busy = FALSE;
  	    break;
  #endif /* FEAT_INS_EXPAND */
  
***************
*** 3172,3177 ****
--- 3178,3184 ----
  	vim_free(match);
      } while (compl_curr_match != NULL && compl_curr_match != compl_first_match);
      compl_first_match = compl_curr_match = NULL;
+     compl_shown_match = NULL;
  }
  
      static void
*** ../vim-7.2.223/src/version.c	2009-07-09 15:55:34.000000000 +0200
--- src/version.c	2009-07-09 18:14:16.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     224,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
77. The phone company asks you to test drive their new PBX system

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.225
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.225
Problem:    When using ":normal" a saved character may be executed.
Solution:   Also store old_char when saving typeahead.
Files:	    src/getchar.c, src/structs.h


*** ../vim-7.2.224/src/getchar.c	2009-02-22 23:42:08.000000000 +0100
--- src/getchar.c	2009-07-09 18:09:13.000000000 +0200
***************
*** 1309,1314 ****
--- 1309,1317 ----
      return OK;
  }
  
+ static int old_char = -1;	/* character put back by vungetc() */
+ static int old_mod_mask;	/* mod_mask for ungotten character */
+ 
  #if defined(FEAT_EVAL) || defined(FEAT_EX_EXTRA) || defined(PROTO)
  
  /*
***************
*** 1323,1328 ****
--- 1326,1335 ----
      if (!tp->typebuf_valid)
  	typebuf = tp->save_typebuf;
  
+     tp->old_char = old_char;
+     tp->old_mod_mask = old_mod_mask;
+     old_char = -1;
+ 
      tp->save_stuffbuff = stuffbuff;
      stuffbuff.bh_first.b_next = NULL;
  # ifdef USE_INPUT_BUF
***************
*** 1344,1349 ****
--- 1351,1359 ----
  	typebuf = tp->save_typebuf;
      }
  
+     old_char = tp->old_char;
+     old_mod_mask = tp->old_mod_mask;
+ 
      free_buff(&stuffbuff);
      stuffbuff = tp->save_stuffbuff;
  # ifdef USE_INPUT_BUF
***************
*** 1499,1507 ****
  #define KL_PART_KEY -1		/* keylen value for incomplete key-code */
  #define KL_PART_MAP -2		/* keylen value for incomplete mapping */
  
- static int old_char = -1;	/* character put back by vungetc() */
- static int old_mod_mask;	/* mod_mask for ungotten character */
- 
  /*
   * Get the next input character.
   * Can return a special key or a multi-byte character.
--- 1509,1514 ----
*** ../vim-7.2.224/src/structs.h	2009-06-16 16:01:34.000000000 +0200
--- src/structs.h	2009-07-09 18:09:20.000000000 +0200
***************
*** 882,887 ****
--- 882,889 ----
  {
      typebuf_T		save_typebuf;
      int			typebuf_valid;	    /* TRUE when save_typebuf valid */
+     int			old_char;
+     int			old_mod_mask;
      struct buffheader	save_stuffbuff;
  #ifdef USE_INPUT_BUF
      char_u		*save_inputbuf;
*** ../vim-7.2.224/src/version.c	2009-07-09 18:15:19.000000000 +0200
--- src/version.c	2009-07-09 18:21:56.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     225,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
78. You find yourself dialing IP numbers on the phone.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.226
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.226
Problem:    ml_get error after deleting the last line. (Xavier de Gaye)
Solution:   When adjusting marks a callback may be invoked.  Adjust the cursor
	    position before invoking deleted_lines_mark().
Files:	    src/ex_cmds.c, src/ex_docmd.c, src/if_mzsch.c, src/if_python.c,
	    src/if_perl.xs, src/misc1.c


*** ../vim-7.2.225/src/ex_cmds.c	2009-05-17 13:30:58.000000000 +0200
--- src/ex_cmds.c	2009-07-09 12:56:51.000000000 +0200
***************
*** 4013,4018 ****
--- 4013,4021 ----
  	    break;
  	ml_delete(eap->line1, FALSE);
      }
+ 
+     /* make sure the cursor is not beyond the end of the file now */
+     check_cursor_lnum();
      deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));
  
      /* ":append" on the line above the deleted lines. */
*** ../vim-7.2.225/src/ex_docmd.c	2009-07-09 15:55:34.000000000 +0200
--- src/ex_docmd.c	2009-07-09 15:24:03.000000000 +0200
***************
*** 7845,7854 ****
  		if (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)
  		{
  		    ml_delete(lnum, FALSE);
- 		    deleted_lines_mark(lnum, 1L);
  		    if (curwin->w_cursor.lnum > 1
  					     && curwin->w_cursor.lnum >= lnum)
  			--curwin->w_cursor.lnum;
  		}
  	    }
  	    redraw_curbuf_later(VALID);
--- 7845,7854 ----
  		if (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)
  		{
  		    ml_delete(lnum, FALSE);
  		    if (curwin->w_cursor.lnum > 1
  					     && curwin->w_cursor.lnum >= lnum)
  			--curwin->w_cursor.lnum;
+ 		    deleted_lines_mark(lnum, 1L);
  		}
  	    }
  	    redraw_curbuf_later(VALID);
*** ../vim-7.2.225/src/if_mzsch.c	2009-06-24 17:51:01.000000000 +0200
--- src/if_mzsch.c	2009-07-09 12:59:17.000000000 +0200
***************
*** 2169,2177 ****
  	    curbuf = savebuf;
  	    raise_vim_exn(_("cannot delete line"));
  	}
- 	deleted_lines_mark((linenr_T)n, 1L);
  	if (buf->buf == curwin->w_buffer)
  	    mz_fix_cursor(n, n + 1, -1);
  
  	curbuf = savebuf;
  
--- 2169,2177 ----
  	    curbuf = savebuf;
  	    raise_vim_exn(_("cannot delete line"));
  	}
  	if (buf->buf == curwin->w_buffer)
  	    mz_fix_cursor(n, n + 1, -1);
+ 	deleted_lines_mark((linenr_T)n, 1L);
  
  	curbuf = savebuf;
  
***************
*** 2299,2307 ****
  		    curbuf = savebuf;
  		    raise_vim_exn(_("cannot delete line"));
  		}
- 	    deleted_lines_mark((linenr_T)lo, (long)old_len);
  	    if (buf->buf == curwin->w_buffer)
  		mz_fix_cursor(lo, hi, -old_len);
  	}
  
  	curbuf = savebuf;
--- 2299,2307 ----
  		    curbuf = savebuf;
  		    raise_vim_exn(_("cannot delete line"));
  		}
  	    if (buf->buf == curwin->w_buffer)
  		mz_fix_cursor(lo, hi, -old_len);
+ 	    deleted_lines_mark((linenr_T)lo, (long)old_len);
  	}
  
  	curbuf = savebuf;
*** ../vim-7.2.225/src/if_python.c	2009-05-21 23:25:38.000000000 +0200
--- src/if_python.c	2009-07-09 12:59:45.000000000 +0200
***************
*** 2497,2505 ****
  	    PyErr_SetVim(_("cannot delete line"));
  	else
  	{
- 	    deleted_lines_mark((linenr_T)n, 1L);
  	    if (buf == curwin->w_buffer)
  		py_fix_cursor((linenr_T)n, (linenr_T)n + 1, (linenr_T)-1);
  	}
  
  	curbuf = savebuf;
--- 2497,2505 ----
  	    PyErr_SetVim(_("cannot delete line"));
  	else
  	{
  	    if (buf == curwin->w_buffer)
  		py_fix_cursor((linenr_T)n, (linenr_T)n + 1, (linenr_T)-1);
+ 	    deleted_lines_mark((linenr_T)n, 1L);
  	}
  
  	curbuf = savebuf;
***************
*** 2596,2605 ****
  		    break;
  		}
  	    }
- 	    deleted_lines_mark((linenr_T)lo, (long)i);
- 
  	    if (buf == curwin->w_buffer)
  		py_fix_cursor((linenr_T)lo, (linenr_T)hi, (linenr_T)-n);
  	}
  
  	curbuf = savebuf;
--- 2596,2604 ----
  		    break;
  		}
  	    }
  	    if (buf == curwin->w_buffer)
  		py_fix_cursor((linenr_T)lo, (linenr_T)hi, (linenr_T)-n);
+ 	    deleted_lines_mark((linenr_T)lo, (long)i);
  	}
  
  	curbuf = savebuf;
*** ../vim-7.2.225/src/if_perl.xs	2009-06-16 16:01:34.000000000 +0200
--- src/if_perl.xs	2009-07-09 13:02:16.000000000 +0200
***************
*** 1233,1241 ****
  		    if (u_savedel(lnum, 1) == OK)
  		    {
  			ml_delete(lnum, 0);
  			deleted_lines_mark(lnum, 1L);
- 			if (aco.save_curbuf == curbuf)
- 			    check_cursor();
  		    }
  
  		    /* restore curwin/curbuf and a few other things */
--- 1235,1242 ----
  		    if (u_savedel(lnum, 1) == OK)
  		    {
  			ml_delete(lnum, 0);
+ 			check_cursor();
  			deleted_lines_mark(lnum, 1L);
  		    }
  
  		    /* restore curwin/curbuf and a few other things */
*** ../vim-7.2.225/src/misc1.c	2009-06-24 16:25:23.000000000 +0200
--- src/misc1.c	2009-07-09 13:00:59.000000000 +0200
***************
*** 2345,2356 ****
      int		undo;		/* if TRUE, prepare for undo */
  {
      long	n;
  
      if (nlines <= 0)
  	return;
  
      /* save the deleted lines for undo */
!     if (undo && u_savedel(curwin->w_cursor.lnum, nlines) == FAIL)
  	return;
  
      for (n = 0; n < nlines; )
--- 2345,2357 ----
      int		undo;		/* if TRUE, prepare for undo */
  {
      long	n;
+     linenr_T	first = curwin->w_cursor.lnum;
  
      if (nlines <= 0)
  	return;
  
      /* save the deleted lines for undo */
!     if (undo && u_savedel(first, nlines) == FAIL)
  	return;
  
      for (n = 0; n < nlines; )
***************
*** 2358,2375 ****
  	if (curbuf->b_ml.ml_flags & ML_EMPTY)	    /* nothing to delete */
  	    break;
  
! 	ml_delete(curwin->w_cursor.lnum, TRUE);
  	++n;
  
  	/* If we delete the last line in the file, stop */
! 	if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
  	    break;
      }
-     /* adjust marks, mark the buffer as changed and prepare for displaying */
-     deleted_lines_mark(curwin->w_cursor.lnum, n);
  
      curwin->w_cursor.col = 0;
      check_cursor_lnum();
  }
  
      int
--- 2359,2379 ----
  	if (curbuf->b_ml.ml_flags & ML_EMPTY)	    /* nothing to delete */
  	    break;
  
! 	ml_delete(first, TRUE);
  	++n;
  
  	/* If we delete the last line in the file, stop */
! 	if (first > curbuf->b_ml.ml_line_count)
  	    break;
      }
  
+     /* Correct the cursor position before calling deleted_lines_mark(), it may
+      * trigger a callback to display the cursor. */
      curwin->w_cursor.col = 0;
      check_cursor_lnum();
+ 
+     /* adjust marks, mark the buffer as changed and prepare for displaying */
+     deleted_lines_mark(first, n);
  }
  
      int
***************
*** 2621,2626 ****
--- 2625,2632 ----
  
  /*
   * Like deleted_lines(), but adjust marks first.
+  * Make sure the cursor is on a valid line before calling, a GUI callback may
+  * be triggered to display the cursor.
   */
      void
  deleted_lines_mark(lnum, count)
*** ../vim-7.2.225/src/version.c	2009-07-09 18:24:24.000000000 +0200
--- src/version.c	2009-07-09 20:01:16.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     226,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
80. At parties, you introduce your spouse as your "service provider."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.227
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.227
Problem:    When using ":cd" in a script there is no way to track this.
Solution:   Display the directory when 'verbose' is 5 or higher.
Files:	    src/ex_docmd.c


*** ../vim-7.2.226/src/ex_docmd.c	2009-07-09 20:06:30.000000000 +0200
--- src/ex_docmd.c	2009-07-09 15:24:03.000000000 +0200
***************
*** 7964,7970 ****
  	    shorten_fnames(TRUE);
  
  	    /* Echo the new current directory if the command was typed. */
! 	    if (KeyTyped)
  		ex_pwd(eap);
  	}
  	vim_free(tofree);
--- 7964,7970 ----
  	    shorten_fnames(TRUE);
  
  	    /* Echo the new current directory if the command was typed. */
! 	    if (KeyTyped || p_verbose >= 5)
  		ex_pwd(eap);
  	}
  	vim_free(tofree);
*** ../vim-7.2.226/src/version.c	2009-07-09 20:06:30.000000000 +0200
--- src/version.c	2009-07-09 20:13:13.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     227,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
83. Batteries in the TV remote now last for months.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.228
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.228
Problem:    Cscope is limited to 8 connections.
Solution:   Allocated the connection array to handle any number of
	    connections. (Dominique Pelle)
Files:	    runtime/doc/if_cscop.txt, src/if_cscope.h, src/if_cscope.c


*** ../vim-7.2.227/runtime/doc/if_cscop.txt	2009-03-18 14:30:46.000000000 +0100
--- runtime/doc/if_cscop.txt	2009-07-09 15:40:48.000000000 +0200
***************
*** 355,367 ****
  The DJGPP-built version from http://cscope.sourceforge.net is known to not
  work with Vim.
  
! There are a couple of hard-coded limitations:
! 
!     1. The maximum number of cscope connections allowed is 8.  Do you
!     really need more?
! 
!     2. Doing a |:tjump| when |:cstag| searches the tag files is not
!     configurable (e.g., you can't do a tselect instead).
  
  ==============================================================================
  6. Suggested usage					*cscope-suggestions*
--- 355,362 ----
  The DJGPP-built version from http://cscope.sourceforge.net is known to not
  work with Vim.
  
! Hard-coded limitation: doing a |:tjump| when |:cstag| searches the tag files
! is not configurable (e.g., you can't do a tselect instead).
  
  ==============================================================================
  6. Suggested usage					*cscope-suggestions*
*** ../vim-7.2.227/src/if_cscope.h	2008-08-25 04:35:13.000000000 +0200
--- src/if_cscope.h	2009-07-09 15:39:32.000000000 +0200
***************
*** 25,31 ****
  
  #define CSCOPE_SUCCESS		0
  #define CSCOPE_FAILURE		-1
- #define CSCOPE_MAX_CONNECTIONS	8   /* you actually need more? */
  
  #define	CSCOPE_DBFILE		"cscope.out"
  #define	CSCOPE_PROMPT		">> "
--- 25,30 ----
*** ../vim-7.2.227/src/if_cscope.c	2009-05-16 17:29:37.000000000 +0200
--- src/if_cscope.c	2009-07-09 15:39:32.000000000 +0200
***************
*** 46,52 ****
  static int	    cs_find __ARGS((exarg_T *eap));
  static int	    cs_find_common __ARGS((char *opt, char *pat, int, int, int));
  static int	    cs_help __ARGS((exarg_T *eap));
- static void	    cs_init __ARGS((void));
  static void	    clear_csinfo __ARGS((int i));
  static int	    cs_insert_filelist __ARGS((char *, char *, char *,
  			struct stat *));
--- 46,51 ----
***************
*** 66,72 ****
  static int	    cs_show __ARGS((exarg_T *eap));
  
  
! static csinfo_T	    csinfo[CSCOPE_MAX_CONNECTIONS];
  static int	    eap_arg_len;    /* length of eap->arg, set in
  				       cs_lookup_cmd() */
  static cscmd_T	    cs_cmds[] =
--- 65,74 ----
  static int	    cs_show __ARGS((exarg_T *eap));
  
  
! static csinfo_T *   csinfo = NULL;
! static int	    csinfo_size = 0;	/* number of items allocated in
! 					   csinfo[] */
! 
  static int	    eap_arg_len;    /* length of eap->arg, set in
  				       cs_lookup_cmd() */
  static cscmd_T	    cs_cmds[] =
***************
*** 144,166 ****
  	}
      case EXP_CSCOPE_KILL:
  	{
! 	    static char_u	connection[2];
  
  	    /* ":cscope kill" accepts connection numbers or partial names of
  	     * the pathname of the cscope database as argument.  Only complete
  	     * with connection numbers. -1 can also be used to kill all
  	     * connections. */
! 	    for (i = 0, current_idx = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
  	    {
  		if (csinfo[i].fname == NULL)
  		    continue;
  		if (current_idx++ == idx)
  		{
! 		    /* Connection number fits in one character since
! 		     * CSCOPE_MAX_CONNECTIONS is < 10 */
! 		    connection[0] = i + '0';
! 		    connection[1] = NUL;
! 		    return connection;
  		}
  	    }
  	    return (current_idx == idx && idx > 0) ? (char_u *)"-1" : NULL;
--- 146,165 ----
  	}
      case EXP_CSCOPE_KILL:
  	{
! 	    static char	connection[5];
  
  	    /* ":cscope kill" accepts connection numbers or partial names of
  	     * the pathname of the cscope database as argument.  Only complete
  	     * with connection numbers. -1 can also be used to kill all
  	     * connections. */
! 	    for (i = 0, current_idx = 0; i < csinfo_size; i++)
  	    {
  		if (csinfo[i].fname == NULL)
  		    continue;
  		if (current_idx++ == idx)
  		{
! 		    vim_snprintf(connection, sizeof(connection), "%d", i);
! 		    return (char_u *)connection;
  		}
  	    }
  	    return (current_idx == idx && idx > 0) ? (char_u *)"-1" : NULL;
***************
*** 223,229 ****
  {
      cscmd_T *cmdp;
  
-     cs_init();
      if ((cmdp = cs_lookup_cmd(eap)) == NULL)
      {
  	cs_help(eap);
--- 222,227 ----
***************
*** 284,291 ****
  {
      int ret = FALSE;
  
-     cs_init();
- 
      if (*eap->arg == NUL)
      {
  	(void)EMSG(_("E562: Usage: cstag <ident>"));
--- 282,287 ----
***************
*** 441,447 ****
      if (num < 0 || num > 4 || (num > 0 && !dbpath))
  	return FALSE;
  
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
      {
  	if (!csinfo[i].fname)
  	    continue;
--- 437,443 ----
      if (num < 0 || num > 4 || (num > 0 && !dbpath))
  	return FALSE;
  
!     for (i = 0; i < csinfo_size; i++)
      {
  	if (!csinfo[i].fname)
  	    continue;
***************
*** 684,690 ****
      short i;
      short cnt = 0;
  
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
      {
  	if (csinfo[i].fname != NULL)
  	    cnt++;
--- 680,686 ----
      short i;
      short cnt = 0;
  
!     for (i = 0; i < csinfo_size; i++)
      {
  	if (csinfo[i].fname != NULL)
  	    cnt++;
***************
*** 1112,1118 ****
  {
      int i;
      char *cmd;
!     int nummatches[CSCOPE_MAX_CONNECTIONS], totmatches;
  #ifdef FEAT_QUICKFIX
      char cmdletter;
      char *qfpos;
--- 1108,1115 ----
  {
      int i;
      char *cmd;
!     int *nummatches;
!     int totmatches;
  #ifdef FEAT_QUICKFIX
      char cmdletter;
      char *qfpos;
***************
*** 1123,1135 ****
      if (cmd == NULL)
  	return FALSE;
  
      /* send query to all open connections, then count the total number
       * of matches so we can alloc matchesp all in one swell foop
       */
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
  	nummatches[i] = 0;
      totmatches = 0;
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
      {
  	if (csinfo[i].fname == NULL || csinfo[i].to_fp == NULL)
  	    continue;
--- 1120,1136 ----
      if (cmd == NULL)
  	return FALSE;
  
+     nummatches = (int *)alloc(sizeof(int)*csinfo_size);
+     if (nummatches == NULL)
+ 	return FALSE;
+ 
      /* send query to all open connections, then count the total number
       * of matches so we can alloc matchesp all in one swell foop
       */
!     for (i = 0; i < csinfo_size; i++)
  	nummatches[i] = 0;
      totmatches = 0;
!     for (i = 0; i < csinfo_size; i++)
      {
  	if (csinfo[i].fname == NULL || csinfo[i].to_fp == NULL)
  	    continue;
***************
*** 1154,1160 ****
--- 1155,1164 ----
  	char *buf;
  
  	if (!verbose)
+ 	{
+ 	    vim_free(nummatches);
  	    return FALSE;
+ 	}
  
  	buf = (char *)alloc((unsigned)(strlen(opt) + strlen(pat) + strlen(nf)));
  	if (buf == NULL)
***************
*** 1165,1170 ****
--- 1169,1175 ----
  	    (void)EMSG(buf);
  	    vim_free(buf);
  	}
+ 	vim_free(nummatches);
  	return FALSE;
      }
  
***************
*** 1217,1222 ****
--- 1222,1228 ----
  		(void)EMSG(buf);
  		vim_free(buf);
  	    }
+ 	    vim_free(nummatches);
  	    return FALSE;
  	}
      }
***************
*** 1264,1269 ****
--- 1270,1276 ----
  	}
  	mch_remove(tmp);
  	vim_free(tmp);
+ 	vim_free(nummatches);
  	return TRUE;
      }
      else
***************
*** 1275,1280 ****
--- 1282,1288 ----
  	/* read output */
  	cs_fill_results((char *)pat, totmatches, nummatches, &matches,
  							 &contexts, &matched);
+ 	vim_free(nummatches);
  	if (matches == NULL)
  	    return FALSE;
  
***************
*** 1328,1353 ****
  } /* cs_help */
  
  
- /*
-  * PRIVATE: cs_init
-  *
-  * initialize cscope structure if not already
-  */
-     static void
- cs_init()
- {
-     short i;
-     static int init_already = FALSE;
- 
-     if (init_already)
- 	return;
- 
-     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
- 	clear_csinfo(i);
- 
-     init_already = TRUE;
- } /* cs_init */
- 
      static void
  clear_csinfo(i)
      int	    i;
--- 1336,1341 ----
***************
*** 1444,1450 ****
  #endif
  
      i = -1; /* can be set to the index of an empty item in csinfo */
!     for (j = 0; j < CSCOPE_MAX_CONNECTIONS; j++)
      {
  	if (csinfo[j].fname != NULL
  #if defined(UNIX)
--- 1432,1438 ----
  #endif
  
      i = -1; /* can be set to the index of an empty item in csinfo */
!     for (j = 0; j < csinfo_size; j++)
      {
  	if (csinfo[j].fname != NULL
  #if defined(UNIX)
***************
*** 1471,1479 ****
  
      if (i == -1)
      {
! 	if (p_csverbose)
! 	    (void)EMSG(_("E569: maximum number of cscope connections reached"));
! 	return -1;
      }
  
      if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
--- 1459,1483 ----
  
      if (i == -1)
      {
! 	i = csinfo_size;
! 	if (csinfo_size == 0)
! 	{
! 	    /* First time allocation: allocate only 1 connection. It should
! 	     * be enough for most users.  If more is needed, csinfo will be
! 	     * reallocated. */
! 	    csinfo_size = 1;
! 	    csinfo = (csinfo_T *)alloc_clear(sizeof(csinfo_T));
! 	}
! 	else
! 	{
! 	    /* Reallocate space for more connections. */
! 	    csinfo_size *= 2;
! 	    csinfo = vim_realloc(csinfo, sizeof(csinfo_T)*csinfo_size);
! 	}
! 	if (csinfo == NULL)
! 	    return -1;
! 	for (j = csinfo_size/2; j < csinfo_size; j++)
! 	    clear_csinfo(j);
      }
  
      if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
***************
*** 1580,1594 ****
  	/* It must be part of a name.  We will try to find a match
  	 * within all the names in the csinfo data structure
  	 */
! 	for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
  	{
  	    if (csinfo[i].fname != NULL && strstr(csinfo[i].fname, stok))
  		break;
  	}
      }
  
!     if ((i >= CSCOPE_MAX_CONNECTIONS || i < -1 || csinfo[i].fname == NULL)
! 	    && i != -1)
      {
  	if (p_csverbose)
  	    (void)EMSG2(_("E261: cscope connection %s not found"), stok);
--- 1584,1597 ----
  	/* It must be part of a name.  We will try to find a match
  	 * within all the names in the csinfo data structure
  	 */
! 	for (i = 0; i < csinfo_size; i++)
  	{
  	    if (csinfo[i].fname != NULL && strstr(csinfo[i].fname, stok))
  		break;
  	}
      }
  
!     if ((i != -1) && (i >= csinfo_size || i < -1 || csinfo[i].fname == NULL))
      {
  	if (p_csverbose)
  	    (void)EMSG2(_("E261: cscope connection %s not found"), stok);
***************
*** 1597,1603 ****
      {
  	if (i == -1)
  	{
! 	    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
  	    {
  		if (csinfo[i].fname)
  		    cs_kill_execute(i, csinfo[i].fname);
--- 1600,1606 ----
      {
  	if (i == -1)
  	{
! 	    for (i = 0; i < csinfo_size; i++)
  	    {
  		if (csinfo[i].fname)
  		    cs_kill_execute(i, csinfo[i].fname);
***************
*** 1857,1863 ****
      if (buf == NULL)
  	return;
  
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
      {
  	if (nummatches_a[i] < 1)
  	    continue;
--- 1860,1866 ----
      if (buf == NULL)
  	return;
  
!     for (i = 0; i < csinfo_size; i++)
      {
  	if (nummatches_a[i] < 1)
  	    continue;
***************
*** 1929,1935 ****
      if ((cntxts = (char **)alloc(sizeof(char *) * totmatches)) == NULL)
  	goto parse_out;
  
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
      {
  	if (nummatches_a[i] < 1)
  	    continue;
--- 1932,1938 ----
      if ((cntxts = (char **)alloc(sizeof(char *) * totmatches)) == NULL)
  	goto parse_out;
  
!     for (i = 0; i < csinfo_size; i++)
      {
  	if (nummatches_a[i] < 1)
  	    continue;
***************
*** 2383,2392 ****
      int	i;
      char buf[20]; /* for sprintf " (#%d)" */
  
      /* malloc our db and ppath list */
!     dblist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
!     pplist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
!     fllist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
      if (dblist == NULL || pplist == NULL || fllist == NULL)
      {
  	vim_free(dblist);
--- 2386,2398 ----
      int	i;
      char buf[20]; /* for sprintf " (#%d)" */
  
+     if (csinfo_size == 0)
+ 	return CSCOPE_SUCCESS;
+ 
      /* malloc our db and ppath list */
!     dblist = (char **)alloc(csinfo_size * sizeof(char *));
!     pplist = (char **)alloc(csinfo_size * sizeof(char *));
!     fllist = (char **)alloc(csinfo_size * sizeof(char *));
      if (dblist == NULL || pplist == NULL || fllist == NULL)
      {
  	vim_free(dblist);
***************
*** 2395,2401 ****
  	return CSCOPE_FAILURE;
      }
  
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
      {
  	dblist[i] = csinfo[i].fname;
  	pplist[i] = csinfo[i].ppath;
--- 2401,2407 ----
  	return CSCOPE_FAILURE;
      }
  
!     for (i = 0; i < csinfo_size; i++)
      {
  	dblist[i] = csinfo[i].fname;
  	pplist[i] = csinfo[i].ppath;
***************
*** 2405,2411 ****
      }
  
      /* rebuild the cscope connection list */
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
      {
  	if (dblist[i] != NULL)
  	{
--- 2411,2417 ----
      }
  
      /* rebuild the cscope connection list */
!     for (i = 0; i < csinfo_size; i++)
      {
  	if (dblist[i] != NULL)
  	{
***************
*** 2502,2508 ****
  	MSG_PUTS_ATTR(
  	    _(" # pid    database name                       prepend path\n"),
  	    hl_attr(HLF_T));
! 	for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
  	{
  	    if (csinfo[i].fname == NULL)
  		continue;
--- 2508,2514 ----
  	MSG_PUTS_ATTR(
  	    _(" # pid    database name                       prepend path\n"),
  	    hl_attr(HLF_T));
! 	for (i = 0; i < csinfo_size; i++)
  	{
  	    if (csinfo[i].fname == NULL)
  		continue;
***************
*** 2531,2538 ****
  {
      int i;
  
!     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
  	cs_release_csp(i, TRUE);
  }
  
  #endif	/* FEAT_CSCOPE */
--- 2537,2546 ----
  {
      int i;
  
!     for (i = 0; i < csinfo_size; i++)
  	cs_release_csp(i, TRUE);
+     vim_free(csinfo);
+     csinfo_size = 0;
  }
  
  #endif	/* FEAT_CSCOPE */
*** ../vim-7.2.227/src/version.c	2009-07-09 20:13:59.000000000 +0200
--- src/version.c	2009-07-09 21:21:48.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     228,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
84. Books in your bookcase bear the names Bongo, WinSock and Inside OLE

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.229
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.229
Problem:    Warning for shadowed variable.
Solution:   Rename "wait" to "wait_time".
Files:	    src/os_unix.c


*** ../vim-7.2.228/src/os_unix.c	2009-06-16 15:12:11.000000000 +0200
--- src/os_unix.c	2009-07-09 16:24:14.000000000 +0200
***************
*** 1138,1147 ****
       * to happen).
       */
      {
! 	long wait;
! 	for (wait = 0; !sigcont_received && wait <= 3L; wait++)
  	    /* Loop is not entered most of the time */
! 	    mch_delay(wait, FALSE);
      }
  # endif
  
--- 1138,1147 ----
       * to happen).
       */
      {
! 	long wait_time;
! 	for (wait_time = 0; !sigcont_received && wait_time <= 3L; wait_time++)
  	    /* Loop is not entered most of the time */
! 	    mch_delay(wait_time, FALSE);
      }
  # endif
  
*** ../vim-7.2.228/src/version.c	2009-07-09 21:22:36.000000000 +0200
--- src/version.c	2009-07-14 12:18:21.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     229,
  /**/

-- 
From "know your smileys":
 :-)	Funny
 |-)	Funny Oriental
 (-:	Funny Australian

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.230
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.230
Problem:    A few old lint-style ARGUSED comments.
Solution:   Change to the new UNUSED style.
Files:	    src/getchar.c


*** ../vim-7.2.229/src/getchar.c	2009-07-09 18:24:24.000000000 +0200
--- src/getchar.c	2009-07-09 18:09:13.000000000 +0200
***************
*** 3708,3718 ****
   * Clear all mappings or abbreviations.
   * 'abbr' should be FALSE for mappings, TRUE for abbreviations.
   */
- /*ARGSUSED*/
      void
  map_clear(cmdp, arg, forceit, abbr)
      char_u	*cmdp;
!     char_u	*arg;
      int		forceit;
      int		abbr;
  {
--- 3708,3717 ----
   * Clear all mappings or abbreviations.
   * 'abbr' should be FALSE for mappings, TRUE for abbreviations.
   */
      void
  map_clear(cmdp, arg, forceit, abbr)
      char_u	*cmdp;
!     char_u	*arg UNUSED;
      int		forceit;
      int		abbr;
  {
***************
*** 3741,3753 ****
  /*
   * Clear all mappings in "mode".
   */
- /*ARGSUSED*/
      void
  map_clear_int(buf, mode, local, abbr)
!     buf_T	*buf;	    /* buffer for local mappings */
!     int		mode;	    /* mode in which to delete */
!     int		local;	    /* TRUE for buffer-local mappings */
!     int		abbr;	    /* TRUE for abbreviations */
  {
      mapblock_T	*mp, **mpp;
      int		hash;
--- 3740,3751 ----
  /*
   * Clear all mappings in "mode".
   */
      void
  map_clear_int(buf, mode, local, abbr)
!     buf_T	*buf UNUSED;	/* buffer for local mappings */
!     int		mode;		/* mode in which to delete */
!     int		local UNUSED;	/* TRUE for buffer-local mappings */
!     int		abbr;		/* TRUE for abbreviations */
  {
      mapblock_T	*mp, **mpp;
      int		hash;
*** ../vim-7.2.229/src/version.c	2009-07-14 12:20:28.000000000 +0200
--- src/version.c	2009-07-14 13:44:05.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     230,
  /**/

-- 
From "know your smileys":
 :~)	A man with a tape recorder up his nose

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.231
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.231
Problem:    Warning for unreacheable code.
Solution:   Add #ifdef.
Files:	    src/if_perl.xs


*** ../vim-7.2.230/src/if_perl.xs	2009-07-09 20:06:30.000000000 +0200
--- src/if_perl.xs	2009-07-09 13:02:16.000000000 +0200
***************
*** 720,728 ****
--- 720,730 ----
  #ifdef HAVE_SANDBOX
      if (sandbox)
      {
+ # ifndef MAKE_TEST  /* avoid a warning for unreachable code */
  	if ((safe = perl_get_sv( "VIM::safe", FALSE )) == NULL || !SvTRUE(safe))
  	    EMSG(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
  	else
+ # endif
  	{
  	    PUSHMARK(SP);
  	    XPUSHs(safe);
*** ../vim-7.2.230/src/version.c	2009-07-14 13:44:43.000000000 +0200
--- src/version.c	2009-07-14 16:04:07.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     231,
  /**/

-- 
From "know your smileys":
 ~#:-(	I just washed my hair, and I can't do nuthin' with it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.232
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.232
Problem:    Cannot debug problems with being in a wrong directory.
Solution:   When 'verbose' is 5 or higher report directory changes.
Files:	    src/os_unix.c, src/os_unix.h, src/proto/os_unix.pro


*** ../vim-7.2.231/src/os_unix.c	2009-07-14 12:20:28.000000000 +0200
--- src/os_unix.c	2009-07-14 17:13:15.000000000 +0200
***************
*** 319,324 ****
--- 319,341 ----
      {-1,	    "Unknown!", FALSE}
  };
  
+     int
+ mch_chdir(path)
+     char *path;
+ {
+     if (p_verbose >= 5)
+     {
+ 	verbose_enter();
+ 	smsg((char_u *)"chdir(%s)", path);
+ 	verbose_leave();
+     }
+ # ifdef VMS
+     return chdir(vms_fixfilename(path));
+ # else
+     return chdir(path);
+ # endif
+ }
+ 
  /*
   * Write s[len] to the screen.
   */
***************
*** 2424,2429 ****
--- 2441,2452 ----
  #ifdef HAVE_FCHDIR
  	    if (fd >= 0)
  	    {
+ 		if (p_verbose >= 5)
+ 		{
+ 		    verbose_enter();
+ 		    MSG("fchdir() to previous dir");
+ 		    verbose_leave();
+ 		}
  		l = fchdir(fd);
  		close(fd);
  	    }
*** ../vim-7.2.231/src/os_unix.h	2009-05-16 16:36:25.000000000 +0200
--- src/os_unix.h	2009-07-14 16:55:05.000000000 +0200
***************
*** 482,492 ****
  # else
  int mch_rename __ARGS((const char *src, const char *dest));
  # endif
- # ifdef VMS
- #  define mch_chdir(s) chdir(vms_fixfilename(s))
- # else
- #  define mch_chdir(s) chdir(s)
- # endif
  # ifndef VMS
  #  ifdef __MVS__
    /* on OS390 Unix getenv() doesn't return a pointer to persistent
--- 482,487 ----
*** ../vim-7.2.231/src/proto/os_unix.pro	2008-06-24 23:58:57.000000000 +0200
--- src/proto/os_unix.pro	2009-07-14 16:58:08.000000000 +0200
***************
*** 1,4 ****
--- 1,5 ----
  /* os_unix.c */
+ int mch_chdir __ARGS((char *path));
  void mch_write __ARGS((char_u *s, int len));
  int mch_inchar __ARGS((char_u *buf, int maxlen, long wtime, int tb_change_cnt));
  int mch_char_avail __ARGS((void));
*** ../vim-7.2.231/src/version.c	2009-07-14 16:05:14.000000000 +0200
--- src/version.c	2009-07-14 17:37:15.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     232,
  /**/

-- 
From "know your smileys":
 O:-)	Saint

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.233 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.233 (extra part of 7.2.232)
Problem:    Cannot debug problems with being in a wrong directory.
Solution:   When 'verbose' is 5 or higher report directory changes.
Files:	    src/os_msdos.c, src/os_mswin.c, src/os_riscos.c, src/os_mac.h


*** ../vim-7.2.232/src/os_msdos.c	2008-06-24 23:30:18.000000000 +0200
--- src/os_msdos.c	2009-07-14 16:50:57.000000000 +0200
***************
*** 2039,2044 ****
--- 2039,2050 ----
  {
      if (path[0] == NUL)		    /* just checking... */
  	return 0;
+     if (p_verbose >= 5)
+     {
+ 	verbose_enter();
+ 	smsg((char_u *)"chdir(%s)", path);
+ 	verbose_leave();
+     }
      if (path[1] == ':')		    /* has a drive name */
      {
  	if (change_drive(TOLOWER_ASC(path[0]) - 'a' + 1))
*** ../vim-7.2.232/src/os_mswin.c	2009-05-14 22:00:37.000000000 +0200
--- src/os_mswin.c	2009-07-14 16:53:03.000000000 +0200
***************
*** 653,658 ****
--- 653,664 ----
      if (path[0] == NUL)		/* just checking... */
  	return -1;
  
+     if (p_verbose >= 5)
+     {
+ 	verbose_enter();
+ 	smsg((char_u *)"chdir(%s)", path);
+ 	verbose_leave();
+     }
      if (isalpha(path[0]) && path[1] == ':')	/* has a drive name */
      {
  	/* If we can change to the drive, skip that part of the path.  If we
*** ../vim-7.2.232/src/os_riscos.c	2006-03-07 23:25:50.000000000 +0100
--- src/os_riscos.c	2009-07-14 16:53:35.000000000 +0200
***************
*** 1203,1208 ****
--- 1203,1214 ----
      int	    retval;
      char_u  *new_dir;
  
+     if (p_verbose >= 5)
+     {
+ 	verbose_enter();
+ 	smsg((char_u *)"chdir(%s)", dir);
+ 	verbose_leave();
+     }
      length = strlen(dir);
      if (dir[length - 1] != '.')
  	return chdir(dir);	    /* No trailing dots - nothing to do. */
*** ../vim-7.2.232/src/os_mac.h	2009-06-24 16:41:01.000000000 +0200
--- src/os_mac.h	2009-07-14 16:54:33.000000000 +0200
***************
*** 291,297 ****
  #  define HAVE_SETENV
  #  define HAVE_RENAME
  # endif
- # define mch_chdir(s) chdir(s)
  #endif
  
  #if defined(MACOS_X) && !defined(HAVE_CONFIG_H)
--- 291,296 ----
*** ../vim-7.2.232/src/version.c	2009-07-14 17:38:51.000000000 +0200
--- src/version.c	2009-07-14 18:35:30.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     233,
  /**/

-- 
From "know your smileys":
 :-O>-o   Smiley American tourist (note big mouth and camera)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.234
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.234
Problem:    It is not possible to ignore file names without a suffix.
Solution:   Use an empty entry in 'suffixes' for file names without a dot.
Files:	    runtime/doc/cmdline.txt, src/misc1.c


*** ../vim-7.2.233/runtime/doc/cmdline.txt	2008-11-09 13:43:25.000000000 +0100
--- runtime/doc/cmdline.txt	2009-07-14 13:35:56.000000000 +0200
***************
*** 441,453 ****
  those files with an extension that is in the 'suffixes' option are ignored.
  The default is ".bak,~,.o,.h,.info,.swp,.obj", which means that files ending
  in ".bak", "~", ".o", ".h", ".info", ".swp" and ".obj" are sometimes ignored.
! It is impossible to ignore suffixes with two dots.  Examples:
  
    pattern:	files:				match:	~
     test*	test.c test.h test.o		test.c
     test*	test.h test.o			test.h and test.o
     test*	test.i test.h test.c		test.i and test.c
  
  If there is more than one matching file (after ignoring the ones matching
  the 'suffixes' option) the first file name is inserted.  You can see that
  there is only one match when you type 'wildchar' twice and the completed
--- 439,458 ----
  those files with an extension that is in the 'suffixes' option are ignored.
  The default is ".bak,~,.o,.h,.info,.swp,.obj", which means that files ending
  in ".bak", "~", ".o", ".h", ".info", ".swp" and ".obj" are sometimes ignored.
! 
! An empty entry, two consecutive commas, match a file name that does not
! contain a ".", thus has no suffix.  This is useful to ignore "prog" and prefer
! "prog.c".
! 
! Examples:
  
    pattern:	files:				match:	~
     test*	test.c test.h test.o		test.c
     test*	test.h test.o			test.h and test.o
     test*	test.i test.h test.c		test.i and test.c
  
+ It is impossible to ignore suffixes with two dots.
+ 
  If there is more than one matching file (after ignoring the ones matching
  the 'suffixes' option) the first file name is inserted.  You can see that
  there is only one match when you type 'wildchar' twice and the completed
*** ../vim-7.2.233/src/misc1.c	2009-07-09 20:06:30.000000000 +0200
--- src/misc1.c	2009-07-14 15:51:55.000000000 +0200
***************
*** 8533,8543 ****
      for (setsuf = p_su; *setsuf; )
      {
  	setsuflen = copy_option_part(&setsuf, suf_buf, MAXSUFLEN, ".,");
! 	if (fnamelen >= setsuflen
! 		&& fnamencmp(suf_buf, fname + fnamelen - setsuflen,
! 					      (size_t)setsuflen) == 0)
! 	    break;
! 	setsuflen = 0;
      }
      return (setsuflen != 0);
  }
--- 8534,8558 ----
      for (setsuf = p_su; *setsuf; )
      {
  	setsuflen = copy_option_part(&setsuf, suf_buf, MAXSUFLEN, ".,");
! 	if (setsuflen == 0)
! 	{
! 	    char_u *tail = gettail(fname);
! 
! 	    /* empty entry: match name without a '.' */
! 	    if (vim_strchr(tail, '.') == NULL)
! 	    {
! 		setsuflen = 1;
! 		break;
! 	    }
! 	}
! 	else
! 	{
! 	    if (fnamelen >= setsuflen
! 		    && fnamencmp(suf_buf, fname + fnamelen - setsuflen,
! 						  (size_t)setsuflen) == 0)
! 		break;
! 	    setsuflen = 0;
! 	}
      }
      return (setsuflen != 0);
  }
*** ../vim-7.2.233/src/version.c	2009-07-14 18:38:09.000000000 +0200
--- src/version.c	2009-07-14 21:38:30.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     234,
  /**/

-- 
How many light bulbs does it take to change a person?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.235
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.235
Problem:    Using CTRL-O z= in Insert mode has a delay before redrawing.
Solution:   Reset msg_didout and msg_scroll.
Files:	    src/misc1.c, src/spell.c


*** ../vim-7.2.234/src/misc1.c	2009-07-14 21:40:30.000000000 +0200
--- src/misc1.c	2009-07-14 15:51:55.000000000 +0200
***************
*** 3276,3281 ****
--- 3276,3282 ----
  	cmdline_row = msg_row - 1;
  	need_wait_return = FALSE;
  	msg_didany = FALSE;
+ 	msg_didout = FALSE;
      }
      else
  	cmdline_row = save_cmdline_row;
*** ../vim-7.2.234/src/spell.c	2009-05-17 13:30:58.000000000 +0200
--- src/spell.c	2009-07-14 15:57:55.000000000 +0200
***************
*** 10252,10257 ****
--- 10252,10258 ----
      int		limit;
      int		selected = count;
      int		badlen = 0;
+     int		msg_scroll_save = msg_scroll;
  
      if (no_spell_checking(curwin))
  	return;
***************
*** 10416,10422 ****
  	selected = prompt_for_number(&mouse_used);
  	if (mouse_used)
  	    selected -= lines_left;
! 	lines_left = Rows;	/* avoid more prompt */
      }
  
      if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)
--- 10417,10425 ----
  	selected = prompt_for_number(&mouse_used);
  	if (mouse_used)
  	    selected -= lines_left;
! 	lines_left = Rows;		/* avoid more prompt */
! 	/* don't delay for 'smd' in normal_cmd() */
! 	msg_scroll = msg_scroll_save;
      }
  
      if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)
***************
*** 10441,10447 ****
  	}
  
  	/* Replace the word. */
! 	p = alloc((unsigned)STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);
  	if (p != NULL)
  	{
  	    c = (int)(sug.su_badptr - line);
--- 10444,10451 ----
  	}
  
  	/* Replace the word. */
! 	p = alloc((unsigned)STRLEN(line) - stp->st_orglen
! 						       + stp->st_wordlen + 1);
  	if (p != NULL)
  	{
  	    c = (int)(sug.su_badptr - line);
*** ../vim-7.2.234/src/version.c	2009-07-14 21:40:30.000000000 +0200
--- src/version.c	2009-07-22 11:00:34.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     235,
  /**/

-- 
From "know your smileys":
 |-(	Contact lenses, but has lost them

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.236
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.236
Problem:    Mac: Compiling with Ruby doesn't always work.
Solution:   In configure filter out the --arch argument (Bjorn Winckler)
Files:	    src/configure.in, src/auto/configure


*** ../vim-7.2.235/src/configure.in	2009-05-26 22:58:43.000000000 +0200
--- src/configure.in	2009-07-14 16:09:34.000000000 +0200
***************
*** 984,990 ****
  	fi
  	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG[["LDFLAGS"]]'`
  	if test "X$rubyldflags" != "X"; then
! 	  LDFLAGS="$rubyldflags $LDFLAGS"
  	fi
  	RUBY_SRC="if_ruby.c"
  	RUBY_OBJ="objects/if_ruby.o"
--- 984,996 ----
  	fi
  	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG[["LDFLAGS"]]'`
  	if test "X$rubyldflags" != "X"; then
! 	  dnl Ruby on Mac OS X 10.5 adds "-arch" flags but these should only
! 	  dnl be included if requested by passing --with-mac-arch to
! 	  dnl configure, so strip these flags first (if present)
! 	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//'`
! 	  if test "X$rubyldflags" != "X"; then
! 	    LDFLAGS="$rubyldflags $LDFLAGS"
! 	  fi
  	fi
  	RUBY_SRC="if_ruby.c"
  	RUBY_OBJ="objects/if_ruby.o"
*** ../vim-7.2.235/src/auto/configure	2009-05-26 22:58:43.000000000 +0200
--- src/auto/configure	2009-07-14 16:11:58.000000000 +0200
***************
*** 5780,5786 ****
  	fi
  	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG["LDFLAGS"]'`
  	if test "X$rubyldflags" != "X"; then
! 	  LDFLAGS="$rubyldflags $LDFLAGS"
  	fi
  	RUBY_SRC="if_ruby.c"
  	RUBY_OBJ="objects/if_ruby.o"
--- 5780,5789 ----
  	fi
  	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG["LDFLAGS"]'`
  	if test "X$rubyldflags" != "X"; then
! 	  	  	  	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//'`
! 	  if test "X$rubyldflags" != "X"; then
! 	    LDFLAGS="$rubyldflags $LDFLAGS"
! 	  fi
  	fi
  	RUBY_SRC="if_ruby.c"
  	RUBY_OBJ="objects/if_ruby.o"
*** ../vim-7.2.235/src/version.c	2009-07-22 11:03:38.000000000 +0200
--- src/version.c	2009-07-22 11:14:38.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     236,
  /**/

-- 
From "know your smileys":
 <|-) Chinese
 <|-( Chinese and doesn't like these kind of jokes

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.237
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.237
Problem:    Crash on exit when window icon not set.
Solution:   Copy terminal name when using it for the icon name.
Files:	    src/os_unix.c


*** ../vim-7.2.236/src/os_unix.c	2009-07-14 17:38:51.000000000 +0200
--- src/os_unix.c	2009-07-14 18:30:04.000000000 +0200
***************
*** 1734,1742 ****
      if (oldicon == NULL && !test_only)
      {
  	if (STRNCMP(T_NAME, "builtin_", 8) == 0)
! 	    oldicon = T_NAME + 8;
  	else
! 	    oldicon = T_NAME;
      }
  
      return retval;
--- 1734,1742 ----
      if (oldicon == NULL && !test_only)
      {
  	if (STRNCMP(T_NAME, "builtin_", 8) == 0)
! 	    oldicon = vim_strsave(T_NAME + 8);
  	else
! 	    oldicon = vim_strsave(T_NAME);
      }
  
      return retval;
***************
*** 1939,1947 ****
      if (!test_only)
      {
  	if (STRNCMP(T_NAME, "builtin_", 8) == 0)
! 	    oldicon = T_NAME + 8;
  	else
! 	    oldicon = T_NAME;
      }
      return FALSE;
  }
--- 1939,1947 ----
      if (!test_only)
      {
  	if (STRNCMP(T_NAME, "builtin_", 8) == 0)
! 	    oldicon = vim_strsave(T_NAME + 8);
  	else
! 	    oldicon = vim_strsave(T_NAME);
      }
      return FALSE;
  }
*** ../vim-7.2.236/src/version.c	2009-07-22 11:16:54.000000000 +0200
--- src/version.c	2009-07-22 13:26:30.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     237,
  /**/

-- 
Common sense is what tells you that the world is flat.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.238
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.238
Problem:    Leaking memory when setting term to "builtin_dumb".
Solution:   Free memory when resetting term option t_Co.
Files:	    src/option.c, src/proto/option.pro, src/term.c


*** ../vim-7.2.237/src/option.c	2009-06-16 17:50:56.000000000 +0200
--- src/option.c	2009-07-22 12:49:19.000000000 +0200
***************
*** 403,410 ****
  #define P_NUM		0x02	/* the option is numeric */
  #define P_STRING	0x04	/* the option is a string */
  #define P_ALLOCED	0x08	/* the string option is in allocated memory,
! 				    must use vim_free() when assigning new
! 				    value. Not set if default is the same. */
  #define P_EXPAND	0x10	/* environment expansion.  NOTE: P_EXPAND can
  				   never be used for local or hidden options! */
  #define P_NODEFAULT	0x40	/* don't set to default value */
--- 403,411 ----
  #define P_NUM		0x02	/* the option is numeric */
  #define P_STRING	0x04	/* the option is a string */
  #define P_ALLOCED	0x08	/* the string option is in allocated memory,
! 				   must use free_string_option() when
! 				   assigning new value. Not set if default is
! 				   the same. */
  #define P_EXPAND	0x10	/* environment expansion.  NOTE: P_EXPAND can
  				   never be used for local or hidden options! */
  #define P_NODEFAULT	0x40	/* don't set to default value */
***************
*** 8927,8932 ****
--- 8928,8955 ----
  }
  
  /*
+  * Free the string for one term option, if it was allocated.
+  * Set the string to empty_option and clear allocated flag.
+  * "var" points to the option value.
+  */
+     void
+ free_one_termoption(var)
+     char_u *var;
+ {
+     struct vimoption   *p;
+ 
+     for (p = &options[0]; p->fullname != NULL; p++)
+ 	if (p->var == var)
+ 	{
+ 	    if (p->flags & P_ALLOCED)
+ 		free_string_option(*(char_u **)(p->var));
+ 	    *(char_u **)(p->var) = empty_option;
+ 	    p->flags &= ~P_ALLOCED;
+ 	    break;
+ 	}
+ }
+ 
+ /*
   * Set the terminal option defaults to the current value.
   * Used after setting the terminal name.
   */
*** ../vim-7.2.237/src/proto/option.pro	2009-02-21 20:27:00.000000000 +0100
--- src/proto/option.pro	2009-07-22 12:52:31.000000000 +0200
***************
*** 29,34 ****
--- 29,35 ----
  int makefoldset __ARGS((FILE *fd));
  void clear_termoptions __ARGS((void));
  void free_termoptions __ARGS((void));
+ void free_one_termoption __ARGS((char_u *var));
  void set_term_defaults __ARGS((void));
  void comp_col __ARGS((void));
  char_u *get_equalprg __ARGS((void));
*** ../vim-7.2.237/src/term.c	2009-06-16 14:31:56.000000000 +0200
--- src/term.c	2009-07-22 13:19:59.000000000 +0200
***************
*** 2881,2887 ****
  
  	/* if 'Sb' and 'AB' are not defined, reset "Co" */
  	if (*T_CSB == NUL && *T_CAB == NUL)
! 	    T_CCO = empty_option;
  
  	/* Set 'weirdinvert' according to value of 't_xs' */
  	p_wiv = (*T_XS != NUL);
--- 2881,2887 ----
  
  	/* if 'Sb' and 'AB' are not defined, reset "Co" */
  	if (*T_CSB == NUL && *T_CAB == NUL)
! 	    free_one_termoption(T_CCO);
  
  	/* Set 'weirdinvert' according to value of 't_xs' */
  	p_wiv = (*T_XS != NUL);
*** ../vim-7.2.237/src/version.c	2009-07-22 13:27:50.000000000 +0200
--- src/version.c	2009-07-22 14:25:44.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     238,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
95. Only communication in your household is through email.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.239
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.239
Problem:    Using :diffpatch twice or when patching fails causes memory
	    corruption and/or a crash.  (Bryan Venteicher)
Solution:   Detect missing output file.  Avoid using non-existing buffer.
Files:	    src/diff.c


*** ../vim-7.2.238/src/diff.c	2009-05-14 22:19:19.000000000 +0200
--- src/diff.c	2009-07-22 16:06:21.000000000 +0200
***************
*** 893,898 ****
--- 893,899 ----
      char_u	*browseFile = NULL;
      int		browse_flag = cmdmod.browse;
  #endif
+     struct stat st;
  
  #ifdef FEAT_BROWSE
      if (cmdmod.browse)
***************
*** 999,1042 ****
      STRCAT(buf, ".rej");
      mch_remove(buf);
  
!     if (curbuf->b_fname != NULL)
      {
! 	newname = vim_strnsave(curbuf->b_fname,
  					  (int)(STRLEN(curbuf->b_fname) + 4));
! 	if (newname != NULL)
! 	    STRCAT(newname, ".new");
!     }
  
  #ifdef FEAT_GUI
!     need_mouse_correct = TRUE;
  #endif
!     /* don't use a new tab page, each tab page has its own diffs */
!     cmdmod.tab = 0;
! 
!     if (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)
!     {
! 	/* Pretend it was a ":split fname" command */
! 	eap->cmdidx = CMD_split;
! 	eap->arg = tmp_new;
! 	do_exedit(eap, old_curwin);
  
! 	if (curwin != old_curwin)		/* split must have worked */
  	{
! 	    /* Set 'diff', 'scrollbind' on and 'wrap' off. */
! 	    diff_win_options(curwin, TRUE);
! 	    diff_win_options(old_curwin, TRUE);
  
! 	    if (newname != NULL)
  	    {
! 		/* do a ":file filename.new" on the patched buffer */
! 		eap->arg = newname;
! 		ex_file(eap);
  
  #ifdef FEAT_AUTOCMD
! 		/* Do filetype detection with the new name. */
! 		if (au_has_group((char_u *)"filetypedetect"))
! 		    do_cmdline_cmd((char_u *)":doau filetypedetect BufRead");
  #endif
  	    }
  	}
      }
--- 1000,1050 ----
      STRCAT(buf, ".rej");
      mch_remove(buf);
  
!     /* Only continue if the output file was created. */
!     if (mch_stat((char *)tmp_new, &st) < 0 || st.st_size == 0)
! 	EMSG(_("E816: Cannot read patch output"));
!     else
      {
! 	if (curbuf->b_fname != NULL)
! 	{
! 	    newname = vim_strnsave(curbuf->b_fname,
  					  (int)(STRLEN(curbuf->b_fname) + 4));
! 	    if (newname != NULL)
! 		STRCAT(newname, ".new");
! 	}
  
  #ifdef FEAT_GUI
! 	need_mouse_correct = TRUE;
  #endif
! 	/* don't use a new tab page, each tab page has its own diffs */
! 	cmdmod.tab = 0;
  
! 	if (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)
  	{
! 	    /* Pretend it was a ":split fname" command */
! 	    eap->cmdidx = CMD_split;
! 	    eap->arg = tmp_new;
! 	    do_exedit(eap, old_curwin);
  
! 	    /* check that split worked and editing tmp_new */
! 	    if (curwin != old_curwin && win_valid(old_curwin))
  	    {
! 		/* Set 'diff', 'scrollbind' on and 'wrap' off. */
! 		diff_win_options(curwin, TRUE);
! 		diff_win_options(old_curwin, TRUE);
! 
! 		if (newname != NULL)
! 		{
! 		    /* do a ":file filename.new" on the patched buffer */
! 		    eap->arg = newname;
! 		    ex_file(eap);
  
  #ifdef FEAT_AUTOCMD
! 		    /* Do filetype detection with the new name. */
! 		    if (au_has_group((char_u *)"filetypedetect"))
! 			do_cmdline_cmd((char_u *)":doau filetypedetect BufRead");
  #endif
+ 		}
  	    }
  	}
      }
*** ../vim-7.2.238/src/version.c	2009-07-22 14:27:33.000000000 +0200
--- src/version.c	2009-07-22 16:21:29.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     239,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
97. Your mother tells you to remember something, and you look for
    a File/Save command.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.240
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.240
Problem:    Crash when using find/replace dialog repeatedly. (Michiel
	    Hartsuiker)
Solution:   Avoid doing the operation while busy or recursively.  Also refuse
	    replace when text is locked.
Files:	    src/gui.c


*** ../vim-7.2.239/src/gui.c	2009-06-24 18:31:36.000000000 +0200
--- src/gui.c	2009-07-22 16:54:16.000000000 +0200
***************
*** 5004,5009 ****
--- 5004,5022 ----
      char_u	*p;
      regmatch_T	regmatch;
      int		save_did_emsg = did_emsg;
+     static int  busy = FALSE;
+ 
+     /* When the screen is being updated we should not change buffers and
+      * windows structures, it may cause freed memory to be used.  Also don't
+      * do this recursively (pressing "Find" quickly several times. */
+     if (updating_screen || busy)
+ 	return FALSE;
+ 
+     /* refuse replace when text cannot be changed */
+     if ((type == FRD_REPLACE || type == FRD_REPLACEALL) && text_locked())
+ 	return FALSE;
+ 
+     busy = TRUE;
  
      ga_init2(&ga, 1, 100);
      if (type == FRD_REPLACEALL)
***************
*** 5094,5099 ****
--- 5107,5113 ----
      }
  
      vim_free(ga.ga_data);
+     busy = FALSE;
      return (ga.ga_len > 0);
  }
  
*** ../vim-7.2.239/src/version.c	2009-07-22 16:22:33.000000000 +0200
--- src/version.c	2009-07-29 11:09:13.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     240,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
113. You are asked about a bus schedule, you wonder if it is 16 or 32 bits.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.241
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.241
Problem:    When using a combination of ":bufdo" and "doautoall" we may end up
	    in the wrong directory. (Ajit Thakkar)
	    Crash when triggering an autocommand in ":vimgrep".  (Yukihiro
	    Nakadaira)
Solution:   Clear w_localdir and globaldir when using the aucmd_win.
	    Use a separate flag to decide aucmd_win needs to be restored.
Files:	    src/fileio.c, src/globals.h, src/structs.h


*** ../vim-7.2.240/src/fileio.c	2009-07-01 17:11:40.000000000 +0200
--- src/fileio.c	2009-07-22 19:08:55.000000000 +0200
***************
*** 8420,8425 ****
--- 8420,8429 ----
  	if (aucmd_win == NULL)
  	    win = curwin;
      }
+     if (win == NULL && aucmd_win_used)
+ 	/* Strange recursive autocommand, fall back to using the current
+ 	 * window.  Expect a few side effects... */
+ 	win = curwin;
  
      aco->save_curwin = curwin;
      aco->save_curbuf = curbuf;
***************
*** 8428,8433 ****
--- 8432,8438 ----
  	/* There is a window for "buf" in the current tab page, make it the
  	 * curwin.  This is preferred, it has the least side effects (esp. if
  	 * "buf" is curbuf). */
+ 	aco->use_aucmd_win = FALSE;
  	curwin = win;
      }
      else
***************
*** 8436,8444 ****
--- 8441,8460 ----
  	 * effects, insert it in a the current tab page.
  	 * Anything related to a window (e.g., setting folds) may have
  	 * unexpected results. */
+ 	aco->use_aucmd_win = TRUE;
+ 	aucmd_win_used = TRUE;
  	aucmd_win->w_buffer = buf;
  	++buf->b_nwindows;
  	win_init_empty(aucmd_win); /* set cursor and topline to safe values */
+ 	vim_free(aucmd_win->w_localdir);
+ 	aucmd_win->w_localdir = NULL;
+ 
+ 	/* Make sure w_localdir and globaldir are NULL to avoid a chdir() in
+ 	 * win_enter_ext(). */
+ 	aucmd_win->w_localdir = NULL;
+ 	aco->globaldir = globaldir;
+ 	globaldir = NULL;
+ 
  
  #ifdef FEAT_WINDOWS
  	/* Split the current window, put the aucmd_win in the upper half.
***************
*** 8472,8478 ****
      int dummy;
  #endif
  
!     if (aco->new_curwin == aucmd_win)
      {
  	--curbuf->b_nwindows;
  #ifdef FEAT_WINDOWS
--- 8488,8494 ----
      int dummy;
  #endif
  
!     if (aco->use_aucmd_win)
      {
  	--curbuf->b_nwindows;
  #ifdef FEAT_WINDOWS
***************
*** 8499,8504 ****
--- 8515,8521 ----
  	/* Remove the window and frame from the tree of frames. */
  	(void)winframe_remove(curwin, &dummy, NULL);
  	win_remove(curwin, NULL);
+ 	aucmd_win_used = FALSE;
  	last_status(FALSE);	    /* may need to remove last status line */
  	restore_snapshot(SNAP_AUCMD_IDX, FALSE);
  	(void)win_comp_pos();   /* recompute window positions */
***************
*** 8517,8522 ****
--- 8534,8542 ----
  #endif
  	curbuf = curwin->w_buffer;
  
+ 	vim_free(globaldir);
+ 	globaldir = aco->globaldir;
+ 
  	/* the buffer contents may have changed */
  	check_cursor();
  	if (curwin->w_topline > curbuf->b_ml.ml_line_count)
***************
*** 8541,8547 ****
  #endif
  	{
  	    /* Restore the buffer which was previously edited by curwin, if
! 	     * it was chagned, we are still the same window and the buffer is
  	     * valid. */
  	    if (curwin == aco->new_curwin
  		    && curbuf != aco->new_curbuf
--- 8561,8567 ----
  #endif
  	{
  	    /* Restore the buffer which was previously edited by curwin, if
! 	     * it was changed, we are still the same window and the buffer is
  	     * valid. */
  	    if (curwin == aco->new_curwin
  		    && curbuf != aco->new_curbuf
*** ../vim-7.2.240/src/globals.h	2009-06-16 16:01:34.000000000 +0200
--- src/globals.h	2009-07-22 19:50:53.000000000 +0200
***************
*** 541,546 ****
--- 541,547 ----
  
  #ifdef FEAT_AUTOCMD
  EXTERN win_T	*aucmd_win;	/* window used in aucmd_prepbuf() */
+ EXTERN int	aucmd_win_used INIT(= FALSE);	/* aucmd_win is being used */
  #endif
  
  /*
*** ../vim-7.2.240/src/structs.h	2009-07-09 18:24:24.000000000 +0200
--- src/structs.h	2009-07-22 18:58:35.000000000 +0200
***************
*** 2288,2296 ****
--- 2288,2298 ----
  {
      buf_T	*save_curbuf;	/* saved curbuf */
  #ifdef FEAT_AUTOCMD
+     int		use_aucmd_win;	/* using aucmd_win */
      win_T	*save_curwin;	/* saved curwin */
      win_T	*new_curwin;	/* new curwin */
      buf_T	*new_curbuf;	/* new curbuf */
+     char_u	*globaldir;	/* saved value of globaldir */
  #endif
  } aco_save_T;
  
*** ../vim-7.2.240/src/version.c	2009-07-29 11:10:31.000000000 +0200
--- src/version.c	2009-07-29 12:06:31.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     241,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
114. You are counting items, you go "0,1,2,3,4,5,6,7,8,9,A,B,C,D...".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.242
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.242
Problem:    Setting 'lazyredraw' causes the cursor column to be recomputed.
	    (Tom Link)
Solution:   Only recompute the cursor column for a boolean option if changes
	    the cursor position.
Files:	    src/option.c


*** ../vim-7.2.241/src/option.c	2009-07-22 14:27:33.000000000 +0200
--- src/option.c	2009-07-29 10:03:39.000000000 +0200
***************
*** 7194,7199 ****
--- 7194,7207 ----
  	compatible_set();
      }
  
+     /* 'list', 'number' */
+     else if ((int *)varp == &curwin->w_p_list
+ 	  || (int *)varp == &curwin->w_p_nu)
+     {
+ 	if (curwin->w_curswant != MAXCOL)
+ 	    curwin->w_set_curswant = TRUE;
+     }
+ 
      else if ((int *)varp == &curbuf->b_p_ro)
      {
  	/* when 'readonly' is reset globally, also reset readonlymode */
***************
*** 7645,7650 ****
--- 7653,7666 ----
  	    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;
  # endif
  	}
+ 	if (curwin->w_curswant != MAXCOL)
+ 	    curwin->w_set_curswant = TRUE;
+     }
+ 
+     else if ((int *)varp == &p_arshape)
+     {
+ 	if (curwin->w_curswant != MAXCOL)
+ 	    curwin->w_set_curswant = TRUE;
      }
  #endif
  
***************
*** 7655,7662 ****
      options[opt_idx].flags |= P_WAS_SET;
  
      comp_col();			    /* in case 'ruler' or 'showcmd' changed */
!     if (curwin->w_curswant != MAXCOL)
! 	curwin->w_set_curswant = TRUE;  /* in case 'list' changed */
      check_redraw(options[opt_idx].flags);
  
      return NULL;
--- 7671,7677 ----
      options[opt_idx].flags |= P_WAS_SET;
  
      comp_col();			    /* in case 'ruler' or 'showcmd' changed */
! 
      check_redraw(options[opt_idx].flags);
  
      return NULL;
*** ../vim-7.2.241/src/version.c	2009-07-29 12:09:49.000000000 +0200
--- src/version.c	2009-07-29 15:40:43.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     242,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
117. You are more comfortable typing in html.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.243
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.243
Problem:    Memory leak when using :vimgrep and resizing. (Dominique Pelle)
Solution:   Free memory for aucmd_win when resizing and don't allocate it
	    twice.
Files:	    src/screen.c


*** ../vim-7.2.242/src/screen.c	2009-06-16 17:22:38.000000000 +0200
--- src/screen.c	2009-07-29 15:59:37.000000000 +0200
***************
*** 7467,7472 ****
--- 7467,7476 ----
       */
      FOR_ALL_TAB_WINDOWS(tp, wp)
  	win_free_lsize(wp);
+ #ifdef FEAT_AUTOCMD
+     if (aucmd_win != NULL)
+ 	win_free_lsize(aucmd_win);
+ #endif
  
      new_ScreenLines = (schar_T *)lalloc((long_u)(
  			      (Rows + 1) * Columns * sizeof(schar_T)), FALSE);
***************
*** 7504,7510 ****
  	}
      }
  #ifdef FEAT_AUTOCMD
!     if (aucmd_win != NULL && win_alloc_lines(aucmd_win) == FAIL)
  	outofmem = TRUE;
  #endif
  #ifdef FEAT_WINDOWS
--- 7508,7515 ----
  	}
      }
  #ifdef FEAT_AUTOCMD
!     if (aucmd_win != NULL && aucmd_win->w_lines == NULL
! 					&& win_alloc_lines(aucmd_win) == FAIL)
  	outofmem = TRUE;
  #endif
  #ifdef FEAT_WINDOWS
*** ../vim-7.2.242/src/version.c	2009-07-29 15:41:32.000000000 +0200
--- src/version.c	2009-07-29 16:07:47.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     243,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
118. You are on a first-name basis with your ISP's staff.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.244
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.244
Problem:    When 'enc' is utf-8 and 'fenc' is latin1, writing a non-latin1
	    character gives a conversion error without any hint what is wrong.
Solution:   When known add the line number to the error message.
Files:	    src/fileio.c


*** ../vim-7.2.243/src/fileio.c	2009-07-29 12:09:49.000000000 +0200
--- src/fileio.c	2009-07-29 17:04:06.000000000 +0200
***************
*** 121,126 ****
--- 121,128 ----
      char_u	*bw_conv_buf;	/* buffer for writing converted chars */
      int		bw_conv_buflen; /* size of bw_conv_buf */
      int		bw_conv_error;	/* set for conversion error */
+     linenr_T	bw_conv_error_lnum;  /* first line with error or zero */
+     linenr_T	bw_start_lnum;  /* line number at start of buffer */
  # ifdef USE_ICONV
      iconv_t	bw_iconv_fd;	/* descriptor for iconv() or -1 */
  # endif
***************
*** 2924,2929 ****
--- 2925,2931 ----
      linenr_T	    lnum;
      long	    nchars;
      char_u	    *errmsg = NULL;
+     int		    errmsg_allocated = FALSE;
      char_u	    *errnum = NULL;
      char_u	    *buffer;
      char_u	    smallbuf[SMBUFSIZE];
***************
*** 2987,2992 ****
--- 2989,2995 ----
      /* must init bw_conv_buf and bw_iconv_fd before jumping to "fail" */
      write_info.bw_conv_buf = NULL;
      write_info.bw_conv_error = FALSE;
+     write_info.bw_conv_error_lnum = 0;
      write_info.bw_restlen = 0;
  # ifdef USE_ICONV
      write_info.bw_iconv_fd = (iconv_t)-1;
***************
*** 4243,4248 ****
--- 4245,4251 ----
  		nchars += write_info.bw_len;
  	}
      }
+     write_info.bw_start_lnum = start;
  #endif
  
      write_info.bw_len = bufsize;
***************
*** 4278,4283 ****
--- 4281,4289 ----
  	    nchars += bufsize;
  	    s = buffer;
  	    len = 0;
+ #ifdef FEAT_MBYTE
+ 	    write_info.bw_start_lnum = lnum;
+ #endif
  	}
  	/* write failed or last line has no EOL: stop here */
  	if (end == 0
***************
*** 4474,4480 ****
  	{
  #ifdef FEAT_MBYTE
  	    if (write_info.bw_conv_error)
! 		errmsg = (char_u *)_("E513: write error, conversion failed (make 'fenc' empty to override)");
  	    else
  #endif
  		if (got_int)
--- 4480,4496 ----
  	{
  #ifdef FEAT_MBYTE
  	    if (write_info.bw_conv_error)
! 	    {
! 		if (write_info.bw_conv_error_lnum == 0)
! 		    errmsg = (char_u *)_("E513: write error, conversion failed (make 'fenc' empty to override)");
! 		else
! 		{
! 		    errmsg_allocated = TRUE;
! 		    errmsg = alloc(300);
! 		    vim_snprintf((char *)errmsg, 300, _("E513: write error, conversion failed in line %ld (make 'fenc' empty to override)"),
! 					 (long)write_info.bw_conv_error_lnum);
! 		}
! 	    }
  	    else
  #endif
  		if (got_int)
***************
*** 4550,4555 ****
--- 4566,4577 ----
  	{
  	    STRCAT(IObuff, _(" CONVERSION ERROR"));
  	    c = TRUE;
+ 	    if (write_info.bw_conv_error_lnum != 0)
+ 	    {
+ 		int l = STRLEN(IObuff);
+ 		vim_snprintf((char *)IObuff + l, IOSIZE - l, _(" in line %ld;"),
+ 			(long)write_info.bw_conv_error_lnum);
+ 	    }
  	}
  	else if (notconverted)
  	{
***************
*** 4746,4751 ****
--- 4768,4775 ----
  	}
  	STRCAT(IObuff, errmsg);
  	emsg(IObuff);
+ 	if (errmsg_allocated)
+ 	    vim_free(errmsg);
  
  	retval = FAIL;
  	if (end == 0)
***************
*** 5105,5111 ****
  			c = buf[wlen];
  		}
  
! 		ip->bw_conv_error |= ucs2bytes(c, &p, flags);
  	    }
  	    if (flags & FIO_LATIN1)
  		len = (int)(p - buf);
--- 5129,5141 ----
  			c = buf[wlen];
  		}
  
! 		if (ucs2bytes(c, &p, flags) && !ip->bw_conv_error)
! 		{
! 		    ip->bw_conv_error = TRUE;
! 		    ip->bw_conv_error_lnum = ip->bw_start_lnum;
! 		}
! 		if (c == NL)
! 		    ++ip->bw_start_lnum;
  	    }
  	    if (flags & FIO_LATIN1)
  		len = (int)(p - buf);
***************
*** 5386,5391 ****
--- 5416,5422 ----
  #ifdef FEAT_MBYTE
  /*
   * Convert a Unicode character to bytes.
+  * Return TRUE for an error, FALSE when it's OK.
   */
      static int
  ucs2bytes(c, pp, flags)
*** ../vim-7.2.243/src/version.c	2009-07-29 16:13:35.000000000 +0200
--- src/version.c	2009-07-29 18:01:27.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     244,
  /**/

-- 
Support your right to bare arms!  Wear short sleeves!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.245
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.245
Problem:    When 'enc' is "utf-16" and 'fenc' is "utf-8" writing a file does
	    conversion while none should be done. (Yukihiro Nakadaira) When
	    'fenc' is empty the file is written as utf-8 instead of utf-16.
Solution:   Do proper comparison of encodings, taking into account that all
	    Unicode values for 'enc' use utf-8 internally.
Files:	    src/fileio.c


*** ../vim-7.2.244/src/fileio.c	2009-07-29 18:05:57.000000000 +0200
--- src/fileio.c	2009-07-29 17:04:06.000000000 +0200
***************
*** 134,140 ****
  #ifdef FEAT_MBYTE
  static linenr_T readfile_linenr __ARGS((linenr_T linecnt, char_u *p, char_u *endp));
  static int ucs2bytes __ARGS((unsigned c, char_u **pp, int flags));
! static int same_encoding __ARGS((char_u *a, char_u *b));
  static int get_fio_flags __ARGS((char_u *ptr));
  static char_u *check_for_bom __ARGS((char_u *p, long size, int *lenp, int flags));
  static int make_bom __ARGS((char_u *buf, char_u *name));
--- 134,140 ----
  #ifdef FEAT_MBYTE
  static linenr_T readfile_linenr __ARGS((linenr_T linecnt, char_u *p, char_u *endp));
  static int ucs2bytes __ARGS((unsigned c, char_u **pp, int flags));
! static int need_conversion __ARGS((char_u *fenc));
  static int get_fio_flags __ARGS((char_u *ptr));
  static char_u *check_for_bom __ARGS((char_u *p, long size, int *lenp, int flags));
  static int make_bom __ARGS((char_u *buf, char_u *name));
***************
*** 1043,1055 ****
      }
  
      /*
!      * Conversion is required when the encoding of the file is different
!      * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4 (requires
!      * conversion to UTF-8).
       */
      fio_flags = 0;
!     converted = (*fenc != NUL && !same_encoding(p_enc, fenc));
!     if (converted || enc_unicode != 0)
      {
  
  	/* "ucs-bom" means we need to check the first bytes of the file
--- 1043,1054 ----
      }
  
      /*
!      * Conversion may be required when the encoding of the file is different
!      * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.
       */
      fio_flags = 0;
!     converted = need_conversion(fenc);
!     if (converted)
      {
  
  	/* "ucs-bom" means we need to check the first bytes of the file
***************
*** 3969,3978 ****
  	fenc = buf->b_p_fenc;
  
      /*
!      * The file needs to be converted when 'fileencoding' is set and
!      * 'fileencoding' differs from 'encoding'.
       */
!     converted = (*fenc != NUL && !same_encoding(p_enc, fenc));
  
      /*
       * Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or
--- 3968,3976 ----
  	fenc = buf->b_p_fenc;
  
      /*
!      * Check if the file needs to be converted.
       */
!     converted = need_conversion(fenc);
  
      /*
       * Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or
***************
*** 5502,5521 ****
  }
  
  /*
!  * Return TRUE if "a" and "b" are the same 'encoding'.
!  * Ignores difference between "ansi" and "latin1", "ucs-4" and "ucs-4be", etc.
   */
      static int
! same_encoding(a, b)
!     char_u	*a;
!     char_u	*b;
  {
!     int		f;
  
!     if (STRCMP(a, b) == 0)
! 	return TRUE;
!     f = get_fio_flags(a);
!     return (f != 0 && get_fio_flags(b) == f);
  }
  
  /*
--- 5500,5536 ----
  }
  
  /*
!  * Return TRUE if file encoding "fenc" requires conversion from or to
!  * 'encoding'.
   */
      static int
! need_conversion(fenc)
!     char_u	*fenc;
  {
!     int		same_encoding;
!     int		enc_flags;
!     int		fenc_flags;
  
!     if (*fenc == NUL || STRCMP(p_enc, fenc) == 0)
! 	same_encoding = TRUE;
!     else
!     {
! 	/* Ignore difference between "ansi" and "latin1", "ucs-4" and
! 	 * "ucs-4be", etc. */
! 	enc_flags = get_fio_flags(p_enc);
! 	fenc_flags = get_fio_flags(fenc);
! 	same_encoding = (enc_flags != 0 && fenc_flags == enc_flags);
!     }
!     if (same_encoding)
!     {
! 	/* Specified encoding matches with 'encoding'.  This requires
! 	 * conversion when 'encoding' is Unicode but not UTF-8. */
! 	return enc_unicode != 0;
!     }
! 
!     /* Encodings differ.  However, conversion is not needed when 'enc' is any
!      * Unicode encoding and the file is UTF-8. */
!     return !(enc_utf8 && fenc_flags == FIO_UTF8);
  }
  
  /*
*** ../vim-7.2.244/src/version.c	2009-07-29 18:05:57.000000000 +0200
--- src/version.c	2009-07-29 18:20:08.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     245,
  /**/

-- 
An actual excerpt from a classified section of a city newspaper:
"Illiterate?  Write today for free help!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.246
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.246
Problem:    Cscope home page link is wrong.
Solution:   Update the URL. (Sergey Khorev)
Files:	    runtime/doc/if_cscop.txt


*** ../vim-7.2.245/runtime/doc/if_cscop.txt	2009-07-09 21:22:36.000000000 +0200
--- runtime/doc/if_cscop.txt	2009-09-11 11:19:31.000000000 +0200
***************
*** 481,487 ****
  any problems, suggestions, patches, et al., you have for the usage of
  cscope within Vim to him.
  							*cscope-win32*
! For a cscope version for Win32 see: http://iamphet.nm.ru/cscope/index.html
  
  Win32 support was added by Sergey Khorev <sergey.khorev@gmail.com>.  Contact
  him if you have Win32-specific issues.
--- 481,488 ----
  any problems, suggestions, patches, et al., you have for the usage of
  cscope within Vim to him.
  							*cscope-win32*
! For a cscope version for Win32 see:
! 	http://code.google.com/p/cscope-win32/
  
  Win32 support was added by Sergey Khorev <sergey.khorev@gmail.com>.  Contact
  him if you have Win32-specific issues.
*** ../vim-7.2.245/src/version.c	2009-07-29 18:24:59.000000000 +0200
--- src/version.c	2009-09-11 11:29:02.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     246,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
221. Your wife melts your keyboard in the oven.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.247
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.247
Problem:    Mzscheme interface minor problem.
Solution:   Better error message when build fails. (Sergey Khorev)
Files:	    src/if_mzsch.c


*** ../vim-7.2.246/src/if_mzsch.c	2009-07-09 20:06:30.000000000 +0200
--- src/if_mzsch.c	2009-09-11 11:20:39.000000000 +0200
***************
*** 635,642 ****
  #endif /* DYNAMIC_MZSCHEME */
  
  /* need to put it here for dynamic stuff to work */
! #ifdef INCLUDE_MZSCHEME_BASE
  # include "mzscheme_base.c"
  #endif
  
  /*
--- 635,644 ----
  #endif /* DYNAMIC_MZSCHEME */
  
  /* need to put it here for dynamic stuff to work */
! #if defined(INCLUDE_MZSCHEME_BASE)
  # include "mzscheme_base.c"
+ #elif MZSCHEME_VERSION_MAJOR >= 400
+ # error MzScheme 4.x must include mzscheme_base.c, for MinGW32 you need to define MZSCHEME_GENERATE_BASE=yes
  #endif
  
  /*
***************
*** 875,888 ****
  #ifdef INCLUDE_MZSCHEME_BASE
      {
  	/*
! 	 * versions 4.x do not provide Scheme bindings by defaults
  	 * we need to add them explicitly
  	 */
  	Scheme_Object *scheme_base_symbol = NULL;
  	MZ_GC_DECL_REG(1);
  	MZ_GC_VAR_IN_REG(0, scheme_base_symbol);
  	MZ_GC_REG();
! 	/* invoke function from generated and included base.c */
  	declare_modules(environment);
  	scheme_base_symbol = scheme_intern_symbol("scheme/base");
  	MZ_GC_CHECK();
--- 877,890 ----
  #ifdef INCLUDE_MZSCHEME_BASE
      {
  	/*
! 	 * versions 4.x do not provide Scheme bindings by default
  	 * we need to add them explicitly
  	 */
  	Scheme_Object *scheme_base_symbol = NULL;
  	MZ_GC_DECL_REG(1);
  	MZ_GC_VAR_IN_REG(0, scheme_base_symbol);
  	MZ_GC_REG();
! 	/* invoke function from generated and included mzscheme_base.c */
  	declare_modules(environment);
  	scheme_base_symbol = scheme_intern_symbol("scheme/base");
  	MZ_GC_CHECK();
*** ../vim-7.2.246/src/version.c	2009-09-11 11:30:12.000000000 +0200
--- src/version.c	2009-09-11 11:53:59.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     247,
  /**/

-- 
Your fault: core dumped

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.248 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.248 (extra)
Problem:    Mzscheme interface building minor problems.
Solution:   Update Win32 makefiles. (Sergey Khorev)
Files:	    src/Make_cyg.mak, src/Make_ming.mak, src/Make_mvc.mak


*** ../vim-7.2.247/src/Make_cyg.mak	2007-09-30 22:28:48.000000000 +0200
--- src/Make_cyg.mak	2009-09-11 11:23:23.000000000 +0200
***************
*** 212,224 ****
  MZSCHEME_VER = 209_000
  endif
  
  ifeq (yes, $(DYNAMIC_MZSCHEME))
  DEFINES += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
  else
  ifndef MZSCHEME_DLLS
  MZSCHEME_DLLS = $(MZSCHEME)
  endif
! EXTRA_LIBS += -L$(MZSCHEME_DLLS) -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
  endif
  endif
  
--- 212,245 ----
  MZSCHEME_VER = 209_000
  endif
  
+ ifndef MZSCHEME_PRECISE_GC
+ MZSCHEME_PRECISE_GC=no
+ endif
+ 
+ # for version 4.x we need to generate byte-code for Scheme base
+ ifndef MZSCHEME_GENERATE_BASE
+ MZSCHEME_GENERATE_BASE=no
+ endif
+ 
  ifeq (yes, $(DYNAMIC_MZSCHEME))
  DEFINES += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
  else
  ifndef MZSCHEME_DLLS
  MZSCHEME_DLLS = $(MZSCHEME)
  endif
! ifeq (yes,$(MZSCHEME_PRECISE_GC))
! MZSCHEME_LIB=-lmzsch$(MZSCHEME_VER)
! else
! MZSCHEME_LIB = -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
! endif
! EXTRA_LIBS += -L$(MZSCHEME_DLLS) -L$(MZSCHEME_DLLS)/lib $(MZSCHEME_LIB)
! endif
! ifeq (yes,$(MZSCHEME_GENERATE_BASE))
! DEFINES += -DINCLUDE_MZSCHEME_BASE
! MZ_EXTRA_DEP += mzscheme_base.c
! endif
! ifeq (yes,$(MZSCHEME_PRECISE_GC))
! DEFINES += -DMZ_PRECISE_GC
  endif
  endif
  
***************
*** 473,478 ****
--- 494,502 ----
  ifdef PERL
  	-$(DEL) if_perl.c
  endif
+ ifdef MZSCHEME
+ 	-$(DEL) mzscheme_base.c
+ endif
  	-$(DEL) pathdef.c
  	$(MAKE) -C xxd -f Make_cyg.mak clean
  	$(MAKE) -C GvimExt -f Make_ming.mak clean
***************
*** 523,531 ****
--- 547,561 ----
  $(OUTDIR)/netbeans.o:	netbeans.c $(INCL) $(NBDEBUG_DEP)
  	$(CC) -c $(CFLAGS) netbeans.c -o $(OUTDIR)/netbeans.o
  
+ $(OUTDIR)/if_mzsch.o:	if_mzsch.c $(INCL) if_mzsch.h $(MZ_EXTRA_DEP)
+ 	$(CC) -c $(CFLAGS) if_mzsch.c -o $(OUTDIR)/if_mzsch.o
+ 
  $(OUTDIR)/vimrc.o:	vim.rc version.h gui_w32_rc.h
  	$(RC) $(RCFLAGS) vim.rc -o $(OUTDIR)/vimrc.o
  
+ mzscheme_base.c:
+ 	$(MZSCHEME)/mzc --c-mods mzscheme_base.c ++lib scheme/base
+ 
  pathdef.c: $(INCL)
  ifneq (sh.exe, $(SHELL))
  	@echo creating pathdef.c
*** ../vim-7.2.247/src/Make_ming.mak	2009-05-26 22:58:43.000000000 +0200
--- src/Make_ming.mak	2009-09-11 11:23:28.000000000 +0200
***************
*** 135,141 ****
  ifndef MZSCHEME_DLLS
  MZSCHEME_DLLS=$(MZSCHEME)
  endif
! MZSCHEME_LIBDIR=-L$(MZSCHEME_DLLS)
  endif
  
  endif
--- 135,141 ----
  ifndef MZSCHEME_DLLS
  MZSCHEME_DLLS=$(MZSCHEME)
  endif
! MZSCHEME_LIBDIR=-L$(MZSCHEME_DLLS) -L$(MZSCHEME_DLLS)\lib
  endif
  
  endif
***************
*** 563,568 ****
--- 563,571 ----
  ifdef PERL
  	-$(DEL) if_perl.c
  endif
+ ifdef MZSCHEME
+ 	-$(DEL) mzscheme_base.c
+ endif
  	$(MAKE) -C GvimExt -f Make_ming.mak clean
  	$(MAKE) -C xxd -f Make_cyg.mak clean
  
*** ../vim-7.2.247/src/Make_mvc.mak	2009-06-16 16:45:14.000000000 +0200
--- src/Make_mvc.mak	2009-09-11 11:23:28.000000000 +0200
***************
*** 865,870 ****
--- 865,871 ----
  	- if exist dimm_i.c del dimm_i.c
  	- if exist dimm.tlb del dimm.tlb
  	- if exist dosinst.exe del dosinst.exe
+ 	- if exist mzscheme_base.c del mzscheme_base.c
  	cd xxd
  	$(MAKE) /NOLOGO -f Make_mvc.mak clean
  	cd ..
*** ../vim-7.2.247/src/version.c	2009-09-11 12:20:47.000000000 +0200
--- src/version.c	2009-09-11 12:48:26.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     248,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
222. You send more than 20 personal e-mails a day.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.249
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.249
Problem:    The script to check .po files can't handle '%' in plural forms.
Solution:   Remove "Plural-Forms:" from the checked string.
Files:	    src/po/check.vim


*** ../vim-7.2.248/src/po/check.vim	2008-06-09 14:45:38.000000000 +0200
--- src/po/check.vim	2009-09-11 12:37:56.000000000 +0200
***************
*** 23,28 ****
--- 23,31 ----
    " remove '%', not used for formatting.
    let idline = substitute(idline, "'%'", '', 'g')
  
+   " remove '%' used for plural forms.
+   let idline = substitute(idline, '\\nPlural-Forms: .\+;\\n', '', '')
+ 
    " remove everything but % items.
    return substitute(idline, '[^%]*\(%[-+ #''.0-9*]*l\=[dsuxXpoc%]\)\=', '\1', 'g')
  endfunc
*** ../vim-7.2.248/src/version.c	2009-09-11 12:48:56.000000000 +0200
--- src/version.c	2009-09-11 12:59:18.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     249,
  /**/

-- 
If evolution theories are correct, humans will soon grow a third
hand for operating the mouse.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.250 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.250 (extra)
Problem:    Possible buffer overflow.
Solution:   Compute the remaining space. (Dominique Pelle)
Files:	    src/GvimExt/gvimext.cpp


*** ../vim-7.2.249/src/GvimExt/gvimext.cpp	2008-07-24 20:51:11.000000000 +0200
--- src/GvimExt/gvimext.cpp	2009-09-11 13:26:27.000000000 +0200
***************
*** 635,641 ****
  	}
  	// Now concatenate
  	strncpy(temp, _("Edit with existing Vim - "), BUFSIZE - 1);
! 	strncat(temp, title, BUFSIZE - 1);
  	InsertMenu(hMenu,
  		indexMenu++,
  		MF_STRING|MF_BYPOSITION,
--- 635,643 ----
  	}
  	// Now concatenate
  	strncpy(temp, _("Edit with existing Vim - "), BUFSIZE - 1);
! 	temp[BUFSIZE - 1] = '\0';
! 	strncat(temp, title, BUFSIZE - 1 - strlen(temp));
! 	temp[BUFSIZE - 1] = '\0';
  	InsertMenu(hMenu,
  		indexMenu++,
  		MF_STRING|MF_BYPOSITION,
*** ../vim-7.2.249/src/version.c	2009-09-11 12:59:57.000000000 +0200
--- src/version.c	2009-09-11 13:23:45.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     250,
  /**/


-- 
hundred-and-one symptoms of being an internet addict:
223. You set up a web-cam as your home's security system.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.251
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.251 (after 7.2.044)
Problem:    Compiler adds invalid memory bounds check.
Solution:   Remove _FORTIFY_SOURCE=2 from CFLAGS. (Dominique Pelle)
Files:	    src/auto/configure, src/configure.in


*** ../vim-7.2.250/src/auto/configure	2009-07-22 11:16:54.000000000 +0200
--- src/auto/configure	2009-08-07 14:49:52.000000000 +0200
***************
*** 17135,17141 ****
        { $as_echo "$as_me:$LINENO: checking whether we need -D_FORTIFY_SOURCE=1" >&5
  $as_echo_n "checking whether we need -D_FORTIFY_SOURCE=1... " >&6; }
    if test "$gccmajor" -gt "3"; then
!     CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=1"
      { $as_echo "$as_me:$LINENO: result: yes" >&5
  $as_echo "yes" >&6; }
    else
--- 17135,17141 ----
        { $as_echo "$as_me:$LINENO: checking whether we need -D_FORTIFY_SOURCE=1" >&5
  $as_echo_n "checking whether we need -D_FORTIFY_SOURCE=1... " >&6; }
    if test "$gccmajor" -gt "3"; then
!     CFLAGS=`echo "$CFLAGS -D_FORTIFY_SOURCE=1" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=2//g' -e 's/-D_FORTIFY_SOURCE=2//g'`
      { $as_echo "$as_me:$LINENO: result: yes" >&5
  $as_echo "yes" >&6; }
    else
*** ../vim-7.2.250/src/configure.in	2009-07-22 11:16:54.000000000 +0200
--- src/configure.in	2009-08-07 14:49:47.000000000 +0200
***************
*** 3233,3239 ****
    dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
    AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
    if test "$gccmajor" -gt "3"; then
!     CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=1"
      AC_MSG_RESULT(yes)
    else
      AC_MSG_RESULT(no)
--- 3233,3239 ----
    dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
    AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
    if test "$gccmajor" -gt "3"; then
!     CFLAGS=`echo "$CFLAGS -D_FORTIFY_SOURCE=1" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=2//g' -e 's/-D_FORTIFY_SOURCE=2//g'`
      AC_MSG_RESULT(yes)
    else
      AC_MSG_RESULT(no)
*** ../vim-7.2.250/src/version.c	2009-09-11 13:26:38.000000000 +0200
--- src/version.c	2009-09-11 13:43:46.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     251,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
225. You sign up for free subscriptions for all the computer magazines

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.252
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.252
Problem:    When using a multi-byte 'enc' the 'iskeyword' option cannot
	    contain characters above 128.
Solution:   Use mb_ptr2char_adv().
Files:	    src/charset.c


*** ../vim-7.2.251/src/charset.c	2009-05-14 22:19:19.000000000 +0200
--- src/charset.c	2009-09-09 21:11:46.000000000 +0200
***************
*** 174,179 ****
--- 174,184 ----
  	    if (VIM_ISDIGIT(*p))
  		c = getdigits(&p);
  	    else
+ #ifdef FEAT_MBYTE
+ 		 if (has_mbyte)
+ 		c = mb_ptr2char_adv(&p);
+ 	    else
+ #endif
  		c = *p++;
  	    c2 = -1;
  	    if (*p == '-' && p[1] != NUL)
*** ../vim-7.2.251/src/version.c	2009-09-11 13:44:33.000000000 +0200
--- src/version.c	2009-09-11 14:01:48.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     252,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
226. You sit down at the computer right after dinner and your spouse
     says "See you in the morning."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.253
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.253
Problem:    Netbeans interface: getLength always uses current buffer.
Solution:   Use ml_get_buf() instead of ml_get(). (Xavier de Gaye)
Files:	    src/netbeans.c


*** ../vim-7.2.252/src/netbeans.c	2009-06-24 16:49:50.000000000 +0200
--- src/netbeans.c	2009-09-11 13:40:14.000000000 +0200
***************
*** 1499,1505 ****
  		    return FAIL;
  		}
  		first = *pos;
! 		nbdebug(("    FIRST POS: line %d, col %d\n", first.lnum, first.col));
  		pos = off2pos(buf->bufp, off+count-1);
  		if (!pos)
  		{
--- 1499,1506 ----
  		    return FAIL;
  		}
  		first = *pos;
! 		nbdebug(("    FIRST POS: line %d, col %d\n",
! 						      first.lnum, first.col));
  		pos = off2pos(buf->bufp, off+count-1);
  		if (!pos)
  		{
***************
*** 1510,1516 ****
  		    return FAIL;
  		}
  		last = *pos;
! 		nbdebug(("    LAST POS: line %d, col %d\n", last.lnum, last.col));
  		del_from_lnum = first.lnum;
  		del_to_lnum = last.lnum;
  		doupdate = 1;
--- 1511,1518 ----
  		    return FAIL;
  		}
  		last = *pos;
! 		nbdebug(("    LAST POS: line %d, col %d\n",
! 							last.lnum, last.col));
  		del_from_lnum = first.lnum;
  		del_to_lnum = last.lnum;
  		doupdate = 1;
***************
*** 1521,1527 ****
  		next = off2pos(buf->bufp, off + count);
  
  		/* Remove part of the first line. */
! 		if (first.col != 0 || (next != NULL && first.lnum == next->lnum))
  		{
  		    if (first.lnum != last.lnum
  			    || (next != NULL && first.lnum != next->lnum))
--- 1523,1530 ----
  		next = off2pos(buf->bufp, off + count);
  
  		/* Remove part of the first line. */
! 		if (first.col != 0
! 				|| (next != NULL && first.lnum == next->lnum))
  		{
  		    if (first.lnum != last.lnum
  			    || (next != NULL && first.lnum != next->lnum))
***************
*** 1584,1590 ****
  			int id = buf_findsign_id(buf->bufp, (linenr_T)i);
  			if (id > 0)
  			{
! 			    nbdebug(("    Deleting sign %d on line %d\n", id, i));
  			    buf_delsign(buf->bufp, id);
  			}
  			else
--- 1587,1594 ----
  			int id = buf_findsign_id(buf->bufp, (linenr_T)i);
  			if (id > 0)
  			{
! 			    nbdebug(("    Deleting sign %d on line %d\n",
! 								      id, i));
  			    buf_delsign(buf->bufp, id);
  			}
  			else
***************
*** 1593,1599 ****
  			}
  		    }
  
! 		    nbdebug(("    Deleting lines %d through %d\n", del_from_lnum, del_to_lnum));
  		    curwin->w_cursor.lnum = del_from_lnum;
  		    curwin->w_cursor.col = 0;
  		    del_lines(del_to_lnum - del_from_lnum + 1, FALSE);
--- 1597,1604 ----
  			}
  		    }
  
! 		    nbdebug(("    Deleting lines %d through %d\n",
! 						 del_from_lnum, del_to_lnum));
  		    curwin->w_cursor.lnum = del_from_lnum;
  		    curwin->w_cursor.col = 0;
  		    del_lines(del_to_lnum - del_from_lnum + 1, FALSE);
***************
*** 3514,3520 ****
  	    eol_size = 1;
  	for (lnum = 1; lnum <= bufp->b_ml.ml_line_count; ++lnum)
  	{
! 	    char_count += (long)STRLEN(ml_get(lnum)) + eol_size;
  	    /* Check for a CTRL-C every 100000 characters */
  	    if (char_count > last_check)
  	    {
--- 3519,3526 ----
  	    eol_size = 1;
  	for (lnum = 1; lnum <= bufp->b_ml.ml_line_count; ++lnum)
  	{
! 	    char_count += (long)STRLEN(ml_get_buf(bufp, lnum, FALSE))
! 								   + eol_size;
  	    /* Check for a CTRL-C every 100000 characters */
  	    if (char_count > last_check)
  	    {
*** ../vim-7.2.252/src/version.c	2009-09-11 14:02:25.000000000 +0200
--- src/version.c	2009-09-11 14:18:45.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     253,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
227. You sleep next to your monitor.  Or on top of it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.254
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.254
Problem:    Compiler warning for assigning size_t to int.
Solution:   Use size_t for the variable. (George Reilly)
Files:	    src/fileio.c


*** ../vim-7.2.253/src/fileio.c	2009-07-29 18:24:59.000000000 +0200
--- src/fileio.c	2009-09-11 13:46:19.000000000 +0200
***************
*** 4568,4574 ****
  	    c = TRUE;
  	    if (write_info.bw_conv_error_lnum != 0)
  	    {
! 		int l = STRLEN(IObuff);
  		vim_snprintf((char *)IObuff + l, IOSIZE - l, _(" in line %ld;"),
  			(long)write_info.bw_conv_error_lnum);
  	    }
--- 4568,4574 ----
  	    c = TRUE;
  	    if (write_info.bw_conv_error_lnum != 0)
  	    {
! 		size_t l = STRLEN(IObuff);
  		vim_snprintf((char *)IObuff + l, IOSIZE - l, _(" in line %ld;"),
  			(long)write_info.bw_conv_error_lnum);
  	    }
*** ../vim-7.2.253/src/version.c	2009-09-11 14:19:41.000000000 +0200
--- src/version.c	2009-09-11 15:03:42.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     254,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
230. You spend your Friday nights typing away at your keyboard

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.255
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.255 (after 7.2.242)
Problem:    Setting 'rightleft', 'linebreak' and 'wrap' may cause cursor to be
	    in wrong place.
Solution:   Recompute the cursor column for these options.
Files:	    src/option.c


*** ../vim-7.2.254/src/option.c	2009-07-29 15:41:32.000000000 +0200
--- src/option.c	2009-09-11 13:59:55.000000000 +0200
***************
*** 7430,7435 ****
--- 7430,7437 ----
      {
  	if (curwin->w_p_wrap)
  	    curwin->w_leftcol = 0;
+ 	if (curwin->w_curswant != MAXCOL)
+ 	    curwin->w_set_curswant = TRUE;
      }
  
  #ifdef FEAT_WINDOWS
***************
*** 7664,7669 ****
--- 7666,7687 ----
      }
  #endif
  
+ #ifdef FEAT_LINEBREAK
+     if ((int *)varp == &curwin->w_p_lbr)
+     {
+ 	if (curwin->w_curswant != MAXCOL)
+ 	    curwin->w_set_curswant = TRUE;
+     }
+ #endif
+ 
+ #ifdef FEAT_RIGHTLEFT
+     if ((int *)varp == &curwin->w_p_rl)
+     {
+ 	if (curwin->w_curswant != MAXCOL)
+ 	    curwin->w_set_curswant = TRUE;
+     }
+ #endif
+ 
      /*
       * End of handling side effects for bool options.
       */
*** ../vim-7.2.254/src/version.c	2009-09-11 15:04:13.000000000 +0200
--- src/version.c	2009-09-11 15:19:40.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     255,
  /**/

-- 
A computer without Windows is like a fish without a bicycle.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.256
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.256
Problem:    When 'guifont' was not set GTK font dialog doesn't have a default.
	    (Andreas Metzler)
Solution:   Set default to DEFAULT_FONT. (James Vega)
Files:	    src/gui_gtk_x11.c


*** ../vim-7.2.255/src/gui_gtk_x11.c	2009-07-01 18:04:30.000000000 +0200
--- src/gui_gtk_x11.c	2009-09-11 14:21:32.000000000 +0200
***************
*** 4729,4734 ****
--- 4729,4737 ----
      if (oldval != NULL && *oldval != NUL)
  	gtk_font_selection_dialog_set_font_name(
  		GTK_FONT_SELECTION_DIALOG(gui.fontdlg), (char *)oldval);
+     else
+ 	gtk_font_selection_dialog_set_font_name(
+ 		GTK_FONT_SELECTION_DIALOG(gui.fontdlg), DEFAULT_FONT);
  
      if (gui.fontname)
      {
***************
*** 4816,4821 ****
--- 4819,4827 ----
  	if (oldname != oldval)
  	    vim_free(oldname);
      }
+     else
+ 	gtk_font_selection_dialog_set_font_name(
+ 		GTK_FONT_SELECTION_DIALOG(dialog), DEFAULT_FONT);
  
      response = gtk_dialog_run(GTK_DIALOG(dialog));
  
*** ../vim-7.2.255/src/version.c	2009-09-11 15:20:22.000000000 +0200
--- src/version.c	2009-09-11 15:45:36.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     256,
  /**/

-- 
Get a life?  What is the URL where it can be downloaded?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.257
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.257
Problem:    With GTK 2.17 lots of assertion error messages.
Solution:   Remove check for static gravity. (Sebastian Droege)
Files:	    src/gui_gtk_f.c


*** ../vim-7.2.256/src/gui_gtk_f.c	2009-05-17 23:25:16.000000000 +0200
--- src/gui_gtk_f.c	2009-09-11 15:15:41.000000000 +0200
***************
*** 860,870 ****
  gtk_form_set_static_gravity(GdkWindow *window, gboolean use_static)
  {
  #ifdef HAVE_GTK2
!     gboolean static_gravity_supported;
! 
!     static_gravity_supported = gdk_window_set_static_gravities(window,
! 							       use_static);
!     g_return_if_fail(static_gravity_supported);
  #else
      XSetWindowAttributes xattributes;
  
--- 860,868 ----
  gtk_form_set_static_gravity(GdkWindow *window, gboolean use_static)
  {
  #ifdef HAVE_GTK2
!     /* We don't check if static gravity is actually supported, because it
!      * results in an annoying assertion error message. */
!     gdk_window_set_static_gravities(window, use_static);
  #else
      XSetWindowAttributes xattributes;
  
*** ../vim-7.2.256/src/version.c	2009-09-11 15:46:20.000000000 +0200
--- src/version.c	2009-09-11 16:16:52.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     257,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
231. You sprinkle Carpet Fresh on the rugs and put your vacuum cleaner
     in the front doorway permanently so it always looks like you are
     actually attempting to do something about that mess that has amassed
     since you discovered the Internet.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.258
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.258
Problem:    v:beval_col and b:beval_text are wrong in UTF-8 text. (Tony
	    Mechelynck)
Solution:   Use byte number instead of character number for the column.
Files:	    src/ui.c


*** ../vim-7.2.257/src/ui.c	2009-07-01 18:04:30.000000000 +0200
--- src/ui.c	2009-09-11 16:11:50.000000000 +0200
***************
*** 3055,3072 ****
      int		vcol;
  {
      /* try to advance to the specified column */
-     int		col = 0;
      int		count = 0;
      char_u	*ptr;
  
!     ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);
      while (count <= vcol && *ptr != NUL)
      {
- 	++col;
  	count += win_lbr_chartabsize(wp, ptr, count, NULL);
  	mb_ptr_adv(ptr);
      }
!     return col;
  }
  #endif
  
--- 3055,3071 ----
      int		vcol;
  {
      /* try to advance to the specified column */
      int		count = 0;
      char_u	*ptr;
+     char_u	*start;
  
!     start = ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);
      while (count <= vcol && *ptr != NUL)
      {
  	count += win_lbr_chartabsize(wp, ptr, count, NULL);
  	mb_ptr_adv(ptr);
      }
!     return (int)(ptr - start);
  }
  #endif
  
*** ../vim-7.2.257/src/version.c	2009-09-11 16:17:36.000000000 +0200
--- src/version.c	2009-09-11 16:45:48.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     258,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
232. You start conversations with, "Have you gotten an ISDN line?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.259
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.259
Problem:    exists() doesn't work properly for an empty aucmd group.
Solution:   Change how au_exists() handles a missing pattern.  Also add a
	    test for this. (Bob Hiestand)
Files:	    src/fileio.c, src/testdir/Makefile, src/testdir/test67.in,
	    src/testdir/test67.ok


*** ../vim-7.2.258/src/fileio.c	2009-09-11 15:04:13.000000000 +0200
--- src/fileio.c	2009-09-11 16:37:08.000000000 +0200
***************
*** 9498,9512 ****
      ap = first_autopat[(int)event];
      if (ap == NULL)
  	goto theend;
-     if (pattern == NULL)
-     {
- 	retval = TRUE;
- 	goto theend;
-     }
  
      /* if pattern is "<buffer>", special handling is needed which uses curbuf */
      /* for pattern "<buffer=N>, fnamecmp() will work fine */
!     if (STRICMP(pattern, "<buffer>") == 0)
  	buflocal_buf = curbuf;
  
      /* Check if there is an autocommand with the given pattern. */
--- 9498,9507 ----
      ap = first_autopat[(int)event];
      if (ap == NULL)
  	goto theend;
  
      /* if pattern is "<buffer>", special handling is needed which uses curbuf */
      /* for pattern "<buffer=N>, fnamecmp() will work fine */
!     if (pattern != NULL && STRICMP(pattern, "<buffer>") == 0)
  	buflocal_buf = curbuf;
  
      /* Check if there is an autocommand with the given pattern. */
***************
*** 9515,9523 ****
  	/* For buffer-local autocommands, fnamecmp() works fine. */
  	if (ap->pat != NULL && ap->cmds != NULL
  	    && (group == AUGROUP_ALL || ap->group == group)
! 	    && (buflocal_buf == NULL
! 		 ? fnamecmp(ap->pat, pattern) == 0
! 		 : ap->buflocal_nr == buflocal_buf->b_fnum))
  	{
  	    retval = TRUE;
  	    break;
--- 9510,9519 ----
  	/* For buffer-local autocommands, fnamecmp() works fine. */
  	if (ap->pat != NULL && ap->cmds != NULL
  	    && (group == AUGROUP_ALL || ap->group == group)
! 	    && (pattern == NULL
! 		|| (buflocal_buf == NULL
! 		    ? fnamecmp(ap->pat, pattern) == 0
! 		    : ap->buflocal_nr == buflocal_buf->b_fnum)))
  	{
  	    retval = TRUE;
  	    break;
*** ../vim-7.2.258/src/testdir/Makefile	2009-06-24 18:07:55.000000000 +0200
--- src/testdir/Makefile	2009-09-11 16:31:33.000000000 +0200
***************
*** 22,28 ****
  		test48.out test49.out test51.out test52.out test53.out \
  		test54.out test55.out test56.out test57.out test58.out \
  		test59.out test60.out test61.out test62.out test63.out \
! 		test64.out test65.out test66.out
  
  SCRIPTS_GUI = test16.out
  
--- 22,28 ----
  		test48.out test49.out test51.out test52.out test53.out \
  		test54.out test55.out test56.out test57.out test58.out \
  		test59.out test60.out test61.out test62.out test63.out \
! 		test64.out test65.out test66.out test67.out
  
  SCRIPTS_GUI = test16.out
  
*** ../vim-7.2.258/src/testdir/test67.in	2009-09-11 17:23:47.000000000 +0200
--- src/testdir/test67.in	2009-09-11 16:43:11.000000000 +0200
***************
*** 0 ****
--- 1,33 ----
+ Test that groups and patterns are tested correctly when calling exists() for
+ autocommands.
+ 
+ STARTTEST
+ :so small.vim
+ :let results=[]
+ :augroup auexists
+ :augroup END
+ :call add(results, "##BufEnter: " . exists("##BufEnter"))
+ :call add(results, "#BufEnter: " . exists("#BufEnter"))
+ :au BufEnter * let g:entered=1
+ :call add(results, "#BufEnter: " . exists("#BufEnter"))
+ :call add(results, "#auexists#BufEnter: " . exists("#auexists#BufEnter"))
+ :augroup auexists
+ :au BufEnter * let g:entered=1
+ :augroup END
+ :call add(results, "#auexists#BufEnter: " . exists("#auexists#BufEnter"))
+ :call add(results, "#BufEnter#*.test: " . exists("#BufEnter#*.test"))
+ :au BufEnter *.test let g:entered=1
+ :call add(results, "#BufEnter#*.test: " . exists("#BufEnter#*.test"))
+ :edit testfile.test
+ :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
+ :au BufEnter <buffer> let g:entered=1
+ :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
+ :edit testfile2.test
+ :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
+ :e test.out
+ :call append(0, results)
+ :$d
+ :w
+ :qa!
+ ENDTEST
+ 
*** ../vim-7.2.258/src/testdir/test67.ok	2009-09-11 17:23:47.000000000 +0200
--- src/testdir/test67.ok	2009-09-11 16:43:15.000000000 +0200
***************
*** 0 ****
--- 1,10 ----
+ ##BufEnter: 1
+ #BufEnter: 0
+ #BufEnter: 1
+ #auexists#BufEnter: 0
+ #auexists#BufEnter: 1
+ #BufEnter#*.test: 0
+ #BufEnter#*.test: 1
+ #BufEnter#<buffer>: 0
+ #BufEnter#<buffer>: 1
+ #BufEnter#<buffer>: 0
*** ../vim-7.2.258/src/version.c	2009-09-11 16:48:06.000000000 +0200
--- src/version.c	2009-09-11 17:23:14.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     259,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
234. You started college as a chemistry major, and walk out four years
     later as an Internet provider.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.260 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.260 (extra part of 7.2.259)
Problem:    exists() doesn't work properly for empty aucmd group.
Solution:   Change how au_exists() handles a missing pattern.  Also add a
	    test for this. (Bob Hiestand)
Files:	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_ming.mak, src/testdir/Make_os2.mak,
	    src/testdir/Make_vms.mms


*** ../vim-7.2.259/src/testdir/Make_amiga.mak	2009-03-11 16:36:04.000000000 +0100
--- src/testdir/Make_amiga.mak	2009-09-11 16:29:54.000000000 +0200
***************
*** 26,32 ****
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
  		test61.out test62.out test63.out test64.out test65.out \
! 		test66.out
  
  .SUFFIXES: .in .out
  
--- 26,32 ----
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
  		test61.out test62.out test63.out test64.out test65.out \
! 		test66.out test67.out
  
  .SUFFIXES: .in .out
  
***************
*** 112,114 ****
--- 112,115 ----
  test64.out: test64.in
  test65.out: test65.in
  test66.out: test66.in
+ test67.out: test67.in
*** ../vim-7.2.259/src/testdir/Make_dos.mak	2009-03-11 16:36:04.000000000 +0100
--- src/testdir/Make_dos.mak	2009-09-11 16:30:17.000000000 +0200
***************
*** 26,32 ****
  		test15.out test17.out test18.out test21.out test26.out \
  		test30.out test31.out test32.out test33.out test34.out \
  		test37.out test38.out test39.out test40.out test41.out \
! 		test42.out test52.out test65.out test66.out
  
  SCRIPTS32 =	test50.out
  
--- 26,32 ----
  		test15.out test17.out test18.out test21.out test26.out \
  		test30.out test31.out test32.out test33.out test34.out \
  		test37.out test38.out test39.out test40.out test41.out \
! 		test42.out test52.out test65.out test66.out test67.out
  
  SCRIPTS32 =	test50.out
  
*** ../vim-7.2.259/src/testdir/Make_ming.mak	2009-03-11 16:36:04.000000000 +0100
--- src/testdir/Make_ming.mak	2009-09-11 16:30:37.000000000 +0200
***************
*** 45,51 ****
  		test15.out test17.out test18.out test21.out test26.out \
  		test30.out test31.out test32.out test33.out test34.out \
  		test37.out test38.out test39.out test40.out test41.out \
! 		test42.out test52.out test65.out test66.out
  
  SCRIPTS32 =	test50.out
  
--- 45,51 ----
  		test15.out test17.out test18.out test21.out test26.out \
  		test30.out test31.out test32.out test33.out test34.out \
  		test37.out test38.out test39.out test40.out test41.out \
! 		test42.out test52.out test65.out test66.out test67.out
  
  SCRIPTS32 =	test50.out
  
*** ../vim-7.2.259/src/testdir/Make_os2.mak	2009-03-11 16:36:04.000000000 +0100
--- src/testdir/Make_os2.mak	2009-09-11 16:30:52.000000000 +0200
***************
*** 26,32 ****
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
  		test61.out test62.out test63.out test64.out test65.out \
! 		test66.out
  
  .SUFFIXES: .in .out
  
--- 26,32 ----
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
  		test61.out test62.out test63.out test64.out test65.out \
! 		test66.out test67.out
  
  .SUFFIXES: .in .out
  
*** ../vim-7.2.259/src/testdir/Make_vms.mms	2009-03-11 16:36:04.000000000 +0100
--- src/testdir/Make_vms.mms	2009-09-11 16:31:06.000000000 +0200
***************
*** 4,10 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2009 Mar 05
  #
  # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
--- 4,10 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2009 Sep 11
  #
  # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
***************
*** 69,75 ****
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test60.out \
  	 test61.out test62.out test63.out test64.out test65.out \
! 	 test66.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
--- 69,75 ----
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test60.out \
  	 test61.out test62.out test63.out test64.out test65.out \
! 	 test66.out test67.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
*** ../vim-7.2.259/src/version.c	2009-09-11 17:24:01.000000000 +0200
--- src/version.c	2009-09-18 14:57:05.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     260,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
251. You've never seen your closest friends who usually live WAY too far away.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.261
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.261
Problem:    When deleting lines with a specific folding configuration E38 may
	    appear. (Shahaf)
Solution:   When adjusting nested folds for deleted lines take into account
	    that they don't start at the top of the enclosing fold.
Files:	    src/fold.c


*** ../vim-7.2.260/src/fold.c	2009-01-06 15:01:58.000000000 +0100
--- src/fold.c	2009-09-18 14:43:23.000000000 +0200
***************
*** 1607,1617 ****
  	    }
  	    else
  	    {
- 		/* 2, 3, or 5: need to correct nested folds too */
- 		foldMarkAdjustRecurse(&fp->fd_nested, line1 - fp->fd_top,
- 				  line2 - fp->fd_top, amount, amount_after);
  		if (fp->fd_top < top)
  		{
  		    if (last <= line2)
  		    {
  			/* 2. fold contains line1, line2 is below fold */
--- 1607,1617 ----
  	    }
  	    else
  	    {
  		if (fp->fd_top < top)
  		{
+ 		    /* 2 or 3: need to correct nested folds too */
+ 		    foldMarkAdjustRecurse(&fp->fd_nested, line1 - fp->fd_top,
+ 				  line2 - fp->fd_top, amount, amount_after);
  		    if (last <= line2)
  		    {
  			/* 2. fold contains line1, line2 is below fold */
***************
*** 1628,1634 ****
  		}
  		else
  		{
! 		    /* 5. fold is below line1 and contains line2 */
  		    if (amount == MAXLNUM)
  		    {
  			fp->fd_len -= line2 - fp->fd_top + 1;
--- 1628,1638 ----
  		}
  		else
  		{
! 		    /* 5. fold is below line1 and contains line2; need to
! 		     * correct nested folds too */
! 		    foldMarkAdjustRecurse(&fp->fd_nested, line1 - fp->fd_top,
! 				  line2 - fp->fd_top, amount,
! 				  amount_after + (fp->fd_top - top));
  		    if (amount == MAXLNUM)
  		    {
  			fp->fd_len -= line2 - fp->fd_top + 1;
*** ../vim-7.2.260/src/version.c	2009-09-18 14:58:26.000000000 +0200
--- src/version.c	2009-09-18 15:14:40.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     261,
  /**/

-- 
Emacs is a nice OS - but it lacks a good text editor.
That's why I am using Vim.  --Anonymous

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.262
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.262
Problem:    When using custom completion for a user command the pattern string
	    goes beyond the cursor position. (Hari Krishna Dara)
Solution:   Truncate the string at the cursor position.
Files:	    src/ex_getln.c, src/structs.h


*** ../vim-7.2.261/src/ex_getln.c	2009-06-24 17:04:40.000000000 +0200
--- src/ex_getln.c	2009-09-18 16:58:16.000000000 +0200
***************
*** 3266,3272 ****
      int		i, j;
      char_u	*p1;
      char_u	*p2;
-     int		oldlen;
      int		difflen;
      int		v;
  
--- 3266,3271 ----
***************
*** 3291,3297 ****
      out_flush();
  
      i = (int)(xp->xp_pattern - ccline.cmdbuff);
!     oldlen = ccline.cmdpos - i;
  
      if (type == WILD_NEXT || type == WILD_PREV)
      {
--- 3290,3296 ----
      out_flush();
  
      i = (int)(xp->xp_pattern - ccline.cmdbuff);
!     xp->xp_pattern_len = ccline.cmdpos - i;
  
      if (type == WILD_NEXT || type == WILD_PREV)
      {
***************
*** 3305,3322 ****
  	/*
  	 * Translate string into pattern and expand it.
  	 */
! 	if ((p1 = addstar(&ccline.cmdbuff[i], oldlen, xp->xp_context)) == NULL)
  	    p2 = NULL;
  	else
  	{
! 	    p2 = ExpandOne(xp, p1, vim_strnsave(&ccline.cmdbuff[i], oldlen),
  		    WILD_HOME_REPLACE|WILD_ADD_SLASH|WILD_SILENT|WILD_ESCAPE
  							      |options, type);
  	    vim_free(p1);
  	    /* longest match: make sure it is not shorter (happens with :help */
  	    if (p2 != NULL && type == WILD_LONGEST)
  	    {
! 		for (j = 0; j < oldlen; ++j)
  		     if (ccline.cmdbuff[i + j] == '*'
  			     || ccline.cmdbuff[i + j] == '?')
  			 break;
--- 3304,3323 ----
  	/*
  	 * Translate string into pattern and expand it.
  	 */
! 	if ((p1 = addstar(xp->xp_pattern, xp->xp_pattern_len,
! 						     xp->xp_context)) == NULL)
  	    p2 = NULL;
  	else
  	{
! 	    p2 = ExpandOne(xp, p1,
! 			 vim_strnsave(&ccline.cmdbuff[i], xp->xp_pattern_len),
  		    WILD_HOME_REPLACE|WILD_ADD_SLASH|WILD_SILENT|WILD_ESCAPE
  							      |options, type);
  	    vim_free(p1);
  	    /* longest match: make sure it is not shorter (happens with :help */
  	    if (p2 != NULL && type == WILD_LONGEST)
  	    {
! 		for (j = 0; j < xp->xp_pattern_len; ++j)
  		     if (ccline.cmdbuff[i + j] == '*'
  			     || ccline.cmdbuff[i + j] == '?')
  			 break;
***************
*** 3331,3337 ****
  
      if (p2 != NULL && !got_int)
      {
! 	difflen = (int)STRLEN(p2) - oldlen;
  	if (ccline.cmdlen + difflen > ccline.cmdbufflen - 4)
  	{
  	    v = realloc_cmdbuff(ccline.cmdlen + difflen);
--- 3332,3338 ----
  
      if (p2 != NULL && !got_int)
      {
! 	difflen = (int)STRLEN(p2) - xp->xp_pattern_len;
  	if (ccline.cmdlen + difflen > ccline.cmdbufflen - 4)
  	{
  	    v = realloc_cmdbuff(ccline.cmdlen + difflen);
***************
*** 3620,3625 ****
--- 3621,3627 ----
      expand_T	*xp;
  {
      xp->xp_pattern = NULL;
+     xp->xp_pattern_len = 0;
      xp->xp_backslash = XP_BS_NONE;
  #ifndef BACKSLASH_IN_FILENAME
      xp->xp_shell = FALSE;
***************
*** 4311,4318 ****
      }
  
      /* add star to file name, or convert to regexp if not exp. files. */
!     file_str = addstar(xp->xp_pattern,
! 			   (int)(str + col - xp->xp_pattern), xp->xp_context);
      if (file_str == NULL)
  	return EXPAND_UNSUCCESSFUL;
  
--- 4313,4320 ----
      }
  
      /* add star to file name, or convert to regexp if not exp. files. */
!     xp->xp_pattern_len = (int)(str + col - xp->xp_pattern);
!     file_str = addstar(xp->xp_pattern, xp->xp_pattern_len, xp->xp_context);
      if (file_str == NULL)
  	return EXPAND_UNSUCCESSFUL;
  
***************
*** 4781,4787 ****
  	sprintf((char *)num, "%d", ccline.cmdpos);
  	args[1] = ccline.cmdbuff;
      }
!     args[0] = xp->xp_pattern;
      args[2] = num;
  
      /* Save the cmdline, we don't know what the function may do. */
--- 4783,4789 ----
  	sprintf((char *)num, "%d", ccline.cmdpos);
  	args[1] = ccline.cmdbuff;
      }
!     args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
      args[2] = num;
  
      /* Save the cmdline, we don't know what the function may do. */
***************
*** 4797,4802 ****
--- 4799,4805 ----
      if (ccline.cmdbuff != NULL)
  	ccline.cmdbuff[ccline.cmdlen] = keep;
  
+     vim_free(args[0]);
      return ret;
  }
  
*** ../vim-7.2.261/src/structs.h	2009-07-29 12:09:49.000000000 +0200
--- src/structs.h	2009-09-18 15:33:15.000000000 +0200
***************
*** 432,437 ****
--- 432,438 ----
  {
      int		xp_context;		/* type of expansion */
      char_u	*xp_pattern;		/* start of item to expand */
+     int		xp_pattern_len;		/* bytes in xp_pattern before cursor */
  #if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
      char_u	*xp_arg;		/* completion function */
      int		xp_scriptID;		/* SID for completion function */
*** ../vim-7.2.261/src/version.c	2009-09-18 15:16:37.000000000 +0200
--- src/version.c	2009-09-18 17:23:20.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     262,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
252. You vote for foreign officials.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.263
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.263
Problem:    GTK2: when using the -geom argument with an offset from the right
	    edge and the size is smaller than the default, the Vim window is
	    not positioned properly.
Solution:   Use another function to set the size. (Vitaly Minko)
Files:	    src/gui_gtk_x11.c


*** ../vim-7.2.262/src/gui_gtk_x11.c	2009-09-11 15:46:20.000000000 +0200
--- src/gui_gtk_x11.c	2009-09-23 15:43:52.000000000 +0200
***************
*** 4066,4071 ****
--- 4066,4073 ----
  {
      guicolor_T fg_pixel = INVALCOLOR;
      guicolor_T bg_pixel = INVALCOLOR;
+     guint		pixel_width;
+     guint		pixel_height;
  
  #ifdef HAVE_GTK2
      /*
***************
*** 4106,4113 ****
  	unsigned int	w, h;
  	int		x = 0;
  	int		y = 0;
- 	guint		pixel_width;
- 	guint		pixel_height;
  
  	mask = XParseGeometry((char *)gui.geom, &x, &y, &w, &h);
  
--- 4108,4113 ----
***************
*** 4160,4168 ****
  	}
      }
  
!     gtk_form_set_size(GTK_FORM(gui.formwin),
! 	    (guint)(gui_get_base_width() + Columns * gui.char_width),
! 	    (guint)(gui_get_base_height() + Rows * gui.char_height));
      update_window_manager_hints(0, 0);
  
      if (foreground_argument != NULL)
--- 4160,4175 ----
  	}
      }
  
!     pixel_width = (guint)(gui_get_base_width() + Columns * gui.char_width);
!     pixel_height = (guint)(gui_get_base_height() + Rows * gui.char_height);
! #ifdef HAVE_GTK2
!     /* For GTK2 changing the size of the form widget doesn't cause window
!      * resizing. */
!     if (gtk_socket_id == 0) 
! 	gtk_window_resize(GTK_WINDOW(gui.mainwin), pixel_width, pixel_height);
! #else
!     gtk_form_set_size(GTK_FORM(gui.formwin), pixel_width, pixel_height);
! #endif
      update_window_manager_hints(0, 0);
  
      if (foreground_argument != NULL)
*** ../vim-7.2.262/src/version.c	2009-09-18 17:24:54.000000000 +0200
--- src/version.c	2009-09-23 17:34:08.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     263,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
267. You get an extra phone line so you can get phone calls.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.264
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.264
Problem:    GTK2: When the Vim window is maximized setting 'columns' or
	    'lines' doesn't work.
Solution:   Unmaximize the window before setting the size. (Vitaly Minko)
Files:	    src/gui.c, src/gui_gtk_x11.c, src/proto/gui_gtk_x11.pro


*** ../vim-7.2.263/src/gui.c	2009-07-29 11:10:31.000000000 +0200
--- src/gui.c	2009-09-23 16:28:09.000000000 +0200
***************
*** 1386,1391 ****
--- 1386,1395 ----
      int		min_height;
      int		screen_w;
      int		screen_h;
+ #ifdef HAVE_GTK2
+     int		un_maximize = mustset;
+     int         did_adjust = 0;
+ #endif
  
      if (!gui.shell_created)
  	return;
***************
*** 1425,1446 ****
  	    if (Columns < MIN_COLUMNS)
  		Columns = MIN_COLUMNS;
  	    width = Columns * gui.char_width + base_width;
  	}
  	if ((direction & RESIZE_VERT) && height > screen_h)
  	{
  	    Rows = (screen_h - base_height) / gui.char_height;
  	    check_shellsize();
  	    height = Rows * gui.char_height + base_height;
  	}
      }
      gui.num_cols = Columns;
      gui.num_rows = Rows;
  
      min_width = base_width + MIN_COLUMNS * gui.char_width;
      min_height = base_height + MIN_LINES * gui.char_height;
! # ifdef FEAT_WINDOWS
      min_height += tabline_height() * gui.char_height;
! # endif
  
      gui_mch_set_shellsize(width, height, min_width, min_height,
  					  base_width, base_height, direction);
--- 1429,1475 ----
  	    if (Columns < MIN_COLUMNS)
  		Columns = MIN_COLUMNS;
  	    width = Columns * gui.char_width + base_width;
+ #ifdef HAVE_GTK2
+ 	    ++did_adjust;
+ #endif
  	}
  	if ((direction & RESIZE_VERT) && height > screen_h)
  	{
  	    Rows = (screen_h - base_height) / gui.char_height;
  	    check_shellsize();
  	    height = Rows * gui.char_height + base_height;
+ #ifdef HAVE_GTK2
+ 	    ++did_adjust;
+ #endif
  	}
+ #ifdef HAVE_GTK2
+ 	if (did_adjust == 2 || (width + gui.char_width >= screen_w
+ 				     && height + gui.char_height >= screen_h))
+ 	    /* don't unmaximize if at maximum size */
+ 	    un_maximize = FALSE;
+ #endif
      }
      gui.num_cols = Columns;
      gui.num_rows = Rows;
  
      min_width = base_width + MIN_COLUMNS * gui.char_width;
      min_height = base_height + MIN_LINES * gui.char_height;
! #ifdef FEAT_WINDOWS
      min_height += tabline_height() * gui.char_height;
! #endif
! 
! #ifdef HAVE_GTK2
!     if (un_maximize)
!     {
! 	/* If the window size is smaller than the screen unmaximize the
! 	 * window, otherwise resizing won't work. */
! 	gui_mch_get_screen_dimensions(&screen_w, &screen_h);
! 	if ((width + gui.char_width < screen_w
! 				   || height + gui.char_height * 2 < screen_h)
! 		&& gui_mch_maximized())
! 	    gui_mch_unmaximize();
!     }
! #endif
  
      gui_mch_set_shellsize(width, height, min_width, min_height,
  					  base_width, base_height, direction);
*** ../vim-7.2.263/src/gui_gtk_x11.c	2009-09-23 17:35:17.000000000 +0200
--- src/gui_gtk_x11.c	2009-09-23 15:43:52.000000000 +0200
***************
*** 4376,4381 ****
--- 4376,4404 ----
  #endif
  #endif /* HAVE_GTK2 */
  
+ #if defined(HAVE_GTK2) || defined(PROTO)
+ /*
+  * Return TRUE if the main window is maximized.
+  */
+     int
+ gui_mch_maximized()
+ {
+     return (gui.mainwin != NULL && gui.mainwin->window != NULL
+ 	    && (gdk_window_get_state(gui.mainwin->window)
+ 					       & GDK_WINDOW_STATE_MAXIMIZED));
+ }
+ 
+ /*
+  * Unmaximize the main window
+  */
+     void
+ gui_mch_unmaximize()
+ {
+     if (gui.mainwin != NULL)
+ 	gtk_window_unmaximize(GTK_WINDOW(gui.mainwin));
+ }
+ #endif
+ 
  /*
   * Set the windows size.
   */
*** ../vim-7.2.263/src/proto/gui_gtk_x11.pro	2007-05-05 19:18:54.000000000 +0200
--- src/proto/gui_gtk_x11.pro	2009-09-23 15:43:45.000000000 +0200
***************
*** 16,21 ****
--- 16,23 ----
  void gui_mch_exit __ARGS((int rc));
  int gui_mch_get_winpos __ARGS((int *x, int *y));
  void gui_mch_set_winpos __ARGS((int x, int y));
+ int gui_mch_maximized __ARGS((void));
+ void gui_mch_unmaximize __ARGS((void));
  void gui_mch_set_shellsize __ARGS((int width, int height, int min_width, int min_height, int base_width, int base_height, int direction));
  void gui_mch_get_screen_dimensions __ARGS((int *screen_w, int *screen_h));
  void gui_mch_settitle __ARGS((char_u *title, char_u *icon));
*** ../vim-7.2.263/src/version.c	2009-09-23 17:35:17.000000000 +0200
--- src/version.c	2009-09-23 18:12:21.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     264,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
268. You get up in the morning and go online before getting your coffee.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.265
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.265
Problem:    When using ":silent broken" inside try/catch silency may persist.
	    (dr-dr xp)
Solution:   Set msg_silent when there is an error and it's bigger than the
	    saved value.
Files:	    src/ex_docmd.c


*** ../vim-7.2.264/src/ex_docmd.c	2009-07-09 20:13:59.000000000 +0200
--- src/ex_docmd.c	2009-09-30 11:40:53.000000000 +0200
***************
*** 2695,2701 ****
      {
  	/* messages could be enabled for a serious error, need to check if the
  	 * counters don't become negative */
! 	if (!did_emsg)
  	    msg_silent = save_msg_silent;
  	emsg_silent -= did_esilent;
  	if (emsg_silent < 0)
--- 2695,2701 ----
      {
  	/* messages could be enabled for a serious error, need to check if the
  	 * counters don't become negative */
! 	if (!did_emsg || msg_silent > save_msg_silent)
  	    msg_silent = save_msg_silent;
  	emsg_silent -= did_esilent;
  	if (emsg_silent < 0)
*** ../vim-7.2.264/src/version.c	2009-09-23 18:14:13.000000000 +0200
--- src/version.c	2009-09-30 13:22:47.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     265,
  /**/

-- 
FIRST HEAD:  Oh! quick! get the sword out I want to cut his head off.
THIRD HEAD:  Oh, cut your own head off.
SECOND HEAD: Yes - do us all a favour.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.266
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.266
Problem:    When an expression abbreviation is triggered, the typed character
	    is unknown.
Solution:   Make the typed character available in v:char.
Files:	    runtime/doc/map.txt, src/eval.c, src/getchar.c, src/ops.c,
	    src/proto/eval.pro


*** ../vim-7.2.265/runtime/doc/map.txt	2008-08-09 19:36:49.000000000 +0200
--- runtime/doc/map.txt	2009-09-23 19:39:19.000000000 +0200
***************
*** 224,229 ****
--- 224,233 ----
  The result of the InsertDot() function will be inserted.  It could check the
  text before the cursor and start omni completion when some condition is met.
  
+ For abbreviations |v:char| is set to the character that was typed to trigger
+ the abbreviation.  You can use this to decide how to expand the {lhs}.  You
+ can't change v:char and you should not insert it.
+ 
  Be very careful about side effects!  The expression is evaluated while
  obtaining characters, you may very well make the command dysfunctional.
  For this reason the following is blocked:
*** ../vim-7.2.265/src/eval.c	2009-06-03 14:25:47.000000000 +0200
--- src/eval.c	2009-09-23 19:36:32.000000000 +0200
***************
*** 18101,18106 ****
--- 18101,18131 ----
  }
  
  /*
+  * Set v:char to character "c".
+  */
+     void
+ set_vim_var_char(c)
+     int c;
+ {
+ #ifdef FEAT_MBYTE
+     char_u	buf[MB_MAXBYTES];
+ #else
+     char_u	buf[2];
+ #endif
+ 
+ #ifdef FEAT_MBYTE
+     if (has_mbyte)
+ 	buf[(*mb_char2bytes)(c, buf)] = NUL;
+     else
+ #endif
+     {
+ 	buf[0] = c;
+ 	buf[1] = NUL;
+     }
+     set_vim_var_string(VV_CHAR, buf, -1);
+ }
+ 
+ /*
   * Set v:count to "count" and v:count1 to "count1".
   * When "set_prevcount" is TRUE first set v:prevcount from v:count.
   */
*** ../vim-7.2.265/src/getchar.c	2009-07-14 13:44:43.000000000 +0200
--- src/getchar.c	2009-09-23 19:35:54.000000000 +0200
***************
*** 129,135 ****
  static void	validate_maphash __ARGS((void));
  static void	showmap __ARGS((mapblock_T *mp, int local));
  #ifdef FEAT_EVAL
! static char_u	*eval_map_expr __ARGS((char_u *str));
  #endif
  
  /*
--- 129,135 ----
  static void	validate_maphash __ARGS((void));
  static void	showmap __ARGS((mapblock_T *mp, int local));
  #ifdef FEAT_EVAL
! static char_u	*eval_map_expr __ARGS((char_u *str, int c));
  #endif
  
  /*
***************
*** 2446,2452 ****
  			    if (tabuf.typebuf_valid)
  			    {
  				vgetc_busy = 0;
! 				s = eval_map_expr(mp->m_str);
  				vgetc_busy = save_vgetc_busy;
  			    }
  			    else
--- 2446,2452 ----
  			    if (tabuf.typebuf_valid)
  			    {
  				vgetc_busy = 0;
! 				s = eval_map_expr(mp->m_str, NUL);
  				vgetc_busy = save_vgetc_busy;
  			    }
  			    else
***************
*** 4367,4375 ****
  	     * abbreviation, but is not inserted into the input stream.
  	     */
  	    j = 0;
- 					/* special key code, split up */
  	    if (c != Ctrl_RSB)
  	    {
  		if (IS_SPECIAL(c) || c == K_SPECIAL)
  		{
  		    tb[j++] = K_SPECIAL;
--- 4367,4375 ----
  	     * abbreviation, but is not inserted into the input stream.
  	     */
  	    j = 0;
  	    if (c != Ctrl_RSB)
  	    {
+ 					/* special key code, split up */
  		if (IS_SPECIAL(c) || c == K_SPECIAL)
  		{
  		    tb[j++] = K_SPECIAL;
***************
*** 4398,4404 ****
  	    }
  #ifdef FEAT_EVAL
  	    if (mp->m_expr)
! 		s = eval_map_expr(mp->m_str);
  	    else
  #endif
  		s = mp->m_str;
--- 4398,4404 ----
  	    }
  #ifdef FEAT_EVAL
  	    if (mp->m_expr)
! 		s = eval_map_expr(mp->m_str, c);
  	    else
  #endif
  		s = mp->m_str;
***************
*** 4434,4441 ****
   * special characters.
   */
      static char_u *
! eval_map_expr(str)
      char_u	*str;
  {
      char_u	*res;
      char_u	*p;
--- 4434,4442 ----
   * special characters.
   */
      static char_u *
! eval_map_expr(str, c)
      char_u	*str;
+     int		c;	    /* NUL or typed character for abbreviation */
  {
      char_u	*res;
      char_u	*p;
***************
*** 4452,4457 ****
--- 4453,4459 ----
  #ifdef FEAT_EX_EXTRA
      ++ex_normal_lock;
  #endif
+     set_vim_var_char(c);  /* set v:char to the typed character */
      save_cursor = curwin->w_cursor;
      p = eval_to_string(str, NULL, FALSE);
      --textlock;
*** ../vim-7.2.265/src/ops.c	2009-07-01 18:04:30.000000000 +0200
--- src/ops.c	2009-09-23 19:11:40.000000000 +0200
***************
*** 4473,4483 ****
      int		use_sandbox = was_set_insecurely((char_u *)"formatexpr",
  								   OPT_LOCAL);
      int		r;
- #ifdef FEAT_MBYTE
-     char_u	buf[MB_MAXBYTES];
- #else
-     char_u	buf[2];
- #endif
  
      /*
       * Set v:lnum to the first line number and v:count to the number of lines.
--- 4473,4478 ----
***************
*** 4485,4501 ****
       */
      set_vim_var_nr(VV_LNUM, lnum);
      set_vim_var_nr(VV_COUNT, count);
! 
! #ifdef FEAT_MBYTE
!     if (has_mbyte)
! 	buf[(*mb_char2bytes)(c, buf)] = NUL;
!     else
! #endif
!     {
! 	buf[0] = c;
! 	buf[1] = NUL;
!     }
!     set_vim_var_string(VV_CHAR, buf, -1);
  
      /*
       * Evaluate the function.
--- 4480,4486 ----
       */
      set_vim_var_nr(VV_LNUM, lnum);
      set_vim_var_nr(VV_COUNT, count);
!     set_vim_var_char(c);
  
      /*
       * Evaluate the function.
*** ../vim-7.2.265/src/proto/eval.pro	2008-11-20 16:11:03.000000000 +0100
--- src/proto/eval.pro	2009-09-23 19:36:30.000000000 +0200
***************
*** 61,66 ****
--- 61,67 ----
  long get_vim_var_nr __ARGS((int idx));
  char_u *get_vim_var_str __ARGS((int idx));
  list_T *get_vim_var_list __ARGS((int idx));
+ void set_vim_var_char __ARGS((int c));
  void set_vcount __ARGS((long count, long count1, int set_prevcount));
  void set_vim_var_string __ARGS((int idx, char_u *val, int len));
  void set_vim_var_list __ARGS((int idx, list_T *val));
*** ../vim-7.2.265/src/version.c	2009-09-30 13:23:57.000000000 +0200
--- src/version.c	2009-09-30 15:11:29.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     266,
  /**/

-- 
Life would be so much easier if we could just look at the source code.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.267
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.267
Problem:    Crash for narrow window and double-width character.
Solution:   Check for zero width.  (Taro Muraoka)
Files:	    src/charset.c


*** ../vim-7.2.266/src/charset.c	2009-09-11 14:02:25.000000000 +0200
--- src/charset.c	2009-10-07 16:17:27.000000000 +0200
***************
*** 1218,1223 ****
--- 1218,1225 ----
      if ((int)vcol == width1 - 1)
  	return TRUE;
      width2 = width1 + win_col_off2(wp);
+     if (width2 <= 0)
+ 	return FALSE;
      return ((vcol - width1) % width2 == width2 - 1);
  }
  #endif /* FEAT_MBYTE */
*** ../vim-7.2.266/src/version.c	2009-09-30 15:15:33.000000000 +0200
--- src/version.c	2009-10-07 16:19:05.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     267,
  /**/

-- 
You got to work at a mill?  Lucky!  I got sent back to work in the
acid-mines for my daily crust of stale bread... which not even the
birds would eat.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.268
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.268
Problem:    Crash when using Python to set cursor beyond end of line.
	    (winterTTr)
Solution:   Check the column to be valid.
Files:	    src/if_python.c


*** ../vim-7.2.267/src/if_python.c	2009-07-09 20:06:30.000000000 +0200
--- src/if_python.c	2009-10-10 14:49:10.000000000 +0200
***************
*** 2058,2063 ****
--- 2058,2064 ----
      {
  	long lnum;
  	long col;
+ 	long len;
  
  	if (!PyArg_Parse(val, "(ll)", &lnum, &col))
  	    return -1;
***************
*** 2072,2081 ****
  	if (VimErrorCheck())
  	    return -1;
  
! 	/* NO CHECK ON COLUMN - SEEMS NOT TO MATTER */
  
  	this->win->w_cursor.lnum = lnum;
  	this->win->w_cursor.col = col;
  	update_screen(VALID);
  
  	return 0;
--- 2073,2088 ----
  	if (VimErrorCheck())
  	    return -1;
  
! 	/* When column is out of range silently correct it. */
! 	len = STRLEN(ml_get_buf(this->win->w_buffer, lnum, FALSE));
! 	if (col > len)
! 	    col = len;
  
  	this->win->w_cursor.lnum = lnum;
  	this->win->w_cursor.col = col;
+ #ifdef FEAT_VIRTUALEDIT
+ 	this->win->w_cursor.coladd = 0;
+ #endif
  	update_screen(VALID);
  
  	return 0;
*** ../vim-7.2.267/src/version.c	2009-10-07 16:19:52.000000000 +0200
--- src/version.c	2009-11-03 11:42:08.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     268,
  /**/

-- 
VOICE OVER: As the horrendous Black Beast lunged forward, escape for Arthur
            and his knights seemed hopeless,  when, suddenly ... the animator
            suffered a fatal heart attack.
ANIMATOR:   Aaaaagh!
VOICE OVER: The cartoon peril was no more ... The Quest for Holy Grail could
            continue.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.269
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.269
Problem:    Many people struggle to find out why Vim startup is slow.
Solution:   Add the --startuptime command line flag.
Files:	    runtime/doc/starting.txt, src/globals.h, src/feature.h,
	    src/main.c, src/macros.h


*** ../vim-7.2.268/runtime/doc/starting.txt	2008-11-09 13:43:25.000000000 +0100
--- runtime/doc/starting.txt	2009-10-25 11:57:51.000000000 +0100
***************
*** 144,149 ****
--- 144,156 ----
  			-u NORC			no		    yes
  			--noplugin		yes		    no
  
+ --startuptime={fname}					*--startuptime*
+ 		During startup write timing messages to the file {fname}.
+ 		This can be used to find out where time is spent while loading
+ 		your .vimrc and plugins.
+ 		When {fname} already exists new messages are appended.
+ 		{only when compiled with this feature}
+ 
  							*--literal*
  --literal	Take file names literally, don't expand wildcards.  Not needed
  		for Unix, because Vim always takes file names literally (the
***************
*** 471,476 ****
--- 487,493 ----
  		window title and copy/paste using the X clipboard.  This
  		avoids a long startup time when running Vim in a terminal
  		emulator and the connection to the X server is slow.
+ 		See |--startuptime| to find out if affects you.
  		Only makes a difference on Unix or VMS, when compiled with the
  		|+X11| feature.  Otherwise it's ignored.
  		To disable the connection only for specific terminals, see the
*** ../vim-7.2.268/src/globals.h	2009-07-29 12:09:49.000000000 +0200
--- src/globals.h	2009-10-10 15:14:31.000000000 +0200
***************
*** 1567,1572 ****
--- 1567,1576 ----
  /* For undo we need to know the lowest time possible. */
  EXTERN time_t starttime;
  
+ #ifdef STARTUPTIME
+ EXTERN FILE *time_fd INIT(= NULL);  /* where to write startup timing */
+ #endif
+ 
  /*
   * Some compilers warn for not using a return value, but in some situations we
   * can't do anything useful with the value.  Assign to this variable to avoid
*** ../vim-7.2.268/src/feature.h	2008-11-09 13:43:25.000000000 +0100
--- src/feature.h	2009-10-10 16:16:19.000000000 +0200
***************
*** 844,853 ****
  /* #define DEBUG */
  
  /*
!  * STARTUPTIME		Time the startup process.  Writes a "vimstartup" file
!  *			with timestamps.
   */
! /* #define STARTUPTIME "vimstartup" */
  
  /*
   * MEM_PROFILE		Debugging of memory allocation and freeing.
--- 844,857 ----
  /* #define DEBUG */
  
  /*
!  * STARTUPTIME		Time the startup process.  Writes a file with
!  *			timestamps.
   */
! #if defined(FEAT_NORMAL) \
! 	&& ((defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)) \
! 		|| defined(WIN3264))
! # define STARTUPTIME 1
! #endif
  
  /*
   * MEM_PROFILE		Debugging of memory allocation and freeing.
*** ../vim-7.2.268/src/main.c	2009-05-26 22:58:43.000000000 +0200
--- src/main.c	2009-10-10 16:18:32.000000000 +0200
***************
*** 130,139 ****
  #endif
  
  
- #ifdef STARTUPTIME
- static FILE *time_fd = NULL;
- #endif
- 
  /*
   * Different types of error messages.
   */
--- 130,135 ----
***************
*** 173,178 ****
--- 169,177 ----
      char_u	*fname = NULL;		/* file name from command line */
      mparm_T	params;			/* various parameters passed between
  					 * main() and other functions. */
+ #ifdef STARTUPTIME
+     int		i;
+ #endif
  
      /*
       * Do any system-specific initialisations.  These can NOT use IObuff or
***************
*** 203,210 ****
  #endif
  
  #ifdef STARTUPTIME
!     time_fd = mch_fopen(STARTUPTIME, "a");
!     TIME_MSG("--- VIM STARTING ---");
  #endif
      starttime = time(NULL);
  
--- 202,216 ----
  #endif
  
  #ifdef STARTUPTIME
!     for (i = 1; i < argc; ++i)
!     {
! 	if (STRNICMP(argv[i], "--startuptime=", 14) == 0)
! 	{
! 	    time_fd = mch_fopen(argv[i] + 14, "a");
! 	    TIME_MSG("--- VIM STARTING ---");
! 	    break;
! 	}
!     }
  #endif
      starttime = time(NULL);
  
***************
*** 1150,1155 ****
--- 1156,1173 ----
  	    cursor_on();
  
  	    do_redraw = FALSE;
+ 
+ #ifdef STARTUPTIME
+ 	    /* Now that we have drawn the first screen all the startup stuff
+ 	     * has been done, close any file for startup messages. */
+ 	    if (time_fd != NULL)
+ 	    {
+ 		TIME_MSG("first screen update");
+ 		TIME_MSG("--- VIM STARTED ---");
+ 		fclose(time_fd);
+ 		time_fd = NULL;
+ 	    }
+ #endif
  	}
  #ifdef FEAT_GUI
  	if (need_mouse_correct)
***************
*** 1743,1748 ****
--- 1761,1770 ----
  		    /* already processed, skip */
  		}
  #endif
+ 		else if (STRNICMP(argv[0] + argv_idx, "startuptime", 11) == 0)
+ 		{
+ 		    /* already processed, skip */
+ 		}
  		else
  		{
  		    if (argv[0][argv_idx])
***************
*** 3211,3216 ****
--- 3233,3252 ----
  
  static struct timeval	prev_timeval;
  
+ # ifdef WIN3264
+ /*
+  * Windows doesn't have gettimeofday(), although it does have struct timeval.
+  */
+     static int
+ gettimeofday(struct timeval *tv, char *dummy)
+ {
+     long t = clock();
+     tv->tv_sec = t / CLOCKS_PER_SEC;
+     tv->tv_usec = (t - tv->tv_sec * CLOCKS_PER_SEC) * 1000000 / CLOCKS_PER_SEC;
+     return 0;
+ }
+ # endif
+ 
  /*
   * Save the previous time before doing something that could nest.
   * set "*tv_rel" to the time elapsed so far.
***************
*** 3299,3318 ****
      }
  }
  
- # ifdef WIN3264
- /*
-  * Windows doesn't have gettimeofday(), although it does have struct timeval.
-  */
-     int
- gettimeofday(struct timeval *tv, char *dummy)
- {
-     long t = clock();
-     tv->tv_sec = t / CLOCKS_PER_SEC;
-     tv->tv_usec = (t - tv->tv_sec * CLOCKS_PER_SEC) * 1000000 / CLOCKS_PER_SEC;
-     return 0;
- }
- # endif
- 
  #endif
  
  #if defined(FEAT_CLIENTSERVER) || defined(PROTO)
--- 3335,3340 ----
*** ../vim-7.2.268/src/macros.h	2009-05-17 13:30:58.000000000 +0200
--- src/macros.h	2009-10-10 15:19:07.000000000 +0200
***************
*** 243,249 ****
  #endif
  
  #ifdef STARTUPTIME
! # define TIME_MSG(s) time_msg(s, NULL)
  #else
  # define TIME_MSG(s)
  #endif
--- 243,249 ----
  #endif
  
  #ifdef STARTUPTIME
! # define TIME_MSG(s) { if (time_fd != NULL) time_msg(s, NULL); }
  #else
  # define TIME_MSG(s)
  #endif
*** ../vim-7.2.268/src/version.c	2009-11-03 11:43:05.000000000 +0100
--- src/version.c	2009-11-03 12:06:31.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     269,
  /**/

-- 
BEDEVERE: Look!  It's the old man from scene 24 - what's he Doing here?
ARTHUR:   He is the keeper of the Bridge.  He asks each traveler five
          questions ...
GALAHAD:  Three questions.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.270
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.270
Problem:    Using ":@c" when the c register contains a CR causes the rest to
	    be executed later. (Dexter Douglas)
Solution:   Don't check for typeahead to start with ':', keep executing
	    commands until all added typeahead has been used.
Files:	    src/ex_docmd.c


*** ../vim-7.2.269/src/ex_docmd.c	2009-09-30 13:23:57.000000000 +0200
--- src/ex_docmd.c	2009-10-28 12:06:54.000000000 +0100
***************
*** 8358,8363 ****
--- 8358,8364 ----
      exarg_T	*eap;
  {
      int		c;
+     int		prev_len = typebuf.tb_len;
  
      curwin->w_cursor.lnum = eap->line2;
  
***************
*** 8383,8393 ****
  
  	/*
  	 * Execute from the typeahead buffer.
! 	 * Originally this didn't check for the typeahead buffer to be empty,
! 	 * thus could read more Ex commands from stdin.  It's not clear why,
! 	 * it is certainly unexpected.
  	 */
! 	while ((!stuff_empty() || typebuf.tb_len > 0) && vpeekc() == ':')
  	    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);
  
  	exec_from_reg = save_efr;
--- 8384,8393 ----
  
  	/*
  	 * Execute from the typeahead buffer.
! 	 * Continue until the stuff buffer is empty and all added characters
! 	 * have been consumed.
  	 */
! 	while (!stuff_empty() || typebuf.tb_len > prev_len)
  	    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);
  
  	exec_from_reg = save_efr;
*** ../vim-7.2.269/src/version.c	2009-11-03 12:10:39.000000000 +0100
--- src/version.c	2009-11-03 12:32:47.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     270,
  /**/

-- 
To the optimist, the glass is half full.
To the pessimist, the glass is half empty.
To the engineer, the glass is twice as big as it needs to be.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.271
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.271
Problem:    Using freed memory in Motif GUI version when making a choice.
Solution:   Free memory only after using it. (Dominique Pelle)
Files:	    src/gui_xmdlg.c


*** ../vim-7.2.270/src/gui_xmdlg.c	2009-05-21 23:25:38.000000000 +0200
--- src/gui_xmdlg.c	2009-10-28 21:56:15.000000000 +0100
***************
*** 10,16 ****
  /*
   * (C) 2001,2005 by Marcin Dalecki <martin@dalecki.de>
   *
!  * Implementation of dialogue functions for the Motif GUI variant.
   *
   * Note about Lesstif: Apparently lesstif doesn't get the widget layout right,
   * when using a dynamic scrollbar policy.
--- 10,16 ----
  /*
   * (C) 2001,2005 by Marcin Dalecki <martin@dalecki.de>
   *
!  * Implementation of dialog functions for the Motif GUI variant.
   *
   * Note about Lesstif: Apparently lesstif doesn't get the widget layout right,
   * when using a dynamic scrollbar policy.
***************
*** 633,648 ****
  	data->sel[which] = XtNewString(sel);
      else
      {
- 	XtFree(data->sel[which]);
  	if (!strcmp(data->sel[which], sel))
  	{
  	    /* unselecting current selection */
  	    data->sel[which] = NULL;
  	    if (w)
  		XmListDeselectItem(w, call_data->item);
  	}
  	else
  	    data->sel[which] = XtNewString(sel);
      }
      XtFree(sel);
  
--- 633,651 ----
  	data->sel[which] = XtNewString(sel);
      else
      {
  	if (!strcmp(data->sel[which], sel))
  	{
  	    /* unselecting current selection */
+ 	    XtFree(data->sel[which]);
  	    data->sel[which] = NULL;
  	    if (w)
  		XmListDeselectItem(w, call_data->item);
  	}
  	else
+ 	{
+ 	    XtFree(data->sel[which]);
  	    data->sel[which] = XtNewString(sel);
+ 	}
      }
      XtFree(sel);
  
*** ../vim-7.2.270/src/version.c	2009-11-03 12:38:50.000000000 +0100
--- src/version.c	2009-11-03 12:48:26.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     271,
  /**/

-- 
ROBIN:  (warily) And if you get a question wrong?
ARTHUR: You are cast into the Gorge of Eternal Peril.
ROBIN:  Oh ... wacho!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.272
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.272
Problem:    "_.svz" is not recognized as a swap file. (David M. Besonen)
Solution:   Accept .s[uvw][a-z] as a swap file name extension.
Files:	    src/memline.c


*** ../vim-7.2.271/src/memline.c	2009-04-22 15:56:27.000000000 +0200
--- src/memline.c	2009-10-29 20:55:08.000000000 +0100
***************
*** 864,884 ****
      recoverymode = TRUE;
      called_from_main = (curbuf->b_ml.ml_mfp == NULL);
      attr = hl_attr(HLF_E);
! /*
!  * If the file name ends in ".sw?" we use it directly.
!  * Otherwise a search is done to find the swap file(s).
!  */
      fname = curbuf->b_fname;
      if (fname == NULL)		    /* When there is no file name */
  	fname = (char_u *)"";
      len = (int)STRLEN(fname);
      if (len >= 4 &&
  #if defined(VMS) || defined(RISCOS)
! 	    STRNICMP(fname + len - 4, "_sw" , 3)
  #else
! 	    STRNICMP(fname + len - 4, ".sw" , 3)
  #endif
! 		== 0)
      {
  	directly = TRUE;
  	fname = vim_strsave(fname); /* make a copy for mf_open() */
--- 864,887 ----
      recoverymode = TRUE;
      called_from_main = (curbuf->b_ml.ml_mfp == NULL);
      attr = hl_attr(HLF_E);
! 
!     /*
!      * If the file name ends in ".s[uvw][a-z]" we assume this is the swap file.
!      * Otherwise a search is done to find the swap file(s).
!      */
      fname = curbuf->b_fname;
      if (fname == NULL)		    /* When there is no file name */
  	fname = (char_u *)"";
      len = (int)STRLEN(fname);
      if (len >= 4 &&
  #if defined(VMS) || defined(RISCOS)
! 	    STRNICMP(fname + len - 4, "_s" , 2)
  #else
! 	    STRNICMP(fname + len - 4, ".s" , 2)
  #endif
! 		== 0
! 		&& vim_strchr((char_u *)"UVWuvw", fname[len - 2]) != NULL
! 		&& ASCII_ISALPHA(fname[len - 1]))
      {
  	directly = TRUE;
  	fname = vim_strsave(fname); /* make a copy for mf_open() */
*** ../vim-7.2.271/src/version.c	2009-11-03 12:53:44.000000000 +0100
--- src/version.c	2009-11-03 13:02:51.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     272,
  /**/

-- 
Sorry, no fortune today.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.273
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.273
Problem:    Crash with redir to unknown array. (Christian Brabandt)
Solution:   Don't assign the redir result when there was an error.
Files:	    src/eval.c


*** ../vim-7.2.272/src/eval.c	2009-09-30 15:15:33.000000000 +0200
--- src/eval.c	2009-11-03 12:05:07.000000000 +0100
***************
*** 988,1000 ****
      int		err;
      typval_T	tv;
  
!     /* Make sure a valid variable name is specified */
      if (!eval_isnamec1(*name))
      {
  	EMSG(_(e_invarg));
  	return FAIL;
      }
  
      redir_varname = vim_strsave(name);
      if (redir_varname == NULL)
  	return FAIL;
--- 988,1001 ----
      int		err;
      typval_T	tv;
  
!     /* Catch a bad name early. */
      if (!eval_isnamec1(*name))
      {
  	EMSG(_(e_invarg));
  	return FAIL;
      }
  
+     /* Make a copy of the name, it is used in redir_lval until redir ends. */
      redir_varname = vim_strsave(name);
      if (redir_varname == NULL)
  	return FAIL;
***************
*** 1019,1024 ****
--- 1020,1026 ----
  	    EMSG(_(e_trailing));
  	else
  	    EMSG(_(e_invarg));
+ 	redir_endp = NULL;  /* don't store a value, only cleanup */
  	var_redir_stop();
  	return FAIL;
      }
***************
*** 1037,1042 ****
--- 1039,1045 ----
      did_emsg |= save_emsg;
      if (err)
      {
+ 	redir_endp = NULL;  /* don't store a value, only cleanup */
  	var_redir_stop();
  	return FAIL;
      }
***************
*** 1085,1090 ****
--- 1088,1094 ----
  
  /*
   * Stop redirecting command output to a variable.
+  * Frees the allocated memory.
   */
      void
  var_redir_stop()
***************
*** 1093,1106 ****
  
      if (redir_lval != NULL)
      {
! 	/* Append the trailing NUL. */
! 	ga_append(&redir_ga, NUL);
  
! 	/* Assign the text to the variable. */
! 	tv.v_type = VAR_STRING;
! 	tv.vval.v_string = redir_ga.ga_data;
! 	set_var_lval(redir_lval, redir_endp, &tv, FALSE, (char_u *)".");
! 	vim_free(tv.vval.v_string);
  
  	clear_lval(redir_lval);
  	vim_free(redir_lval);
--- 1097,1114 ----
  
      if (redir_lval != NULL)
      {
! 	/* If there was no error: assign the text to the variable. */
! 	if (redir_endp != NULL)
! 	{
! 	    ga_append(&redir_ga, NUL);  /* Append the trailing NUL. */
! 	    tv.v_type = VAR_STRING;
! 	    tv.vval.v_string = redir_ga.ga_data;
! 	    set_var_lval(redir_lval, redir_endp, &tv, FALSE, (char_u *)".");
! 	}
  
! 	/* free the collected output */
! 	vim_free(redir_ga.ga_data);
! 	redir_ga.ga_data = NULL;
  
  	clear_lval(redir_lval);
  	vim_free(redir_lval);
*** ../vim-7.2.272/src/version.c	2009-11-03 13:06:03.000000000 +0100
--- src/version.c	2009-11-03 14:24:06.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     273,
  /**/

-- 
Permission is granted to read this message out aloud on Kings Cross Road,
London, under the condition that the orator is properly dressed.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.274
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.274
Problem:    Syntax folding doesn't work properly when adding a comment.
Solution:   Fix it and add a test. (Lech Lorens)
Files:	    src/fold.c, src/testdir/test45.in, src/testdir/test45.ok


*** ../vim-7.2.273/src/fold.c	2009-09-18 15:16:37.000000000 +0200
--- src/fold.c	2009-11-03 12:36:37.000000000 +0100
***************
*** 2256,2261 ****
--- 2256,2295 ----
  	}
      }
  
+     /*
+      * If folding is defined by the syntax, it is possible that a change in
+      * one line will cause all sub-folds of the current fold to change (e.g.,
+      * closing a C-style comment can cause folds in the subsequent lines to
+      * appear). To take that into account we should adjust the value of "bot"
+      * to point to the end of the current fold:
+      */
+     if (foldlevelSyntax == getlevel)
+     {
+ 	garray_T *gap = &wp->w_folds;
+ 	fold_T	 *fp = NULL;
+ 	int	  current_fdl = 0;
+ 	linenr_T  fold_start_lnum = 0;
+ 	linenr_T  lnum_rel = fline.lnum;
+ 
+ 	while (current_fdl < fline.lvl)
+ 	{
+ 	    if (!foldFind(gap, lnum_rel, &fp))
+ 		break;
+ 	    ++current_fdl;
+ 
+ 	    fold_start_lnum += fp->fd_top;
+ 	    gap = &fp->fd_nested;
+ 	    lnum_rel -= fp->fd_top;
+ 	}
+ 	if (fp != NULL && current_fdl == fline.lvl)
+ 	{
+ 	    linenr_T fold_end_lnum = fold_start_lnum + fp->fd_len;
+ 
+ 	    if (fold_end_lnum > bot)
+ 		bot = fold_end_lnum;
+ 	}
+     }
+ 
      start = fline.lnum;
      end = bot;
      /* Do at least one line. */
*** ../vim-7.2.273/src/testdir/test45.in	2007-09-25 17:58:43.000000000 +0200
--- src/testdir/test45.in	2009-11-03 12:22:38.000000000 +0100
***************
*** 28,36 ****
  k:call append("$", foldlevel("."))
  :" test syntax folding
  :set fdm=syntax fdl=0
! :syn region Hup start="dd" end="hh" fold
  Gzk:call append("$", "folding " . getline("."))
  k:call append("$", getline("."))
  :" test expression folding
  :fun Flvl()
    let l = getline(v:lnum)
--- 28,41 ----
  k:call append("$", foldlevel("."))
  :" test syntax folding
  :set fdm=syntax fdl=0
! :syn region Hup start="dd" end="ii" fold contains=Fd1,Fd2,Fd3
! :syn region Fd1 start="ee" end="ff" fold contained
! :syn region Fd2 start="gg" end="hh" fold contained
! :syn region Fd3 start="commentstart" end="commentend" fold contained
  Gzk:call append("$", "folding " . getline("."))
  k:call append("$", getline("."))
+ jAcommentstart  Acommentend:set fdl=1
+ 3j:call append("$", getline("."))
  :" test expression folding
  :fun Flvl()
    let l = getline(v:lnum)
*** ../vim-7.2.273/src/testdir/test45.ok	2004-06-13 17:47:37.000000000 +0200
--- src/testdir/test45.ok	2009-11-03 12:22:50.000000000 +0100
***************
*** 8,15 ****
  0
  indent 2
  1
! folding 8 hh
      3 cc
  expr 2
  1
  2
--- 8,16 ----
  0
  indent 2
  1
! folding 9 ii
      3 cc
+ 7 gg
  expr 2
  1
  2
*** ../vim-7.2.273/src/version.c	2009-11-03 14:26:29.000000000 +0100
--- src/version.c	2009-11-03 14:44:21.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     274,
  /**/

-- 
BRIDGEKEEPER: What is your favorite colour?
LAUNCELOT:    Blue.
BRIDGEKEEPER: Right.  Off you go.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.275
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.275
Problem:    Warning for unused argument and comparing signed and unsigned.
Solution:   Add type cast.
Files:	    src/memline.c


*** ../vim-7.2.274/src/memline.c	2009-11-03 13:06:03.000000000 +0100
--- src/memline.c	2009-10-29 20:55:08.000000000 +0100
***************
*** 1285,1291 ****
  		    for (i = 0; i < dp->db_line_count; ++i)
  		    {
  			txt_start = (dp->db_index[i] & DB_INDEX_MASK);
! 			if (txt_start <= HEADER_SIZE
  					  || txt_start >= (int)dp->db_txt_end)
  			{
  			    p = (char_u *)"???";
--- 1285,1291 ----
  		    for (i = 0; i < dp->db_line_count; ++i)
  		    {
  			txt_start = (dp->db_index[i] & DB_INDEX_MASK);
! 			if (txt_start <= (int)HEADER_SIZE
  					  || txt_start >= (int)dp->db_txt_end)
  			{
  			    p = (char_u *)"???";
***************
*** 1296,1302 ****
  			ml_append(lnum++, p, (colnr_T)0, TRUE);
  		    }
  		    if (has_error)
! 			ml_append(lnum++, (char_u *)_("???END"), (colnr_T)0, TRUE);
  		}
  	    }
  	}
--- 1296,1303 ----
  			ml_append(lnum++, p, (colnr_T)0, TRUE);
  		    }
  		    if (has_error)
! 			ml_append(lnum++, (char_u *)_("???END"),
! 							    (colnr_T)0, TRUE);
  		}
  	    }
  	}
***************
*** 3576,3586 ****
   * Make swap file name out of the file name and a directory name.
   * Returns pointer to allocated memory or NULL.
   */
- /*ARGSUSED*/
      char_u *
  makeswapname(fname, ffname, buf, dir_name)
      char_u	*fname;
!     char_u	*ffname;
      buf_T	*buf;
      char_u	*dir_name;
  {
--- 3577,3586 ----
   * Make swap file name out of the file name and a directory name.
   * Returns pointer to allocated memory or NULL.
   */
      char_u *
  makeswapname(fname, ffname, buf, dir_name)
      char_u	*fname;
!     char_u	*ffname UNUSED;
      buf_T	*buf;
      char_u	*dir_name;
  {
*** ../vim-7.2.274/src/version.c	2009-11-03 14:46:35.000000000 +0100
--- src/version.c	2009-11-03 15:28:33.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     275,
  /**/

-- 
BRIDGEKEEPER: What is your favorite colour?
GAWAIN:       Blue ...  No yelloooooww!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.276
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.276
Problem:    Crash when setting 'isprint' to a small bullet. (Raul Coronado)
Solution:   Check for the character to be < 256.  Also make it possible to
	    specify a range of multi-byte characters. (Lech Lorens)
Files:	    src/charset.c


*** ../vim-7.2.275/src/charset.c	2009-10-07 16:19:52.000000000 +0200
--- src/charset.c	2009-11-03 12:46:12.000000000 +0100
***************
*** 187,195 ****
  		if (VIM_ISDIGIT(*p))
  		    c2 = getdigits(&p);
  		else
  		    c2 = *p++;
  	    }
! 	    if (c <= 0 || (c2 < c && c2 != -1) || c2 >= 256
  						 || !(*p == NUL || *p == ','))
  		return FAIL;
  
--- 187,200 ----
  		if (VIM_ISDIGIT(*p))
  		    c2 = getdigits(&p);
  		else
+ #ifdef FEAT_MBYTE
+ 		     if (has_mbyte)
+ 		    c2 = mb_ptr2char_adv(&p);
+ 		else
+ #endif
  		    c2 = *p++;
  	    }
! 	    if (c <= 0 || c >= 256 || (c2 < c && c2 != -1) || c2 >= 256
  						 || !(*p == NUL || *p == ','))
  		return FAIL;
  
*** ../vim-7.2.275/src/version.c	2009-11-03 15:32:58.000000000 +0100
--- src/version.c	2009-11-03 16:03:18.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     276,
  /**/

-- 
BRIDGEKEEPER: What is your favorite editor?
GAWAIN:       Emacs ...  No, Viiiiiiiiiiimmmmmmm!
           "Monty Python and the Holy editor wars" PYTHON (MONTY) SOFTWARE LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.277
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.277
Problem:    CTRL-Y in a diff'ed window may move the cursor outside of the
	    window. (Lech Lorens)
Solution:   Limit the number of filler lines to the height of the window.
	    Don't reset filler lines to zero for an empty buffer.
Files:	    src/move.c


*** ../vim-7.2.276/src/move.c	2009-05-15 21:31:11.000000000 +0200
--- src/move.c	2009-11-03 14:39:55.000000000 +0100
***************
*** 183,191 ****
  	if (curwin->w_topline != 1)
  	    redraw_later(NOT_VALID);
  	curwin->w_topline = 1;
- #ifdef FEAT_DIFF
- 	curwin->w_topfill = 0;
- #endif
  	curwin->w_botline = 2;
  	curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
  #ifdef FEAT_SCROLLBIND
--- 183,188 ----
***************
*** 1257,1263 ****
      while (line_count-- > 0)
      {
  #ifdef FEAT_DIFF
! 	if (curwin->w_topfill < diff_check(curwin, curwin->w_topline))
  	{
  	    ++curwin->w_topfill;
  	    ++done;
--- 1254,1261 ----
      while (line_count-- > 0)
      {
  #ifdef FEAT_DIFF
! 	if (curwin->w_topfill < diff_check(curwin, curwin->w_topline)
! 		&& curwin->w_topfill < curwin->w_height - 1)
  	{
  	    ++curwin->w_topfill;
  	    ++done;
*** ../vim-7.2.276/src/version.c	2009-11-03 16:03:59.000000000 +0100
--- src/version.c	2009-11-03 16:22:04.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     277,
  /**/

-- 
SIGFUN -- signature too funny (core dumped)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.278
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.278
Problem:    Using magic number in the folding code.
Solution:   Use the defined MAX_LEVEL.
Files:	    src/fold.c


*** ../vim-7.2.277/src/fold.c	2009-11-03 14:46:35.000000000 +0100
--- src/fold.c	2009-11-03 12:36:37.000000000 +0100
***************
*** 1932,1938 ****
  #ifdef FEAT_EVAL
      if (*wp->w_p_fdt != NUL)
      {
! 	char_u	dashes[51];
  	win_T	*save_curwin;
  	int	level;
  	char_u	*p;
--- 1932,1938 ----
  #ifdef FEAT_EVAL
      if (*wp->w_p_fdt != NUL)
      {
! 	char_u	dashes[MAX_LEVEL + 2];
  	win_T	*save_curwin;
  	int	level;
  	char_u	*p;
***************
*** 1944,1951 ****
  	/* Set "v:folddashes" to a string of "level" dashes. */
  	/* Set "v:foldlevel" to "level". */
  	level = foldinfo->fi_level;
! 	if (level > 50)
! 	    level = 50;
  	vim_memset(dashes, '-', (size_t)level);
  	dashes[level] = NUL;
  	set_vim_var_string(VV_FOLDDASHES, dashes, -1);
--- 1944,1951 ----
  	/* Set "v:folddashes" to a string of "level" dashes. */
  	/* Set "v:foldlevel" to "level". */
  	level = foldinfo->fi_level;
! 	if (level > (int)sizeof(dashes) - 1)
! 	    level = (int)sizeof(dashes) - 1;
  	vim_memset(dashes, '-', (size_t)level);
  	dashes[level] = NUL;
  	set_vim_var_string(VV_FOLDDASHES, dashes, -1);
*** ../vim-7.2.277/src/version.c	2009-11-03 16:22:59.000000000 +0100
--- src/version.c	2009-11-03 16:29:08.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     278,
  /**/

-- 
BRIDGEKEEPER: What is the air-speed velocity of an unladen swallow?
ARTHUR:       What do you mean?  An African or European swallow?
BRIDGEKEEPER: Er ...  I don't know that ... Aaaaarrrrrrggghhh!
   BRIDGEKEEPER is cast into the gorge.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.279
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.279
Problem:    Invalid memory read with visual mode "r". (Dominique Pelle)
Solution:   Make sure the cursor position is valid.  Don't check the cursor
	    position but the position being used.  And make sure we get the
	    right line.
Files:	    src/misc2.c, src/ops.c


*** ../vim-7.2.278/src/misc2.c	2009-05-16 21:06:36.000000000 +0200
--- src/misc2.c	2009-11-03 16:43:10.000000000 +0100
***************
*** 156,162 ****
  		    || ((ve_flags & VE_ONEMORE) && wcol < MAXCOL)
  #endif
  		    ;
!     line = ml_get_curline();
  
      if (wcol >= MAXCOL)
      {
--- 156,162 ----
  		    || ((ve_flags & VE_ONEMORE) && wcol < MAXCOL)
  #endif
  		    ;
!     line = ml_get_buf(curbuf, pos->lnum, FALSE);
  
      if (wcol >= MAXCOL)
      {
***************
*** 332,340 ****
  #endif
  
  #ifdef FEAT_MBYTE
!     /* prevent cursor from moving on the trail byte */
      if (has_mbyte)
! 	mb_adjust_cursor();
  #endif
  
      if (col < wcol)
--- 332,340 ----
  #endif
  
  #ifdef FEAT_MBYTE
!     /* prevent from moving onto a trail byte */
      if (has_mbyte)
! 	mb_adjustpos(pos);
  #endif
  
      if (col < wcol)
*** ../vim-7.2.278/src/ops.c	2009-09-30 15:15:33.000000000 +0200
--- src/ops.c	2009-11-03 15:18:50.000000000 +0100
***************
*** 2020,2025 ****
--- 2020,2026 ----
  	bd.is_MAX = (curwin->w_curswant == MAXCOL);
  	for ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)
  	{
+ 	    curwin->w_cursor.col = 0;  /* make sure cursor position is valid */
  	    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);
  	    if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))
  		continue;	    /* nothing to replace */
***************
*** 2035,2040 ****
--- 2036,2042 ----
  	    {
  		pos_T vpos;
  
+ 		vpos.lnum = curwin->w_cursor.lnum;
  		getvpos(&vpos, oap->start_vcol);
  		bd.startspaces += vpos.coladd;
  		n = bd.startspaces;
***************
*** 2693,2703 ****
  			 * initial coladd offset as part of "startspaces" */
  			if (bd.is_short)
  			{
! 			    linenr_T lnum = curwin->w_cursor.lnum;
! 
! 			    curwin->w_cursor.lnum = linenr;
  			    (void)getvpos(&vpos, oap->start_vcol);
- 			    curwin->w_cursor.lnum = lnum;
  			}
  			else
  			    vpos.coladd = 0;
--- 2695,2702 ----
  			 * initial coladd offset as part of "startspaces" */
  			if (bd.is_short)
  			{
! 			    vpos.lnum = linenr;
  			    (void)getvpos(&vpos, oap->start_vcol);
  			}
  			else
  			    vpos.coladd = 0;
*** ../vim-7.2.278/src/version.c	2009-11-03 16:29:48.000000000 +0100
--- src/version.c	2009-11-03 16:41:53.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     279,
  /**/

-- 
BEDEVERE: How do you know so much about swallows?
ARTHUR:   Well you have to know these things when you're a king, you know.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.280
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.280
Problem:    A redraw in a custom statusline with %! may cause a crash.
            (Yukihiro Nakadaira)
Solution:   Make a copy of 'statusline'.  Also fix typo in function name
            redraw_custum_statusline. (party by Dominique Pelle)
Files:      src/screen.c


*** ../vim-7.2.279/src/screen.c	2009-07-29 16:13:35.000000000 +0200
--- src/screen.c	2009-11-03 17:13:16.000000000 +0100
***************
*** 132,138 ****
  static void draw_vsep_win __ARGS((win_T *wp, int row));
  #endif
  #ifdef FEAT_STL_OPT
! static void redraw_custum_statusline __ARGS((win_T *wp));
  #endif
  #ifdef FEAT_SEARCH_EXTRA
  #define SEARCH_HL_PRIORITY 0
--- 132,138 ----
  static void draw_vsep_win __ARGS((win_T *wp, int row));
  #endif
  #ifdef FEAT_STL_OPT
! static void redraw_custom_statusline __ARGS((win_T *wp));
  #endif
  #ifdef FEAT_SEARCH_EXTRA
  #define SEARCH_HL_PRIORITY 0
***************
*** 5772,5778 ****
      else if (*p_stl != NUL || *wp->w_p_stl != NUL)
      {
  	/* redraw custom status line */
! 	redraw_custum_statusline(wp);
      }
  #endif
      else
--- 5794,5800 ----
      else if (*p_stl != NUL || *wp->w_p_stl != NUL)
      {
  	/* redraw custom status line */
! 	redraw_custom_statusline(wp);
      }
  #endif
      else
***************
*** 5897,5914 ****
   * errors encountered.
   */
      static void
! redraw_custum_statusline(wp)
      win_T	    *wp;
  {
!     int	save_called_emsg = called_emsg;
  
      called_emsg = FALSE;
      win_redr_custom(wp, FALSE);
      if (called_emsg)
  	set_string_option_direct((char_u *)"statusline", -1,
  		(char_u *)"", OPT_FREE | (*wp->w_p_stl != NUL
  					? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);
      called_emsg |= save_called_emsg;
  }
  #endif
  
--- 5919,5949 ----
   * errors encountered.
   */
      static void
! redraw_custom_statusline(wp)
      win_T	    *wp;
  {
!     static int	    entered = FALSE;
!     int		    save_called_emsg = called_emsg;
! 
!     /* When called recursively return.  This can happen when the statusline
!      * contains an expression that triggers a redraw. */
!     if (entered)
! 	return;
!     entered = TRUE;
  
      called_emsg = FALSE;
      win_redr_custom(wp, FALSE);
      if (called_emsg)
+     {
+ 	/* When there is an error disable the statusline, otherwise the
+ 	 * display is messed up with errors and a redraw triggers the problem
+ 	 * again and again. */
  	set_string_option_direct((char_u *)"statusline", -1,
  		(char_u *)"", OPT_FREE | (*wp->w_p_stl != NUL
  					? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);
+     }
      called_emsg |= save_called_emsg;
+     entered = FALSE;
  }
  #endif
  
***************
*** 6016,6021 ****
--- 6051,6057 ----
      int		len;
      int		fillchar;
      char_u	buf[MAXPATHL];
+     char_u	*stl;
      char_u	*p;
      struct	stl_hlrec hltab[STL_MAX_ITEM];
      struct	stl_hlrec tabtab[STL_MAX_ITEM];
***************
*** 6025,6031 ****
      if (wp == NULL)
      {
  	/* Use 'tabline'.  Always at the first line of the screen. */
! 	p = p_tal;
  	row = 0;
  	fillchar = ' ';
  	attr = hl_attr(HLF_TPF);
--- 6061,6067 ----
      if (wp == NULL)
      {
  	/* Use 'tabline'.  Always at the first line of the screen. */
! 	stl = p_tal;
  	row = 0;
  	fillchar = ' ';
  	attr = hl_attr(HLF_TPF);
***************
*** 6042,6058 ****
  
  	if (draw_ruler)
  	{
! 	    p = p_ruf;
  	    /* advance past any leading group spec - implicit in ru_col */
! 	    if (*p == '%')
  	    {
! 		if (*++p == '-')
! 		    p++;
! 		if (atoi((char *) p))
! 		    while (VIM_ISDIGIT(*p))
! 			p++;
! 		if (*p++ != '(')
! 		    p = p_ruf;
  	    }
  #ifdef FEAT_VERTSPLIT
  	    col = ru_col - (Columns - W_WIDTH(wp));
--- 6078,6094 ----
  
  	if (draw_ruler)
  	{
! 	    stl = p_ruf;
  	    /* advance past any leading group spec - implicit in ru_col */
! 	    if (*stl == '%')
  	    {
! 		if (*++stl == '-')
! 		    stl++;
! 		if (atoi((char *)stl))
! 		    while (VIM_ISDIGIT(*stl))
! 			stl++;
! 		if (*stl++ != '(')
! 		    stl = p_ruf;
  	    }
  #ifdef FEAT_VERTSPLIT
  	    col = ru_col - (Columns - W_WIDTH(wp));
***************
*** 6081,6089 ****
  	else
  	{
  	    if (*wp->w_p_stl != NUL)
! 		p = wp->w_p_stl;
  	    else
! 		p = p_stl;
  # ifdef FEAT_EVAL
  	    use_sandbox = was_set_insecurely((char_u *)"statusline",
  					 *wp->w_p_stl == NUL ? 0 : OPT_LOCAL);
--- 6117,6125 ----
  	else
  	{
  	    if (*wp->w_p_stl != NUL)
! 		stl = wp->w_p_stl;
  	    else
! 		stl = p_stl;
  # ifdef FEAT_EVAL
  	    use_sandbox = was_set_insecurely((char_u *)"statusline",
  					 *wp->w_p_stl == NUL ? 0 : OPT_LOCAL);
***************
*** 6098,6107 ****
      if (maxwidth <= 0)
  	return;
  
      width = build_stl_str_hl(wp == NULL ? curwin : wp,
  				buf, sizeof(buf),
! 				p, use_sandbox,
  				fillchar, maxwidth, hltab, tabtab);
      len = (int)STRLEN(buf);
  
      while (width < maxwidth && len < (int)sizeof(buf) - 1)
--- 6134,6147 ----
      if (maxwidth <= 0)
  	return;
  
+     /* Make a copy, because the statusline may include a function call that
+      * might change the option value and free the memory. */
+     stl = vim_strsave(stl);
      width = build_stl_str_hl(wp == NULL ? curwin : wp,
  				buf, sizeof(buf),
! 				stl, use_sandbox,
  				fillchar, maxwidth, hltab, tabtab);
+     vim_free(stl);
      len = (int)STRLEN(buf);
  
      while (width < maxwidth && len < (int)sizeof(buf) - 1)
***************
*** 9465,9471 ****
  #if defined(FEAT_STL_OPT) && defined(FEAT_WINDOWS)
      if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)
      {
! 	redraw_custum_statusline(curwin);
      }
      else
  #endif
--- 9505,9511 ----
  #if defined(FEAT_STL_OPT) && defined(FEAT_WINDOWS)
      if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)
      {
! 	redraw_custom_statusline(curwin);
      }
      else
  #endif
*** ../vim-7.2.279/src/version.c	2009-11-03 16:44:04.000000000 +0100
--- src/version.c	2009-11-03 17:15:35.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     280,
  /**/

-- 
Every exit is an entrance into something else.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.281
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.281
Problem:    'cursorcolumn' highlighting is wrong in diff mode.
Solution:   Adjust the column computation. (Lech Lorens)
Files:	    src/screen.c


*** ../vim-7.2.280/src/screen.c	2009-11-03 17:20:18.000000000 +0100
--- src/screen.c	2009-11-03 17:13:16.000000000 +0100
***************
*** 3008,3018 ****
  	    mb_ptr_adv(ptr);
  	}
  
! #ifdef FEAT_VIRTUALEDIT
! 	/* When 'virtualedit' is set the end of the line may be before the
! 	 * start of the displayed part. */
! 	if (vcol < v && *ptr == NUL && virtual_active())
  	    vcol = v;
  #endif
  
  	/* Handle a character that's not completely on the screen: Put ptr at
--- 3008,3040 ----
  	    mb_ptr_adv(ptr);
  	}
  
! #if defined(FEAT_SYN_HL) || defined(FEAT_VIRTUALEDIT) || defined(FEAT_VISUAL)
! 	/* When:
! 	 * - 'cuc' is set, or
! 	 * - 'virtualedit' is set, or
! 	 * - the visual mode is active,
! 	 * the end of the line may be before the start of the displayed part.
! 	 */
! 	if (vcol < v && (
! # ifdef FEAT_SYN_HL
! 	     wp->w_p_cuc
! #  if defined(FEAT_VIRTUALEDIT) || defined(FEAT_VISUAL)
! 	     ||
! #  endif
! # endif
! # ifdef FEAT_VIRTUALEDIT
! 	     virtual_active()
! #  ifdef FEAT_VISUAL
! 	     ||
! #  endif
! # endif
! # ifdef FEAT_VISUAL
! 	     (VIsual_active && wp->w_buffer == curwin->w_buffer)
! # endif
! 	     ))
! 	{
  	    vcol = v;
+ 	}
  #endif
  
  	/* Handle a character that's not completely on the screen: Put ptr at
*** ../vim-7.2.280/src/version.c	2009-11-03 17:20:18.000000000 +0100
--- src/version.c	2009-11-03 17:34:54.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     281,
  /**/

-- 
Every person is responsible for the choices he makes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.282
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.282
Problem:    A fold can't be closed.
Solution:   Initialize fd_small to MAYBE. (Lech Lorens)
Files:	    src/fold.c


*** ../vim-7.2.281/src/fold.c	2009-11-03 16:29:48.000000000 +0100
--- src/fold.c	2009-11-03 17:41:50.000000000 +0100
***************
*** 2851,2856 ****
--- 2851,2858 ----
      fp[1].fd_top = bot + 1;
      fp[1].fd_len = fp->fd_len - (fp[1].fd_top - fp->fd_top);
      fp[1].fd_flags = fp->fd_flags;
+     fp[1].fd_small = MAYBE;
+     fp->fd_small = MAYBE;
  
      /* Move nested folds below bot to new fold.  There can't be
       * any between top and bot, they have been removed by the caller. */
*** ../vim-7.2.281/src/version.c	2009-11-03 17:36:09.000000000 +0100
--- src/version.c	2009-11-03 17:59:12.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     282,
  /**/

-- 
You can be stopped by the police for biking over 65 miles per hour.
You are not allowed to walk across a street on your hands.
		[real standing laws in Connecticut, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.283
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.283
Problem:    Changing font while the window is maximized doesn't keep the
	    window maximized.
Solution:   Recompute number of lines and columns after changing font. (James
	    Vega)
Files:	    src/gui_gtk_x11.c


*** ../vim-7.2.282/src/gui_gtk_x11.c	2009-09-23 18:14:13.000000000 +0200
--- src/gui_gtk_x11.c	2009-11-03 17:56:27.000000000 +0100
***************
*** 5267,5274 ****
  # endif
  #endif /* !HAVE_GTK2 */
  
!     /* Preserve the logical dimensions of the screen. */
!     update_window_manager_hints(0, 0);
  
      return OK;
  }
--- 5267,5290 ----
  # endif
  #endif /* !HAVE_GTK2 */
  
! #ifdef HAVE_GTK2
!     if (gui_mch_maximized())
!     {
! 	int w, h;
! 
! 	/* Update lines and columns in accordance with the new font, keep the
! 	 * window maximized. */
! 	gtk_window_get_size(GTK_WINDOW(gui.mainwin), &w, &h);
! 	w -= get_menu_tool_width();
! 	h -= get_menu_tool_height();
! 	gui_resize_shell(w, h);
!     }
!     else
! #endif
!     {
! 	/* Preserve the logical dimensions of the screen. */
! 	update_window_manager_hints(0, 0);
!     }
  
      return OK;
  }
*** ../vim-7.2.282/src/version.c	2009-11-03 18:04:26.000000000 +0100
--- src/version.c	2009-11-03 18:11:53.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     283,
  /**/

-- 
If an elephant is left tied to a parking meter, the parking fee has to be paid
just as it would for a vehicle.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.284
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.284
Problem:    When editing the same buffer in two windows, one with folding,
	    display may be wrong after changes.
Solution:   Call set_topline() to take care of side effects. (Lech Lorens)
Files:	    src/misc1.c


*** ../vim-7.2.283/src/misc1.c	2009-07-22 11:03:38.000000000 +0200
--- src/misc1.c	2009-11-03 18:38:15.000000000 +0100
***************
*** 2886,2891 ****
--- 2886,2898 ----
  		    }
  #endif
  		}
+ 
+ #ifdef FEAT_FOLDING
+ 	    /* Take care of side effects for setting w_topline when folds have
+ 	     * changed.  Esp. when the buffer was changed in another window. */
+ 	    if (hasAnyFolding(wp))
+ 		set_topline(wp, wp->w_topline);
+ #endif
  	}
      }
  
*** ../vim-7.2.283/src/version.c	2009-11-03 18:13:36.000000000 +0100
--- src/version.c	2009-11-03 18:44:12.000000000 +0100
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     284,
  /**/

-- 
Men may not be seen publicly in any kind of strapless gown.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.285
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.285 (after 7.2.169)
Problem:    CTRL-U in Insert mode also deletes indent. (Andrey Voropaev)
Solution:   Fix mistake made in patch 7.2.169.
Files:	    src/edit.c


*** ../vim-7.2.284/src/edit.c	2009-07-09 18:15:19.000000000 +0200
--- src/edit.c	2009-11-05 20:25:15.000000000 +0100
***************
*** 8519,8525 ****
  	{
  	    save_col = curwin->w_cursor.col;
  	    beginline(BL_WHITE);
! 	    if (curwin->w_cursor.col < (colnr_T)temp)
  		mincol = curwin->w_cursor.col;
  	    curwin->w_cursor.col = save_col;
  	}
--- 8519,8525 ----
  	{
  	    save_col = curwin->w_cursor.col;
  	    beginline(BL_WHITE);
! 	    if (curwin->w_cursor.col < save_col)
  		mincol = curwin->w_cursor.col;
  	    curwin->w_cursor.col = save_col;
  	}
*** ../vim-7.2.284/src/version.c	2009-11-03 18:46:53.000000000 +0100
--- src/version.c	2009-11-11 13:21:25.000000000 +0100
***************
*** 678,679 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     285,
  /**/

-- 
(letter from Mark to Mike, about the film's probable certificate)
      I would like to get back to the Censor and agree to lose the shits, take
      the odd Jesus Christ out and lose Oh fuck off, but to retain 'fart in
      your general direction', 'castanets of your testicles' and 'oral sex'
      and ask him for an 'A' rating on that basis.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.286
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.286 (after 7.2.269)
Problem:    The "--startuptime=<file>" argument is not consistent with other
	    arguments.
Solution:   Use "--startuptime <file>".  Added the +startuptime feature.
Files:	    runtime/doc/eval.txt, runtime/doc/starting.txt,
	    runtime/doc/various.txt, src/eval.c, src/main.c, src/version.c


*** ../vim-7.2.285/runtime/doc/eval.txt	2009-04-22 12:53:31.000000000 +0200
--- runtime/doc/eval.txt	2009-11-11 13:01:58.000000000 +0100
***************
*** 5869,5874 ****
--- 5881,5887 ----
  signs			Compiled with |:sign| support.
  smartindent		Compiled with 'smartindent' support.
  sniff			Compiled with SNiFF interface support.
+ startuptime		Compiled with |--startuptime| support.
  statusline		Compiled with support for 'statusline', 'rulerformat'
  			and special formats of 'titlestring' and 'iconstring'.
  sun_workshop		Compiled with support for Sun |workshop|.
*** ../vim-7.2.285/runtime/doc/starting.txt	2009-11-03 12:10:39.000000000 +0100
--- runtime/doc/starting.txt	2009-11-11 13:20:56.000000000 +0100
***************
*** 144,155 ****
  			-u NORC			no		    yes
  			--noplugin		yes		    no
  
! --startuptime={fname}					*--startuptime*
  		During startup write timing messages to the file {fname}.
  		This can be used to find out where time is spent while loading
! 		your .vimrc and plugins.
  		When {fname} already exists new messages are appended.
! 		{only when compiled with this feature}
  
  							*--literal*
  --literal	Take file names literally, don't expand wildcards.  Not needed
--- 144,156 ----
  			-u NORC			no		    yes
  			--noplugin		yes		    no
  
! --startuptime {fname}					*--startuptime*
  		During startup write timing messages to the file {fname}.
  		This can be used to find out where time is spent while loading
! 		your .vimrc, plugins and opening the first file.
  		When {fname} already exists new messages are appended.
! 		(Only available when compiled with the |+startuptime|
! 		feature).
  
  							*--literal*
  --literal	Take file names literally, don't expand wildcards.  Not needed
*** ../vim-7.2.285/runtime/doc/various.txt	2009-07-09 15:55:34.000000000 +0200
--- runtime/doc/various.txt	2009-11-11 13:03:52.000000000 +0100
***************
*** 374,379 ****
--- 374,380 ----
  B  *+signs*		|:sign|
  N  *+smartindent*	|'smartindent'|
  m  *+sniff*		SniFF interface |sniff|
+ N  *+startuptime*	|--startuptime| argument
  N  *+statusline*	Options 'statusline', 'rulerformat' and special
  			formats of 'titlestring' and 'iconstring'
  m  *+sun_workshop*	|workshop|
*** ../vim-7.2.285/src/eval.c	2009-11-03 14:26:29.000000000 +0100
--- src/eval.c	2009-11-11 12:59:53.000000000 +0100
***************
*** 11736,11741 ****
--- 11736,11744 ----
  #ifdef FEAT_SNIFF
  	"sniff",
  #endif
+ #ifdef STARTUPTIME
+ 	"startuptime",
+ #endif
  #ifdef FEAT_STL_OPT
  	"statusline",
  #endif
*** ../vim-7.2.285/src/main.c	2009-11-03 12:10:39.000000000 +0100
--- src/main.c	2009-11-08 12:57:46.000000000 +0100
***************
*** 204,212 ****
  #ifdef STARTUPTIME
      for (i = 1; i < argc; ++i)
      {
! 	if (STRNICMP(argv[i], "--startuptime=", 14) == 0)
  	{
! 	    time_fd = mch_fopen(argv[i] + 14, "a");
  	    TIME_MSG("--- VIM STARTING ---");
  	    break;
  	}
--- 204,212 ----
  #ifdef STARTUPTIME
      for (i = 1; i < argc; ++i)
      {
! 	if (STRICMP(argv[i], "--startuptime") == 0 && i + 1 < argc)
  	{
! 	    time_fd = mch_fopen(argv[i + 1], "a");
  	    TIME_MSG("--- VIM STARTING ---");
  	    break;
  	}
***************
*** 1726,1731 ****
--- 1726,1736 ----
  		    want_argument = TRUE;
  		    argv_idx += 3;
  		}
+ 		else if (STRNICMP(argv[0] + argv_idx, "startuptime", 11) == 0)
+ 		{
+ 		    want_argument = TRUE;
+ 		    argv_idx += 11;
+ 		}
  #ifdef FEAT_CLIENTSERVER
  		else if (STRNICMP(argv[0] + argv_idx, "serverlist", 10) == 0)
  		    ; /* already processed -- no arg */
***************
*** 1761,1770 ****
  		    /* already processed, skip */
  		}
  #endif
- 		else if (STRNICMP(argv[0] + argv_idx, "startuptime", 11) == 0)
- 		{
- 		    /* already processed, skip */
- 		}
  		else
  		{
  		    if (argv[0][argv_idx])
--- 1766,1771 ----
***************
*** 2061,2067 ****
  		    mainerr(ME_GARBAGE, (char_u *)argv[0]);
  
  		--argc;
! 		if (argc < 1 && c != 'S')
  		    mainerr_arg_missing((char_u *)argv[0]);
  		++argv;
  		argv_idx = -1;
--- 2062,2068 ----
  		    mainerr(ME_GARBAGE, (char_u *)argv[0]);
  
  		--argc;
! 		if (argc < 1 && c != 'S')  /* -S has an optional argument */
  		    mainerr_arg_missing((char_u *)argv[0]);
  		++argv;
  		argv_idx = -1;
***************
*** 2102,2112 ****
  							    (char_u *)argv[0];
  		    break;
  
! 		case '-':	/* "--cmd {command}" execute command */
! 		    if (parmp->n_pre_commands >= MAX_ARG_CMDS)
! 			mainerr(ME_EXTRA_CMD, NULL);
! 		    parmp->pre_commands[parmp->n_pre_commands++] =
  							    (char_u *)argv[0];
  		    break;
  
  	    /*	case 'd':   -d {device} is handled in mch_check_win() for the
--- 2103,2118 ----
  							    (char_u *)argv[0];
  		    break;
  
! 		case '-':
! 		    if (argv[-1][2] == 'c')
! 		    {
! 			/* "--cmd {command}" execute command */
! 			if (parmp->n_pre_commands >= MAX_ARG_CMDS)
! 			    mainerr(ME_EXTRA_CMD, NULL);
! 			parmp->pre_commands[parmp->n_pre_commands++] =
  							    (char_u *)argv[0];
+ 		    }
+ 		    /* "--startuptime <file>" already handled */
  		    break;
  
  	    /*	case 'd':   -d {device} is handled in mch_check_win() for the
***************
*** 3144,3149 ****
--- 3150,3158 ----
      main_msg(_("--serverlist\t\tList available Vim server names and exit"));
      main_msg(_("--servername <name>\tSend to/become the Vim server <name>"));
  #endif
+ #ifdef STARTUPTIME
+     main_msg(_("--startuptime=<file>\tWrite startup timing messages to <file>"));
+ #endif
  #ifdef FEAT_VIMINFO
      main_msg(_("-i <viminfo>\t\tUse <viminfo> instead of .viminfo"));
  #endif
*** ../vim-7.2.285/src/version.c	2009-11-11 13:22:09.000000000 +0100
--- src/version.c	2009-11-11 14:17:28.000000000 +0100
***************
*** 494,499 ****
--- 494,504 ----
  #else
  	"-sniff",
  #endif
+ #ifdef STARTUPTIME
+ 	"+startuptime",
+ #else
+ 	"-startuptime",
+ #endif
  #ifdef FEAT_STL_OPT
  	"+statusline",
  #else
*** ../vim-7.2.285/src/version.c	2009-11-11 13:22:09.000000000 +0100
--- src/version.c	2009-11-11 14:17:28.000000000 +0100
***************
*** 678,679 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     286,
  /**/

-- 
A fool must search for a greater fool to find admiration.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.287
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.287
Problem:    Warning from gcc 3.4 about uninitialized variable.
Solution:   Move assignment outside of #ifdef.
Files:	    src/if_perl.xs


*** ../vim-7.2.286/src/if_perl.xs	2009-07-14 16:05:14.000000000 +0200
--- src/if_perl.xs	2009-11-11 12:29:32.000000000 +0100
***************
*** 720,727 ****
  #ifdef HAVE_SANDBOX
      if (sandbox)
      {
  # ifndef MAKE_TEST  /* avoid a warning for unreachable code */
! 	if ((safe = perl_get_sv( "VIM::safe", FALSE )) == NULL || !SvTRUE(safe))
  	    EMSG(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
  	else
  # endif
--- 720,728 ----
  #ifdef HAVE_SANDBOX
      if (sandbox)
      {
+ 	safe = perl_get_sv( "VIM::safe", FALSE );
  # ifndef MAKE_TEST  /* avoid a warning for unreachable code */
! 	if (safe == NULL || !SvTRUE(safe))
  	    EMSG(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
  	else
  # endif
*** ../vim-7.2.286/src/version.c	2009-11-11 14:21:48.000000000 +0100
--- src/version.c	2009-11-11 14:44:49.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     287,
  /**/

-- 
The most powerful force in the universe is gossip.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.288
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.288
Problem:    Python 2.6 pyconfig.h redefines macros.
Solution:   Undefine the macros before including pyconfig.h.
Files:      src/if_python.c


*** ../vim-7.2.287/src/if_python.c	2009-11-03 11:43:05.000000000 +0100
--- src/if_python.c	2009-11-11 12:33:37.000000000 +0100
***************
*** 37,42 ****
--- 37,48 ----
  #ifdef HAVE_STDARG_H
  # undef HAVE_STDARG_H	/* Python's config.h defines it as well. */
  #endif
+ #ifdef _POSIX_C_SOURCE
+ # undef _POSIX_C_SOURCE	/* pyconfig.h defines it as well. */
+ #endif
+ #ifdef _XOPEN_SOURCE
+ # undef _XOPEN_SOURCE	/* pyconfig.h defines it as well. */
+ #endif
  
  #define PY_SSIZE_T_CLEAN
  
*** ../vim-7.2.287/src/version.c	2009-11-11 14:45:36.000000000 +0100
--- src/version.c	2009-11-11 15:05:51.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     288,
  /**/

-- 
I am always surprised in the Linux world how quickly solutions can be
obtained.  (Imagine sending an email to Bill Gates, asking why Windows
crashed, and how to fix it...  and then getting an answer that fixed the
problem... <0>_<0> !)		              -- Mark Langdon

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.289
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.289
Problem:    Checking wrong struct member.
Solution:   Change tb_buf to tb_noremap. (Dominique Pelle)
Files:	    src/getchar.c


*** ../vim-7.2.288/src/getchar.c	2009-09-30 15:15:33.000000000 +0200
--- src/getchar.c	2009-11-11 12:50:58.000000000 +0100
***************
*** 22,28 ****
   * These buffers are used for storing:
   * - stuffed characters: A command that is translated into another command.
   * - redo characters: will redo the last change.
!  * - recorded chracters: for the "q" command.
   *
   * The bytes are stored like in the typeahead buffer:
   * - K_SPECIAL introduces a special key (two more bytes follow).  A literal
--- 22,28 ----
   * These buffers are used for storing:
   * - stuffed characters: A command that is translated into another command.
   * - redo characters: will redo the last change.
!  * - recorded characters: for the "q" command.
   *
   * The bytes are stored like in the typeahead buffer:
   * - K_SPECIAL introduces a special key (two more bytes follow).  A literal
***************
*** 1283,1289 ****
  	EMSG2(_(e_intern2), "Free typebuf 1");
      else
  	vim_free(typebuf.tb_buf);
!     if (typebuf.tb_buf == noremapbuf_init)
  	EMSG2(_(e_intern2), "Free typebuf 2");
      else
  	vim_free(typebuf.tb_noremap);
--- 1283,1289 ----
  	EMSG2(_(e_intern2), "Free typebuf 1");
      else
  	vim_free(typebuf.tb_buf);
!     if (typebuf.tb_noremap == noremapbuf_init)
  	EMSG2(_(e_intern2), "Free typebuf 2");
      else
  	vim_free(typebuf.tb_noremap);
***************
*** 1516,1522 ****
   * wanted.
   * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.
   * Collects the bytes of a multibyte character into the whole character.
!  * Returns the modifers in the global "mod_mask".
   */
      int
  vgetc()
--- 1516,1522 ----
   * wanted.
   * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.
   * Collects the bytes of a multibyte character into the whole character.
!  * Returns the modifiers in the global "mod_mask".
   */
      int
  vgetc()
***************
*** 3320,3326 ****
  			    retval = 1;
  			    goto theend;
  			}
! 	    /* An abbrevation cannot contain white space. */
  	    for (n = 0; n < len; ++n)
  		if (vim_iswhite(keys[n]))
  		{
--- 3320,3326 ----
  			    retval = 1;
  			    goto theend;
  			}
! 	    /* An abbreviation cannot contain white space. */
  	    for (n = 0; n < len; ++n)
  		if (vim_iswhite(keys[n]))
  		{
***************
*** 4272,4278 ****
  
      /*
       * Check for word before the cursor: If it ends in a keyword char all
!      * chars before it must be al keyword chars or non-keyword chars, but not
       * white space. If it ends in a non-keyword char we accept any characters
       * before it except white space.
       */
--- 4272,4278 ----
  
      /*
       * Check for word before the cursor: If it ends in a keyword char all
!      * chars before it must be keyword chars or non-keyword chars, but not
       * white space. If it ends in a non-keyword char we accept any characters
       * before it except white space.
       */
*** ../vim-7.2.288/src/version.c	2009-11-11 15:06:59.000000000 +0100
--- src/version.c	2009-11-11 16:19:12.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     289,
  /**/

-- 
A M00se once bit my sister ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.290
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.290
Problem:    Not freeing memory from ":lmap", ":xmap" and ":menutranslate".
Solution:   Free the memory when exiting. (Dominique Pelle)
Files:	    src/misc2.c


*** ../vim-7.2.289/src/misc2.c	2009-11-03 16:44:04.000000000 +0100
--- src/misc2.c	2009-11-11 16:49:13.000000000 +0100
***************
*** 1005,1013 ****
--- 1005,1018 ----
  # ifdef FEAT_MENU
      /* Clear menus. */
      do_cmdline_cmd((char_u *)"aunmenu *");
+ #  ifdef FEAT_MULTI_LANG
+     do_cmdline_cmd((char_u *)"menutranslate clear");
+ #  endif
  # endif
  
      /* Clear mappings, abbreviations, breakpoints. */
+     do_cmdline_cmd((char_u *)"lmapclear");
+     do_cmdline_cmd((char_u *)"xmapclear");
      do_cmdline_cmd((char_u *)"mapclear");
      do_cmdline_cmd((char_u *)"mapclear!");
      do_cmdline_cmd((char_u *)"abclear");
***************
*** 1282,1288 ****
  
  /*
   * Escape "string" for use as a shell argument with system().
!  * This uses single quotes, except when we know we need to use double qoutes
   * (MS-DOS and MS-Windows without 'shellslash' set).
   * Escape a newline, depending on the 'shell' option.
   * When "do_special" is TRUE also replace "!", "%", "#" and things starting
--- 1287,1293 ----
  
  /*
   * Escape "string" for use as a shell argument with system().
!  * This uses single quotes, except when we know we need to use double quotes
   * (MS-DOS and MS-Windows without 'shellslash' set).
   * Escape a newline, depending on the 'shell' option.
   * When "do_special" is TRUE also replace "!", "%", "#" and things starting
***************
*** 1537,1543 ****
  #if defined(FEAT_VISUALEXTRA) || defined(PROTO)
  /*
   * Copy a character a number of times.
!  * Does not work for multi-byte charactes!
   */
      void
  copy_chars(ptr, count, c)
--- 1542,1548 ----
  #if defined(FEAT_VISUALEXTRA) || defined(PROTO)
  /*
   * Copy a character a number of times.
!  * Does not work for multi-byte characters!
   */
      void
  copy_chars(ptr, count, c)
***************
*** 4260,4266 ****
  	 * or '**76' is transposed to '**N'( 'N' is ASCII value 76).
  	 * For EBCDIC you get different character values.
  	 * If no restrict is given after '**' the default is used.
! 	 * Due to this technic the path looks awful if you print it as a
  	 * string.
  	 */
  	len = 0;
--- 4265,4271 ----
  	 * or '**76' is transposed to '**N'( 'N' is ASCII value 76).
  	 * For EBCDIC you get different character values.
  	 * If no restrict is given after '**' the default is used.
! 	 * Due to this technique the path looks awful if you print it as a
  	 * string.
  	 */
  	len = 0;
***************
*** 4649,4655 ****
  				      && !mch_isdir(stackp->ffs_filearray[i]))
  			    continue;   /* not a directory */
  
! 			/* prepare the filename to be checked for existance
  			 * below */
  			STRCPY(file_path, stackp->ffs_filearray[i]);
  			add_pathsep(file_path);
--- 4654,4660 ----
  				      && !mch_isdir(stackp->ffs_filearray[i]))
  			    continue;   /* not a directory */
  
! 			/* prepare the filename to be checked for existence
  			 * below */
  			STRCPY(file_path, stackp->ffs_filearray[i]);
  			add_pathsep(file_path);
***************
*** 5438,5444 ****
  #if defined(MSWIN) || defined(MSDOS) || defined(OS2)
  	    /* handle "\tmp" as absolute path */
  	    || vim_ispathsep(ff_file_to_find[0])
! 	    /* handle "c:name" as absulute path */
  	    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')
  #endif
  #ifdef AMIGA
--- 5443,5449 ----
  #if defined(MSWIN) || defined(MSDOS) || defined(OS2)
  	    /* handle "\tmp" as absolute path */
  	    || vim_ispathsep(ff_file_to_find[0])
! 	    /* handle "c:name" as absolute path */
  	    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')
  #endif
  #ifdef AMIGA
***************
*** 5681,5687 ****
  		p2 = (char_u *)base + (j + gap) * elm_size;
  		if ((*cmp)((void *)p1, (void *)p2) <= 0)
  		    break;
! 		/* Exchange the elemets. */
  		mch_memmove(buf, p1, elm_size);
  		mch_memmove(p1, p2, elm_size);
  		mch_memmove(p2, buf, elm_size);
--- 5686,5692 ----
  		p2 = (char_u *)base + (j + gap) * elm_size;
  		if ((*cmp)((void *)p1, (void *)p2) <= 0)
  		    break;
! 		/* Exchange the elements. */
  		mch_memmove(buf, p1, elm_size);
  		mch_memmove(p1, p2, elm_size);
  		mch_memmove(p2, buf, elm_size);
*** ../vim-7.2.289/src/version.c	2009-11-11 16:23:37.000000000 +0100
--- src/version.c	2009-11-11 16:54:53.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     290,
  /**/

-- 
ARTHUR: It is I, Arthur, son of Uther Pendragon, from the castle of Camelot.
        King of all Britons, defeator of the Saxons, sovereign of all England!
   [Pause]
SOLDIER: Get away!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.291
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.291
Problem:    Reading uninitialised memory in arabic mode.
Solution:   Use utfc_ptr2char_len() rather than utfc_ptr2char().  (Dominique
	    Pelle)
Files:	    src/screen.c


*** ../vim-7.2.290/src/screen.c	2009-11-03 17:36:09.000000000 +0100
--- src/screen.c	2009-11-11 17:04:53.000000000 +0100
***************
*** 6413,6419 ****
  		    }
  		    else
  		    {
! 			nc = utfc_ptr2char(ptr + mbyte_blen, pcc);
  			nc1 = pcc[0];
  		    }
  		    pc = prev_c;
--- 6413,6420 ----
  		    }
  		    else
  		    {
! 			nc = utfc_ptr2char_len(ptr + mbyte_blen, pcc,
! 				      (int)((text + len) - ptr - mbyte_blen));
  			nc1 = pcc[0];
  		    }
  		    pc = prev_c;
*** ../vim-7.2.290/src/version.c	2009-11-11 16:56:13.000000000 +0100
--- src/version.c	2009-11-11 17:06:48.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     291,
  /**/

-- 
The problem with political jokes is that they get elected.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.292
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.292
Problem:    Block right-shift doesn't work properly with multi-byte encoding
	    and 'list' set.
Solution:   Add the missing "else". (Lech Lorens)
Files:	    src/ops.c


*** ../vim-7.2.291/src/ops.c	2009-11-03 16:44:04.000000000 +0100
--- src/ops.c	2009-11-11 17:15:04.000000000 +0100
***************
*** 422,429 ****
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		bd.textstart += (*mb_ptr2len)(bd.textstart);
  #endif
! 	    ++bd.textstart;
  	}
  	for ( ; vim_iswhite(*bd.textstart); )
  	{
--- 422,430 ----
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		bd.textstart += (*mb_ptr2len)(bd.textstart);
+ 	    else
  #endif
! 		++bd.textstart;
  	}
  	for ( ; vim_iswhite(*bd.textstart); )
  	{
*** ../vim-7.2.291/src/version.c	2009-11-11 17:07:25.000000000 +0100
--- src/version.c	2009-11-11 17:21:31.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     292,
  /**/

-- 
Computers make very fast, very accurate, mistakes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.293
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.293
Problem:    When setting 'comments' option it may be used in a wrong way. 
Solution:   Don't increment after skipping over digets. (Yukihiro Nakadaira)
Files:	    src/misc1.c


*** ../vim-7.2.292/src/misc1.c	2009-11-03 18:46:53.000000000 +0100
--- src/misc1.c	2009-11-11 17:27:38.000000000 +0100
***************
*** 1026,1037 ****
  		    int		c = 0;
  		    int		off = 0;
  
! 		    for (p = lead_flags; *p && *p != ':'; ++p)
  		    {
  			if (*p == COM_RIGHT || *p == COM_LEFT)
! 			    c = *p;
  			else if (VIM_ISDIGIT(*p) || *p == '-')
  			    off = getdigits(&p);
  		    }
  		    if (c == COM_RIGHT)    /* right adjusted leader */
  		    {
--- 1026,1039 ----
  		    int		c = 0;
  		    int		off = 0;
  
! 		    for (p = lead_flags; *p != NUL && *p != ':'; )
  		    {
  			if (*p == COM_RIGHT || *p == COM_LEFT)
! 			    c = *p++;
  			else if (VIM_ISDIGIT(*p) || *p == '-')
  			    off = getdigits(&p);
+ 			else
+ 			    ++p;
  		    }
  		    if (c == COM_RIGHT)    /* right adjusted leader */
  		    {
*** ../vim-7.2.292/src/version.c	2009-11-11 17:22:30.000000000 +0100
--- src/version.c	2009-11-11 17:29:24.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     293,
  /**/

-- 
SOLDIER: What?  Ridden on a horse?
ARTHUR:  Yes!
SOLDIER: You're using coconuts!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.294
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.294
Problem:    When using TEMPDIRS dir name could get too long.
Solution:   Overwrite tail instead of appending each time.  Use mkdtemp() when
	    available. (James Vega)
Files:	    src/auto/configure, src/config.h.in, src/configure.in, src/fileio.c


*** ../vim-7.2.293/src/auto/configure	2009-09-11 13:44:33.000000000 +0200
--- src/auto/configure	2009-11-17 12:03:15.000000000 +0100
***************
*** 14019,14027 ****
  
  
  
  for ac_func in bcmp fchdir fchown fseeko fsync ftello getcwd getpseudotty \
  	getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
! 	memset nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
--- 14019,14028 ----
  
  
  
+ 
  for ac_func in bcmp fchdir fchown fseeko fsync ftello getcwd getpseudotty \
  	getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
! 	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
*** ../vim-7.2.293/src/config.h.in	2009-05-21 23:25:38.000000000 +0200
--- src/config.h.in	2009-11-11 17:40:21.000000000 +0100
***************
*** 157,162 ****
--- 157,163 ----
  #undef HAVE_LSTAT
  #undef HAVE_MEMCMP
  #undef HAVE_MEMSET
+ #undef HAVE_MKDTEMP
  #undef HAVE_NANOSLEEP
  #undef HAVE_OPENDIR
  #undef HAVE_FLOAT_FUNCS
*** ../vim-7.2.293/src/configure.in	2009-09-11 13:44:33.000000000 +0200
--- src/configure.in	2009-11-11 17:40:21.000000000 +0100
***************
*** 2635,2641 ****
  dnl Check for functions in one big call, to reduce the size of configure
  AC_CHECK_FUNCS(bcmp fchdir fchown fseeko fsync ftello getcwd getpseudotty \
  	getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
! 	memset nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
--- 2635,2641 ----
  dnl Check for functions in one big call, to reduce the size of configure
  AC_CHECK_FUNCS(bcmp fchdir fchown fseeko fsync ftello getcwd getpseudotty \
  	getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
! 	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
*** ../vim-7.2.293/src/fileio.c	2009-09-11 17:24:01.000000000 +0200
--- src/fileio.c	2009-11-11 18:01:22.000000000 +0100
***************
*** 146,151 ****
--- 146,152 ----
  # endif
  #endif
  static int move_lines __ARGS((buf_T *frombuf, buf_T *tobuf));
+ static void vim_settempdir __ARGS((char_u *tempdir));
  #ifdef FEAT_AUTOCMD
  static char *e_auchangedbuf = N_("E812: Autocommands changed buffer or buffer name");
  #endif
***************
*** 6987,6992 ****
--- 6988,7020 ----
  #endif
  
  /*
+  * Directory "tempdir" was created.  Expand this name to a full path and put
+  * it in "vim_tempdir".  This avoids that using ":cd" would confuse us.
+  * "tempdir" must be no longer than MAXPATHL.
+  */
+     static void
+ vim_settempdir(tempdir)
+     char_u	*tempdir;
+ {
+     char_u	*buf;
+ 
+     buf = alloc((unsigned)MAXPATHL + 2);
+     if (buf != NULL)
+     {
+ 	if (vim_FullName(tempdir, buf, MAXPATHL, FALSE) == FAIL)
+ 	    STRCPY(buf, tempdir);
+ # ifdef __EMX__
+ 	if (vim_strchr(buf, '/') != NULL)
+ 	    STRCAT(buf, "/");
+ 	else
+ # endif
+ 	    add_pathsep(buf);
+ 	vim_tempdir = vim_strsave(buf);
+ 	vim_free(buf);
+     }
+ }
+ 
+ /*
   * vim_tempname(): Return a unique name that can be used for a temp file.
   *
   * The temp file is NOT created.
***************
*** 7007,7014 ****
  #ifdef TEMPDIRNAMES
      static char	*(tempdirs[]) = {TEMPDIRNAMES};
      int		i;
-     long	nr;
-     long	off;
  # ifndef EEXIST
      struct stat	st;
  # endif
--- 7035,7040 ----
***************
*** 7027,7032 ****
--- 7053,7064 ----
  	 */
  	for (i = 0; i < (int)(sizeof(tempdirs) / sizeof(char *)); ++i)
  	{
+ 	    size_t	itmplen;
+ # ifndef HAVE_MKDTEMP
+ 	    long	nr;
+ 	    long	off;
+ # endif
+ 
  	    /* expand $TMP, leave room for "/v1100000/999999999" */
  	    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);
  	    if (mch_isdir(itmp))		/* directory exists */
***************
*** 7040,7046 ****
--- 7072,7085 ----
  		else
  # endif
  		    add_pathsep(itmp);
+ 		itmplen = STRLEN(itmp);
  
+ # ifdef HAVE_MKDTEMP
+ 		/* Leave room for filename */
+ 		STRCAT(itmp, "vXXXXXX");
+ 		if (mkdtemp((char *)itmp) != NULL)
+ 		    vim_settempdir(itmp);
+ # else
  		/* Get an arbitrary number of up to 6 digits.  When it's
  		 * unlikely that it already exists it will be faster,
  		 * otherwise it doesn't matter.  The use of mkdir() avoids any
***************
*** 7052,7110 ****
  		for (off = 0; off < 10000L; ++off)
  		{
  		    int		r;
! #if defined(UNIX) || defined(VMS)
  		    mode_t	umask_save;
! #endif
  
! 		    sprintf((char *)itmp + STRLEN(itmp), "v%ld", nr + off);
! # ifndef EEXIST
  		    /* If mkdir() does not set errno to EEXIST, check for
  		     * existing file here.  There is a race condition then,
  		     * although it's fail-safe. */
  		    if (mch_stat((char *)itmp, &st) >= 0)
  			continue;
! # endif
! #if defined(UNIX) || defined(VMS)
  		    /* Make sure the umask doesn't remove the executable bit.
  		     * "repl" has been reported to use "177". */
  		    umask_save = umask(077);
! #endif
  		    r = vim_mkdir(itmp, 0700);
! #if defined(UNIX) || defined(VMS)
  		    (void)umask(umask_save);
! #endif
  		    if (r == 0)
  		    {
! 			char_u	*buf;
! 
! 			/* Directory was created, use this name.
! 			 * Expand to full path; When using the current
! 			 * directory a ":cd" would confuse us. */
! 			buf = alloc((unsigned)MAXPATHL + 1);
! 			if (buf != NULL)
! 			{
! 			    if (vim_FullName(itmp, buf, MAXPATHL, FALSE)
! 								      == FAIL)
! 				STRCPY(buf, itmp);
! # ifdef __EMX__
! 			    if (vim_strchr(buf, '/') != NULL)
! 				STRCAT(buf, "/");
! 			    else
! # endif
! 				add_pathsep(buf);
! 			    vim_tempdir = vim_strsave(buf);
! 			    vim_free(buf);
! 			}
  			break;
  		    }
! # ifdef EEXIST
  		    /* If the mkdir() didn't fail because the file/dir exists,
  		     * we probably can't create any dir here, try another
  		     * place. */
  		    if (errno != EEXIST)
! # endif
  			break;
  		}
  		if (vim_tempdir != NULL)
  		    break;
  	    }
--- 7091,7131 ----
  		for (off = 0; off < 10000L; ++off)
  		{
  		    int		r;
! #  if defined(UNIX) || defined(VMS)
  		    mode_t	umask_save;
! #  endif
  
! 		    sprintf((char *)itmp + itmplen, "v%ld", nr + off);
! #  ifndef EEXIST
  		    /* If mkdir() does not set errno to EEXIST, check for
  		     * existing file here.  There is a race condition then,
  		     * although it's fail-safe. */
  		    if (mch_stat((char *)itmp, &st) >= 0)
  			continue;
! #  endif
! #  if defined(UNIX) || defined(VMS)
  		    /* Make sure the umask doesn't remove the executable bit.
  		     * "repl" has been reported to use "177". */
  		    umask_save = umask(077);
! #  endif
  		    r = vim_mkdir(itmp, 0700);
! #  if defined(UNIX) || defined(VMS)
  		    (void)umask(umask_save);
! #  endif
  		    if (r == 0)
  		    {
! 			vim_settempdir(itmp);
  			break;
  		    }
! #  ifdef EEXIST
  		    /* If the mkdir() didn't fail because the file/dir exists,
  		     * we probably can't create any dir here, try another
  		     * place. */
  		    if (errno != EEXIST)
! #  endif
  			break;
  		}
+ # endif /* HAVE_MKDTEMP */
  		if (vim_tempdir != NULL)
  		    break;
  	    }
*** ../vim-7.2.293/src/version.c	2009-11-11 17:30:05.000000000 +0100
--- src/version.c	2009-11-17 11:54:49.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     294,
  /**/

-- 
ARTHUR:       Now stand aside worthy adversary.
BLACK KNIGHT: (Glancing at his shoulder) 'Tis but a scratch.
ARTHUR:       A scratch?  Your arm's off.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.295
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.295
Problem:    When using map() on a List the index is not known.
Solution:   Set v:key to the  index. (Hari Krishna Dara)
Files:	    runtime/doc/eval.txt, src/eval.c


*** ../vim-7.2.294/runtime/doc/eval.txt	2009-11-11 14:21:48.000000000 +0100
--- runtime/doc/eval.txt	2009-11-11 18:22:54.000000000 +0100
***************
*** 3802,3808 ****
  		Replace each item in {expr} with the result of evaluating
  		{string}.
  		Inside {string} |v:val| has the value of the current item.
! 		For a |Dictionary| |v:key| has the key of the current item.
  		Example: >
  			:call map(mylist, '"> " . v:val . " <"')
  <		This puts "> " before and " <" after each item in "mylist".
--- 3812,3819 ----
  		Replace each item in {expr} with the result of evaluating
  		{string}.
  		Inside {string} |v:val| has the value of the current item.
! 		For a |Dictionary| |v:key| has the key of the current item
! 		and for a |List| |v:key| has the index of the current item.
  		Example: >
  			:call map(mylist, '"> " . v:val . " <"')
  <		This puts "> " before and " <" after each item in "mylist".
*** ../vim-7.2.294/src/eval.c	2009-11-11 14:21:48.000000000 +0100
--- src/eval.c	2009-11-11 18:22:49.000000000 +0100
***************
*** 9928,9933 ****
--- 9928,9934 ----
      int		todo;
      char_u	*ermsg = map ? (char_u *)"map()" : (char_u *)"filter()";
      int		save_did_emsg;
+     int		index = 0;
  
      if (argvars[0].v_type == VAR_LIST)
      {
***************
*** 9961,9969 ****
  	save_did_emsg = did_emsg;
  	did_emsg = FALSE;
  
  	if (argvars[0].v_type == VAR_DICT)
  	{
- 	    prepare_vimvar(VV_KEY, &save_key);
  	    vimvars[VV_KEY].vv_type = VAR_STRING;
  
  	    ht = &d->dv_hashtab;
--- 9962,9970 ----
  	save_did_emsg = did_emsg;
  	did_emsg = FALSE;
  
+ 	prepare_vimvar(VV_KEY, &save_key);
  	if (argvars[0].v_type == VAR_DICT)
  	{
  	    vimvars[VV_KEY].vv_type = VAR_STRING;
  
  	    ht = &d->dv_hashtab;
***************
*** 9987,10010 ****
  		}
  	    }
  	    hash_unlock(ht);
- 
- 	    restore_vimvar(VV_KEY, &save_key);
  	}
  	else
  	{
  	    for (li = l->lv_first; li != NULL; li = nli)
  	    {
  		if (tv_check_lock(li->li_tv.v_lock, ermsg))
  		    break;
  		nli = li->li_next;
  		if (filter_map_one(&li->li_tv, expr, map, &rem) == FAIL
  								  || did_emsg)
  		    break;
  		if (!map && rem)
  		    listitem_remove(l, li);
  	    }
  	}
  
  	restore_vimvar(VV_VAL, &save_val);
  
  	did_emsg |= save_did_emsg;
--- 9988,10014 ----
  		}
  	    }
  	    hash_unlock(ht);
  	}
  	else
  	{
+ 	    vimvars[VV_KEY].vv_type = VAR_NUMBER;
+ 
  	    for (li = l->lv_first; li != NULL; li = nli)
  	    {
  		if (tv_check_lock(li->li_tv.v_lock, ermsg))
  		    break;
  		nli = li->li_next;
+ 		vimvars[VV_KEY].vv_nr = index;
  		if (filter_map_one(&li->li_tv, expr, map, &rem) == FAIL
  								  || did_emsg)
  		    break;
  		if (!map && rem)
  		    listitem_remove(l, li);
+ 		++index;
  	    }
  	}
  
+ 	restore_vimvar(VV_KEY, &save_key);
  	restore_vimvar(VV_VAL, &save_val);
  
  	did_emsg |= save_did_emsg;
*** ../vim-7.2.294/src/version.c	2009-11-17 12:08:48.000000000 +0100
--- src/version.c	2009-11-17 12:18:08.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     295,
  /**/

-- 
ARTHUR:       You are indeed brave Sir knight, but the fight is mine.
BLACK KNIGHT: Had enough?
ARTHUR:       You stupid bastard.  You havn't got any arms left.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.296
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.296
Problem:    Help message about startuptime is wrong. (Dominique Pelle)
Solution:   Remove the equal sign.
Files:	    src/main.c


*** ../vim-7.2.295/src/main.c	2009-11-11 14:21:48.000000000 +0100
--- src/main.c	2009-11-11 22:51:04.000000000 +0100
***************
*** 3151,3157 ****
      main_msg(_("--servername <name>\tSend to/become the Vim server <name>"));
  #endif
  #ifdef STARTUPTIME
!     main_msg(_("--startuptime=<file>\tWrite startup timing messages to <file>"));
  #endif
  #ifdef FEAT_VIMINFO
      main_msg(_("-i <viminfo>\t\tUse <viminfo> instead of .viminfo"));
--- 3151,3157 ----
      main_msg(_("--servername <name>\tSend to/become the Vim server <name>"));
  #endif
  #ifdef STARTUPTIME
!     main_msg(_("--startuptime <file>\tWrite startup timing messages to <file>"));
  #endif
  #ifdef FEAT_VIMINFO
      main_msg(_("-i <viminfo>\t\tUse <viminfo> instead of .viminfo"));
*** ../vim-7.2.295/src/version.c	2009-11-17 12:20:30.000000000 +0100
--- src/version.c	2009-11-17 12:30:29.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     296,
  /**/

-- 
BLACK KNIGHT: I'm invincible!
ARTHUR:       You're a looney.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.297
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.297
Problem:    Reading freed memory when writing ":reg" output to a register.
	    (Dominique Pelle)
Solution:   Skip the register being written to.
Files:	    src/ops.c


*** ../vim-7.2.296/src/ops.c	2009-11-11 17:22:30.000000000 +0100
--- src/ops.c	2009-11-11 19:30:47.000000000 +0100
***************
*** 3991,3996 ****
--- 3991,4004 ----
  	}
  	else
  	    yb = &(y_regs[i]);
+ 
+ #ifdef FEAT_EVAL
+ 	if (name == MB_TOLOWER(redir_reg)
+ 		|| (redir_reg == '"' && yb == y_previous))
+ 	    continue;	    /* do not list register being written to, the
+ 			     * pointer can be freed */
+ #endif
+ 
  	if (yb->y_array != NULL)
  	{
  	    msg_putchar('\n');
***************
*** 6090,6096 ****
      long	maxlen;
  #endif
  
!     if (y_ptr->y_array == NULL)		/* NULL means emtpy register */
  	y_ptr->y_size = 0;
  
      /*
--- 6098,6104 ----
      long	maxlen;
  #endif
  
!     if (y_ptr->y_array == NULL)		/* NULL means empty register */
  	y_ptr->y_size = 0;
  
      /*
*** ../vim-7.2.296/src/version.c	2009-11-17 12:31:30.000000000 +0100
--- src/version.c	2009-11-17 12:42:28.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     297,
  /**/

-- 
"Beware of bugs in the above code; I have only proved
it correct, not tried it." -- Donald Knuth

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.298
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.298
Problem:    ":vimgrep" crashes when there is an autocommand that sets a
	    window-local variable.
Solution:   Initialize the w: hashtab for re-use. (Yukihiro Nakadaira)
Files:	    src/fileio.c


*** ../vim-7.2.297/src/fileio.c	2009-11-17 12:08:48.000000000 +0100
--- src/fileio.c	2009-11-17 13:22:06.000000000 +0100
***************
*** 8597,8602 ****
--- 8605,8611 ----
  	    curwin = firstwin;
  # ifdef FEAT_EVAL
  	vars_clear(&aucmd_win->w_vars.dv_hashtab);  /* free all w: variables */
+ 	hash_init(&aucmd_win->w_vars.dv_hashtab);   /* re-use the hashtab */
  # endif
  #else
  	curwin = aco->save_curwin;
*** ../vim-7.2.297/src/version.c	2009-11-17 12:43:19.000000000 +0100
--- src/version.c	2009-11-17 14:56:19.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     298,
  /**/

-- 
Eye have a spelling checker, it came with my PC;
It plainly marks four my revue mistakes I cannot sea.
I've run this poem threw it, I'm sure your please to no,
It's letter perfect in it's weigh, my checker tolled me sew!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.299
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.299
Problem:    Crash when comment middle is longer than start.
Solution:   Fix size computation. (Lech Lorens)
Files:	    src/misc1.c


*** ../vim-7.2.298/src/misc1.c	2009-11-11 17:30:05.000000000 +0100
--- src/misc1.c	2009-11-17 15:59:28.000000000 +0100
***************
*** 1121,1127 ****
  			    if (i != lead_repl_len)
  			    {
  				mch_memmove(p + lead_repl_len, p + i,
! 				       (size_t)(lead_len - i - (leader - p)));
  				lead_len += lead_repl_len - i;
  			    }
  			}
--- 1121,1127 ----
  			    if (i != lead_repl_len)
  			    {
  				mch_memmove(p + lead_repl_len, p + i,
! 				       (size_t)(lead_len - i - (p - leader)));
  				lead_len += lead_repl_len - i;
  			    }
  			}
*** ../vim-7.2.298/src/version.c	2009-11-17 14:57:19.000000000 +0100
--- src/version.c	2009-11-17 16:01:07.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     299,
  /**/

-- 
BLACK KNIGHT: The Black Knight always triumphs. Have at you!
   ARTHUR takes his last leg off.  The BLACK KNIGHT's body lands upright.
BLACK KNIGHT: All right, we'll call it a draw.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.300
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.300
Problem:    Vim doesn't close file descriptors when forking and executing
	    another command, e.g., ":shell".
Solution:   Use FD_CLOEXEC when available. (James Vega)
Files:	    src/auto/configure, src/config.h.in, src/configure.in,
	    src/ex_cmdds2.c, src/fileio.c, src/memfile.c, src/memline.c


*** ../vim-7.2.299/src/auto/configure	2009-11-17 12:08:48.000000000 +0100
--- src/auto/configure	2009-11-17 13:09:03.000000000 +0100
***************
*** 15174,15179 ****
--- 15174,15231 ----
  $as_echo "yes" >&6; }
  fi
  
+ { $as_echo "$as_me:$LINENO: checking for FD_CLOEXEC" >&5
+ $as_echo_n "checking for FD_CLOEXEC... " >&6; }
+ cat >conftest.$ac_ext <<_ACEOF
+ /* confdefs.h.  */
+ _ACEOF
+ cat confdefs.h >>conftest.$ac_ext
+ cat >>conftest.$ac_ext <<_ACEOF
+ /* end confdefs.h.  */
+ #if HAVE_FCNTL_H
+ # include <fcntl.h>
+ #endif
+ int
+ main ()
+ {
+ 	int flag = FD_CLOEXEC;
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext
+ if { (ac_try="$ac_compile"
+ case "(($ac_try" in
+   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+   *) ac_try_echo=$ac_try;;
+ esac
+ eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+ $as_echo "$ac_try_echo") >&5
+   (eval "$ac_compile") 2>conftest.er1
+   ac_status=$?
+   grep -v '^ *+' conftest.er1 >conftest.err
+   rm -f conftest.er1
+   cat conftest.err >&5
+   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } && {
+ 	 test -z "$ac_c_werror_flag" ||
+ 	 test ! -s conftest.err
+        } && test -s conftest.$ac_objext; then
+   { $as_echo "$as_me:$LINENO: result: yes" >&5
+ $as_echo "yes" >&6; }; cat >>confdefs.h <<\_ACEOF
+ #define HAVE_FD_CLOEXEC 1
+ _ACEOF
+ 
+ else
+   $as_echo "$as_me: failed program was:" >&5
+ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+ 	{ $as_echo "$as_me:$LINENO: result: not usable" >&5
+ $as_echo "not usable" >&6; }
+ fi
+ 
+ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ 
  { $as_echo "$as_me:$LINENO: checking for rename" >&5
  $as_echo_n "checking for rename... " >&6; }
  cat >conftest.$ac_ext <<_ACEOF
*** ../vim-7.2.299/src/config.h.in	2009-11-17 12:08:48.000000000 +0100
--- src/config.h.in	2009-11-17 13:01:36.000000000 +0100
***************
*** 388,390 ****
--- 388,393 ----
  
  /* Define if you want XSMP interaction as well as vanilla swapfile safety */
  #undef USE_XSMP_INTERACT
+ 
+ /* Define if fcntl()'s F_SETFD command knows about FD_CLOEXEC */
+ #undef HAVE_FD_CLOEXEC
*** ../vim-7.2.299/src/configure.in	2009-11-17 12:08:48.000000000 +0100
--- src/configure.in	2009-11-17 13:01:36.000000000 +0100
***************
*** 2855,2860 ****
--- 2855,2870 ----
    AC_MSG_RESULT(yes)
  fi
  
+ dnl make sure the FD_CLOEXEC flag for fcntl()'s F_SETFD command is known
+ AC_MSG_CHECKING(for FD_CLOEXEC)
+ AC_TRY_COMPILE(
+ [#if HAVE_FCNTL_H
+ # include <fcntl.h>
+ #endif],
+ [	int flag = FD_CLOEXEC;],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FD_CLOEXEC),
+ 	AC_MSG_RESULT(not usable))
+ 
  dnl rename needs to be checked separately to work on Nextstep with cc
  AC_MSG_CHECKING(for rename)
  AC_TRY_LINK([#include <stdio.h>], [rename("this", "that")],
*** ../vim-7.2.299/src/fileio.c	2009-11-17 14:57:19.000000000 +0100
--- src/fileio.c	2009-11-17 13:22:06.000000000 +0100
***************
*** 2254,2259 ****
--- 2254,2267 ----
  
      if (!read_buffer && !read_stdin)
  	close(fd);				/* errors are ignored */
+ #ifdef HAVE_FD_CLOEXEC
+     else
+     {
+ 	int fdflags = fcntl(fd, F_GETFD);
+ 	if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
+ 	    fcntl(fd, F_SETFD, fdflags | FD_CLOEXEC);
+     }
+ #endif
      vim_free(buffer);
  
  #ifdef HAVE_DUP
*** ../vim-7.2.299/src/memfile.c	2008-07-13 19:39:39.000000000 +0200
--- src/memfile.c	2009-11-17 13:22:15.000000000 +0100
***************
*** 1343,1348 ****
--- 1343,1353 ----
      }
      else
      {
+ #ifdef HAVE_FD_CLOEXEC
+ 	int fdflags = fcntl(mfp->mf_fd, F_GETFD);
+ 	if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
+ 	    fcntl(mfp->mf_fd, F_SETFD, fdflags | FD_CLOEXEC);
+ #endif
  #ifdef HAVE_SELINUX
  	mch_copy_sec(fname, mfp->mf_fname);
  #endif
*** ../vim-7.2.299/src/memline.c	2009-11-03 15:32:58.000000000 +0100
--- src/memline.c	2009-11-17 13:21:40.000000000 +0100
***************
*** 382,388 ****
      dp->db_index[0] = --dp->db_txt_start;	/* at end of block */
      dp->db_free -= 1 + INDEX_SIZE;
      dp->db_line_count = 1;
!     *((char_u *)dp + dp->db_txt_start) = NUL;	/* emtpy line */
  
      return OK;
  
--- 382,388 ----
      dp->db_index[0] = --dp->db_txt_start;	/* at end of block */
      dp->db_free -= 1 + INDEX_SIZE;
      dp->db_line_count = 1;
!     *((char_u *)dp + dp->db_txt_start) = NUL;	/* empty line */
  
      return OK;
  
***************
*** 490,495 ****
--- 490,502 ----
  	    EMSG(_("E301: Oops, lost the swap file!!!"));
  	    return;
  	}
+ #ifdef HAVE_FD_CLOEXEC
+ 	{
+ 	    int fdflags = fcntl(mfp->mf_fd, F_GETFD);
+ 	    if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
+ 		fcntl(mfp->mf_fd, F_SETFD, fdflags | FD_CLOEXEC);
+ 	}
+ #endif
      }
      if (!success)
  	EMSG(_("E302: Could not rename swap file"));
*** ../vim-7.2.299/src/version.c	2009-11-17 16:08:12.000000000 +0100
--- src/version.c	2009-11-17 17:09:43.000000000 +0100
***************
*** 683,684 ****
--- 683,686 ----
  {   /* Add new patch number below this line */
+ /**/
+     300,
  /**/

-- 
            |

Ceci n'est pas une pipe.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
