To: vim-dev@vim.org
Subject: Patch 7.2.101 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.101 (extra)
Problem:    MSVC version not recognized.
Solution:   Add the version number to the list.  (Zhong Zhang)
Files:	    src/Make_mvc.mak


*** ../vim-7.2.100/src/Make_mvc.mak	Thu Jul 24 20:49:58 2008
--- src/Make_mvc.mak	Wed Feb  4 18:32:47 2009
***************
*** 354,359 ****
--- 354,362 ----
  !if "$(_NMAKE_VER)" == "9.00.21022.08"
  MSVCVER = 9.0
  !endif
+ !if "$(_NMAKE_VER)" == "9.00.30729.01"
+ MSVCVER = 9.0
+ !endif
  !endif
  
  # Abort bulding VIM if version of VC is unrecognised.
*** ../vim-7.2.100/src/version.c	Wed Feb  4 17:49:46 2009
--- src/version.c	Wed Feb  4 18:34:12 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     101,
  /**/

-- 
Light travels faster than sound.  This is why some people
appear bright until you hear them speak

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.102
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.102 (after 7.2.100)
Problem:    When 'encoding' is "utf-8" a BOM at the start of a Vim script is
	    not removed. (Tony Mechelynck)
Solution:   When no conversion is taking place make a copy of the line without
	    the BOM.
Files:	    src/ex_cmds2.c


*** ../vim-7.2.101/src/ex_cmds2.c	Wed Feb  4 17:49:46 2009
--- src/ex_cmds2.c	Thu Feb  5 20:41:56 2009
***************
*** 3013,3018 ****
--- 3013,3020 ----
  	/* Found BOM; setup conversion, skip over BOM and recode the line. */
  	convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
  	p = string_convert(&cookie.conv, firstline + 3, NULL);
+ 	if (p == NULL)
+ 	    p = vim_strsave(firstline + 3);
  	if (p != NULL)
  	{
  	    vim_free(firstline);
*** ../vim-7.2.101/src/version.c	Wed Feb  4 18:34:54 2009
--- src/version.c	Thu Feb  5 20:44:55 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     102,
  /**/

-- 
CVS sux, men don't like commitment

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.103
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.103
Problem:    When 'bomb' is changed the window title is updated to show/hide a
	    "+", but the tab page label isn't. (Patrick Texier)
Solution:   Set "redraw_tabline" in most places where "need_maketitle" is set.
	    (partly by Lech Lorens)
Files:	    src/option.c


*** ../vim-7.2.102/src/option.c	Wed Feb  4 17:27:50 2009
--- src/option.c	Wed Feb  4 17:40:02 2009
***************
*** 5268,5273 ****
--- 5268,5288 ----
  }
  #endif
  
+ #ifdef FEAT_TITLE
+ static void redraw_titles __ARGS((void));
+ 
+ /*
+  * Redraw the window title and/or tab page text later.
+  */
+ static void redraw_titles()
+ {
+     need_maketitle = TRUE;
+ # ifdef FEAT_WINDOWS
+     redraw_tabline = TRUE;
+ # endif
+ }
+ #endif
+ 
  /*
   * Set a string option to a new value (without checking the effect).
   * The string is copied into allocated memory.
***************
*** 5672,5678 ****
  	    {
  # ifdef FEAT_TITLE
  		/* May show a "+" in the title now. */
! 		need_maketitle = TRUE;
  # endif
  		/* Add 'fileencoding' to the swap file. */
  		ml_setflags(curbuf);
--- 5687,5693 ----
  	    {
  # ifdef FEAT_TITLE
  		/* May show a "+" in the title now. */
! 		redraw_titles();
  # endif
  		/* Add 'fileencoding' to the swap file. */
  		ml_setflags(curbuf);
***************
*** 5691,5697 ****
  	    {
  		errmsg = mb_init();
  # ifdef FEAT_TITLE
! 		need_maketitle = TRUE;
  # endif
  	    }
  	}
--- 5706,5712 ----
  	    {
  		errmsg = mb_init();
  # ifdef FEAT_TITLE
! 		redraw_titles();
  # endif
  	    }
  	}
***************
*** 5800,5806 ****
  	    else
  		curbuf->b_p_tx = FALSE;
  #ifdef FEAT_TITLE
! 	    need_maketitle = TRUE;
  #endif
  	    /* update flag in swap file */
  	    ml_setflags(curbuf);
--- 5815,5821 ----
  	    else
  		curbuf->b_p_tx = FALSE;
  #ifdef FEAT_TITLE
! 	    redraw_titles();
  #endif
  	    /* update flag in swap file */
  	    ml_setflags(curbuf);
***************
*** 7127,7148 ****
  	    curbuf->b_did_warn = FALSE;
  
  #ifdef FEAT_TITLE
! 	need_maketitle = TRUE;
  #endif
      }
  
  #ifdef FEAT_TITLE
      /* when 'modifiable' is changed, redraw the window title */
      else if ((int *)varp == &curbuf->b_p_ma)
! 	need_maketitle = TRUE;
      /* when 'endofline' is changed, redraw the window title */
      else if ((int *)varp == &curbuf->b_p_eol)
! 	need_maketitle = TRUE;
! #ifdef FEAT_MBYTE
!     /* when 'bomb' is changed, redraw the window title */
      else if ((int *)varp == &curbuf->b_p_bomb)
! 	need_maketitle = TRUE;
! #endif
  #endif
  
      /* when 'bin' is set also set some other options */
--- 7142,7169 ----
  	    curbuf->b_did_warn = FALSE;
  
  #ifdef FEAT_TITLE
! 	redraw_titles();
  #endif
      }
  
  #ifdef FEAT_TITLE
      /* when 'modifiable' is changed, redraw the window title */
      else if ((int *)varp == &curbuf->b_p_ma)
!     {
! 	redraw_titles();
!     }
      /* when 'endofline' is changed, redraw the window title */
      else if ((int *)varp == &curbuf->b_p_eol)
!     {
! 	redraw_titles();
!     }
! # ifdef FEAT_MBYTE
!     /* when 'bomb' is changed, redraw the window title and tab page text */
      else if ((int *)varp == &curbuf->b_p_bomb)
!     {
! 	redraw_titles();
!     }
! # endif
  #endif
  
      /* when 'bin' is set also set some other options */
***************
*** 7150,7156 ****
      {
  	set_options_bin(old_value, curbuf->b_p_bin, opt_flags);
  #ifdef FEAT_TITLE
! 	need_maketitle = TRUE;
  #endif
      }
  
--- 7171,7177 ----
      {
  	set_options_bin(old_value, curbuf->b_p_bin, opt_flags);
  #ifdef FEAT_TITLE
! 	redraw_titles();
  #endif
      }
  
***************
*** 7301,7307 ****
  	if (!value)
  	    save_file_ff(curbuf);	/* Buffer is unchanged */
  #ifdef FEAT_TITLE
! 	need_maketitle = TRUE;
  #endif
  #ifdef FEAT_AUTOCMD
  	modified_was_set = value;
--- 7322,7328 ----
  	if (!value)
  	    save_file_ff(curbuf);	/* Buffer is unchanged */
  #ifdef FEAT_TITLE
! 	redraw_titles();
  #endif
  #ifdef FEAT_AUTOCMD
  	modified_was_set = value;
***************
*** 7736,7742 ****
  	newFoldLevel();
      }
  
!     /* 'foldminlevel' */
      else if (pp == &curwin->w_p_fml)
      {
  	foldUpdateAll(curwin);
--- 7757,7763 ----
  	newFoldLevel();
      }
  
!     /* 'foldminlines' */
      else if (pp == &curwin->w_p_fml)
      {
  	foldUpdateAll(curwin);
*** ../vim-7.2.102/src/version.c	Thu Feb  5 20:47:14 2009
--- src/version.c	Wed Feb 11 11:32:20 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     103,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
73. You give your dog used motherboards instead of bones

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.104
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.104
Problem:    When using ":saveas bar.c" the tab label isn't updated right away.
Solution:   Set redraw_tabline. (Francois Ingelrest)
Files:      src/ex_cmds.c


*** ../vim-7.2.103/src/ex_cmds.c	Wed Feb  4 13:13:42 2009
--- src/ex_cmds.c	Wed Feb 11 15:58:06 2009
***************
*** 2707,2713 ****
--- 2707,2718 ----
  	if (eap->cmdidx == CMD_saveas)
  	{
  	    if (retval == OK)
+ 	    {
  		curbuf->b_p_ro = FALSE;
+ #ifdef FEAT_WINDOWS
+ 		redraw_tabline = TRUE;
+ #endif
+ 	    }
  	    /* Change directories when the 'acd' option is set. */
  	    DO_AUTOCHDIR
  	}
*** ../vim-7.2.103/src/version.c	Wed Feb 11 11:34:24 2009
--- src/version.c	Wed Feb 11 16:02:19 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     104,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
75. You start wondering whether you could actually upgrade your brain
    with a Pentium Pro microprocessor 80.  The upgrade works just fine.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.105
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.105
Problem:    Modeline setting for 'foldmethod' overrules diff options. (Ingo
	    Karkat)
Solution:   Don't set 'foldmethod' and 'wrap' from a modeline when 'diff' is
	    on.
Files:	    src/option.c


*** ../vim-7.2.104/src/option.c	Wed Feb 11 11:34:24 2009
--- src/option.c	Wed Feb 11 16:29:56 2009
***************
*** 4119,4129 ****
  					   && options[opt_idx].var == VAR_WIN)
  		goto skip;
  
! 	    /* Disallow changing some options from modelines */
! 	    if ((opt_flags & OPT_MODELINE) && (flags & P_SECURE))
  	    {
! 		errmsg = (char_u *)_("E520: Not allowed in a modeline");
! 		goto skip;
  	    }
  
  #ifdef HAVE_SANDBOX
--- 4119,4139 ----
  					   && options[opt_idx].var == VAR_WIN)
  		goto skip;
  
! 	    /* Disallow changing some options from modelines. */
! 	    if (opt_flags & OPT_MODELINE)
  	    {
! 		if (flags & P_SECURE)
! 		{
! 		    errmsg = (char_u *)_("E520: Not allowed in a modeline");
! 		    goto skip;
! 		}
! 		/* In diff mode some options are overruled.  This avoids that
! 		 * 'foldmethod' becomes "marker" instead of "diff" and that
! 		 * "wrap" gets set. */
! 		if (curwin->w_p_diff
! 			&& (options[opt_idx].indir == PV_FDM
! 			    || options[opt_idx].indir == PV_WRAP))
! 		    goto skip;
  	    }
  
  #ifdef HAVE_SANDBOX
*** ../vim-7.2.104/src/version.c	Wed Feb 11 16:02:29 2009
--- src/version.c	Wed Feb 11 16:40:35 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     105,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
76. Your ISP regards you as a business partner rather than as a customer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.106
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.106
Problem:    Endless loop when using "]s" in HTML when there are no
	    misspellings. (Ingo Karkat)
Solution:   Break the search loop.  Also fix pointer alignment for systems
	    with pointers larger than int.
Files:	    src/spell.c


*** ../vim-7.2.105/src/spell.c	Tue Dec  9 22:34:02 2008
--- src/spell.c	Wed Feb 11 17:54:50 2009
***************
*** 2376,2382 ****
  
  	    /* If we are back at the starting line and there is no match then
  	     * give up. */
! 	    if (lnum == wp->w_cursor.lnum && !found_one)
  		break;
  
  	    /* Skip the characters at the start of the next line that were
--- 2376,2382 ----
  
  	    /* If we are back at the starting line and there is no match then
  	     * give up. */
! 	    if (lnum == wp->w_cursor.lnum && (!found_one || wrapped))
  		break;
  
  	    /* Skip the characters at the start of the next line that were
***************
*** 4956,4968 ****
   * Structure that is used to store the items in the word tree.  This avoids
   * the need to keep track of each allocated thing, everything is freed all at
   * once after ":mkspell" is done.
   */
  #define  SBLOCKSIZE 16000	/* size of sb_data */
  typedef struct sblock_S sblock_T;
  struct sblock_S
  {
-     sblock_T	*sb_next;	/* next block in list */
      int		sb_used;	/* nr of bytes already in use */
      char_u	sb_data[1];	/* data, actually longer */
  };
  
--- 4956,4971 ----
   * Structure that is used to store the items in the word tree.  This avoids
   * the need to keep track of each allocated thing, everything is freed all at
   * once after ":mkspell" is done.
+  * Note: "sb_next" must be just before "sb_data" to make sure the alignment of
+  * "sb_data" is correct for systems where pointers must be aligned on
+  * pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).
   */
  #define  SBLOCKSIZE 16000	/* size of sb_data */
  typedef struct sblock_S sblock_T;
  struct sblock_S
  {
      int		sb_used;	/* nr of bytes already in use */
+     sblock_T	*sb_next;	/* next block in list */
      char_u	sb_data[1];	/* data, actually longer */
  };
  
***************
*** 15011,15017 ****
  
  	case 0:
  	    /*
! 	     * Lenghts are equal, thus changes must result in same length: An
  	     * insert is only possible in combination with a delete.
  	     * 1: check if for identical strings
  	     */
--- 15014,15020 ----
  
  	case 0:
  	    /*
! 	     * Lengths are equal, thus changes must result in same length: An
  	     * insert is only possible in combination with a delete.
  	     * 1: check if for identical strings
  	     */
*** ../vim-7.2.105/src/version.c	Wed Feb 11 16:45:56 2009
--- src/version.c	Wed Feb 11 17:56:34 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     106,
  /**/

-- 
If bankers can count, how come they have eight windows and
only four tellers?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.107
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.107
Problem:    When using a GUI dialog and ":echo" commands the messages are
	    deleted after the dialog. (Vicent Birebent)
Solution:   Don't call msg_end_prompt() since there was no prompt.
Files:	    src/message.c


*** ../vim-7.2.106/src/message.c	Tue Jan 13 16:37:31 2009
--- src/message.c	Wed Feb 11 18:38:14 2009
***************
*** 3309,3315 ****
      {
  	c = gui_mch_dialog(type, title, message, buttons, dfltbutton,
  								   textfield);
! 	msg_end_prompt();
  
  	/* Flush output to avoid that further messages and redrawing is done
  	 * in the wrong order. */
--- 3309,3318 ----
      {
  	c = gui_mch_dialog(type, title, message, buttons, dfltbutton,
  								   textfield);
! 	/* avoid a hit-enter prompt without clearing the cmdline */
! 	need_wait_return = FALSE;
! 	emsg_on_display = FALSE;
! 	cmdline_row = msg_row;
  
  	/* Flush output to avoid that further messages and redrawing is done
  	 * in the wrong order. */
*** ../vim-7.2.106/src/version.c	Wed Feb 11 17:57:43 2009
--- src/version.c	Wed Feb 11 18:46:12 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     107,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
79. All of your most erotic dreams have a scrollbar at the right side.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.108
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.108 (after 7.2.105)
Problem:    Can't build without the diff feature.
Solution:   Add #ifdef.
Files:	    src/option.c


*** ../vim-7.2.107/src/option.c	Wed Feb 11 16:45:56 2009
--- src/option.c	Wed Feb 11 22:21:16 2009
***************
*** 4127,4132 ****
--- 4127,4133 ----
  		    errmsg = (char_u *)_("E520: Not allowed in a modeline");
  		    goto skip;
  		}
+ #ifdef FEAT_DIFF
  		/* In diff mode some options are overruled.  This avoids that
  		 * 'foldmethod' becomes "marker" instead of "diff" and that
  		 * "wrap" gets set. */
***************
*** 4134,4139 ****
--- 4135,4141 ----
  			&& (options[opt_idx].indir == PV_FDM
  			    || options[opt_idx].indir == PV_WRAP))
  		    goto skip;
+ #endif
  	    }
  
  #ifdef HAVE_SANDBOX
*** ../vim-7.2.107/src/version.c	Wed Feb 11 18:46:48 2009
--- src/version.c	Wed Feb 11 22:46:40 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     108,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
80. At parties, you introduce your spouse as your "service provider."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.109
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.109
Problem:    'langmap' does not work for multi-byte characters.
Solution:   Add a list of mapped multi-byte characters. (based on work by
            Konstantin Korikov, Agathoklis Hatzimanikas)
Files:      runtime/doc/options.txt, src/edit.c, src/getchar.c, src/macros.h,
            src/normal.c, src/option.c, src/proto/option.pro, src/window.c
    

*** ../vim-7.2.108/runtime/doc/options.txt	Fri Nov 28 10:59:57 2008
--- runtime/doc/options.txt	Wed Feb 11 18:59:34 2009
***************
*** 4175,4183 ****
  	be able to execute Normal mode commands.
  	This is the opposite of the 'keymap' option, where characters are
  	mapped in Insert mode.
- 	This only works for 8-bit characters.  The value of 'langmap' may be
- 	specified with multi-byte characters (e.g., UTF-8), but only the lower
- 	8 bits of each character will be used.
  
  	Example (for Greek, in UTF-8):				*greek*  >
  	    :set langmap=ΑA,ΒB,ΨC,ΔD,ΕE,ΦF,ΓG,ΗH,ΙI,ΞJ,ΚK,ΛL,ΜM,ΝN,ΟO,ΠP,QQ,ΡR,ΣS,ΤT,ΘU,ΩV,WW,ΧX,ΥY,ΖZ,αa,βb,ψc,δd,εe,φf,γg,ηh,ιi,ξj,κk,λl,μm,νn,οo,πp,qq,ρr,σs,τt,θu,ωv,ςw,χx,υy,ζz
--- 4188,4193 ----
*** ../vim-7.2.108/src/edit.c	Wed Feb  4 11:19:40 2009
--- src/edit.c	Sat Feb 21 19:54:03 2009
***************
*** 7703,7711 ****
       */
      ++no_mapping;
      regname = plain_vgetc();
- #ifdef FEAT_LANGMAP
      LANGMAP_ADJUST(regname, TRUE);
- #endif
      if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)
      {
  	/* Get a third key for literal register insertion */
--- 7703,7709 ----
***************
*** 7714,7722 ****
  	add_to_showcmd_c(literally);
  #endif
  	regname = plain_vgetc();
- #ifdef FEAT_LANGMAP
  	LANGMAP_ADJUST(regname, TRUE);
- #endif
      }
      --no_mapping;
  
--- 7712,7718 ----
*** ../vim-7.2.108/src/macros.h	Wed Aug 15 20:41:07 2007
--- src/macros.h	Sat Feb 21 19:55:38 2009
***************
*** 127,141 ****
  #ifdef FEAT_LANGMAP
  /*
   * Adjust chars in a language according to 'langmap' option.
!  * NOTE that there is NO overhead if 'langmap' is not set; but even
!  * when set we only have to do 2 ifs and an array lookup.
   * Don't apply 'langmap' if the character comes from the Stuff buffer.
   * The do-while is just to ignore a ';' after the macro.
   */
! # define LANGMAP_ADJUST(c, condition) do { \
! 	if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0 && (c) < 256) \
! 	    c = langmap_mapchar[c]; \
      } while (0)
  #endif
  
  /*
--- 127,157 ----
  #ifdef FEAT_LANGMAP
  /*
   * Adjust chars in a language according to 'langmap' option.
!  * NOTE that there is no noticeable overhead if 'langmap' is not set.
!  * When set the overhead for characters < 256 is small.
   * Don't apply 'langmap' if the character comes from the Stuff buffer.
   * The do-while is just to ignore a ';' after the macro.
   */
! # ifdef FEAT_MBYTE
! #  define LANGMAP_ADJUST(c, condition) \
!     do { \
!         if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0) \
! 	{ \
! 	    if ((c) < 256) \
! 		c = langmap_mapchar[c]; \
! 	    else \
! 		c = langmap_adjust_mb(c); \
! 	} \
      } while (0)
+ # else
+ #  define LANGMAP_ADJUST(c, condition) \
+     do { \
+         if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0 && (c) < 256) \
+             c = langmap_mapchar[c]; \
+     } while (0)
+ # endif
+ #else
+ # define LANGMAP_ADJUST(c, condition) /* nop */
  #endif
  
  /*
*** ../vim-7.2.108/src/normal.c	Wed Feb  4 11:45:28 2009
--- src/normal.c	Sat Feb 21 19:55:17 2009
***************
*** 651,660 ****
       * Get the command character from the user.
       */
      c = safe_vgetc();
- 
- #ifdef FEAT_LANGMAP
      LANGMAP_ADJUST(c, TRUE);
- #endif
  
  #ifdef FEAT_VISUAL
      /*
--- 651,657 ----
***************
*** 744,752 ****
  	    }
  	    ++no_zero_mapping;		/* don't map zero here */
  	    c = plain_vgetc();
- #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(c, TRUE);
- #endif
  	    --no_zero_mapping;
  	    if (ctrl_w)
  	    {
--- 741,747 ----
***************
*** 769,777 ****
  	    ++no_mapping;
  	    ++allow_keys;		/* no mapping for nchar, but keys */
  	    c = plain_vgetc();		/* get next character */
- #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(c, TRUE);
- #endif
  	    --no_mapping;
  	    --allow_keys;
  #ifdef FEAT_CMDL_INFO
--- 764,770 ----
***************
*** 959,967 ****
  	     * "gr", "g'" and "g`".
  	     */
  	    ca.nchar = plain_vgetc();
- #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(ca.nchar, TRUE);
- #endif
  #ifdef FEAT_CMDL_INFO
  	    need_flushbuf |= add_to_showcmd(ca.nchar);
  #endif
--- 952,958 ----
***************
*** 1062,1071 ****
  		}
  #endif
  
- #ifdef FEAT_LANGMAP
  		/* adjust chars > 127, except after "tTfFr" commands */
  		LANGMAP_ADJUST(*cp, !lang);
- #endif
  #ifdef FEAT_RIGHTLEFT
  		/* adjust Hebrew mapped char */
  		if (p_hkmap && lang && KeyTyped)
--- 1053,1060 ----
***************
*** 4630,4638 ****
  	    ++no_mapping;
  	    ++allow_keys;   /* no mapping for nchar, but allow key codes */
  	    nchar = plain_vgetc();
- #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(nchar, TRUE);
- #endif
  	    --no_mapping;
  	    --allow_keys;
  #ifdef FEAT_CMDL_INFO
--- 4619,4625 ----
***************
*** 4988,4996 ****
  		++no_mapping;
  		++allow_keys;   /* no mapping for nchar, but allow key codes */
  		nchar = plain_vgetc();
- #ifdef FEAT_LANGMAP
  		LANGMAP_ADJUST(nchar, TRUE);
- #endif
  		--no_mapping;
  		--allow_keys;
  #ifdef FEAT_CMDL_INFO
--- 4975,4981 ----
*** ../vim-7.2.108/src/option.c	Wed Feb 11 22:47:32 2009
--- src/option.c	Sat Feb 21 19:46:13 2009
***************
*** 10153,10177 ****
  
  #ifdef FEAT_LANGMAP
  /*
!  * Any character has an equivalent character.  This is used for keyboards that
!  * have a special language mode that sends characters above 128 (although
!  * other characters can be translated too).
   */
  
  /*
!  * char_u langmap_mapchar[256];
!  * Normally maps each of the 128 upper chars to an <128 ascii char; used to
!  * "translate" native lang chars in normal mode or some cases of
!  * insert mode without having to tediously switch lang mode back&forth.
   */
  
      static void
  langmap_init()
  {
      int i;
  
!     for (i = 0; i < 256; i++)		/* we init with a-one-to one map */
! 	langmap_mapchar[i] = i;
  }
  
  /*
--- 10153,10262 ----
  
  #ifdef FEAT_LANGMAP
  /*
!  * Any character has an equivalent 'langmap' character.  This is used for
!  * keyboards that have a special language mode that sends characters above
!  * 128 (although other characters can be translated too).  The "to" field is a
!  * Vim command character.  This avoids having to switch the keyboard back to
!  * ASCII mode when leaving Insert mode.
!  *
!  * langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim
!  * commands.
!  * When FEAT_MBYTE is defined langmap_mapga.ga_data is a sorted table of
!  * langmap_entry_T.  This does the same as langmap_mapchar[] for characters >=
!  * 256.
!  */
! # ifdef FEAT_MBYTE
! /*
!  * With multi-byte support use growarray for 'langmap' chars >= 256
   */
+ typedef struct
+ {
+     int	    from;
+     int     to;
+ } langmap_entry_T;
+ 
+ static garray_T langmap_mapga;
+ static void langmap_set_entry __ARGS((int from, int to));
+ 
+ /*
+  * Search for an entry in "langmap_mapga" for "from".  If found set the "to"
+  * field.  If not found insert a new entry at the appropriate location.
+  */
+     static void
+ langmap_set_entry(from, to)
+     int    from;
+     int    to;
+ {
+     langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
+     int             a = 0;
+     int             b = langmap_mapga.ga_len;
+ 
+     /* Do a binary search for an existing entry. */
+     while (a != b)
+     {
+ 	int i = (a + b) / 2;
+ 	int d = entries[i].from - from;
+ 
+ 	if (d == 0)
+ 	{
+ 	    entries[i].to = to;
+ 	    return;
+ 	}
+ 	if (d < 0)
+ 	    a = i + 1;
+ 	else
+ 	    b = i;
+     }
+ 
+     if (ga_grow(&langmap_mapga, 1) != OK)
+ 	return;  /* out of memory */
+ 
+     /* insert new entry at position "a" */
+     entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;
+     mch_memmove(entries + 1, entries,
+ 			(langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));
+     ++langmap_mapga.ga_len;
+     entries[0].from = from;
+     entries[0].to = to;
+ }
  
  /*
!  * Apply 'langmap' to multi-byte character "c" and return the result.
   */
+     int
+ langmap_adjust_mb(c)
+     int c;
+ {
+     langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
+     int a = 0;
+     int b = langmap_mapga.ga_len;
+ 
+     while (a != b)
+     {
+ 	int i = (a + b) / 2;
+ 	int d = entries[i].from - c;
+ 
+ 	if (d == 0)
+ 	    return entries[i].to;  /* found matching entry */
+ 	if (d < 0)
+ 	    a = i + 1;
+ 	else
+ 	    b = i;
+     }
+     return c;  /* no entry found, return "c" unmodified */
+ }
+ # endif
  
      static void
  langmap_init()
  {
      int i;
  
!     for (i = 0; i < 256; i++)
! 	langmap_mapchar[i] = i;	 /* we init with a one-to-one map */
! # ifdef FEAT_MBYTE
!     ga_init2(&langmap_mapga, sizeof(langmap_entry_T), 8);
! # endif
  }
  
  /*
***************
*** 10185,10191 ****
      char_u  *p2;
      int	    from, to;
  
!     langmap_init();			    /* back to one-to-one map first */
  
      for (p = p_langmap; p[0] != NUL; )
      {
--- 10270,10279 ----
      char_u  *p2;
      int	    from, to;
  
! #ifdef FEAT_MBYTE
!     ga_clear(&langmap_mapga);		    /* clear the previous map first */
! #endif
!     langmap_init();			    /* back to one-to-one map */
  
      for (p = p_langmap; p[0] != NUL; )
      {
***************
*** 10235,10241 ****
  							     transchar(from));
  		return;
  	    }
! 	    langmap_mapchar[from & 255] = to;
  
  	    /* Advance to next pair */
  	    mb_ptr_adv(p);
--- 10323,10335 ----
  							     transchar(from));
  		return;
  	    }
! 
! #ifdef FEAT_MBYTE
! 	    if (from >= 256)
! 		langmap_set_entry(from, to);
! 	    else
! #endif
! 		langmap_mapchar[from & 255] = to;
  
  	    /* Advance to next pair */
  	    mb_ptr_adv(p);
*** ../vim-7.2.108/src/proto/option.pro	Sat May  5 19:28:04 2007
--- src/proto/option.pro	Wed Feb 11 21:21:05 2009
***************
*** 44,49 ****
--- 44,50 ----
  void set_context_in_set_cmd __ARGS((expand_T *xp, char_u *arg, int opt_flags));
  int ExpandSettings __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file));
  int ExpandOldSetting __ARGS((int *num_file, char_u ***file));
+ int langmap_adjust_mb __ARGS((int c));
  int has_format_option __ARGS((int x));
  int shortmess __ARGS((int x));
  void vimrc_found __ARGS((char_u *fname, char_u *envname));
*** ../vim-7.2.108/src/window.c	Fri Nov 28 21:26:50 2008
--- src/window.c	Sat Feb 21 19:55:25 2009
***************
*** 594,602 ****
  		++allow_keys;   /* no mapping for xchar, but allow key codes */
  		if (xchar == NUL)
  		    xchar = plain_vgetc();
- #ifdef FEAT_LANGMAP
  		LANGMAP_ADJUST(xchar, TRUE);
- #endif
  		--no_mapping;
  		--allow_keys;
  #ifdef FEAT_CMDL_INFO
--- 594,600 ----
*** ../vim-7.2.108/src/version.c	Wed Feb 11 22:47:32 2009
--- src/version.c	Sat Feb 21 19:34:28 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     109,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
99. The hum of a cooling fan and the click of keys is comforting to you.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.110
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.110
Problem:    Compiler warning for unused variable.
Solution:   Init the variable.
Files:      src/ex_docmd.c
    

*** ../vim-7.2.109/src/ex_docmd.c	Wed Jan 28 15:42:07 2009
--- src/ex_docmd.c	Tue Feb 17 03:47:13 2009
***************
*** 5916,5922 ****
      char_u	*q;
  
      char_u	*start;
!     char_u	*end;
      char_u	*ksp;
      size_t	len, totlen;
  
--- 5916,5922 ----
      char_u	*q;
  
      char_u	*start;
!     char_u	*end = NULL;
      char_u	*ksp;
      size_t	len, totlen;
  
*** ../vim-7.2.109/src/version.c	Sat Feb 21 20:27:00 2009
--- src/version.c	Sat Feb 21 20:35:50 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     110,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
100. The most exciting sporting events you noticed during summer 1996
    was Netscape vs. Microsoft.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.111
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.111
Problem:    When using Visual block mode with 'cursorcolumn' it's unclear what
            is selected.
Solution:   Don't use 'cursorcolumn' highlighting inside the Visual selection.
            (idea by Dominique Pelle)
Files:      src/screen.c
    

*** ../vim-7.2.110/src/screen.c	Wed Oct  1 21:09:02 2008
--- src/screen.c	Sat Feb 21 21:04:19 2009
***************
*** 2596,2601 ****
--- 2596,2602 ----
      int		noinvcur = FALSE;	/* don't invert the cursor */
  #ifdef FEAT_VISUAL
      pos_T	*top, *bot;
+     int		lnum_in_visual_area = FALSE;
  #endif
      pos_T	pos;
      long	v;
***************
*** 2792,2800 ****
  	    top = &VIsual;
  	    bot = &curwin->w_cursor;
  	}
  	if (VIsual_mode == Ctrl_V)	/* block mode */
  	{
! 	    if (lnum >= top->lnum && lnum <= bot->lnum)
  	    {
  		fromcol = wp->w_old_cursor_fcol;
  		tocol = wp->w_old_cursor_lcol;
--- 2793,2802 ----
  	    top = &VIsual;
  	    bot = &curwin->w_cursor;
  	}
+ 	lnum_in_visual_area = (lnum >= top->lnum && lnum <= bot->lnum);
  	if (VIsual_mode == Ctrl_V)	/* block mode */
  	{
! 	    if (lnum_in_visual_area)
  	    {
  		fromcol = wp->w_old_cursor_fcol;
  		tocol = wp->w_old_cursor_lcol;
***************
*** 4557,4563 ****
  	 * highlight the cursor position itself. */
  	if (wp->w_p_cuc && vcol == (long)wp->w_virtcol
  		&& lnum != wp->w_cursor.lnum
! 		&& draw_state == WL_LINE)
  	{
  	    vcol_save_attr = char_attr;
  	    char_attr = hl_combine_attr(char_attr, hl_attr(HLF_CUC));
--- 4560,4567 ----
  	 * highlight the cursor position itself. */
  	if (wp->w_p_cuc && vcol == (long)wp->w_virtcol
  		&& lnum != wp->w_cursor.lnum
! 		&& draw_state == WL_LINE
! 		&& !lnum_in_visual_area)
  	{
  	    vcol_save_attr = char_attr;
  	    char_attr = hl_combine_attr(char_attr, hl_attr(HLF_CUC));
*** ../vim-7.2.110/src/version.c	Sat Feb 21 20:36:30 2009
--- src/version.c	Sat Feb 21 21:08:14 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     111,
  /**/

-- 
Contrary to popular belief, Unix is user friendly.
It just happens to be selective about who it makes friends with.
                                               -- Dave Parnas

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.112
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.112 
Problem:    Cursor invisible in Visual mode when 'number' is set and cursor in 
            first column. (Matti Niemenmaa, Renato Alves) 
Solution:   Check that vcol_prev is smaller than vcol. 
Files:      src/screen.c 


*** ../vim-7.2.111/src/screen.c	Sat Feb 21 21:10:24 2009
--- src/screen.c	Sat Feb 21 21:04:19 2009
***************
*** 3422,3427 ****
--- 3422,3428 ----
  			&& (*mb_ptr2cells)(ptr) > 1)
  #endif
  		    || ((int)vcol_prev == fromcol_prev
+ 			&& vcol_prev < vcol	/* not at margin */
  			&& vcol < tocol))
  		area_attr = attr;		/* start highlighting */
  	    else if (area_attr != 0
*** ../vim-7.2.111/src/version.c	Sat Feb 21 21:10:24 2009
--- src/version.c	Sat Feb 21 21:20:51 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     112,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
102. When filling out your driver's license application, you give
     your IP address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.113
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.113
Problem:    Crash for substitute() call using submatch(1) while there is no
            such submatch. (Yukihiro Nakadaira)
Solution:   Also check the start of the submatch is set, it can be NULL when
            an attempted match didn't work out.
Files:      src/regexp.c


*** ../vim-7.2.112/src/regexp.c	Fri Aug  8 13:45:31 2008
--- src/regexp.c	Sat Feb 21 21:46:49 2009
***************
*** 4532,4538 ****
  		cleanup_subexpr();
  		if (!REG_MULTI)		/* Single-line regexp */
  		{
! 		    if (reg_endp[no] == NULL)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
--- 4532,4538 ----
  		cleanup_subexpr();
  		if (!REG_MULTI)		/* Single-line regexp */
  		{
! 		    if (reg_startp[no] == NULL || reg_endp[no] == NULL)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
***************
*** 4548,4554 ****
  		}
  		else				/* Multi-line regexp */
  		{
! 		    if (reg_endpos[no].lnum < 0)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
--- 4548,4554 ----
  		}
  		else				/* Multi-line regexp */
  		{
! 		    if (reg_startpos[no].lnum < 0 || reg_endpos[no].lnum < 0)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
***************
*** 7279,7291 ****
      }
      else
      {
! 	if (submatch_match->endp[no] == NULL)
  	    retval = NULL;
  	else
- 	{
- 	    s = submatch_match->startp[no];
  	    retval = vim_strnsave(s, (int)(submatch_match->endp[no] - s));
- 	}
      }
  
      return retval;
--- 7279,7289 ----
      }
      else
      {
! 	s = submatch_match->startp[no];
! 	if (s == NULL || submatch_match->endp[no] == NULL)
  	    retval = NULL;
  	else
  	    retval = vim_strnsave(s, (int)(submatch_match->endp[no] - s));
      }
  
      return retval;
*** ../vim-7.2.112/src/version.c	Sat Feb 21 21:22:44 2009
--- src/version.c	Sat Feb 21 22:01:56 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     113,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
103. When you find yourself in the "Computer" section of Barnes & Noble
     enjoying yourself.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.114
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.114
Problem:    Using wrong printf format.
Solution:   Use "%ld" instead of "%d". (Dominique Pelle)
Files:      src/netbeans.c


*** ../vim-7.2.113/src/netbeans.c	Tue Jan  6 16:13:42 2009
--- src/netbeans.c	Tue Feb 17 03:21:33 2009
***************
*** 1924,1930 ****
  	    vim_free(path);
  	    if (bufp == NULL)
  	    {
! 	    	nbdebug(("    File %s not found in setBufferNumber\n", args));
  		EMSG2("E642: File %s not found in setBufferNumber", args);
  		return FAIL;
  	    }
--- 1924,1930 ----
  	    vim_free(path);
  	    if (bufp == NULL)
  	    {
! 		nbdebug(("    File %s not found in setBufferNumber\n", args));
  		EMSG2("E642: File %s not found in setBufferNumber", args);
  		return FAIL;
  	    }
***************
*** 2318,2324 ****
  	    }
  	    if (pos)
  	    {
! 		coloncmd(":sign place %d line=%d name=%d buffer=%d",
  			   serNum, pos->lnum, typeNum, buf->bufp->b_fnum);
  		if (typeNum == curPCtype)
  		    coloncmd(":sign jump %d buffer=%d", serNum,
--- 2318,2324 ----
  	    }
  	    if (pos)
  	    {
! 		coloncmd(":sign place %d line=%ld name=%d buffer=%d",
  			   serNum, pos->lnum, typeNum, buf->bufp->b_fnum);
  		if (typeNum == curPCtype)
  		    coloncmd(":sign jump %d buffer=%d", serNum,
***************
*** 2422,2428 ****
  				GUARDED) == 0)
  			    {
  				coloncmd(
! 				    ":sign place %d line=%d name=%d buffer=%d",
  				     guardId++, lnum, GUARDED,
  				     buf->bufp->b_fnum);
  			    }
--- 2422,2428 ----
  				GUARDED) == 0)
  			    {
  				coloncmd(
! 				    ":sign place %d line=%ld name=%d buffer=%d",
  				     guardId++, lnum, GUARDED,
  				     buf->bufp->b_fnum);
  			    }
*** ../vim-7.2.113/src/version.c	Sat Feb 21 22:03:06 2009
--- src/version.c	Sat Feb 21 22:11:21 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     114,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
104. When people ask about the Presidential Election you ask "Which country?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.115
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.115
Problem:    Some debugging code is never used.
Solution:   Remove nbtrace() and nbprt(). (Dominique Pelle)
Files:      src/nbdebug.c, src/nbdebug.h

*** ../vim-7.2.114/src/nbdebug.c	Tue Jun 24 23:54:30 2008
--- src/nbdebug.c	Tue Feb 17 03:26:07 2009
***************
*** 33,39 ****
  u_int		 nb_dlevel = 0;		/* nb_debug verbosity level */
  
  void		 nbdb(char *, ...);
- void		 nbtrace(char *, ...);
  
  static int	 lookup(char *);
  #ifdef USE_NB_ERRORHANDLER
--- 33,38 ----
***************
*** 100,124 ****
  }    /* end nbdebug_log_init */
  
  
- 
- 
- void
- nbtrace(
- 	char		*fmt,
- 	...)
- {
- 	va_list		 ap;
- 
- 	if (nb_debug!= NULL && (nb_dlevel & (NB_TRACE | NB_TRACE_VERBOSE))) {
- 		va_start(ap, fmt);
- 		vfprintf(nb_debug, fmt, ap);
- 		va_end(ap);
- 		fflush(nb_debug);
- 	}
- 
- }    /* end nbtrace */
- 
- 
  void
  nbdbg(
  	char		*fmt,
--- 99,104 ----
***************
*** 136,158 ****
  }    /* end nbdbg */
  
  
- void
- nbprt(
- 	char		*fmt,
- 	...)
- {
- 	va_list		 ap;
- 
- 	if (nb_debug != NULL && nb_dlevel & NB_PRINT) {
- 		va_start(ap, fmt);
- 		vfprintf(nb_debug, fmt, ap);
- 		va_end(ap);
- 		fflush(nb_debug);
- 	}
- 
- }    /* end nbprt */
- 
- 
  static int
  lookup(
  	char		*file)
--- 116,121 ----
*** ../vim-7.2.114/src/nbdebug.h	Wed Jun 25 00:47:21 2008
--- src/nbdebug.h	Tue Feb 17 03:26:38 2009
***************
*** 43,50 ****
  
  
  void		 nbdbg(char *, ...);
- void		 nbprt(char *, ...);
- void		 nbtrace(char *, ...);
  
  void nbdebug_wait __ARGS((u_int wait_flags, char *wait_var, u_int wait_secs));
  void nbdebug_log_init __ARGS((char *log_var, char *level_var));
--- 43,48 ----
***************
*** 70,88 ****
  {
  }
  
- void
- nbprt(
- 	char		*fmt,
- 	...)
- {
- }
- 
- void
- nbtrace(
- 	char		*fmt,
- 	...)
- {
- }
- 
  #endif /* NBDEBUG */
  #endif /* NBDEBUG_H */
--- 68,72 ----
*** ../vim-7.2.114/src/version.c	Sat Feb 21 22:12:43 2009
--- src/version.c	Sat Feb 21 22:28:21 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     115,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
105. When someone asks you for your address, you tell them your URL.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.116
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.116 
Problem:    Not all memory is freed when EXITFREE is defined. 
Solution:   Free allocated memory on exit. (Dominique Pelle) 
Files:      src/ex_docmd.c, src/gui_gtk_x11.c, src/misc2.c, src/search.c, 
            src/tag.c 
    

*** ../vim-7.2.115/src/tag.c	Tue Jan 13 17:27:18 2009
--- src/tag.c	Tue Feb 17 03:43:32 2009
***************
*** 2542,2547 ****
--- 2542,2556 ----
  {
      ga_clear_strings(&tag_fnames);
      do_tag(NULL, DT_FREE, 0, 0, 0);
+     tag_freematch();
+ 
+ # if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
+     if (ptag_entry.tagname)
+     {
+         vim_free(ptag_entry.tagname);
+         ptag_entry.tagname = NULL;
+     }
+ # endif
  }
  #endif
  
*** ../vim-7.2.115/src/version.c	Sat Feb 21 22:29:12 2009
--- src/version.c	Sat Feb 21 22:56:14 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     116,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
106. When told to "go to your room" you inform your parents that you
     can't...because you were kicked out and banned.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.117
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.117
Problem:    Location list incorrectly labelled "Quickfix List".
Solution:   Break out of both loops for finding window for location list
            buffer. (Lech Lorens)
Files:      src/buffer.c, src/quickfix.c, src/screen.c


*** ../vim-7.2.116/src/buffer.c	Tue Jan  6 16:13:42 2009
--- src/buffer.c	Tue Feb 17 04:00:51 2009
***************
*** 5098,5104 ****
  	 */
  	FOR_ALL_TAB_WINDOWS(tp, win)
  	    if (win->w_buffer == buf)
! 		break;
  	if (win != NULL && win->w_llist_ref != NULL)
  	    return _("[Location List]");
  	else
--- 5098,5105 ----
  	 */
  	FOR_ALL_TAB_WINDOWS(tp, win)
  	    if (win->w_buffer == buf)
! 		goto win_found;
! win_found:
  	if (win != NULL && win->w_llist_ref != NULL)
  	    return _("[Location List]");
  	else
*** ../vim-7.2.116/src/quickfix.c	Sat Nov 15 14:10:23 2008
--- src/quickfix.c	Sat Feb 21 22:54:25 2009
***************
*** 1610,1619 ****
  		{
  		    goto_tabpage_win(tp, wp);
  		    usable_win = 1;
! 		    break;
  		}
  	    }
  	}
  
  	/*
  	 * If there is only one window and it is the quickfix window, create a
--- 1612,1622 ----
  		{
  		    goto_tabpage_win(tp, wp);
  		    usable_win = 1;
! 		    goto win_found;
  		}
  	    }
  	}
+ win_found:
  
  	/*
  	 * If there is only one window and it is the quickfix window, create a
*** ../vim-7.2.116/src/screen.c	Sat Feb 21 21:22:44 2009
--- src/screen.c	Sat Feb 21 21:04:19 2009
***************
*** 7452,7461 ****
  	{
  	    outofmem = TRUE;
  #ifdef FEAT_WINDOWS
! 	    break;
  #endif
  	}
      }
  
  #ifdef FEAT_MBYTE
      for (i = 0; i < p_mco; ++i)
--- 7452,7464 ----
  	{
  	    outofmem = TRUE;
  #ifdef FEAT_WINDOWS
! 	    goto give_up;
  #endif
  	}
      }
+ #ifdef FEAT_WINDOWS
+ give_up:
+ #endif
  
  #ifdef FEAT_MBYTE
      for (i = 0; i < p_mco; ++i)
*** ../vim-7.2.116/src/version.c	Sat Feb 21 22:57:10 2009
--- src/version.c	Sat Feb 21 23:58:24 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     117,
  /**/

-- 
Laughing helps. It's like jogging on the inside.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.118
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.118
Problem:    <PageUp> at the more prompt only does half a page.
Solution:   Make <PageUp> go up a whole page.  Also make 'f' go a page
            forward, but not quit the more prompt. (Markus Heidelberg)
Files:      src/message.c


*** ../vim-7.2.117/src/message.c	Wed Feb 11 18:46:48 2009
--- src/message.c	Fri Feb 20 05:20:15 2009
***************
*** 976,982 ****
  		    }
  		}
  		else if (msg_scrolled > Rows - 2
! 				     && (c == 'j' || c == K_DOWN || c == 'd'))
  		    c = K_IGNORE;
  	    }
  	} while ((had_got_int && c == Ctrl_C)
--- 976,982 ----
  		    }
  		}
  		else if (msg_scrolled > Rows - 2
! 			 && (c == 'j' || c == K_DOWN || c == 'd' || c == 'f'))
  		    c = K_IGNORE;
  	    }
  	} while ((had_got_int && c == Ctrl_C)
***************
*** 2504,2510 ****
  	    break;
  
  	case 'u':		/* Up half a page */
- 	case K_PAGEUP:
  	    scroll = -(Rows / 2);
  	    break;
  
--- 2504,2509 ----
***************
*** 2513,2522 ****
--- 2512,2523 ----
  	    break;
  
  	case 'b':		/* one page back */
+ 	case K_PAGEUP:
  	    scroll = -(Rows - 1);
  	    break;
  
  	case ' ':		/* one extra page */
+ 	case 'f':
  	case K_PAGEDOWN:
  	case K_LEFTMOUSE:
  	    scroll = Rows - 1;
*** ../vim-7.2.117/src/version.c	Sun Feb 22 00:01:42 2009
--- src/version.c	Sun Feb 22 00:57:16 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     118,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
109. You actually read -- and enjoy -- lists like this.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.119
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.119
Problem:    Status line is redrawn too often.
Solution:   Check ScreeenLinesUC[] properly. (Yukihiro Nakadaira)
Files:      src/screen.c


*** ../vim-7.2.118/src/screen.c	Sun Feb 22 00:01:42 2009
--- src/screen.c	Sun Feb 22 01:07:38 2009
***************
*** 6362,6368 ****
  		    && c == 0x8e
  		    && ScreenLines2[off] != ptr[1])
  		|| (enc_utf8
! 		    && (ScreenLinesUC[off] != (u8char_T)u8c
  			|| screen_comp_differs(off, u8cc)))
  #endif
  		|| ScreenAttrs[off] != attr
--- 6362,6368 ----
  		    && c == 0x8e
  		    && ScreenLines2[off] != ptr[1])
  		|| (enc_utf8
! 		    && (ScreenLinesUC[off] != (u8char_T)(c >= 0x80 ? u8c : 0)
  			|| screen_comp_differs(off, u8cc)))
  #endif
  		|| ScreenAttrs[off] != attr
*** ../vim-7.2.118/src/version.c	Sun Feb 22 00:58:03 2009
--- src/version.c	Sun Feb 22 01:09:54 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     119,
  /**/

-- 
In a world without walls and borders, who needs windows and gates?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.120
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.120
Problem:    When opening the quickfix window or splitting the window and
            setting the location list, the location list is copied and then
            deleted, which is inefficient.
Solution:   Don't copy the location list when not needed. (Lech Lorens)
Files:      src/quickfix.c, src/vim.h, src/window.c


*** ../vim-7.2.119/src/quickfix.c	Sun Feb 22 00:01:42 2009
--- src/quickfix.c	Sat Feb 21 22:54:25 2009
***************
*** 1419,1424 ****
--- 1419,1425 ----
      int			opened_window = FALSE;
      win_T		*win;
      win_T		*altwin;
+     int			flags;
  #endif
      win_T		*oldwin = curwin;
      int			print_message = TRUE;
***************
*** 1531,1537 ****
      if (qf_ptr->qf_type == 1 && (!curwin->w_buffer->b_help || cmdmod.tab != 0))
      {
  	win_T	*wp;
- 	int	n;
  
  	if (cmdmod.tab != 0)
  	    wp = NULL;
--- 1532,1537 ----
***************
*** 1547,1559 ****
  	     * Split off help window; put it at far top if no position
  	     * specified, the current window is vertically split and narrow.
  	     */
! 	    n = WSP_HELP;
  # ifdef FEAT_VERTSPLIT
  	    if (cmdmod.split == 0 && curwin->w_width != Columns
  						      && curwin->w_width < 80)
! 		n |= WSP_TOP;
  # endif
! 	    if (win_split(0, n) == FAIL)
  		goto theend;
  	    opened_window = TRUE;	/* close it when fail */
  
--- 1547,1562 ----
  	     * Split off help window; put it at far top if no position
  	     * specified, the current window is vertically split and narrow.
  	     */
! 	    flags = WSP_HELP;
  # ifdef FEAT_VERTSPLIT
  	    if (cmdmod.split == 0 && curwin->w_width != Columns
  						      && curwin->w_width < 80)
! 		flags |= WSP_TOP;
  # endif
! 	    if (qi != &ql_info)
! 		flags |= WSP_NEWLOC;  /* don't copy the location list */
! 
! 	    if (win_split(0, flags) == FAIL)
  		goto theend;
  	    opened_window = TRUE;	/* close it when fail */
  
***************
*** 1563,1569 ****
  	    if (qi != &ql_info)	    /* not a quickfix list */
  	    {
  		/* The new window should use the supplied location list */
- 		qf_free_all(curwin);
  		curwin->w_llist = qi;
  		qi->qf_refcount++;
  	    }
--- 1566,1571 ----
***************
*** 1624,1630 ****
  	{
  	    ll_ref = curwin->w_llist_ref;
  
! 	    if (win_split(0, WSP_ABOVE) == FAIL)
  		goto failed;		/* not enough room for window */
  	    opened_window = TRUE;	/* close it when fail */
  	    p_swb = empty_option;	/* don't split again */
--- 1626,1635 ----
  	{
  	    ll_ref = curwin->w_llist_ref;
  
! 	    flags = WSP_ABOVE;
! 	    if (ll_ref != NULL)
! 		flags |= WSP_NEWLOC;
! 	    if (win_split(0, flags) == FAIL)
  		goto failed;		/* not enough room for window */
  	    opened_window = TRUE;	/* close it when fail */
  	    p_swb = empty_option;	/* don't split again */
***************
*** 1636,1642 ****
  	    {
  		/* The new window should use the location list from the
  		 * location list window */
- 		qf_free_all(curwin);
  		curwin->w_llist = ll_ref;
  		ll_ref->qf_refcount++;
  	    }
--- 1641,1646 ----
***************
*** 2311,2325 ****
  	if (eap->cmdidx == CMD_copen || eap->cmdidx == CMD_cwindow)
  	    /* Create the new window at the very bottom. */
  	    win_goto(lastwin);
! 	if (win_split(height, WSP_BELOW) == FAIL)
  	    return;		/* not enough room for window */
  #ifdef FEAT_SCROLLBIND
  	curwin->w_p_scb = FALSE;
  #endif
  
- 	/* Remove the location list for the quickfix window */
- 	qf_free_all(curwin);
- 
  	if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
  	{
  	    /*
--- 2315,2326 ----
  	if (eap->cmdidx == CMD_copen || eap->cmdidx == CMD_cwindow)
  	    /* Create the new window at the very bottom. */
  	    win_goto(lastwin);
! 	if (win_split(height, WSP_BELOW | WSP_NEWLOC) == FAIL)
  	    return;		/* not enough room for window */
  #ifdef FEAT_SCROLLBIND
  	curwin->w_p_scb = FALSE;
  #endif
  
  	if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
  	{
  	    /*
*** ../vim-7.2.119/src/vim.h	Thu Nov 20 14:11:47 2008
--- src/vim.h	Sat Feb 21 22:53:03 2009
***************
*** 1057,1062 ****
--- 1057,1063 ----
  #define WSP_HELP	16	/* creating the help window */
  #define WSP_BELOW	32	/* put new window below/right */
  #define WSP_ABOVE	64	/* put new window above/left */
+ #define WSP_NEWLOC	128	/* don't copy location list */
  
  /*
   * arguments for gui_set_shellsize()
*** ../vim-7.2.119/src/window.c	Sat Feb 21 20:27:00 2009
--- src/window.c	Sat Feb 21 23:56:41 2009
***************
*** 12,18 ****
  static int path_is_url __ARGS((char_u *p));
  #if defined(FEAT_WINDOWS) || defined(PROTO)
  static int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
! static void win_init __ARGS((win_T *newp, win_T *oldp));
  static void frame_comp_pos __ARGS((frame_T *topfrp, int *row, int *col));
  static void frame_setheight __ARGS((frame_T *curfrp, int height));
  #ifdef FEAT_VERTSPLIT
--- 12,18 ----
  static int path_is_url __ARGS((char_u *p));
  #if defined(FEAT_WINDOWS) || defined(PROTO)
  static int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
! static void win_init __ARGS((win_T *newp, win_T *oldp, int flags));
  static void frame_comp_pos __ARGS((frame_T *topfrp, int *row, int *col));
  static void frame_setheight __ARGS((frame_T *curfrp, int height));
  #ifdef FEAT_VERTSPLIT
***************
*** 911,917 ****
  	    return FAIL;
  
  	/* make the contents of the new window the same as the current one */
! 	win_init(wp, curwin);
      }
  
      /*
--- 911,917 ----
  	    return FAIL;
  
  	/* make the contents of the new window the same as the current one */
! 	win_init(wp, curwin, flags);
      }
  
      /*
***************
*** 1160,1170 ****
   * Initialize window "newp" from window "oldp".
   * Used when splitting a window and when creating a new tab page.
   * The windows will both edit the same buffer.
   */
      static void
! win_init(newp, oldp)
      win_T	*newp;
      win_T	*oldp;
  {
      int		i;
  
--- 1160,1174 ----
   * Initialize window "newp" from window "oldp".
   * Used when splitting a window and when creating a new tab page.
   * The windows will both edit the same buffer.
+  * WSP_NEWLOC may be specified in flags to prevent the location list from
+  * being copied.
   */
+ /*ARGSUSED*/
      static void
! win_init(newp, oldp, flags)
      win_T	*newp;
      win_T	*oldp;
+     int		 flags;
  {
      int		i;
  
***************
*** 1189,1195 ****
      copy_jumplist(oldp, newp);
  #endif
  #ifdef FEAT_QUICKFIX
!     copy_loclist(oldp, newp);
  #endif
      if (oldp->w_localdir != NULL)
  	newp->w_localdir = vim_strsave(oldp->w_localdir);
--- 1193,1206 ----
      copy_jumplist(oldp, newp);
  #endif
  #ifdef FEAT_QUICKFIX
!     if (flags & WSP_NEWLOC)
!     {
! 	/* Don't copy the location list.  */
! 	newp->w_llist = NULL;
! 	newp->w_llist_ref = NULL;
!     }
!     else
! 	copy_loclist(oldp, newp);
  #endif
      if (oldp->w_localdir != NULL)
  	newp->w_localdir = vim_strsave(oldp->w_localdir);
***************
*** 3219,3225 ****
      else
      {
  	/* First window in new tab page, initialize it from "oldwin". */
! 	win_init(curwin, oldwin);
  
  # ifdef FEAT_SCROLLBIND
  	/* We don't want scroll-binding in the first window. */
--- 3230,3236 ----
      else
      {
  	/* First window in new tab page, initialize it from "oldwin". */
! 	win_init(curwin, oldwin, 0);
  
  # ifdef FEAT_SCROLLBIND
  	/* We don't want scroll-binding in the first window. */
*** ../vim-7.2.119/src/version.c	Sun Feb 22 01:13:45 2009
--- src/version.c	Sun Feb 22 02:32:14 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     120,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
110. You actually volunteer to become your employer's webmaster.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.121
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.121
Problem:    In gvim "!grep a *.c" spews out a lot of text that can't be
            stopped with CTRL-C.
Solution:   When looping to read and show text, do check for typed characters
            every two seconds.
Files:      src/os_unix.c


*** ../vim-7.2.120/src/os_unix.c	Wed Feb  4 14:18:44 2009
--- src/os_unix.c	Sun Feb 22 00:54:05 2009
***************
*** 4092,4097 ****
--- 4092,4100 ----
  		int	    fromshell_fd;
  		garray_T    ga;
  		int	    noread_cnt;
+ # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+ 		struct timeval  start_tv;
+ # endif
  
  # ifdef FEAT_GUI
  		if (pty_master_fd >= 0)
***************
*** 4201,4207 ****
  		    ga_init2(&ga, 1, BUFLEN);
  
  		noread_cnt = 0;
! 
  		for (;;)
  		{
  		    /*
--- 4204,4212 ----
  		    ga_init2(&ga, 1, BUFLEN);
  
  		noread_cnt = 0;
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 		gettimeofday(&start_tv, NULL);
! # endif
  		for (;;)
  		{
  		    /*
***************
*** 4214,4238 ****
  		     * that a typed password is echoed for ssh or gpg command.
  		     * Don't get characters when the child has already
  		     * finished (wait_pid == 0).
- 		     * Don't get extra characters when we already have one.
  		     * Don't read characters unless we didn't get output for a
! 		     * while, avoids that ":r !ls" eats typeahead.
  		     */
  		    len = 0;
  		    if (!(options & SHELL_EXPAND)
  			    && ((options &
  					 (SHELL_READ|SHELL_WRITE|SHELL_COOKED))
  				      != (SHELL_READ|SHELL_WRITE|SHELL_COOKED)
! #ifdef FEAT_GUI
  						    || gui.in_use
! #endif
  						    )
  			    && wait_pid == 0
! 			    && (ta_len > 0
! 				|| (noread_cnt > 4
! 				    && (len = ui_inchar(ta_buf,
! 						       BUFLEN, 10L, 0)) > 0)))
  		    {
  			/*
  			 * For pipes:
  			 * Check for CTRL-C: send interrupt signal to child.
--- 4219,4252 ----
  		     * that a typed password is echoed for ssh or gpg command.
  		     * Don't get characters when the child has already
  		     * finished (wait_pid == 0).
  		     * Don't read characters unless we didn't get output for a
! 		     * while (noread_cnt > 4), avoids that ":r !ls" eats
! 		     * typeahead.
  		     */
  		    len = 0;
  		    if (!(options & SHELL_EXPAND)
  			    && ((options &
  					 (SHELL_READ|SHELL_WRITE|SHELL_COOKED))
  				      != (SHELL_READ|SHELL_WRITE|SHELL_COOKED)
! # ifdef FEAT_GUI
  						    || gui.in_use
! # endif
  						    )
  			    && wait_pid == 0
! 			    && (ta_len > 0 || noread_cnt > 4))
  		    {
+ 		      if (ta_len == 0)
+ 		      {
+ 			  /* Get extra characters when we don't have any.
+ 			   * Reset the counter and timer. */
+ 			  noread_cnt = 0;
+ # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+ 			  gettimeofday(&start_tv, NULL);
+ # endif
+ 			  len = ui_inchar(ta_buf, BUFLEN, 10L, 0);
+ 		      }
+ 		      if (ta_len > 0 || len > 0)
+ 		      {
  			/*
  			 * For pipes:
  			 * Check for CTRL-C: send interrupt signal to child.
***************
*** 4334,4342 ****
  			    {
  				ta_len -= len;
  				mch_memmove(ta_buf, ta_buf + len, ta_len);
- 				noread_cnt = 0;
  			    }
  			}
  		    }
  
  		    if (got_int)
--- 4348,4356 ----
  			    {
  				ta_len -= len;
  				mch_memmove(ta_buf, ta_buf + len, ta_len);
  			    }
  			}
+ 		      }
  		    }
  
  		    if (got_int)
***************
*** 4444,4449 ****
--- 4458,4482 ----
  			out_flush();
  			if (got_int)
  			    break;
+ 
+ # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+ 			{
+ 			    struct timeval  now_tv;
+ 			    long	    msec;
+ 
+ 			    /* Avoid that we keep looping here without
+ 			     * checking for a CTRL-C for a long time.  Don't
+ 			     * break out too often to avoid losing typeahead. */
+ 			    gettimeofday(&now_tv, NULL);
+ 			    msec = (now_tv.tv_sec - start_tv.tv_sec) * 1000L
+ 				+ (now_tv.tv_usec - start_tv.tv_usec) / 1000L;
+ 			    if (msec > 2000)
+ 			    {
+ 				noread_cnt = 5;
+ 				break;
+ 			    }
+ 			}
+ # endif
  		    }
  
  		    /* If we already detected the child has finished break the
*** ../vim-7.2.120/src/version.c	Sun Feb 22 02:36:36 2009
--- src/version.c	Sun Feb 22 02:48:03 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     121,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
111. You and your friends get together regularly on IRC, even though
     all of you live in the same city.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.122
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.122
Problem:    Invalid memory access when the VimResized autocommand changes
            'columns' and/or 'lines'.
Solution:   After VimResized check for changed values. (Dominique Pelle)
Files:      src/screen.c


*** ../vim-7.2.121/src/screen.c	Sun Feb 22 01:13:45 2009
--- src/screen.c	Sun Feb 22 01:07:38 2009
***************
*** 7368,7374 ****
--- 7368,7378 ----
  #endif
      static int	    entered = FALSE;		/* avoid recursiveness */
      static int	    done_outofmem_msg = FALSE;	/* did outofmem message */
+ #ifdef FEAT_AUTOCMD
+     int		    retry_count = 0;
  
+ retry:
+ #endif
      /*
       * Allocation of the screen buffers is done only when the size changes and
       * when Rows and Columns have been set and we have started doing full
***************
*** 7643,7650 ****
      --RedrawingDisabled;
  
  #ifdef FEAT_AUTOCMD
!     if (starting == 0)
  	apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);
  #endif
  }
  
--- 7647,7663 ----
      --RedrawingDisabled;
  
  #ifdef FEAT_AUTOCMD
!     /*
!      * Do not apply autocommands more than 3 times to avoid an endless loop
!      * in case applying autocommands always changes Rows or Columns.
!      */
!     if (starting == 0 && ++retry_count <= 3)
!     {
  	apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);
+ 	/* In rare cases, autocommands may have altered Rows or Columns,
+ 	 * jump back to check if we need to allocate the screen again. */
+ 	goto retry;
+     }
  #endif
  }
  
*** ../vim-7.2.121/src/version.c	Sun Feb 22 02:51:37 2009
--- src/version.c	Sun Feb 22 21:11:14 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     122,
  /**/

-- 
FIXME and XXX are two common keywords used to mark broken or incomplete code
not only since XXX as a sex reference would grab everbodys attention but
simply due to the fact that Vim would highlight these words.
					-- Hendrik Scholz

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.123
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.123
Problem:    Typing 'q' at more prompt for ":map" output still displays another
            line, causing another more prompt. (Markus Heidelberg)
Solution:   Quit listing maps when 'q' typed.
Files:      src/getchar.c


*** ../vim-7.2.122/src/getchar.c	Fri Nov 28 12:05:07 2008
--- src/getchar.c	Sun Feb 22 23:10:45 2009
***************
*** 3816,3822 ****
--- 3816,3826 ----
      int len = 1;
  
      if (msg_didout || msg_silent != 0)
+     {
  	msg_putchar('\n');
+ 	if (got_int)	    /* 'q' typed at MORE prompt */
+ 	    return;
+     }
      if ((mp->m_mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
  	msg_putchar('!');			/* :map! */
      else if (mp->m_mode & INSERT)
*** ../vim-7.2.122/src/version.c	Sun Feb 22 21:12:22 2009
--- src/version.c	Sun Feb 22 23:16:29 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     123,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
120. You ask a friend, "What's that big shiny thing?" He says, "It's the sun."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.124
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.124
Problem:    Typing 'q' at more prompt for ":tselect" output still displays
            more lines, causing another more prompt. (Markus Heidelberg)
Solution:   Quit listing tags when 'q' typed.
Files:      src/tag.c


*** ../vim-7.2.123/src/tag.c	Sat Feb 21 22:57:10 2009
--- src/tag.c	Mon Feb 23 00:07:24 2009
***************
*** 618,624 ****
  		taglen_advance(taglen);
  		MSG_PUTS_ATTR(_("file\n"), hl_attr(HLF_T));
  
! 		for (i = 0; i < num_matches; ++i)
  		{
  		    parse_match(matches[i], &tagp);
  		    if (!new_tag && (
--- 618,624 ----
  		taglen_advance(taglen);
  		MSG_PUTS_ATTR(_("file\n"), hl_attr(HLF_T));
  
! 		for (i = 0; i < num_matches && !got_int; ++i)
  		{
  		    parse_match(matches[i], &tagp);
  		    if (!new_tag && (
***************
*** 655,660 ****
--- 655,662 ----
  		    }
  		    if (msg_col > 0)
  			msg_putchar('\n');
+ 		    if (got_int)
+ 			break;
  		    msg_advance(15);
  
  		    /* print any extra fields */
***************
*** 689,694 ****
--- 691,698 ----
  				if (msg_col + ptr2cells(p) >= Columns)
  				{
  				    msg_putchar('\n');
+ 				    if (got_int)
+ 					break;
  				    msg_advance(15);
  				}
  				p = msg_outtrans_one(p, attr);
***************
*** 704,709 ****
--- 708,715 ----
  			if (msg_col > 15)
  			{
  			    msg_putchar('\n');
+ 			    if (got_int)
+ 				break;
  			    msg_advance(15);
  			}
  		    }
***************
*** 734,739 ****
--- 740,747 ----
  		    {
  			if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns)
  			    msg_putchar('\n');
+ 			if (got_int)
+ 			    break;
  			msg_advance(15);
  
  			/* skip backslash used for escaping command char */
***************
*** 760,771 ****
  		    if (msg_col)
  			msg_putchar('\n');
  		    ui_breakcheck();
- 		    if (got_int)
- 		    {
- 			got_int = FALSE;	/* only stop the listing */
- 			break;
- 		    }
  		}
  		ask_for_selection = TRUE;
  	    }
  #if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)
--- 768,776 ----
  		    if (msg_col)
  			msg_putchar('\n');
  		    ui_breakcheck();
  		}
+ 		if (got_int)
+ 		    got_int = FALSE;	/* only stop the listing */
  		ask_for_selection = TRUE;
  	    }
  #if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)
*** ../vim-7.2.123/src/version.c	Sun Feb 22 23:42:08 2009
--- src/version.c	Mon Feb 23 00:51:57 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     124,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
123. You ask the car dealer to install an extra cigarette lighter
     on your new car to power your notebook.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.125
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.125
Problem:    Leaking memory when reading XPM bitmap for a sign.
Solution:   Don't allocate the memory twice. (Dominique Pelle)
Files:      src/gui_x11.c


*** ../vim-7.2.124/src/gui_x11.c	Wed Nov 12 13:07:48 2008
--- src/gui_x11.c	Sun Feb 22 21:58:19 2009
***************
*** 1587,1592 ****
--- 1587,1594 ----
      XtCloseDisplay(gui.dpy);
      gui.dpy = NULL;
      vimShell = (Widget)0;
+     vim_free(gui_argv);
+     gui_argv = NULL;
  }
  
  /*
***************
*** 1761,1766 ****
--- 1763,1770 ----
       * says that this isn't needed when exiting, so just skip it. */
      XtCloseDisplay(gui.dpy);
  #endif
+     vim_free(gui_argv);
+     gui_argv = NULL;
  }
  
  /*
***************
*** 3439,3485 ****
      char_u	    *signfile;
  {
      XpmAttributes   attrs;
!     XImage	    *sign;
      int		    status;
  
      /*
       * Setup the color substitution table.
       */
-     sign = NULL;
      if (signfile[0] != NUL && signfile[0] != '-')
      {
! 	sign = (XImage *)alloc(sizeof(XImage));
! 	if (sign != NULL)
  	{
! 	    XpmColorSymbol color[5] =
! 	    {
! 		{"none", NULL, 0},
! 		{"iconColor1", NULL, 0},
! 		{"bottomShadowColor", NULL, 0},
! 		{"topShadowColor", NULL, 0},
! 		{"selectColor", NULL, 0}
! 	    };
! 	    attrs.valuemask = XpmColorSymbols;
! 	    attrs.numsymbols = 2;
! 	    attrs.colorsymbols = color;
! 	    attrs.colorsymbols[0].pixel = gui.back_pixel;
! 	    attrs.colorsymbols[1].pixel = gui.norm_pixel;
! 	    status = XpmReadFileToImage(gui.dpy, (char *)signfile,
  							 &sign, NULL, &attrs);
! 
! 	    if (status == 0)
! 	    {
! 		/* Sign width is fixed at two columns now.
! 		if (sign->width > gui.sign_width)
! 		    gui.sign_width = sign->width + 8; */
! 	    }
! 	    else
! 	    {
! 		vim_free(sign);
! 		sign = NULL;
! 		EMSG(_(e_signdata));
! 	    }
  	}
      }
  
      return (void *)sign;
--- 3443,3479 ----
      char_u	    *signfile;
  {
      XpmAttributes   attrs;
!     XImage	    *sign = NULL;
      int		    status;
  
      /*
       * Setup the color substitution table.
       */
      if (signfile[0] != NUL && signfile[0] != '-')
      {
! 	XpmColorSymbol color[5] =
  	{
! 	    {"none", NULL, 0},
! 	    {"iconColor1", NULL, 0},
! 	    {"bottomShadowColor", NULL, 0},
! 	    {"topShadowColor", NULL, 0},
! 	    {"selectColor", NULL, 0}
! 	};
! 	attrs.valuemask = XpmColorSymbols;
! 	attrs.numsymbols = 2;
! 	attrs.colorsymbols = color;
! 	attrs.colorsymbols[0].pixel = gui.back_pixel;
! 	attrs.colorsymbols[1].pixel = gui.norm_pixel;
! 	status = XpmReadFileToImage(gui.dpy, (char *)signfile,
  							 &sign, NULL, &attrs);
! 	if (status == 0)
! 	{
! 	    /* Sign width is fixed at two columns now.
! 	    if (sign->width > gui.sign_width)
! 	        gui.sign_width = sign->width + 8; */
  	}
+ 	else
+ 	    EMSG(_(e_signdata));
      }
  
      return (void *)sign;
***************
*** 3489,3496 ****
  gui_mch_destroy_sign(sign)
      void *sign;
  {
!     XFree(((XImage *)sign)->data);
!     vim_free(sign);
  }
  #endif
  
--- 3483,3489 ----
  gui_mch_destroy_sign(sign)
      void *sign;
  {
!     XDestroyImage((XImage*)sign);
  }
  #endif
  
*** ../vim-7.2.124/src/version.c	Mon Feb 23 00:53:35 2009
--- src/version.c	Tue Feb 24 04:09:33 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     125,
  /**/

-- 
I have a watch cat! Just break in and she'll watch.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.126
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.126
Problem:    When EXITFREE is defined signs are not freed.
Solution:   Free all signs on exit.  Also free keymaps. (Dominique Pelle)
Files:      src/misc2.c, src/ex_cmds.c, src/proto/ex_cmds.pro


*** ../vim-7.2.125/src/misc2.c	Thu Jan 22 21:31:24 2009
--- src/misc2.c	Sun Feb 22 22:04:53 2009
***************
*** 1010,1015 ****
--- 1010,1018 ----
  # if defined(FEAT_PROFILE)
      do_cmdline_cmd((char_u *)"profdel *");
  # endif
+ # if defined(FEAT_KEYMAP)
+     do_cmdline_cmd((char_u *)"set keymap=");
+ #endif
  
  # ifdef FEAT_TITLE
      free_titles();
***************
*** 1034,1039 ****
--- 1037,1045 ----
      free_regexp_stuff();
      free_tag_stuff();
      free_cd_dir();
+ # ifdef FEAT_SIGNS
+     free_signs();
+ # endif
  # ifdef FEAT_EVAL
      set_expr_line(NULL);
  # endif
*** ../vim-7.2.125/src/ex_cmds.c	Wed Feb 11 16:02:29 2009
--- src/ex_cmds.c	Sun Feb 22 22:07:08 2009
***************
*** 6541,6546 ****
--- 6541,6547 ----
  static int	last_sign_typenr = MAX_TYPENR;	/* is decremented */
  
  static void sign_list_defined __ARGS((sign_T *sp));
+ static void sign_undefine __ARGS((sign_T *sp, sign_T *sp_prev));
  
  /*
   * ":sign" command
***************
*** 6749,6772 ****
  		/* ":sign list {name}" */
  		sign_list_defined(sp);
  	    else
- 	    {
  		/* ":sign undefine {name}" */
! 		vim_free(sp->sn_name);
! 		vim_free(sp->sn_icon);
! #ifdef FEAT_SIGN_ICONS
! 		if (sp->sn_image != NULL)
! 		{
! 		    out_flush();
! 		    gui_mch_destroy_sign(sp->sn_image);
! 		}
! #endif
! 		vim_free(sp->sn_text);
! 		if (sp_prev == NULL)
! 		    first_sign = sp->sn_next;
! 		else
! 		    sp_prev->sn_next = sp->sn_next;
! 		vim_free(sp);
! 	    }
  	}
      }
      else
--- 6750,6757 ----
  		/* ":sign list {name}" */
  		sign_list_defined(sp);
  	    else
  		/* ":sign undefine {name}" */
! 		sign_undefine(sp, sp_prev);
  	}
      }
      else
***************
*** 7015,7020 ****
--- 7000,7030 ----
  }
  
  /*
+  * Undefine a sign and free its memory.
+  */
+     static void
+ sign_undefine(sp, sp_prev)
+     sign_T	*sp;
+     sign_T	*sp_prev;
+ {
+     vim_free(sp->sn_name);
+     vim_free(sp->sn_icon);
+ #ifdef FEAT_SIGN_ICONS
+     if (sp->sn_image != NULL)
+     {
+ 	out_flush();
+ 	gui_mch_destroy_sign(sp->sn_image);
+     }
+ #endif
+     vim_free(sp->sn_text);
+     if (sp_prev == NULL)
+ 	first_sign = sp->sn_next;
+     else
+ 	sp_prev->sn_next = sp->sn_next;
+     vim_free(sp);
+ }
+ 
+ /*
   * Get highlighting attribute for sign "typenr".
   * If "line" is TRUE: line highl, if FALSE: text highl.
   */
***************
*** 7088,7093 ****
--- 7098,7115 ----
      return (char_u *)_("[Deleted]");
  }
  
+ #if defined(EXITFREE) || defined(PROTO)
+ /*
+  * Undefine/free all signs.
+  */
+     void
+ free_signs()
+ {
+     while (first_sign != NULL)
+ 	sign_undefine(first_sign, NULL);
+ }
+ #endif
+ 
  #endif
  
  #if defined(FEAT_GUI) || defined(FEAT_CLIENTSERVER) || defined(PROTO)
*** ../vim-7.2.125/src/proto/ex_cmds.pro	Sat Nov 15 14:10:23 2008
--- src/proto/ex_cmds.pro	Sun Feb 22 22:04:53 2009
***************
*** 40,45 ****
--- 40,46 ----
  int read_viminfo_sub_string __ARGS((vir_T *virp, int force));
  void write_viminfo_sub_string __ARGS((FILE *fp));
  void free_old_sub __ARGS((void));
+ void free_signs __ARGS((void));
  int prepare_tagpreview __ARGS((int undo_sync));
  void ex_help __ARGS((exarg_T *eap));
  char_u *check_help_lang __ARGS((char_u *arg));
*** ../vim-7.2.125/src/version.c	Tue Feb 24 04:11:07 2009
--- src/version.c	Tue Feb 24 04:24:46 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     126,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
125. You begin to wonder how often it REALLY is necessary to get up
     and shower or bathe.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.127
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.127
Problem:    When listing mappings and a wrapping line causes the more prompt,
            after typing 'q' there can be another more prompt. (Markus 
            Heidelberg)
Solution:   Set "lines_left" to allow more lines to be displayed.
Files:      src/message.c


*** ../vim-7.2.126/src/message.c	Sun Feb 22 00:58:03 2009
--- src/message.c	Mon Feb 23 04:17:39 2009
***************
*** 2553,2559 ****
  	    {
  		/* Jump to the choices of the dialog. */
  		retval = TRUE;
- 		lines_left = Rows - 1;
  	    }
  	    else
  #endif
--- 2553,2558 ----
***************
*** 2561,2566 ****
--- 2560,2568 ----
  		got_int = TRUE;
  		quit_more = TRUE;
  	    }
+ 	    /* When there is some more output (wrapping line) display that
+ 	     * without another prompt. */
+ 	    lines_left = Rows - 1;
  	    break;
  
  #ifdef FEAT_CLIPBOARD
*** ../vim-7.2.126/src/version.c	Tue Feb 24 04:28:40 2009
--- src/version.c	Tue Feb 24 04:35:38 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     127,
  /**/

-- 
The difference between theory and practice, is that in theory, there
is no difference between theory and practice.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.128
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.128 (after 7.2.055)
Problem:    Using ":lcd" makes session files not work.
Solution:   Compare return value of mch_chdir() properly. (Andreas Bernauer)
Files:      src/ex_docmd.c


*** ../vim-7.2.127/src/ex_docmd.c	Sat Feb 21 20:36:30 2009
--- src/ex_docmd.c	Sun Mar  1 02:39:38 2009
***************
*** 8792,8798 ****
  		else if (*dirnow != NUL
  			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
  		{
! 		    if (mch_chdir((char *)globaldir) == OK)
  			shorten_fnames(TRUE);
  		}
  
--- 8799,8805 ----
  		else if (*dirnow != NUL
  			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
  		{
! 		    if (mch_chdir((char *)globaldir) == 0)
  			shorten_fnames(TRUE);
  		}
  
*** ../vim-7.2.127/src/version.c	Tue Feb 24 04:36:50 2009
--- src/version.c	Sun Mar  1 02:42:47 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     128,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
138. You develop a liking for cold coffee.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.129
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.129
Problem:    When opening a command window from input() it uses the search
            history.
Solution:   Use get_cmdline_type(). (James Vega)
Files:      src/ex_getln.c


*** ../vim-7.2.128/src/ex_getln.c	Fri Nov 28 10:59:57 2008
--- src/ex_getln.c	Mon Mar  2 00:53:39 2009
***************
*** 6047,6055 ****
  # endif
  	return K_IGNORE;
      }
!     cmdwin_type = ccline.cmdfirstc;
!     if (cmdwin_type == NUL)
! 	cmdwin_type = '-';
  
      /* Create the command-line buffer empty. */
      (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
--- 6062,6068 ----
  # endif
  	return K_IGNORE;
      }
!     cmdwin_type = get_cmdline_type();
  
      /* Create the command-line buffer empty. */
      (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
***************
*** 6073,6079 ****
      /* Showing the prompt may have set need_wait_return, reset it. */
      need_wait_return = FALSE;
  
!     histtype = hist_char2type(ccline.cmdfirstc);
      if (histtype == HIST_CMD || histtype == HIST_DEBUG)
      {
  	if (p_wc == TAB)
--- 6086,6092 ----
      /* Showing the prompt may have set need_wait_return, reset it. */
      need_wait_return = FALSE;
  
!     histtype = hist_char2type(cmdwin_type);
      if (histtype == HIST_CMD || histtype == HIST_DEBUG)
      {
  	if (p_wc == TAB)
*** ../vim-7.2.128/src/version.c	Sun Mar  1 02:43:50 2009
--- src/version.c	Mon Mar  2 02:10:11 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     129,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
146. You experience ACTUAL physical withdrawal symptoms when away
     from your 'puter and the net.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.130
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.130
Problem:    Vim may haing until CTRL-C is typed when using CTRL-Z.
Solution:   Avoid using pause().  Also use "volatile" for variables used in
            signal functions. (Dominique Pelle)
Files:      src/auto/configure, src/configure.in, src/config.h.in,
            src/globals.h, src/os_unix.c
    

*** ../vim-7.2.129/src/auto/configure	Thu Nov 20 10:36:04 2008
--- src/auto/configure	Mon Mar  2 02:36:52 2009
***************
*** 11565,11570 ****
--- 11565,11631 ----
  
  fi
  
+ { $as_echo "$as_me:$LINENO: checking for working volatile" >&5
+ $as_echo_n "checking for working volatile... " >&6; }
+ if test "${ac_cv_c_volatile+set}" = set; then
+   $as_echo_n "(cached) " >&6
+ else
+   cat >conftest.$ac_ext <<_ACEOF
+ /* confdefs.h.  */
+ _ACEOF
+ cat confdefs.h >>conftest.$ac_ext
+ cat >>conftest.$ac_ext <<_ACEOF
+ /* end confdefs.h.  */
+ 
+ int
+ main ()
+ {
+ 
+ volatile int x;
+ int * volatile y = (int *) 0;
+ return !x && !y;
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext
+ if { (ac_try="$ac_compile"
+ case "(($ac_try" in
+   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+   *) ac_try_echo=$ac_try;;
+ esac
+ eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+ $as_echo "$ac_try_echo") >&5
+   (eval "$ac_compile") 2>conftest.er1
+   ac_status=$?
+   grep -v '^ *+' conftest.er1 >conftest.err
+   rm -f conftest.er1
+   cat conftest.err >&5
+   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } && {
+ 	 test -z "$ac_c_werror_flag" ||
+ 	 test ! -s conftest.err
+        } && test -s conftest.$ac_objext; then
+   ac_cv_c_volatile=yes
+ else
+   $as_echo "$as_me: failed program was:" >&5
+ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+ 	ac_cv_c_volatile=no
+ fi
+ 
+ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ fi
+ { $as_echo "$as_me:$LINENO: result: $ac_cv_c_volatile" >&5
+ $as_echo "$ac_cv_c_volatile" >&6; }
+ if test $ac_cv_c_volatile = no; then
+ 
+ cat >>confdefs.h <<\_ACEOF
+ #define volatile /**/
+ _ACEOF
+ 
+ fi
+ 
  { $as_echo "$as_me:$LINENO: checking for mode_t" >&5
  $as_echo_n "checking for mode_t... " >&6; }
  if test "${ac_cv_type_mode_t+set}" = set; then
*** ../vim-7.2.129/src/configure.in	Thu Nov 20 10:36:04 2008
--- src/configure.in	Sun Feb 22 21:47:44 2009
***************
*** 2148,2153 ****
--- 2148,2154 ----
  dnl Checks for typedefs, structures, and compiler characteristics.
  AC_PROG_GCC_TRADITIONAL
  AC_C_CONST
+ AC_C_VOLATILE
  AC_TYPE_MODE_T
  AC_TYPE_OFF_T
  AC_TYPE_PID_T
*** ../vim-7.2.129/src/config.h.in	Tue Jun 24 23:47:46 2008
--- src/config.h.in	Mon Feb 23 00:13:17 2009
***************
*** 50,55 ****
--- 50,58 ----
  /* Define to empty if the keyword does not work.  */
  #undef const
  
+ /* Define to empty if the keyword does not work.  */
+ #undef volatile
+ 
  /* Define to `int' if <sys/types.h> doesn't define.  */
  #undef mode_t
  
*** ../vim-7.2.129/src/globals.h	Tue Jan  6 16:13:42 2009
--- src/globals.h	Mon Mar  2 02:40:16 2009
***************
*** 482,489 ****
  /*
   * While executing external commands or in Ex mode, should not insert GUI
   * events in the input buffer: Set hold_gui_events to non-zero.
   */
! EXTERN int	hold_gui_events INIT(= 0);
  
  /*
   * When resizing the shell is postponed, remember the new size, and call
--- 482,491 ----
  /*
   * While executing external commands or in Ex mode, should not insert GUI
   * events in the input buffer: Set hold_gui_events to non-zero.
+  *
+  * volatile because it is used in signal handler sig_sysmouse().
   */
! EXTERN volatile int hold_gui_events INIT(= 0);
  
  /*
   * When resizing the shell is postponed, remember the new size, and call
***************
*** 597,603 ****
  EXTERN int	really_exiting INIT(= FALSE);
  				/* TRUE when we are sure to exit, e.g., after
  				 * a deadly signal */
! EXTERN int	full_screen INIT(= FALSE);
  				/* TRUE when doing full-screen output
  				 * otherwise only writing some messages */
  
--- 599,606 ----
  EXTERN int	really_exiting INIT(= FALSE);
  				/* TRUE when we are sure to exit, e.g., after
  				 * a deadly signal */
! /* volatile because it is used in signal handler deathtrap(). */
! EXTERN volatile int full_screen INIT(= FALSE);
  				/* TRUE when doing full-screen output
  				 * otherwise only writing some messages */
  
***************
*** 739,748 ****
   */
  EXTERN JMP_BUF lc_jump_env;	/* argument to SETJMP() */
  # ifdef SIGHASARG
! EXTERN int lc_signal;		/* catched signal number, 0 when no was signal
! 				   catched; used for mch_libcall() */
  # endif
! EXTERN int lc_active INIT(= FALSE); /* TRUE when lc_jump_env is valid. */
  #endif
  
  #if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT)
--- 747,758 ----
   */
  EXTERN JMP_BUF lc_jump_env;	/* argument to SETJMP() */
  # ifdef SIGHASARG
! /* volatile because it is used in signal handlers. */
! EXTERN volatile int lc_signal;	/* caught signal number, 0 when no was signal
! 				   caught; used for mch_libcall() */
  # endif
! /* volatile because it is used in signal handler deathtrap(). */
! EXTERN volatile int lc_active INIT(= FALSE); /* TRUE when lc_jump_env is valid. */
  #endif
  
  #if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT)
***************
*** 986,992 ****
  EXTERN FILE	*scriptout  INIT(= NULL);   /* stream to write script to */
  EXTERN int	read_cmd_fd INIT(= 0);	    /* fd to read commands from */
  
! EXTERN int	got_int INIT(= FALSE);	    /* set to TRUE when interrupt
  						signal occurred */
  #ifdef USE_TERM_CONSOLE
  EXTERN int	term_console INIT(= FALSE); /* set to TRUE when console used */
--- 996,1003 ----
  EXTERN FILE	*scriptout  INIT(= NULL);   /* stream to write script to */
  EXTERN int	read_cmd_fd INIT(= 0);	    /* fd to read commands from */
  
! /* volatile because it is used in signal handler catch_sigint(). */
! EXTERN volatile int got_int INIT(= FALSE);    /* set to TRUE when interrupt
  						signal occurred */
  #ifdef USE_TERM_CONSOLE
  EXTERN int	term_console INIT(= FALSE); /* set to TRUE when console used */
*** ../vim-7.2.129/src/os_unix.c	Sun Feb 22 02:51:37 2009
--- src/os_unix.c	Mon Mar  2 01:05:50 2009
***************
*** 181,187 ****
  	&& defined(FEAT_TITLE) && !defined(FEAT_GUI_GTK)
  # define SET_SIG_ALARM
  static RETSIGTYPE sig_alarm __ARGS(SIGPROTOARG);
! static int sig_alarm_called;
  #endif
  static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
  
--- 181,188 ----
  	&& defined(FEAT_TITLE) && !defined(FEAT_GUI_GTK)
  # define SET_SIG_ALARM
  static RETSIGTYPE sig_alarm __ARGS(SIGPROTOARG);
! /* volatile because it is used in signal handler sig_alarm(). */
! static volatile int sig_alarm_called;
  #endif
  static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
  
***************
*** 201,213 ****
  # define SIG_ERR	((RETSIGTYPE (*)())-1)
  #endif
  
! static int	do_resize = FALSE;
  #ifndef __EMX__
  static char_u	*extra_shell_arg = NULL;
  static int	show_shell_mess = TRUE;
  #endif
! static int	deadly_signal = 0;	    /* The signal we caught */
! static int	in_mch_delay = FALSE;	    /* sleeping in mch_delay() */
  
  static int curr_tmode = TMODE_COOK;	/* contains current terminal mode */
  
--- 202,217 ----
  # define SIG_ERR	((RETSIGTYPE (*)())-1)
  #endif
  
! /* volatile because it is used in signal handler sig_winch(). */
! static volatile int do_resize = FALSE;
  #ifndef __EMX__
  static char_u	*extra_shell_arg = NULL;
  static int	show_shell_mess = TRUE;
  #endif
! /* volatile because it is used in signal handler deathtrap(). */
! static volatile int deadly_signal = 0;	    /* The signal we caught */
! /* volatile because it is used in signal handler deathtrap(). */
! static volatile int in_mch_delay = FALSE;    /* sleeping in mch_delay() */
  
  static int curr_tmode = TMODE_COOK;	/* contains current terminal mode */
  
***************
*** 802,808 ****
  #endif
  
  /*
!  * We need correct potatotypes for a signal function, otherwise mean compilers
   * will barf when the second argument to signal() is ``wrong''.
   * Let me try it with a few tricky defines from my own osdef.h	(jw).
   */
--- 806,812 ----
  #endif
  
  /*
!  * We need correct prototypes for a signal function, otherwise mean compilers
   * will barf when the second argument to signal() is ``wrong''.
   * Let me try it with a few tricky defines from my own osdef.h	(jw).
   */
***************
*** 1068,1080 ****
      SIGRETURN;
  }
  
! #ifdef _REENTRANT
  /*
   * On Solaris with multi-threading, suspending might not work immediately.
   * Catch the SIGCONT signal, which will be used as an indication whether the
   * suspending has been done or not.
   */
! static int sigcont_received;
  static RETSIGTYPE sigcont_handler __ARGS(SIGPROTOARG);
  
  /*
--- 1072,1089 ----
      SIGRETURN;
  }
  
! #if defined(_REENTRANT) && defined(SIGCONT)
  /*
   * On Solaris with multi-threading, suspending might not work immediately.
   * Catch the SIGCONT signal, which will be used as an indication whether the
   * suspending has been done or not.
+  *
+  * On Linux, signal is not always handled immediately either.
+  * See https://bugs.launchpad.net/bugs/291373
+  *
+  * volatile because it is used in in signal handler sigcont_handler().
   */
! static volatile int sigcont_received;
  static RETSIGTYPE sigcont_handler __ARGS(SIGPROTOARG);
  
  /*
***************
*** 1118,1132 ****
      }
  # endif
  
! # ifdef _REENTRANT
      sigcont_received = FALSE;
  # endif
      kill(0, SIGTSTP);	    /* send ourselves a STOP signal */
! # ifdef _REENTRANT
!     /* When we didn't suspend immediately in the kill(), do it now.  Happens
!      * on multi-threaded Solaris. */
!     if (!sigcont_received)
! 	pause();
  # endif
  
  # ifdef FEAT_TITLE
--- 1127,1154 ----
      }
  # endif
  
! # if defined(_REENTRANT) && defined(SIGCONT)
      sigcont_received = FALSE;
  # endif
      kill(0, SIGTSTP);	    /* send ourselves a STOP signal */
! # if defined(_REENTRANT) && defined(SIGCONT)
!     /*
!      * Wait for the SIGCONT signal to be handled. It generally happens
!      * immediately, but somehow not all the time. Do not call pause()
!      * because there would be race condition which would hang Vim if
!      * signal happened in between the test of sigcont_received and the
!      * call to pause(). If signal is not yet received, call sleep(0)
!      * to just yield CPU. Signal should then be received. If somehow
!      * it's still not received, sleep 1, 2, 3 ms. Don't bother waiting
!      * further if signal is not received after 1+2+3+4 ms (not expected
!      * to happen).
!      */
!     {
! 	long wait;
! 	for (wait = 0; !sigcont_received && wait <= 3L; wait++)
! 	    /* Loop is not entered most of the time */
! 	    mch_delay(wait, FALSE);
!     }
  # endif
  
  # ifdef FEAT_TITLE
***************
*** 1175,1181 ****
  #ifdef SIGTSTP
      signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
  #endif
! #ifdef _REENTRANT
      signal(SIGCONT, sigcont_handler);
  #endif
  
--- 1197,1203 ----
  #ifdef SIGTSTP
      signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
  #endif
! #if defined(_REENTRANT) && defined(SIGCONT)
      signal(SIGCONT, sigcont_handler);
  #endif
  
***************
*** 1234,1240 ****
  reset_signals()
  {
      catch_signals(SIG_DFL, SIG_DFL);
! #ifdef _REENTRANT
      /* SIGCONT isn't in the list, because its default action is ignore */
      signal(SIGCONT, SIG_DFL);
  #endif
--- 1256,1262 ----
  reset_signals()
  {
      catch_signals(SIG_DFL, SIG_DFL);
! #if defined(_REENTRANT) && defined(SIGCONT)
      /* SIGCONT isn't in the list, because its default action is ignore */
      signal(SIGCONT, SIG_DFL);
  #endif
***************
*** 5899,5905 ****
--- 5921,5929 ----
  	     * we are going to suspend or starting an external process
  	     * so we shouldn't  have problem with this
  	     */
+ # ifdef SIGTSTP
  	    signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
+ # endif
  	    return 1; /* succeed */
  	}
  	if (gpm_fd == -2)
*** ../vim-7.2.129/src/version.c	Mon Mar  2 02:11:09 2009
--- src/version.c	Mon Mar  2 02:36:00 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     130,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
148. You find it easier to dial-up the National Weather Service
     Weather/your_town/now.html than to simply look out the window.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.131
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.131
Problem:    When 'keymap' is cleared may still use the cursor highlighting for
            when it's enabled.
Solution:   Reset 'iminsert' and 'imsearch'. (partly by Dominique Pelle)
            Also avoid ":setlocal" for these options have a global effect.
Files:      src/option.c


*** ../vim-7.2.130/src/option.c	Sat Feb 21 20:27:00 2009
--- src/option.c	Wed Mar  4 04:09:51 2009
***************
*** 5797,5810 ****
  	/* load or unload key mapping tables */
  	errmsg = keymap_init();
  
! 	/* When successfully installed a new keymap switch on using it. */
! 	if (*curbuf->b_p_keymap != NUL && errmsg == NULL)
  	{
! 	    curbuf->b_p_iminsert = B_IMODE_LMAP;
! 	    if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
! 		curbuf->b_p_imsearch = B_IMODE_LMAP;
! 	    set_iminsert_global();
! 	    set_imsearch_global();
  # ifdef FEAT_WINDOWS
  	    status_redraw_curbuf();
  # endif
--- 5797,5824 ----
  	/* load or unload key mapping tables */
  	errmsg = keymap_init();
  
! 	if (errmsg == NULL)
  	{
! 	    if (*curbuf->b_p_keymap != NUL)
! 	    {
! 		/* Installed a new keymap, switch on using it. */
! 		curbuf->b_p_iminsert = B_IMODE_LMAP;
! 		if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
! 		    curbuf->b_p_imsearch = B_IMODE_LMAP;
! 	    }
! 	    else
! 	    {
! 		/* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */
! 		if (curbuf->b_p_iminsert == B_IMODE_LMAP)
! 		    curbuf->b_p_iminsert = B_IMODE_NONE;
! 		if (curbuf->b_p_imsearch == B_IMODE_LMAP)
! 		    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;
! 	    }
! 	    if ((opt_flags & OPT_LOCAL) == 0)
! 	    {
! 		set_iminsert_global();
! 		set_imsearch_global();
! 	    }
  # ifdef FEAT_WINDOWS
  	    status_redraw_curbuf();
  # endif
*** ../vim-7.2.130/src/version.c	Mon Mar  2 02:44:54 2009
--- src/version.c	Wed Mar  4 04:10:32 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     131,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
157. You fum through a magazine, you first check to see if it has a web
     address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.132
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.132
Problem:    When changing directory during a SwapExists autocmd freed memory
            may be accessed. (Dominique Pelle)
Solution:   Add the allbuf_lock flag.
Files:      src/ex_getln.c, src/globals.h, src/fileio.c,
            src/proto/ex_getln.pro
    

*** ../vim-7.2.131/src/ex_getln.c	Mon Mar  2 02:11:09 2009
--- src/ex_getln.c	Mon Mar  2 00:53:39 2009
***************
*** 2000,2007 ****
  
  #if defined(FEAT_AUTOCMD) || defined(PROTO)
  /*
!  * Check if "curbuf_lock" is set and return TRUE when it is and give an error
!  * message.
   */
      int
  curbuf_locked()
--- 2000,2007 ----
  
  #if defined(FEAT_AUTOCMD) || defined(PROTO)
  /*
!  * Check if "curbuf_lock" or "allbuf_lock" is set and return TRUE when it is
!  * and give an error message.
   */
      int
  curbuf_locked()
***************
*** 2011,2016 ****
--- 2011,2031 ----
  	EMSG(_("E788: Not allowed to edit another buffer now"));
  	return TRUE;
      }
+     return allbuf_locked();
+ }
+ 
+ /*
+  * Check if "allbuf_lock" is set and return TRUE when it is and give an error
+  * message.
+  */
+     int
+ allbuf_locked()
+ {
+     if (allbuf_lock > 0)
+     {
+ 	EMSG(_("E811: Not allowed to change buffer information now"));
+ 	return TRUE;
+     }
      return FALSE;
  }
  #endif
*** ../vim-7.2.131/src/globals.h	Mon Mar  2 02:44:54 2009
--- src/globals.h	Mon Mar  2 02:40:16 2009
***************
*** 619,624 ****
--- 619,629 ----
  EXTERN int	curbuf_lock INIT(= 0);
  				/* non-zero when the current buffer can't be
  				 * changed.  Used for FileChangedRO. */
+ EXTERN int	allbuf_lock INIT(= 0);
+ 				/* non-zero when no buffer name can be
+ 				 * changed, no buffer can be deleted and
+ 				 * current directory can't be changed.
+ 				 * Used for SwapExists et al. */
  #endif
  #ifdef FEAT_EVAL
  # define HAVE_SANDBOX
*** ../vim-7.2.131/src/fileio.c	Wed Dec 31 16:20:54 2008
--- src/fileio.c	Sun Mar  1 23:37:10 2009
***************
*** 69,75 ****
  static int au_find_group __ARGS((char_u *name));
  
  # define AUGROUP_DEFAULT    -1	    /* default autocmd group */
! # define AUGROUP_ERROR	    -2	    /* errornouse autocmd group */
  # define AUGROUP_ALL	    -3	    /* all autocmd groups */
  #endif
  
--- 69,75 ----
  static int au_find_group __ARGS((char_u *name));
  
  # define AUGROUP_DEFAULT    -1	    /* default autocmd group */
! # define AUGROUP_ERROR	    -2	    /* erroneous autocmd group */
  # define AUGROUP_ALL	    -3	    /* all autocmd groups */
  #endif
  
***************
*** 144,150 ****
  # endif
  #endif
  static int move_lines __ARGS((buf_T *frombuf, buf_T *tobuf));
! 
  
      void
  filemess(buf, name, s, attr)
--- 144,152 ----
  # endif
  #endif
  static int move_lines __ARGS((buf_T *frombuf, buf_T *tobuf));
! #ifdef FEAT_AUTOCMD
! static char *e_auchangedbuf = N_("E812: Autocommands changed buffer or buffer name");
! #endif
  
      void
  filemess(buf, name, s, attr)
***************
*** 295,300 ****
--- 297,315 ----
      int		conv_restlen = 0;	/* nr of bytes in conv_rest[] */
  #endif
  
+ #ifdef FEAT_AUTOCMD
+     /* Remember the initial values of curbuf, curbuf->b_ffname and
+      * curbuf->b_fname to detect whether they are altered as a result of
+      * executing nasty autocommands.  Also check if "fname" and "sfname"
+      * point to one of these values. */
+     buf_T   *old_curbuf = curbuf;
+     char_u  *old_b_ffname = curbuf->b_ffname;
+     char_u  *old_b_fname = curbuf->b_fname;
+     int     using_b_ffname = (fname == curbuf->b_ffname)
+ 					      || (sfname == curbuf->b_ffname);
+     int     using_b_fname = (fname == curbuf->b_fname)
+ 					       || (sfname == curbuf->b_fname);
+ #endif
      write_no_eol_lnum = 0;	/* in case it was set by the previous read */
  
      /*
***************
*** 589,595 ****
--- 604,624 ----
  #ifdef FEAT_QUICKFIX
  		    if (!bt_dontwrite(curbuf))
  #endif
+ 		    {
  			check_need_swap(newfile);
+ #ifdef FEAT_AUTOCMD
+ 			/* SwapExists autocommand may mess things up */
+ 			if (curbuf != old_curbuf
+ 				|| (using_b_ffname
+ 					&& (old_b_ffname != curbuf->b_ffname))
+ 				|| (using_b_fname
+ 					 && (old_b_fname != curbuf->b_fname)))
+ 			{
+ 			    EMSG(_(e_auchangedbuf));
+ 			    return FAIL;
+ 			}
+ #endif
+ 		    }
  		    if (dir_of_file_exists(fname))
  			filemess(curbuf, sfname, (char_u *)_("[New File]"), 0);
  		    else
***************
*** 668,673 ****
--- 697,713 ----
  #endif
      {
  	check_need_swap(newfile);
+ #ifdef FEAT_AUTOCMD
+ 	if (!read_stdin && (curbuf != old_curbuf
+ 		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
+ 		|| (using_b_fname && (old_b_fname != curbuf->b_fname))))
+ 	{
+ 	    EMSG(_(e_auchangedbuf));
+ 	    if (!read_buffer)
+ 		close(fd);
+ 	    return FAIL;
+ 	}
+ #endif
  #ifdef UNIX
  	/* Set swap file protection bits after creating it. */
  	if (swap_mode > 0 && curbuf->b_ml.ml_mfp->mf_fname != NULL)
***************
*** 698,704 ****
      {
  	int	m = msg_scroll;
  	int	n = msg_scrolled;
- 	buf_T	*old_curbuf = curbuf;
  
  	/*
  	 * The file must be closed again, the autocommands may want to change
--- 738,743 ----
***************
*** 740,747 ****
--- 779,791 ----
  	/*
  	 * Don't allow the autocommands to change the current buffer.
  	 * Try to re-open the file.
+ 	 *
+ 	 * Don't allow the autocommands to change the buffer name either
+ 	 * (cd for example) if it invalidates fname or sfname.
  	 */
  	if (!read_stdin && (curbuf != old_curbuf
+ 		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
+ 		|| (using_b_fname && (old_b_fname != curbuf->b_fname))
  		|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))
  	{
  	    --no_wait_return;
***************
*** 6320,6326 ****
  
      if (!stuff_empty() || global_busy || !typebuf_typed()
  #ifdef FEAT_AUTOCMD
! 			|| autocmd_busy || curbuf_lock > 0
  #endif
  					)
  	need_check_timestamps = TRUE;		/* check later */
--- 6364,6370 ----
  
      if (!stuff_empty() || global_busy || !typebuf_typed()
  #ifdef FEAT_AUTOCMD
! 			|| autocmd_busy || curbuf_lock > 0 || allbuf_lock > 0
  #endif
  					)
  	need_check_timestamps = TRUE;		/* check later */
***************
*** 6522,6529 ****
--- 6566,6575 ----
  	    set_vim_var_string(VV_FCS_REASON, (char_u *)reason, -1);
  	    set_vim_var_string(VV_FCS_CHOICE, (char_u *)"", -1);
  # endif
+ 	    ++allbuf_lock;
  	    n = apply_autocmds(EVENT_FILECHANGEDSHELL,
  				      buf->b_fname, buf->b_fname, FALSE, buf);
+ 	    --allbuf_lock;
  	    busy = FALSE;
  	    if (n)
  	    {
*** ../vim-7.2.131/src/proto/ex_getln.pro	Fri Nov 28 10:59:57 2008
--- src/proto/ex_getln.pro	Sun Mar  1 00:27:12 2009
***************
*** 4,9 ****
--- 4,10 ----
  int text_locked __ARGS((void));
  void text_locked_msg __ARGS((void));
  int curbuf_locked __ARGS((void));
+ int allbuf_locked __ARGS((void));
  char_u *getexline __ARGS((int c, void *dummy, int indent));
  char_u *getexmodeline __ARGS((int promptc, void *dummy, int indent));
  int cmdline_overstrike __ARGS((void));
*** ../vim-7.2.131/src/version.c	Wed Mar  4 04:11:56 2009
--- src/version.c	Thu Mar  5 03:08:54 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     132,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
168. You have your own domain name.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.133
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.133
Problem:    ":diffoff!" changes settings in windows not in diff mode.
Solution:   Only change settings in other windows when 'diff' is set, always
	    do it for the current window. (Lech Lorens)
Files:	    src/diff.c


*** ../vim-7.2.132/src/diff.c	Thu Jan 22 20:48:07 2009
--- src/diff.c	Fri Mar  6 04:17:41 2009
***************
*** 1153,1159 ****
  
      for (wp = firstwin; wp != NULL; wp = wp->w_next)
      {
! 	if (wp == curwin || eap->forceit)
  	{
  	    /* Set 'diff', 'scrollbind' off and 'wrap' on. */
  	    wp->w_p_diff = FALSE;
--- 1153,1159 ----
  
      for (wp = firstwin; wp != NULL; wp = wp->w_next)
      {
! 	if (wp == curwin || (eap->forceit && wp->w_p_diff))
  	{
  	    /* Set 'diff', 'scrollbind' off and 'wrap' on. */
  	    wp->w_p_diff = FALSE;
*** ../vim-7.2.132/src/version.c	Thu Mar  5 03:13:51 2009
--- src/version.c	Wed Mar 11 12:45:10 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     133,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
192. Your boss asks you to "go fer" coffee and you come up with 235 FTP sites.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.134
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.134
Problem:    Warning for discarding "const" from pointer.
Solution:   Don't pass const pointer to mch_memmove().
Files:	    src/fileio.c


*** ../vim-7.2.133/src/fileio.c	Thu Mar  5 03:13:51 2009
--- src/fileio.c	Wed Mar 11 12:59:35 2009
***************
*** 5288,5300 ****
  	    /* Convert with iconv(). */
  	    if (ip->bw_restlen > 0)
  	    {
  		/* Need to concatenate the remainder of the previous call and
  		 * the bytes of the current call.  Use the end of the
  		 * conversion buffer for this. */
  		fromlen = len + ip->bw_restlen;
! 		from = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;
! 		mch_memmove((void *)from, ip->bw_rest, (size_t)ip->bw_restlen);
! 		mch_memmove((void *)(from + ip->bw_restlen), buf, (size_t)len);
  		tolen = ip->bw_conv_buflen - fromlen;
  	    }
  	    else
--- 5288,5303 ----
  	    /* Convert with iconv(). */
  	    if (ip->bw_restlen > 0)
  	    {
+ 		char *fp;
+ 
  		/* Need to concatenate the remainder of the previous call and
  		 * the bytes of the current call.  Use the end of the
  		 * conversion buffer for this. */
  		fromlen = len + ip->bw_restlen;
! 		fp = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;
! 		mch_memmove(fp, ip->bw_rest, (size_t)ip->bw_restlen);
! 		mch_memmove(fp + ip->bw_restlen, buf, (size_t)len);
! 		from = fp;
  		tolen = ip->bw_conv_buflen - fromlen;
  	    }
  	    else
*** ../vim-7.2.133/src/version.c	Wed Mar 11 12:45:44 2009
--- src/version.c	Wed Mar 11 13:08:25 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     134,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
193. You ask your girlfriend to drive home so you can sit back with
     your PDA and download the information to your laptop

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.135
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.135
Problem:    Memory leak when redefining user command with complete argument.
Solution:   Free the old complete argument. (Dominique Pelle)
Files:	    src/ex_docmd.c


*** ../vim-7.2.134/src/ex_docmd.c	Sun Mar  1 02:43:50 2009
--- src/ex_docmd.c	Wed Mar 11 11:13:31 2009
***************
*** 5124,5130 ****
  	    }
  
  	    vim_free(cmd->uc_rep);
! 	    cmd->uc_rep = 0;
  	    break;
  	}
  
--- 5124,5134 ----
  	    }
  
  	    vim_free(cmd->uc_rep);
! 	    cmd->uc_rep = NULL;
! #if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
! 	    vim_free(cmd->uc_compl_arg);
! 	    cmd->uc_compl_arg = NULL;
! #endif
  	    break;
  	}
  
***************
*** 5941,5947 ****
      for (;;)
      {
  	p = cmd->uc_rep;    /* source */
! 	q = buf;	    /* destinateion */
  	totlen = 0;
  
  	for (;;)
--- 5945,5951 ----
      for (;;)
      {
  	p = cmd->uc_rep;    /* source */
! 	q = buf;	    /* destination */
  	totlen = 0;
  
  	for (;;)
***************
*** 7846,7851 ****
--- 7850,7858 ----
  {
      vim_free(prev_dir);
      prev_dir = NULL;
+ 
+     vim_free(globaldir);
+     globaldir = NULL;
  }
  #endif
  
*** ../vim-7.2.134/src/version.c	Wed Mar 11 13:09:30 2009
--- src/version.c	Wed Mar 11 15:06:23 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     135,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
194. Your business cards contain your e-mail and home page address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.136
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.136 (after 7.2.132)
Problem:    ":cd" is still possible in a SwapExists autocmd.
Solution:   Check the allbuf_lock flag in ex_cd().
Files:	    src/ex_docmd.c


*** ../vim-7.2.135/src/ex_docmd.c	Wed Mar 11 15:09:07 2009
--- src/ex_docmd.c	Wed Mar 11 11:13:31 2009
***************
*** 7875,7880 ****
--- 7875,7884 ----
      else
  #endif
      {
+ #ifdef FEAT_AUTOCMD
+ 	if (allbuf_locked())
+ 	    return;
+ #endif
  	if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged()
  							     && !eap->forceit)
  	{
*** ../vim-7.2.135/src/version.c	Wed Mar 11 15:09:07 2009
--- src/version.c	Wed Mar 11 15:35:36 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     136,
  /**/

-- 
Press any key to continue, press any other key to quit.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.137
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Note: The special characters in the patch may cause problems.

Patch 7.2.137
Problem:    When 'virtualedit' is set, a left shift of a blockwise selection
	    that starts and ends inside a tab shifts too much. (Helmut
	    Stiegler)
Solution:   Redo the block left shift code. (Lech Lorens)
Files:	    src/ops.c, src/testdir/Makefile, src/testdir/test66.in,
	    src/testdir/test66.ok


*** ../vim-7.2.136/src/ops.c	Wed Dec  3 13:38:00 2008
--- src/ops.c	Thu Mar  5 04:47:09 2009
***************
*** 72,82 ****
   */
  struct block_def
  {
!     int		startspaces;	/* 'extra' cols of first char */
!     int		endspaces;	/* 'extra' cols of first char */
      int		textlen;	/* chars in block */
!     char_u	*textstart;	/* pointer to 1st char in block */
!     colnr_T	textcol;	/* cols of chars (at least part.) in block */
      colnr_T	start_vcol;	/* start col of 1st char wholly inside block */
      colnr_T	end_vcol;	/* start col of 1st char wholly after block */
  #ifdef FEAT_VISUALEXTRA
--- 72,82 ----
   */
  struct block_def
  {
!     int		startspaces;	/* 'extra' cols before first char */
!     int		endspaces;	/* 'extra' cols after last char */
      int		textlen;	/* chars in block */
!     char_u	*textstart;	/* pointer to 1st char (partially) in block */
!     colnr_T	textcol;	/* index of chars (partially) in block */
      colnr_T	start_vcol;	/* start col of 1st char wholly inside block */
      colnr_T	end_vcol;	/* start col of 1st char wholly after block */
  #ifdef FEAT_VISUALEXTRA
***************
*** 382,396 ****
  {
      int			left = (oap->op_type == OP_LSHIFT);
      int			oldstate = State;
!     int			total, split;
!     char_u		*newp, *oldp, *midp, *ptr;
      int			oldcol = curwin->w_cursor.col;
      int			p_sw = (int)curbuf->b_p_sw;
      int			p_ts = (int)curbuf->b_p_ts;
      struct block_def	bd;
-     int			internal = 0;
      int			incr;
!     colnr_T		vcol, col = 0, ws_vcol;
      int			i = 0, j = 0;
      int			len;
  
--- 382,395 ----
  {
      int			left = (oap->op_type == OP_LSHIFT);
      int			oldstate = State;
!     int			total;
!     char_u		*newp, *oldp;
      int			oldcol = curwin->w_cursor.col;
      int			p_sw = (int)curbuf->b_p_sw;
      int			p_ts = (int)curbuf->b_p_ts;
      struct block_def	bd;
      int			incr;
!     colnr_T		ws_vcol;
      int			i = 0, j = 0;
      int			len;
  
***************
*** 456,522 ****
      }
      else /* left */
      {
! 	vcol = oap->start_vcol;
! 	/* walk vcol past ws to be removed */
! 	for (midp = oldp + bd.textcol;
! 	      vcol < (oap->start_vcol + total) && vim_iswhite(*midp); )
! 	{
! 	    incr = lbr_chartabsize_adv(&midp, (colnr_T)vcol);
! 	    vcol += incr;
! 	}
! 	/* internal is the block-internal ws replacing a split TAB */
! 	if (vcol > (oap->start_vcol + total))
! 	{
! 	    /* we have to split the TAB *(midp-1) */
! 	    internal = vcol - (oap->start_vcol + total);
! 	}
! 	/* if 'expandtab' is not set, use TABs */
  
! 	split = bd.startspaces + internal;
! 	if (split > 0)
! 	{
! 	    if (!curbuf->b_p_et)
! 	    {
! 		for (ptr = oldp, col = 0; ptr < oldp+bd.textcol; )
! 		    col += lbr_chartabsize_adv(&ptr, (colnr_T)col);
  
! 		/* col+1 now equals the start col of the first char of the
! 		 * block (may be < oap.start_vcol if we're splitting a TAB) */
! 		i = ((col % p_ts) + split) / p_ts; /* number of tabs */
! 	    }
! 	    if (i)
! 		j = ((col % p_ts) + split) % p_ts; /* number of spp */
! 	    else
! 		j = split;
! 	}
  
! 	newp = alloc_check(bd.textcol + i + j + (unsigned)STRLEN(midp) + 1);
! 	if (newp == NULL)
! 	    return;
! 	vim_memset(newp, NUL, (size_t)(bd.textcol + i + j + STRLEN(midp) + 1));
  
! 	/* copy first part we want to keep */
! 	mch_memmove(newp, oldp, (size_t)bd.textcol);
! 	/* Now copy any TABS and spp to ensure correct alignment! */
! 	while (vim_iswhite(*midp))
  	{
! 	    if (*midp == TAB)
! 		i++;
! 	    else /*space */
! 		j++;
! 	    midp++;
  	}
! 	/* We might have an extra TAB worth of spp now! */
! 	if (j / p_ts && !curbuf->b_p_et)
  	{
! 	    i++;
! 	    j -= p_ts;
  	}
- 	copy_chars(newp + bd.textcol, (size_t)i, TAB);
- 	copy_spaces(newp + bd.textcol + i, (size_t)j);
  
! 	/* the end */
! 	STRMOVE(newp + STRLEN(newp), midp);
      }
      /* replace the line */
      ml_replace(curwin->w_cursor.lnum, newp, FALSE);
--- 455,543 ----
      }
      else /* left */
      {
! 	colnr_T	    destination_col;	/* column to which text in block will
! 					   be shifted */
! 	char_u	    *verbatim_copy_end;	/* end of the part of the line which is
! 					   copied verbatim */
! 	colnr_T	    verbatim_copy_width;/* the (displayed) width of this part
! 					   of line */
! 	unsigned    fill;		/* nr of spaces that replace a TAB */
! 	unsigned    new_line_len;	/* the length of the line after the
! 					   block shift */
! 	size_t	    block_space_width;
! 	size_t	    shift_amount;
! 	char_u	    *non_white = bd.textstart;
! 	colnr_T	    non_white_col;
  
! 	/*
! 	 * Firstly, let's find the first non-whitespace character that is
! 	 * displayed after the block's start column and the character's column
! 	 * number. Also, let's calculate the width of all the whitespace
! 	 * characters that are displayed in the block and precede the searched
! 	 * non-whitespace character.
! 	 */
  
! 	/* If "bd.startspaces" is set, "bd.textstart" points to the character,
! 	 * the part of which is displayed at the block's beginning. Let's start
! 	 * searching from the next character. */
! 	if (bd.startspaces)
! 	    mb_ptr_adv(non_white);
  
! 	/* The character's column is in "bd.start_vcol".  */
! 	non_white_col = bd.start_vcol;
  
! 	while (vim_iswhite(*non_white))
  	{
! 	    incr = lbr_chartabsize_adv(&non_white, non_white_col);
! 	    non_white_col += incr;
  	}
! 
! 	block_space_width = non_white_col - oap->start_vcol;
! 	/* We will shift by "total" or "block_space_width", whichever is less.
! 	 */
! 	shift_amount = (block_space_width < total? block_space_width: total);
! 
! 	/* The column to which we will shift the text.  */
! 	destination_col = non_white_col - shift_amount;
! 
! 	/* Now let's find out how much of the beginning of the line we can
! 	 * reuse without modification.  */
! 	verbatim_copy_end = bd.textstart;
! 	verbatim_copy_width = bd.start_vcol;
! 
! 	/* If "bd.startspaces" is set, "bd.textstart" points to the character
! 	 * preceding the block. We have to subtract its width to obtain its
! 	 * column number.  */
! 	if (bd.startspaces)
! 	    verbatim_copy_width -= bd.start_char_vcols;
! 	while (verbatim_copy_width < destination_col)
  	{
! 	    incr = lbr_chartabsize(verbatim_copy_end, verbatim_copy_width);
! 	    if (verbatim_copy_width + incr > destination_col)
! 		break;
! 	    verbatim_copy_width += incr;
! 	    mb_ptr_adv(verbatim_copy_end);
  	}
  
! 	/* If "destination_col" is different from the width of the initial
! 	 * part of the line that will be copied, it means we encountered a tab
! 	 * character, which we will have to partly replace with spaces.  */
! 	fill = destination_col - verbatim_copy_width;
! 
! 	/* The replacement line will consist of:
! 	 * - the beginning of the original line up to "verbatim_copy_end",
! 	 * - "fill" number of spaces,
! 	 * - the rest of the line, pointed to by non_white.  */
! 	new_line_len = (unsigned)(verbatim_copy_end - oldp)
! 		       + fill
! 		       + (unsigned)STRLEN(non_white) + 1;
! 
! 	newp = alloc_check(new_line_len);
! 	if (newp == NULL)
! 	    return;
! 	mch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));
! 	copy_spaces(newp + (verbatim_copy_end - oldp), (size_t)fill);
! 	STRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);
      }
      /* replace the line */
      ml_replace(curwin->w_cursor.lnum, newp, FALSE);
***************
*** 4851,4857 ****
   * - textlen includes the first/last char to be (partly) deleted
   * - start/endspaces is the number of columns that are taken by the
   *   first/last deleted char minus the number of columns that have to be
!  *   deleted.  for yank and tilde:
   * - textlen includes the first/last char to be wholly yanked
   * - start/endspaces is the number of columns of the first/last yanked char
   *   that are to be yanked.
--- 4872,4879 ----
   * - textlen includes the first/last char to be (partly) deleted
   * - start/endspaces is the number of columns that are taken by the
   *   first/last deleted char minus the number of columns that have to be
!  *   deleted.
!  * for yank and tilde:
   * - textlen includes the first/last char to be wholly yanked
   * - start/endspaces is the number of columns of the first/last yanked char
   *   that are to be yanked.
*** ../vim-7.2.136/src/testdir/Makefile	Wed Sep 10 18:25:18 2008
--- src/testdir/Makefile	Thu Mar  5 04:53:58 2009
***************
*** 20,26 ****
  		test48.out test49.out test51.out test52.out test53.out \
  		test54.out test55.out test56.out test57.out test58.out \
  		test59.out test60.out test61.out test62.out test63.out \
! 		test64.out test65.out
  
  SCRIPTS_GUI = test16.out
  
--- 20,26 ----
  		test48.out test49.out test51.out test52.out test53.out \
  		test54.out test55.out test56.out test57.out test58.out \
  		test59.out test60.out test61.out test62.out test63.out \
! 		test64.out test65.out test66.out
  
  SCRIPTS_GUI = test16.out
  
*** ../vim-7.2.136/src/testdir/test66.in	Wed Mar 11 16:24:44 2009
--- src/testdir/test66.in	Wed Mar 11 11:52:57 2009
***************
*** 0 ****
--- 1,25 ----
+ 
+ Test for visual block shift and tab characters.
+ 
+ STARTTEST
+ :so small.vim
+ /^abcdefgh
+ 4jI    j<<11|D
+ 7|a		
+ 7|a		   
+ 7|a	       	4k13|4j<
+ :$-4,$w! test.out
+ :$-4,$s/\s\+//g
+ 4kI    j<<
+ 7|a		
+ 7|a					
+ 7|a	       		4k13|4j3<
+ :$-4,$w >> test.out
+ :qa!
+ ENDTEST
+ 
+ abcdefghijklmnopqrstuvwxyz
+ abcdefghijklmnopqrstuvwxyz
+ abcdefghijklmnopqrstuvwxyz
+ abcdefghijklmnopqrstuvwxyz
+ abcdefghijklmnopqrstuvwxyz
*** ../vim-7.2.136/src/testdir/test66.ok	Wed Mar 11 16:24:44 2009
--- src/testdir/test66.ok	Thu Mar  5 04:39:36 2009
***************
*** 0 ****
--- 1,10 ----
+     abcdefghijklmnopqrstuvwxyz
+ abcdefghij
+     abc	    defghijklmnopqrstuvwxyz
+     abc	    defghijklmnopqrstuvwxyz
+     abc	    defghijklmnopqrstuvwxyz
+     abcdefghijklmnopqrstuvwxyz
+ abcdefghij
+     abc	    defghijklmnopqrstuvwxyz
+     abc		defghijklmnopqrstuvwxyz
+     abc	    defghijklmnopqrstuvwxyz
*** ../vim-7.2.136/src/version.c	Wed Mar 11 15:36:01 2009
--- src/version.c	Wed Mar 11 16:23:07 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     137,
  /**/

-- 
% cat /usr/include/sys/errno.h
#define	EPERM		1		/* Operation not permitted */
#define	ENOENT		2		/* No such file or directory */
#define	ESRCH		3		/* No such process */
[...]
#define EMACS		666		/* Too many macros */
%

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.138 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.138 (extra part of 7.2.137)
Problem:    See 7.2.137.
Solution:   See 7.2.137.
Files:	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_ming.mak, src/testdir/Make_os2.mak,
	    src/testdir/Make_vms.mms


*** ../vim-7.2.137/src/testdir/Make_amiga.mak	Tue Jun 24 23:46:42 2008
--- src/testdir/Make_amiga.mak	Thu Mar  5 04:49:38 2009
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out test64.out test65.out
  
  .SUFFIXES: .in .out
  
--- 25,32 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out test64.out test65.out \
! 		test66.out
  
  .SUFFIXES: .in .out
  
***************
*** 110,112 ****
--- 111,114 ----
  test63.out: test63.in
  test64.out: test64.in
  test65.out: test65.in
+ test66.out: test66.in
*** ../vim-7.2.137/src/testdir/Make_dos.mak	Tue Jun 24 23:39:51 2008
--- src/testdir/Make_dos.mak	Thu Mar  5 04:52:47 2009
***************
*** 26,32 ****
  		test15.out test17.out test18.out test21.out test26.out \
  		test30.out test31.out test32.out test33.out test34.out \
  		test37.out test38.out test39.out test40.out test41.out \
! 		test42.out test52.out test65.out
  
  SCRIPTS32 =	test50.out
  
--- 26,32 ----
  		test15.out test17.out test18.out test21.out test26.out \
  		test30.out test31.out test32.out test33.out test34.out \
  		test37.out test38.out test39.out test40.out test41.out \
! 		test42.out test52.out test65.out test66.out
  
  SCRIPTS32 =	test50.out
  
*** ../vim-7.2.137/src/testdir/Make_ming.mak	Sat Sep 20 16:26:10 2008
--- src/testdir/Make_ming.mak	Thu Mar  5 04:53:16 2009
***************
*** 45,51 ****
  		test15.out test17.out test18.out test21.out test26.out \
  		test30.out test31.out test32.out test33.out test34.out \
  		test37.out test38.out test39.out test40.out test41.out \
! 		test42.out test52.out test65.out
  
  SCRIPTS32 =	test50.out
  
--- 45,51 ----
  		test15.out test17.out test18.out test21.out test26.out \
  		test30.out test31.out test32.out test33.out test34.out \
  		test37.out test38.out test39.out test40.out test41.out \
! 		test42.out test52.out test65.out test66.out
  
  SCRIPTS32 =	test50.out
  
*** ../vim-7.2.137/src/testdir/Make_os2.mak	Tue Jun 24 22:37:41 2008
--- src/testdir/Make_os2.mak	Thu Mar  5 04:53:31 2009
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out test64.out test65.out
  
  .SUFFIXES: .in .out
  
--- 25,32 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out test64.out test65.out \
! 		test66.out
  
  .SUFFIXES: .in .out
  
*** ../vim-7.2.137/src/testdir/Make_vms.mms	Mon Sep  1 16:50:09 2008
--- src/testdir/Make_vms.mms	Thu Mar  5 04:53:42 2009
***************
*** 4,10 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2008 Aug 19
  #
  # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
--- 4,10 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2009 Mar 05
  #
  # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
***************
*** 68,74 ****
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test60.out \
! 	 test61.out test62.out test63.out test64.out test65.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
--- 68,75 ----
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test60.out \
! 	 test61.out test62.out test63.out test64.out test65.out \
! 	 test66.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
*** ../vim-7.2.137/src/version.c	Wed Mar 11 16:26:01 2009
--- src/version.c	Wed Mar 11 16:35:06 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     138,
  /**/

-- 
Some of the well know MS-Windows errors:
	ESLEEP		Operator fell asleep
	ENOERR		No error yet
	EDOLLAR		OS too expensive
	EWINDOWS	MS-Windows loaded, system in danger

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.139
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.139
Problem:    Crash when 'virtualedit' is "all". (James Vega)
Solution:   Avoid overflow when column is MAXCOL. (Dominique Pelle)
Files:	    src/misc2.c


*** ../vim-7.2.138/src/misc2.c	Tue Feb 24 04:28:40 2009
--- src/misc2.c	Wed Mar 11 16:45:05 2009
***************
*** 496,502 ****
  {
      colnr_T len;
  #ifdef FEAT_VIRTUALEDIT
!     colnr_T oldcol = curwin->w_cursor.col + curwin->w_cursor.coladd;
  #endif
  
      len = (colnr_T)STRLEN(ml_get_curline());
--- 496,503 ----
  {
      colnr_T len;
  #ifdef FEAT_VIRTUALEDIT
!     colnr_T oldcol = curwin->w_cursor.col;
!     colnr_T oldcoladd = curwin->w_cursor.col + curwin->w_cursor.coladd;
  #endif
  
      len = (colnr_T)STRLEN(ml_get_curline());
***************
*** 535,541 ****
      if (oldcol == MAXCOL)
  	curwin->w_cursor.coladd = 0;
      else if (ve_flags == VE_ALL)
! 	curwin->w_cursor.coladd = oldcol - curwin->w_cursor.col;
  #endif
  }
  
--- 536,548 ----
      if (oldcol == MAXCOL)
  	curwin->w_cursor.coladd = 0;
      else if (ve_flags == VE_ALL)
!     {
! 	if (oldcoladd > curwin->w_cursor.col)
! 	    curwin->w_cursor.coladd = oldcoladd - curwin->w_cursor.col;
! 	else
! 	    /* avoid weird number when there is a miscalculation or overflow */
! 	    curwin->w_cursor.coladd = 0;
!     }
  #endif
  }
  
*** ../vim-7.2.138/src/version.c	Wed Mar 11 16:36:04 2009
--- src/version.c	Wed Mar 11 17:26:50 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     139,
  /**/

-- 
Some of the well know MS-Windows errors:
	EHUH		Unexpected error
	EUSER		User error, not our fault!
	EGOD		Horrible problem, god knows what has happened
	EERR		Errornous error: nothing wrong

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.140
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.140
Problem:    Diff highlighting isn't displayed before the Visual area if it
	    starts at the cursor position. (Markus Heidelberg)
Solution:   Also check fromcol_prev.
Files:	    src/screen.c


*** ../vim-7.2.139/src/screen.c	Sun Feb 22 21:12:22 2009
--- src/screen.c	Wed Mar 11 13:59:24 2009
***************
*** 3555,3561 ****
  		/* Use line_attr when not in the Visual or 'incsearch' area
  		 * (area_attr may be 0 when "noinvcur" is set). */
  	    else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)
! 					|| (vcol < fromcol || vcol >= tocol)))
  		char_attr = line_attr;
  #endif
  	    else
--- 3555,3562 ----
  		/* Use line_attr when not in the Visual or 'incsearch' area
  		 * (area_attr may be 0 when "noinvcur" is set). */
  	    else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)
! 				|| vcol < fromcol || vcol_prev < fromcol_prev
! 				|| vcol >= tocol))
  		char_attr = line_attr;
  #endif
  	    else
*** ../vim-7.2.139/src/version.c	Wed Mar 11 17:27:46 2009
--- src/version.c	Wed Mar 11 17:42:19 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     140,
  /**/

-- 
Some of the well know MS-Windows errors:
	EMEMORY		Memory error caused by..., eh...
	ELICENSE	Your license has expired, give us more money!
	EMOUSE		Mouse moved, reinstall Windows
	EILLEGAL	Illegal error, you are not allowed to see this
	EVIRUS		Undetectable virus found

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.141
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.141
Problem:    When redrawing a character for bold spill this causes the next
	    character to be redrawn as well.
Solution:   Only redraw one extra character. (Yukihiro Nakadaira)
Files:	    src/screen.c


*** ../vim-7.2.140/src/screen.c	Wed Mar 11 17:44:38 2009
--- src/screen.c	Wed Mar 11 13:59:24 2009
***************
*** 5132,5139 ****
  #endif
  
  #if defined(FEAT_GUI) || defined(UNIX)
! 	    /* The bold trick makes a single row of pixels appear in the next
! 	     * character.  When a bold character is removed, the next
  	     * character should be redrawn too.  This happens for our own GUI
  	     * and for some xterms. */
  	    if (
--- 5132,5139 ----
  #endif
  
  #if defined(FEAT_GUI) || defined(UNIX)
! 	    /* The bold trick makes a single column of pixels appear in the
! 	     * next character.  When a bold character is removed, the next
  	     * character should be redrawn too.  This happens for our own GUI
  	     * and for some xterms. */
  	    if (
***************
*** 6276,6284 ****
--- 6276,6290 ----
      int		pcc[MAX_MCO];
  # endif
  #endif
+ #if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+     int		force_redraw_this;
+     int		force_redraw_next = FALSE;
+ #endif
+     int		need_redraw;
  
      if (ScreenLines == NULL || row >= screen_Rows)	/* safety check */
  	return;
+     off = LineOffset[row] + col;
  
  #ifdef FEAT_MBYTE
      /* When drawing over the right halve of a double-wide char clear out the
***************
*** 6288,6297 ****
  	    && !gui.in_use
  # endif
  	    && mb_fix_col(col, row) != col)
! 	screen_puts_len((char_u *)" ", 1, row, col - 1, 0);
  #endif
  
-     off = LineOffset[row] + col;
  #ifdef FEAT_MBYTE
      max_off = LineOffset[row] + screen_Columns;
  #endif
--- 6294,6314 ----
  	    && !gui.in_use
  # endif
  	    && mb_fix_col(col, row) != col)
!     {
! 	ScreenLines[off - 1] = ' ';
! 	ScreenAttrs[off - 1] = 0;
! 	if (enc_utf8)
! 	{
! 	    ScreenLinesUC[off - 1] = 0;
! 	    ScreenLinesC[0][off - 1] = 0;
! 	}
! 	/* redraw the previous cell, make it empty */
! 	screen_char(off - 1, row, col - 1);
! 	/* force the cell at "col" to be redrawn */
! 	force_redraw_next = TRUE;
!     }
  #endif
  
  #ifdef FEAT_MBYTE
      max_off = LineOffset[row] + screen_Columns;
  #endif
***************
*** 6355,6361 ****
  	}
  #endif
  
! 	if (ScreenLines[off] != c
  #ifdef FEAT_MBYTE
  		|| (mbyte_cells == 2
  		    && ScreenLines[off + 1] != (enc_dbcs ? ptr[1] : 0))
--- 6372,6383 ----
  	}
  #endif
  
! #if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
! 	force_redraw_this = force_redraw_next;
! 	force_redraw_next = FALSE;
! #endif
! 
! 	need_redraw = ScreenLines[off] != c
  #ifdef FEAT_MBYTE
  		|| (mbyte_cells == 2
  		    && ScreenLines[off + 1] != (enc_dbcs ? ptr[1] : 0))
***************
*** 6367,6386 ****
  			|| screen_comp_differs(off, u8cc)))
  #endif
  		|| ScreenAttrs[off] != attr
! 		|| exmode_active
  		)
  	{
  #if defined(FEAT_GUI) || defined(UNIX)
  	    /* The bold trick makes a single row of pixels appear in the next
  	     * character.  When a bold character is removed, the next
  	     * character should be redrawn too.  This happens for our own GUI
! 	     * and for some xterms.
! 	     * Force the redraw by setting the attribute to a different value
! 	     * than "attr", the contents of ScreenLines[] may be needed by
! 	     * mb_off2cells() further on.
! 	     * Don't do this for the last drawn character, because the next
! 	     * character may not be redrawn. */
! 	    if (
  # ifdef FEAT_GUI
  		    gui.in_use
  # endif
--- 6389,6408 ----
  			|| screen_comp_differs(off, u8cc)))
  #endif
  		|| ScreenAttrs[off] != attr
! 		|| exmode_active;
! 
! 	if (need_redraw
! #if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
! 		|| force_redraw_this
! #endif
  		)
  	{
  #if defined(FEAT_GUI) || defined(UNIX)
  	    /* The bold trick makes a single row of pixels appear in the next
  	     * character.  When a bold character is removed, the next
  	     * character should be redrawn too.  This happens for our own GUI
! 	     * and for some xterms. */
! 	    if (need_redraw && ScreenLines[off] != ' ' && (
  # ifdef FEAT_GUI
  		    gui.in_use
  # endif
***************
*** 6390,6412 ****
  # ifdef UNIX
  		    term_is_xterm
  # endif
! 	       )
  	    {
! 		int		n;
  
! 		n = ScreenAttrs[off];
! # ifdef FEAT_MBYTE
! 		if (col + mbyte_cells < screen_Columns
! 			&& (n > HL_ALL || (n & HL_BOLD))
! 			&& (len < 0 ? ptr[mbyte_blen] != NUL
! 					     : ptr + mbyte_blen < text + len))
! 		    ScreenAttrs[off + mbyte_cells] = attr + 1;
! # else
! 		if (col + 1 < screen_Columns
! 			&& (n > HL_ALL || (n & HL_BOLD))
! 			&& (len < 0 ? ptr[1] != NUL : ptr + 1 < text + len))
! 		    ScreenLines[off + 1] = 0;
! # endif
  	    }
  #endif
  #ifdef FEAT_MBYTE
--- 6412,6425 ----
  # ifdef UNIX
  		    term_is_xterm
  # endif
! 		    ))
  	    {
! 		int	n = ScreenAttrs[off];
  
! 		if (n > HL_ALL)
! 		    n = syn_attr2attr(n);
! 		if (n & HL_BOLD)
! 		    force_redraw_next = TRUE;
  	    }
  #endif
  #ifdef FEAT_MBYTE
***************
*** 6493,6498 ****
--- 6506,6525 ----
  	    ++ptr;
  	}
      }
+ 
+ #if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+     /* If we detected the next character needs to be redrawn, but the text
+      * doesn't extend up to there, update the character here. */
+     if (force_redraw_next && col < screen_Columns)
+     {
+ # ifdef FEAT_MBYTE
+ 	if (enc_dbcs != 0 && dbcs_off2cells(off, max_off) > 1)
+ 	    screen_char_2(off, row, col);
+ 	else
+ # endif
+ 	    screen_char(off, row, col);
+     }
+ #endif
  }
  
  #ifdef FEAT_SEARCH_EXTRA
*** ../vim-7.2.140/src/version.c	Wed Mar 11 17:44:38 2009
--- src/version.c	Wed Mar 11 17:55:22 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     141,
  /**/

-- 
Some of the well know MS-Windows errors:
	ETIME		Wrong time, wait a little while
	ECRASH		Try again...
	EDETECT		Unable to detect errors
	EOVER		You lost!  Play another game?
	ENOCLUE		Eh, what did you want?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.142
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.142
Problem:    Motif and Athena balloons don't use tooltip colors.
Solution:   Set the colors. (Matt Wozniski)
Files:	    src/gui_beval.c


*** ../vim-7.2.141/src/gui_beval.c	Thu May 10 21:29:20 2007
--- src/gui_beval.c	Wed Mar 11 15:20:36 2009
***************
*** 1291,1296 ****
--- 1291,1313 ----
  		XtNy, ty,
  		NULL);
  #endif
+ 	/* Set tooltip colors */
+ 	{
+ 	    Arg args[2];
+ 
+ #ifdef FEAT_GUI_MOTIF
+ 	    args[0].name = XmNbackground;
+ 	    args[0].value = gui.tooltip_bg_pixel;
+ 	    args[1].name = XmNforeground;
+ 	    args[1].value = gui.tooltip_fg_pixel;
+ #else /* Athena */
+ 	    args[0].name = XtNbackground;
+ 	    args[0].value = gui.tooltip_bg_pixel;
+ 	    args[1].name = XtNforeground;
+ 	    args[1].value = gui.tooltip_fg_pixel;
+ #endif
+ 	    XtSetValues(beval->balloonLabel, &args[0], XtNumber(args));
+ 	}
  
  	XtPopup(beval->balloonShell, XtGrabNone);
  
*** ../vim-7.2.141/src/version.c	Wed Mar 11 17:57:05 2009
--- src/version.c	Wed Mar 18 12:20:01 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     142,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
233. You start dreaming about web pages...in html.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.143
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.143
Problem:    No command line completion for ":cscope" command.
Solution:   Add the completion for ":cscope". (Dominique Pelle)
Files:	    src/ex_docmd.c, src/ex_getln.c, src/if_cscope.c,
	    src/proto/if_cscope.pro, src/vim.h


*** ../vim-7.2.142/src/ex_docmd.c	Wed Mar 11 15:36:01 2009
--- src/ex_docmd.c	Wed Mar 11 15:45:04 2009
***************
*** 3683,3688 ****
--- 3683,3693 ----
  	case CMD_highlight:
  	    set_context_in_highlight_cmd(xp, arg);
  	    break;
+ #ifdef FEAT_CSCOPE
+ 	case CMD_cscope:
+ 	    set_context_in_cscope_cmd(xp, arg);
+ 	    break;
+ #endif
  #ifdef FEAT_LISTCMDS
  	case CMD_bdelete:
  	case CMD_bwipeout:
***************
*** 5187,5192 ****
--- 5192,5200 ----
      {EXPAND_AUGROUP, "augroup"},
      {EXPAND_BUFFERS, "buffer"},
      {EXPAND_COMMANDS, "command"},
+ #if defined(FEAT_CSCOPE)
+     {EXPAND_CSCOPE, "cscope"},
+ #endif
  #if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
      {EXPAND_USER_DEFINED, "custom"},
      {EXPAND_USER_LIST, "customlist"},
*** ../vim-7.2.142/src/ex_getln.c	Thu Mar  5 03:13:51 2009
--- src/ex_getln.c	Wed Mar 11 15:45:04 2009
***************
*** 4518,4523 ****
--- 4518,4526 ----
  	    {EXPAND_EVENTS, get_event_name, TRUE},
  	    {EXPAND_AUGROUP, get_augroup_name, TRUE},
  #endif
+ #ifdef FEAT_CSCOPE
+ 	    {EXPAND_CSCOPE, get_cscope_name, TRUE},
+ #endif
  #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
  	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
  	    {EXPAND_LANGUAGE, get_lang_arg, TRUE},
*** ../vim-7.2.142/src/if_cscope.c	Wed Jan 28 16:03:51 2009
--- src/if_cscope.c	Wed Mar 11 15:56:07 2009
***************
*** 93,104 ****
      (void)EMSG2(_("E560: Usage: cs[cope] %s"), cs_cmds[(int)x].usage);
  }
  
  /*
   * PRIVATE: do_cscope_general
   *
!  * find the command, print help if invalid, and the then call the
!  * corresponding command function,
!  * called from do_cscope and do_scscope
   */
      static void
  do_cscope_general(eap, make_split)
--- 93,209 ----
      (void)EMSG2(_("E560: Usage: cs[cope] %s"), cs_cmds[(int)x].usage);
  }
  
+ #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+ 
+ static enum
+ {
+     EXP_CSCOPE_SUBCMD,	/* expand ":cscope" sub-commands */
+     EXP_CSCOPE_FIND,	/* expand ":cscope find" arguments */
+     EXP_CSCOPE_KILL	/* expand ":cscope kill" arguments */
+ } expand_what;
+ 
+ /*
+  * Function given to ExpandGeneric() to obtain the cscope command
+  * expansion.
+  */
+ /*ARGSUSED*/
+     char_u *
+ get_cscope_name(xp, idx)
+     expand_T	*xp;
+     int		idx;
+ {
+     switch (expand_what)
+     {
+     case EXP_CSCOPE_SUBCMD:
+ 	/* Complete with sub-commands of ":cscope":
+ 	 * add, find, help, kill, reset, show */
+ 	return (char_u *)cs_cmds[idx].name;
+     case EXP_CSCOPE_FIND:
+ 	{
+ 	    const char *query_type[] =
+ 	    {
+ 		"c", "d", "e", "f", "g", "i", "s", "t", NULL
+ 	    };
+ 
+ 	    /* Complete with query type of ":cscope find {query_type}".
+ 	     * {query_type} can be letters (c, d, ... t) or numbers (0, 1,
+ 	     * ..., 8) but only complete with letters, since numbers are
+ 	     * redundant. */
+ 	    return (char_u *)query_type[idx];
+ 	}
+     case EXP_CSCOPE_KILL:
+ 	{
+ 	    int			i;
+ 	    int			current_idx = 0;
+ 	    static char_u	connection[2];
+ 
+ 	    /* ":cscope kill" accepts connection numbers or partial names of
+ 	     * the pathname of the cscope database as argument.  Only complete
+ 	     * with connection numbers. -1 can also be used to kill all
+ 	     * connections. */
+ 	    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+ 	    {
+ 		if (csinfo[i].fname == NULL)
+ 		    continue;
+ 		if (current_idx++ == idx)
+ 		{
+ 		    /* Connection number fits in one character since
+ 		     * CSCOPE_MAX_CONNECTIONS is < 10 */
+ 		    connection[0] = i + '0';
+ 		    connection[1] = NUL;
+ 		    return connection;
+ 		}
+ 	    }
+ 	    return (current_idx == idx && idx > 0) ? (char_u *)"-1" : NULL;
+ 	}
+     default:
+ 	return NULL;
+     }
+ }
+ 
+ /*
+  * Handle command line completion for :cscope command.
+  */
+     void
+ set_context_in_cscope_cmd(xp, arg)
+     expand_T	*xp;
+     char_u	*arg;
+ {
+     char_u	*p;
+ 
+     /* Default: expand subcommands */
+     xp->xp_context = EXPAND_CSCOPE;
+     expand_what = EXP_CSCOPE_SUBCMD;
+     xp->xp_pattern = arg;
+ 
+     /* (part of) subcommand already typed */
+     if (*arg != NUL)
+     {
+ 	p = skiptowhite(arg);
+ 	if (*p != NUL)		    /* past first word */
+ 	{
+ 	    xp->xp_pattern = skipwhite(p);
+ 	    if (*skiptowhite(xp->xp_pattern) != NUL)
+ 		xp->xp_context = EXPAND_NOTHING;
+ 	    else if (STRNICMP(arg, "add", p - arg) == 0)
+ 		xp->xp_context = EXPAND_FILES;
+ 	    else if (STRNICMP(arg, "kill", p - arg) == 0)
+ 		expand_what = EXP_CSCOPE_KILL;
+ 	    else if (STRNICMP(arg, "find", p - arg) == 0)
+ 		expand_what = EXP_CSCOPE_FIND;
+ 	    else
+ 		xp->xp_context = EXPAND_NOTHING;
+ 	}
+     }
+ }
+ 
+ #endif /* FEAT_CMDL_COMPL */
+ 
  /*
   * PRIVATE: do_cscope_general
   *
!  * Find the command, print help if invalid, and then call the corresponding
!  * command function.
   */
      static void
  do_cscope_general(eap, make_split)
*** ../vim-7.2.142/src/proto/if_cscope.pro	Thu Sep  6 17:38:21 2007
--- src/proto/if_cscope.pro	Wed Mar 11 15:57:03 2009
***************
*** 1,4 ****
--- 1,6 ----
  /* if_cscope.c */
+ char_u *get_cscope_name __ARGS((expand_T *xp, int idx));
+ void set_context_in_cscope_cmd __ARGS((expand_T *xp, char_u *arg));
  void do_cscope __ARGS((exarg_T *eap));
  void do_scscope __ARGS((exarg_T *eap));
  void do_cstag __ARGS((exarg_T *eap));
*** ../vim-7.2.142/src/vim.h	Sun Feb 22 02:36:36 2009
--- src/vim.h	Wed Mar 11 15:45:04 2009
***************
*** 708,713 ****
--- 708,714 ----
  #define EXPAND_USER_DEFINED	30
  #define EXPAND_USER_LIST	31
  #define EXPAND_SHELLCMD		32
+ #define EXPAND_CSCOPE		33
  
  /* Values for exmode_active (0 is no exmode) */
  #define EXMODE_NORMAL		1
*** ../vim-7.2.142/src/version.c	Wed Mar 18 12:20:35 2009
--- src/version.c	Wed Mar 18 12:48:08 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     143,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
234. You started college as a chemistry major, and walk out four years
     later as an Internet provider.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.144
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.144
Problem:    When 't_Co' is set to the value it already had the color scheme is
            reloaded anyway.
Solution:   Only load the colorscheme when the t_Co value changes. (Dominique
            Pelle)
Files:      src/option.c


*** ../vim-7.2.143/src/option.c	Wed Mar  4 04:11:56 2009
--- src/option.c	Wed Mar 18 12:00:28 2009
***************
*** 6022,6036 ****
  	/* ":set t_Co=0" and ":set t_Co=1" do ":set t_Co=" */
  	if (varp == &T_CCO)
  	{
! 	    t_colors = atoi((char *)T_CCO);
! 	    if (t_colors <= 1)
  	    {
! 		if (new_value_alloced)
! 		    vim_free(T_CCO);
! 		T_CCO = empty_option;
  	    }
- 	    /* We now have a different color setup, initialize it again. */
- 	    init_highlight(TRUE, FALSE);
  	}
  	ttest(FALSE);
  	if (varp == &T_ME)
--- 6022,6044 ----
  	/* ":set t_Co=0" and ":set t_Co=1" do ":set t_Co=" */
  	if (varp == &T_CCO)
  	{
! 	    int colors = atoi((char *)T_CCO);
! 
! 	    /* Only reinitialize colors if t_Co value has really changed to
! 	     * avoid expensive reload of colorscheme if t_Co is set to the
! 	     * same value multiple times. */
! 	    if (colors != t_colors)
  	    {
! 		t_colors = colors;
! 		if (t_colors <= 1)
! 		{
! 		    if (new_value_alloced)
! 			vim_free(T_CCO);
! 		    T_CCO = empty_option;
! 		}
! 		/* We now have a different color setup, initialize it again. */
! 		init_highlight(TRUE, FALSE);
  	    }
  	}
  	ttest(FALSE);
  	if (varp == &T_ME)
*** ../vim-7.2.143/src/version.c	Wed Mar 18 12:50:58 2009
--- src/version.c	Wed Mar 18 14:16:48 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     144,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
235. You start naming your kids Pascal, COBOL, Algol and Fortran.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.145
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.145
Problem:    White space in ":cscope find" is not ignored.
Solution:   Ignore the white space, but not when the leading white space is
	    useful for the argument.
Files:	    runtime/doc/if_cscop.txt, src/if_cscope.c


*** ../vim-7.2.144/runtime/doc/if_cscop.txt	Sat Aug  9 19:36:48 2008
--- runtime/doc/if_cscop.txt	Wed Mar 18 14:30:09 2009
***************
*** 1,4 ****
! *if_cscop.txt*  For Vim version 7.2.  Last change: 2005 Mar 29
  
  
  		  VIM REFERENCE MANUAL    by Andy Kahn
--- 1,4 ----
! *if_cscop.txt*  For Vim version 7.2.  Last change: 2009 Mar 18
  
  
  		  VIM REFERENCE MANUAL    by Andy Kahn
***************
*** 131,141 ****
  		7 or f: Find this file
  		8 or i: Find files #including this file
  
  	EXAMPLES >
  	    :cscope find c vim_free
! 	    :cscope find 3 vim_free
  <
! 	    These two examples perform the same query. >
  
  	    :cscope find 0 DEFAULT_TERM
  <
--- 131,152 ----
  		7 or f: Find this file
  		8 or i: Find files #including this file
  
+ 	For all types, except 4 and 6, leading white space for {name} is
+ 	removed.  For 4 and 6 there is exactly one space between {querytype}
+ 	and {name}.  Further white space is included in {name}.
+ 
  	EXAMPLES >
  	    :cscope find c vim_free
! 	    :cscope find 3  vim_free
! <
! 	    These two examples perform the same query: functions calling
! 	    "vim_free". >
! 
! 	    :cscope find t initOnce
! 	    :cscope find t  initOnce
  <
! 	    The first one searches for the text "initOnce", the second one for
! 	    " initOnce". >
  
  	    :cscope find 0 DEFAULT_TERM
  <
*** ../vim-7.2.144/src/if_cscope.c	Wed Mar 18 12:50:58 2009
--- src/if_cscope.c	Wed Mar 18 13:23:53 2009
***************
*** 764,769 ****
--- 764,770 ----
  {
      char *cmd;
      short search;
+     char *pat;
  
      switch (csoption[0])
      {
***************
*** 797,806 ****
  	return NULL;
      }
  
!     if ((cmd = (char *)alloc((unsigned)(strlen(pattern) + 2))) == NULL)
  	return NULL;
  
!     (void)sprintf(cmd, "%d%s", search, pattern);
  
      return cmd;
  } /* cs_create_cmd */
--- 798,814 ----
  	return NULL;
      }
  
!     /* Skip white space before the patter, except for text and pattern search,
!      * they may want to use the leading white space. */
!     pat = pattern;
!     if (search != 4 && search != 6)
! 	while vim_iswhite(*pat)
! 	    ++pat;
! 
!     if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
  	return NULL;
  
!     (void)sprintf(cmd, "%d%s", search, pat);
  
      return cmd;
  } /* cs_create_cmd */
*** ../vim-7.2.144/src/version.c	Wed Mar 18 14:19:28 2009
--- src/version.c	Wed Mar 18 14:28:46 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     145,
  /**/

-- 
Google is kind of like Dr. Who's Tardis; it's weirder on the
inside than on the outside...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.146
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.146
Problem:    v:warningmsg isn't used for all warnings.
Solution:   Set v:warningmsg for relevant warnings. (Ingo Karkat)
Files:	    src/fileio.c, src/misc1.c, src/option.c


*** ../vim-7.2.145/src/fileio.c	Wed Mar 11 13:09:30 2009
--- src/fileio.c	Wed Mar 18 15:03:46 2009
***************
*** 6647,6652 ****
--- 6647,6657 ----
  	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
  							+ STRLEN(mesg2) + 2));
  	    sprintf((char *)tbuf, mesg, path);
+ #ifdef FEAT_EVAL
+ 	    /* Set warningmsg here, before the unimportant and output-specific
+ 	     * mesg2 has been appended. */
+ 	    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);
+ #endif
  #if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)
  	    if (can_reload)
  	    {
*** ../vim-7.2.145/src/misc1.c	Thu Nov 20 17:09:09 2008
--- src/misc1.c	Wed Mar 18 15:06:59 2009
***************
*** 2955,2960 ****
--- 2955,2962 ----
      int	    col;		/* column for message; non-zero when in insert
  				   mode and 'showmode' is on */
  {
+     static char *w_readonly = N_("W10: Warning: Changing a readonly file");
+ 
      if (curbuf->b_did_warn == FALSE
  	    && curbufIsChanged() == 0
  #ifdef FEAT_AUTOCMD
***************
*** 2977,2984 ****
  	if (msg_row == Rows - 1)
  	    msg_col = col;
  	msg_source(hl_attr(HLF_W));
! 	MSG_PUTS_ATTR(_("W10: Warning: Changing a readonly file"),
! 						   hl_attr(HLF_W) | MSG_HIST);
  	msg_clr_eos();
  	(void)msg_end();
  	if (msg_silent == 0 && !silent_mode)
--- 2979,2988 ----
  	if (msg_row == Rows - 1)
  	    msg_col = col;
  	msg_source(hl_attr(HLF_W));
! 	MSG_PUTS_ATTR(_(w_readonly), hl_attr(HLF_W) | MSG_HIST);
! #ifdef FEAT_EVAL
! 	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
! #endif
  	msg_clr_eos();
  	(void)msg_end();
  	if (msg_silent == 0 && !silent_mode)
*** ../vim-7.2.145/src/option.c	Wed Mar 18 14:19:28 2009
--- src/option.c	Wed Mar 18 15:06:11 2009
***************
*** 7563,7571 ****
  	     * set. */
  	    if (STRCMP(p_enc, "utf-8") != 0)
  	    {
  		msg_source(hl_attr(HLF_W));
! 		MSG_ATTR(_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'"),
! 			hl_attr(HLF_W));
  	    }
  
  # ifdef FEAT_MBYTE
--- 7563,7575 ----
  	     * set. */
  	    if (STRCMP(p_enc, "utf-8") != 0)
  	    {
+ 		static char *w_arabic = N_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'");
+ 
  		msg_source(hl_attr(HLF_W));
! 		MSG_ATTR(_(w_arabic), hl_attr(HLF_W));
! #ifdef FEAT_EVAL
! 		set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);
! #endif
  	    }
  
  # ifdef FEAT_MBYTE
*** ../vim-7.2.145/src/version.c	Wed Mar 18 14:30:46 2009
--- src/version.c	Wed Mar 18 15:38:27 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     146,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
238. You think faxes are old-fashioned.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.147
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.147
Problem:    When compiled as small version and 'number' is on the cursor is
	    displayed in the wrong position after a tab. (James Vega)
Solution:   Don't increment vcol when still displaying the line number.
Files:	    src/screen.c


*** ../vim-7.2.146/src/screen.c	Wed Mar 11 17:57:05 2009
--- src/screen.c	Wed Mar 18 16:18:00 2009
***************
*** 4665,4671 ****
  	    --n_skip;
  
  	/* Only advance the "vcol" when after the 'number' column. */
! 	if (draw_state >= WL_SBR
  #ifdef FEAT_DIFF
  		&& filler_todo <= 0
  #endif
--- 4665,4671 ----
  	    --n_skip;
  
  	/* Only advance the "vcol" when after the 'number' column. */
! 	if (draw_state > WL_NR
  #ifdef FEAT_DIFF
  		&& filler_todo <= 0
  #endif
*** ../vim-7.2.146/src/version.c	Wed Mar 18 15:40:03 2009
--- src/version.c	Wed Mar 18 16:26:00 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     147,
  /**/

-- 
You can tune a file system, but you can't tuna fish
							-- man tunefs

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.148
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.148
Problem:    When searching for "$" while 'hlsearch' is set, highlighting the
	    character after the line does not work in the cursor column.
	    Also highlighting for Visual mode after the line end when this
	    isn't needed.  (Markus Heidelberg)
Solution:   Only compare the cursor column in the cursor line.  Only highlight
	    for Visual selection after the last character when it's needed to
	    see where the Visual selection ends.
Files:	    src/screen.c


*** ../vim-7.2.147/src/screen.c	Wed Mar 18 16:26:31 2009
--- src/screen.c	Wed Mar 18 17:24:56 2009
***************
*** 2889,2896 ****
  	}
  	else
  	    tocol = MAXCOL;
! 	if (fromcol == tocol)		/* do at least one character */
! 	    tocol = fromcol + 1;	/* happens when past end of line */
  	area_highlighting = TRUE;
  	attr = hl_attr(HLF_I);
      }
--- 2889,2897 ----
  	}
  	else
  	    tocol = MAXCOL;
! 	/* do at least one character; happens when past end of line */
! 	if (fromcol == tocol)
! 	    tocol = fromcol + 1;
  	area_highlighting = TRUE;
  	attr = hl_attr(HLF_I);
      }
***************
*** 4118,4123 ****
--- 4119,4125 ----
  # endif
  				    (col < W_WIDTH(wp)))
  				&& !(noinvcur
+ 				    && lnum == wp->w_cursor.lnum
  				    && (colnr_T)vcol == wp->w_virtcol)))
  			&& lcs_eol_one >= 0)
  		{
***************
*** 4259,4265 ****
  	 * preedit_changed and commit.  Thus Vim can't set "im_is_active", use
  	 * im_is_preediting() here. */
  	if (xic != NULL
! 		&& lnum == curwin->w_cursor.lnum
  		&& (State & INSERT)
  		&& !p_imdisable
  		&& im_is_preediting()
--- 4261,4267 ----
  	 * preedit_changed and commit.  Thus Vim can't set "im_is_active", use
  	 * im_is_preediting() here. */
  	if (xic != NULL
! 		&& lnum == wp->w_cursor.lnum
  		&& (State & INSERT)
  		&& !p_imdisable
  		&& im_is_preediting()
***************
*** 4268,4274 ****
  	    colnr_T tcol;
  
  	    if (preedit_end_col == MAXCOL)
! 		getvcol(curwin, &(curwin->w_cursor), &tcol, NULL, NULL);
  	    else
  		tcol = preedit_end_col;
  	    if ((long)preedit_start_col <= vcol && vcol < (long)tcol)
--- 4270,4276 ----
  	    colnr_T tcol;
  
  	    if (preedit_end_col == MAXCOL)
! 		getvcol(curwin, &(wp->w_cursor), &tcol, NULL, NULL);
  	    else
  		tcol = preedit_end_col;
  	    if ((long)preedit_start_col <= vcol && vcol < (long)tcol)
***************
*** 4365,4371 ****
  	    }
  #endif
  	    if (lcs_eol == lcs_eol_one
! 		    && ((area_attr != 0 && vcol == fromcol && c == NUL)
  #ifdef FEAT_SEARCH_EXTRA
  			/* highlight 'hlsearch' match at end of line */
  			|| (prevcol_hl_flag == TRUE
--- 4367,4379 ----
  	    }
  #endif
  	    if (lcs_eol == lcs_eol_one
! 		    && ((area_attr != 0 && vcol == fromcol
! #ifdef FEAT_VISUAL
! 			    && (VIsual_mode != Ctrl_V
! 				|| lnum == VIsual.lnum
! 				|| lnum == curwin->w_cursor.lnum)
! #endif
! 			    && c == NUL)
  #ifdef FEAT_SEARCH_EXTRA
  			/* highlight 'hlsearch' match at end of line */
  			|| (prevcol_hl_flag == TRUE
***************
*** 4459,4465 ****
  	if (c == NUL)
  	{
  #ifdef FEAT_SYN_HL
! 	    if (eol_hl_off > 0 && vcol - eol_hl_off == (long)wp->w_virtcol)
  	    {
  		/* highlight last char after line */
  		--col;
--- 4467,4474 ----
  	if (c == NUL)
  	{
  #ifdef FEAT_SYN_HL
! 	    if (eol_hl_off > 0 && vcol - eol_hl_off == (long)wp->w_virtcol
! 		    && lnum == wp->w_cursor.lnum)
  	    {
  		/* highlight last char after line */
  		--col;
*** ../vim-7.2.147/src/version.c	Wed Mar 18 16:26:31 2009
--- src/version.c	Wed Mar 18 19:05:37 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     148,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
239. You think "surfing" is something you do on dry land.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.149
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.149
Problem:    Using return value of function that doesn't return a value results
	    in reading uninitialized memory.
Solution:   Set the default to return zero.  Make cursor() return -1 on
	    failure.  Let complete() return an empty string in case of an
	    error.  (partly by Dominique Pelle)
Files:	    runtime/doc/eval.txt, src/eval.c


*** ../vim-7.2.148/runtime/doc/eval.txt	Tue Dec  9 10:56:50 2008
--- runtime/doc/eval.txt	Sun Mar 22 14:28:49 2009
***************
*** 2414,2419 ****
--- 2419,2425 ----
  		When 'virtualedit' is used {off} specifies the offset in
  		screen columns from the start of the character.  E.g., a
  		position within a <Tab> or after the last character.
+ 		Returns 0 when the position could be set, -1 otherwise.
  
  
  deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
***************
*** 4516,4521 ****
--- 4526,4532 ----
  		should also work to move files across file systems.  The
  		result is a Number, which is 0 if the file was renamed
  		successfully, and non-zero when the renaming failed.
+ 		NOTE: If {to} exists it is overwritten without warning.
  		This function is not available in the |sandbox|.
  
  repeat({expr}, {count})					*repeat()*
*** ../vim-7.2.148/src/eval.c	Wed Feb  4 16:25:53 2009
--- src/eval.c	Sun Mar 22 20:45:18 2009
***************
*** 1285,1291 ****
--- 1285,1293 ----
      typval_T	tv;
      char_u	*retval;
      garray_T	ga;
+ #ifdef FEAT_FLOAT
      char_u	numbuf[NUMBUFLEN];
+ #endif
  
      if (eval0(arg, &tv, nextcmd, TRUE) == FAIL)
  	retval = NULL;
***************
*** 8018,8024 ****
      /* execute the function if no errors detected and executing */
      if (evaluate && error == ERROR_NONE)
      {
! 	rettv->v_type = VAR_NUMBER;	/* default is number rettv */
  	error = ERROR_UNKNOWN;
  
  	if (!builtin_function(fname))
--- 8020,8027 ----
      /* execute the function if no errors detected and executing */
      if (evaluate && error == ERROR_NONE)
      {
! 	rettv->v_type = VAR_NUMBER;	/* default rettv is number zero */
! 	rettv->vval.v_number = 0;
  	error = ERROR_UNKNOWN;
  
  	if (!builtin_function(fname))
***************
*** 8268,8274 ****
  		return;
  	    li = l->lv_first;
  	}
- 	rettv->vval.v_number = 0;	/* Default: Success */
  	for (;;)
  	{
  	    if (l == NULL)
--- 8271,8276 ----
***************
*** 8728,8734 ****
      int		dummy;
      dict_T	*selfdict = NULL;
  
-     rettv->vval.v_number = 0;
      if (argvars[1].v_type != VAR_LIST)
      {
  	EMSG(_(e_listreq));
--- 8730,8735 ----
***************
*** 9036,9048 ****
      if (buttons == NULL || *buttons == NUL)
  	buttons = (char_u *)_("&Ok");
  
!     if (error)
! 	rettv->vval.v_number = 0;
!     else
  	rettv->vval.v_number = do_dialog(type, NULL, message, buttons,
  								   def, NULL);
- #else
-     rettv->vval.v_number = 0;
  #endif
  }
  
--- 9037,9045 ----
      if (buttons == NULL || *buttons == NUL)
  	buttons = (char_u *)_("&Ok");
  
!     if (!error)
  	rettv->vval.v_number = do_dialog(type, NULL, message, buttons,
  								   def, NULL);
  #endif
  }
  
***************
*** 9181,9195 ****
      }
  
      rettv->vval.v_number = cs_connection(num, dbpath, prepend);
- #else
-     rettv->vval.v_number = 0;
  #endif
  }
  
  /*
   * "cursor(lnum, col)" function
   *
!  * Moves the cursor to the specified line and column
   */
  /*ARGSUSED*/
      static void
--- 9178,9191 ----
      }
  
      rettv->vval.v_number = cs_connection(num, dbpath, prepend);
  #endif
  }
  
  /*
   * "cursor(lnum, col)" function
   *
!  * Moves the cursor to the specified line and column.
!  * Returns 0 when the position could be set, -1 otherwise.
   */
  /*ARGSUSED*/
      static void
***************
*** 9202,9207 ****
--- 9198,9204 ----
      long	coladd = 0;
  #endif
  
+     rettv->vval.v_number = -1;
      if (argvars[1].v_type == VAR_UNKNOWN)
      {
  	pos_T	    pos;
***************
*** 9246,9251 ****
--- 9243,9249 ----
  #endif
  
      curwin->w_set_curswant = TRUE;
+     rettv->vval.v_number = 0;
  }
  
  /*
***************
*** 9291,9298 ****
  {
  #ifdef FEAT_AUTOCMD
      rettv->vval.v_number = did_filetype;
- #else
-     rettv->vval.v_number = 0;
  #endif
  }
  
--- 9289,9294 ----
***************
*** 9605,9611 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_LIST)
      {
  	list_T		*l1, *l2;
--- 9601,9606 ----
***************
*** 9733,9739 ****
      if (check_secure())
  	return;
  
-     rettv->vval.v_number = 0;
      keys = get_tv_string(&argvars[0]);
      if (*keys != NUL)
      {
--- 9728,9733 ----
***************
*** 9901,9907 ****
      char_u	*ermsg = map ? (char_u *)"map()" : (char_u *)"filter()";
      int		save_did_emsg;
  
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type == VAR_LIST)
      {
  	if ((l = argvars[0].vval.v_list) == NULL
--- 9895,9900 ----
***************
*** 10084,10091 ****
  	else
  	    rettv->vval.v_number = (varnumber_T)f;
      }
-     else
- 	rettv->vval.v_number = 0;
  }
  
  /*
--- 10077,10082 ----
***************
*** 10219,10227 ****
      lnum = get_tv_lnum(argvars);
      if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
  	rettv->vval.v_number = foldLevel(lnum);
-     else
  #endif
- 	rettv->vval.v_number = 0;
  }
  
  /*
--- 10210,10216 ----
***************
*** 10337,10343 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
-     rettv->vval.v_number = 0;
  #ifdef FEAT_GUI
      if (gui.in_use)
  	gui_mch_set_foreground();
--- 10326,10331 ----
***************
*** 10359,10365 ****
  {
      char_u	*s;
  
-     rettv->vval.v_number = 0;
      s = get_tv_string(&argvars[0]);
      if (s == NULL || *s == NUL || VIM_ISDIGIT(*s))
  	EMSG2(_(e_invarg2), s);
--- 10347,10352 ----
***************
*** 10429,10437 ****
  
      if (tv == NULL)
      {
! 	if (argvars[2].v_type == VAR_UNKNOWN)
! 	    rettv->vval.v_number = 0;
! 	else
  	    copy_tv(&argvars[2], rettv);
      }
      else
--- 10416,10422 ----
  
      if (tv == NULL)
      {
! 	if (argvars[2].v_type != VAR_UNKNOWN)
  	    copy_tv(&argvars[2], rettv);
      }
      else
***************
*** 10456,10468 ****
  {
      char_u	*p;
  
!     if (retlist)
!     {
! 	if (rettv_list_alloc(rettv) == FAIL)
! 	    return;
!     }
!     else
! 	rettv->vval.v_number = 0;
  
      if (buf == NULL || buf->b_ml.ml_mfp == NULL || start < 0)
  	return;
--- 10441,10448 ----
  {
      char_u	*p;
  
!     if (retlist && rettv_list_alloc(rettv) == FAIL)
! 	return;
  
      if (buf == NULL || buf->b_ml.ml_mfp == NULL || start < 0)
  	return;
***************
*** 11009,11016 ****
      dict_T	*dict;
      matchitem_T	*cur = curwin->w_match_head;
  
-     rettv->vval.v_number = 0;
- 
      if (rettv_list_alloc(rettv) == OK)
      {
  	while (cur != NULL)
--- 10989,10994 ----
***************
*** 11089,11095 ****
      win_T	*wp;
  #endif
  
-     rettv->vval.v_number = 0;
  #ifdef FEAT_QUICKFIX
      if (rettv_list_alloc(rettv) == OK)
      {
--- 11067,11072 ----
***************
*** 11935,11941 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type != VAR_DICT)
      {
  	EMSG(_(e_dictreq));
--- 11912,11917 ----
***************
*** 12052,12059 ****
  	n = del_history_entry(get_histtype(str),
  				      get_tv_string_buf(&argvars[1], buf));
      rettv->vval.v_number = n;
- #else
-     rettv->vval.v_number = 0;
  #endif
  }
  
--- 12028,12033 ----
***************
*** 12415,12421 ****
      int		selected;
      int		mouse_used;
  
-     rettv->vval.v_number = 0;
  #ifdef NO_CONSOLE_INPUT
      /* While starting up, there is no place to enter text. */
      if (no_console_input())
--- 12389,12394 ----
***************
*** 12464,12470 ****
  	--ga_userinput.ga_len;
  	restore_typeahead((tasave_T *)(ga_userinput.ga_data)
  						       + ga_userinput.ga_len);
! 	rettv->vval.v_number = 0; /* OK */
      }
      else if (p_verbose > 1)
      {
--- 12437,12443 ----
  	--ga_userinput.ga_len;
  	restore_typeahead((tasave_T *)(ga_userinput.ga_data)
  						       + ga_userinput.ga_len);
! 	/* default return is zero == OK */
      }
      else if (p_verbose > 1)
      {
***************
*** 12488,12494 ****
  	save_typeahead((tasave_T *)(ga_userinput.ga_data)
  						       + ga_userinput.ga_len);
  	++ga_userinput.ga_len;
! 	rettv->vval.v_number = 0; /* OK */
      }
      else
  	rettv->vval.v_number = 1; /* Failed */
--- 12461,12467 ----
  	save_typeahead((tasave_T *)(ga_userinput.ga_data)
  						       + ga_userinput.ga_len);
  	++ga_userinput.ga_len;
! 	/* default return is zero == OK */
      }
      else
  	rettv->vval.v_number = 1; /* Failed */
***************
*** 12522,12528 ****
      list_T	*l;
      int		error = FALSE;
  
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type != VAR_LIST)
  	EMSG2(_(e_listarg), "insert()");
      else if ((l = argvars[0].vval.v_list) != NULL
--- 12495,12500 ----
***************
*** 12641,12647 ****
      dict_T	*d;
      int		todo;
  
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type != VAR_DICT)
      {
  	EMSG(_(e_dictreq));
--- 12613,12618 ----
***************
*** 12729,12735 ****
      garray_T	ga;
      char_u	*sep;
  
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type != VAR_LIST)
      {
  	EMSG(_(e_listreq));
--- 12700,12705 ----
***************
*** 12827,12835 ****
  #endif
  
      rettv->v_type = type;
!     if (type == VAR_NUMBER)
! 	rettv->vval.v_number = 0;
!     else
  	rettv->vval.v_string = NULL;
  
      if (check_restricted() || check_secure())
--- 12797,12803 ----
  #endif
  
      rettv->v_type = type;
!     if (type != VAR_NUMBER)
  	rettv->vval.v_string = NULL;
  
      if (check_restricted() || check_secure())
***************
*** 13770,13776 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
-     rettv->vval.v_number = 0;
  #ifdef FEAT_INS_EXPAND
      if (pum_visible())
  	rettv->vval.v_number = 1;
--- 13738,13743 ----
***************
*** 13804,13810 ****
  	    stride = get_tv_number_chk(&argvars[2], &error);
      }
  
-     rettv->vval.v_number = 0;
      if (error)
  	return;		/* type error; errmsg already given */
      if (stride == 0)
--- 13771,13776 ----
***************
*** 14193,14199 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
-     rettv->vval.v_number = 0;
  #ifdef FEAT_CLIENTSERVER
  # ifdef WIN32
      /* On Win32 it's done in this application. */
--- 14159,14164 ----
***************
*** 14249,14255 ****
  	rettv->vval.v_number = (s != NULL);
      }
  # else
-     rettv->vval.v_number = 0;
      if (check_connection() == FAIL)
  	return;
  
--- 14214,14219 ----
***************
*** 14338,14344 ****
      dict_T	*d;
      dictitem_T	*di;
  
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type == VAR_DICT)
      {
  	if (argvars[2].v_type != VAR_UNKNOWN)
--- 14302,14307 ----
***************
*** 14696,14702 ****
      list_T	*l;
      listitem_T	*li, *ni;
  
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type != VAR_LIST)
  	EMSG2(_(e_listarg), "reverse()");
      else if ((l = argvars[0].vval.v_list) != NULL
--- 14659,14664 ----
***************
*** 15048,15055 ****
      int		lnum = 0;
      int		col = 0;
  
-     rettv->vval.v_number = 0;
- 
      if (rettv_list_alloc(rettv) == FAIL)
  	return;
  
--- 15010,15015 ----
***************
*** 15236,15243 ****
      int		n;
      int		flags = 0;
  
-     rettv->vval.v_number = 0;
- 
      if (rettv_list_alloc(rettv) == FAIL)
  	return;
  
--- 15196,15201 ----
***************
*** 15323,15330 ****
      typval_T	*varp;
      char_u	nbuf[NUMBUFLEN];
  
-     rettv->vval.v_number = 0;
- 
      if (check_restricted() || check_secure())
  	return;
      (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
--- 15281,15286 ----
***************
*** 15404,15410 ****
      else
  	line = get_tv_string_chk(&argvars[1]);
  
!     rettv->vval.v_number = 0;		/* OK */
      for (;;)
      {
  	if (l != NULL)
--- 15360,15366 ----
      else
  	line = get_tv_string_chk(&argvars[1]);
  
!     /* default result is zero == OK */
      for (;;)
      {
  	if (l != NULL)
***************
*** 15717,15722 ****
--- 15673,15679 ----
  /*
   * "setwinvar()" and "settabwinvar()" functions
   */
+ /*ARGSUSED*/
      static void
  setwinvar(argvars, rettv, off)
      typval_T	*argvars;
***************
*** 15733,15740 ****
      char_u	nbuf[NUMBUFLEN];
      tabpage_T	*tp;
  
-     rettv->vval.v_number = 0;
- 
      if (check_restricted() || check_secure())
  	return;
  
--- 15690,15695 ----
***************
*** 15947,15953 ****
      long	len;
      long	i;
  
-     rettv->vval.v_number = 0;
      if (argvars[0].v_type != VAR_LIST)
  	EMSG2(_(e_listarg), "sort()");
      else
--- 15902,15907 ----
***************
*** 16870,16878 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
! #ifndef FEAT_WINDOWS
!     rettv->vval.v_number = 0;
! #else
      tabpage_T	*tp;
      win_T	*wp = NULL;
  
--- 16824,16830 ----
      typval_T	*argvars;
      typval_T	*rettv;
  {
! #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
      win_T	*wp = NULL;
  
***************
*** 16884,16902 ****
  	if (tp != NULL)
  	    wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
      }
!     if (wp == NULL)
! 	rettv->vval.v_number = 0;
!     else
      {
! 	if (rettv_list_alloc(rettv) == FAIL)
! 	    rettv->vval.v_number = 0;
! 	else
! 	{
! 	    for (; wp != NULL; wp = wp->w_next)
! 		if (list_append_number(rettv->vval.v_list,
  						wp->w_buffer->b_fnum) == FAIL)
! 		    break;
! 	}
      }
  #endif
  }
--- 16836,16847 ----
  	if (tp != NULL)
  	    wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
      }
!     if (wp != NULL && rettv_list_alloc(rettv) != FAIL)
      {
! 	for (; wp != NULL; wp = wp->w_next)
! 	    if (list_append_number(rettv->vval.v_list,
  						wp->w_buffer->b_fnum) == FAIL)
! 		break;
      }
  #endif
  }
***************
*** 17024,17033 ****
      int		first;
  
      if (rettv_list_alloc(rettv) == FAIL)
-     {
- 	rettv->vval.v_number = 0;
  	return;
-     }
  
      for (first = TRUE; ; first = FALSE)
  	if (get_tagfname(&tn, first, fname) == FAIL
--- 16969,16975 ----
***************
*** 17401,17408 ****
      /* A non-zero number or non-empty string argument: reset mode. */
      if (non_zero_arg(&argvars[0]))
  	curbuf->b_visual_mode_eval = NUL;
- #else
-     rettv->vval.v_number = 0; /* return anything, it won't work anyway */
  #endif
  }
  
--- 17343,17348 ----
*** ../vim-7.2.148/src/version.c	Wed Mar 18 19:07:09 2009
--- src/version.c	Wed Apr 22 12:44:05 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     149,
  /**/


-- 
WOMAN:   Well, 'ow did you become king then?
ARTHUR:  The Lady of the Lake, [angels sing] her arm clad in the purest
         shimmering samite, held aloft Excalibur from the bosom of the water
         signifying by Divine Providence that I, Arthur, was to carry
         Excalibur.  [singing stops] That is why I am your king!
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.150 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Note: I haven't tested this myself, since I don't have a compiler that
works for this code.

Patch 7.2.150 (extra)
Problem:    Can't use tab pages from VisVim.
Solution:   Add tab page support to VisVim. (Adam Slater)
Files:	    src/VisVim/Commands.cpp, src/VisVim/Resource.h,
	    src/VisVim/VisVim.rc


*** ../vim-7.2.149/src/VisVim/Commands.cpp	Thu May 10 20:45:34 2007
--- src/VisVim/Commands.cpp	Mon Mar  2 00:52:15 2009
***************
*** 20,39 ****
  
  static BOOL g_bEnableVim = TRUE;	// Vim enabled
  static BOOL g_bDevStudioEditor = FALSE;	// Open file in Dev Studio editor simultaneously
  static int g_ChangeDir = CD_NONE;	// CD after file open?
  
! static void VimSetEnableState (BOOL bEnableState);
! static BOOL VimOpenFile (BSTR& FileName, long LineNr);
! static DISPID VimGetDispatchId (COleAutomationControl& VimOle, char* Method);
! static void VimErrDiag (COleAutomationControl& VimOle);
! static void VimChangeDir (COleAutomationControl& VimOle, DISPID DispatchId, BSTR& FileName);
! static void DebugMsg (char* Msg, char* Arg = NULL);
  
  
  /////////////////////////////////////////////////////////////////////////////
  // CCommands
  
! CCommands::CCommands ()
  {
  	// m_pApplication == NULL; M$ Code generation bug!!!
  	m_pApplication = NULL;
--- 20,40 ----
  
  static BOOL g_bEnableVim = TRUE;	// Vim enabled
  static BOOL g_bDevStudioEditor = FALSE;	// Open file in Dev Studio editor simultaneously
+ static BOOL g_bNewTabs = FALSE;
  static int g_ChangeDir = CD_NONE;	// CD after file open?
  
! static void VimSetEnableState(BOOL bEnableState);
! static BOOL VimOpenFile(BSTR& FileName, long LineNr);
! static DISPID VimGetDispatchId(COleAutomationControl& VimOle, char* Method);
! static void VimErrDiag(COleAutomationControl& VimOle);
! static void VimChangeDir(COleAutomationControl& VimOle, DISPID DispatchId, BSTR& FileName);
! static void DebugMsg(char* Msg, char* Arg = NULL);
  
  
  /////////////////////////////////////////////////////////////////////////////
  // CCommands
  
! CCommands::CCommands()
  {
  	// m_pApplication == NULL; M$ Code generation bug!!!
  	m_pApplication = NULL;
***************
*** 41,57 ****
  	m_pDebuggerEventsObj = NULL;
  }
  
! CCommands::~CCommands ()
  {
! 	ASSERT (m_pApplication != NULL);
  	if (m_pApplication)
  	{
! 		m_pApplication->Release ();
  		m_pApplication = NULL;
  	}
  }
  
! void CCommands::SetApplicationObject (IApplication * pApplication)
  {
  	// This function assumes pApplication has already been AddRef'd
  	// for us, which CDSAddIn did in it's QueryInterface call
--- 42,58 ----
  	m_pDebuggerEventsObj = NULL;
  }
  
! CCommands::~CCommands()
  {
! 	ASSERT(m_pApplication != NULL);
  	if (m_pApplication)
  	{
! 		m_pApplication->Release();
  		m_pApplication = NULL;
  	}
  }
  
! void CCommands::SetApplicationObject(IApplication * pApplication)
  {
  	// This function assumes pApplication has already been AddRef'd
  	// for us, which CDSAddIn did in it's QueryInterface call
***************
*** 61,115 ****
  		return;
  
  	// Create Application event handlers
! 	XApplicationEventsObj::CreateInstance (&m_pApplicationEventsObj);
  	if (! m_pApplicationEventsObj)
  	{
! 		ReportInternalError ("XApplicationEventsObj::CreateInstance");
  		return;
  	}
! 	m_pApplicationEventsObj->AddRef ();
! 	m_pApplicationEventsObj->Connect (m_pApplication);
  	m_pApplicationEventsObj->m_pCommands = this;
  
  #ifdef NEVER
  	// Create Debugger event handler
  	CComPtr < IDispatch > pDebugger;
! 	if (SUCCEEDED (m_pApplication->get_Debugger (&pDebugger))
  	    && pDebugger != NULL)
  	{
! 		XDebuggerEventsObj::CreateInstance (&m_pDebuggerEventsObj);
! 		m_pDebuggerEventsObj->AddRef ();
! 		m_pDebuggerEventsObj->Connect (pDebugger);
  		m_pDebuggerEventsObj->m_pCommands = this;
  	}
  #endif
  
  	// Get settings from registry HKEY_CURRENT_USER\Software\Vim\VisVim
! 	HKEY hAppKey = GetAppKey ("Vim");
  	if (hAppKey)
  	{
! 		HKEY hSectionKey = GetSectionKey (hAppKey, "VisVim");
  		if (hSectionKey)
  		{
! 			g_bEnableVim = GetRegistryInt (hSectionKey, "EnableVim",
  						       g_bEnableVim);
! 			g_bDevStudioEditor = GetRegistryInt(hSectionKey,"DevStudioEditor",
! 							    g_bDevStudioEditor);
! 			g_ChangeDir = GetRegistryInt (hSectionKey, "ChangeDir",
  						      g_ChangeDir);
! 			RegCloseKey (hSectionKey);
  		}
! 		RegCloseKey (hAppKey);
  	}
  }
  
! void CCommands::UnadviseFromEvents ()
  {
! 	ASSERT (m_pApplicationEventsObj != NULL);
  	if (m_pApplicationEventsObj)
  	{
! 		m_pApplicationEventsObj->Disconnect (m_pApplication);
! 		m_pApplicationEventsObj->Release ();
  		m_pApplicationEventsObj = NULL;
  	}
  
--- 62,118 ----
  		return;
  
  	// Create Application event handlers
! 	XApplicationEventsObj::CreateInstance(&m_pApplicationEventsObj);
  	if (! m_pApplicationEventsObj)
  	{
! 		ReportInternalError("XApplicationEventsObj::CreateInstance");
  		return;
  	}
! 	m_pApplicationEventsObj->AddRef();
! 	m_pApplicationEventsObj->Connect(m_pApplication);
  	m_pApplicationEventsObj->m_pCommands = this;
  
  #ifdef NEVER
  	// Create Debugger event handler
  	CComPtr < IDispatch > pDebugger;
! 	if (SUCCEEDED(m_pApplication->get_Debugger(&pDebugger))
  	    && pDebugger != NULL)
  	{
! 		XDebuggerEventsObj::CreateInstance(&m_pDebuggerEventsObj);
! 		m_pDebuggerEventsObj->AddRef();
! 		m_pDebuggerEventsObj->Connect(pDebugger);
  		m_pDebuggerEventsObj->m_pCommands = this;
  	}
  #endif
  
  	// Get settings from registry HKEY_CURRENT_USER\Software\Vim\VisVim
! 	HKEY hAppKey = GetAppKey("Vim");
  	if (hAppKey)
  	{
! 		HKEY hSectionKey = GetSectionKey(hAppKey, "VisVim");
  		if (hSectionKey)
  		{
! 			g_bEnableVim = GetRegistryInt(hSectionKey, "EnableVim",
  						       g_bEnableVim);
! 			g_bDevStudioEditor = GetRegistryInt(hSectionKey,
! 					"DevStudioEditor", g_bDevStudioEditor);
! 			g_bNewTabs = GetRegistryInt(hSectionKey, "NewTabs",
! 						    g_bNewTabs);
! 			g_ChangeDir = GetRegistryInt(hSectionKey, "ChangeDir",
  						      g_ChangeDir);
! 			RegCloseKey(hSectionKey);
  		}
! 		RegCloseKey(hAppKey);
  	}
  }
  
! void CCommands::UnadviseFromEvents()
  {
! 	ASSERT(m_pApplicationEventsObj != NULL);
  	if (m_pApplicationEventsObj)
  	{
! 		m_pApplicationEventsObj->Disconnect(m_pApplication);
! 		m_pApplicationEventsObj->Release();
  		m_pApplicationEventsObj = NULL;
  	}
  
***************
*** 121,130 ****
  		// unadvise from its events (thus the VERIFY_OK below--see
  		// stdafx.h).
  		CComPtr < IDispatch > pDebugger;
! 		VERIFY_OK (m_pApplication->get_Debugger (&pDebugger));
! 		ASSERT (pDebugger != NULL);
! 		m_pDebuggerEventsObj->Disconnect (pDebugger);
! 		m_pDebuggerEventsObj->Release ();
  		m_pDebuggerEventsObj = NULL;
  	}
  #endif
--- 124,133 ----
  		// unadvise from its events (thus the VERIFY_OK below--see
  		// stdafx.h).
  		CComPtr < IDispatch > pDebugger;
! 		VERIFY_OK(m_pApplication->get_Debugger(&pDebugger));
! 		ASSERT(pDebugger != NULL);
! 		m_pDebuggerEventsObj->Disconnect(pDebugger);
! 		m_pDebuggerEventsObj->Release();
  		m_pDebuggerEventsObj = NULL;
  	}
  #endif
***************
*** 136,156 ****
  
  // Application events
  
! HRESULT CCommands::XApplicationEvents::BeforeBuildStart ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::BuildFinish (long nNumErrors, long nNumWarnings)
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::BeforeApplicationShutDown ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
--- 139,159 ----
  
  // Application events
  
! HRESULT CCommands::XApplicationEvents::BeforeBuildStart()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::BuildFinish(long nNumErrors, long nNumWarnings)
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::BeforeApplicationShutDown()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
***************
*** 158,166 ****
  // is done.
  // Vim gets called from here.
  //
! HRESULT CCommands::XApplicationEvents::DocumentOpen (IDispatch * theDocument)
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  
  	if (! g_bEnableVim)
  		// Vim not enabled or empty command line entered
--- 161,169 ----
  // is done.
  // Vim gets called from here.
  //
! HRESULT CCommands::XApplicationEvents::DocumentOpen(IDispatch * theDocument)
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  	if (! g_bEnableVim)
  		// Vim not enabled or empty command line entered
***************
*** 169,175 ****
  	// First get the current file name and line number
  
  	// Get the document object
! 	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc (theDocument);
  	if (! pDoc)
  		return S_OK;
  
--- 172,178 ----
  	// First get the current file name and line number
  
  	// Get the document object
! 	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc(theDocument);
  	if (! pDoc)
  		return S_OK;
  
***************
*** 177,202 ****
  	long LineNr = -1;
  
  	// Get the document name
! 	if (FAILED (pDoc->get_FullName (&FileName)))
  		return S_OK;
  
  	LPDISPATCH pDispSel;
  
  	// Get a selection object dispatch pointer
! 	if (SUCCEEDED (pDoc->get_Selection (&pDispSel)))
  	{
  		// Get the selection object
! 		CComQIPtr < ITextSelection, &IID_ITextSelection > pSel (pDispSel);
  
  		if (pSel)
  			// Get the selection line number
! 			pSel->get_CurrentLine (&LineNr);
  
! 		pDispSel->Release ();
  	}
  
  	// Open the file in Vim and position to the current line
! 	if (VimOpenFile (FileName, LineNr))
  	{
  		if (! g_bDevStudioEditor)
  		{
--- 180,205 ----
  	long LineNr = -1;
  
  	// Get the document name
! 	if (FAILED(pDoc->get_FullName(&FileName)))
  		return S_OK;
  
  	LPDISPATCH pDispSel;
  
  	// Get a selection object dispatch pointer
! 	if (SUCCEEDED(pDoc->get_Selection(&pDispSel)))
  	{
  		// Get the selection object
! 		CComQIPtr < ITextSelection, &IID_ITextSelection > pSel(pDispSel);
  
  		if (pSel)
  			// Get the selection line number
! 			pSel->get_CurrentLine(&LineNr);
  
! 		pDispSel->Release();
  	}
  
  	// Open the file in Vim and position to the current line
! 	if (VimOpenFile(FileName, LineNr))
  	{
  		if (! g_bDevStudioEditor)
  		{
***************
*** 204,233 ****
  			CComVariant vSaveChanges = dsSaveChangesPrompt;
  			DsSaveStatus Saved;
  
! 			pDoc->Close (vSaveChanges, &Saved);
  		}
  	}
  
  	// We're done here
! 	SysFreeString (FileName);
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::BeforeDocumentClose (IDispatch * theDocument)
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::DocumentSave (IDispatch * theDocument)
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::NewDocument (IDispatch * theDocument)
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  
  	if (! g_bEnableVim)
  		// Vim not enabled or empty command line entered
--- 207,236 ----
  			CComVariant vSaveChanges = dsSaveChangesPrompt;
  			DsSaveStatus Saved;
  
! 			pDoc->Close(vSaveChanges, &Saved);
  		}
  	}
  
  	// We're done here
! 	SysFreeString(FileName);
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::BeforeDocumentClose(IDispatch * theDocument)
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::DocumentSave(IDispatch * theDocument)
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::NewDocument(IDispatch * theDocument)
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  	if (! g_bEnableVim)
  		// Vim not enabled or empty command line entered
***************
*** 235,253 ****
  
  	// First get the current file name and line number
  
! 	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc (theDocument);
  	if (! pDoc)
  		return S_OK;
  
  	BSTR FileName;
  	HRESULT hr;
  
! 	hr = pDoc->get_FullName (&FileName);
! 	if (FAILED (hr))
  		return S_OK;
  
  	// Open the file in Vim and position to the current line
! 	if (VimOpenFile (FileName, 0))
  	{
  		if (! g_bDevStudioEditor)
  		{
--- 238,256 ----
  
  	// First get the current file name and line number
  
! 	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc(theDocument);
  	if (! pDoc)
  		return S_OK;
  
  	BSTR FileName;
  	HRESULT hr;
  
! 	hr = pDoc->get_FullName(&FileName);
! 	if (FAILED(hr))
  		return S_OK;
  
  	// Open the file in Vim and position to the current line
! 	if (VimOpenFile(FileName, 0))
  	{
  		if (! g_bDevStudioEditor)
  		{
***************
*** 255,303 ****
  			CComVariant vSaveChanges = dsSaveChangesPrompt;
  			DsSaveStatus Saved;
  
! 			pDoc->Close (vSaveChanges, &Saved);
  		}
  	}
  
! 	SysFreeString (FileName);
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::WindowActivate (IDispatch * theWindow)
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::WindowDeactivate (IDispatch * theWindow)
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::WorkspaceOpen ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::WorkspaceClose ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::NewWorkspace ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
  // Debugger event
  
! HRESULT CCommands::XDebuggerEvents::BreakpointHit (IDispatch * pBreakpoint)
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  	return S_OK;
  }
  
--- 258,306 ----
  			CComVariant vSaveChanges = dsSaveChangesPrompt;
  			DsSaveStatus Saved;
  
! 			pDoc->Close(vSaveChanges, &Saved);
  		}
  	}
  
! 	SysFreeString(FileName);
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::WindowActivate(IDispatch * theWindow)
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::WindowDeactivate(IDispatch * theWindow)
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::WorkspaceOpen()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::WorkspaceClose()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
! HRESULT CCommands::XApplicationEvents::NewWorkspace()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
  // Debugger event
  
! HRESULT CCommands::XDebuggerEvents::BreakpointHit(IDispatch * pBreakpoint)
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  	return S_OK;
  }
  
***************
*** 308,324 ****
  class CMainDialog : public CDialog
  {
      public:
! 	CMainDialog (CWnd * pParent = NULL);	// Standard constructor
  
  	//{{AFX_DATA(CMainDialog)
  	enum { IDD = IDD_ADDINMAIN };
  	int	m_ChangeDir;
  	BOOL	m_bDevStudioEditor;
  	//}}AFX_DATA
  
  	//{{AFX_VIRTUAL(CMainDialog)
      protected:
! 	virtual void DoDataExchange (CDataExchange * pDX);	// DDX/DDV support
  	//}}AFX_VIRTUAL
  
      protected:
--- 311,328 ----
  class CMainDialog : public CDialog
  {
      public:
! 	CMainDialog(CWnd * pParent = NULL);	// Standard constructor
  
  	//{{AFX_DATA(CMainDialog)
  	enum { IDD = IDD_ADDINMAIN };
  	int	m_ChangeDir;
  	BOOL	m_bDevStudioEditor;
+ 	BOOL	m_bNewTabs;
  	//}}AFX_DATA
  
  	//{{AFX_VIRTUAL(CMainDialog)
      protected:
! 	virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
  	//}}AFX_VIRTUAL
  
      protected:
***************
*** 326,425 ****
  	afx_msg void OnEnable();
  	afx_msg void OnDisable();
  	//}}AFX_MSG
! 	DECLARE_MESSAGE_MAP ()
  };
  
! CMainDialog::CMainDialog (CWnd * pParent /* =NULL */ )
! 	: CDialog (CMainDialog::IDD, pParent)
  {
  	//{{AFX_DATA_INIT(CMainDialog)
  	m_ChangeDir = -1;
  	m_bDevStudioEditor = FALSE;
  	//}}AFX_DATA_INIT
  }
  
! void CMainDialog::DoDataExchange (CDataExchange * pDX)
  {
! 	CDialog::DoDataExchange (pDX);
  	//{{AFX_DATA_MAP(CMainDialog)
  	DDX_Radio(pDX, IDC_CD_SOURCE_PATH, m_ChangeDir);
! 	DDX_Check (pDX, IDC_DEVSTUDIO_EDITOR, m_bDevStudioEditor);
  	//}}AFX_DATA_MAP
  }
  
! BEGIN_MESSAGE_MAP (CMainDialog, CDialog)
  	//{{AFX_MSG_MAP(CMainDialog)
  	//}}AFX_MSG_MAP
! END_MESSAGE_MAP ()
  
  
  /////////////////////////////////////////////////////////////////////////////
  // CCommands methods
  
! STDMETHODIMP CCommands::VisVimDialog ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  
  	// Use m_pApplication to access the Developer Studio Application
  	// object,
  	// and VERIFY_OK to see error strings in DEBUG builds of your add-in
  	// (see stdafx.h)
  
! 	VERIFY_OK (m_pApplication->EnableModeless (VARIANT_FALSE));
  
  	CMainDialog Dlg;
  
  	Dlg.m_bDevStudioEditor = g_bDevStudioEditor;
  	Dlg.m_ChangeDir = g_ChangeDir;
! 	if (Dlg.DoModal () == IDOK)
  	{
  		g_bDevStudioEditor = Dlg.m_bDevStudioEditor;
  		g_ChangeDir = Dlg.m_ChangeDir;
  
  		// Save settings to registry HKEY_CURRENT_USER\Software\Vim\VisVim
! 		HKEY hAppKey = GetAppKey ("Vim");
  		if (hAppKey)
  		{
! 			HKEY hSectionKey = GetSectionKey (hAppKey, "VisVim");
  			if (hSectionKey)
  			{
! 				WriteRegistryInt (hSectionKey, "DevStudioEditor",
  						  g_bDevStudioEditor);
! 				WriteRegistryInt (hSectionKey, "ChangeDir", g_ChangeDir);
! 				RegCloseKey (hSectionKey);
  			}
! 			RegCloseKey (hAppKey);
  		}
  	}
  
! 	VERIFY_OK (m_pApplication->EnableModeless (VARIANT_TRUE));
  	return S_OK;
  }
  
! STDMETHODIMP CCommands::VisVimEnable ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
! 	VimSetEnableState (true);
  	return S_OK;
  }
  
! STDMETHODIMP CCommands::VisVimDisable ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
! 	VimSetEnableState (false);
  	return S_OK;
  }
  
! STDMETHODIMP CCommands::VisVimToggle ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
! 	VimSetEnableState (! g_bEnableVim);
  	return S_OK;
  }
  
! STDMETHODIMP CCommands::VisVimLoad ()
  {
! 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
  
  	// Use m_pApplication to access the Developer Studio Application object,
  	// and VERIFY_OK to see error strings in DEBUG builds of your add-in
--- 330,435 ----
  	afx_msg void OnEnable();
  	afx_msg void OnDisable();
  	//}}AFX_MSG
! 	DECLARE_MESSAGE_MAP()
  };
  
! CMainDialog::CMainDialog(CWnd * pParent /* =NULL */ )
! 	: CDialog(CMainDialog::IDD, pParent)
  {
  	//{{AFX_DATA_INIT(CMainDialog)
  	m_ChangeDir = -1;
  	m_bDevStudioEditor = FALSE;
+ 	m_bNewTabs = FALSE;
  	//}}AFX_DATA_INIT
  }
  
! void CMainDialog::DoDataExchange(CDataExchange * pDX)
  {
! 	CDialog::DoDataExchange(pDX);
  	//{{AFX_DATA_MAP(CMainDialog)
  	DDX_Radio(pDX, IDC_CD_SOURCE_PATH, m_ChangeDir);
! 	DDX_Check(pDX, IDC_DEVSTUDIO_EDITOR, m_bDevStudioEditor);
! 	DDX_Check(pDX, IDC_NEW_TABS, m_bNewTabs);
  	//}}AFX_DATA_MAP
  }
  
! BEGIN_MESSAGE_MAP(CMainDialog, CDialog)
  	//{{AFX_MSG_MAP(CMainDialog)
  	//}}AFX_MSG_MAP
! END_MESSAGE_MAP()
  
  
  /////////////////////////////////////////////////////////////////////////////
  // CCommands methods
  
! STDMETHODIMP CCommands::VisVimDialog()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  	// Use m_pApplication to access the Developer Studio Application
  	// object,
  	// and VERIFY_OK to see error strings in DEBUG builds of your add-in
  	// (see stdafx.h)
  
! 	VERIFY_OK(m_pApplication->EnableModeless(VARIANT_FALSE));
  
  	CMainDialog Dlg;
  
  	Dlg.m_bDevStudioEditor = g_bDevStudioEditor;
+ 	Dlg.m_bNewTabs = g_bNewTabs;
  	Dlg.m_ChangeDir = g_ChangeDir;
! 	if (Dlg.DoModal() == IDOK)
  	{
  		g_bDevStudioEditor = Dlg.m_bDevStudioEditor;
+ 		g_bNewTabs = Dlg.m_bNewTabs;
  		g_ChangeDir = Dlg.m_ChangeDir;
  
  		// Save settings to registry HKEY_CURRENT_USER\Software\Vim\VisVim
! 		HKEY hAppKey = GetAppKey("Vim");
  		if (hAppKey)
  		{
! 			HKEY hSectionKey = GetSectionKey(hAppKey, "VisVim");
  			if (hSectionKey)
  			{
! 				WriteRegistryInt(hSectionKey, "DevStudioEditor",
  						  g_bDevStudioEditor);
! 				WriteRegistryInt(hSectionKey, "NewTabs",
! 						  g_bNewTabs);
! 				WriteRegistryInt(hSectionKey, "ChangeDir", g_ChangeDir);
! 				RegCloseKey(hSectionKey);
  			}
! 			RegCloseKey(hAppKey);
  		}
  	}
  
! 	VERIFY_OK(m_pApplication->EnableModeless(VARIANT_TRUE));
  	return S_OK;
  }
  
! STDMETHODIMP CCommands::VisVimEnable()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
! 	VimSetEnableState(true);
  	return S_OK;
  }
  
! STDMETHODIMP CCommands::VisVimDisable()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
! 	VimSetEnableState(false);
  	return S_OK;
  }
  
! STDMETHODIMP CCommands::VisVimToggle()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
! 	VimSetEnableState(! g_bEnableVim);
  	return S_OK;
  }
  
! STDMETHODIMP CCommands::VisVimLoad()
  {
! 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  	// Use m_pApplication to access the Developer Studio Application object,
  	// and VERIFY_OK to see error strings in DEBUG builds of your add-in
***************
*** 430,436 ****
  	CComPtr < IDispatch > pDispDoc, pDispSel;
  
  	// Get a document object dispatch pointer
! 	VERIFY_OK (m_pApplication->get_ActiveDocument (&pDispDoc));
  	if (! pDispDoc)
  		return S_OK;
  
--- 440,446 ----
  	CComPtr < IDispatch > pDispDoc, pDispSel;
  
  	// Get a document object dispatch pointer
! 	VERIFY_OK(m_pApplication->get_ActiveDocument(&pDispDoc));
  	if (! pDispDoc)
  		return S_OK;
  
***************
*** 438,467 ****
  	long LineNr = -1;
  
  	// Get the document object
! 	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc (pDispDoc);
  
  	if (! pDoc)
  		return S_OK;
  
  	// Get the document name
! 	if (FAILED (pDoc->get_FullName (&FileName)))
  		return S_OK;
  
  	// Get a selection object dispatch pointer
! 	if (SUCCEEDED (pDoc->get_Selection (&pDispSel)))
  	{
  		// Get the selection object
! 		CComQIPtr < ITextSelection, &IID_ITextSelection > pSel (pDispSel);
  
  		if (pSel)
  			// Get the selection line number
! 			pSel->get_CurrentLine (&LineNr);
  	}
  
  	// Open the file in Vim
! 	VimOpenFile (FileName, LineNr);
  
! 	SysFreeString (FileName);
  	return S_OK;
  }
  
--- 448,477 ----
  	long LineNr = -1;
  
  	// Get the document object
! 	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc(pDispDoc);
  
  	if (! pDoc)
  		return S_OK;
  
  	// Get the document name
! 	if (FAILED(pDoc->get_FullName(&FileName)))
  		return S_OK;
  
  	// Get a selection object dispatch pointer
! 	if (SUCCEEDED(pDoc->get_Selection(&pDispSel)))
  	{
  		// Get the selection object
! 		CComQIPtr < ITextSelection, &IID_ITextSelection > pSel(pDispSel);
  
  		if (pSel)
  			// Get the selection line number
! 			pSel->get_CurrentLine(&LineNr);
  	}
  
  	// Open the file in Vim
! 	VimOpenFile(FileName, LineNr);
  
! 	SysFreeString(FileName);
  	return S_OK;
  }
  
***************
*** 472,487 ****
  
  // Set the enable state and save to registry
  //
! static void VimSetEnableState (BOOL bEnableState)
  {
  	g_bEnableVim = bEnableState;
! 	HKEY hAppKey = GetAppKey ("Vim");
  	if (hAppKey)
  	{
! 		HKEY hSectionKey = GetSectionKey (hAppKey, "VisVim");
  		if (hSectionKey)
! 			WriteRegistryInt (hSectionKey, "EnableVim", g_bEnableVim);
! 		RegCloseKey (hAppKey);
  	}
  }
  
--- 482,497 ----
  
  // Set the enable state and save to registry
  //
! static void VimSetEnableState(BOOL bEnableState)
  {
  	g_bEnableVim = bEnableState;
! 	HKEY hAppKey = GetAppKey("Vim");
  	if (hAppKey)
  	{
! 		HKEY hSectionKey = GetSectionKey(hAppKey, "VisVim");
  		if (hSectionKey)
! 			WriteRegistryInt(hSectionKey, "EnableVim", g_bEnableVim);
! 		RegCloseKey(hAppKey);
  	}
  }
  
***************
*** 490,496 ****
  // letter.
  // 'LineNr' must contain a valid line number or 0, e. g. for a new file
  //
! static BOOL VimOpenFile (BSTR& FileName, long LineNr)
  {
  
  	// OLE automation object for com. with Vim
--- 500,506 ----
  // letter.
  // 'LineNr' must contain a valid line number or 0, e. g. for a new file
  //
! static BOOL VimOpenFile(BSTR& FileName, long LineNr)
  {
  
  	// OLE automation object for com. with Vim
***************
*** 507,513 ****
  	// Get a dispatch id for the SendKeys method of Vim;
  	// enables connection to Vim if necessary
  	DISPID DispatchId;
! 	DispatchId = VimGetDispatchId (VimOle, "SendKeys");
  	if (! DispatchId)
  		// OLE error, can't obtain dispatch id
  		goto OleError;
--- 517,523 ----
  	// Get a dispatch id for the SendKeys method of Vim;
  	// enables connection to Vim if necessary
  	DISPID DispatchId;
! 	DispatchId = VimGetDispatchId(VimOle, "SendKeys");
  	if (! DispatchId)
  		// OLE error, can't obtain dispatch id
  		goto OleError;
***************
*** 525,544 ****
  #ifdef SINGLE_WINDOW
  	// Update the current file in Vim if it has been modified.
  	// Disabled, because it could write the file when you don't want to.
! 	sprintf (VimCmd + 2, ":up\n");
  #endif
! 	if (! VimOle.Method (DispatchId, "s", TO_OLE_STR_BUF (VimCmd, Buf)))
  		goto OleError;
  
  	// Change Vim working directory to where the file is if desired
  	if (g_ChangeDir != CD_NONE)
! 		VimChangeDir (VimOle, DispatchId, FileName);
  
  	// Make Vim open the file.
  	// In the filename convert all \ to /, put a \ before a space.
! 	sprintf(VimCmd, ":drop ");
  	sprintf(FileNameTmp, "%S", (char *)FileName);
- 	s = VimCmd + 6;
  	for (p = FileNameTmp; *p != '\0' && s < FileNameTmp + MAX_OLE_STR - 4;
  									  ++p)
  		if (*p == '\\')
--- 535,562 ----
  #ifdef SINGLE_WINDOW
  	// Update the current file in Vim if it has been modified.
  	// Disabled, because it could write the file when you don't want to.
! 	sprintf(VimCmd + 2, ":up\n");
  #endif
! 	if (! VimOle.Method(DispatchId, "s", TO_OLE_STR_BUF(VimCmd, Buf)))
  		goto OleError;
  
  	// Change Vim working directory to where the file is if desired
  	if (g_ChangeDir != CD_NONE)
! 		VimChangeDir(VimOle, DispatchId, FileName);
  
  	// Make Vim open the file.
  	// In the filename convert all \ to /, put a \ before a space.
! 	if (g_bNewTabs)
! 	{
! 		sprintf(VimCmd, ":tab drop ");
! 		s = VimCmd + 11;
! 	}
! 	else
! 	{
! 		sprintf(VimCmd, ":drop ");
! 		s = VimCmd + 6;
! 	}
  	sprintf(FileNameTmp, "%S", (char *)FileName);
  	for (p = FileNameTmp; *p != '\0' && s < FileNameTmp + MAX_OLE_STR - 4;
  									  ++p)
  		if (*p == '\\')
***************
*** 552,571 ****
  	*s++ = '\n';
  	*s = '\0';
  
! 	if (! VimOle.Method (DispatchId, "s", TO_OLE_STR_BUF (VimCmd, Buf)))
  		goto OleError;
  
  	if (LineNr > 0)
  	{
  		// Goto line
! 		sprintf (VimCmd, ":%d\n", LineNr);
! 		if (! VimOle.Method (DispatchId, "s", TO_OLE_STR_BUF (VimCmd, Buf)))
  			goto OleError;
  	}
  
  	// Make Vim come to the foreground
! 	if (! VimOle.Method ("SetForeground"))
! 		VimOle.ErrDiag ();
  
  	// We're done
  	return true;
--- 570,589 ----
  	*s++ = '\n';
  	*s = '\0';
  
! 	if (! VimOle.Method(DispatchId, "s", TO_OLE_STR_BUF(VimCmd, Buf)))
  		goto OleError;
  
  	if (LineNr > 0)
  	{
  		// Goto line
! 		sprintf(VimCmd, ":%d\n", LineNr);
! 		if (! VimOle.Method(DispatchId, "s", TO_OLE_STR_BUF(VimCmd, Buf)))
  			goto OleError;
  	}
  
  	// Make Vim come to the foreground
! 	if (! VimOle.Method("SetForeground"))
! 		VimOle.ErrDiag();
  
  	// We're done
  	return true;
***************
*** 573,579 ****
      OleError:
  	// There was an OLE error
  	// Check if it's the "unknown class string" error
! 	VimErrDiag (VimOle);
  	return false;
  }
  
--- 591,597 ----
      OleError:
  	// There was an OLE error
  	// Check if it's the "unknown class string" error
! 	VimErrDiag(VimOle);
  	return false;
  }
  
***************
*** 581,598 ****
  // Create the Vim OLE object if necessary
  // Returns a valid dispatch id or null on error
  //
! static DISPID VimGetDispatchId (COleAutomationControl& VimOle, char* Method)
  {
  	// Initialize Vim OLE connection if not already done
! 	if (! VimOle.IsCreated ())
  	{
! 		if (! VimOle.CreateObject ("Vim.Application"))
  			return NULL;
  	}
  
  	// Get the dispatch id for the SendKeys method.
  	// By doing this, we are checking if Vim is still there...
! 	DISPID DispatchId = VimOle.GetDispatchId ("SendKeys");
  	if (! DispatchId)
  	{
  		// We can't get a dispatch id.
--- 599,616 ----
  // Create the Vim OLE object if necessary
  // Returns a valid dispatch id or null on error
  //
! static DISPID VimGetDispatchId(COleAutomationControl& VimOle, char* Method)
  {
  	// Initialize Vim OLE connection if not already done
! 	if (! VimOle.IsCreated())
  	{
! 		if (! VimOle.CreateObject("Vim.Application"))
  			return NULL;
  	}
  
  	// Get the dispatch id for the SendKeys method.
  	// By doing this, we are checking if Vim is still there...
! 	DISPID DispatchId = VimOle.GetDispatchId("SendKeys");
  	if (! DispatchId)
  	{
  		// We can't get a dispatch id.
***************
*** 604,615 ****
  		// should not be kept long enough to allow the user to terminate Vim
  		// to avoid memory corruption (why the heck is there no system garbage
  		// collection for those damned OLE memory chunks???).
! 		VimOle.DeleteObject ();
! 		if (! VimOle.CreateObject ("Vim.Application"))
  			// If this create fails, it's time for an error msg
  			return NULL;
  
! 		if (! (DispatchId = VimOle.GetDispatchId ("SendKeys")))
  			// There is something wrong...
  			return NULL;
  	}
--- 622,633 ----
  		// should not be kept long enough to allow the user to terminate Vim
  		// to avoid memory corruption (why the heck is there no system garbage
  		// collection for those damned OLE memory chunks???).
! 		VimOle.DeleteObject();
! 		if (! VimOle.CreateObject("Vim.Application"))
  			// If this create fails, it's time for an error msg
  			return NULL;
  
! 		if (! (DispatchId = VimOle.GetDispatchId("SendKeys")))
  			// There is something wrong...
  			return NULL;
  	}
***************
*** 620,639 ****
  // Output an error message for an OLE error
  // Check on the classstring error, which probably means Vim wasn't registered.
  //
! static void VimErrDiag (COleAutomationControl& VimOle)
  {
! 	SCODE sc = GetScode (VimOle.GetResult ());
  	if (sc == CO_E_CLASSSTRING)
  	{
  		char Buf[256];
! 		sprintf (Buf, "There is no registered OLE automation server named "
  			 "\"Vim.Application\".\n"
  			 "Use the OLE-enabled version of Vim with VisVim and "
  			 "make sure to register Vim by running \"vim -register\".");
! 		MessageBox (NULL, Buf, "OLE Error", MB_OK);
  	}
  	else
! 		VimOle.ErrDiag ();
  }
  
  // Change directory to the directory the file 'FileName' is in or it's parent
--- 638,657 ----
  // Output an error message for an OLE error
  // Check on the classstring error, which probably means Vim wasn't registered.
  //
! static void VimErrDiag(COleAutomationControl& VimOle)
  {
! 	SCODE sc = GetScode(VimOle.GetResult());
  	if (sc == CO_E_CLASSSTRING)
  	{
  		char Buf[256];
! 		sprintf(Buf, "There is no registered OLE automation server named "
  			 "\"Vim.Application\".\n"
  			 "Use the OLE-enabled version of Vim with VisVim and "
  			 "make sure to register Vim by running \"vim -register\".");
! 		MessageBox(NULL, Buf, "OLE Error", MB_OK);
  	}
  	else
! 		VimOle.ErrDiag();
  }
  
  // Change directory to the directory the file 'FileName' is in or it's parent
***************
*** 644,650 ****
  //	CD_SOURCE_PATH
  //	CD_SOURCE_PARENT
  //
! static void VimChangeDir (COleAutomationControl& VimOle, DISPID DispatchId, BSTR& FileName)
  {
  	// Do a :cd first
  
--- 662,668 ----
  //	CD_SOURCE_PATH
  //	CD_SOURCE_PARENT
  //
! static void VimChangeDir(COleAutomationControl& VimOle, DISPID DispatchId, BSTR& FileName)
  {
  	// Do a :cd first
  
***************
*** 655,661 ****
  	char DirUnix[_MAX_DIR * 2];
  	char *s, *t;
  
! 	_splitpath (StrFileName, Drive, Dir, NULL, NULL);
  
  	// Convert to Unix path name format, escape spaces.
  	t = DirUnix;
--- 673,679 ----
  	char DirUnix[_MAX_DIR * 2];
  	char *s, *t;
  
! 	_splitpath(StrFileName, Drive, Dir, NULL, NULL);
  
  	// Convert to Unix path name format, escape spaces.
  	t = DirUnix;
***************
*** 676,694 ****
  	OLECHAR Buf[MAX_OLE_STR];
  	char VimCmd[MAX_OLE_STR];
  
! 	sprintf (VimCmd, ":cd %s%s%s\n", Drive, DirUnix,
  		 g_ChangeDir == CD_SOURCE_PARENT && DirUnix[1] ? ".." : "");
! 	VimOle.Method (DispatchId, "s", TO_OLE_STR_BUF (VimCmd, Buf));
  }
  
  #ifdef _DEBUG
  // Print out a debug message
  //
! static void DebugMsg (char* Msg, char* Arg)
  {
  	char Buf[400];
! 	sprintf (Buf, Msg, Arg);
! 	AfxMessageBox (Buf);
  }
  #endif
- 
--- 694,711 ----
  	OLECHAR Buf[MAX_OLE_STR];
  	char VimCmd[MAX_OLE_STR];
  
! 	sprintf(VimCmd, ":cd %s%s%s\n", Drive, DirUnix,
  		 g_ChangeDir == CD_SOURCE_PARENT && DirUnix[1] ? ".." : "");
! 	VimOle.Method(DispatchId, "s", TO_OLE_STR_BUF(VimCmd, Buf));
  }
  
  #ifdef _DEBUG
  // Print out a debug message
  //
! static void DebugMsg(char* Msg, char* Arg)
  {
  	char Buf[400];
! 	sprintf(Buf, Msg, Arg);
! 	AfxMessageBox(Buf);
  }
  #endif
*** ../vim-7.2.149/src/VisVim/Resource.h	Sun Jun 13 19:17:32 2004
--- src/VisVim/Resource.h	Mon Mar  2 00:39:21 2009
***************
*** 16,21 ****
--- 16,22 ----
  #define IDC_CD_SOURCE_PATH		1001
  #define IDC_CD_SOURCE_PARENT		1002
  #define IDC_CD_NONE			1003
+ #define IDC_NEW_TABS			1004
  
  // Next default values for new objects
  //
*** ../vim-7.2.149/src/VisVim/VisVim.rc	Sun Jun 13 19:38:03 2004
--- src/VisVim/VisVim.rc	Mon Mar  2 00:40:19 2009
***************
*** 122,127 ****
--- 122,130 ----
      CONTROL         "&Open file in DevStudio editor simultaneously",
                      IDC_DEVSTUDIO_EDITOR,"Button",BS_AUTOCHECKBOX | WS_GROUP | 
                      WS_TABSTOP,7,7,153,10
+     CONTROL         "Open files in new tabs",
+                     IDC_NEW_TABS,"Button",BS_AUTOCHECKBOX | WS_GROUP | 
+                     WS_TABSTOP,7,21,153,10
      GROUPBOX        "Current directory",IDC_STATIC,7,35,164,58,WS_GROUP
      CONTROL         "Set to &source file path",IDC_CD_SOURCE_PATH,"Button",
                      BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,17,49,85,10
*** ../vim-7.2.149/src/version.c	Wed Apr 22 12:53:31 2009
--- src/version.c	Wed Apr 22 13:04:32 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     150,
  /**/

-- 
A poem:                read aloud:

<> !*''#               Waka waka bang splat tick tick hash,
^"`$$-                 Caret quote back-tick dollar dollar dash,
!*=@$_                 Bang splat equal at dollar under-score,
%*<> ~#4               Percent splat waka waka tilde number four,
&[]../                 Ampersand bracket bracket dot dot slash,
|{,,SYSTEM HALTED      Vertical-bar curly-bracket comma comma CRASH.

Fred Bremmer and Steve Kroese (Calvin College & Seminary of Grand Rapids, MI.)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.151
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.151
Problem:    ":hist a" doesn't work like ":hist all" as the docs suggest.
Solution:   Make ":hist a" and ":hist al" work. (Dominique Pelle)
Files:	    src/ex_getln.c


*** ../vim-7.2.150/src/ex_getln.c	Wed Mar 18 12:50:58 2009
--- src/ex_getln.c	Sun Apr 12 13:36:06 2009
***************
*** 5686,5692 ****
  	histype1 = get_histtype(arg);
  	if (histype1 == -1)
  	{
! 	    if (STRICMP(arg, "all") == 0)
  	    {
  		histype1 = 0;
  		histype2 = HIST_COUNT-1;
--- 5686,5692 ----
  	histype1 = get_histtype(arg);
  	if (histype1 == -1)
  	{
! 	    if (STRNICMP(arg, "all", STRLEN(arg)) == 0)
  	    {
  		histype1 = 0;
  		histype2 = HIST_COUNT-1;
*** ../vim-7.2.150/src/version.c	Wed Apr 22 13:06:11 2009
--- src/version.c	Wed Apr 22 13:49:41 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     151,
  /**/

-- 
I'm sure that I asked CBuilder to do a "full" install.  Looks like I got
a "fool" install, instead.		Charles E Campbell, Jr, PhD


 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.152
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.152
Problem:    When using "silent echo x" inside ":redir" a next echo may start
	    halfway the line. (Tony Mechelynck, Dennis Benzinger)
Solution:   Reset msg_col after redirecting silently.
Files:	    src/ex_docmd.c, src/message.c, src/proto/message.pro


*** ../vim-7.2.151/src/ex_docmd.c	Wed Mar 18 12:50:58 2009
--- src/ex_docmd.c	Wed Apr 22 11:57:49 2009
***************
*** 2699,2704 ****
--- 2699,2709 ----
  	/* Restore msg_scroll, it's set by file I/O commands, even when no
  	 * message is actually displayed. */
  	msg_scroll = save_msg_scroll;
+ 
+ 	/* "silent reg" or "silent echo x" inside "redir" leaves msg_col
+ 	 * somewhere in the line.  Put it back in the first column. */
+ 	if (redirecting())
+ 	    msg_col = 0;
      }
  
  #ifdef HAVE_SANDBOX
*** ../vim-7.2.151/src/message.c	Tue Feb 24 04:36:50 2009
--- src/message.c	Sun Apr 12 14:08:25 2009
***************
*** 3023,3033 ****
      if (*p_vfile != NUL)
  	verbose_write(s, maxlen);
  
!     if (redir_fd != NULL
! #ifdef FEAT_EVAL
! 			  || redir_reg || redir_vname
! #endif
! 				       )
      {
  	/* If the string doesn't start with CR or NL, go to msg_col */
  	if (*s != '\n' && *s != '\r')
--- 3023,3029 ----
      if (*p_vfile != NUL)
  	verbose_write(s, maxlen);
  
!     if (redirecting())
      {
  	/* If the string doesn't start with CR or NL, go to msg_col */
  	if (*s != '\n' && *s != '\r')
***************
*** 3074,3079 ****
--- 3070,3085 ----
      }
  }
  
+     int
+ redirecting()
+ {
+     return redir_fd != NULL
+ #ifdef FEAT_EVAL
+ 			  || redir_reg || redir_vname
+ #endif
+ 				       ;
+ }
+ 
  /*
   * Before giving verbose message.
   * Must always be called paired with verbose_leave()!
*** ../vim-7.2.151/src/proto/message.pro	Sat May  5 19:35:34 2007
--- src/proto/message.pro	Sun Apr 12 14:08:50 2009
***************
*** 54,59 ****
--- 54,60 ----
  void msg_clr_cmdline __ARGS((void));
  int msg_end __ARGS((void));
  void msg_check __ARGS((void));
+ int redirecting __ARGS((void));
  void verbose_enter __ARGS((void));
  void verbose_leave __ARGS((void));
  void verbose_enter_scroll __ARGS((void));
*** ../vim-7.2.151/src/version.c	Wed Apr 22 13:50:14 2009
--- src/version.c	Wed Apr 22 14:40:22 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     152,
  /**/

-- 
Q: How does a UNIX Guru pick up a girl?
A: look; grep; which; eval; nice; uname; talk; date;

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.153
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.153
Problem:    Memory leak for ":recover empty_dir/".
Solution:   Free files[] when it becomes empty. (Dominique Pelle)
Files:	    src/memline.c


*** ../vim-7.2.152/src/memline.c	Sun Jul 13 19:40:43 2008
--- src/memline.c	Wed Apr 22 11:48:35 2009
***************
*** 1554,1563 ****
  	    for (i = 0; i < num_files; ++i)
  		if (fullpathcmp(p, files[i], TRUE) & FPC_SAME)
  		{
  		    vim_free(files[i]);
! 		    --num_files;
! 		    for ( ; i < num_files; ++i)
! 			files[i] = files[i + 1];
  		}
  	}
  	if (nr > 0)
--- 1554,1568 ----
  	    for (i = 0; i < num_files; ++i)
  		if (fullpathcmp(p, files[i], TRUE) & FPC_SAME)
  		{
+ 		    /* Remove the name from files[i].  Move further entries
+ 		     * down.  When the array becomes empty free it here, since
+ 		     * FreeWild() won't be called below. */
  		    vim_free(files[i]);
! 		    if (--num_files == 0)
! 			vim_free(files);
! 		    else
! 			for ( ; i < num_files; ++i)
! 			    files[i] = files[i + 1];
  		}
  	}
  	if (nr > 0)
***************
*** 3522,3528 ****
  	    if (errno == EINVAL || errno == ENOENT)
  	    {
  		/* Found non-symlink or not existing file, stop here.
! 		 * When at the first level use the unmodifed name, skip the
  		 * call to vim_FullName(). */
  		if (depth == 1)
  		    return FAIL;
--- 3527,3533 ----
  	    if (errno == EINVAL || errno == ENOENT)
  	    {
  		/* Found non-symlink or not existing file, stop here.
! 		 * When at the first level use the unmodified name, skip the
  		 * call to vim_FullName(). */
  		if (depth == 1)
  		    return FAIL;
***************
*** 4560,4566 ****
  			buf->b_ml.ml_chunksize + curix,
  			(buf->b_ml.ml_usedchunks - curix) *
  			sizeof(chunksize_T));
! 	    /* Compute length of first half of lines in the splitted chunk */
  	    size = 0;
  	    linecnt = 0;
  	    while (curline < buf->b_ml.ml_line_count
--- 4568,4574 ----
  			buf->b_ml.ml_chunksize + curix,
  			(buf->b_ml.ml_usedchunks - curix) *
  			sizeof(chunksize_T));
! 	    /* Compute length of first half of lines in the split chunk */
  	    size = 0;
  	    linecnt = 0;
  	    while (curline < buf->b_ml.ml_line_count
*** ../vim-7.2.152/src/version.c	Wed Apr 22 14:42:26 2009
--- src/version.c	Wed Apr 22 15:34:18 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     153,
  /**/

-- 
Windows
M!uqoms

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.154
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.154 (after 7.2.132)
Problem:    ":cd" is still possible in a SwapExists autocmd.
Solution:   Set allbuf_lock in do_swapexists().
Files:	    src/memline.c


*** ../vim-7.2.153/src/memline.c	Wed Apr 22 15:37:12 2009
--- src/memline.c	Wed Apr 22 15:54:48 2009
***************
*** 3771,3778 ****
      set_vim_var_string(VV_SWAPCHOICE, NULL, -1);
  
      /* Trigger SwapExists autocommands with <afile> set to the file being
!      * edited. */
      apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);
  
      set_vim_var_string(VV_SWAPNAME, NULL, -1);
  
--- 3771,3780 ----
      set_vim_var_string(VV_SWAPCHOICE, NULL, -1);
  
      /* Trigger SwapExists autocommands with <afile> set to the file being
!      * edited.  Disallow changing directory here. */
!     ++allbuf_lock;
      apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);
+     --allbuf_lock;
  
      set_vim_var_string(VV_SWAPNAME, NULL, -1);
  
***************
*** 3798,3803 ****
--- 3800,3806 ----
   *
   * Note: If BASENAMELEN is not correct, you will get error messages for
   *	 not being able to open the swapfile
+  * Note: May trigger SwapExists autocmd, pointers may change!
   */
      static char_u *
  findswapname(buf, dirp, old_fname)
*** ../vim-7.2.153/src/version.c	Wed Apr 22 15:37:12 2009
--- src/version.c	Wed Apr 22 15:55:48 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     154,
  /**/

-- 
ARTHUR:  Be quiet!
DENNIS:  Well you can't expect to wield supreme executive power just 'cause
         some watery tart threw a sword at you!
ARTHUR:  Shut up!
DENNIS:  I mean, if I went around sayin' I was an empereror just because some
         moistened bint had lobbed a scimitar at me they'd put me away!
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.155
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.155
Problem:    Memory leak in ":function /pat".
Solution:   Free the memory. (Dominique Pelle)
Files:	    src/eval.c


*** ../vim-7.2.154/src/eval.c	Wed Apr 22 12:53:31 2009
--- src/eval.c	Wed Apr 22 16:04:34 2009
***************
*** 19720,19725 ****
--- 19720,19726 ----
  			    list_func_head(fp, FALSE);
  		    }
  		}
+ 		vim_free(regmatch.regprog);
  	    }
  	}
  	if (*p == '/')
*** ../vim-7.2.154/src/version.c	Wed Apr 22 15:56:27 2009
--- src/version.c	Wed Apr 22 16:07:27 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     155,
  /**/

-- 
Q:   How many hardware engineers does it take to change a lightbulb?
A:   None.  We'll fix it in software.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.156
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.156 (after 7.2.143)
Problem:    No completion for :scscope and :lcscope commands.
Solution:   Implement the completion. (Dominique Pelle)
Files:	    src/if_cscope.c, src/ex_docmd.c, src/proto/if_cscope.pro


*** ../vim-7.2.155/src/if_cscope.c	Wed Mar 18 14:30:46 2009
--- src/if_cscope.c	Wed Apr 22 11:57:49 2009
***************
*** 98,103 ****
--- 98,104 ----
  static enum
  {
      EXP_CSCOPE_SUBCMD,	/* expand ":cscope" sub-commands */
+     EXP_SCSCOPE_SUBCMD,	/* expand ":scscope" sub-commands */
      EXP_CSCOPE_FIND,	/* expand ":cscope find" arguments */
      EXP_CSCOPE_KILL	/* expand ":cscope kill" arguments */
  } expand_what;
***************
*** 112,123 ****
--- 113,135 ----
      expand_T	*xp;
      int		idx;
  {
+     int		current_idx;
+     int		i;
+ 
      switch (expand_what)
      {
      case EXP_CSCOPE_SUBCMD:
  	/* Complete with sub-commands of ":cscope":
  	 * add, find, help, kill, reset, show */
  	return (char_u *)cs_cmds[idx].name;
+     case EXP_SCSCOPE_SUBCMD:
+ 	/* Complete with sub-commands of ":scscope": same sub-commands as
+ 	 * ":cscope" but skip commands which don't support split windows */
+ 	for (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)
+ 	    if (cs_cmds[i].cansplit)
+ 		if (current_idx++ == idx)
+ 		    break;
+ 	return (char_u *)cs_cmds[i].name;
      case EXP_CSCOPE_FIND:
  	{
  	    const char *query_type[] =
***************
*** 133,147 ****
  	}
      case EXP_CSCOPE_KILL:
  	{
- 	    int			i;
- 	    int			current_idx = 0;
  	    static char_u	connection[2];
  
  	    /* ":cscope kill" accepts connection numbers or partial names of
  	     * the pathname of the cscope database as argument.  Only complete
  	     * with connection numbers. -1 can also be used to kill all
  	     * connections. */
! 	    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
  	    {
  		if (csinfo[i].fname == NULL)
  		    continue;
--- 145,157 ----
  	}
      case EXP_CSCOPE_KILL:
  	{
  	    static char_u	connection[2];
  
  	    /* ":cscope kill" accepts connection numbers or partial names of
  	     * the pathname of the cscope database as argument.  Only complete
  	     * with connection numbers. -1 can also be used to kill all
  	     * connections. */
! 	    for (i = 0, current_idx = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
  	    {
  		if (csinfo[i].fname == NULL)
  		    continue;
***************
*** 165,180 ****
   * Handle command line completion for :cscope command.
   */
      void
! set_context_in_cscope_cmd(xp, arg)
      expand_T	*xp;
      char_u	*arg;
  {
      char_u	*p;
  
      /* Default: expand subcommands */
      xp->xp_context = EXPAND_CSCOPE;
-     expand_what = EXP_CSCOPE_SUBCMD;
      xp->xp_pattern = arg;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
--- 175,192 ----
   * Handle command line completion for :cscope command.
   */
      void
! set_context_in_cscope_cmd(xp, arg, cmdidx)
      expand_T	*xp;
      char_u	*arg;
+     cmdidx_T	cmdidx;
  {
      char_u	*p;
  
      /* Default: expand subcommands */
      xp->xp_context = EXPAND_CSCOPE;
      xp->xp_pattern = arg;
+     expand_what = (cmdidx == CMD_scscope)
+ 			? EXP_SCSCOPE_SUBCMD : EXP_CSCOPE_SUBCMD;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
*** ../vim-7.2.155/src/ex_docmd.c	Wed Apr 22 14:42:26 2009
--- src/ex_docmd.c	Wed Apr 22 11:57:49 2009
***************
*** 3690,3696 ****
  	    break;
  #ifdef FEAT_CSCOPE
  	case CMD_cscope:
! 	    set_context_in_cscope_cmd(xp, arg);
  	    break;
  #endif
  #ifdef FEAT_LISTCMDS
--- 3690,3698 ----
  	    break;
  #ifdef FEAT_CSCOPE
  	case CMD_cscope:
! 	case CMD_lcscope:
! 	case CMD_scscope:
! 	    set_context_in_cscope_cmd(xp, arg, ea.cmdidx);
  	    break;
  #endif
  #ifdef FEAT_LISTCMDS
*** ../vim-7.2.155/src/proto/if_cscope.pro	Wed Mar 18 12:50:58 2009
--- src/proto/if_cscope.pro	Wed Apr 22 11:57:49 2009
***************
*** 1,6 ****
  /* if_cscope.c */
  char_u *get_cscope_name __ARGS((expand_T *xp, int idx));
! void set_context_in_cscope_cmd __ARGS((expand_T *xp, char_u *arg));
  void do_cscope __ARGS((exarg_T *eap));
  void do_scscope __ARGS((exarg_T *eap));
  void do_cstag __ARGS((exarg_T *eap));
--- 1,6 ----
  /* if_cscope.c */
  char_u *get_cscope_name __ARGS((expand_T *xp, int idx));
! void set_context_in_cscope_cmd __ARGS((expand_T *xp, char_u *arg, cmdidx_T cmdidx));
  void do_cscope __ARGS((exarg_T *eap));
  void do_scscope __ARGS((exarg_T *eap));
  void do_cstag __ARGS((exarg_T *eap));
*** ../vim-7.2.155/src/version.c	Wed Apr 22 16:07:57 2009
--- src/version.c	Wed Apr 22 16:21:43 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     156,
  /**/

-- 
ARTHUR:  Shut up!  Will you shut up!
DENNIS:  Ah, now we see the violence inherent in the system.
ARTHUR:  Shut up!
DENNIS:  Oh!  Come and see the violence inherent in the system!
         HELP! HELP!  I'm being repressed!
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.157
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.157
Problem:    Illegal memory access when searching in path.
Solution:   Avoid looking at a byte after end of a string. (Dominique Pelle)
Files:	    src/search.c


*** ../vim-7.2.156/src/search.c	Fri Jul 18 12:05:58 2008
--- src/search.c	Wed Apr 22 12:26:19 2009
***************
*** 2327,2334 ****
  		    for (col = pos.col; check_prevcol(linep, col, '\\', &col);)
  			bslcnt++;
  		}
! 		/* Only accept a match when 'M' is in 'cpo' or when ecaping is
! 		 * what we expect. */
  		if (cpo_bsl || (bslcnt & 1) == match_escaped)
  		{
  		    if (c == initc)
--- 2336,2343 ----
  		    for (col = pos.col; check_prevcol(linep, col, '\\', &col);)
  			bslcnt++;
  		}
! 		/* Only accept a match when 'M' is in 'cpo' or when escaping
! 		 * is what we expect. */
  		if (cpo_bsl || (bslcnt & 1) == match_escaped)
  		{
  		    if (c == initc)
***************
*** 4663,4669 ****
  			    msg_putchar('\n');	    /* cursor below last one */
  			    if (!got_int)	    /* don't display if 'q'
  						       typed at "--more--"
! 						       mesage */
  			    {
  				msg_home_replace_hl(new_fname);
  				MSG_PUTS(_(" (includes previously listed match)"));
--- 4672,4678 ----
  			    msg_putchar('\n');	    /* cursor below last one */
  			    if (!got_int)	    /* don't display if 'q'
  						       typed at "--more--"
! 						       message */
  			    {
  				msg_home_replace_hl(new_fname);
  				MSG_PUTS(_(" (includes previously listed match)"));
***************
*** 4975,4981 ****
  					    || IObuff[i-2] == '!'))))
  				IObuff[i++] = ' ';
  			}
! 			/* copy as much as posible of the new word */
  			if (p - aux >= IOSIZE - i)
  			    p = aux + IOSIZE - i - 1;
  			STRNCPY(IObuff + i, aux, p - aux);
--- 4984,4990 ----
  					    || IObuff[i-2] == '!'))))
  				IObuff[i++] = ' ';
  			}
! 			/* copy as much as possible of the new word */
  			if (p - aux >= IOSIZE - i)
  			    p = aux + IOSIZE - i - 1;
  			STRNCPY(IObuff + i, aux, p - aux);
***************
*** 5010,5016 ****
  		    if (did_show)
  			msg_putchar('\n');	/* cursor below last one */
  		    if (!got_int)		/* don't display if 'q' typed
! 						    at "--more--" mesage */
  			msg_home_replace_hl(curr_fname);
  		    prev_fname = curr_fname;
  		}
--- 5019,5025 ----
  		    if (did_show)
  			msg_putchar('\n');	/* cursor below last one */
  		    if (!got_int)		/* don't display if 'q' typed
! 						    at "--more--" message */
  			msg_home_replace_hl(curr_fname);
  		    prev_fname = curr_fname;
  		}
***************
*** 5092,5098 ****
  		}
  		if (action != ACTION_SHOW)
  		{
! 		    curwin->w_cursor.col = (colnr_T) (startp - line);
  		    curwin->w_set_curswant = TRUE;
  		}
  
--- 5101,5107 ----
  		}
  		if (action != ACTION_SHOW)
  		{
! 		    curwin->w_cursor.col = (colnr_T)(startp - line);
  		    curwin->w_set_curswant = TRUE;
  		}
  
***************
*** 5119,5125 ****
  		    && action == ACTION_EXPAND
  		    && !(compl_cont_status & CONT_SOL)
  #endif
! 		    && *(p = startp + 1))
  		goto search_line;
  	}
  	line_breakcheck();
--- 5128,5135 ----
  		    && action == ACTION_EXPAND
  		    && !(compl_cont_status & CONT_SOL)
  #endif
! 		    && *startp != NUL
! 		    && *(p = startp + 1) != NUL)
  		goto search_line;
  	}
  	line_breakcheck();
*** ../vim-7.2.156/src/version.c	Wed Apr 22 16:22:44 2009
--- src/version.c	Wed Apr 22 16:39:59 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     157,
  /**/


-- 
ARTHUR:  Bloody peasant!
DENNIS:  Oh, what a give away.  Did you hear that, did you hear that, eh?
         That's what I'm on about -- did you see him repressing me, you saw it
         didn't you?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.158
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.158
Problem:    Warnings from VisualC compiler.
Solution:   Add type casts. (George Reilly)
Files:	    src/ops.c


*** ../vim-7.2.157/src/ops.c	Wed Mar 11 16:26:01 2009
--- src/ops.c	Wed Apr 22 13:01:46 2009
***************
*** 495,504 ****
  	block_space_width = non_white_col - oap->start_vcol;
  	/* We will shift by "total" or "block_space_width", whichever is less.
  	 */
! 	shift_amount = (block_space_width < total? block_space_width: total);
  
  	/* The column to which we will shift the text.  */
! 	destination_col = non_white_col - shift_amount;
  
  	/* Now let's find out how much of the beginning of the line we can
  	 * reuse without modification.  */
--- 495,505 ----
  	block_space_width = non_white_col - oap->start_vcol;
  	/* We will shift by "total" or "block_space_width", whichever is less.
  	 */
! 	shift_amount = (block_space_width < (size_t)total
! 					 ? block_space_width : (size_t)total);
  
  	/* The column to which we will shift the text.  */
! 	destination_col = (colnr_T)(non_white_col - shift_amount);
  
  	/* Now let's find out how much of the beginning of the line we can
  	 * reuse without modification.  */
*** ../vim-7.2.157/src/version.c	Wed Apr 22 16:42:24 2009
--- src/version.c	Wed Apr 22 17:42:19 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     158,
  /**/

-- 
ARTHUR:        What?
BLACK KNIGHT:  None shall pass.
ARTHUR:        I have no quarrel with you, good Sir knight, but I must cross
               this bridge.
BLACK KNIGHT:  Then you shall die.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.159
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.159
Problem:    When $x_includes ends up being "NONE" configure fails.
Solution:   Check for $x_includes not to be "NONE" (Rainer)
Files:	    src/auto/configure, src/configure.in


*** ../vim-7.2.158/src/auto/configure	Mon Mar  2 02:44:54 2009
--- src/auto/configure	Wed Apr 22 14:37:24 2009
***************
*** 15519,15525 ****
  if test "$enable_multibyte" = "yes"; then
    cflags_save=$CFLAGS
    ldflags_save=$LDFLAGS
!   if test -n "$x_includes" ; then
      CFLAGS="$CFLAGS -I$x_includes"
      LDFLAGS="$X_LIBS $LDFLAGS -lX11"
      { $as_echo "$as_me:$LINENO: checking whether X_LOCALE needed" >&5
--- 15519,15525 ----
  if test "$enable_multibyte" = "yes"; then
    cflags_save=$CFLAGS
    ldflags_save=$LDFLAGS
!   if test "x$x_includes" != "xNONE" ; then
      CFLAGS="$CFLAGS -I$x_includes"
      LDFLAGS="$X_LIBS $LDFLAGS -lX11"
      { $as_echo "$as_me:$LINENO: checking whether X_LOCALE needed" >&5
*** ../vim-7.2.158/src/configure.in	Mon Mar  2 02:44:54 2009
--- src/configure.in	Wed Apr 22 14:35:57 2009
***************
*** 2952,2958 ****
  if test "$enable_multibyte" = "yes"; then
    cflags_save=$CFLAGS
    ldflags_save=$LDFLAGS
!   if test -n "$x_includes" ; then
      CFLAGS="$CFLAGS -I$x_includes"
      LDFLAGS="$X_LIBS $LDFLAGS -lX11"
      AC_MSG_CHECKING(whether X_LOCALE needed)
--- 2952,2958 ----
  if test "$enable_multibyte" = "yes"; then
    cflags_save=$CFLAGS
    ldflags_save=$LDFLAGS
!   if test "x$x_includes" != "xNONE" ; then
      CFLAGS="$CFLAGS -I$x_includes"
      LDFLAGS="$X_LIBS $LDFLAGS -lX11"
      AC_MSG_CHECKING(whether X_LOCALE needed)
*** ../vim-7.2.158/src/version.c	Wed Apr 22 17:42:53 2009
--- src/version.c	Wed Apr 22 17:49:50 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     159,
  /**/

-- 
"Hegel was right when he said that we learn from history that man can
never learn anything from history."       (George Bernard Shaw)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.160
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.160
Problem:    Search pattern not freed on exit when 'rightleft' set.
Solution:   Free mr_pattern_alloced.
Files:	    src/search.c


*** ../vim-7.2.159/src/search.c	Wed Apr 22 16:42:24 2009
--- src/search.c	Wed Apr 22 12:26:19 2009
***************
*** 345,350 ****
--- 345,359 ----
  {
      vim_free(spats[0].pat);
      vim_free(spats[1].pat);
+ 
+ # ifdef FEAT_RIGHTLEFT
+     if (mr_pattern_alloced)
+     {
+         vim_free(mr_pattern);
+         mr_pattern_alloced = FALSE;
+         mr_pattern = NULL;
+     }
+ # endif
  }
  #endif
  
*** ../vim-7.2.159/src/version.c	Wed Apr 22 17:50:53 2009
--- src/version.c	Wed Apr 22 18:42:25 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     160,
  /**/

-- 
    f y cn rd ths thn y cn hv grt jb n cmptr prgrmmng

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.161
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.161
Problem:    Folds messed up in other tab page. (Vlad Irnov)
Solution:   Instead of going over all windows in current tab page go over all
	    windows in all tab pages.  Also free memory for location lists in
	    other tab pages when exiting. (Lech Lorens)
Files:	    src/fileio.c, src/mark.c, src/misc1.c, src/misc2.c


*** ../vim-7.2.160/src/fileio.c	Wed Mar 18 15:40:03 2009
--- src/fileio.c	Wed Apr 22 15:46:35 2009
***************
*** 6846,6855 ****
  #endif
  #ifdef FEAT_FOLDING
  	{
! 	    win_T *wp;
  
  	    /* Update folds unless they are defined manually. */
! 	    FOR_ALL_WINDOWS(wp)
  		if (wp->w_buffer == curwin->w_buffer
  			&& !foldmethodIsManual(wp))
  		    foldUpdateAll(wp);
--- 6846,6856 ----
  #endif
  #ifdef FEAT_FOLDING
  	{
! 	    win_T	*wp;
! 	    tabpage_T	*tp;
  
  	    /* Update folds unless they are defined manually. */
! 	    FOR_ALL_TAB_WINDOWS(tp, wp)
  		if (wp->w_buffer == curwin->w_buffer
  			&& !foldmethodIsManual(wp))
  		    foldUpdateAll(wp);
*** ../vim-7.2.160/src/mark.c	Sun Nov  9 13:43:25 2008
--- src/mark.c	Wed Apr 22 17:32:29 2009
***************
*** 1023,1028 ****
--- 1023,1031 ----
      int		fnum = curbuf->b_fnum;
      linenr_T	*lp;
      win_T	*win;
+ #ifdef FEAT_WINDOWS
+     tabpage_T	*tab;
+ #endif
  
      if (line2 < line1 && amount_after == 0L)	    /* nothing to do */
  	return;
***************
*** 1064,1070 ****
  	/* quickfix marks */
  	qf_mark_adjust(NULL, line1, line2, amount, amount_after);
  	/* location lists */
! 	FOR_ALL_WINDOWS(win)
  	    qf_mark_adjust(win, line1, line2, amount, amount_after);
  #endif
  
--- 1067,1073 ----
  	/* quickfix marks */
  	qf_mark_adjust(NULL, line1, line2, amount, amount_after);
  	/* location lists */
! 	FOR_ALL_TAB_WINDOWS(tab, win)
  	    qf_mark_adjust(win, line1, line2, amount, amount_after);
  #endif
  
***************
*** 1086,1092 ****
      /*
       * Adjust items in all windows related to the current buffer.
       */
!     FOR_ALL_WINDOWS(win)
      {
  #ifdef FEAT_JUMPLIST
  	if (!cmdmod.lockmarks)
--- 1089,1095 ----
      /*
       * Adjust items in all windows related to the current buffer.
       */
!     FOR_ALL_TAB_WINDOWS(tab, win)
      {
  #ifdef FEAT_JUMPLIST
  	if (!cmdmod.lockmarks)
*** ../vim-7.2.160/src/misc1.c	Wed Mar 18 15:40:03 2009
--- src/misc1.c	Wed Apr 22 17:32:46 2009
***************
*** 2717,2722 ****
--- 2717,2725 ----
      long	xtra;
  {
      win_T	*wp;
+ #ifdef FEAT_WINDOWS
+     tabpage_T	*tp;
+ #endif
      int		i;
  #ifdef FEAT_JUMPLIST
      int		cols;
***************
*** 2769,2775 ****
  		    curbuf->b_changelistlen = JUMPLISTSIZE - 1;
  		    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,
  					  sizeof(pos_T) * (JUMPLISTSIZE - 1));
! 		    FOR_ALL_WINDOWS(wp)
  		    {
  			/* Correct position in changelist for other windows on
  			 * this buffer. */
--- 2772,2778 ----
  		    curbuf->b_changelistlen = JUMPLISTSIZE - 1;
  		    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,
  					  sizeof(pos_T) * (JUMPLISTSIZE - 1));
! 		    FOR_ALL_TAB_WINDOWS(tp, wp)
  		    {
  			/* Correct position in changelist for other windows on
  			 * this buffer. */
***************
*** 2777,2783 ****
  			    --wp->w_changelistidx;
  		    }
  		}
! 		FOR_ALL_WINDOWS(wp)
  		{
  		    /* For other windows, if the position in the changelist is
  		     * at the end it stays at the end. */
--- 2780,2786 ----
  			    --wp->w_changelistidx;
  		    }
  		}
! 		FOR_ALL_TAB_WINDOWS(tp, wp)
  		{
  		    /* For other windows, if the position in the changelist is
  		     * at the end it stays at the end. */
***************
*** 2796,2802 ****
  #endif
      }
  
!     FOR_ALL_WINDOWS(wp)
      {
  	if (wp->w_buffer == curbuf)
  	{
--- 2799,2805 ----
  #endif
      }
  
!     FOR_ALL_TAB_WINDOWS(tp, wp)
      {
  	if (wp->w_buffer == curbuf)
  	{
*** ../vim-7.2.160/src/misc2.c	Wed Mar 11 17:27:46 2009
--- src/misc2.c	Wed Apr 22 15:46:35 2009
***************
*** 1075,1085 ****
  
  #ifdef FEAT_QUICKFIX
      {
! 	win_T	*win;
  
  	qf_free_all(NULL);
  	/* Free all location lists */
! 	FOR_ALL_WINDOWS(win)
  	    qf_free_all(win);
      }
  #endif
--- 1075,1086 ----
  
  #ifdef FEAT_QUICKFIX
      {
! 	win_T	    *win;
! 	tabpage_T   *tab;
  
  	qf_free_all(NULL);
  	/* Free all location lists */
! 	FOR_ALL_TAB_WINDOWS(tab, win)
  	    qf_free_all(win);
      }
  #endif
*** ../vim-7.2.160/src/version.c	Wed Apr 22 18:43:06 2009
--- src/version.c	Wed Apr 29 10:59:01 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     161,
  /**/

-- 
CONCORDE:  Quickly, sir, come this way!
LAUNCELOT: No!  It's not right for my idiom.  I must escape more  ... more ...
CONCORDE:  Dramatically, sir?
LAUNCELOT: Dramatically.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.162
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.162
Problem:    The quickfix window may get wrong filetype.
Solution:   Do not detect the filetype for the quickfix window. (Lech Lorens)
Files:	    src/quickfix.c


*** ../vim-7.2.161/src/quickfix.c	Sun Feb 22 02:36:36 2009
--- src/quickfix.c	Wed Apr 22 17:34:57 2009
***************
*** 2346,2352 ****
  	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
  								   OPT_LOCAL);
  	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
! 	    set_option_value((char_u *)"diff", 0L, NULL, OPT_LOCAL);
  	}
  
  	/* Only set the height when still in the same tab page and there is no
--- 2346,2358 ----
  	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
  								   OPT_LOCAL);
  	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
! #ifdef FEAT_DIFF
! 	    curwin->w_p_diff = FALSE;
! #endif
! #ifdef FEAT_FOLDING
! 	    set_option_value((char_u *)"fdm", 0L, (char_u *)"manual",
! 								   OPT_LOCAL);
! #endif
  	}
  
  	/* Only set the height when still in the same tab page and there is no
***************
*** 2607,2616 ****
--- 2613,2624 ----
      curbuf->b_p_ma = FALSE;
  
  #ifdef FEAT_AUTOCMD
+     keep_filetype = TRUE;		/* don't detect 'filetype' */
      apply_autocmds(EVENT_BUFREADPOST, (char_u *)"quickfix", NULL,
  							       FALSE, curbuf);
      apply_autocmds(EVENT_BUFWINENTER, (char_u *)"quickfix", NULL,
  							       FALSE, curbuf);
+     keep_filetype = FALSE;
  #endif
  
      /* make sure it will be redrawn */
*** ../vim-7.2.161/src/version.c	Wed Apr 29 11:00:09 2009
--- src/version.c	Wed Apr 29 11:49:09 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     162,
  /**/

-- 
Yesterday is history.
Tomorrow is a mystery.
Today is a gift.
That's why it is called 'present'.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.163
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.163
Problem:    The command line window may get folding.
Solution:   Default to no/manual folding. (Lech Lorens)
Files:	    src/ex_getln.c


*** ../vim-7.2.162/src/ex_getln.c	Wed Apr 22 13:50:14 2009
--- src/ex_getln.c	Wed Apr 22 16:12:54 2009
***************
*** 6073,6078 ****
--- 6073,6081 ----
      set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
      set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
      curbuf->b_p_ma = TRUE;
+ #ifdef FEAT_FOLDING
+     curwin->w_p_fen = FALSE;
+ #endif
  # ifdef FEAT_RIGHTLEFT
      curwin->w_p_rl = cmdmsg_rl;
      cmdmsg_rl = FALSE;
*** ../vim-7.2.162/src/version.c	Wed Apr 29 11:49:57 2009
--- src/version.c	Wed Apr 29 12:02:56 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     163,
  /**/

-- 
   [SIR LAUNCELOT runs back up the stairs, grabs a rope
   of the wall and swings out over the heads of the CROWD in a
   swashbuckling manner towards a large window.  He stops just short
   of the window and is left swing pathetically back and forth.]
LAUNCELOT: Excuse me ... could somebody give me a push ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.164
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.164
Problem:    When 'showbreak' is set the size of the Visual block may be
	    reported wrong. (Eduardo Daudt Flach)
Solution:   Temporarily make 'sbr' empty.
Files:	    src/normal.c, src/ops.c


*** ../vim-7.2.163/src/normal.c	Sat Feb 21 20:27:00 2009
--- src/normal.c	Wed Apr 22 18:30:20 2009
***************
*** 3709,3721 ****
  #ifdef FEAT_VISUAL
      if (VIsual_active && !char_avail())
      {
! 	int		i = lt(VIsual, curwin->w_cursor);
  	long		lines;
  	colnr_T		leftcol, rightcol;
  	linenr_T	top, bot;
  
  	/* Show the size of the Visual area. */
! 	if (i)
  	{
  	    top = VIsual.lnum;
  	    bot = curwin->w_cursor.lnum;
--- 3709,3721 ----
  #ifdef FEAT_VISUAL
      if (VIsual_active && !char_avail())
      {
! 	int		cursor_bot = lt(VIsual, curwin->w_cursor);
  	long		lines;
  	colnr_T		leftcol, rightcol;
  	linenr_T	top, bot;
  
  	/* Show the size of the Visual area. */
! 	if (cursor_bot)
  	{
  	    top = VIsual.lnum;
  	    bot = curwin->w_cursor.lnum;
***************
*** 3734,3747 ****
  
  	if (VIsual_mode == Ctrl_V)
  	{
  	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
  	    sprintf((char *)showcmd_buf, "%ldx%ld", lines,
  					      (long)(rightcol - leftcol + 1));
  	}
  	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
  	    sprintf((char *)showcmd_buf, "%ld", lines);
  	else
! 	    sprintf((char *)showcmd_buf, "%ld", (long)(i
  		    ? curwin->w_cursor.col - VIsual.col
  		    : VIsual.col - curwin->w_cursor.col) + (*p_sel != 'e'));
  	showcmd_buf[SHOWCMD_COLS] = NUL;	/* truncate */
--- 3734,3756 ----
  
  	if (VIsual_mode == Ctrl_V)
  	{
+ #ifdef FEAT_LINEBREAK
+ 	    char_u *saved_sbr = p_sbr;
+ 
+ 	    /* Make 'sbr' empty for a moment to get the correct size. */
+ 	    p_sbr = empty_option;
+ #endif
  	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
+ #ifdef FEAT_LINEBREAK
+ 	    p_sbr = saved_sbr;
+ #endif
  	    sprintf((char *)showcmd_buf, "%ldx%ld", lines,
  					      (long)(rightcol - leftcol + 1));
  	}
  	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
  	    sprintf((char *)showcmd_buf, "%ld", lines);
  	else
! 	    sprintf((char *)showcmd_buf, "%ld", (long)(cursor_bot
  		    ? curwin->w_cursor.col - VIsual.col
  		    : VIsual.col - curwin->w_cursor.col) + (*p_sel != 'e'));
  	showcmd_buf[SHOWCMD_COLS] = NUL;	/* truncate */
*** ../vim-7.2.163/src/ops.c	Wed Apr 22 17:42:53 2009
--- src/ops.c	Wed Apr 22 18:30:07 2009
***************
*** 392,398 ****
      colnr_T		ws_vcol;
      int			i = 0, j = 0;
      int			len;
- 
  #ifdef FEAT_RIGHTLEFT
      int			old_p_ri = p_ri;
  
--- 392,397 ----
***************
*** 6284,6294 ****
--- 6283,6302 ----
  
  	    if (VIsual_mode == Ctrl_V)
  	    {
+ #ifdef FEAT_LINEBREAK
+ 		char_u * saved_sbr = p_sbr;
+ 
+ 		/* Make 'sbr' empty for a moment to get the correct size. */
+ 		p_sbr = empty_option;
+ #endif
  		oparg.is_VIsual = 1;
  		oparg.block_mode = TRUE;
  		oparg.op_type = OP_NOP;
  		getvcols(curwin, &min_pos, &max_pos,
  					  &oparg.start_vcol, &oparg.end_vcol);
+ #ifdef FEAT_LINEBREAK
+ 		p_sbr = saved_sbr;
+ #endif
  		if (curwin->w_curswant == MAXCOL)
  		    oparg.end_vcol = MAXCOL;
  		/* Swap the start, end vcol if needed */
*** ../vim-7.2.163/src/version.c	Wed Apr 29 12:03:35 2009
--- src/version.c	Wed Apr 29 17:38:05 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     164,
  /**/

-- 
There are 10 kinds of people: Those who understand binary and those who don't.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.165
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.165
Problem:    The argument for the FuncUndefined autocmd event is expanded like
	    a file name.
Solution:   Don't try expanding it. (Wang Xu)
Files:	    src/fileio.c


*** ../vim-7.2.164/src/fileio.c	Wed Apr 29 11:00:09 2009
--- src/fileio.c	Wed Apr 29 18:01:06 2009
***************
*** 8785,8793 ****
      else
      {
  	sfname = vim_strsave(fname);
! 	/* Don't try expanding FileType, Syntax, WindowID or QuickFixCmd* */
  	if (event == EVENT_FILETYPE
  		|| event == EVENT_SYNTAX
  		|| event == EVENT_REMOTEREPLY
  		|| event == EVENT_SPELLFILEMISSING
  		|| event == EVENT_QUICKFIXCMDPRE
--- 8785,8795 ----
      else
      {
  	sfname = vim_strsave(fname);
! 	/* Don't try expanding FileType, Syntax, FuncUndefined, WindowID or
! 	 * QuickFixCmd* */
  	if (event == EVENT_FILETYPE
  		|| event == EVENT_SYNTAX
+ 		|| event == EVENT_FUNCUNDEFINED
  		|| event == EVENT_REMOTEREPLY
  		|| event == EVENT_SPELLFILEMISSING
  		|| event == EVENT_QUICKFIXCMDPRE
*** ../vim-7.2.164/src/version.c	Wed Apr 29 17:39:17 2009
--- src/version.c	Wed Apr 29 18:00:43 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     165,
  /**/

-- 
Be nice to your kids...  they'll be the ones choosing your nursing home.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.166
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.166
Problem:    No completion for ":sign" command.
Solution:   Add ":sign" completion. (Dominique Pelle)
Files:	    src/ex_cmds.c, src/ex_docmd.c, src/ex_getln.c, src/vim.h,
	    src/proto/ex_cmds.pro


*** ../vim-7.2.165/src/ex_cmds.c	Tue Feb 24 04:28:40 2009
--- src/ex_cmds.c	Wed Apr 29 17:08:27 2009
***************
*** 6543,6562 ****
  static void sign_list_defined __ARGS((sign_T *sp));
  static void sign_undefine __ARGS((sign_T *sp, sign_T *sp_prev));
  
! /*
!  * ":sign" command
!  */
!     void
! ex_sign(eap)
!     exarg_T	*eap;
! {
!     char_u	*arg = eap->arg;
!     char_u	*p;
!     int		idx;
!     sign_T	*sp;
!     sign_T	*sp_prev;
!     buf_T	*buf;
!     static char	*cmds[] = {
  			"define",
  #define SIGNCMD_DEFINE	0
  			"undefine",
--- 6543,6549 ----
  static void sign_list_defined __ARGS((sign_T *sp));
  static void sign_undefine __ARGS((sign_T *sp, sign_T *sp_prev));
  
! static char *cmds[] = {
  			"define",
  #define SIGNCMD_DEFINE	0
  			"undefine",
***************
*** 6569,6590 ****
  #define SIGNCMD_UNPLACE	4
  			"jump",
  #define SIGNCMD_JUMP	5
  #define SIGNCMD_LAST	6
!     };
  
      /* Parse the subcommand. */
      p = skiptowhite(arg);
!     if (*p != NUL)
! 	*p++ = NUL;
!     for (idx = 0; ; ++idx)
      {
! 	if (idx == SIGNCMD_LAST)
! 	{
! 	    EMSG2(_("E160: Unknown sign command: %s"), arg);
! 	    return;
! 	}
! 	if (STRCMP(arg, cmds[idx]) == 0)
! 	    break;
      }
      arg = skipwhite(p);
  
--- 6556,6606 ----
  #define SIGNCMD_UNPLACE	4
  			"jump",
  #define SIGNCMD_JUMP	5
+ 			NULL
  #define SIGNCMD_LAST	6
! };
! 
! /*
!  * Find index of a ":sign" subcmd from its name.
!  * "*end_cmd" must be writable.
!  */
!     static int
! sign_cmd_idx(begin_cmd, end_cmd)
!     char	*begin_cmd;	/* begin of sign subcmd */
!     char	*end_cmd;	/* just after sign subcmd */
! {
!     int		idx;
!     char	save = *end_cmd;
! 
!     *end_cmd = NUL;
!     for (idx = 0; ; ++idx)
! 	if (cmds[idx] == NULL || STRCMP(begin_cmd, cmds[idx]) == 0)
! 	    break;
!     *end_cmd = save;
!     return idx;
! }
! 
! /*
!  * ":sign" command
!  */
!     void
! ex_sign(eap)
!     exarg_T	*eap;
! {
!     char_u	*arg = eap->arg;
!     char_u	*p;
!     int		idx;
!     sign_T	*sp;
!     sign_T	*sp_prev;
!     buf_T	*buf;
  
      /* Parse the subcommand. */
      p = skiptowhite(arg);
!     idx = sign_cmd_idx(arg, p);
!     if (idx == SIGNCMD_LAST)
      {
! 	EMSG2(_("E160: Unknown sign command: %s"), arg);
! 	return;
      }
      arg = skipwhite(p);
  
***************
*** 7110,7115 ****
--- 7126,7311 ----
  }
  #endif
  
+ #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+ static enum
+ {
+     EXP_SUBCMD,		/* expand :sign sub-commands */
+     EXP_DEFINE,		/* expand :sign define {name} args */
+     EXP_PLACE,		/* expand :sign place {id} args */
+     EXP_UNPLACE,	/* expand :sign unplace" */
+     EXP_SIGN_NAMES	/* expand with name of placed signs */
+ } expand_what;
+ 
+ /*
+  * Function given to ExpandGeneric() to obtain the sign command
+  * expansion.
+  */
+ /*ARGSUSED*/
+     char_u *
+ get_sign_name(xp, idx)
+     expand_T	*xp;
+     int		idx;
+ {
+     sign_T	*sp;
+     int		current_idx;
+ 
+     switch (expand_what)
+     {
+     case EXP_SUBCMD:
+ 	return (char_u *)cmds[idx];
+     case EXP_DEFINE:
+ 	{
+ 	    char *define_arg[] =
+ 	    {
+ 		"icon=", "linehl=", "text=", "texthl=", NULL
+ 	    };
+ 	    return (char_u *)define_arg[idx];
+ 	}
+     case EXP_PLACE:
+ 	{
+ 	    char *place_arg[] =
+ 	    {
+ 		"line=", "name=", "file=", "buffer=", NULL
+ 	    };
+ 	    return (char_u *)place_arg[idx];
+ 	}
+     case EXP_UNPLACE:
+ 	{
+ 	    char *unplace_arg[] = { "file=", "buffer=", NULL };
+ 	    return (char_u *)unplace_arg[idx];
+ 	}
+     case EXP_SIGN_NAMES:
+ 	/* Complete with name of signs already defined */
+ 	current_idx = 0;
+ 	for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+ 	    if (current_idx++ == idx)
+ 		return sp->sn_name;
+ 	return NULL;
+     default:
+ 	return NULL;
+     }
+ }
+ 
+ /*
+  * Handle command line completion for :sign command.
+  */
+     void
+ set_context_in_sign_cmd(xp, arg)
+     expand_T	*xp;
+     char_u	*arg;
+ {
+     char_u	*p;
+     char_u	*end_subcmd;
+     char_u	*last;
+     int		cmd_idx;
+     char_u	*begin_subcmd_args;
+ 
+     /* Default: expand subcommands. */
+     xp->xp_context = EXPAND_SIGN;
+     expand_what = EXP_SUBCMD;
+     xp->xp_pattern = arg;
+ 
+     end_subcmd = skiptowhite(arg);
+     if (*end_subcmd == NUL)
+ 	/* expand subcmd name
+ 	 * :sign {subcmd}<CTRL-D>*/
+ 	return;
+ 
+     cmd_idx = sign_cmd_idx(arg, end_subcmd);
+ 
+     /* :sign {subcmd} {subcmd_args}
+      *                |
+      *                begin_subcmd_args */
+     begin_subcmd_args = skipwhite(end_subcmd);
+     p = skiptowhite(begin_subcmd_args);
+     if (*p == NUL)
+     {
+ 	/*
+ 	 * Expand first argument of subcmd when possible.
+ 	 * For ":jump {id}" and ":unplace {id}", we could
+ 	 * possibly expand the ids of all signs already placed.
+ 	 */
+ 	xp->xp_pattern = begin_subcmd_args;
+ 	switch (cmd_idx)
+ 	{
+ 	    case SIGNCMD_LIST:
+ 	    case SIGNCMD_UNDEFINE:
+ 		/* :sign list <CTRL-D>
+ 		 * :sign undefine <CTRL-D> */
+ 		expand_what = EXP_SIGN_NAMES;
+ 		break;
+ 	    default:
+ 		xp->xp_context = EXPAND_NOTHING;
+ 	}
+ 	return;
+     }
+ 
+     /* expand last argument of subcmd */
+ 
+     /* :sign define {name} {args}...
+      *              |
+      *              p */
+ 
+     /* Loop until reaching last argument. */
+     do
+     {
+ 	p = skipwhite(p);
+ 	last = p;
+ 	p = skiptowhite(p);
+     } while (*p != NUL);
+ 
+     p = vim_strchr(last, '=');
+ 
+     /* :sign define {name} {args}... {last}=
+      *                               |     |
+      *                            last     p */
+     if (p == NUL)
+     {
+ 	/* Expand last argument name (before equal sign). */
+ 	xp->xp_pattern = last;
+ 	switch (cmd_idx)
+ 	{
+ 	    case SIGNCMD_DEFINE:
+ 		expand_what = EXP_DEFINE;
+ 		break;
+ 	    case SIGNCMD_PLACE:
+ 		expand_what = EXP_PLACE;
+ 		break;
+ 	    case SIGNCMD_JUMP:
+ 	    case SIGNCMD_UNPLACE:
+ 		expand_what = EXP_UNPLACE;
+ 		break;
+ 	    default:
+ 		xp->xp_context = EXPAND_NOTHING;
+ 	}
+     }
+     else
+     {
+ 	/* Expand last argument value (after equal sign). */
+ 	xp->xp_pattern = p + 1;
+ 	switch (cmd_idx)
+ 	{
+ 	    case SIGNCMD_DEFINE:
+ 		if (STRNCMP(last, "texthl", p - last) == 0 ||
+ 		    STRNCMP(last, "linehl", p - last) == 0)
+ 		    xp->xp_context = EXPAND_HIGHLIGHT;
+ 		else if (STRNCMP(last, "icon", p - last) == 0)
+ 		    xp->xp_context = EXPAND_FILES;
+ 		else
+ 		    xp->xp_context = EXPAND_NOTHING;
+ 		break;
+ 	    case SIGNCMD_PLACE:
+ 		if (STRNCMP(last, "name", p - last) == 0)
+ 		    expand_what = EXP_SIGN_NAMES;
+ 		else
+ 		    xp->xp_context = EXPAND_NOTHING;
+ 		break;
+ 	    default:
+ 		xp->xp_context = EXPAND_NOTHING;
+ 	}
+     }
+ }
+ #endif
  #endif
  
  #if defined(FEAT_GUI) || defined(FEAT_CLIENTSERVER) || defined(PROTO)
*** ../vim-7.2.165/src/ex_docmd.c	Wed Apr 22 16:22:44 2009
--- src/ex_docmd.c	Wed Apr 29 17:05:23 2009
***************
*** 3695,3700 ****
--- 3695,3705 ----
  	    set_context_in_cscope_cmd(xp, arg, ea.cmdidx);
  	    break;
  #endif
+ #ifdef FEAT_SIGNS
+ 	case CMD_sign:
+ 	    set_context_in_sign_cmd(xp, arg);
+ 	    break;
+ #endif
  #ifdef FEAT_LISTCMDS
  	case CMD_bdelete:
  	case CMD_bwipeout:
***************
*** 5218,5223 ****
--- 5223,5231 ----
      {EXPAND_MENUS, "menu"},
      {EXPAND_SETTINGS, "option"},
      {EXPAND_SHELLCMD, "shellcmd"},
+ #if defined(FEAT_SIGNS)
+     {EXPAND_SIGN, "sign"},
+ #endif
      {EXPAND_TAGS, "tag"},
      {EXPAND_TAGS_LISTFILES, "tag_listfiles"},
      {EXPAND_USER_VARS, "var"},
*** ../vim-7.2.165/src/ex_getln.c	Wed Apr 29 12:03:35 2009
--- src/ex_getln.c	Wed Apr 29 12:51:42 2009
***************
*** 325,331 ****
  #endif
  
  #ifdef FEAT_DIGRAPHS
!     do_digraph(-1);		/* init digraph typahead */
  #endif
  
      /*
--- 325,331 ----
  #endif
  
  #ifdef FEAT_DIGRAPHS
!     do_digraph(-1);		/* init digraph typeahead */
  #endif
  
      /*
***************
*** 4521,4526 ****
--- 4521,4529 ----
  #ifdef FEAT_CSCOPE
  	    {EXPAND_CSCOPE, get_cscope_name, TRUE},
  #endif
+ #ifdef FEAT_SIGNS
+ 	    {EXPAND_SIGN, get_sign_name, TRUE},
+ #endif
  #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
  	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
  	    {EXPAND_LANGUAGE, get_lang_arg, TRUE},
*** ../vim-7.2.165/src/vim.h	Wed Mar 18 12:50:58 2009
--- src/vim.h	Wed Apr 29 12:51:42 2009
***************
*** 709,714 ****
--- 709,715 ----
  #define EXPAND_USER_LIST	31
  #define EXPAND_SHELLCMD		32
  #define EXPAND_CSCOPE		33
+ #define EXPAND_SIGN		34
  
  /* Values for exmode_active (0 is no exmode) */
  #define EXMODE_NORMAL		1
*** ../vim-7.2.165/src/proto/ex_cmds.pro	Tue Feb 24 04:28:40 2009
--- src/proto/ex_cmds.pro	Wed Apr 29 17:10:29 2009
***************
*** 40,46 ****
  int read_viminfo_sub_string __ARGS((vir_T *virp, int force));
  void write_viminfo_sub_string __ARGS((FILE *fp));
  void free_old_sub __ARGS((void));
- void free_signs __ARGS((void));
  int prepare_tagpreview __ARGS((int undo_sync));
  void ex_help __ARGS((exarg_T *eap));
  char_u *check_help_lang __ARGS((char_u *arg));
--- 40,45 ----
***************
*** 56,60 ****
--- 55,62 ----
  char_u *sign_get_text __ARGS((int typenr));
  void *sign_get_image __ARGS((int typenr));
  char_u *sign_typenr2name __ARGS((int typenr));
+ void free_signs __ARGS((void));
+ char_u *get_sign_name __ARGS((expand_T *xp, int idx));
+ void set_context_in_sign_cmd __ARGS((expand_T *xp, char_u *arg));
  void ex_drop __ARGS((exarg_T *eap));
  /* vim: set ft=c : */
*** ../vim-7.2.165/src/version.c	Wed Apr 29 18:01:23 2009
--- src/version.c	Wed Apr 29 18:43:14 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     166,
  /**/

-- 
Did you ever stop to think...  and forget to start again?
                                  -- Steven Wright

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.167
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.167
Problem:    Splint doesn't work well for checking the code.
Solution:   Add splint arguments in the Makefile.  Exclude some code from
	    splint that it can't handle.  Tune splint arguments to give
	    reasonable errors.  Add a filter for removing false warnings from
	    splint output.  Many small changes to avoid warnings.  More to
	    follow...
Files:	    Filelist, src/Makefile, src/buffer.c, src/charset.c,
	    src/cleanlint.vim, src/digraph.c, src/edit.c, src/ex_cmds.c,
	    src/globals.h, src/ops.c, src/os_unix.c, src/os_unix.h,
	    src/proto/buffer.pro, src/proto/edit.pro, src/screen.c,
	    src/structs.h

*** ../vim-7.2.166/Filelist	2008-09-20 16:26:10.000000000 +0200
--- Filelist	2009-05-05 21:45:49.000000000 +0200
***************
*** 139,144 ****
--- 139,145 ----
  		src/INSTALL \
  		src/INSTALLx.txt \
  		src/Makefile \
+ 		src/cleanlint.vim \
  		src/auto/configure \
  		src/config.aap.in \
  		src/config.h.in \
***************
*** 683,691 ****
  		runtime/spell/??/main.aap \
  		runtime/spell/yi/README.txt \
  		runtime/spell/main.aap \
- 		runtime/spell/cleanadd.vim \
  		runtime/spell/*.vim \
- 		runtime/spell/fixdup \
  
  # generic language files, binary
  LANG_GEN_BIN = \
--- 684,690 ----
*** ../vim-7.2.166/src/Makefile	2009-04-29 18:44:45.000000000 +0200
--- src/Makefile	2009-05-06 00:23:15.000000000 +0200
***************
*** 551,557 ****
  # }}}
  
  # LINT - for running lint
! LINT_OPTIONS = -beprxzF
  
  # PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
  # Might not work with GUI or Perl.
--- 551,562 ----
  # }}}
  
  # LINT - for running lint
! #  For standard lint
! #LINT = lint
! #LINT_OPTIONS = -beprxzF
! #  For splint  (see cleanlint.vim for filtering the output)
! LINT = splint
! LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999
  
  # PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
  # Might not work with GUI or Perl.
***************
*** 1259,1274 ****
  #     This is for cproto 3 patchlevel 8 or below
  #     __inline, __attribute__ and __extension__ are not recognized by cproto
  #     G_IMPLEMENT_INLINES is to avoid functions defined in glib/gutils.h.
! NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
! 	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
! 	  -D__extension__= -D__restrict="" \
! 	  -D__gnuc_va_list=char -D__builtin_va_list=char
  
  #
! #     This is for cproto 3 patchlevel 9 or above (currently 4.6)
  #     __inline and __attribute__ are now recognized by cproto
  #     -D"foo()=" is not supported by all compilers so do not use it
! # NO_ATTR=
  #
  #     maybe the "/usr/bin/cc -E" has to be adjusted for some systems
  # This is for cproto 3.5 patchlevel 3:
--- 1264,1279 ----
  #     This is for cproto 3 patchlevel 8 or below
  #     __inline, __attribute__ and __extension__ are not recognized by cproto
  #     G_IMPLEMENT_INLINES is to avoid functions defined in glib/gutils.h.
! #NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
! #	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
! #	  -D__extension__= -D__restrict="" \
! #	  -D__gnuc_va_list=char -D__builtin_va_list=char
  
  #
! #     This is for cproto 3 patchlevel 9 or above (currently 4.6, 4.7g)
  #     __inline and __attribute__ are now recognized by cproto
  #     -D"foo()=" is not supported by all compilers so do not use it
! NO_ATTR=
  #
  #     maybe the "/usr/bin/cc -E" has to be adjusted for some systems
  # This is for cproto 3.5 patchlevel 3:
***************
*** 1432,1437 ****
--- 1437,1443 ----
  	$(SNIFF_SRC) $(WORKSHOP_SRC) $(WSDEBUG_SRC) $(NETBEANS_SRC)
  #LINT_SRC = $(SRC)
  #LINT_SRC = $(ALL_SRC)
+ #LINT_SRC = $(BASIC_SRC)
  
  OBJ = \
  	objects/buffer.o \
***************
*** 2272,2283 ****
  
  # Run lint.  Clean up the *.ln files that are sometimes left behind.
  lint:
! 	lint $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
  	-rm -f *.ln
  
  # Check dosinst.c with lint.
  lintinstall:
! 	lint $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
  	-rm -f dosinst.ln
  
  ###########################################################################
--- 2279,2290 ----
  
  # Run lint.  Clean up the *.ln files that are sometimes left behind.
  lint:
! 	$(LINT) $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
  	-rm -f *.ln
  
  # Check dosinst.c with lint.
  lintinstall:
! 	$(LINT) $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
  	-rm -f dosinst.ln
  
  ###########################################################################
*** ../vim-7.2.166/src/buffer.c	2009-02-22 00:01:42.000000000 +0100
--- src/buffer.c	2009-05-13 12:25:29.000000000 +0200
***************
*** 44,49 ****
--- 44,50 ----
  #ifdef FEAT_TITLE
  static int	ti_change __ARGS((char_u *str, char_u **last));
  #endif
+ static int	append_arg_number __ARGS((win_T *wp, char_u *buf, int buflen, int add_file));
  static void	free_buffer __ARGS((buf_T *));
  static void	free_buffer_stuff __ARGS((buf_T *buf, int free_options));
  static void	clear_wininfo __ARGS((buf_T *buf));
***************
*** 1453,1465 ****
  
  #ifdef FEAT_KEYMAP
      if (curbuf->b_kmap_state & KEYMAP_INIT)
! 	keymap_init();
  #endif
  #ifdef FEAT_SPELL
      /* May need to set the spell language.  Can only do this after the buffer
       * has been properly setup. */
      if (!curbuf->b_help && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
! 	did_set_spelllang(curbuf);
  #endif
  
      redraw_later(NOT_VALID);
--- 1454,1466 ----
  
  #ifdef FEAT_KEYMAP
      if (curbuf->b_kmap_state & KEYMAP_INIT)
! 	(void)keymap_init();
  #endif
  #ifdef FEAT_SPELL
      /* May need to set the spell language.  Can only do this after the buffer
       * has been properly setup. */
      if (!curbuf->b_help && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
! 	(void)did_set_spelllang(curbuf);
  #endif
  
      redraw_later(NOT_VALID);
***************
*** 2516,2522 ****
      buf_T	*buf;
  {
      wininfo_T	*wip;
!     static pos_T no_position = {1, 0};
  
      wip = find_wininfo(buf, FALSE);
      if (wip != NULL)
--- 2517,2523 ----
      buf_T	*buf;
  {
      wininfo_T	*wip;
!     static pos_T no_position = INIT_POS_T(1, 0, 0);
  
      wip = find_wininfo(buf, FALSE);
      if (wip != NULL)
***************
*** 2577,2584 ****
  	{
  	    IObuff[len++] = ' ';
  	} while (--i > 0 && len < IOSIZE - 18);
! 	vim_snprintf((char *)IObuff + len, IOSIZE - len, _("line %ld"),
! 		buf == curbuf ? curwin->w_cursor.lnum
  					       : (long)buflist_findlnum(buf));
  	msg_outtrans(IObuff);
  	out_flush();	    /* output one line at a time */
--- 2578,2585 ----
  	{
  	    IObuff[len++] = ' ';
  	} while (--i > 0 && len < IOSIZE - 18);
! 	vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),
! 		_("line %ld"), buf == curbuf ? curwin->w_cursor.lnum
  					       : (long)buflist_findlnum(buf));
  	msg_outtrans(IObuff);
  	out_flush();	    /* output one line at a time */
***************
*** 2967,2973 ****
  
      if (fullname > 1)	    /* 2 CTRL-G: include buffer number */
      {
! 	sprintf((char *)buffer, "buf %d: ", curbuf->b_fnum);
  	p = buffer + STRLEN(buffer);
      }
      else
--- 2968,2974 ----
  
      if (fullname > 1)	    /* 2 CTRL-G: include buffer number */
      {
! 	vim_snprintf((char *)buffer, IOSIZE, "buf %d: ", curbuf->b_fnum);
  	p = buffer + STRLEN(buffer);
      }
      else
***************
*** 3041,3051 ****
  		(long)curbuf->b_ml.ml_line_count,
  		n);
  	validate_virtcol();
! 	col_print(buffer + STRLEN(buffer),
  		   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);
      }
  
!     (void)append_arg_number(curwin, buffer, !shortmess(SHM_FILE), IOSIZE);
  
      if (dont_truncate)
      {
--- 3042,3053 ----
  		(long)curbuf->b_ml.ml_line_count,
  		n);
  	validate_virtcol();
! 	len = STRLEN(buffer);
! 	col_print(buffer + len, IOSIZE - len,
  		   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);
      }
  
!     (void)append_arg_number(curwin, buffer, IOSIZE, !shortmess(SHM_FILE));
  
      if (dont_truncate)
      {
***************
*** 3073,3087 ****
  }
  
      void
! col_print(buf, col, vcol)
      char_u  *buf;
      int	    col;
      int	    vcol;
  {
      if (col == vcol)
! 	sprintf((char *)buf, "%d", col);
      else
! 	sprintf((char *)buf, "%d-%d", col, vcol);
  }
  
  #if defined(FEAT_TITLE) || defined(PROTO)
--- 3075,3090 ----
  }
  
      void
! col_print(buf, buflen, col, vcol)
      char_u  *buf;
+     size_t  buflen;
      int	    col;
      int	    vcol;
  {
      if (col == vcol)
! 	vim_snprintf((char *)buf, buflen, "%d", col);
      else
! 	vim_snprintf((char *)buf, buflen, "%d-%d", col, vcol);
  }
  
  #if defined(FEAT_TITLE) || defined(PROTO)
***************
*** 3194,3211 ****
  		if (p == buf + off)
  		    /* must be a help buffer */
  		    vim_strncpy(buf + off, (char_u *)_("help"),
! 							    IOSIZE - off - 1);
  		else
  		    *p = NUL;
  
  		/* translate unprintable chars */
  		p = transstr(buf + off);
! 		vim_strncpy(buf + off, p, IOSIZE - off - 1);
  		vim_free(p);
  		STRCAT(buf, ")");
  	    }
  
! 	    append_arg_number(curwin, buf, FALSE, IOSIZE);
  
  #if defined(FEAT_CLIENTSERVER)
  	    if (serverName != NULL)
--- 3197,3214 ----
  		if (p == buf + off)
  		    /* must be a help buffer */
  		    vim_strncpy(buf + off, (char_u *)_("help"),
! 						  (size_t)(IOSIZE - off - 1));
  		else
  		    *p = NUL;
  
  		/* translate unprintable chars */
  		p = transstr(buf + off);
! 		vim_strncpy(buf + off, p, (size_t)(IOSIZE - off - 1));
  		vim_free(p);
  		STRCAT(buf, ")");
  	    }
  
! 	    append_arg_number(curwin, buf, IOSIZE, FALSE);
  
  #if defined(FEAT_CLIENTSERVER)
  	    if (serverName != NULL)
***************
*** 3520,3526 ****
  		    n = (long)(p - t) - item[groupitem[groupdepth]].maxwid + 1;
  
  		*t = '<';
! 		mch_memmove(t + 1, t + n, p - (t + n));
  		p = p - n + 1;
  #ifdef FEAT_MBYTE
  		/* Fill up space left over by half a double-wide char. */
--- 3523,3529 ----
  		    n = (long)(p - t) - item[groupitem[groupdepth]].maxwid + 1;
  
  		*t = '<';
! 		mch_memmove(t + 1, t + n, (size_t)(p - (t + n)));
  		p = p - n + 1;
  #ifdef FEAT_MBYTE
  		/* Fill up space left over by half a double-wide char. */
***************
*** 3550,3556 ****
  		else
  		{
  		    /* fill by inserting characters */
! 		    mch_memmove(t + n - l, t, p - t);
  		    l = n - l;
  		    if (p + l >= out + outlen)
  			l = (long)((out + outlen) - p - 1);
--- 3553,3559 ----
  		else
  		{
  		    /* fill by inserting characters */
! 		    mch_memmove(t + n - l, t, (size_t)(p - t));
  		    l = n - l;
  		    if (p + l >= out + outlen)
  			l = (long)((out + outlen) - p - 1);
***************
*** 3686,3692 ****
  	    p = t;
  
  #ifdef FEAT_EVAL
! 	    sprintf((char *)tmp, "%d", curbuf->b_fnum);
  	    set_internal_string_var((char_u *)"actual_curbuf", tmp);
  
  	    o_curbuf = curbuf;
--- 3689,3695 ----
  	    p = t;
  
  #ifdef FEAT_EVAL
! 	    vim_snprintf((char *)tmp, sizeof(tmp), "%d", curbuf->b_fnum);
  	    set_internal_string_var((char_u *)"actual_curbuf", tmp);
  
  	    o_curbuf = curbuf;
***************
*** 3753,3765 ****
  
  	case STL_ALTPERCENT:
  	    str = tmp;
! 	    get_rel_pos(wp, str);
  	    break;
  
  	case STL_ARGLISTSTAT:
  	    fillable = FALSE;
  	    tmp[0] = 0;
! 	    if (append_arg_number(wp, tmp, FALSE, (int)sizeof(tmp)))
  		str = tmp;
  	    break;
  
--- 3756,3768 ----
  
  	case STL_ALTPERCENT:
  	    str = tmp;
! 	    get_rel_pos(wp, str, TMPLEN);
  	    break;
  
  	case STL_ARGLISTSTAT:
  	    fillable = FALSE;
  	    tmp[0] = 0;
! 	    if (append_arg_number(wp, tmp, (int)sizeof(tmp), FALSE))
  		str = tmp;
  	    break;
  
***************
*** 3794,3800 ****
  	case STL_BYTEVAL_X:
  	    base = 'X';
  	case STL_BYTEVAL:
! 	    if (wp->w_cursor.col > STRLEN(linecont))
  		num = 0;
  	    else
  	    {
--- 3797,3803 ----
  	case STL_BYTEVAL_X:
  	    base = 'X';
  	case STL_BYTEVAL:
! 	    if (wp->w_cursor.col > (colnr_T)STRLEN(linecont))
  		num = 0;
  	    else
  	    {
***************
*** 3967,3973 ****
  	    if (zeropad)
  		*t++ = '0';
  	    *t++ = '*';
! 	    *t++ = nbase == 16 ? base : (nbase == 8 ? 'o' : 'd');
  	    *t = 0;
  
  	    for (n = num, l = 1; n >= nbase; n /= nbase)
--- 3970,3976 ----
  	    if (zeropad)
  		*t++ = '0';
  	    *t++ = '*';
! 	    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');
  	    *t = 0;
  
  	    for (n = num, l = 1; n >= nbase; n /= nbase)
***************
*** 4160,4172 ****
  #if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \
  	    || defined(FEAT_GUI_TABLINE) || defined(PROTO)
  /*
!  * Get relative cursor position in window into "str[]", in the form 99%, using
!  * "Top", "Bot" or "All" when appropriate.
   */
      void
! get_rel_pos(wp, str)
      win_T	*wp;
!     char_u	*str;
  {
      long	above; /* number of lines above window */
      long	below; /* number of lines below window */
--- 4163,4176 ----
  #if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \
  	    || defined(FEAT_GUI_TABLINE) || defined(PROTO)
  /*
!  * Get relative cursor position in window into "buf[buflen]", in the form 99%,
!  * using "Top", "Bot" or "All" when appropriate.
   */
      void
! get_rel_pos(wp, buf, buflen)
      win_T	*wp;
!     char_u	*buf;
!     int		buflen;
  {
      long	above; /* number of lines above window */
      long	below; /* number of lines below window */
***************
*** 4177,4210 ****
  #endif
      below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;
      if (below <= 0)
! 	STRCPY(str, above == 0 ? _("All") : _("Bot"));
      else if (above <= 0)
! 	STRCPY(str, _("Top"));
      else
! 	sprintf((char *)str, "%2d%%", above > 1000000L
  				    ? (int)(above / ((above + below) / 100L))
  				    : (int)(above * 100L / (above + below)));
  }
  #endif
  
  /*
!  * Append (file 2 of 8) to 'buf', if editing more than one file.
   * Return TRUE if it was appended.
   */
!     int
! append_arg_number(wp, buf, add_file, maxlen)
      win_T	*wp;
      char_u	*buf;
      int		add_file;	/* Add "file" before the arg number */
-     int		maxlen;		/* maximum nr of chars in buf or zero*/
  {
      char_u	*p;
  
      if (ARGCOUNT <= 1)		/* nothing to do */
  	return FALSE;
  
!     p = buf + STRLEN(buf);		/* go to the end of the buffer */
!     if (maxlen && p - buf + 35 >= maxlen) /* getting too long */
  	return FALSE;
      *p++ = ' ';
      *p++ = '(';
--- 4181,4215 ----
  #endif
      below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;
      if (below <= 0)
! 	vim_strncpy(buf, (char_u *)(above == 0 ? _("All") : _("Bot")),
! 							(size_t)(buflen - 1));
      else if (above <= 0)
! 	vim_strncpy(buf, (char_u *)_("Top"), (size_t)(buflen - 1));
      else
! 	vim_snprintf((char *)buf, (size_t)buflen, "%2d%%", above > 1000000L
  				    ? (int)(above / ((above + below) / 100L))
  				    : (int)(above * 100L / (above + below)));
  }
  #endif
  
  /*
!  * Append (file 2 of 8) to "buf[buflen]", if editing more than one file.
   * Return TRUE if it was appended.
   */
!     static int
! append_arg_number(wp, buf, buflen, add_file)
      win_T	*wp;
      char_u	*buf;
+     int		buflen;
      int		add_file;	/* Add "file" before the arg number */
  {
      char_u	*p;
  
      if (ARGCOUNT <= 1)		/* nothing to do */
  	return FALSE;
  
!     p = buf + STRLEN(buf);	/* go to the end of the buffer */
!     if (p - buf + 35 >= buflen)	/* getting too long */
  	return FALSE;
      *p++ = ' ';
      *p++ = '(';
***************
*** 4213,4219 ****
  	STRCPY(p, "file ");
  	p += 5;
      }
!     sprintf((char *)p, wp->w_arg_idx_invalid ? "(%d) of %d)"
  				  : "%d of %d)", wp->w_arg_idx + 1, ARGCOUNT);
      return TRUE;
  }
--- 4218,4225 ----
  	STRCPY(p, "file ");
  	p += 5;
      }
!     vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),
! 		wp->w_arg_idx_invalid ? "(%d) of %d)"
  				  : "%d of %d)", wp->w_arg_idx + 1, ARGCOUNT);
      return TRUE;
  }
***************
*** 4996,5002 ****
  	if (tab != NULL)
  	{
  	    *tab++ = '\0';
! 	    col = atoi((char *)tab);
  	    tab = vim_strrchr(xline, '\t');
  	    if (tab != NULL)
  	    {
--- 5002,5008 ----
  	if (tab != NULL)
  	{
  	    *tab++ = '\0';
! 	    col = (colnr_T)atoi((char *)tab);
  	    tab = vim_strrchr(xline, '\t');
  	    if (tab != NULL)
  	    {
***************
*** 5034,5039 ****
--- 5040,5046 ----
  #endif
      char_u	*line;
      int		max_buffers;
+     size_t	len;
  
      if (find_viminfo_parameter('%') == NULL)
  	return;
***************
*** 5042,5048 ****
      max_buffers = get_viminfo_parameter('%');
  
      /* Allocate room for the file name, lnum and col. */
!     line = alloc(MAXPATHL + 40);
      if (line == NULL)
  	return;
  
--- 5049,5056 ----
      max_buffers = get_viminfo_parameter('%');
  
      /* Allocate room for the file name, lnum and col. */
! #define LINE_BUF_LEN (MAXPATHL + 40)
!     line = alloc(LINE_BUF_LEN);
      if (line == NULL)
  	return;
  
***************
*** 5068,5074 ****
  	    break;
  	putc('%', fp);
  	home_replace(NULL, buf->b_ffname, line, MAXPATHL, TRUE);
! 	sprintf((char *)line + STRLEN(line), "\t%ld\t%d",
  			(long)buf->b_last_cursor.lnum,
  			buf->b_last_cursor.col);
  	viminfo_writestring(fp, line);
--- 5076,5083 ----
  	    break;
  	putc('%', fp);
  	home_replace(NULL, buf->b_ffname, line, MAXPATHL, TRUE);
! 	len = STRLEN(line);
! 	vim_snprintf((char *)line + len, len - LINE_BUF_LEN, "\t%ld\t%d",
  			(long)buf->b_last_cursor.lnum,
  			buf->b_last_cursor.col);
  	viminfo_writestring(fp, line);
***************
*** 5226,5232 ****
      return;
  }
  
!     int
  buf_change_sign_type(buf, markId, typenr)
      buf_T	*buf;		/* buffer to store sign in */
      int		markId;		/* sign ID */
--- 5235,5241 ----
      return;
  }
  
!     linenr_T
  buf_change_sign_type(buf, markId, typenr)
      buf_T	*buf;		/* buffer to store sign in */
      int		markId;		/* sign ID */
***************
*** 5243,5252 ****
  	}
      }
  
!     return 0;
  }
  
!     int_u
  buf_getsigntype(buf, lnum, type)
      buf_T	*buf;
      linenr_T	lnum;
--- 5252,5261 ----
  	}
      }
  
!     return (linenr_T)0;
  }
  
!     int
  buf_getsigntype(buf, lnum, type)
      buf_T	*buf;
      linenr_T	lnum;
*** ../vim-7.2.166/src/charset.c	2008-07-24 21:30:44.000000000 +0200
--- src/charset.c	2009-05-05 18:17:11.000000000 +0200
***************
*** 17,23 ****
  static int win_nolbr_chartabsize __ARGS((win_T *wp, char_u *s, colnr_T col, int *headp));
  #endif
  
! static int nr2hex __ARGS((int c));
  
  static int    chartab_initialized = FALSE;
  
--- 17,23 ----
  static int win_nolbr_chartabsize __ARGS((win_T *wp, char_u *s, colnr_T col, int *headp));
  #endif
  
! static unsigned nr2hex __ARGS((unsigned c));
  
  static int    chartab_initialized = FALSE;
  
***************
*** 664,670 ****
      }
  #endif
      buf[++i] = nr2hex((unsigned)c >> 4);
!     buf[++i] = nr2hex(c);
      buf[++i] = '>';
      buf[++i] = NUL;
  }
--- 664,670 ----
      }
  #endif
      buf[++i] = nr2hex((unsigned)c >> 4);
!     buf[++i] = nr2hex((unsigned)c);
      buf[++i] = '>';
      buf[++i] = NUL;
  }
***************
*** 674,682 ****
   * Lower case letters are used to avoid the confusion of <F1> being 0xf1 or
   * function key 1.
   */
!     static int
  nr2hex(c)
!     int		c;
  {
      if ((c & 0xf) <= 9)
  	return (c & 0xf) + '0';
--- 674,682 ----
   * Lower case letters are used to avoid the confusion of <F1> being 0xf1 or
   * function key 1.
   */
!     static unsigned
  nr2hex(c)
!     unsigned	c;
  {
      if ((c & 0xf) <= 9)
  	return (c & 0xf) + '0';
***************
*** 884,890 ****
      if (c >= 0x100)
      {
  	if (enc_dbcs != 0)
! 	    return dbcs_class((unsigned)c >> 8, c & 0xff) >= 2;
  	if (enc_utf8)
  	    return utf_class(c) >= 2;
      }
--- 884,890 ----
      if (c >= 0x100)
      {
  	if (enc_dbcs != 0)
! 	    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2;
  	if (enc_utf8)
  	    return utf_class(c) >= 2;
      }
***************
*** 1090,1096 ****
  	 */
  	numberextra = win_col_off(wp);
  	col2 = col;
! 	colmax = W_WIDTH(wp) - numberextra;
  	if (col >= colmax)
  	{
  	    n = colmax + win_col_off2(wp);
--- 1090,1096 ----
  	 */
  	numberextra = win_col_off(wp);
  	col2 = col;
! 	colmax = (colnr_T)(W_WIDTH(wp) - numberextra);
  	if (col >= colmax)
  	{
  	    n = colmax + win_col_off2(wp);
***************
*** 1201,1217 ****
      win_T	*wp;
      colnr_T	vcol;
  {
!     colnr_T	width1;		/* width of first line (after line number) */
!     colnr_T	width2;		/* width of further lines */
  
  #ifdef FEAT_VERTSPLIT
      if (wp->w_width == 0)	/* there is no border */
  	return FALSE;
  #endif
      width1 = W_WIDTH(wp) - win_col_off(wp);
!     if (vcol < width1 - 1)
  	return FALSE;
!     if (vcol == width1 - 1)
  	return TRUE;
      width2 = width1 + win_col_off2(wp);
      return ((vcol - width1) % width2 == width2 - 1);
--- 1201,1217 ----
      win_T	*wp;
      colnr_T	vcol;
  {
!     int		width1;		/* width of first line (after line number) */
!     int		width2;		/* width of further lines */
  
  #ifdef FEAT_VERTSPLIT
      if (wp->w_width == 0)	/* there is no border */
  	return FALSE;
  #endif
      width1 = W_WIDTH(wp) - win_col_off(wp);
!     if ((int)vcol < width1 - 1)
  	return FALSE;
!     if ((int)vcol == width1 - 1)
  	return TRUE;
      width2 = width1 + win_col_off2(wp);
      return ((vcol - width1) % width2 == width2 - 1);
***************
*** 1396,1408 ****
  # ifdef FEAT_MBYTE
  	/* Cannot put the cursor on part of a wide character. */
  	ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
! 	if (pos->col < STRLEN(ptr))
  	{
  	    int c = (*mb_ptr2char)(ptr + pos->col);
  
  	    if (c != TAB && vim_isprintc(c))
  	    {
! 		endadd = char2cells(c) - 1;
  		if (coladd > endadd)	/* past end of line */
  		    endadd = 0;
  		else
--- 1396,1408 ----
  # ifdef FEAT_MBYTE
  	/* Cannot put the cursor on part of a wide character. */
  	ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
! 	if (pos->col < (colnr_T)STRLEN(ptr))
  	{
  	    int c = (*mb_ptr2char)(ptr + pos->col);
  
  	    if (c != TAB && vim_isprintc(c))
  	    {
! 		endadd = (colnr_T)(char2cells(c) - 1);
  		if (coladd > endadd)	/* past end of line */
  		    endadd = 0;
  		else
*** ../vim-7.2.166/src/cleanlint.vim	2009-05-13 12:08:12.000000000 +0200
--- src/cleanlint.vim	2009-05-05 21:34:01.000000000 +0200
***************
*** 0 ****
--- 1,27 ----
+ " Vim tool: Filter output of splint
+ "
+ " Maintainer:	Bram Moolenaar <Bram@vim.org>
+ " Last Change:	2009 May 05
+ 
+ " Usage: redirect output of "make lint" to a file, edit that file with Vim and
+ " :call CleanLint()
+ " This deletes irrelevant messages.  What remains might be valid warnings.
+ 
+ fun! CleanLint()
+   g/^  Types are incompatible/lockmarks d
+   g/Assignment of dev_t to __dev_t:/lockmarks d
+   g/Assignment of __dev_t to dev_t:/lockmarks d
+   g/Operands of == have incompatible types (__dev_t, dev_t): /lockmarks d
+   g/Operands of == have incompatible types (unsigned int, int): /lockmarks d
+   g/Assignment of char to char_u: /lockmarks d
+   g/Assignment of unsigned int to int: /lockmarks d
+   g/Assignment of colnr_T to int: /lockmarks d
+   g/Assignment of int to char_u: /lockmarks d
+   g/Function .* expects arg . to be wint_t gets int: /lockmarks d
+   g/^digraph.c.*digraphdefault.*is type char, expects char_u:/lockmarks d
+   g/^digraph.c.*Additional initialization errors for digraphdefault not reported/lockmarks d
+   g/Function strncasecmp expects arg 3 to be int gets size_t: /lockmarks d
+   g/ To ignore signs in type comparisons use +ignoresigns/lockmarks d
+   g/ To allow arbitrary integral types to match any integral type, use +matchanyintegral./lockmarks d
+   g/ To allow arbitrary integral types to match long unsigned, use +longintegral./lockmarks d
+ endfun
*** ../vim-7.2.166/src/digraph.c	2008-06-25 00:26:41.000000000 +0200
--- src/digraph.c	2009-05-05 20:32:43.000000000 +0200
***************
*** 32,38 ****
  static void printdigraph __ARGS((digr_T *));
  
  /* digraphs added by the user */
! static garray_T	user_digraphs = {0, 0, sizeof(digr_T), 10, NULL};
  
  /*
   * Note: Characters marked with XX are not included literally, because some
--- 32,38 ----
  static void printdigraph __ARGS((digr_T *));
  
  /* digraphs added by the user */
! static garray_T	user_digraphs = {0, 0, (int)sizeof(digr_T), 10, NULL};
  
  /*
   * Note: Characters marked with XX are not included literally, because some
***************
*** 2371,2380 ****
  	}
  	else
  #endif
! 	    *p++ = dp->result;
  	if (char2cells(dp->result) == 1)
  	    *p++ = ' ';
! 	sprintf((char *)p, " %3d", dp->result);
  	msg_outtrans(buf);
      }
  }
--- 2371,2380 ----
  	}
  	else
  #endif
! 	    *p++ = (char_u)dp->result;
  	if (char2cells(dp->result) == 1)
  	    *p++ = ' ';
! 	vim_snprintf((char *)p, sizeof(buf) - (p - buf), " %3d", dp->result);
  	msg_outtrans(buf);
      }
  }
***************
*** 2395,2401 ****
  static void keymap_unload __ARGS((void));
  
  /*
!  * Set up key mapping tables for the 'keymap' option
   */
      char_u *
  keymap_init()
--- 2395,2404 ----
  static void keymap_unload __ARGS((void));
  
  /*
!  * Set up key mapping tables for the 'keymap' option.
!  * Returns NULL if OK, an error message for failure.  This only needs to be
!  * used when setting the option, not later when the value has already been
!  * checked.
   */
      char_u *
  keymap_init()
***************
*** 2412,2436 ****
      else
      {
  	char_u	*buf;
  
  	/* Source the keymap file.  It will contain a ":loadkeymap" command
  	 * which will call ex_loadkeymap() below. */
! 	buf = alloc((unsigned)(STRLEN(curbuf->b_p_keymap)
  # ifdef FEAT_MBYTE
! 						       + STRLEN(p_enc)
  # endif
! 						       + 14));
  	if (buf == NULL)
  	    return e_outofmem;
  
  # ifdef FEAT_MBYTE
  	/* try finding "keymap/'keymap'_'encoding'.vim"  in 'runtimepath' */
! 	sprintf((char *)buf, "keymap/%s_%s.vim", curbuf->b_p_keymap, p_enc);
  	if (source_runtime(buf, FALSE) == FAIL)
  # endif
  	{
  	    /* try finding "keymap/'keymap'.vim" in 'runtimepath'  */
! 	    sprintf((char *)buf, "keymap/%s.vim", curbuf->b_p_keymap);
  	    if (source_runtime(buf, FALSE) == FAIL)
  	    {
  		vim_free(buf);
--- 2415,2443 ----
      else
      {
  	char_u	*buf;
+ 	size_t  buflen;
  
  	/* Source the keymap file.  It will contain a ":loadkeymap" command
  	 * which will call ex_loadkeymap() below. */
! 	buflen = STRLEN(curbuf->b_p_keymap)
  # ifdef FEAT_MBYTE
! 					   + STRLEN(p_enc)
  # endif
! 						       + 14;
! 	buf = alloc((unsigned)buflen);
  	if (buf == NULL)
  	    return e_outofmem;
  
  # ifdef FEAT_MBYTE
  	/* try finding "keymap/'keymap'_'encoding'.vim"  in 'runtimepath' */
! 	vim_snprintf((char *)buf, buflen, "keymap/%s_%s.vim",
! 						   curbuf->b_p_keymap, p_enc);
  	if (source_runtime(buf, FALSE) == FAIL)
  # endif
  	{
  	    /* try finding "keymap/'keymap'.vim" in 'runtimepath'  */
! 	    vim_snprintf((char *)buf, buflen, "keymap/%s.vim",
! 							  curbuf->b_p_keymap);
  	    if (source_runtime(buf, FALSE) == FAIL)
  	    {
  		vim_free(buf);
*** ../vim-7.2.166/src/edit.c	2009-02-21 20:27:00.000000000 +0100
--- src/edit.c	2009-05-05 21:14:50.000000000 +0200
***************
*** 57,63 ****
      N_(" Keyword Local completion (^N^P)"),
  };
  
! static char_u e_hitend[] = N_("Hit end of paragraph");
  
  /*
   * Structure used to store one match for insert completion.
--- 57,63 ----
      N_(" Keyword Local completion (^N^P)"),
  };
  
! static char e_hitend[] = N_("Hit end of paragraph");
  
  /*
   * Structure used to store one match for insert completion.
***************
*** 69,75 ****
--- 69,79 ----
      compl_T	*cp_prev;
      char_u	*cp_str;	/* matched text */
      char	cp_icase;	/* TRUE or FALSE: ignore case */
+ #ifdef S_SPLINT_S  /* splint can't handle array of pointers */
+     char_u	**cp_text;	/* text for the menu */
+ #else
      char_u	*(cp_text[CPT_COUNT]);	/* text for the menu */
+ #endif
      char_u	*cp_fname;	/* file containing the match, allocated when
  				 * cp_flags has FREE_FNAME */
      int		cp_flags;	/* ORIGINAL_TEXT, CONT_S_IPOS or FREE_FNAME */
***************
*** 306,312 ****
      int		c = 0;
      char_u	*ptr;
      int		lastc;
!     colnr_T	mincol;
      static linenr_T o_lnum = 0;
      int		i;
      int		did_backspace = TRUE;	    /* previous char was backspace */
--- 310,316 ----
      int		c = 0;
      char_u	*ptr;
      int		lastc;
!     int		mincol;
      static linenr_T o_lnum = 0;
      int		i;
      int		did_backspace = TRUE;	    /* previous char was backspace */
***************
*** 387,393 ****
  	if (startln)
  	    Insstart.col = 0;
      }
!     Insstart_textlen = linetabsize(ml_get_curline());
      Insstart_blank_vcol = MAXCOL;
      if (!did_ai)
  	ai_col = 0;
--- 391,397 ----
  	if (startln)
  	    Insstart.col = 0;
      }
!     Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
      Insstart_blank_vcol = MAXCOL;
      if (!did_ai)
  	ai_col = 0;
***************
*** 653,659 ****
  	    mincol = curwin->w_wcol;
  	    validate_cursor_col();
  
! 	    if ((int)curwin->w_wcol < (int)mincol - curbuf->b_p_ts
  		    && curwin->w_wrow == W_WINROW(curwin)
  						 + curwin->w_height - 1 - p_so
  		    && (curwin->w_cursor.lnum != curwin->w_topline
--- 657,663 ----
  	    mincol = curwin->w_wcol;
  	    validate_cursor_col();
  
! 	    if ((int)curwin->w_wcol < mincol - curbuf->b_p_ts
  		    && curwin->w_wrow == W_WINROW(curwin)
  						 + curwin->w_height - 1 - p_so
  		    && (curwin->w_cursor.lnum != curwin->w_topline
***************
*** 1773,1779 ****
  	 * Compute the screen column where the cursor should be.
  	 */
  	vcol = get_indent() - vcol;
! 	curwin->w_virtcol = (vcol < 0) ? 0 : vcol;
  
  	/*
  	 * Advance the cursor until we reach the right screen column.
--- 1777,1783 ----
  	 * Compute the screen column where the cursor should be.
  	 */
  	vcol = get_indent() - vcol;
! 	curwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);
  
  	/*
  	 * Advance the cursor until we reach the right screen column.
***************
*** 1800,1808 ****
  	 */
  	if (vcol != (int)curwin->w_virtcol)
  	{
! 	    curwin->w_cursor.col = new_cursor_col;
  	    i = (int)curwin->w_virtcol - vcol;
! 	    ptr = alloc(i + 1);
  	    if (ptr != NULL)
  	    {
  		new_cursor_col += i;
--- 1804,1812 ----
  	 */
  	if (vcol != (int)curwin->w_virtcol)
  	{
! 	    curwin->w_cursor.col = (colnr_T)new_cursor_col;
  	    i = (int)curwin->w_virtcol - vcol;
! 	    ptr = alloc((unsigned)(i + 1));
  	    if (ptr != NULL)
  	    {
  		new_cursor_col += i;
***************
*** 1826,1832 ****
      if (new_cursor_col <= 0)
  	curwin->w_cursor.col = 0;
      else
! 	curwin->w_cursor.col = new_cursor_col;
      curwin->w_set_curswant = TRUE;
      changed_cline_bef_curs();
  
--- 1830,1836 ----
      if (new_cursor_col <= 0)
  	curwin->w_cursor.col = 0;
      else
! 	curwin->w_cursor.col = (colnr_T)new_cursor_col;
      curwin->w_set_curswant = TRUE;
      changed_cline_bef_curs();
  
***************
*** 1966,1972 ****
  #ifdef FEAT_MBYTE
      if (enc_utf8 && limit_col >= 0)
      {
! 	int ecol = curwin->w_cursor.col + 1;
  
  	/* Make sure the cursor is at the start of a character, but
  	 * skip forward again when going too far back because of a
--- 1970,1976 ----
  #ifdef FEAT_MBYTE
      if (enc_utf8 && limit_col >= 0)
      {
! 	colnr_T ecol = curwin->w_cursor.col + 1;
  
  	/* Make sure the cursor is at the start of a character, but
  	 * skip forward again when going too far back because of a
***************
*** 1982,1988 ****
  	}
  	if (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)
  	    return FALSE;
! 	del_bytes((long)(ecol - curwin->w_cursor.col), FALSE, TRUE);
      }
      else
  #endif
--- 1986,1992 ----
  	}
  	if (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)
  	    return FALSE;
! 	del_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);
      }
      else
  #endif
***************
*** 2201,2207 ****
  	    actual_compl_length = compl_length;
  
  	/* Allocate wide character array for the completion and fill it. */
! 	wca = (int *)alloc(actual_len * sizeof(int));
  	if (wca != NULL)
  	{
  	    p = str;
--- 2205,2211 ----
  	    actual_compl_length = compl_length;
  
  	/* Allocate wide character array for the completion and fill it. */
! 	wca = (int *)alloc((unsigned)(actual_len * sizeof(int)));
  	if (wca != NULL)
  	{
  	    p = str;
***************
*** 2580,2586 ****
   */
      void
  set_completion(startcol, list)
!     int	    startcol;
      list_T  *list;
  {
      /* If already doing completions stop it. */
--- 2584,2590 ----
   */
      void
  set_completion(startcol, list)
!     colnr_T startcol;
      list_T  *list;
  {
      /* If already doing completions stop it. */
***************
*** 2591,2600 ****
      if (stop_arrow() == FAIL)
  	return;
  
!     if (startcol > (int)curwin->w_cursor.col)
  	startcol = curwin->w_cursor.col;
      compl_col = startcol;
!     compl_length = curwin->w_cursor.col - startcol;
      /* compl_pattern doesn't need to be set */
      compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);
      if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
--- 2595,2604 ----
      if (stop_arrow() == FAIL)
  	return;
  
!     if (startcol > curwin->w_cursor.col)
  	startcol = curwin->w_cursor.col;
      compl_col = startcol;
!     compl_length = (int)curwin->w_cursor.col - (int)startcol;
      /* compl_pattern doesn't need to be set */
      compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);
      if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
***************
*** 2860,2866 ****
      regmatch_T	regmatch;
      char_u	**files;
      int		count;
-     int		i;
      int		save_p_scs;
      int		dir = compl_direction;
  
--- 2864,2869 ----
***************
*** 2892,2908 ****
      if (ctrl_x_mode == CTRL_X_WHOLE_LINE)
      {
  	char_u *pat_esc = vim_strsave_escaped(pat, (char_u *)"\\");
  
  	if (pat_esc == NULL)
  	    goto theend;
! 	i = (int)STRLEN(pat_esc) + 10;
! 	ptr = alloc(i);
  	if (ptr == NULL)
  	{
  	    vim_free(pat_esc);
  	    goto theend;
  	}
! 	vim_snprintf((char *)ptr, i, "^\\s*\\zs\\V%s", pat_esc);
  	regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);
  	vim_free(pat_esc);
  	vim_free(ptr);
--- 2895,2912 ----
      if (ctrl_x_mode == CTRL_X_WHOLE_LINE)
      {
  	char_u *pat_esc = vim_strsave_escaped(pat, (char_u *)"\\");
+ 	size_t len;
  
  	if (pat_esc == NULL)
  	    goto theend;
! 	len = STRLEN(pat_esc) + 10;
! 	ptr = alloc((unsigned)len);
  	if (ptr == NULL)
  	{
  	    vim_free(pat_esc);
  	    goto theend;
  	}
! 	vim_snprintf((char *)ptr, len, "^\\s*\\zs\\V%s", pat_esc);
  	regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);
  	vim_free(pat_esc);
  	vim_free(ptr);
***************
*** 2993,2999 ****
  	{
  	    vim_snprintf((char *)IObuff, IOSIZE,
  			      _("Scanning dictionary: %s"), (char *)files[i]);
! 	    msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  	}
  
  	if (fp != NULL)
--- 2997,3003 ----
  	{
  	    vim_snprintf((char *)IObuff, IOSIZE,
  			      _("Scanning dictionary: %s"), (char *)files[i]);
! 	    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  	}
  
  	if (fp != NULL)
***************
*** 3311,3317 ****
      static int
  ins_compl_len()
  {
!     int off = curwin->w_cursor.col - compl_col;
  
      if (off < 0)
  	return 0;
--- 3315,3321 ----
      static int
  ins_compl_len()
  {
!     int off = (int)curwin->w_cursor.col - (int)compl_col;
  
      if (off < 0)
  	return 0;
***************
*** 3347,3353 ****
  
      vim_free(compl_leader);
      compl_leader = vim_strnsave(ml_get_curline() + compl_col,
! 					    curwin->w_cursor.col - compl_col);
      if (compl_leader != NULL)
  	ins_compl_new_leader();
  }
--- 3351,3357 ----
  
      vim_free(compl_leader);
      compl_leader = vim_strnsave(ml_get_curline() + compl_col,
! 				     (int)(curwin->w_cursor.col - compl_col));
      if (compl_leader != NULL)
  	ins_compl_new_leader();
  }
***************
*** 3395,3401 ****
  ins_compl_addfrommatch()
  {
      char_u	*p;
!     int		len = curwin->w_cursor.col - compl_col;
      int		c;
      compl_T	*cp;
  
--- 3399,3405 ----
  ins_compl_addfrommatch()
  {
      char_u	*p;
!     int		len = (int)curwin->w_cursor.col - (int)compl_col;
      int		c;
      compl_T	*cp;
  
***************
*** 3961,3967 ****
  			    : ins_buf->b_sfname == NULL
  				? (char *)ins_buf->b_fname
  				: (char *)ins_buf->b_sfname);
! 		msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  	    }
  	    else if (*e_cpt == NUL)
  		break;
--- 3965,3971 ----
  			    : ins_buf->b_sfname == NULL
  				? (char *)ins_buf->b_fname
  				: (char *)ins_buf->b_sfname);
! 		(void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  	    }
  	    else if (*e_cpt == NUL)
  		break;
***************
*** 3991,3997 ****
  		{
  		    type = CTRL_X_TAGS;
  		    sprintf((char*)IObuff, _("Scanning tags."));
! 		    msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  		}
  		else
  		    type = -1;
--- 3995,4001 ----
  		{
  		    type = CTRL_X_TAGS;
  		    sprintf((char*)IObuff, _("Scanning tags."));
! 		    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  		}
  		else
  		    type = -1;
***************
*** 6320,6326 ****
  	    ins_need_undo = FALSE;
  	}
  	Insstart = curwin->w_cursor;	/* new insertion starts here */
! 	Insstart_textlen = linetabsize(ml_get_curline());
  	ai_col = 0;
  #ifdef FEAT_VREPLACE
  	if (State & VREPLACE_FLAG)
--- 6324,6330 ----
  	    ins_need_undo = FALSE;
  	}
  	Insstart = curwin->w_cursor;	/* new insertion starts here */
! 	Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
  	ai_col = 0;
  #ifdef FEAT_VREPLACE
  	if (State & VREPLACE_FLAG)
*** ../vim-7.2.166/src/ex_cmds.c	2009-04-29 18:44:38.000000000 +0200
--- src/ex_cmds.c	2009-05-05 17:55:40.000000000 +0200
***************
*** 1789,1795 ****
  	 * overwrite a user's viminfo file after a "su root", with a
  	 * viminfo file that the user can't read.
  	 */
! 	st_old.st_dev = 0;
  	st_old.st_ino = 0;
  	st_old.st_mode = 0600;
  	if (mch_stat((char *)fname, &st_old) == 0
--- 1789,1795 ----
  	 * overwrite a user's viminfo file after a "su root", with a
  	 * viminfo file that the user can't read.
  	 */
! 	st_old.st_dev = (dev_t)0;
  	st_old.st_ino = 0;
  	st_old.st_mode = 0600;
  	if (mch_stat((char *)fname, &st_old) == 0
***************
*** 3715,3721 ****
      /* If the window options were changed may need to set the spell language.
       * Can only do this after the buffer has been properly setup. */
      if (did_get_winopts && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
! 	did_set_spelllang(curbuf);
  #endif
  
      if (command == NULL)
--- 3715,3721 ----
      /* If the window options were changed may need to set the spell language.
       * Can only do this after the buffer has been properly setup. */
      if (did_get_winopts && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
! 	(void)did_set_spelllang(curbuf);
  #endif
  
      if (command == NULL)
***************
*** 3788,3794 ****
  
  #ifdef FEAT_KEYMAP
      if (curbuf->b_kmap_state & KEYMAP_INIT)
! 	keymap_init();
  #endif
  
      --RedrawingDisabled;
--- 3788,3794 ----
  
  #ifdef FEAT_KEYMAP
      if (curbuf->b_kmap_state & KEYMAP_INIT)
! 	(void)keymap_init();
  #endif
  
      --RedrawingDisabled;
*** ../vim-7.2.166/src/globals.h	2009-03-05 03:13:51.000000000 +0100
--- src/globals.h	2009-05-09 21:14:49.000000000 +0200
***************
*** 524,530 ****
  EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
  # define W_NEXT(wp) ((wp)->w_next)
  # define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
! #define FOR_ALL_TAB_WINDOWS(tp, wp) \
      for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next) \
  	for ((wp) = ((tp) == curtab) \
  		? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)
--- 524,530 ----
  EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
  # define W_NEXT(wp) ((wp)->w_next)
  # define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
! # define FOR_ALL_TAB_WINDOWS(tp, wp) \
      for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next) \
  	for ((wp) = ((tp) == curtab) \
  		? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)
***************
*** 718,724 ****
  
  EXTERN pos_T	saved_cursor		/* w_cursor before formatting text. */
  # ifdef DO_INIT
! 	= INIT_POS_T
  # endif
  	;
  
--- 718,724 ----
  
  EXTERN pos_T	saved_cursor		/* w_cursor before formatting text. */
  # ifdef DO_INIT
! 	= INIT_POS_T(0, 0, 0)
  # endif
  	;
  
***************
*** 1039,1045 ****
  EXTERN int	did_cursorhold INIT(= FALSE); /* set when CursorHold t'gerd */
  EXTERN pos_T	last_cursormoved	    /* for CursorMoved event */
  # ifdef DO_INIT
! 			= INIT_POS_T
  # endif
  			;
  #endif
--- 1039,1045 ----
  EXTERN int	did_cursorhold INIT(= FALSE); /* set when CursorHold t'gerd */
  EXTERN pos_T	last_cursormoved	    /* for CursorMoved event */
  # ifdef DO_INIT
! 			= INIT_POS_T(0, 0, 0)
  # endif
  			;
  #endif
*** ../vim-7.2.166/src/ops.c	2009-04-29 17:39:17.000000000 +0200
--- src/ops.c	2009-05-13 12:41:02.000000000 +0200
***************
*** 6400,6406 ****
  	    {
  		getvcols(curwin, &min_pos, &max_pos, &min_pos.col,
  								&max_pos.col);
! 		sprintf((char *)buf1, _("%ld Cols; "),
  			(long)(oparg.end_vcol - oparg.start_vcol + 1));
  	    }
  	    else
--- 6400,6406 ----
  	    {
  		getvcols(curwin, &min_pos, &max_pos, &min_pos.col,
  								&max_pos.col);
! 		vim_snprintf((char *)buf1, sizeof(buf1), _("%ld Cols; "),
  			(long)(oparg.end_vcol - oparg.start_vcol + 1));
  	    }
  	    else
***************
*** 6408,6420 ****
  
  	    if (char_count_cursor == byte_count_cursor
  						  && char_count == byte_count)
! 		sprintf((char *)IObuff, _("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
  			buf1, line_count_selected,
  			(long)curbuf->b_ml.ml_line_count,
  			word_count_cursor, word_count,
  			byte_count_cursor, byte_count);
  	    else
! 		sprintf((char *)IObuff, _("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
  			buf1, line_count_selected,
  			(long)curbuf->b_ml.ml_line_count,
  			word_count_cursor, word_count,
--- 6408,6422 ----
  
  	    if (char_count_cursor == byte_count_cursor
  						  && char_count == byte_count)
! 		vim_snprintf((char *)IObuff, IOSIZE,
! 			_("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
  			buf1, line_count_selected,
  			(long)curbuf->b_ml.ml_line_count,
  			word_count_cursor, word_count,
  			byte_count_cursor, byte_count);
  	    else
! 		vim_snprintf((char *)IObuff, IOSIZE,
! 			_("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
  			buf1, line_count_selected,
  			(long)curbuf->b_ml.ml_line_count,
  			word_count_cursor, word_count,
***************
*** 6426,6445 ****
  	{
  	    p = ml_get_curline();
  	    validate_virtcol();
! 	    col_print(buf1, (int)curwin->w_cursor.col + 1,
  		    (int)curwin->w_virtcol + 1);
! 	    col_print(buf2, (int)STRLEN(p), linetabsize(p));
  
  	    if (char_count_cursor == byte_count_cursor
  		    && char_count == byte_count)
! 		sprintf((char *)IObuff, _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
  		    (char *)buf1, (char *)buf2,
  		    (long)curwin->w_cursor.lnum,
  		    (long)curbuf->b_ml.ml_line_count,
  		    word_count_cursor, word_count,
  		    byte_count_cursor, byte_count);
  	    else
! 		sprintf((char *)IObuff, _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
  		    (char *)buf1, (char *)buf2,
  		    (long)curwin->w_cursor.lnum,
  		    (long)curbuf->b_ml.ml_line_count,
--- 6428,6449 ----
  	{
  	    p = ml_get_curline();
  	    validate_virtcol();
! 	    col_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,
  		    (int)curwin->w_virtcol + 1);
! 	    col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));
  
  	    if (char_count_cursor == byte_count_cursor
  		    && char_count == byte_count)
! 		vim_snprintf((char *)IObuff, IOSIZE,
! 		    _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
  		    (char *)buf1, (char *)buf2,
  		    (long)curwin->w_cursor.lnum,
  		    (long)curbuf->b_ml.ml_line_count,
  		    word_count_cursor, word_count,
  		    byte_count_cursor, byte_count);
  	    else
! 		vim_snprintf((char *)IObuff, IOSIZE,
! 		    _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
  		    (char *)buf1, (char *)buf2,
  		    (long)curwin->w_cursor.lnum,
  		    (long)curbuf->b_ml.ml_line_count,
*** ../vim-7.2.166/src/os_unix.c	2009-03-02 02:44:54.000000000 +0100
--- src/os_unix.c	2009-05-05 17:35:58.000000000 +0200
***************
*** 199,205 ****
  #endif
  
  #ifndef SIG_ERR
! # define SIG_ERR	((RETSIGTYPE (*)())-1)
  #endif
  
  /* volatile because it is used in signal handler sig_winch(). */
--- 199,207 ----
  #endif
  
  #ifndef SIG_ERR
! # ifndef S_SPLINT_S
! #  define SIG_ERR	((RETSIGTYPE (*)())-1)
! # endif
  #endif
  
  /* volatile because it is used in signal handler sig_winch(). */
***************
*** 441,447 ****
  
  #if defined(HAVE_TOTAL_MEM) || defined(PROTO)
  # ifdef HAVE_SYS_RESOURCE_H
! #  include <sys/resource.h>
  # endif
  # if defined(HAVE_SYS_SYSCTL_H) && defined(HAVE_SYSCTL)
  #  include <sys/sysctl.h>
--- 443,451 ----
  
  #if defined(HAVE_TOTAL_MEM) || defined(PROTO)
  # ifdef HAVE_SYS_RESOURCE_H
! #  ifndef S_SPLINT_S  /* splint crashes on bits/resource.h */
! #   include <sys/resource.h>
! #  endif
  # endif
  # if defined(HAVE_SYS_SYSCTL_H) && defined(HAVE_SYSCTL)
  #  include <sys/sysctl.h>
*** ../vim-7.2.166/src/os_unix.h	2008-06-20 18:06:36.000000000 +0200
--- src/os_unix.h	2009-05-05 17:07:45.000000000 +0200
***************
*** 53,59 ****
  #endif
  
  #ifdef HAVE_UNISTD_H
! # include <unistd.h>
  #endif
  
  #ifdef HAVE_LIBC_H
--- 53,61 ----
  #endif
  
  #ifdef HAVE_UNISTD_H
! # ifndef S_SPLINT_S  /* splint crashes on bits/confname.h */
! #  include <unistd.h>
! # endif
  #endif
  
  #ifdef HAVE_LIBC_H
*** ../vim-7.2.166/src/proto/buffer.pro	2008-11-15 14:10:23.000000000 +0100
--- src/proto/buffer.pro	2009-05-13 12:23:41.000000000 +0200
***************
*** 37,49 ****
  int otherfile __ARGS((char_u *ffname));
  void buf_setino __ARGS((buf_T *buf));
  void fileinfo __ARGS((int fullname, int shorthelp, int dont_truncate));
! void col_print __ARGS((char_u *buf, int col, int vcol));
  void maketitle __ARGS((void));
  void resettitle __ARGS((void));
  void free_titles __ARGS((void));
  int build_stl_str_hl __ARGS((win_T *wp, char_u *out, size_t outlen, char_u *fmt, int use_sandbox, int fillchar, int maxwidth, struct stl_hlrec *hltab, struct stl_hlrec *tabtab));
! void get_rel_pos __ARGS((win_T *wp, char_u *str));
! int append_arg_number __ARGS((win_T *wp, char_u *buf, int add_file, int maxlen));
  char_u *fix_fname __ARGS((char_u *fname));
  void fname_expand __ARGS((buf_T *buf, char_u **ffname, char_u **sfname));
  char_u *alist_name __ARGS((aentry_T *aep));
--- 37,48 ----
  int otherfile __ARGS((char_u *ffname));
  void buf_setino __ARGS((buf_T *buf));
  void fileinfo __ARGS((int fullname, int shorthelp, int dont_truncate));
! void col_print __ARGS((char_u *buf, size_t buflen, int col, int vcol));
  void maketitle __ARGS((void));
  void resettitle __ARGS((void));
  void free_titles __ARGS((void));
  int build_stl_str_hl __ARGS((win_T *wp, char_u *out, size_t outlen, char_u *fmt, int use_sandbox, int fillchar, int maxwidth, struct stl_hlrec *hltab, struct stl_hlrec *tabtab));
! void get_rel_pos __ARGS((win_T *wp, char_u *buf, int buflen));
  char_u *fix_fname __ARGS((char_u *fname));
  void fname_expand __ARGS((buf_T *buf, char_u **ffname, char_u **sfname));
  char_u *alist_name __ARGS((aentry_T *aep));
***************
*** 54,61 ****
  void write_viminfo_bufferlist __ARGS((FILE *fp));
  char *buf_spname __ARGS((buf_T *buf));
  void buf_addsign __ARGS((buf_T *buf, int id, linenr_T lnum, int typenr));
! int buf_change_sign_type __ARGS((buf_T *buf, int markId, int typenr));
! int_u buf_getsigntype __ARGS((buf_T *buf, linenr_T lnum, int type));
  linenr_T buf_delsign __ARGS((buf_T *buf, int id));
  int buf_findsign __ARGS((buf_T *buf, int id));
  int buf_findsign_id __ARGS((buf_T *buf, linenr_T lnum));
--- 53,60 ----
  void write_viminfo_bufferlist __ARGS((FILE *fp));
  char *buf_spname __ARGS((buf_T *buf));
  void buf_addsign __ARGS((buf_T *buf, int id, linenr_T lnum, int typenr));
! linenr_T buf_change_sign_type __ARGS((buf_T *buf, int markId, int typenr));
! int buf_getsigntype __ARGS((buf_T *buf, linenr_T lnum, int type));
  linenr_T buf_delsign __ARGS((buf_T *buf, int id));
  int buf_findsign __ARGS((buf_T *buf, int id));
  int buf_findsign_id __ARGS((buf_T *buf, linenr_T lnum));
*** ../vim-7.2.166/src/proto/edit.pro	2008-01-16 20:03:13.000000000 +0100
--- src/proto/edit.pro	2009-05-05 20:51:56.000000000 +0200
***************
*** 8,14 ****
  void backspace_until_column __ARGS((int col));
  int vim_is_ctrl_x_key __ARGS((int c));
  int ins_compl_add_infercase __ARGS((char_u *str, int len, int icase, char_u *fname, int dir, int flags));
! void set_completion __ARGS((int startcol, list_T *list));
  void ins_compl_show_pum __ARGS((void));
  char_u *find_word_start __ARGS((char_u *ptr));
  char_u *find_word_end __ARGS((char_u *ptr));
--- 8,14 ----
  void backspace_until_column __ARGS((int col));
  int vim_is_ctrl_x_key __ARGS((int c));
  int ins_compl_add_infercase __ARGS((char_u *str, int len, int icase, char_u *fname, int dir, int flags));
! void set_completion __ARGS((colnr_T startcol, list_T *list));
  void ins_compl_show_pum __ARGS((void));
  char_u *find_word_start __ARGS((char_u *ptr));
  char_u *find_word_end __ARGS((char_u *ptr));
*** ../vim-7.2.166/src/screen.c	2009-03-18 19:07:09.000000000 +0100
--- src/screen.c	2009-05-05 17:42:45.000000000 +0200
***************
*** 9481,9493 ****
      win_T	*wp;
      int		always;
  {
!     char_u	buffer[70];
      int		row;
      int		fillchar;
      int		attr;
      int		empty_line = FALSE;
      colnr_T	virtcol;
      int		i;
      int		o;
  #ifdef FEAT_VERTSPLIT
      int		this_ru_col;
--- 9481,9495 ----
      win_T	*wp;
      int		always;
  {
! #define RULER_BUF_LEN 70
!     char_u	buffer[RULER_BUF_LEN];
      int		row;
      int		fillchar;
      int		attr;
      int		empty_line = FALSE;
      colnr_T	virtcol;
      int		i;
+     size_t	len;
      int		o;
  #ifdef FEAT_VERTSPLIT
      int		this_ru_col;
***************
*** 9602,9612 ****
  	 * Some sprintfs return the length, some return a pointer.
  	 * To avoid portability problems we use strlen() here.
  	 */
! 	sprintf((char *)buffer, "%ld,",
  		(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)
  		    ? 0L
  		    : (long)(wp->w_cursor.lnum));
! 	col_print(buffer + STRLEN(buffer),
  			empty_line ? 0 : (int)wp->w_cursor.col + 1,
  			(int)virtcol + 1);
  
--- 9604,9615 ----
  	 * Some sprintfs return the length, some return a pointer.
  	 * To avoid portability problems we use strlen() here.
  	 */
! 	vim_snprintf((char *)buffer, RULER_BUF_LEN, "%ld,",
  		(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)
  		    ? 0L
  		    : (long)(wp->w_cursor.lnum));
! 	len = STRLEN(buffer);
! 	col_print(buffer + len, RULER_BUF_LEN - len,
  			empty_line ? 0 : (int)wp->w_cursor.col + 1,
  			(int)virtcol + 1);
  
***************
*** 9616,9622 ****
  	 * screen up on some terminals).
  	 */
  	i = (int)STRLEN(buffer);
! 	get_rel_pos(wp, buffer + i + 1);
  	o = i + vim_strsize(buffer + i + 1);
  #ifdef FEAT_WINDOWS
  	if (wp->w_status_height == 0)	/* can't use last char of screen */
--- 9619,9625 ----
  	 * screen up on some terminals).
  	 */
  	i = (int)STRLEN(buffer);
! 	get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);
  	o = i + vim_strsize(buffer + i + 1);
  #ifdef FEAT_WINDOWS
  	if (wp->w_status_height == 0)	/* can't use last char of screen */
***************
*** 9643,9649 ****
  		    buffer[i++] = fillchar;
  		++o;
  	    }
! 	    get_rel_pos(wp, buffer + i);
  	}
  	/* Truncate at window boundary. */
  #ifdef FEAT_MBYTE
--- 9646,9652 ----
  		    buffer[i++] = fillchar;
  		++o;
  	    }
! 	    get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);
  	}
  	/* Truncate at window boundary. */
  #ifdef FEAT_MBYTE
*** ../vim-7.2.166/src/structs.h	2008-11-15 16:05:30.000000000 +0100
--- src/structs.h	2009-05-05 18:20:36.000000000 +0200
***************
*** 33,41 ****
  } pos_T;
  
  #ifdef FEAT_VIRTUALEDIT
! # define INIT_POS_T {0, 0, 0}
  #else
! # define INIT_POS_T {0, 0}
  #endif
  
  /*
--- 33,41 ----
  } pos_T;
  
  #ifdef FEAT_VIRTUALEDIT
! # define INIT_POS_T(l, c, ca) {l, c, ca}
  #else
! # define INIT_POS_T(l, c, ca) {l, c}
  #endif
  
  /*
***************
*** 1166,1172 ****
      char_u	*b_fname;	/* current file name */
  
  #ifdef UNIX
!     int		b_dev;		/* device number (-1 if not set) */
      ino_t	b_ino;		/* inode number */
  #endif
  #ifdef FEAT_CW_EDITOR
--- 1166,1172 ----
      char_u	*b_fname;	/* current file name */
  
  #ifdef UNIX
!     dev_t	b_dev;		/* device number (-1 if not set) */
      ino_t	b_ino;		/* inode number */
  #endif
  #ifdef FEAT_CW_EDITOR
***************
*** 1645,1651 ****
--- 1645,1655 ----
  #endif
  #ifdef FEAT_DIFF
      diff_T	    *tp_first_diff;
+ # ifdef S_SPLINT_S  /* splint doesn't understand the array of pointers */
+     buf_T	    **tp_diffbuf;
+ # else
      buf_T	    *(tp_diffbuf[DB_COUNT]);
+ # endif
      int		    tp_diff_invalid;	/* list of diffs is outdated */
  #endif
      frame_T	    *tp_snapshot;    /* window layout snapshot */
*** ../vim-7.2.166/src/version.c	2009-04-29 18:44:38.000000000 +0200
--- src/version.c	2009-05-13 12:06:36.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     167,
  /**/

-- 
Snoring is prohibited unless all bedroom windows are closed and securely
locked.
		[real standing law in Massachusetts, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.168
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.168
Problem:    When no ctags program can be found, "make tags" attempts to
	    execute the first C file.
Solution:   Default to "ctags" when no ctags program can be found.
Files:	    src/configure.in, src/auto/configure


*** ../vim-7.2.167/src/configure.in	2009-04-22 17:50:53.000000000 +0200
--- src/configure.in	2009-05-05 17:46:45.000000000 +0200
***************
*** 2968,2974 ****
  dnl Link with xpg4, it is said to make Korean locale working
  AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
  
! dnl Check how we can run ctags
  dnl --version for Exuberant ctags (preferred)
  dnl       Add --fields=+S to get function signatures for omni completion.
  dnl -t for typedefs (many ctags have this)
--- 2968,2974 ----
  dnl Link with xpg4, it is said to make Korean locale working
  AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
  
! dnl Check how we can run ctags.  Default to "ctags" when nothing works.
  dnl --version for Exuberant ctags (preferred)
  dnl       Add --fields=+S to get function signatures for omni completion.
  dnl -t for typedefs (many ctags have this)
***************
*** 2980,2985 ****
--- 2980,2986 ----
  if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
    TAGPRG="ctags -I INIT+ --fields=+S"
  else
+   TAGPRG="ctags"
    (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
    (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
    (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
*** ../vim-7.2.167/src/auto/configure	2009-04-22 17:50:53.000000000 +0200
--- src/auto/configure	2009-05-13 14:38:10.000000000 +0200
***************
*** 15707,15712 ****
--- 15723,15729 ----
  if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
    TAGPRG="ctags -I INIT+ --fields=+S"
  else
+   TAGPRG="ctags"
    (eval etags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags"
    (eval etags -c   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags -c"
    (eval ctags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags"
*** ../vim-7.2.167/src/version.c	2009-05-13 12:46:36.000000000 +0200
--- src/version.c	2009-05-13 14:46:35.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     168,
  /**/

-- 
Zen Microsystems: we're the om in .commmmmmmmm

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.169
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.169
Problem:    Splint complains about a lot of things.
Solution:   Add type casts, #ifdefs and other changes to avoid warnings.
	    Change colnr_T from unsigned to int.  Avoids mistakes with
	    subtracting columns.
Files:	    src/cleanlint.vim, src/diff.c, src/edit.c, src/ex_cmds.c,
	    src/ex_cmds2.c, src/ex_docmd.c, src/proto/ex_cmds.pro,
	    src/proto/spell.pro, src/quickfix.c, src/spell.c, src/structs.h,
	    src/term.h, src/vim.h


*** ../vim-7.2.168/src/cleanlint.vim	2009-05-13 12:46:36.000000000 +0200
--- src/cleanlint.vim	2009-05-13 18:03:11.000000000 +0200
***************
*** 1,27 ****
  " Vim tool: Filter output of splint
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2009 May 05
  
  " Usage: redirect output of "make lint" to a file, edit that file with Vim and
  " :call CleanLint()
  " This deletes irrelevant messages.  What remains might be valid warnings.
  
  fun! CleanLint()
-   g/^  Types are incompatible/lockmarks d
    g/Assignment of dev_t to __dev_t:/lockmarks d
    g/Assignment of __dev_t to dev_t:/lockmarks d
    g/Operands of == have incompatible types (__dev_t, dev_t): /lockmarks d
!   g/Operands of == have incompatible types (unsigned int, int): /lockmarks d
    g/Assignment of char to char_u: /lockmarks d
    g/Assignment of unsigned int to int: /lockmarks d
!   g/Assignment of colnr_T to int: /lockmarks d
    g/Assignment of int to char_u: /lockmarks d
    g/Function .* expects arg . to be wint_t gets int: /lockmarks d
!   g/^digraph.c.*digraphdefault.*is type char, expects char_u:/lockmarks d
    g/^digraph.c.*Additional initialization errors for digraphdefault not reported/lockmarks d
    g/Function strncasecmp expects arg 3 to be int gets size_t: /lockmarks d
    g/ To ignore signs in type comparisons use +ignoresigns/lockmarks d
    g/ To allow arbitrary integral types to match any integral type, use +matchanyintegral./lockmarks d
    g/ To allow arbitrary integral types to match long unsigned, use +longintegral./lockmarks d
  endfun
--- 1,32 ----
  " Vim tool: Filter output of splint
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2009 May 13
  
  " Usage: redirect output of "make lint" to a file, edit that file with Vim and
  " :call CleanLint()
  " This deletes irrelevant messages.  What remains might be valid warnings.
  
  fun! CleanLint()
    g/Assignment of dev_t to __dev_t:/lockmarks d
    g/Assignment of __dev_t to dev_t:/lockmarks d
    g/Operands of == have incompatible types (__dev_t, dev_t): /lockmarks d
!   g/Operands of == have incompatible types (char_u, int): /lockmarks d
    g/Assignment of char to char_u: /lockmarks d
    g/Assignment of unsigned int to int: /lockmarks d
!   g/Assignment of int to unsigned int: /lockmarks d
!   g/Assignment of unsigned int to long int: /lockmarks d
    g/Assignment of int to char_u: /lockmarks d
    g/Function .* expects arg . to be wint_t gets int: /lockmarks d
!   g/Function .* expects arg . to be size_t gets int: /lockmarks d
!   g/Initial value of .* is type char, expects char_u: /lockmarks d
!   g/^ex_cmds.h:.* Function types are inconsistent. Parameter 1 is implicitly temp, but unqualified in assigned function:/lockmarks d
!   g/^ex_docmd.c:.* nospec_str/lockmarks d
    g/^digraph.c.*Additional initialization errors for digraphdefault not reported/lockmarks d
    g/Function strncasecmp expects arg 3 to be int gets size_t: /lockmarks d
+   g/^  Types are incompatible/lockmarks d
    g/ To ignore signs in type comparisons use +ignoresigns/lockmarks d
    g/ To allow arbitrary integral types to match any integral type, use +matchanyintegral./lockmarks d
    g/ To allow arbitrary integral types to match long unsigned, use +longintegral./lockmarks d
+   g+ A variable is declared but never used. Use /.@unused@./ in front of declaration to suppress message.+lockmarks d
  endfun
*** ../vim-7.2.168/src/diff.c	2009-03-11 12:45:44.000000000 +0100
--- src/diff.c	2009-05-13 16:16:11.000000000 +0200
***************
*** 827,832 ****
--- 827,833 ----
      char_u	*tmp_diff;
  {
      char_u	*cmd;
+     size_t	len;
  
  #ifdef FEAT_EVAL
      if (*p_dex != NUL)
***************
*** 835,842 ****
      else
  #endif
      {
! 	cmd = alloc((unsigned)(STRLEN(tmp_orig) + STRLEN(tmp_new)
! 				+ STRLEN(tmp_diff) + STRLEN(p_srr) + 27));
  	if (cmd != NULL)
  	{
  	    /* We don't want $DIFF_OPTIONS to get in the way. */
--- 836,844 ----
      else
  #endif
      {
! 	len = STRLEN(tmp_orig) + STRLEN(tmp_new)
! 				      + STRLEN(tmp_diff) + STRLEN(p_srr) + 27;
! 	cmd = alloc((unsigned)len);
  	if (cmd != NULL)
  	{
  	    /* We don't want $DIFF_OPTIONS to get in the way. */
***************
*** 846,852 ****
  	    /* Build the diff command and execute it.  Always use -a, binary
  	     * differences are of no use.  Ignore errors, diff returns
  	     * non-zero when differences have been found. */
! 	    sprintf((char *)cmd, "diff %s%s%s%s%s %s",
  		    diff_a_works == FALSE ? "" : "-a ",
  #if defined(MSWIN) || defined(MSDOS)
  		    diff_bin_works == TRUE ? "--binary " : "",
--- 848,854 ----
  	    /* Build the diff command and execute it.  Always use -a, binary
  	     * differences are of no use.  Ignore errors, diff returns
  	     * non-zero when differences have been found. */
! 	    vim_snprintf((char *)cmd, len, "diff %s%s%s%s%s %s",
  		    diff_a_works == FALSE ? "" : "-a ",
  #if defined(MSWIN) || defined(MSDOS)
  		    diff_bin_works == TRUE ? "--binary " : "",
***************
*** 856,862 ****
  		    (diff_flags & DIFF_IWHITE) ? "-b " : "",
  		    (diff_flags & DIFF_ICASE) ? "-i " : "",
  		    tmp_orig, tmp_new);
! 	    append_redir(cmd, p_srr, tmp_diff);
  #ifdef FEAT_AUTOCMD
  	    block_autocmds();	/* Avoid ShellCmdPost stuff */
  #endif
--- 858,864 ----
  		    (diff_flags & DIFF_IWHITE) ? "-b " : "",
  		    (diff_flags & DIFF_ICASE) ? "-i " : "",
  		    tmp_orig, tmp_new);
! 	    append_redir(cmd, (int)len, p_srr, tmp_diff);
  #ifdef FEAT_AUTOCMD
  	    block_autocmds();	/* Avoid ShellCmdPost stuff */
  #endif
***************
*** 881,886 ****
--- 883,889 ----
      char_u	*tmp_orig;	/* name of original temp file */
      char_u	*tmp_new;	/* name of patched temp file */
      char_u	*buf = NULL;
+     size_t	buflen;
      win_T	*old_curwin = curwin;
      char_u	*newname = NULL;	/* name of patched file buffer */
  #ifdef UNIX
***************
*** 920,930 ****
      /* Get the absolute path of the patchfile, changing directory below. */
      fullname = FullName_save(eap->arg, FALSE);
  #endif
!     buf = alloc((unsigned)(STRLEN(tmp_orig) + (
  # ifdef UNIX
  		    fullname != NULL ? STRLEN(fullname) :
  # endif
! 		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16));
      if (buf == NULL)
  	goto theend;
  
--- 923,934 ----
      /* Get the absolute path of the patchfile, changing directory below. */
      fullname = FullName_save(eap->arg, FALSE);
  #endif
!     buflen = STRLEN(tmp_orig) + (
  # ifdef UNIX
  		    fullname != NULL ? STRLEN(fullname) :
  # endif
! 		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16;
!     buf = alloc((unsigned)buflen);
      if (buf == NULL)
  	goto theend;
  
***************
*** 961,967 ****
      {
  	/* Build the patch command and execute it.  Ignore errors.  Switch to
  	 * cooked mode to allow the user to respond to prompts. */
! 	sprintf((char *)buf, "patch -o %s %s < \"%s\"", tmp_new, tmp_orig,
  # ifdef UNIX
  		fullname != NULL ? fullname :
  # endif
--- 965,972 ----
      {
  	/* Build the patch command and execute it.  Ignore errors.  Switch to
  	 * cooked mode to allow the user to respond to prompts. */
! 	vim_snprintf((char *)buf, buflen, "patch -o %s %s < \"%s\"",
! 		tmp_new, tmp_orig,
  # ifdef UNIX
  		fullname != NULL ? fullname :
  # endif
*** ../vim-7.2.168/src/edit.c	2009-05-13 12:46:36.000000000 +0200
--- src/edit.c	2009-05-13 18:29:21.000000000 +0200
***************
*** 169,175 ****
  static int  ins_compl_key2count __ARGS((int c));
  static int  ins_compl_use_match __ARGS((int c));
  static int  ins_complete __ARGS((int c));
! static int  quote_meta __ARGS((char_u *dest, char_u *str, int len));
  #endif /* FEAT_INS_EXPAND */
  
  #define BACKSPACE_CHAR		    1
--- 169,175 ----
  static int  ins_compl_key2count __ARGS((int c));
  static int  ins_compl_use_match __ARGS((int c));
  static int  ins_complete __ARGS((int c));
! static unsigned  quote_meta __ARGS((char_u *dest, char_u *str, int len));
  #endif /* FEAT_INS_EXPAND */
  
  #define BACKSPACE_CHAR		    1
***************
*** 757,763 ****
  		 * there is nothing to add, CTRL-L works like CTRL-P then. */
  		if (c == Ctrl_L
  			&& (ctrl_x_mode != CTRL_X_WHOLE_LINE
! 			    || STRLEN(compl_shown_match->cp_str)
  					  > curwin->w_cursor.col - compl_col))
  		{
  		    ins_compl_addfrommatch();
--- 757,763 ----
  		 * there is nothing to add, CTRL-L works like CTRL-P then. */
  		if (c == Ctrl_L
  			&& (ctrl_x_mode != CTRL_X_WHOLE_LINE
! 			    || (int)STRLEN(compl_shown_match->cp_str)
  					  > curwin->w_cursor.col - compl_col))
  		{
  		    ins_compl_addfrommatch();
***************
*** 3837,3843 ****
--- 3837,3847 ----
      char_u	*word;
      int		icase = FALSE;
      int		adup = FALSE;
+ #ifdef S_SPLINT_S  /* splint doesn't parse array of pointers correctly */
+     char_u	**cptext;
+ #else
      char_u	*(cptext[CPT_COUNT]);
+ #endif
  
      if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)
      {
***************
*** 3994,4000 ****
  		else if (*e_cpt == ']' || *e_cpt == 't')
  		{
  		    type = CTRL_X_TAGS;
! 		    sprintf((char*)IObuff, _("Scanning tags."));
  		    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  		}
  		else
--- 3998,4004 ----
  		else if (*e_cpt == ']' || *e_cpt == 't')
  		{
  		    type = CTRL_X_TAGS;
! 		    vim_snprintf((char *)IObuff, IOSIZE, _("Scanning tags."));
  		    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  		}
  		else
***************
*** 4093,4099 ****
  	case CTRL_X_SPELL:
  #ifdef FEAT_SPELL
  	    num_matches = expand_spelling(first_match_pos.lnum,
! 				 first_match_pos.col, compl_pattern, &matches);
  	    if (num_matches > 0)
  		ins_compl_add_matches(num_matches, matches, p_ic);
  #endif
--- 4097,4103 ----
  	case CTRL_X_SPELL:
  #ifdef FEAT_SPELL
  	    num_matches = expand_spelling(first_match_pos.lnum,
! 						     compl_pattern, &matches);
  	    if (num_matches > 0)
  		ins_compl_add_matches(num_matches, matches, p_ic);
  #endif
***************
*** 4803,4812 ****
  	    {
  		char_u	    *prefix = (char_u *)"\\<";
  
! 		/* we need 3 extra chars, 1 for the NUL and
! 		 * 2 >= strlen(prefix)	-- Acevedo */
  		compl_pattern = alloc(quote_meta(NULL, line + compl_col,
! 							   compl_length) + 3);
  		if (compl_pattern == NULL)
  		    return FAIL;
  		if (!vim_iswordp(line + compl_col)
--- 4807,4815 ----
  	    {
  		char_u	    *prefix = (char_u *)"\\<";
  
! 		/* we need up to 2 extra chars for the prefix */
  		compl_pattern = alloc(quote_meta(NULL, line + compl_col,
! 							   compl_length) + 2);
  		if (compl_pattern == NULL)
  		    return FAIL;
  		if (!vim_iswordp(line + compl_col)
***************
*** 4881,4887 ****
  		else
  		{
  		    compl_pattern = alloc(quote_meta(NULL, line + compl_col,
! 							   compl_length) + 3);
  		    if (compl_pattern == NULL)
  			return FAIL;
  		    STRCPY((char *)compl_pattern, "\\<");
--- 4884,4890 ----
  		else
  		{
  		    compl_pattern = alloc(quote_meta(NULL, line + compl_col,
! 							   compl_length) + 2);
  		    if (compl_pattern == NULL)
  			return FAIL;
  		    STRCPY((char *)compl_pattern, "\\<");
***************
*** 4963,4969 ****
  	    if (col < 0)
  		col = curs_col;
  	    compl_col = col;
! 	    if ((colnr_T)compl_col > curs_col)
  		compl_col = curs_col;
  
  	    /* Setup variables for completion.  Need to obtain "line" again,
--- 4966,4972 ----
  	    if (col < 0)
  		col = curs_col;
  	    compl_col = col;
! 	    if (compl_col > curs_col)
  		compl_col = curs_col;
  
  	    /* Setup variables for completion.  Need to obtain "line" again,
***************
*** 5236,5250 ****
   * a backslash) the metachars, and dest would be NUL terminated.
   * Returns the length (needed) of dest
   */
!     static int
  quote_meta(dest, src, len)
      char_u	*dest;
      char_u	*src;
      int		len;
  {
!     int	m;
  
!     for (m = len; --len >= 0; src++)
      {
  	switch (*src)
  	{
--- 5239,5253 ----
   * a backslash) the metachars, and dest would be NUL terminated.
   * Returns the length (needed) of dest
   */
!     static unsigned
  quote_meta(dest, src, len)
      char_u	*dest;
      char_u	*src;
      int		len;
  {
!     unsigned	m = (unsigned)len + 1;  /* one extra for the NUL */
  
!     for ( ; --len >= 0; src++)
      {
  	switch (*src)
  	{
***************
*** 6073,6079 ****
       * in 'formatoptions' and there is a single character before the cursor.
       * Otherwise the line would be broken and when typing another non-white
       * next they are not joined back together. */
!     wasatend = (pos.col == STRLEN(old));
      if (*old != NUL && !trailblank && wasatend)
      {
  	dec_cursor();
--- 6076,6082 ----
       * in 'formatoptions' and there is a single character before the cursor.
       * Otherwise the line would be broken and when typing another non-white
       * next they are not joined back together. */
!     wasatend = (pos.col == (colnr_T)STRLEN(old));
      if (*old != NUL && !trailblank && wasatend)
      {
  	dec_cursor();
***************
*** 6250,6256 ****
       * three digits. */
      if (VIM_ISDIGIT(c))
      {
! 	sprintf((char *)buf, "%03d", c);
  	AppendToRedobuff(buf);
      }
      else
--- 6253,6259 ----
       * three digits. */
      if (VIM_ISDIGIT(c))
      {
! 	vim_snprintf((char *)buf, sizeof(buf), "%03d", c);
  	AppendToRedobuff(buf);
      }
      else
***************
*** 6453,6462 ****
  	     * deleted characters. */
  	    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)
  	    {
! 		cc = (int)STRLEN(ml_get_curline());
! 		if (VIsual.col > (colnr_T)cc)
  		{
! 		    VIsual.col = cc;
  # ifdef FEAT_VIRTUALEDIT
  		    VIsual.coladd = 0;
  # endif
--- 6457,6467 ----
  	     * deleted characters. */
  	    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)
  	    {
! 		int len = (int)STRLEN(ml_get_curline());
! 
! 		if (VIsual.col > len)
  		{
! 		    VIsual.col = len;
  # ifdef FEAT_VIRTUALEDIT
  		    VIsual.coladd = 0;
  # endif
***************
*** 8315,8320 ****
--- 8320,8326 ----
      linenr_T	lnum;
      int		cc;
      int		temp = 0;	    /* init for GCC */
+     colnr_T	save_col;
      colnr_T	mincol;
      int		did_backspace = FALSE;
      int		in_indent;
***************
*** 8472,8484 ****
  		 */
  		while (cc > 0)
  		{
! 		    temp = curwin->w_cursor.col;
  #ifdef FEAT_MBYTE
  		    mb_replace_pop_ins(cc);
  #else
  		    ins_char(cc);
  #endif
! 		    curwin->w_cursor.col = temp;
  		    cc = replace_pop();
  		}
  		/* restore the characters that NL replaced */
--- 8478,8490 ----
  		 */
  		while (cc > 0)
  		{
! 		    save_col = curwin->w_cursor.col;
  #ifdef FEAT_MBYTE
  		    mb_replace_pop_ins(cc);
  #else
  		    ins_char(cc);
  #endif
! 		    curwin->w_cursor.col = save_col;
  		    cc = replace_pop();
  		}
  		/* restore the characters that NL replaced */
***************
*** 8510,8520 ****
  #endif
  			    )
  	{
! 	    temp = curwin->w_cursor.col;
  	    beginline(BL_WHITE);
  	    if (curwin->w_cursor.col < (colnr_T)temp)
  		mincol = curwin->w_cursor.col;
! 	    curwin->w_cursor.col = temp;
  	}
  
  	/*
--- 8516,8526 ----
  #endif
  			    )
  	{
! 	    save_col = curwin->w_cursor.col;
  	    beginline(BL_WHITE);
  	    if (curwin->w_cursor.col < (colnr_T)temp)
  		mincol = curwin->w_cursor.col;
! 	    curwin->w_cursor.col = save_col;
  	}
  
  	/*
*** ../vim-7.2.168/src/ex_cmds.c	2009-05-13 12:46:36.000000000 +0200
--- src/ex_cmds.c	2009-05-13 18:24:18.000000000 +0200
***************
*** 87,99 ****
  			       ))
  	{
  	    transchar_nonprint(buf3, c);
! 	    sprintf(buf1, "  <%s>", (char *)buf3);
  	}
  	else
  	    buf1[0] = NUL;
  #ifndef EBCDIC
  	if (c >= 0x80)
! 	    sprintf(buf2, "  <M-%s>", transchar(c & 0x7f));
  	else
  #endif
  	    buf2[0] = NUL;
--- 87,100 ----
  			       ))
  	{
  	    transchar_nonprint(buf3, c);
! 	    vim_snprintf(buf1, sizeof(buf1), "  <%s>", (char *)buf3);
  	}
  	else
  	    buf1[0] = NUL;
  #ifndef EBCDIC
  	if (c >= 0x80)
! 	    vim_snprintf(buf2, sizeof(buf2), "  <M-%s>",
! 						 (char *)transchar(c & 0x7f));
  	else
  #endif
  	    buf2[0] = NUL;
***************
*** 358,364 ****
      linenr_T	lnum;
      long	maxlen = 0;
      sorti_T	*nrs;
!     size_t	count = eap->line2 - eap->line1 + 1;
      size_t	i;
      char_u	*p;
      char_u	*s;
--- 359,365 ----
      linenr_T	lnum;
      long	maxlen = 0;
      sorti_T	*nrs;
!     size_t	count = (size_t)(eap->line2 - eap->line1 + 1);
      size_t	i;
      char_u	*p;
      char_u	*s;
***************
*** 957,963 ****
  	    }
  	    len += (int)STRLEN(prevcmd);
  	}
! 	if ((t = alloc(len)) == NULL)
  	{
  	    vim_free(newcmd);
  	    return;
--- 958,964 ----
  	    }
  	    len += (int)STRLEN(prevcmd);
  	}
! 	if ((t = alloc((unsigned)len)) == NULL)
  	{
  	    vim_free(newcmd);
  	    return;
***************
*** 1548,1554 ****
       * redirecting input and/or output.
       */
      if (itmp != NULL || otmp != NULL)
! 	sprintf((char *)buf, "(%s)", (char *)cmd);
      else
  	STRCPY(buf, cmd);
      if (itmp != NULL)
--- 1549,1555 ----
       * redirecting input and/or output.
       */
      if (itmp != NULL || otmp != NULL)
! 	vim_snprintf((char *)buf, len, "(%s)", (char *)cmd);
      else
  	STRCPY(buf, cmd);
      if (itmp != NULL)
***************
*** 1597,1633 ****
      }
  #endif
      if (otmp != NULL)
! 	append_redir(buf, p_srr, otmp);
  
      return buf;
  }
  
  /*
!  * Append output redirection for file "fname" to the end of string buffer "buf"
   * Works with the 'shellredir' and 'shellpipe' options.
   * The caller should make sure that there is enough room:
   *	STRLEN(opt) + STRLEN(fname) + 3
   */
      void
! append_redir(buf, opt, fname)
      char_u	*buf;
      char_u	*opt;
      char_u	*fname;
  {
      char_u	*p;
  
!     buf += STRLEN(buf);
      /* find "%s", skipping "%%" */
      for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)
  	if (p[1] == 's')
  	    break;
      if (p != NULL)
      {
! 	*buf = ' '; /* not really needed? Not with sh, ksh or bash */
! 	sprintf((char *)buf + 1, (char *)opt, (char *)fname);
      }
      else
! 	sprintf((char *)buf,
  #ifdef FEAT_QUICKFIX
  # ifndef RISCOS
  		opt != p_sp ? " %s%s" :
--- 1598,1638 ----
      }
  #endif
      if (otmp != NULL)
! 	append_redir(buf, (int)len, p_srr, otmp);
  
      return buf;
  }
  
  /*
!  * Append output redirection for file "fname" to the end of string buffer
!  * "buf[buflen]"
   * Works with the 'shellredir' and 'shellpipe' options.
   * The caller should make sure that there is enough room:
   *	STRLEN(opt) + STRLEN(fname) + 3
   */
      void
! append_redir(buf, buflen, opt, fname)
      char_u	*buf;
+     int		buflen;
      char_u	*opt;
      char_u	*fname;
  {
      char_u	*p;
+     char_u	*end;
  
!     end = buf + STRLEN(buf);
      /* find "%s", skipping "%%" */
      for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)
  	if (p[1] == 's')
  	    break;
      if (p != NULL)
      {
! 	*end = ' '; /* not really needed? Not with sh, ksh or bash */
! 	vim_snprintf((char *)end + 1, (size_t)(buflen - (end + 1 - buf)),
! 						  (char *)opt, (char *)fname);
      }
      else
! 	vim_snprintf((char *)end, (size_t)(buflen - (end - buf)),
  #ifdef FEAT_QUICKFIX
  # ifndef RISCOS
  		opt != p_sp ? " %s%s" :
***************
*** 2390,2396 ****
  
      if (curwin->w_p_nu || use_number)
      {
! 	sprintf((char *)numbuf, "%*ld ", number_width(curwin), (long)lnum);
  	msg_puts_attr(numbuf, hl_attr(HLF_N));	/* Highlight line nrs */
      }
      msg_prt_line(ml_get(lnum), list);
--- 2395,2402 ----
  
      if (curwin->w_p_nu || use_number)
      {
! 	vim_snprintf((char *)numbuf, sizeof(numbuf),
! 				   "%*ld ", number_width(curwin), (long)lnum);
  	msg_puts_attr(numbuf, hl_attr(HLF_N));	/* Highlight line nrs */
      }
      msg_prt_line(ml_get(lnum), list);
***************
*** 4486,4492 ****
  	    char_u	*p1;
  	    int		did_sub = FALSE;
  	    int		lastone;
! 	    unsigned	len, needed_len;
  	    long	nmatch_tl = 0;	/* nr of lines matched below lnum */
  	    int		do_again;	/* do it again after joining lines */
  	    int		skip_match = FALSE;
--- 4492,4498 ----
  	    char_u	*p1;
  	    int		did_sub = FALSE;
  	    int		lastone;
! 	    int		len, copy_len, needed_len;
  	    long	nmatch_tl = 0;	/* nr of lines matched below lnum */
  	    int		do_again;	/* do it again after joining lines */
  	    int		skip_match = FALSE;
***************
*** 4631,4636 ****
--- 4637,4644 ----
  
  		if (do_ask)
  		{
+ 		    int typed;
+ 
  		    /* change State to CONFIRM, so that the mouse works
  		     * properly */
  		    save_State = State;
***************
*** 4669,4675 ****
  			    resp = getexmodeline('?', NULL, 0);
  			    if (resp != NULL)
  			    {
! 				i = *resp;
  				vim_free(resp);
  			    }
  			}
--- 4677,4683 ----
  			    resp = getexmodeline('?', NULL, 0);
  			    if (resp != NULL)
  			    {
! 				typed = *resp;
  				vim_free(resp);
  			    }
  			}
***************
*** 4721,4727 ****
  #endif
  			    ++no_mapping;	/* don't map this key */
  			    ++allow_keys;	/* allow special keys */
! 			    i = plain_vgetc();
  			    --allow_keys;
  			    --no_mapping;
  
--- 4729,4735 ----
  #endif
  			    ++no_mapping;	/* don't map this key */
  			    ++allow_keys;	/* allow special keys */
! 			    typed = plain_vgetc();
  			    --allow_keys;
  			    --no_mapping;
  
***************
*** 4732,4766 ****
  			}
  
  			need_wait_return = FALSE; /* no hit-return prompt */
! 			if (i == 'q' || i == ESC || i == Ctrl_C
  #ifdef UNIX
! 				|| i == intr_char
  #endif
  				)
  			{
  			    got_quit = TRUE;
  			    break;
  			}
! 			if (i == 'n')
  			    break;
! 			if (i == 'y')
  			    break;
! 			if (i == 'l')
  			{
  			    /* last: replace and then stop */
  			    do_all = FALSE;
  			    line2 = lnum;
  			    break;
  			}
! 			if (i == 'a')
  			{
  			    do_ask = FALSE;
  			    break;
  			}
  #ifdef FEAT_INS_EXPAND
! 			if (i == Ctrl_E)
  			    scrollup_clamp();
! 			else if (i == Ctrl_Y)
  			    scrolldown_clamp();
  #endif
  		    }
--- 4740,4774 ----
  			}
  
  			need_wait_return = FALSE; /* no hit-return prompt */
! 			if (typed == 'q' || typed == ESC || typed == Ctrl_C
  #ifdef UNIX
! 				|| typed == intr_char
  #endif
  				)
  			{
  			    got_quit = TRUE;
  			    break;
  			}
! 			if (typed == 'n')
  			    break;
! 			if (typed == 'y')
  			    break;
! 			if (typed == 'l')
  			{
  			    /* last: replace and then stop */
  			    do_all = FALSE;
  			    line2 = lnum;
  			    break;
  			}
! 			if (typed == 'a')
  			{
  			    do_ask = FALSE;
  			    break;
  			}
  #ifdef FEAT_INS_EXPAND
! 			if (typed == Ctrl_E)
  			    scrollup_clamp();
! 			else if (typed == Ctrl_Y)
  			    scrolldown_clamp();
  #endif
  		    }
***************
*** 4771,4777 ****
  		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
  			--no_u_sync;
  
! 		    if (i == 'n')
  		    {
  			/* For a multi-line match, put matchcol at the NUL at
  			 * the end of the line and set nmatch to one, so that
--- 4779,4785 ----
  		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
  			--no_u_sync;
  
! 		    if (typed == 'n')
  		    {
  			/* For a multi-line match, put matchcol at the NUL at
  			 * the end of the line and set nmatch to one, so that
***************
*** 4822,4830 ****
  		    p1 = ml_get(sub_firstlnum + nmatch - 1);
  		    nmatch_tl += nmatch - 1;
  		}
! 		i = regmatch.startpos[0].col - copycol;
! 		needed_len = i + ((unsigned)STRLEN(p1) - regmatch.endpos[0].col)
! 								 + sublen + 1;
  		if (new_start == NULL)
  		{
  		    /*
--- 4830,4838 ----
  		    p1 = ml_get(sub_firstlnum + nmatch - 1);
  		    nmatch_tl += nmatch - 1;
  		}
! 		copy_len = regmatch.startpos[0].col - copycol;
! 		needed_len = copy_len + ((unsigned)STRLEN(p1)
! 				       - regmatch.endpos[0].col) + sublen + 1;
  		if (new_start == NULL)
  		{
  		    /*
***************
*** 4847,4853 ****
  		     */
  		    len = (unsigned)STRLEN(new_start);
  		    needed_len += len;
! 		    if (needed_len > new_start_len)
  		    {
  			new_start_len = needed_len + 50;
  			if ((p1 = alloc_check(new_start_len)) == NULL)
--- 4855,4861 ----
  		     */
  		    len = (unsigned)STRLEN(new_start);
  		    needed_len += len;
! 		    if (needed_len > (int)new_start_len)
  		    {
  			new_start_len = needed_len + 50;
  			if ((p1 = alloc_check(new_start_len)) == NULL)
***************
*** 4865,4872 ****
  		/*
  		 * copy the text up to the part that matched
  		 */
! 		mch_memmove(new_end, sub_firstline + copycol, (size_t)i);
! 		new_end += i;
  
  		(void)vim_regsub_multi(&regmatch,
  				    sub_firstlnum - regmatch.startpos[0].lnum,
--- 4873,4880 ----
  		/*
  		 * copy the text up to the part that matched
  		 */
! 		mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);
! 		new_end += copy_len;
  
  		(void)vim_regsub_multi(&regmatch,
  				    sub_firstlnum - regmatch.startpos[0].lnum,
***************
*** 5768,5773 ****
--- 5776,5785 ----
  {
      char_u	*s, *d;
      int		i;
+ #ifdef S_SPLINT_S  /* splint doesn't understand array of pointers */
+     static char **mtable;
+     static char **rtable;
+ #else
      static char *(mtable[]) = {"*", "g*", "[*", "]*", ":*",
  			       "/*", "/\\*", "\"*", "**",
  			       "/\\(\\)",
***************
*** 5782,5787 ****
--- 5794,5800 ----
  			       "/\\\\?", "/\\\\z(\\\\)", "\\\\=", ":s\\\\=",
  			       "\\[count]", "\\[quotex]", "\\[range]",
  			       "\\[pattern]", "\\\\bar", "/\\\\%\\$"};
+ #endif
      int flags;
  
      d = IObuff;		    /* assume IObuff is long enough! */
***************
*** 5790,5796 ****
       * Recognize a few exceptions to the rule.	Some strings that contain '*'
       * with "star".  Otherwise '*' is recognized as a wildcard.
       */
!     for (i = sizeof(mtable) / sizeof(char *); --i >= 0; )
  	if (STRCMP(arg, mtable[i]) == 0)
  	{
  	    STRCPY(d, rtable[i]);
--- 5803,5809 ----
       * Recognize a few exceptions to the rule.	Some strings that contain '*'
       * with "star".  Otherwise '*' is recognized as a wildcard.
       */
!     for (i = (int)(sizeof(mtable) / sizeof(char *)); --i >= 0; )
  	if (STRCMP(arg, mtable[i]) == 0)
  	{
  	    STRCPY(d, rtable[i]);
*** ../vim-7.2.168/src/ex_cmds2.c	2009-02-05 20:47:14.000000000 +0100
--- src/ex_cmds2.c	2009-05-13 16:22:33.000000000 +0200
***************
*** 3373,3379 ****
  	    p = skipwhite(sp->nextline);
  	    if (*p != '\\')
  		break;
! 	    s = alloc((int)(STRLEN(line) + STRLEN(p)));
  	    if (s == NULL)	/* out of memory */
  		break;
  	    STRCPY(s, line);
--- 3373,3379 ----
  	    p = skipwhite(sp->nextline);
  	    if (*p != '\\')
  		break;
! 	    s = alloc((unsigned)(STRLEN(line) + STRLEN(p)));
  	    if (s == NULL)	/* out of memory */
  		break;
  	    STRCPY(s, line);
*** ../vim-7.2.168/src/ex_docmd.c	2009-04-29 18:44:38.000000000 +0200
--- src/ex_docmd.c	2009-05-13 17:56:44.000000000 +0200
***************
*** 2737,2743 ****
      int		i;
  
      for (i = 0; cmd[i] != NUL; ++i)
! 	if (cmd[i] != (*pp)[i])
  	    break;
      if (i >= len && !isalpha((*pp)[i]))
      {
--- 2737,2743 ----
      int		i;
  
      for (i = 0; cmd[i] != NUL; ++i)
! 	if (((char_u *)cmd)[i] != (*pp)[i])
  	    break;
      if (i >= len && !isalpha((*pp)[i]))
      {
***************
*** 2803,2809 ****
  	    /* Check for ":dl", ":dell", etc. to ":deletel": that's
  	     * :delete with the 'l' flag.  Same for 'p'. */
  	    for (i = 0; i < len; ++i)
! 		if (eap->cmd[i] != "delete"[i])
  		    break;
  	    if (i == len - 1)
  	    {
--- 2803,2809 ----
  	    /* Check for ":dl", ":dell", etc. to ":deletel": that's
  	     * :delete with the 'l' flag.  Same for 'p'. */
  	    for (i = 0; i < len; ++i)
! 		if (eap->cmd[i] != ((char_u *)"delete")[i])
  		    break;
  	    if (i == len - 1)
  	    {
***************
*** 3823,3829 ****
      char_u	*cmd;
      int		*ctx;	/* pointer to xp_context or NULL */
  {
!     int		delim;
  
      while (vim_strchr((char_u *)" \t0123456789.$%'/?-+,;", *cmd) != NULL)
      {
--- 3823,3829 ----
      char_u	*cmd;
      int		*ctx;	/* pointer to xp_context or NULL */
  {
!     unsigned	delim;
  
      while (vim_strchr((char_u *)" \t0123456789.$%'/?-+,;", *cmd) != NULL)
      {
***************
*** 9417,9423 ****
  {
      int		len;
      int		i;
!     static char *(spec_str[]) = {
  		    "%",
  #define SPEC_PERC   0
  		    "#",
--- 9417,9429 ----
  {
      int		len;
      int		i;
! #ifdef S_SPLINT_S  /* splint can't handle array of pointers */
!     static char **spec_str;
!     static char *(nospec_str[])
! #else
!     static char *(spec_str[])
! #endif
! 	= {
  		    "%",
  #define SPEC_PERC   0
  		    "#",
***************
*** 9443,9451 ****
  # define SPEC_CLIENT 9
  #endif
      };
- #define SPEC_COUNT  (sizeof(spec_str) / sizeof(char *))
  
!     for (i = 0; i < SPEC_COUNT; ++i)
      {
  	len = (int)STRLEN(spec_str[i]);
  	if (STRNCMP(src, spec_str[i], len) == 0)
--- 9449,9456 ----
  # define SPEC_CLIENT 9
  #endif
      };
  
!     for (i = 0; i < (int)(sizeof(spec_str) / sizeof(char *)); ++i)
      {
  	len = (int)STRLEN(spec_str[i]);
  	if (STRNCMP(src, spec_str[i], len) == 0)
***************
*** 9796,9802 ****
  	}
  
  	/* allocate memory */
! 	retval = alloc(len + 1);
  	if (retval == NULL)
  	    break;
      }
--- 9801,9807 ----
  	}
  
  	/* allocate memory */
! 	retval = alloc((unsigned)len + 1);
  	if (retval == NULL)
  	    break;
      }
*** ../vim-7.2.168/src/proto/ex_cmds.pro	2009-04-29 18:44:38.000000000 +0200
--- src/proto/ex_cmds.pro	2009-05-13 15:53:39.000000000 +0200
***************
*** 9,15 ****
  void do_bang __ARGS((int addr_count, exarg_T *eap, int forceit, int do_in, int do_out));
  void do_shell __ARGS((char_u *cmd, int flags));
  char_u *make_filter_cmd __ARGS((char_u *cmd, char_u *itmp, char_u *otmp));
! void append_redir __ARGS((char_u *buf, char_u *opt, char_u *fname));
  int viminfo_error __ARGS((char *errnum, char *message, char_u *line));
  int read_viminfo __ARGS((char_u *file, int flags));
  void write_viminfo __ARGS((char_u *file, int forceit));
--- 9,15 ----
  void do_bang __ARGS((int addr_count, exarg_T *eap, int forceit, int do_in, int do_out));
  void do_shell __ARGS((char_u *cmd, int flags));
  char_u *make_filter_cmd __ARGS((char_u *cmd, char_u *itmp, char_u *otmp));
! void append_redir __ARGS((char_u *buf, int buflen, char_u *opt, char_u *fname));
  int viminfo_error __ARGS((char *errnum, char *message, char_u *line));
  int read_viminfo __ARGS((char_u *file, int flags));
  void write_viminfo __ARGS((char_u *file, int forceit));
*** ../vim-7.2.168/src/proto/spell.pro	2007-05-05 19:19:19.000000000 +0200
--- src/proto/spell.pro	2009-05-13 16:43:13.000000000 +0200
***************
*** 22,26 ****
  char_u *spell_to_word_end __ARGS((char_u *start, buf_T *buf));
  int spell_word_start __ARGS((int startcol));
  void spell_expand_check_cap __ARGS((colnr_T col));
! int expand_spelling __ARGS((linenr_T lnum, int col, char_u *pat, char_u ***matchp));
  /* vim: set ft=c : */
--- 22,26 ----
  char_u *spell_to_word_end __ARGS((char_u *start, buf_T *buf));
  int spell_word_start __ARGS((int startcol));
  void spell_expand_check_cap __ARGS((colnr_T col));
! int expand_spelling __ARGS((linenr_T lnum, char_u *pat, char_u ***matchp));
  /* vim: set ft=c : */
*** ../vim-7.2.168/src/quickfix.c	2009-04-29 11:49:57.000000000 +0200
--- src/quickfix.c	2009-05-13 15:53:18.000000000 +0200
***************
*** 2774,2780 ****
      sprintf((char *)cmd, "%s%s%s", (char *)p_shq, (char *)eap->arg,
  							       (char *)p_shq);
      if (*p_sp != NUL)
! 	append_redir(cmd, p_sp, fname);
      /*
       * Output a newline if there's something else than the :make command that
       * was typed (in which case the cursor is in column 0).
--- 2774,2780 ----
      sprintf((char *)cmd, "%s%s%s", (char *)p_shq, (char *)eap->arg,
  							       (char *)p_shq);
      if (*p_sp != NUL)
! 	append_redir(cmd, len, p_sp, fname);
      /*
       * Output a newline if there's something else than the :make command that
       * was typed (in which case the cursor is in column 0).
*** ../vim-7.2.168/src/spell.c	2009-02-11 17:57:43.000000000 +0100
--- src/spell.c	2009-05-13 16:31:15.000000000 +0200
***************
*** 16151,16161 ****
   * Returns the number of matches.  The matches are in "matchp[]", array of
   * allocated strings.
   */
- /*ARGSUSED*/
      int
! expand_spelling(lnum, col, pat, matchp)
      linenr_T	lnum;
-     int		col;
      char_u	*pat;
      char_u	***matchp;
  {
--- 16151,16159 ----
   * Returns the number of matches.  The matches are in "matchp[]", array of
   * allocated strings.
   */
      int
! expand_spelling(lnum, pat, matchp)
      linenr_T	lnum;
      char_u	*pat;
      char_u	***matchp;
  {
*** ../vim-7.2.168/src/structs.h	2009-05-13 12:46:36.000000000 +0200
--- src/structs.h	2009-05-13 16:45:51.000000000 +0200
***************
*** 16,22 ****
   */
  #if defined(SASC) && SASC < 658
  typedef long		linenr_T;
! typedef unsigned	colnr_T;
  typedef unsigned short	short_u;
  #endif
  
--- 16,22 ----
   */
  #if defined(SASC) && SASC < 658
  typedef long		linenr_T;
! typedef int		colnr_T;
  typedef unsigned short	short_u;
  #endif
  
*** ../vim-7.2.168/src/term.h	2005-03-16 10:53:56.000000000 +0100
--- src/term.h	2009-05-13 17:27:41.000000000 +0200
***************
*** 96,102 ****
--- 96,106 ----
   * - there should be code in term.c to obtain the value from the termcap
   */
  
+ #ifdef S_SPLINT_S  /* splint doesn't understand array of pointers */
+ extern char_u **term_strings;    /* current terminal strings */
+ #else
  extern char_u *(term_strings[]);    /* current terminal strings */
+ #endif
  
  /*
   * strings used for terminal
*** ../vim-7.2.168/src/vim.h	2009-04-29 18:44:38.000000000 +0200
--- src/vim.h	2009-05-13 16:45:39.000000000 +0200
***************
*** 1460,1467 ****
  # define PERROR(msg)		    perror(msg)
  #endif
  
! typedef long	    linenr_T;		/* line number type */
! typedef unsigned    colnr_T;		/* column number type */
  typedef unsigned short disptick_T;	/* display tick type */
  
  #define MAXLNUM (0x7fffffffL)		/* maximum (invalid) line number */
--- 1460,1467 ----
  # define PERROR(msg)		    perror(msg)
  #endif
  
! typedef long	linenr_T;		/* line number type */
! typedef int	colnr_T;		/* column number type */
  typedef unsigned short disptick_T;	/* display tick type */
  
  #define MAXLNUM (0x7fffffffL)		/* maximum (invalid) line number */
*** ../vim-7.2.168/src/version.c	2009-05-13 14:48:55.000000000 +0200
--- src/version.c	2009-05-13 18:44:28.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     169,
  /**/

-- 
Females are strictly forbidden to appear unshaven in public.
		[real standing law in New Mexico, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.170
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.170
Problem:    Using b_dev while it was not set. (Dominique Pelle)
Solution:   Add the b_dev_valid flag.
Files:	    src/buffer.c, src/fileio.c, src/structs.h


*** ../vim-7.2.169/src/buffer.c	2009-05-13 12:46:36.000000000 +0200
--- src/buffer.c	2009-05-13 20:23:51.000000000 +0200
***************
*** 1678,1686 ****
      buf->b_fname = buf->b_sfname;
  #ifdef UNIX
      if (st.st_dev == (dev_T)-1)
! 	buf->b_dev = -1;
      else
      {
  	buf->b_dev = st.st_dev;
  	buf->b_ino = st.st_ino;
      }
--- 1678,1687 ----
      buf->b_fname = buf->b_sfname;
  #ifdef UNIX
      if (st.st_dev == (dev_T)-1)
! 	buf->b_dev_valid = FALSE;
      else
      {
+ 	buf->b_dev_valid = TRUE;
  	buf->b_dev = st.st_dev;
  	buf->b_ino = st.st_ino;
      }
***************
*** 2693,2701 ****
      buf->b_fname = buf->b_sfname;
  #ifdef UNIX
      if (st.st_dev == (dev_T)-1)
! 	buf->b_dev = -1;
      else
      {
  	buf->b_dev = st.st_dev;
  	buf->b_ino = st.st_ino;
      }
--- 2694,2703 ----
      buf->b_fname = buf->b_sfname;
  #ifdef UNIX
      if (st.st_dev == (dev_T)-1)
! 	buf->b_dev_valid = FALSE;
      else
      {
+ 	buf->b_dev_valid = TRUE;
  	buf->b_dev = st.st_dev;
  	buf->b_ino = st.st_ino;
      }
***************
*** 2889,2895 ****
  	/* If no struct stat given, get it now */
  	if (stp == NULL)
  	{
! 	    if (buf->b_dev < 0 || mch_stat((char *)ffname, &st) < 0)
  		st.st_dev = (dev_T)-1;
  	    stp = &st;
  	}
--- 2891,2897 ----
  	/* If no struct stat given, get it now */
  	if (stp == NULL)
  	{
! 	    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)
  		st.st_dev = (dev_T)-1;
  	    stp = &st;
  	}
***************
*** 2926,2936 ****
  
      if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)
      {
  	buf->b_dev = st.st_dev;
  	buf->b_ino = st.st_ino;
      }
      else
! 	buf->b_dev = -1;
  }
  
  /*
--- 2928,2939 ----
  
      if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)
      {
+ 	buf->b_dev_valid = TRUE;
  	buf->b_dev = st.st_dev;
  	buf->b_ino = st.st_ino;
      }
      else
! 	buf->b_dev_valid = FALSE;
  }
  
  /*
***************
*** 2941,2947 ****
      buf_T	*buf;
      struct stat *stp;
  {
!     return (buf->b_dev >= 0
  	    && stp->st_dev == buf->b_dev
  	    && stp->st_ino == buf->b_ino);
  }
--- 2944,2950 ----
      buf_T	*buf;
      struct stat *stp;
  {
!     return (buf->b_dev_valid
  	    && stp->st_dev == buf->b_dev
  	    && stp->st_ino == buf->b_ino);
  }
*** ../vim-7.2.169/src/fileio.c	2009-04-29 18:01:23.000000000 +0200
--- src/fileio.c	2009-05-13 20:24:08.000000000 +0200
***************
*** 4416,4422 ****
  # endif
  	buf_setino(buf);
      }
!     else if (buf->b_dev < 0)
  	/* Set the inode when creating a new file. */
  	buf_setino(buf);
  #endif
--- 4416,4422 ----
  # endif
  	buf_setino(buf);
      }
!     else if (!buf->b_dev_valid)
  	/* Set the inode when creating a new file. */
  	buf_setino(buf);
  #endif
*** ../vim-7.2.169/src/structs.h	2009-05-13 18:54:14.000000000 +0200
--- src/structs.h	2009-05-13 20:24:54.000000000 +0200
***************
*** 1166,1172 ****
      char_u	*b_fname;	/* current file name */
  
  #ifdef UNIX
!     dev_t	b_dev;		/* device number (-1 if not set) */
      ino_t	b_ino;		/* inode number */
  #endif
  #ifdef FEAT_CW_EDITOR
--- 1166,1173 ----
      char_u	*b_fname;	/* current file name */
  
  #ifdef UNIX
!     int		b_dev_valid;	/* TRUE when b_dev has a valid number */
!     dev_t	b_dev;		/* device number */
      ino_t	b_ino;		/* inode number */
  #endif
  #ifdef FEAT_CW_EDITOR
*** ../vim-7.2.169/src/version.c	2009-05-13 18:54:14.000000000 +0200
--- src/version.c	2009-05-13 20:43:22.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     170,
  /**/

-- 
A special cleaning ordinance bans housewives from hiding dirt and dust under a
rug in a dwelling.
		[real standing law in Pennsylvania, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.171
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.171 (after 7.2.169)
Problem:    Compiler warnings. (Tony Mechelynck)
Solution:   Add function prototype. (Patrick Texier)  Init variable.
Files:	    src/ex_cmds.c


*** ../vim-7.2.170/src/ex_cmds.c	2009-05-13 18:54:14.000000000 +0200
--- src/ex_cmds.c	2009-05-14 21:11:01.000000000 +0200
***************
*** 4637,4643 ****
  
  		if (do_ask)
  		{
! 		    int typed;
  
  		    /* change State to CONFIRM, so that the mouse works
  		     * properly */
--- 4635,4641 ----
  
  		if (do_ask)
  		{
! 		    int typed = 0;
  
  		    /* change State to CONFIRM, so that the mouse works
  		     * properly */
***************
*** 6553,6558 ****
--- 6549,6555 ----
  static sign_T	*first_sign = NULL;
  static int	last_sign_typenr = MAX_TYPENR;	/* is decremented */
  
+ static int sign_cmd_idx __ARGS((char_u *begin_cmd, char_u *end_cmd));
  static void sign_list_defined __ARGS((sign_T *sp));
  static void sign_undefine __ARGS((sign_T *sp, sign_T *sp_prev));
  
***************
*** 6579,6586 ****
   */
      static int
  sign_cmd_idx(begin_cmd, end_cmd)
!     char	*begin_cmd;	/* begin of sign subcmd */
!     char	*end_cmd;	/* just after sign subcmd */
  {
      int		idx;
      char	save = *end_cmd;
--- 6576,6583 ----
   */
      static int
  sign_cmd_idx(begin_cmd, end_cmd)
!     char_u	*begin_cmd;	/* begin of sign subcmd */
!     char_u	*end_cmd;	/* just after sign subcmd */
  {
      int		idx;
      char	save = *end_cmd;
*** ../vim-7.2.170/src/version.c	2009-05-13 20:47:07.000000000 +0200
--- src/version.c	2009-05-14 21:49:22.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     171,
  /**/

-- 
Living on Earth includes an annual free trip around the Sun.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.172 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.172 (extra)
Problem:    Compiler warning.
Solution:   Adjust function prototype. (Patrick Texier)
Files:	    src/os_mswin.c


*** ../vim-7.2.171/src/os_mswin.c	2009-01-22 21:49:21.000000000 +0100
--- src/os_mswin.c	2009-05-14 20:54:32.000000000 +0200
***************
*** 1227,1234 ****
   * Wait for another process to Close the Clipboard.
   * Returns TRUE for success.
   */
!     int
! vim_open_clipboard()
  {
      int delay = 10;
  
--- 1227,1234 ----
   * Wait for another process to Close the Clipboard.
   * Returns TRUE for success.
   */
!     static int
! vim_open_clipboard(void)
  {
      int delay = 10;
  
*** ../vim-7.2.171/src/version.c	2009-05-14 21:51:06.000000000 +0200
--- src/version.c	2009-05-14 21:59:45.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     172,
  /**/

-- 
FROG: How you English say:  I one more time, mac, I unclog my nose towards
      you, sons of a window-dresser,  so, you think you could out-clever us
      French fellows with your silly knees-bent creeping about advancing
      behaviour.  (blows a raspberry) I wave my private parts at your aunties,
      you brightly-coloured, mealy-templed, cranberry-smelling, electric
      donkey-bottom biters.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.173
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.173
Problem:    Without lint there is no check for unused function arguments.
Solution:   Use gcc -Wunused-parameter instead of lint.  For a few files add
	    attributes to arguments that are known not to be used.
Files:	    src/auto/configure, src/buffer.c, src/charset.c, src/diff.c,
	    src/configure.in, src/config.h.in, src/edit.c, src/ex_cmds.c,
	    src/ex_cmds2.c, src/version.c, src/vim.h


*** ../vim-7.2.172/src/auto/configure	2009-05-13 14:48:55.000000000 +0200
--- src/auto/configure	2009-05-14 22:08:12.000000000 +0200
***************
*** 10362,10367 ****
--- 10372,10427 ----
  
  rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
  
+ { $as_echo "$as_me:$LINENO: checking whether __attribute__((unused)) is allowed" >&5
+ $as_echo_n "checking whether __attribute__((unused)) is allowed... " >&6; }
+ cat >conftest.$ac_ext <<_ACEOF
+ /* confdefs.h.  */
+ _ACEOF
+ cat confdefs.h >>conftest.$ac_ext
+ cat >>conftest.$ac_ext <<_ACEOF
+ /* end confdefs.h.  */
+ #include <stdio.h>
+ int
+ main ()
+ {
+ int x __attribute__((unused));
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext
+ if { (ac_try="$ac_compile"
+ case "(($ac_try" in
+   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+   *) ac_try_echo=$ac_try;;
+ esac
+ eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+ $as_echo "$ac_try_echo") >&5
+   (eval "$ac_compile") 2>conftest.er1
+   ac_status=$?
+   grep -v '^ *+' conftest.er1 >conftest.err
+   rm -f conftest.er1
+   cat conftest.err >&5
+   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } && {
+ 	 test -z "$ac_c_werror_flag" ||
+ 	 test ! -s conftest.err
+        } && test -s conftest.$ac_objext; then
+   { $as_echo "$as_me:$LINENO: result: yes" >&5
+ $as_echo "yes" >&6; }; cat >>confdefs.h <<\_ACEOF
+ #define HAVE_ATTRIBUTE_UNUSED 1
+ _ACEOF
+ 
+ else
+   $as_echo "$as_me: failed program was:" >&5
+ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+ 	{ $as_echo "$as_me:$LINENO: result: no" >&5
+ $as_echo "no" >&6; }
+ fi
+ 
+ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ 
  if test "${ac_cv_header_elf_h+set}" = set; then
    { $as_echo "$as_me:$LINENO: checking for elf.h" >&5
  $as_echo_n "checking for elf.h... " >&6; }
*** ../vim-7.2.172/src/buffer.c	2009-05-13 20:47:07.000000000 +0200
--- src/buffer.c	2009-05-14 21:34:06.000000000 +0200
***************
*** 512,523 ****
   * buf_freeall() - free all things allocated for a buffer that are related to
   * the file.
   */
- /*ARGSUSED*/
      void
  buf_freeall(buf, del_buf, wipe_buf)
      buf_T	*buf;
!     int		del_buf;	/* buffer is going to be deleted */
!     int		wipe_buf;	/* buffer is going to be wiped out */
  {
  #ifdef FEAT_AUTOCMD
      int		is_curbuf = (buf == curbuf);
--- 512,522 ----
   * buf_freeall() - free all things allocated for a buffer that are related to
   * the file.
   */
      void
  buf_freeall(buf, del_buf, wipe_buf)
      buf_T	*buf;
!     int		del_buf UNUSED;	    /* buffer is going to be deleted */
!     int		wipe_buf UNUSED;    /* buffer is going to be wiped out */
  {
  #ifdef FEAT_AUTOCMD
      int		is_curbuf = (buf == curbuf);
***************
*** 2437,2447 ****
   * another tab page.
   * Returns NULL when there isn't any info.
   */
- /*ARGSUSED*/
      static wininfo_T *
  find_wininfo(buf, skip_diff_buffer)
      buf_T	*buf;
!     int		skip_diff_buffer;
  {
      wininfo_T	*wip;
  
--- 2436,2445 ----
   * another tab page.
   * Returns NULL when there isn't any info.
   */
      static wininfo_T *
  find_wininfo(buf, skip_diff_buffer)
      buf_T	*buf;
!     int		skip_diff_buffer UNUSED;
  {
      wininfo_T	*wip;
  
***************
*** 4278,4287 ****
   * Make "ffname" a full file name, set "sfname" to "ffname" if not NULL.
   * "ffname" becomes a pointer to allocated memory (or NULL).
   */
- /*ARGSUSED*/
      void
  fname_expand(buf, ffname, sfname)
!     buf_T	*buf;
      char_u	**ffname;
      char_u	**sfname;
  {
--- 4276,4284 ----
   * Make "ffname" a full file name, set "sfname" to "ffname" if not NULL.
   * "ffname" becomes a pointer to allocated memory (or NULL).
   */
      void
  fname_expand(buf, ffname, sfname)
!     buf_T	*buf UNUSED;
      char_u	**ffname;
      char_u	**sfname;
  {
***************
*** 5577,5587 ****
   * this buffer.  Call this to wipe out a temp buffer that does not contain any
   * marks.
   */
- /*ARGSUSED*/
      void
  wipe_buffer(buf, aucmd)
      buf_T	*buf;
!     int		aucmd;	    /* When TRUE trigger autocommands. */
  {
      if (buf->b_fnum == top_file_num - 1)
  	--top_file_num;
--- 5574,5583 ----
   * this buffer.  Call this to wipe out a temp buffer that does not contain any
   * marks.
   */
      void
  wipe_buffer(buf, aucmd)
      buf_T	*buf;
!     int		aucmd UNUSED;	    /* When TRUE trigger autocommands. */
  {
      if (buf->b_fnum == top_file_num - 1)
  	--top_file_num;
*** ../vim-7.2.172/src/charset.c	2009-05-13 14:10:46.000000000 +0200
--- src/charset.c	2009-05-14 21:34:30.000000000 +0200
***************
*** 1026,1038 ****
   * string at start of line.  Warning: *headp is only set if it's a non-zero
   * value, init to 0 before calling.
   */
- /*ARGSUSED*/
      int
  win_lbr_chartabsize(wp, s, col, headp)
      win_T	*wp;
      char_u	*s;
      colnr_T	col;
!     int		*headp;
  {
  #ifdef FEAT_LINEBREAK
      int		c;
--- 1026,1037 ----
   * string at start of line.  Warning: *headp is only set if it's a non-zero
   * value, init to 0 before calling.
   */
      int
  win_lbr_chartabsize(wp, s, col, headp)
      win_T	*wp;
      char_u	*s;
      colnr_T	col;
!     int		*headp UNUSED;
  {
  #ifdef FEAT_LINEBREAK
      int		c;
*** ../vim-7.2.172/src/diff.c	2009-05-13 18:54:14.000000000 +0200
--- src/diff.c	2009-05-14 21:24:59.000000000 +0200
***************
*** 652,661 ****
   * The buffers are written to a file, also for unmodified buffers (the file
   * could have been produced by autocommands, e.g. the netrw plugin).
   */
- /*ARGSUSED*/
      void
  ex_diffupdate(eap)
!     exarg_T	*eap;	    /* can be NULL, it's not used */
  {
      buf_T	*buf;
      int		idx_orig;
--- 652,660 ----
   * The buffers are written to a file, also for unmodified buffers (the file
   * could have been produced by autocommands, e.g. the netrw plugin).
   */
      void
  ex_diffupdate(eap)
!     exarg_T	*eap UNUSED;	    /* can be NULL */
  {
      buf_T	*buf;
      int		idx_orig;
***************
*** 1094,1103 ****
  /*
   * Set options to show difs for the current window.
   */
- /*ARGSUSED*/
      void
  ex_diffthis(eap)
!     exarg_T	*eap;
  {
      /* Set 'diff', 'scrollbind' on and 'wrap' off. */
      diff_win_options(curwin, TRUE);
--- 1093,1101 ----
  /*
   * Set options to show difs for the current window.
   */
      void
  ex_diffthis(eap)
!     exarg_T	*eap UNUSED;
  {
      /* Set 'diff', 'scrollbind' on and 'wrap' off. */
      diff_win_options(curwin, TRUE);
*** ../vim-7.2.172/src/configure.in	2009-05-13 14:48:55.000000000 +0200
--- src/configure.in	2009-05-14 22:08:06.000000000 +0200
***************
*** 2067,2072 ****
--- 2067,2077 ----
  	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),
  	AC_MSG_RESULT(no))
  
+ AC_MSG_CHECKING(whether __attribute__((unused)) is allowed)
+ AC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),
+ 	AC_MSG_RESULT(no))
+ 
  dnl Checks for header files.
  AC_CHECK_HEADER(elf.h, HAS_ELF=1)
  dnl AC_CHECK_HEADER(dwarf.h, SVR4=1)
*** ../vim-7.2.172/src/config.h.in	2009-03-02 02:44:54.000000000 +0100
--- src/config.h.in	2009-05-14 21:15:02.000000000 +0200
***************
*** 30,35 ****
--- 30,38 ----
  /* Define when __DATE__ " " __TIME__ can be used */
  #undef HAVE_DATE_TIME
  
+ /* Define when __attribute__((unused)) can be used */
+ #undef HAVE_ATTRIBUTE_UNUSED
+ 
  /* defined always when using configure */
  #undef UNIX
  
*** ../vim-7.2.172/src/edit.c	2009-05-13 18:54:14.000000000 +0200
--- src/edit.c	2009-05-14 21:35:08.000000000 +0200
***************
*** 1447,1456 ****
   * Only redraw when there are no characters available.  This speeds up
   * inserting sequences of characters (e.g., for CTRL-R).
   */
- /*ARGSUSED*/
      static void
  ins_redraw(ready)
!     int		ready;	    /* not busy with something */
  {
      if (!char_avail())
      {
--- 1447,1455 ----
   * Only redraw when there are no characters available.  This speeds up
   * inserting sequences of characters (e.g., for CTRL-R).
   */
      static void
  ins_redraw(ready)
!     int		ready UNUSED;	    /* not busy with something */
  {
      if (!char_avail())
      {
***************
*** 1962,1971 ****
   * Only matters when there are composing characters.
   * Return TRUE when something was deleted.
   */
- /*ARGSUSED*/
     static int
  del_char_after_col(limit_col)
!     int limit_col;
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 && limit_col >= 0)
--- 1961,1969 ----
   * Only matters when there are composing characters.
   * Return TRUE when something was deleted.
   */
     static int
  del_char_after_col(limit_col)
!     int limit_col UNUSED;
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 && limit_col >= 0)
*** ../vim-7.2.172/src/ex_cmds.c	2009-05-14 21:51:06.000000000 +0200
--- src/ex_cmds.c	2009-05-14 21:11:01.000000000 +0200
***************
*** 43,52 ****
  /*
   * ":ascii" and "ga".
   */
- /*ARGSUSED*/
      void
  do_ascii(eap)
!     exarg_T	*eap;
  {
      int		c;
      int		cval;
--- 43,51 ----
  /*
   * ":ascii" and "ga".
   */
      void
  do_ascii(eap)
!     exarg_T	*eap UNUSED;
  {
      int		c;
      int		cval;
***************
*** 2373,2382 ****
   *   ^?		^H
   * not ^?	^?
   */
- /*ARGSUSED*/
      void
  do_fixdel(eap)
!     exarg_T	*eap;
  {
      char_u  *p;
  
--- 2372,2380 ----
   *   ^?		^H
   * not ^?	^?
   */
      void
  do_fixdel(eap)
!     exarg_T	*eap UNUSED;
  {
      char_u  *p;
  
***************
*** 6127,6136 ****
  /*
   * ":exusage"
   */
- /*ARGSUSED*/
      void
  ex_exusage(eap)
!     exarg_T	*eap;
  {
      do_cmdline_cmd((char_u *)"help ex-cmd-index");
  }
--- 6125,6133 ----
  /*
   * ":exusage"
   */
      void
  ex_exusage(eap)
!     exarg_T	*eap UNUSED;
  {
      do_cmdline_cmd((char_u *)"help ex-cmd-index");
  }
***************
*** 6138,6147 ****
  /*
   * ":viusage"
   */
- /*ARGSUSED*/
      void
  ex_viusage(eap)
!     exarg_T	*eap;
  {
      do_cmdline_cmd((char_u *)"help normal-index");
  }
--- 6135,6143 ----
  /*
   * ":viusage"
   */
      void
  ex_viusage(eap)
!     exarg_T	*eap UNUSED;
  {
      do_cmdline_cmd((char_u *)"help normal-index");
  }
***************
*** 7154,7163 ****
   * Function given to ExpandGeneric() to obtain the sign command
   * expansion.
   */
- /*ARGSUSED*/
      char_u *
  get_sign_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      sign_T	*sp;
--- 7150,7158 ----
   * Function given to ExpandGeneric() to obtain the sign command
   * expansion.
   */
      char_u *
  get_sign_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      sign_T	*sp;
*** ../vim-7.2.172/src/ex_cmds2.c	2009-05-13 18:54:14.000000000 +0200
--- src/ex_cmds2.c	2009-05-14 21:35:40.000000000 +0200
***************
*** 680,689 ****
  /*
   * ":breaklist".
   */
- /*ARGSUSED*/
      void
  ex_breaklist(eap)
!     exarg_T	*eap;
  {
      struct debuggy *bp;
      int		i;
--- 680,688 ----
  /*
   * ":breaklist".
   */
      void
  ex_breaklist(eap)
!     exarg_T	*eap UNUSED;
  {
      struct debuggy *bp;
      int		i;
***************
*** 1342,1355 ****
  /*
   * return TRUE if buffer was changed and cannot be abandoned.
   */
- /*ARGSUSED*/
      int
  check_changed(buf, checkaw, mult_win, forceit, allbuf)
      buf_T	*buf;
      int		checkaw;	/* do autowrite if buffer was changed */
      int		mult_win;	/* check also when several wins for the buf */
      int		forceit;
!     int		allbuf;		/* may write all buffers */
  {
      if (       !forceit
  	    && bufIsChanged(buf)
--- 1341,1353 ----
  /*
   * return TRUE if buffer was changed and cannot be abandoned.
   */
      int
  check_changed(buf, checkaw, mult_win, forceit, allbuf)
      buf_T	*buf;
      int		checkaw;	/* do autowrite if buffer was changed */
      int		mult_win;	/* check also when several wins for the buf */
      int		forceit;
!     int		allbuf UNUSED;	/* may write all buffers */
  {
      if (       !forceit
  	    && bufIsChanged(buf)
***************
*** 1759,1770 ****
   *
   * Return FAIL for failure, OK otherwise.
   */
- /*ARGSUSED*/
      static int
  do_arglist(str, what, after)
      char_u	*str;
!     int		what;
!     int		after;		/* 0 means before first one */
  {
      garray_T	new_ga;
      int		exp_count;
--- 1757,1767 ----
   *
   * Return FAIL for failure, OK otherwise.
   */
      static int
  do_arglist(str, what, after)
      char_u	*str;
!     int		what UNUSED;
!     int		after UNUSED;		/* 0 means before first one */
  {
      garray_T	new_ga;
      int		exp_count;
***************
*** 2549,2559 ****
  
  static void source_callback __ARGS((char_u *fname, void *cookie));
  
- /*ARGSUSED*/
      static void
  source_callback(fname, cookie)
      char_u	*fname;
!     void	*cookie;
  {
      (void)do_source(fname, FALSE, DOSO_NONE);
  }
--- 2546,2555 ----
  
  static void source_callback __ARGS((char_u *fname, void *cookie));
  
      static void
  source_callback(fname, cookie)
      char_u	*fname;
!     void	*cookie UNUSED;
  {
      (void)do_source(fname, FALSE, DOSO_NONE);
  }
***************
*** 2680,2689 ****
  /*
   * ":options"
   */
- /*ARGSUSED*/
      void
  ex_options(eap)
!     exarg_T	*eap;
  {
      cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);
  }
--- 2676,2684 ----
  /*
   * ":options"
   */
      void
  ex_options(eap)
!     exarg_T	*eap UNUSED;
  {
      cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);
  }
***************
*** 3190,3199 ****
  /*
   * ":scriptnames"
   */
- /*ARGSUSED*/
      void
  ex_scriptnames(eap)
!     exarg_T	*eap;
  {
      int i;
  
--- 3185,3193 ----
  /*
   * ":scriptnames"
   */
      void
  ex_scriptnames(eap)
!     exarg_T	*eap UNUSED;
  {
      int i;
  
***************
*** 3317,3328 ****
   * Return a pointer to the line in allocated memory.
   * Return NULL for end-of-file or some error.
   */
- /* ARGSUSED */
      char_u *
  getsourceline(c, cookie, indent)
!     int		c;		/* not used */
      void	*cookie;
!     int		indent;		/* not used */
  {
      struct source_cookie *sp = (struct source_cookie *)cookie;
      char_u		*line;
--- 3311,3321 ----
   * Return a pointer to the line in allocated memory.
   * Return NULL for end-of-file or some error.
   */
      char_u *
  getsourceline(c, cookie, indent)
!     int		c UNUSED;
      void	*cookie;
!     int		indent UNUSED;
  {
      struct source_cookie *sp = (struct source_cookie *)cookie;
      char_u		*line;
***************
*** 3649,3658 ****
   * ":scriptencoding": Set encoding conversion for a sourced script.
   * Without the multi-byte feature it's simply ignored.
   */
- /*ARGSUSED*/
      void
  ex_scriptencoding(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_MBYTE
      struct source_cookie	*sp;
--- 3642,3650 ----
   * ":scriptencoding": Set encoding conversion for a sourced script.
   * Without the multi-byte feature it's simply ignored.
   */
      void
  ex_scriptencoding(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_MBYTE
      struct source_cookie	*sp;
***************
*** 4101,4110 ****
   * Function given to ExpandGeneric() to obtain the possible arguments of the
   * ":language" command.
   */
- /*ARGSUSED*/
      char_u *
  get_lang_arg(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      if (idx == 0)
--- 4093,4101 ----
   * Function given to ExpandGeneric() to obtain the possible arguments of the
   * ":language" command.
   */
      char_u *
  get_lang_arg(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      if (idx == 0)
*** ../vim-7.2.172/src/version.c	2009-05-14 22:00:37.000000000 +0200
--- src/version.c	2009-05-14 22:14:51.000000000 +0200
***************
*** 1623,1632 ****
  /*
   * ":intro": clear screen, display intro screen and wait for return.
   */
- /*ARGSUSED*/
      void
  ex_intro(eap)
!     exarg_T	*eap;
  {
      screenclear();
      intro_message(TRUE);
--- 1625,1633 ----
  /*
   * ":intro": clear screen, display intro screen and wait for return.
   */
      void
  ex_intro(eap)
!     exarg_T	*eap UNUSED;
  {
      screenclear();
      intro_message(TRUE);
*** ../vim-7.2.172/src/vim.h	2009-05-13 18:54:14.000000000 +0200
--- src/vim.h	2009-05-14 21:17:51.000000000 +0200
***************
*** 262,267 ****
--- 262,275 ----
  # define __PARMS(x) __ARGS(x)
  #endif
  
+ /* Mark unused function arguments with UNUSED, so that gcc -Wunused-parameter
+  * can be used to check for mistakes. */
+ #ifdef HAVE_ATTRIBUTE_UNUSED
+ # define UNUSED __attribute__((unused))
+ #else
+ # define UNUSED
+ #endif
+ 
  /* if we're compiling in C++ (currently only KVim), the system
   * headers must have the correct prototypes or nothing will build.
   * conversely, our prototypes might clash due to throw() specifiers and
*** ../vim-7.2.172/src/version.c	2009-05-14 22:00:37.000000000 +0200
--- src/version.c	2009-05-14 22:14:51.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     173,
  /**/

-- 
SIGIRO -- irony detected (iron core dumped)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.174
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.174
Problem:    Too many warnings from gcc -Wextra.
Solution:   Change initializer.  Add UNUSED.  Add type casts.
Files:      src/edit.c, src/eval.c, src/ex_cmds.c, src/ex_docmd.c,
            src/ex_getln.c, src/fileio.c, getchar.c, globals.h, main.c,
            memline.c, message.c, src/misc1.c, src/move.c, src/normal.c,
            src/option.c, src/os_unix.c, src/os_unix.h, src/regexp.c,
            src/search.c, src/tag.c


*** ../vim-7.2.173/src/edit.c	2009-05-14 22:19:19.000000000 +0200
--- src/edit.c	2009-05-15 21:06:07.000000000 +0200
***************
*** 8991,8997 ****
  	foldOpenCursor();
  #endif
      undisplay_dollar();
!     if (gchar_cursor() != NUL || virtual_active()
  	    )
      {
  	start_arrow(&curwin->w_cursor);
--- 8992,9001 ----
  	foldOpenCursor();
  #endif
      undisplay_dollar();
!     if (gchar_cursor() != NUL
! #ifdef FEAT_VIRTUALEDIT
! 	    || virtual_active()
! #endif
  	    )
      {
  	start_arrow(&curwin->w_cursor);
*** ../vim-7.2.173/src/eval.c	2009-04-22 16:07:57.000000000 +0200
--- src/eval.c	2009-05-15 21:18:08.000000000 +0200
***************
*** 8303,8312 ****
  /*
   * "argc()" function
   */
- /* ARGSUSED */
      static void
  f_argc(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = ARGCOUNT;
--- 8303,8311 ----
  /*
   * "argc()" function
   */
      static void
  f_argc(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = ARGCOUNT;
***************
*** 8315,8324 ****
  /*
   * "argidx()" function
   */
- /* ARGSUSED */
      static void
  f_argidx(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = curwin->w_arg_idx;
--- 8314,8322 ----
  /*
   * "argidx()" function
   */
      static void
  f_argidx(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = curwin->w_arg_idx;
***************
*** 8396,8405 ****
  /*
   * "browse(save, title, initdir, default)" function
   */
- /* ARGSUSED */
      static void
  f_browse(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
--- 8394,8402 ----
  /*
   * "browse(save, title, initdir, default)" function
   */
      static void
  f_browse(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
***************
*** 8431,8440 ****
  /*
   * "browsedir(title, initdir)" function
   */
- /* ARGSUSED */
      static void
  f_browsedir(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
--- 8428,8436 ----
  /*
   * "browsedir(title, initdir)" function
   */
      static void
  f_browsedir(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
***************
*** 8801,8810 ****
  /*
   * "changenr()" function
   */
- /*ARGSUSED*/
      static void
  f_changenr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = curbuf->b_u_seq_cur;
--- 8797,8805 ----
  /*
   * "changenr()" function
   */
      static void
  f_changenr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = curbuf->b_u_seq_cur;
***************
*** 8854,8863 ****
  /*
   * "clearmatches()" function
   */
- /*ARGSUSED*/
      static void
  f_clearmatches(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_SEARCH_EXTRA
--- 8849,8857 ----
  /*
   * "clearmatches()" function
   */
      static void
  f_clearmatches(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_SEARCH_EXTRA
*** ../vim-7.2.173/src/ex_cmds.c	2009-05-14 22:19:19.000000000 +0200
--- src/ex_cmds.c	2009-05-15 20:42:18.000000000 +0200
***************
*** 4040,4047 ****
--- 4040,4049 ----
  	bigness = curwin->w_height;
      else if (firstwin == lastwin)
  	bigness = curwin->w_p_scr * 2;
+ #ifdef FEAT_WINDOWS
      else
  	bigness = curwin->w_height - 3;
+ #endif
      if (bigness < 1)
  	bigness = 1;
  
*** ../vim-7.2.173/src/ex_docmd.c	2009-05-13 18:54:14.000000000 +0200
--- src/ex_docmd.c	2009-05-15 20:47:58.000000000 +0200
***************
*** 1578,1588 ****
   * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
   * "func".  * Otherwise return TRUE when "fgetline" equals "func".
   */
- /*ARGSUSED*/
      int
  getline_equal(fgetline, cookie, func)
      char_u	*(*fgetline) __ARGS((int, void *, int));
!     void	*cookie;		/* argument for fgetline() */
      char_u	*(*func) __ARGS((int, void *, int));
  {
  #ifdef FEAT_EVAL
--- 1578,1587 ----
   * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
   * "func".  * Otherwise return TRUE when "fgetline" equals "func".
   */
      int
  getline_equal(fgetline, cookie, func)
      char_u	*(*fgetline) __ARGS((int, void *, int));
!     void	*cookie UNUSED;		/* argument for fgetline() */
      char_u	*(*func) __ARGS((int, void *, int));
  {
  #ifdef FEAT_EVAL
***************
*** 1610,1619 ****
   * If "fgetline" is get_loop_line(), return the cookie used by the original
   * getline function.  Otherwise return "cookie".
   */
- /*ARGSUSED*/
      void *
  getline_cookie(fgetline, cookie)
!     char_u	*(*fgetline) __ARGS((int, void *, int));
      void	*cookie;		/* argument for fgetline() */
  {
  # ifdef FEAT_EVAL
--- 1609,1617 ----
   * If "fgetline" is get_loop_line(), return the cookie used by the original
   * getline function.  Otherwise return "cookie".
   */
      void *
  getline_cookie(fgetline, cookie)
!     char_u	*(*fgetline) __ARGS((int, void *, int)) UNUSED;
      void	*cookie;		/* argument for fgetline() */
  {
  # ifdef FEAT_EVAL
***************
*** 2754,2764 ****
   * "full" is set to TRUE if the whole command name matched.
   * Returns NULL for an ambiguous user command.
   */
- /*ARGSUSED*/
      static char_u *
  find_command(eap, full)
      exarg_T	*eap;
!     int		*full;
  {
      int		len;
      char_u	*p;
--- 2752,2761 ----
   * "full" is set to TRUE if the whole command name matched.
   * Returns NULL for an ambiguous user command.
   */
      static char_u *
  find_command(eap, full)
      exarg_T	*eap;
!     int		*full UNUSED;
  {
      int		len;
      char_u	*p;
***************
*** 5053,5062 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of command names.
   */
- /*ARGSUSED*/
      char_u *
  get_command_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      if (idx >= (int)CMD_SIZE)
--- 5050,5058 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of command names.
   */
      char_u *
  get_command_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      if (idx >= (int)CMD_SIZE)
***************
*** 5573,5582 ****
   * ":comclear"
   * Clear all user commands, global and for current buffer.
   */
- /*ARGSUSED*/
      void
  ex_comclear(eap)
!     exarg_T	*eap;
  {
      uc_clear(&ucmds);
      uc_clear(&curbuf->b_ucmds);
--- 5569,5577 ----
   * ":comclear"
   * Clear all user commands, global and for current buffer.
   */
      void
  ex_comclear(eap)
!     exarg_T	*eap UNUSED;
  {
      uc_clear(&ucmds);
      uc_clear(&curbuf->b_ucmds);
***************
*** 6072,6081 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of user command names.
   */
- /*ARGSUSED*/
      char_u *
  get_user_commands(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      if (idx < curbuf->b_ucmds.ga_len)
--- 6067,6075 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of user command names.
   */
      char_u *
  get_user_commands(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      if (idx < curbuf->b_ucmds.ga_len)
***************
*** 6090,6099 ****
   * Function given to ExpandGeneric() to obtain the list of user command
   * attributes.
   */
- /*ARGSUSED*/
      char_u *
  get_user_cmd_flags(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      static char *user_cmd_flags[] =
--- 6084,6092 ----
   * Function given to ExpandGeneric() to obtain the list of user command
   * attributes.
   */
      char_u *
  get_user_cmd_flags(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      static char *user_cmd_flags[] =
***************
*** 6108,6117 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of values for -nargs.
   */
- /*ARGSUSED*/
      char_u *
  get_user_cmd_nargs(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
--- 6101,6109 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of values for -nargs.
   */
      char_u *
  get_user_cmd_nargs(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
***************
*** 6124,6133 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of values for -complete.
   */
- /*ARGSUSED*/
      char_u *
  get_user_cmd_complete(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      return (char_u *)command_complete[idx].name;
--- 6116,6124 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of values for -complete.
   */
      char_u *
  get_user_cmd_complete(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      return (char_u *)command_complete[idx].name;
***************
*** 6305,6314 ****
  /*
   * ":cquit".
   */
- /*ARGSUSED*/
      static void
  ex_cquit(eap)
!     exarg_T	*eap;
  {
      getout(1);	/* this does not always pass on the exit code to the Manx
  		   compiler. why? */
--- 6296,6304 ----
  /*
   * ":cquit".
   */
      static void
  ex_cquit(eap)
!     exarg_T	*eap UNUSED;
  {
      getout(1);	/* this does not always pass on the exit code to the Manx
  		   compiler. why? */
***************
*** 6750,6759 ****
  /*
   * ":shell".
   */
- /*ARGSUSED*/
      static void
  ex_shell(eap)
!     exarg_T	*eap;
  {
      do_shell(NULL, 0);
  }
--- 6740,6748 ----
  /*
   * ":shell".
   */
      static void
  ex_shell(eap)
!     exarg_T	*eap UNUSED;
  {
      do_shell(NULL, 0);
  }
***************
*** 7057,7066 ****
  /*
   * ":preserve".
   */
- /*ARGSUSED*/
      static void
  ex_preserve(eap)
!     exarg_T	*eap;
  {
      curbuf->b_flags |= BF_PRESERVED;
      ml_preserve(curbuf, TRUE);
--- 7046,7054 ----
  /*
   * ":preserve".
   */
      static void
  ex_preserve(eap)
!     exarg_T	*eap UNUSED;
  {
      curbuf->b_flags |= BF_PRESERVED;
      ml_preserve(curbuf, TRUE);
***************
*** 7292,7301 ****
  /*
   * :tabs command: List tabs and their contents.
   */
- /*ARGSUSED*/
      static void
  ex_tabs(eap)
!     exarg_T	*eap;
  {
      tabpage_T	*tp;
      win_T	*wp;
--- 7280,7288 ----
  /*
   * :tabs command: List tabs and their contents.
   */
      static void
  ex_tabs(eap)
!     exarg_T	*eap UNUSED;
  {
      tabpage_T	*tp;
      win_T	*wp;
***************
*** 7482,7488 ****
  /*
   * ":edit <file>" command and alikes.
   */
- /*ARGSUSED*/
      void
  do_exedit(eap, old_curwin)
      exarg_T	*eap;
--- 7469,7474 ----
***************
*** 7694,7703 ****
  }
  #endif
  
- /*ARGSUSED*/
      static void
  ex_swapname(eap)
!     exarg_T	*eap;
  {
      if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
  	MSG(_("No swap file"));
--- 7680,7688 ----
  }
  #endif
  
      static void
  ex_swapname(eap)
!     exarg_T	*eap UNUSED;
  {
      if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
  	MSG(_("No swap file"));
***************
*** 7710,7719 ****
   * offset.
   * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
   */
- /*ARGSUSED*/
      static void
  ex_syncbind(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_SCROLLBIND
      win_T	*wp;
--- 7695,7703 ----
   * offset.
   * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
   */
      static void
  ex_syncbind(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_SCROLLBIND
      win_T	*wp;
***************
*** 7983,7992 ****
  /*
   * ":pwd".
   */
- /*ARGSUSED*/
      static void
  ex_pwd(eap)
!     exarg_T	*eap;
  {
      if (mch_dirname(NameBuff, MAXPATHL) == OK)
      {
--- 7967,7975 ----
  /*
   * ":pwd".
   */
      static void
  ex_pwd(eap)
!     exarg_T	*eap UNUSED;
  {
      if (mch_dirname(NameBuff, MAXPATHL) == OK)
      {
***************
*** 8417,8426 ****
  /*
   * ":undo".
   */
- /*ARGSUSED*/
      static void
  ex_undo(eap)
!     exarg_T	*eap;
  {
      if (eap->addr_count == 1)	    /* :undo 123 */
  	undo_time(eap->line2, FALSE, TRUE);
--- 8400,8408 ----
  /*
   * ":undo".
   */
      static void
  ex_undo(eap)
!     exarg_T	*eap UNUSED;
  {
      if (eap->addr_count == 1)	    /* :undo 123 */
  	undo_time(eap->line2, FALSE, TRUE);
***************
*** 8431,8440 ****
  /*
   * ":redo".
   */
- /*ARGSUSED*/
      static void
  ex_redo(eap)
!     exarg_T	*eap;
  {
      u_redo(1);
  }
--- 8413,8421 ----
  /*
   * ":redo".
   */
      static void
  ex_redo(eap)
!     exarg_T	*eap UNUSED;
  {
      u_redo(1);
  }
***************
*** 8442,8448 ****
  /*
   * ":earlier" and ":later".
   */
- /*ARGSUSED*/
      static void
  ex_later(eap)
      exarg_T	*eap;
--- 8423,8428 ----
***************
*** 8627,8636 ****
  /*
   * ":redrawstatus": force redraw of status line(s)
   */
- /*ARGSUSED*/
      static void
  ex_redrawstatus(eap)
!     exarg_T	*eap;
  {
  #if defined(FEAT_WINDOWS)
      int		r = RedrawingDisabled;
--- 8607,8615 ----
  /*
   * ":redrawstatus": force redraw of status line(s)
   */
      static void
  ex_redrawstatus(eap)
!     exarg_T	*eap UNUSED;
  {
  #if defined(FEAT_WINDOWS)
      int		r = RedrawingDisabled;
***************
*** 8891,8901 ****
  
  #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
  	|| defined(PROTO)
- /*ARGSUSED*/
      int
  vim_mkdir_emsg(name, prot)
      char_u	*name;
!     int		prot;
  {
      if (vim_mkdir(name, prot) != 0)
      {
--- 8870,8879 ----
  
  #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
  	|| defined(PROTO)
      int
  vim_mkdir_emsg(name, prot)
      char_u	*name;
!     int		prot UNUSED;
  {
      if (vim_mkdir(name, prot) != 0)
      {
***************
*** 10968,10977 ****
  }
  #endif
  
- /*ARGSUSED*/
      static void
  ex_digraphs(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_DIGRAPHS
      if (*eap->arg != NUL)
--- 10946,10954 ----
  }
  #endif
  
      static void
  ex_digraphs(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_DIGRAPHS
      if (*eap->arg != NUL)
***************
*** 11005,11014 ****
  /*
   * ":nohlsearch"
   */
- /*ARGSUSED*/
      static void
  ex_nohlsearch(eap)
!     exarg_T	*eap;
  {
      no_hlsearch = TRUE;
      redraw_all_later(SOME_VALID);
--- 10982,10990 ----
  /*
   * ":nohlsearch"
   */
      static void
  ex_nohlsearch(eap)
!     exarg_T	*eap UNUSED;
  {
      no_hlsearch = TRUE;
      redraw_all_later(SOME_VALID);
***************
*** 11087,11096 ****
  /*
   * ":X": Get crypt key
   */
- /*ARGSUSED*/
      static void
  ex_X(eap)
!     exarg_T	*eap;
  {
      (void)get_crypt_key(TRUE, TRUE);
  }
--- 11063,11071 ----
  /*
   * ":X": Get crypt key
   */
      static void
  ex_X(eap)
!     exarg_T	*eap UNUSED;
  {
      (void)get_crypt_key(TRUE, TRUE);
  }
*** ../vim-7.2.173/src/ex_getln.c	2009-04-29 18:44:38.000000000 +0200
--- src/ex_getln.c	2009-05-15 20:49:22.000000000 +0200
***************
*** 140,150 ****
   * Return pointer to allocated string if there is a commandline, NULL
   * otherwise.
   */
- /*ARGSUSED*/
      char_u *
  getcmdline(firstc, count, indent)
      int		firstc;
!     long	count;		/* only used for incremental search */
      int		indent;		/* indent for inside conditionals */
  {
      int		c;
--- 140,149 ----
   * Return pointer to allocated string if there is a commandline, NULL
   * otherwise.
   */
      char_u *
  getcmdline(firstc, count, indent)
      int		firstc;
!     long	count UNUSED;	/* only used for incremental search */
      int		indent;		/* indent for inside conditionals */
  {
      int		c;
***************
*** 2113,2123 ****
  /*
   * Get an Ex command line for the ":" command.
   */
- /* ARGSUSED */
      char_u *
! getexline(c, dummy, indent)
      int		c;		/* normally ':', NUL for ":append" */
!     void	*dummy;		/* cookie not used */
      int		indent;		/* indent for inside conditionals */
  {
      /* When executing a register, remove ':' that's in front of each line. */
--- 2112,2121 ----
  /*
   * Get an Ex command line for the ":" command.
   */
      char_u *
! getexline(c, cookie, indent)
      int		c;		/* normally ':', NUL for ":append" */
!     void	*cookie UNUSED;
      int		indent;		/* indent for inside conditionals */
  {
      /* When executing a register, remove ':' that's in front of each line. */
***************
*** 2132,2143 ****
   * mappings or abbreviations.
   * Returns a string in allocated memory or NULL.
   */
- /* ARGSUSED */
      char_u *
! getexmodeline(promptc, dummy, indent)
      int		promptc;	/* normally ':', NUL for ":append" and '?' for
  				   :s prompt */
!     void	*dummy;		/* cookie not used */
      int		indent;		/* indent for inside conditionals */
  {
      garray_T	line_ga;
--- 2130,2140 ----
   * mappings or abbreviations.
   * Returns a string in allocated memory or NULL.
   */
      char_u *
! getexmodeline(promptc, cookie, indent)
      int		promptc;	/* normally ':', NUL for ":append" and '?' for
  				   :s prompt */
!     void	*cookie UNUSED;
      int		indent;		/* indent for inside conditionals */
  {
      garray_T	line_ga;
***************
*** 3832,3842 ****
   * Returns EXPAND_NOTHING when the character that triggered expansion should
   * be inserted like a normal character.
   */
- /*ARGSUSED*/
      static int
  showmatches(xp, wildmenu)
      expand_T	*xp;
!     int		wildmenu;
  {
  #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
      int		num_files;
--- 3829,3838 ----
   * Returns EXPAND_NOTHING when the character that triggered expansion should
   * be inserted like a normal character.
   */
      static int
  showmatches(xp, wildmenu)
      expand_T	*xp;
!     int		wildmenu UNUSED;
  {
  #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
      int		num_files;
*** ../vim-7.2.173/src/fileio.c	2009-05-13 20:47:07.000000000 +0200
--- src/fileio.c	2009-05-15 20:52:40.000000000 +0200
***************
*** 3498,3504 ****
  		    if (mch_stat((char *)IObuff, &st) < 0
  			    || st.st_uid != st_old.st_uid
  			    || st.st_gid != st_old.st_gid
! 			    || st.st_mode != perm)
  			backup_copy = TRUE;
  # endif
  		    /* Close the file before removing it, on MS-Windows we
--- 3498,3504 ----
  		    if (mch_stat((char *)IObuff, &st) < 0
  			    || st.st_uid != st_old.st_uid
  			    || st.st_gid != st_old.st_gid
! 			    || (long)st.st_mode != perm)
  			backup_copy = TRUE;
  # endif
  		    /* Close the file before removing it, on MS-Windows we
***************
*** 5963,5969 ****
  	else if (*ext == '.')
  #endif
  	{
! 	    if (s - ptr > (size_t)8)
  	    {
  		s = ptr + 8;
  		*s = '\0';
--- 5971,5977 ----
  	else if (*ext == '.')
  #endif
  	{
! 	    if ((size_t)(s - ptr) > (size_t)8)
  	    {
  		s = ptr + 8;
  		*s = '\0';
***************
*** 6460,6470 ****
   * return 2 if a message has been displayed.
   * return 0 otherwise.
   */
- /*ARGSUSED*/
      int
  buf_check_timestamp(buf, focus)
      buf_T	*buf;
!     int		focus;		/* called for GUI focus event */
  {
      struct stat	st;
      int		stat_res;
--- 6468,6477 ----
   * return 2 if a message has been displayed.
   * return 0 otherwise.
   */
      int
  buf_check_timestamp(buf, focus)
      buf_T	*buf;
!     int		focus UNUSED;	/* called for GUI focus event */
  {
      struct stat	st;
      int		stat_res;
***************
*** 6868,6879 ****
      /* Careful: autocommands may have made "buf" invalid! */
  }
  
- /*ARGSUSED*/
      void
  buf_store_time(buf, st, fname)
      buf_T	*buf;
      struct stat	*st;
!     char_u	*fname;
  {
      buf->b_mtime = (long)st->st_mtime;
      buf->b_orig_size = (size_t)st->st_size;
--- 6875,6885 ----
      /* Careful: autocommands may have made "buf" invalid! */
  }
  
      void
  buf_store_time(buf, st, fname)
      buf_T	*buf;
      struct stat	*st;
!     char_u	*fname UNUSED;
  {
      buf->b_mtime = (long)st->st_mtime;
      buf->b_orig_size = (size_t)st->st_size;
***************
*** 6936,6945 ****
   * The returned pointer is to allocated memory.
   * The returned pointer is NULL if no valid name was found.
   */
- /*ARGSUSED*/
      char_u  *
  vim_tempname(extra_char)
!     int	    extra_char;	    /* character to use in the name instead of '?' */
  {
  #ifdef USE_TMPNAM
      char_u	itmp[L_tmpnam];	/* use tmpnam() */
--- 6942,6950 ----
   * The returned pointer is to allocated memory.
   * The returned pointer is NULL if no valid name was found.
   */
      char_u  *
  vim_tempname(extra_char)
!     int	    extra_char UNUSED;  /* char to use in the name instead of '?' */
  {
  #ifdef USE_TMPNAM
      char_u	itmp[L_tmpnam];	/* use tmpnam() */
***************
*** 6968,6974 ****
  	/*
  	 * Try the entries in TEMPDIRNAMES to create the temp directory.
  	 */
! 	for (i = 0; i < sizeof(tempdirs) / sizeof(char *); ++i)
  	{
  	    /* expand $TMP, leave room for "/v1100000/999999999" */
  	    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);
--- 6973,6979 ----
  	/*
  	 * Try the entries in TEMPDIRNAMES to create the temp directory.
  	 */
! 	for (i = 0; i < (int)(sizeof(tempdirs) / sizeof(char *)); ++i)
  	{
  	    /* expand $TMP, leave room for "/v1100000/999999999" */
  	    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);
***************
*** 9588,9600 ****
   *
   * Returns NULL when out of memory.
   */
- /*ARGSUSED*/
      char_u *
  file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)
      char_u	*pat;
      char_u	*pat_end;	/* first char after pattern or NULL */
      char	*allow_dirs;	/* Result passed back out in here */
!     int		no_bslash;	/* Don't use a backward slash as pathsep */
  {
      int		size;
      char_u	*endp;
--- 9593,9604 ----
   *
   * Returns NULL when out of memory.
   */
      char_u *
  file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)
      char_u	*pat;
      char_u	*pat_end;	/* first char after pattern or NULL */
      char	*allow_dirs;	/* Result passed back out in here */
!     int		no_bslash UNUSED; /* Don't use a backward slash as pathsep */
  {
      int		size;
      char_u	*endp;
*** ../vim-7.2.173/src/misc1.c	2009-04-29 11:00:09.000000000 +0200
--- src/misc1.c	2009-05-15 20:59:08.000000000 +0200
***************
*** 2188,2199 ****
   *
   * return FAIL for failure, OK otherwise
   */
- /*ARGSUSED*/
      int
  del_bytes(count, fixpos_arg, use_delcombine)
      long	count;
      int		fixpos_arg;
!     int		use_delcombine;	    /* 'delcombine' option applies */
  {
      char_u	*oldp, *newp;
      colnr_T	oldlen;
--- 2188,2198 ----
   *
   * return FAIL for failure, OK otherwise
   */
      int
  del_bytes(count, fixpos_arg, use_delcombine)
      long	count;
      int		fixpos_arg;
!     int		use_delcombine UNUSED;	    /* 'delcombine' option applies */
  {
      char_u	*oldp, *newp;
      colnr_T	oldlen;
*** ../vim-7.2.173/src/move.c	2008-11-15 16:05:30.000000000 +0100
--- src/move.c	2009-05-15 21:00:06.000000000 +0200
***************
*** 1238,1248 ****
  /*
   * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
   */
- /*ARGSUSED*/
      void
  scrolldown(line_count, byfold)
      long	line_count;
!     int		byfold;		/* TRUE: count a closed fold as one line */
  {
      long	done = 0;	/* total # of physical lines done */
      int		wrow;
--- 1238,1247 ----
  /*
   * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
   */
      void
  scrolldown(line_count, byfold)
      long	line_count;
!     int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
  {
      long	done = 0;	/* total # of physical lines done */
      int		wrow;
***************
*** 1349,1359 ****
  /*
   * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
   */
- /*ARGSUSED*/
      void
  scrollup(line_count, byfold)
      long	line_count;
!     int		byfold;		/* TRUE: count a closed fold as one line */
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
      linenr_T	lnum;
--- 1348,1357 ----
  /*
   * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
   */
      void
  scrollup(line_count, byfold)
      long	line_count;
!     int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
      linenr_T	lnum;
*** ../vim-7.2.173/src/normal.c	2009-04-29 17:39:17.000000000 +0200
--- src/normal.c	2009-05-15 21:08:07.000000000 +0200
***************
*** 493,506 ****
      int		i;
  
      /* Fill the index table with a one to one relation. */
!     for (i = 0; i < NV_CMDS_SIZE; ++i)
  	nv_cmd_idx[i] = i;
  
      /* Sort the commands by the command character.  */
      qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);
  
      /* Find the first entry that can't be indexed by the command character. */
!     for (i = 0; i < NV_CMDS_SIZE; ++i)
  	if (i != nv_cmds[nv_cmd_idx[i]].cmd_char)
  	    break;
      nv_max_linear = i - 1;
--- 493,506 ----
      int		i;
  
      /* Fill the index table with a one to one relation. */
!     for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
  	nv_cmd_idx[i] = i;
  
      /* Sort the commands by the command character.  */
      qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);
  
      /* Find the first entry that can't be indexed by the command character. */
!     for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
  	if (i != nv_cmds[nv_cmd_idx[i]].cmd_char)
  	    break;
      nv_max_linear = i - 1;
***************
*** 561,571 ****
  /*
   * Execute a command in Normal mode.
   */
- /*ARGSUSED*/
      void
  normal_cmd(oap, toplevel)
      oparg_T	*oap;
!     int		toplevel;		/* TRUE when called from main() */
  {
      cmdarg_T	ca;			/* command arguments */
      int		c;
--- 561,570 ----
  /*
   * Execute a command in Normal mode.
   */
      void
  normal_cmd(oap, toplevel)
      oparg_T	*oap;
!     int		toplevel UNUSED;	/* TRUE when called from main() */
  {
      cmdarg_T	ca;			/* command arguments */
      int		c;
***************
*** 2188,2197 ****
  /*
   * Handle the "g@" operator: call 'operatorfunc'.
   */
- /*ARGSUSED*/
      static void
  op_function(oap)
!     oparg_T	*oap;
  {
  #ifdef FEAT_EVAL
      char_u	*(argv[1]);
--- 2187,2195 ----
  /*
   * Handle the "g@" operator: call 'operatorfunc'.
   */
      static void
  op_function(oap)
!     oparg_T	*oap UNUSED;
  {
  #ifdef FEAT_EVAL
      char_u	*(argv[1]);
***************
*** 4100,4109 ****
   * Command character that doesn't do anything, but unlike nv_ignore() does
   * start edit().  Used for "startinsert" executed while starting up.
   */
- /*ARGSUSED */
      static void
  nv_nop(cap)
!     cmdarg_T	*cap;
  {
  }
  
--- 4098,4106 ----
   * Command character that doesn't do anything, but unlike nv_ignore() does
   * start edit().  Used for "startinsert" executed while starting up.
   */
      static void
  nv_nop(cap)
!     cmdarg_T	*cap UNUSED;
  {
  }
  
***************
*** 5241,5247 ****
  	if (cap->oap->op_type != OP_NOP
  		&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count
  		    || cap->oap->start.col >
! 					 STRLEN(ml_get(cap->oap->start.lnum))))
  	    clearopbeep(cap->oap);
      }
  }
--- 5238,5244 ----
  	if (cap->oap->op_type != OP_NOP
  		&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count
  		    || cap->oap->start.col >
! 			       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))))
  	    clearopbeep(cap->oap);
      }
  }
***************
*** 5816,5822 ****
      for (n = cap->count1; n > 0; --n)
      {
  	if ((!PAST_LINE && oneright() == FAIL)
! 		|| (PAST_LINE && *ml_get_cursor() == NUL))
  	{
  	    /*
  	     *	  <Space> wraps to next line if 'whichwrap' has 's'.
--- 5813,5822 ----
      for (n = cap->count1; n > 0; --n)
      {
  	if ((!PAST_LINE && oneright() == FAIL)
! #ifdef FEAT_VISUAL
! 		|| (PAST_LINE && *ml_get_cursor() == NUL)
! #endif
! 		)
  	{
  	    /*
  	     *	  <Space> wraps to next line if 'whichwrap' has 's'.
*** ../vim-7.2.173/src/option.c	2009-03-18 15:40:03.000000000 +0100
--- src/option.c	2009-05-15 21:08:50.000000000 +0200
***************
*** 5302,5315 ****
   * When "set_sid" is zero set the scriptID to current_SID.  When "set_sid" is
   * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
   */
- /*ARGSUSED*/
      void
  set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)
      char_u	*name;
      int		opt_idx;
      char_u	*val;
      int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
!     int		set_sid;
  {
      char_u	*s;
      char_u	**varp;
--- 5302,5314 ----
   * When "set_sid" is zero set the scriptID to current_SID.  When "set_sid" is
   * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
   */
      void
  set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)
      char_u	*name;
      int		opt_idx;
      char_u	*val;
      int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
!     int		set_sid UNUSED;
  {
      char_u	*s;
      char_u	**varp;
***************
*** 9357,9366 ****
  /*
   * Check for NULL pointers in a winopt_T and replace them with empty_option.
   */
- /*ARGSUSED*/
      void
  check_winopt(wop)
!     winopt_T	*wop;
  {
  #ifdef FEAT_FOLDING
      check_string_option(&wop->wo_fdi);
--- 9356,9364 ----
  /*
   * Check for NULL pointers in a winopt_T and replace them with empty_option.
   */
      void
  check_winopt(wop)
!     winopt_T	*wop UNUSED;
  {
  #ifdef FEAT_FOLDING
      check_string_option(&wop->wo_fdi);
***************
*** 9382,9391 ****
  /*
   * Free the allocated memory inside a winopt_T.
   */
- /*ARGSUSED*/
      void
  clear_winopt(wop)
!     winopt_T	*wop;
  {
  #ifdef FEAT_FOLDING
      clear_string_option(&wop->wo_fdi);
--- 9380,9388 ----
  /*
   * Free the allocated memory inside a winopt_T.
   */
      void
  clear_winopt(wop)
!     winopt_T	*wop UNUSED;
  {
  #ifdef FEAT_FOLDING
      clear_string_option(&wop->wo_fdi);
*** ../vim-7.2.173/src/os_unix.c	2009-05-13 12:46:36.000000000 +0200
--- src/os_unix.c	2009-05-15 21:13:43.000000000 +0200
***************
*** 458,467 ****
   * Return total amount of memory available in Kbyte.
   * Doesn't change when memory has been allocated.
   */
- /* ARGSUSED */
      long_u
  mch_total_mem(special)
!     int special;
  {
  # ifdef __EMX__
      return ulimit(3, 0L) >> 10;   /* always 32MB? */
--- 458,466 ----
   * Return total amount of memory available in Kbyte.
   * Doesn't change when memory has been allocated.
   */
      long_u
  mch_total_mem(special)
!     int special UNUSED;
  {
  # ifdef __EMX__
      return ulimit(3, 0L) >> 10;   /* always 32MB? */
***************
*** 815,821 ****
   * Let me try it with a few tricky defines from my own osdef.h	(jw).
   */
  #if defined(SIGWINCH)
- /* ARGSUSED */
      static RETSIGTYPE
  sig_winch SIGDEFARG(sigarg)
  {
--- 814,819 ----
***************
*** 1355,1365 ****
  /*
   * Check_win checks whether we have an interactive stdout.
   */
- /* ARGSUSED */
      int
  mch_check_win(argc, argv)
!     int	    argc;
!     char    **argv;
  {
  #ifdef OS2
      /*
--- 1353,1362 ----
  /*
   * Check_win checks whether we have an interactive stdout.
   */
      int
  mch_check_win(argc, argv)
!     int	    argc UNUSED;
!     char    **argv UNUSED;
  {
  #ifdef OS2
      /*
***************
*** 2467,2473 ****
      }
  
      /* Catch file names which are too long. */
!     if (retval == FAIL || STRLEN(buf) + STRLEN(fname) >= len)
  	return FAIL;
  
      /* Do not append ".", "/dir/." is equal to "/dir". */
--- 2464,2470 ----
      }
  
      /* Catch file names which are too long. */
!     if (retval == FAIL || (int)(STRLEN(buf) + STRLEN(fname)) >= len)
  	return FAIL;
  
      /* Do not append ".", "/dir/." is equal to "/dir". */
***************
*** 2686,2692 ****
   */
      vim_acl_T
  mch_get_acl(fname)
!     char_u	*fname;
  {
      vim_acl_T	ret = NULL;
  #ifdef HAVE_POSIX_ACL
--- 2683,2689 ----
   */
      vim_acl_T
  mch_get_acl(fname)
!     char_u	*fname UNUSED;
  {
      vim_acl_T	ret = NULL;
  #ifdef HAVE_POSIX_ACL
***************
*** 2746,2752 ****
   */
      void
  mch_set_acl(fname, aclent)
!     char_u	*fname;
      vim_acl_T	aclent;
  {
      if (aclent == NULL)
--- 2743,2749 ----
   */
      void
  mch_set_acl(fname, aclent)
!     char_u	*fname UNUSED;
      vim_acl_T	aclent;
  {
      if (aclent == NULL)
***************
*** 2789,2798 ****
  /*
   * Set hidden flag for "name".
   */
- /* ARGSUSED */
      void
  mch_hide(name)
!     char_u	*name;
  {
      /* can't hide a file */
  }
--- 2786,2794 ----
  /*
   * Set hidden flag for "name".
   */
      void
  mch_hide(name)
!     char_u	*name UNUSED;
  {
      /* can't hide a file */
  }
***************
*** 3481,3490 ****
  /*
   * set screen mode, always fails.
   */
- /* ARGSUSED */
      int
  mch_screenmode(arg)
!     char_u   *arg;
  {
      EMSG(_(e_screenmode));
      return FAIL;
--- 3477,3485 ----
  /*
   * set screen mode, always fails.
   */
      int
  mch_screenmode(arg)
!     char_u   *arg UNUSED;
  {
      EMSG(_(e_screenmode));
      return FAIL;
***************
*** 4189,4197 ****
  			    {
  				s = vim_strchr(lp + written, NL);
  				len = write(toshell_fd, (char *)lp + written,
! 					   s == NULL ? l : s - (lp + written));
  			    }
! 			    if (len == l)
  			    {
  				/* Finished a line, add a NL, unless this line
  				 * should not have one. */
--- 4184,4193 ----
  			    {
  				s = vim_strchr(lp + written, NL);
  				len = write(toshell_fd, (char *)lp + written,
! 					   s == NULL ? l
! 					      : (size_t)(s - (lp + written)));
  			    }
! 			    if (len == (int)l)
  			    {
  				/* Finished a line, add a NL, unless this line
  				 * should not have one. */
***************
*** 4746,4752 ****
   * Returns also, when a request from Sniff is waiting -- toni.
   * Or when a Linux GPM mouse event is waiting.
   */
- /* ARGSUSED */
  #if defined(__BEOS__)
      int
  #else
--- 4742,4747 ----
***************
*** 4755,4761 ****
  RealWaitForChar(fd, msec, check_for_gpm)
      int		fd;
      long	msec;
!     int		*check_for_gpm;
  {
      int		ret;
  #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
--- 4750,4756 ----
  RealWaitForChar(fd, msec, check_for_gpm)
      int		fd;
      long	msec;
!     int		*check_for_gpm UNUSED;
  {
      int		ret;
  #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
***************
*** 5572,5578 ****
      i = fread((char *)buffer, 1, len, fd);
      fclose(fd);
      mch_remove(tempname);
!     if (i != len)
      {
  	/* unexpected read error */
  	EMSG2(_(e_notread), tempname);
--- 5567,5573 ----
      i = fread((char *)buffer, 1, len, fd);
      fclose(fd);
      mch_remove(tempname);
!     if (i != (int)len)
      {
  	/* unexpected read error */
  	EMSG2(_(e_notread), tempname);
***************
*** 5633,5639 ****
  	if (shell_style == STYLE_PRINT && !did_find_nul)
  	{
  	    /* If there is a NUL, set did_find_nul, else set check_spaces */
! 	    if (len && (int)STRLEN(buffer) < len - 1)
  		did_find_nul = TRUE;
  	    else
  		check_spaces = TRUE;
--- 5628,5634 ----
  	if (shell_style == STYLE_PRINT && !did_find_nul)
  	{
  	    /* If there is a NUL, set did_find_nul, else set check_spaces */
! 	    if (len && (int)STRLEN(buffer) < (int)len - 1)
  		did_find_nul = TRUE;
  	    else
  		check_spaces = TRUE;
*** ../vim-7.2.173/src/os_unix.h	2009-05-13 12:46:36.000000000 +0200
--- src/os_unix.h	2009-05-15 21:10:31.000000000 +0200
***************
*** 126,132 ****
  #  define SIGDUMMYARG	0, 0, (struct sigcontext *)0
  # else
  #  define SIGPROTOARG	(int)
! #  define SIGDEFARG(s)	(s) int s;
  #  define SIGDUMMYARG	0
  # endif
  #else
--- 126,132 ----
  #  define SIGDUMMYARG	0, 0, (struct sigcontext *)0
  # else
  #  define SIGPROTOARG	(int)
! #  define SIGDEFARG(s)	(s) int s UNUSED;
  #  define SIGDUMMYARG	0
  # endif
  #else
*** ../vim-7.2.173/src/regexp.c	2009-02-21 22:03:06.000000000 +0100
--- src/regexp.c	2009-05-15 21:14:18.000000000 +0200
***************
*** 471,477 ****
  
      if ((*pp)[1] == ':')
      {
! 	for (i = 0; i < sizeof(class_names) / sizeof(*class_names); ++i)
  	    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)
  	    {
  		*pp += STRLEN(class_names[i]) + 2;
--- 471,477 ----
  
      if ((*pp)[1] == ':')
      {
! 	for (i = 0; i < (int)(sizeof(class_names) / sizeof(*class_names)); ++i)
  	    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)
  	    {
  		*pp += STRLEN(class_names[i]) + 2;
***************
*** 3362,3373 ****
   * Match a regexp against a string ("line" points to the string) or multiple
   * lines ("line" is NULL, use reg_getline()).
   */
- /*ARGSUSED*/
      static long
  vim_regexec_both(line, col, tm)
      char_u	*line;
      colnr_T	col;		/* column to start looking for match */
!     proftime_T	*tm;		/* timeout limit or NULL */
  {
      regprog_T	*prog;
      char_u	*s;
--- 3362,3372 ----
   * Match a regexp against a string ("line" points to the string) or multiple
   * lines ("line" is NULL, use reg_getline()).
   */
      static long
  vim_regexec_both(line, col, tm)
      char_u	*line;
      colnr_T	col;		/* column to start looking for match */
!     proftime_T	*tm UNUSED;	/* timeout limit or NULL */
  {
      regprog_T	*prog;
      char_u	*s;
*** ../vim-7.2.173/src/search.c	2009-04-22 18:43:06.000000000 +0200
--- src/search.c	2009-05-15 21:16:36.000000000 +0200
***************
*** 522,528 ****
   * When FEAT_EVAL is defined, returns the index of the first matching
   * subpattern plus one; one if there was none.
   */
- /*ARGSUSED*/
      int
  searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum, tm)
      win_T	*win;		/* window to search in; can be NULL for a
--- 522,527 ----
***************
*** 535,541 ****
      int		options;
      int		pat_use;	/* which pattern to use when "pat" is empty */
      linenr_T	stop_lnum;	/* stop after this line number when != 0 */
!     proftime_T	*tm;		/* timeout limit or NULL */
  {
      int		found;
      linenr_T	lnum;		/* no init to shut up Apollo cc */
--- 534,540 ----
      int		options;
      int		pat_use;	/* which pattern to use when "pat" is empty */
      linenr_T	stop_lnum;	/* stop after this line number when != 0 */
!     proftime_T	*tm UNUSED;	/* timeout limit or NULL */
  {
      int		found;
      linenr_T	lnum;		/* no init to shut up Apollo cc */
***************
*** 554,561 ****
      int		save_called_emsg = called_emsg;
  #ifdef FEAT_SEARCH_EXTRA
      int		break_loop = FALSE;
- #else
- # define break_loop FALSE
  #endif
  
      if (search_regcomp(pat, RE_SEARCH, pat_use,
--- 553,558 ----
***************
*** 940,946 ****
  	     * twice.
  	     */
  	    if (!p_ws || stop_lnum != 0 || got_int || called_emsg
! 					       || break_loop || found || loop)
  		break;
  
  	    /*
--- 937,946 ----
  	     * twice.
  	     */
  	    if (!p_ws || stop_lnum != 0 || got_int || called_emsg
! #ifdef FEAT_SEARCH_EXTRA
! 					       || break_loop
! #endif
! 					       || found || loop)
  		break;
  
  	    /*
***************
*** 958,964 ****
  		give_warning((char_u *)_(dir == BACKWARD
  					  ? top_bot_msg : bot_top_msg), TRUE);
  	}
! 	if (got_int || called_emsg || break_loop)
  	    break;
      }
      while (--count > 0 && found);   /* stop after count matches or no match */
--- 958,968 ----
  		give_warning((char_u *)_(dir == BACKWARD
  					  ? top_bot_msg : bot_top_msg), TRUE);
  	}
! 	if (got_int || called_emsg
! #ifdef FEAT_SEARCH_EXTRA
! 		|| break_loop
! #endif
! 		)
  	    break;
      }
      while (--count > 0 && found);   /* stop after count matches or no match */
*** ../vim-7.2.173/src/tag.c	2009-02-23 00:53:35.000000000 +0100
--- src/tag.c	2009-05-15 21:16:59.000000000 +0200
***************
*** 1105,1114 ****
  /*
   * Print the tag stack
   */
- /*ARGSUSED*/
      void
  do_tags(eap)
!     exarg_T	*eap;
  {
      int		i;
      char_u	*name;
--- 1105,1113 ----
  /*
   * Print the tag stack
   */
      void
  do_tags(eap)
!     exarg_T	*eap UNUSED;
  {
      int		i;
      char_u	*name;
***************
*** 2530,2540 ****
   * Callback function for finding all "tags" and "tags-??" files in
   * 'runtimepath' doc directories.
   */
- /*ARGSUSED*/
      static void
  found_tagfile_cb(fname, cookie)
      char_u	*fname;
!     void	*cookie;
  {
      if (ga_grow(&tag_fnames, 1) == OK)
  	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
--- 2529,2538 ----
   * Callback function for finding all "tags" and "tags-??" files in
   * 'runtimepath' doc directories.
   */
      static void
  found_tagfile_cb(fname, cookie)
      char_u	*fname;
!     void	*cookie UNUSED;
  {
      if (ga_grow(&tag_fnames, 1) == OK)
  	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
*** ../vim-7.2.173/src/version.c	2009-05-14 22:19:19.000000000 +0200
--- src/version.c	2009-05-15 21:21:44.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     174,
  /**/

-- 
TERRY GILLIAM PLAYED: PATSY (ARTHUR'S TRUSTY STEED), THE GREEN KNIGHT
                      SOOTHSAYER, BRIDGEKEEPER, SIR GAWAIN (THE FIRST TO BE
                      KILLED BY THE RABBIT)
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.175
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.175
Problem:    Compiler warning in OpenBSD.
Solution:   Add type cast for NULL. (Dasn)
Files:	    src/if_cscope.c


*** ../vim-7.2.174/src/if_cscope.c	2009-04-22 16:22:44.000000000 +0200
--- src/if_cscope.c	2009-05-16 16:15:03.000000000 +0200
***************
*** 994,1000 ****
  	vim_free(ppath);
  
  #if defined(UNIX)
! 	if (execl("/bin/sh", "sh", "-c", cmd, NULL) == -1)
  	    PERROR(_("cs_create_connection exec failed"));
  
  	exit(127);
--- 994,1000 ----
  	vim_free(ppath);
  
  #if defined(UNIX)
! 	if (execl("/bin/sh", "sh", "-c", cmd, (char *)NULL) == -1)
  	    PERROR(_("cs_create_connection exec failed"));
  
  	exit(127);
*** ../vim-7.2.174/src/version.c	2009-05-15 21:31:11.000000000 +0200
--- src/version.c	2009-05-16 16:13:15.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     175,
  /**/

-- 
Every time I lose weight, it finds me again!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.176
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.176
Problem:    Exceptions for splint are not useful.
Solution:   Remove the S_SPLINT_S ifdefs.
Files:	    src/edit.c, src/ex_cmds.c, src/ex_docmd.c, src/os_unix.c,
	    src/os_unix.h, src/os_unixx.h, src/structs.h, src/term.h


*** ../vim-7.2.175/src/edit.c	2009-05-15 21:31:11.000000000 +0200
--- src/edit.c	2009-05-16 16:18:35.000000000 +0200
***************
*** 69,79 ****
      compl_T	*cp_prev;
      char_u	*cp_str;	/* matched text */
      char	cp_icase;	/* TRUE or FALSE: ignore case */
- #ifdef S_SPLINT_S  /* splint can't handle array of pointers */
-     char_u	**cp_text;	/* text for the menu */
- #else
      char_u	*(cp_text[CPT_COUNT]);	/* text for the menu */
- #endif
      char_u	*cp_fname;	/* file containing the match, allocated when
  				 * cp_flags has FREE_FNAME */
      int		cp_flags;	/* ORIGINAL_TEXT, CONT_S_IPOS or FREE_FNAME */
--- 69,75 ----
***************
*** 3835,3845 ****
      char_u	*word;
      int		icase = FALSE;
      int		adup = FALSE;
- #ifdef S_SPLINT_S  /* splint doesn't parse array of pointers correctly */
-     char_u	**cptext;
- #else
      char_u	*(cptext[CPT_COUNT]);
- #endif
  
      if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)
      {
--- 3831,3837 ----
*** ../vim-7.2.175/src/ex_cmds.c	2009-05-15 21:31:11.000000000 +0200
--- src/ex_cmds.c	2009-05-16 16:18:56.000000000 +0200
***************
*** 5776,5785 ****
  {
      char_u	*s, *d;
      int		i;
- #ifdef S_SPLINT_S  /* splint doesn't understand array of pointers */
-     static char **mtable;
-     static char **rtable;
- #else
      static char *(mtable[]) = {"*", "g*", "[*", "]*", ":*",
  			       "/*", "/\\*", "\"*", "**",
  			       "/\\(\\)",
--- 5776,5781 ----
***************
*** 5794,5800 ****
  			       "/\\\\?", "/\\\\z(\\\\)", "\\\\=", ":s\\\\=",
  			       "\\[count]", "\\[quotex]", "\\[range]",
  			       "\\[pattern]", "\\\\bar", "/\\\\%\\$"};
- #endif
      int flags;
  
      d = IObuff;		    /* assume IObuff is long enough! */
--- 5790,5795 ----
*** ../vim-7.2.175/src/ex_docmd.c	2009-05-15 21:31:11.000000000 +0200
--- src/ex_docmd.c	2009-05-16 16:19:26.000000000 +0200
***************
*** 9395,9407 ****
  {
      int		len;
      int		i;
! #ifdef S_SPLINT_S  /* splint can't handle array of pointers */
!     static char **spec_str;
!     static char *(nospec_str[])
! #else
!     static char *(spec_str[])
! #endif
! 	= {
  		    "%",
  #define SPEC_PERC   0
  		    "#",
--- 9395,9401 ----
  {
      int		len;
      int		i;
!     static char *(spec_str[]) = {
  		    "%",
  #define SPEC_PERC   0
  		    "#",
*** ../vim-7.2.175/src/os_unix.c	2009-05-15 21:31:11.000000000 +0200
--- src/os_unix.c	2009-05-16 16:20:00.000000000 +0200
***************
*** 199,207 ****
  #endif
  
  #ifndef SIG_ERR
! # ifndef S_SPLINT_S
! #  define SIG_ERR	((RETSIGTYPE (*)())-1)
! # endif
  #endif
  
  /* volatile because it is used in signal handler sig_winch(). */
--- 199,205 ----
  #endif
  
  #ifndef SIG_ERR
! # define SIG_ERR	((RETSIGTYPE (*)())-1)
  #endif
  
  /* volatile because it is used in signal handler sig_winch(). */
***************
*** 443,451 ****
  
  #if defined(HAVE_TOTAL_MEM) || defined(PROTO)
  # ifdef HAVE_SYS_RESOURCE_H
! #  ifndef S_SPLINT_S  /* splint crashes on bits/resource.h */
! #   include <sys/resource.h>
! #  endif
  # endif
  # if defined(HAVE_SYS_SYSCTL_H) && defined(HAVE_SYSCTL)
  #  include <sys/sysctl.h>
--- 441,447 ----
  
  #if defined(HAVE_TOTAL_MEM) || defined(PROTO)
  # ifdef HAVE_SYS_RESOURCE_H
! #  include <sys/resource.h>
  # endif
  # if defined(HAVE_SYS_SYSCTL_H) && defined(HAVE_SYSCTL)
  #  include <sys/sysctl.h>
*** ../vim-7.2.175/src/os_unix.h	2009-05-15 21:31:11.000000000 +0200
--- src/os_unix.h	2009-05-16 16:17:22.000000000 +0200
***************
*** 53,61 ****
  #endif
  
  #ifdef HAVE_UNISTD_H
! # ifndef S_SPLINT_S  /* splint crashes on bits/confname.h */
! #  include <unistd.h>
! # endif
  #endif
  
  #ifdef HAVE_LIBC_H
--- 53,59 ----
  #endif
  
  #ifdef HAVE_UNISTD_H
! # include <unistd.h>
  #endif
  
  #ifdef HAVE_LIBC_H
*** ../vim-7.2.175/src/structs.h	2009-05-13 20:47:07.000000000 +0200
--- src/structs.h	2009-05-16 16:17:51.000000000 +0200
***************
*** 1646,1656 ****
  #endif
  #ifdef FEAT_DIFF
      diff_T	    *tp_first_diff;
- # ifdef S_SPLINT_S  /* splint doesn't understand the array of pointers */
-     buf_T	    **tp_diffbuf;
- # else
      buf_T	    *(tp_diffbuf[DB_COUNT]);
- # endif
      int		    tp_diff_invalid;	/* list of diffs is outdated */
  #endif
      frame_T	    *tp_snapshot;    /* window layout snapshot */
--- 1646,1652 ----
*** ../vim-7.2.175/src/term.h	2009-05-13 18:54:14.000000000 +0200
--- src/term.h	2009-05-16 16:20:06.000000000 +0200
***************
*** 96,106 ****
   * - there should be code in term.c to obtain the value from the termcap
   */
  
- #ifdef S_SPLINT_S  /* splint doesn't understand array of pointers */
- extern char_u **term_strings;    /* current terminal strings */
- #else
  extern char_u *(term_strings[]);    /* current terminal strings */
- #endif
  
  /*
   * strings used for terminal
--- 96,102 ----
*** ../vim-7.2.175/src/version.c	2009-05-16 16:15:39.000000000 +0200
--- src/version.c	2009-05-16 16:34:10.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     176,
  /**/

-- 
Corn oil comes from corn and olive oil comes from olives, so where
does baby oil come from?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.177
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.177
Problem:    Compiler warnings when using -Wextra
Solution:   Add UNUSED and type casts.
Files:	    src/eval.c, src/ex_docmd.c, src/ex_eval.c, src/ex_getln.c,
	    src/fileio.c, src/hardcopy.c, src/if_cscope.c, src/if_xcmdsrv.c,
	    src/farsi.c, src/mark.c, src/menu.c


*** ../vim-7.2.176/src/eval.c	2009-05-15 21:31:11.000000000 +0200
--- src/eval.c	2009-05-16 16:58:30.000000000 +0200
***************
*** 3772,3778 ****
   * Function given to ExpandGeneric() to obtain the list of user defined
   * (global/buffer/window/built-in) variable names.
   */
- /*ARGSUSED*/
      char_u *
  get_user_var_name(xp, idx)
      expand_T	*xp;
--- 3772,3777 ----
***************
*** 7787,7793 ****
   * Function given to ExpandGeneric() to obtain the list of internal or
   * user defined variable or function names.
   */
- /*ARGSUSED*/
      char_u *
  get_expr_name(xp, idx)
      expand_T	*xp;
--- 7786,7791 ----
***************
*** 8655,8664 ****
  /*
   * "byte2line(byte)" function
   */
- /*ARGSUSED*/
      static void
  f_byte2line(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifndef FEAT_BYTEOFF
--- 8653,8661 ----
  /*
   * "byte2line(byte)" function
   */
      static void
  f_byte2line(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifndef FEAT_BYTEOFF
***************
*** 8678,8684 ****
  /*
   * "byteidx()" function
   */
- /*ARGSUSED*/
      static void
  f_byteidx(argvars, rettv)
      typval_T	*argvars;
--- 8675,8680 ----
***************
*** 8852,8858 ****
      static void
  f_clearmatches(argvars, rettv)
      typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_SEARCH_EXTRA
      clear_matches(curwin);
--- 8848,8854 ----
      static void
  f_clearmatches(argvars, rettv)
      typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_SEARCH_EXTRA
      clear_matches(curwin);
***************
*** 8916,8926 ****
  /*
   * "complete()" function
   */
- /*ARGSUSED*/
      static void
  f_complete(argvars, rettv)
      typval_T	*argvars;
!     typval_T	*rettv;
  {
      int	    startcol;
  
--- 8912,8921 ----
  /*
   * "complete()" function
   */
      static void
  f_complete(argvars, rettv)
      typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      int	    startcol;
  
***************
*** 8951,8957 ****
  /*
   * "complete_add()" function
   */
- /*ARGSUSED*/
      static void
  f_complete_add(argvars, rettv)
      typval_T	*argvars;
--- 8946,8951 ----
***************
*** 8963,8972 ****
  /*
   * "complete_check()" function
   */
- /*ARGSUSED*/
      static void
  f_complete_check(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      int		saved = RedrawingDisabled;
--- 8957,8965 ----
  /*
   * "complete_check()" function
   */
      static void
  f_complete_check(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      int		saved = RedrawingDisabled;
***************
*** 8981,8991 ****
  /*
   * "confirm(message, buttons[, default [, type]])" function
   */
- /*ARGSUSED*/
      static void
  f_confirm(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
      char_u	*message;
--- 8974,8983 ----
  /*
   * "confirm(message, buttons[, default [, type]])" function
   */
      static void
  f_confirm(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
      char_u	*message;
***************
*** 9150,9160 ****
   *
   * Checks the existence of a cscope connection.
   */
- /*ARGSUSED*/
      static void
  f_cscope_connection(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_CSCOPE
      int		num = 0;
--- 9142,9151 ----
   *
   * Checks the existence of a cscope connection.
   */
      static void
  f_cscope_connection(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_CSCOPE
      int		num = 0;
***************
*** 9181,9187 ****
   * Moves the cursor to the specified line and column.
   * Returns 0 when the position could be set, -1 otherwise.
   */
- /*ARGSUSED*/
      static void
  f_cursor(argvars, rettv)
      typval_T	*argvars;
--- 9172,9177 ----
***************
*** 9275,9285 ****
  /*
   * "did_filetype()" function
   */
- /*ARGSUSED*/
      static void
  f_did_filetype(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_AUTOCMD
      rettv->vval.v_number = did_filetype;
--- 9265,9274 ----
  /*
   * "did_filetype()" function
   */
      static void
  f_did_filetype(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_AUTOCMD
      rettv->vval.v_number = did_filetype;
***************
*** 9289,9299 ****
  /*
   * "diff_filler()" function
   */
- /*ARGSUSED*/
      static void
  f_diff_filler(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_DIFF
      rettv->vval.v_number = diff_check_fill(curwin, get_tv_lnum(argvars));
--- 9278,9287 ----
  /*
   * "diff_filler()" function
   */
      static void
  f_diff_filler(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_DIFF
      rettv->vval.v_number = diff_check_fill(curwin, get_tv_lnum(argvars));
***************
*** 9303,9313 ****
  /*
   * "diff_hlID()" function
   */
- /*ARGSUSED*/
      static void
  f_diff_hlID(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_DIFF
      linenr_T		lnum = get_tv_lnum(argvars);
--- 9291,9300 ----
  /*
   * "diff_hlID()" function
   */
      static void
  f_diff_hlID(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_DIFF
      linenr_T		lnum = get_tv_lnum(argvars);
***************
*** 9420,9426 ****
  /*
   * "eval()" function
   */
- /*ARGSUSED*/
      static void
  f_eval(argvars, rettv)
      typval_T	*argvars;
--- 9407,9412 ----
***************
*** 9444,9453 ****
  /*
   * "eventhandler()" function
   */
- /*ARGSUSED*/
      static void
  f_eventhandler(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = vgetc_busy;
--- 9430,9438 ----
  /*
   * "eventhandler()" function
   */
      static void
  f_eventhandler(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = vgetc_busy;
***************
*** 9704,9714 ****
  /*
   * "feedkeys()" function
   */
- /*ARGSUSED*/
      static void
  f_feedkeys(argvars, rettv)
      typval_T    *argvars;
!     typval_T    *rettv;
  {
      int		remap = TRUE;
      char_u	*keys, *flags;
--- 9689,9698 ----
  /*
   * "feedkeys()" function
   */
      static void
  f_feedkeys(argvars, rettv)
      typval_T    *argvars;
!     typval_T    *rettv UNUSED;
  {
      int		remap = TRUE;
      char_u	*keys, *flags;
***************
*** 10210,10219 ****
  /*
   * "foldtext()" function
   */
- /*ARGSUSED*/
      static void
  f_foldtext(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_FOLDING
--- 10194,10202 ----
  /*
   * "foldtext()" function
   */
      static void
  f_foldtext(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_FOLDING
***************
*** 10278,10287 ****
  /*
   * "foldtextresult(lnum)" function
   */
- /*ARGSUSED*/
      static void
  f_foldtextresult(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_FOLDING
--- 10261,10269 ----
  /*
   * "foldtextresult(lnum)" function
   */
      static void
  f_foldtextresult(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_FOLDING
***************
*** 10314,10324 ****
  /*
   * "foreground()" function
   */
- /*ARGSUSED*/
      static void
  f_foreground(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
--- 10296,10305 ----
  /*
   * "foreground()" function
   */
      static void
  f_foreground(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 10333,10339 ****
  /*
   * "function()" function
   */
- /*ARGSUSED*/
      static void
  f_function(argvars, rettv)
      typval_T	*argvars;
--- 10314,10319 ----
***************
*** 10357,10367 ****
  /*
   * "garbagecollect()" function
   */
- /*ARGSUSED*/
      static void
  f_garbagecollect(argvars, rettv)
      typval_T	*argvars;
!     typval_T	*rettv;
  {
      /* This is postponed until we are back at the toplevel, because we may be
       * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
--- 10337,10346 ----
  /*
   * "garbagecollect()" function
   */
      static void
  f_garbagecollect(argvars, rettv)
      typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      /* This is postponed until we are back at the toplevel, because we may be
       * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
***************
*** 10664,10673 ****
  /*
   * "getcharmod()" function
   */
- /*ARGSUSED*/
      static void
  f_getcharmod(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = mod_mask;
--- 10643,10651 ----
  /*
   * "getcharmod()" function
   */
      static void
  f_getcharmod(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = mod_mask;
***************
*** 10676,10685 ****
  /*
   * "getcmdline()" function
   */
- /*ARGSUSED*/
      static void
  f_getcmdline(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
--- 10654,10662 ----
  /*
   * "getcmdline()" function
   */
      static void
  f_getcmdline(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
***************
*** 10689,10698 ****
  /*
   * "getcmdpos()" function
   */
- /*ARGSUSED*/
      static void
  f_getcmdpos(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = get_cmdline_pos() + 1;
--- 10666,10674 ----
  /*
   * "getcmdpos()" function
   */
      static void
  f_getcmdpos(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = get_cmdline_pos() + 1;
***************
*** 10701,10710 ****
  /*
   * "getcmdtype()" function
   */
- /*ARGSUSED*/
      static void
  f_getcmdtype(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
--- 10677,10685 ----
  /*
   * "getcmdtype()" function
   */
      static void
  f_getcmdtype(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
***************
*** 10719,10728 ****
  /*
   * "getcwd()" function
   */
- /*ARGSUSED*/
      static void
  f_getcwd(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      char_u	cwd[MAXPATHL];
--- 10694,10702 ----
  /*
   * "getcwd()" function
   */
      static void
  f_getcwd(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      char_u	cwd[MAXPATHL];
***************
*** 10743,10752 ****
  /*
   * "getfontname()" function
   */
- /*ARGSUSED*/
      static void
  f_getfontname(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
--- 10717,10725 ----
  /*
   * "getfontname()" function
   */
      static void
  f_getfontname(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
***************
*** 10973,10982 ****
  /*
   * "getmatches()" function
   */
- /*ARGSUSED*/
      static void
  f_getmatches(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_SEARCH_EXTRA
--- 10946,10954 ----
  /*
   * "getmatches()" function
   */
      static void
  f_getmatches(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_SEARCH_EXTRA
***************
*** 11004,11013 ****
  /*
   * "getpid()" function
   */
- /*ARGSUSED*/
      static void
  f_getpid(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = mch_get_pid();
--- 10976,10984 ----
  /*
   * "getpid()" function
   */
      static void
  f_getpid(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = mch_get_pid();
***************
*** 11051,11061 ****
  /*
   * "getqflist()" and "getloclist()" functions
   */
- /*ARGSUSED*/
      static void
  f_getqflist(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_QUICKFIX
      win_T	*wp;
--- 11022,11031 ----
  /*
   * "getqflist()" and "getloclist()" functions
   */
      static void
  f_getqflist(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_QUICKFIX
      win_T	*wp;
***************
*** 11170,11179 ****
  /*
   * "getwinposx()" function
   */
- /*ARGSUSED*/
      static void
  f_getwinposx(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = -1;
--- 11140,11148 ----
  /*
   * "getwinposx()" function
   */
      static void
  f_getwinposx(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = -1;
***************
*** 11191,11200 ****
  /*
   * "getwinposy()" function
   */
- /*ARGSUSED*/
      static void
  f_getwinposy(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = -1;
--- 11160,11168 ----
  /*
   * "getwinposy()" function
   */
      static void
  f_getwinposy(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = -1;
***************
*** 11921,11930 ****
  /*
   * "haslocaldir()" function
   */
- /*ARGSUSED*/
      static void
  f_haslocaldir(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = (curwin->w_localdir != NULL);
--- 11889,11897 ----
  /*
   * "haslocaldir()" function
   */
      static void
  f_haslocaldir(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = (curwin->w_localdir != NULL);
***************
*** 11962,11971 ****
  /*
   * "histadd()" function
   */
- /*ARGSUSED*/
      static void
  f_histadd(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_CMDHIST
--- 11929,11937 ----
  /*
   * "histadd()" function
   */
      static void
  f_histadd(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_CMDHIST
***************
*** 11996,12006 ****
  /*
   * "histdel()" function
   */
- /*ARGSUSED*/
      static void
  f_histdel(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_CMDHIST
      int		n;
--- 11962,11971 ----
  /*
   * "histdel()" function
   */
      static void
  f_histdel(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_CMDHIST
      int		n;
***************
*** 12028,12037 ****
  /*
   * "histget()" function
   */
- /*ARGSUSED*/
      static void
  f_histget(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_CMDHIST
--- 11993,12001 ----
  /*
   * "histget()" function
   */
      static void
  f_histget(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_CMDHIST
***************
*** 12061,12070 ****
  /*
   * "histnr()" function
   */
- /*ARGSUSED*/
      static void
  f_histnr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      int		i;
--- 12025,12033 ----
  /*
   * "histnr()" function
   */
      static void
  f_histnr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      int		i;
***************
*** 12106,12115 ****
  /*
   * "hostname()" function
   */
- /*ARGSUSED*/
      static void
  f_hostname(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      char_u hostname[256];
--- 12069,12077 ----
  /*
   * "hostname()" function
   */
      static void
  f_hostname(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      char_u hostname[256];
***************
*** 12122,12131 ****
  /*
   * iconv() function
   */
- /*ARGSUSED*/
      static void
  f_iconv(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_MBYTE
--- 12084,12092 ----
  /*
   * iconv() function
   */
      static void
  f_iconv(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_MBYTE
***************
*** 12420,12429 ****
  /*
   * "inputrestore()" function
   */
- /*ARGSUSED*/
      static void
  f_inputrestore(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      if (ga_userinput.ga_len > 0)
--- 12381,12389 ----
  /*
   * "inputrestore()" function
   */
      static void
  f_inputrestore(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      if (ga_userinput.ga_len > 0)
***************
*** 12443,12452 ****
  /*
   * "inputsave()" function
   */
- /*ARGSUSED*/
      static void
  f_inputsave(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      /* Add an entry to the stack of typeahead storage. */
--- 12403,12411 ----
  /*
   * "inputsave()" function
   */
      static void
  f_inputsave(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      /* Add an entry to the stack of typeahead storage. */
***************
*** 12733,12742 ****
  /*
   * "last_buffer_nr()" function.
   */
- /*ARGSUSED*/
      static void
  f_last_buffer_nr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      int		n = 0;
--- 12692,12700 ----
  /*
   * "last_buffer_nr()" function.
   */
      static void
  f_last_buffer_nr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      int		n = 0;
***************
*** 12863,12872 ****
  /*
   * "line2byte(lnum)" function
   */
- /*ARGSUSED*/
      static void
  f_line2byte(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifndef FEAT_BYTEOFF
--- 12821,12829 ----
  /*
   * "line2byte(lnum)" function
   */
      static void
  f_line2byte(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifndef FEAT_BYTEOFF
***************
*** 12912,12921 ****
  /*
   * "localtime()" function
   */
- /*ARGSUSED*/
      static void
  f_localtime(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = (varnumber_T)time(NULL);
--- 12869,12877 ----
  /*
   * "localtime()" function
   */
      static void
  f_localtime(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = (varnumber_T)time(NULL);
***************
*** 13497,13503 ****
  /*
   * "mode()" function
   */
- /*ARGSUSED*/
      static void
  f_mode(argvars, rettv)
      typval_T	*argvars;
--- 13453,13458 ----
***************
*** 13726,13736 ****
  /*
   * "pumvisible()" function
   */
- /*ARGSUSED*/
      static void
  f_pumvisible(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_INS_EXPAND
      if (pum_visible())
--- 13681,13690 ----
  /*
   * "pumvisible()" function
   */
      static void
  f_pumvisible(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_INS_EXPAND
      if (pum_visible())
***************
*** 14131,14140 ****
  /*
   * "remote_expr()" function
   */
- /*ARGSUSED*/
      static void
  f_remote_expr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
--- 14085,14093 ----
  /*
   * "remote_expr()" function
   */
      static void
  f_remote_expr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
***************
*** 14147,14157 ****
  /*
   * "remote_foreground()" function
   */
- /*ARGSUSED*/
      static void
  f_remote_foreground(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_CLIENTSERVER
  # ifdef WIN32
--- 14100,14109 ----
  /*
   * "remote_foreground()" function
   */
      static void
  f_remote_foreground(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_CLIENTSERVER
  # ifdef WIN32
***************
*** 14173,14182 ****
  #endif
  }
  
- /*ARGSUSED*/
      static void
  f_remote_peek(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_CLIENTSERVER
--- 14125,14133 ----
  #endif
  }
  
      static void
  f_remote_peek(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_CLIENTSERVER
***************
*** 14231,14240 ****
  #endif
  }
  
- /*ARGSUSED*/
      static void
  f_remote_read(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      char_u	*r = NULL;
--- 14182,14190 ----
  #endif
  }
  
      static void
  f_remote_read(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      char_u	*r = NULL;
***************
*** 14266,14275 ****
  /*
   * "remote_send()" function
   */
- /*ARGSUSED*/
      static void
  f_remote_send(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
--- 14216,14224 ----
  /*
   * "remote_send()" function
   */
      static void
  f_remote_send(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
***************
*** 14398,14404 ****
  /*
   * "repeat()" function
   */
- /*ARGSUSED*/
      static void
  f_repeat(argvars, rettv)
      typval_T	*argvars;
--- 14347,14352 ----
***************
*** 15207,15216 ****
  }
  
  
- /*ARGSUSED*/
      static void
  f_server2client(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_CLIENTSERVER
--- 15155,15163 ----
  }
  
  
      static void
  f_server2client(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_CLIENTSERVER
***************
*** 15239,15248 ****
  #endif
  }
  
- /*ARGSUSED*/
      static void
  f_serverlist(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      char_u	*r = NULL;
--- 15186,15194 ----
  #endif
  }
  
      static void
  f_serverlist(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      char_u	*r = NULL;
***************
*** 15263,15273 ****
  /*
   * "setbufvar()" function
   */
- /*ARGSUSED*/
      static void
  f_setbufvar(argvars, rettv)
      typval_T	*argvars;
!     typval_T	*rettv;
  {
      buf_T	*buf;
      aco_save_T	aco;
--- 15209,15218 ----
  /*
   * "setbufvar()" function
   */
      static void
  f_setbufvar(argvars, rettv)
      typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      buf_T	*buf;
      aco_save_T	aco;
***************
*** 15402,15413 ****
  /*
   * Used by "setqflist()" and "setloclist()" functions
   */
- /*ARGSUSED*/
      static void
  set_qf_ll_list(wp, list_arg, action_arg, rettv)
!     win_T	*wp;
!     typval_T	*list_arg;
!     typval_T	*action_arg;
      typval_T	*rettv;
  {
  #ifdef FEAT_QUICKFIX
--- 15347,15357 ----
  /*
   * Used by "setqflist()" and "setloclist()" functions
   */
      static void
  set_qf_ll_list(wp, list_arg, action_arg, rettv)
!     win_T	*wp UNUSED;
!     typval_T	*list_arg UNUSED;
!     typval_T	*action_arg UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_QUICKFIX
***************
*** 15442,15448 ****
  /*
   * "setloclist()" function
   */
- /*ARGSUSED*/
      static void
  f_setloclist(argvars, rettv)
      typval_T	*argvars;
--- 15386,15391 ----
***************
*** 15520,15526 ****
  /*
   * "setpos()" function
   */
- /*ARGSUSED*/
      static void
  f_setpos(argvars, rettv)
      typval_T	*argvars;
--- 15463,15468 ----
***************
*** 15564,15570 ****
  /*
   * "setqflist()" function
   */
- /*ARGSUSED*/
      static void
  f_setqflist(argvars, rettv)
      typval_T	*argvars;
--- 15506,15511 ----
***************
*** 15667,15677 ****
  /*
   * "setwinvar()" and "settabwinvar()" functions
   */
- /*ARGSUSED*/
      static void
  setwinvar(argvars, rettv, off)
      typval_T	*argvars;
!     typval_T	*rettv;
      int		off;
  {
      win_T	*win;
--- 15608,15617 ----
  /*
   * "setwinvar()" and "settabwinvar()" functions
   */
      static void
  setwinvar(argvars, rettv, off)
      typval_T	*argvars;
!     typval_T	*rettv UNUSED;
      int		off;
  {
      win_T	*win;
***************
*** 15987,15996 ****
  /*
   * "spellbadword()" function
   */
- /* ARGSUSED */
      static void
  f_spellbadword(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      char_u	*word = (char_u *)"";
--- 15927,15935 ----
  /*
   * "spellbadword()" function
   */
      static void
  f_spellbadword(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      char_u	*word = (char_u *)"";
***************
*** 16042,16051 ****
  /*
   * "spellsuggest()" function
   */
- /*ARGSUSED*/
      static void
  f_spellsuggest(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_SPELL
--- 15981,15989 ----
  /*
   * "spellsuggest()" function
   */
      static void
  f_spellsuggest(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_SPELL
***************
*** 16528,16537 ****
  /*
   * "synID(lnum, col, trans)" function
   */
- /*ARGSUSED*/
      static void
  f_synID(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      int		id = 0;
--- 16466,16474 ----
  /*
   * "synID(lnum, col, trans)" function
   */
      static void
  f_synID(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      int		id = 0;
***************
*** 16556,16565 ****
  /*
   * "synIDattr(id, what [, mode])" function
   */
- /*ARGSUSED*/
      static void
  f_synIDattr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      char_u	*p = NULL;
--- 16493,16501 ----
  /*
   * "synIDattr(id, what [, mode])" function
   */
      static void
  f_synIDattr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      char_u	*p = NULL;
***************
*** 16652,16661 ****
  /*
   * "synIDtrans(id)" function
   */
- /*ARGSUSED*/
      static void
  f_synIDtrans(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      int		id;
--- 16588,16596 ----
  /*
   * "synIDtrans(id)" function
   */
      static void
  f_synIDtrans(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      int		id;
***************
*** 16675,16684 ****
  /*
   * "synstack(lnum, col)" function
   */
- /*ARGSUSED*/
      static void
  f_synstack(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_SYN_HL
--- 16610,16618 ----
  /*
   * "synstack(lnum, col)" function
   */
      static void
  f_synstack(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_SYN_HL
***************
*** 16812,16822 ****
  /*
   * "tabpagebuflist()" function
   */
- /* ARGSUSED */
      static void
  f_tabpagebuflist(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
--- 16746,16755 ----
  /*
   * "tabpagebuflist()" function
   */
      static void
  f_tabpagebuflist(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
***************
*** 16844,16853 ****
  /*
   * "tabpagenr()" function
   */
- /* ARGSUSED */
      static void
  f_tabpagenr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      int		nr = 1;
--- 16777,16785 ----
  /*
   * "tabpagenr()" function
   */
      static void
  f_tabpagenr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      int		nr = 1;
***************
*** 16929,16938 ****
  /*
   * "tabpagewinnr()" function
   */
- /* ARGSUSED */
      static void
  f_tabpagewinnr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      int		nr = 1;
--- 16861,16869 ----
  /*
   * "tabpagewinnr()" function
   */
      static void
  f_tabpagewinnr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      int		nr = 1;
***************
*** 16952,16961 ****
  /*
   * "tagfiles()" function
   */
- /*ARGSUSED*/
      static void
  f_tagfiles(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      char_u	fname[MAXPATHL + 1];
--- 16883,16891 ----
  /*
   * "tagfiles()" function
   */
      static void
  f_tagfiles(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      char_u	fname[MAXPATHL + 1];
***************
*** 16995,17004 ****
  /*
   * "tempname()" function
   */
- /*ARGSUSED*/
      static void
  f_tempname(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      static int	x = 'A';
--- 16925,16933 ----
  /*
   * "tempname()" function
   */
      static void
  f_tempname(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      static int	x = 'A';
***************
*** 17031,17041 ****
  /*
   * "test(list)" function: Just checking the walls...
   */
- /*ARGSUSED*/
      static void
  f_test(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      /* Used for unit testing.  Change the code below to your liking. */
  #if 0
--- 16960,16969 ----
  /*
   * "test(list)" function: Just checking the walls...
   */
      static void
  f_test(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
      /* Used for unit testing.  Change the code below to your liking. */
  #if 0
***************
*** 17320,17330 ****
  /*
   * "visualmode()" function
   */
- /*ARGSUSED*/
      static void
  f_visualmode(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_VISUAL
      char_u	str[2];
--- 17248,17257 ----
  /*
   * "visualmode()" function
   */
      static void
  f_visualmode(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_VISUAL
      char_u	str[2];
***************
*** 17360,17369 ****
  /*
   * "wincol()" function
   */
- /*ARGSUSED*/
      static void
  f_wincol(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      validate_cursor();
--- 17287,17295 ----
  /*
   * "wincol()" function
   */
      static void
  f_wincol(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      validate_cursor();
***************
*** 17390,17399 ****
  /*
   * "winline()" function
   */
- /*ARGSUSED*/
      static void
  f_winline(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      validate_cursor();
--- 17316,17324 ----
  /*
   * "winline()" function
   */
      static void
  f_winline(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      validate_cursor();
***************
*** 17403,17412 ****
  /*
   * "winnr()" function
   */
- /* ARGSUSED */
      static void
  f_winnr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      int		nr = 1;
--- 17328,17336 ----
  /*
   * "winnr()" function
   */
      static void
  f_winnr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      int		nr = 1;
***************
*** 17420,17429 ****
  /*
   * "winrestcmd()" function
   */
- /* ARGSUSED */
      static void
  f_winrestcmd(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_WINDOWS
--- 17344,17352 ----
  /*
   * "winrestcmd()" function
   */
      static void
  f_winrestcmd(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_WINDOWS
***************
*** 17455,17465 ****
  /*
   * "winrestview()" function
   */
- /* ARGSUSED */
      static void
  f_winrestview(argvars, rettv)
      typval_T	*argvars;
!     typval_T	*rettv;
  {
      dict_T	*dict;
  
--- 17378,17387 ----
  /*
   * "winrestview()" function
   */
      static void
  f_winrestview(argvars, rettv)
      typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      dict_T	*dict;
  
***************
*** 17501,17510 ****
  /*
   * "winsaveview()" function
   */
- /* ARGSUSED */
      static void
  f_winsaveview(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      dict_T	*dict;
--- 17423,17431 ----
  /*
   * "winsaveview()" function
   */
      static void
  f_winsaveview(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      dict_T	*dict;
***************
*** 21646,21657 ****
   * Called by do_cmdline() to get the next line.
   * Returns allocated string, or NULL for end of function.
   */
- /* ARGSUSED */
      char_u *
  get_func_line(c, cookie, indent)
!     int	    c;		    /* not used */
      void    *cookie;
!     int	    indent;	    /* not used */
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
--- 21567,21577 ----
   * Called by do_cmdline() to get the next line.
   * Returns allocated string, or NULL for end of function.
   */
      char_u *
  get_func_line(c, cookie, indent)
!     int	    c UNUSED;
      void    *cookie;
!     int	    indent UNUSED;
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
***************
*** 22023,22032 ****
  /*
   * List v:oldfiles in a nice way.
   */
- /*ARGSUSED*/
      void
  ex_oldfiles(eap)
!     exarg_T	*eap;
  {
      list_T	*l = vimvars[VV_OLDFILES].vv_list;
      listitem_T	*li;
--- 21943,21951 ----
  /*
   * List v:oldfiles in a nice way.
   */
      void
  ex_oldfiles(eap)
!     exarg_T	*eap UNUSED;
  {
      list_T	*l = vimvars[VV_OLDFILES].vv_list;
      listitem_T	*li;
*** ../vim-7.2.176/src/ex_docmd.c	2009-05-16 16:36:25.000000000 +0200
--- src/ex_docmd.c	2009-05-16 17:01:26.000000000 +0200
***************
*** 3004,3010 ****
  
      if (VIM_ISDIGIT(*cmd))
  	p = skipwhite(skipdigits(cmd));
!     for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
      {
  	for (j = 0; p[j] != NUL; ++j)
  	    if (p[j] != cmdmods[i].name[j])
--- 3004,3010 ----
  
      if (VIM_ISDIGIT(*cmd))
  	p = skipwhite(skipdigits(cmd));
!     for (i = 0; i < (int)(sizeof(cmdmods) / sizeof(struct cmdmod)); ++i)
      {
  	for (j = 0; p[j] != NUL; ++j)
  	    if (p[j] != cmdmods[i].name[j])
***************
*** 3032,3038 ****
      char_u	*p;
  
      /* Check command modifiers. */
!     for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
      {
  	for (j = 0; name[j] != NUL; ++j)
  	    if (name[j] != cmdmods[i].name[j])
--- 3032,3038 ----
      char_u	*p;
  
      /* Check command modifiers. */
!     for (i = 0; i < (int)(sizeof(cmdmods) / sizeof(struct cmdmod)); ++i)
      {
  	for (j = 0; name[j] != NUL; ++j)
  	    if (name[j] != cmdmods[i].name[j])
***************
*** 6093,6099 ****
  	{"bang", "bar", "buffer", "complete", "count",
  	    "nargs", "range", "register"};
  
!     if (idx >= sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0]))
  	return NULL;
      return (char_u *)user_cmd_flags[idx];
  }
--- 6093,6099 ----
  	{"bang", "bar", "buffer", "complete", "count",
  	    "nargs", "range", "register"};
  
!     if (idx >= (int)(sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0])))
  	return NULL;
      return (char_u *)user_cmd_flags[idx];
  }
***************
*** 6108,6114 ****
  {
      static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
  
!     if (idx >= sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0]))
  	return NULL;
      return (char_u *)user_cmd_nargs[idx];
  }
--- 6108,6114 ----
  {
      static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
  
!     if (idx >= (int)(sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0])))
  	return NULL;
      return (char_u *)user_cmd_nargs[idx];
  }
***************
*** 9144,9153 ****
  /*
   * ":stopinsert"
   */
- /*ARGSUSED*/
      static void
  ex_stopinsert(eap)
!     exarg_T	*eap;
  {
      restart_edit = 0;
      stop_insert_mode = TRUE;
--- 9144,9152 ----
  /*
   * ":stopinsert"
   */
      static void
  ex_stopinsert(eap)
!     exarg_T	*eap UNUSED;
  {
      restart_edit = 0;
      stop_insert_mode = TRUE;
*** ../vim-7.2.176/src/ex_eval.c	2007-11-24 21:50:19.000000000 +0100
--- src/ex_eval.c	2009-05-16 17:06:09.000000000 +0200
***************
*** 60,66 ****
--- 60,68 ----
  #else
  /* Values used for the Vim release. */
  # define THROW_ON_ERROR		TRUE
+ # define THROW_ON_ERROR_TRUE
  # define THROW_ON_INTERRUPT	TRUE
+ # define THROW_ON_INTERRUPT_TRUE
  #endif
  
  static void	catch_exception __ARGS((except_T *excp));
***************
*** 1320,1335 ****
--- 1322,1341 ----
       * and reset the did_emsg or got_int flag, so this won't happen again at
       * the next surrounding try conditional.
       */
+ #ifndef THROW_ON_ERROR_TRUE
      if (did_emsg && !THROW_ON_ERROR)
      {
  	inactivate_try = TRUE;
  	did_emsg = FALSE;
      }
+ #endif
+ #ifndef THROW_ON_INTERRUPT_TRUE
      if (got_int && !THROW_ON_INTERRUPT)
      {
  	inactivate_try = TRUE;
  	got_int = FALSE;
      }
+ #endif
      idx = cleanup_conditionals(cstack, 0, inactivate_try);
      if (idx >= 0)
      {
***************
*** 2254,2263 ****
  /*
   * ":endfunction" when not after a ":function"
   */
- /*ARGSUSED*/
      void
  ex_endfunction(eap)
!     exarg_T	*eap;
  {
      EMSG(_("E193: :endfunction not inside a function"));
  }
--- 2260,2268 ----
  /*
   * ":endfunction" when not after a ":function"
   */
      void
  ex_endfunction(eap)
!     exarg_T	*eap UNUSED;
  {
      EMSG(_("E193: :endfunction not inside a function"));
  }
*** ../vim-7.2.176/src/ex_getln.c	2009-05-15 21:31:11.000000000 +0200
--- src/ex_getln.c	2009-05-16 17:06:55.000000000 +0200
***************
*** 4533,4539 ****
  	 * right function to do the expansion.
  	 */
  	ret = FAIL;
! 	for (i = 0; i < sizeof(tab) / sizeof(struct expgen); ++i)
  	    if (xp->xp_context == tab[i].context)
  	    {
  		if (tab[i].ic)
--- 4533,4539 ----
  	 * right function to do the expansion.
  	 */
  	ret = FAIL;
! 	for (i = 0; i < (int)(sizeof(tab) / sizeof(struct expgen)); ++i)
  	    if (xp->xp_context == tab[i].context)
  	    {
  		if (tab[i].ic)
*** ../vim-7.2.176/src/fileio.c	2009-05-15 21:31:11.000000000 +0200
--- src/fileio.c	2009-05-16 17:07:35.000000000 +0200
***************
*** 9085,9096 ****
   * Called by do_cmdline() to get the next line for ":if".
   * Returns allocated string, or NULL for end of autocommands.
   */
- /* ARGSUSED */
      static char_u *
  getnextac(c, cookie, indent)
!     int	    c;		    /* not used */
      void    *cookie;
!     int	    indent;	    /* not used */
  {
      AutoPatCmd	    *acp = (AutoPatCmd *)cookie;
      char_u	    *retval;
--- 9093,9103 ----
   * Called by do_cmdline() to get the next line for ":if".
   * Returns allocated string, or NULL for end of autocommands.
   */
      static char_u *
  getnextac(c, cookie, indent)
!     int	    c UNUSED;
      void    *cookie;
!     int	    indent UNUSED;
  {
      AutoPatCmd	    *acp = (AutoPatCmd *)cookie;
      char_u	    *retval;
***************
*** 9201,9210 ****
   * Function given to ExpandGeneric() to obtain the list of autocommand group
   * names.
   */
- /*ARGSUSED*/
      char_u *
  get_augroup_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      if (idx == augroups.ga_len)		/* add "END" add the end */
--- 9208,9216 ----
   * Function given to ExpandGeneric() to obtain the list of autocommand group
   * names.
   */
      char_u *
  get_augroup_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      if (idx == augroups.ga_len)		/* add "END" add the end */
***************
*** 9270,9279 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of event names.
   */
- /*ARGSUSED*/
      char_u *
  get_event_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      if (idx < augroups.ga_len)		/* First list group names, if wanted */
--- 9276,9284 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of event names.
   */
      char_u *
  get_event_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      if (idx < augroups.ga_len)		/* First list group names, if wanted */
*** ../vim-7.2.176/src/hardcopy.c	2008-01-12 16:46:41.000000000 +0100
--- src/hardcopy.c	2009-05-16 17:18:27.000000000 +0200
***************
*** 442,453 ****
  /*
   * Print the page header.
   */
- /*ARGSUSED*/
      static void
  prt_header(psettings, pagenum, lnum)
      prt_settings_T  *psettings;
      int		pagenum;
!     linenr_T	lnum;
  {
      int		width = psettings->chars_per_line;
      int		page_line;
--- 442,452 ----
  /*
   * Print the page header.
   */
      static void
  prt_header(psettings, pagenum, lnum)
      prt_settings_T  *psettings;
      int		pagenum;
!     linenr_T	lnum UNUSED;
  {
      int		width = psettings->chars_per_line;
      int		page_line;
***************
*** 1881,1887 ****
  	return FALSE;
  
      /* Find type of DSC comment */
!     for (comment = 0; comment < NUM_ELEMENTS(prt_dsc_table); comment++)
  	if (prt_resfile_strncmp(0, prt_dsc_table[comment].string,
  					    prt_dsc_table[comment].len) == 0)
  	    break;
--- 1880,1886 ----
  	return FALSE;
  
      /* Find type of DSC comment */
!     for (comment = 0; comment < (int)NUM_ELEMENTS(prt_dsc_table); comment++)
  	if (prt_resfile_strncmp(0, prt_dsc_table[comment].string,
  					    prt_dsc_table[comment].len) == 0)
  	    break;
***************
*** 2454,2465 ****
  }
  #endif
  
- /*ARGSUSED*/
      int
  mch_print_init(psettings, jobname, forceit)
      prt_settings_T *psettings;
      char_u	*jobname;
!     int		forceit;
  {
      int		i;
      char	*paper_name;
--- 2453,2463 ----
  }
  #endif
  
      int
  mch_print_init(psettings, jobname, forceit)
      prt_settings_T *psettings;
      char_u	*jobname;
!     int		forceit UNUSED;
  {
      int		i;
      char	*paper_name;
***************
*** 2514,2520 ****
      if (!(props & ENC_8BIT) && ((*p_pmcs != NUL) || !(props & ENC_UNICODE)))
      {
  	p_mbenc_first = NULL;
! 	for (cmap = 0; cmap < NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
  	    if (prt_match_encoding((char *)p_encoding, &prt_ps_mbfonts[cmap],
  								    &p_mbenc))
  	    {
--- 2512,2518 ----
      if (!(props & ENC_8BIT) && ((*p_pmcs != NUL) || !(props & ENC_UNICODE)))
      {
  	p_mbenc_first = NULL;
! 	for (cmap = 0; cmap < (int)NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
  	    if (prt_match_encoding((char *)p_encoding, &prt_ps_mbfonts[cmap],
  								    &p_mbenc))
  	    {
***************
*** 2642,2648 ****
  	paper_name = "A4";
  	paper_strlen = 2;
      }
!     for (i = 0; i < PRT_MEDIASIZE_LEN; ++i)
  	if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen
  		&& STRNICMP(prt_mediasize[i].name, paper_name,
  							   paper_strlen) == 0)
--- 2640,2646 ----
  	paper_name = "A4";
  	paper_strlen = 2;
      }
!     for (i = 0; i < (int)PRT_MEDIASIZE_LEN; ++i)
  	if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen
  		&& STRNICMP(prt_mediasize[i].name, paper_name,
  							   paper_strlen) == 0)
***************
*** 3308,3317 ****
      return !prt_file_error;
  }
  
- /*ARGSUSED*/
      int
  mch_print_begin_page(str)
!     char_u	*str;
  {
      int		page_num[2];
  
--- 3306,3314 ----
      return !prt_file_error;
  }
  
      int
  mch_print_begin_page(str)
!     char_u	*str UNUSED;
  {
      int		page_num[2];
  
***************
*** 3379,3389 ****
  #endif
  }
  
- /*ARGSUSED*/
      int
  mch_print_text_out(p, len)
      char_u	*p;
!     int		len;
  {
      int		need_break;
      char_u	ch;
--- 3376,3385 ----
  #endif
  }
  
      int
  mch_print_text_out(p, len)
      char_u	*p;
!     int		len UNUSED;
  {
      int		need_break;
      char_u	ch;
*** ../vim-7.2.176/src/if_cscope.c	2009-05-16 16:15:39.000000000 +0200
--- src/if_cscope.c	2009-05-16 17:19:30.000000000 +0200
***************
*** 83,89 ****
  		N_("Reinit all connections"), "reset", 0 },
      { "show",	cs_show,
  		N_("Show connections"),       "show", 0 },
!     { NULL }
  };
  
      static void
--- 83,89 ----
  		N_("Reinit all connections"), "reset", 0 },
      { "show",	cs_show,
  		N_("Show connections"),       "show", 0 },
!     { NULL, NULL, NULL, NULL, 0 }
  };
  
      static void
***************
*** 107,116 ****
   * Function given to ExpandGeneric() to obtain the cscope command
   * expansion.
   */
- /*ARGSUSED*/
      char_u *
  get_cscope_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      int		current_idx;
--- 107,115 ----
   * Function given to ExpandGeneric() to obtain the cscope command
   * expansion.
   */
      char_u *
  get_cscope_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      int		current_idx;
***************
*** 496,505 ****
   *
   * MAXPATHL 256
   */
- /* ARGSUSED */
      static int
  cs_add(eap)
!     exarg_T *eap;
  {
      char *fname, *ppath, *flags = NULL;
  
--- 495,503 ----
   *
   * MAXPATHL 256
   */
      static int
  cs_add(eap)
!     exarg_T *eap UNUSED;
  {
      char *fname, *ppath, *flags = NULL;
  
***************
*** 1292,1301 ****
   *
   * print help
   */
- /* ARGSUSED */
      static int
  cs_help(eap)
!     exarg_T *eap;
  {
      cscmd_T *cmdp = cs_cmds;
  
--- 1290,1298 ----
   *
   * print help
   */
      static int
  cs_help(eap)
!     exarg_T *eap UNUSED;
  {
      cscmd_T *cmdp = cs_cmds;
  
***************
*** 1399,1411 ****
   *
   * insert a new cscope database filename into the filelist
   */
- /*ARGSUSED*/
      static int
  cs_insert_filelist(fname, ppath, flags, sb)
      char *fname;
      char *ppath;
      char *flags;
!     struct stat *sb;
  {
      short	i, j;
  #ifndef UNIX
--- 1396,1407 ----
   *
   * insert a new cscope database filename into the filelist
   */
      static int
  cs_insert_filelist(fname, ppath, flags, sb)
      char *fname;
      char *ppath;
      char *flags;
!     struct stat *sb UNUSED;
  {
      short	i, j;
  #ifndef UNIX
***************
*** 1561,1570 ****
   *
   * nuke em
   */
- /* ARGSUSED */
      static int
  cs_kill(eap)
!     exarg_T *eap;
  {
      char *stok;
      short i;
--- 1557,1565 ----
   *
   * nuke em
   */
      static int
  cs_kill(eap)
!     exarg_T *eap UNUSED;
  {
      char *stok;
      short i;
***************
*** 2241,2247 ****
  /*
   * Used to catch and ignore SIGALRM below.
   */
- /* ARGSUSED */
      static RETSIGTYPE
  sig_handler SIGDEFARG(sigarg)
  {
--- 2236,2241 ----
***************
*** 2381,2390 ****
   *
   * calls cs_kill on all cscope connections then reinits
   */
- /* ARGSUSED */
      static int
  cs_reset(eap)
!     exarg_T *eap;
  {
      char	**dblist = NULL, **pplist = NULL, **fllist = NULL;
      int	i;
--- 2375,2383 ----
   *
   * calls cs_kill on all cscope connections then reinits
   */
      static int
  cs_reset(eap)
!     exarg_T *eap UNUSED;
  {
      char	**dblist = NULL, **pplist = NULL, **fllist = NULL;
      int	i;
***************
*** 2497,2506 ****
   *
   * show all cscope connections
   */
- /* ARGSUSED */
      static int
  cs_show(eap)
!     exarg_T *eap;
  {
      short i;
      if (cs_cnt_connections() == 0)
--- 2490,2498 ----
   *
   * show all cscope connections
   */
      static int
  cs_show(eap)
!     exarg_T *eap UNUSED;
  {
      short i;
      if (cs_cnt_connections() == 0)
*** ../vim-7.2.176/src/if_xcmdsrv.c	2008-11-12 14:52:11.000000000 +0100
--- src/if_xcmdsrv.c	2009-05-16 17:12:32.000000000 +0200
***************
*** 682,688 ****
       * Scan all of the names out of the property.
       */
      ga_init2(&ga, 1, 100);
!     for (p = regProp; (p - regProp) < numItems; p++)
      {
  	entry = p;
  	while (*p != 0 && !isspace(*p))
--- 682,688 ----
       * Scan all of the names out of the property.
       */
      ga_init2(&ga, 1, 100);
!     for (p = regProp; (long_u)(p - regProp) < numItems; p++)
      {
  	entry = p;
  	while (*p != 0 && !isspace(*p))
***************
*** 969,975 ****
       */
      returnValue = (int_u)None;
      entry = NULL;	/* Not needed, but eliminates compiler warning. */
!     for (p = regProp; (p - regProp) < numItems; )
      {
  	entry = p;
  	while (*p != 0 && !isspace(*p))
--- 969,975 ----
       */
      returnValue = (int_u)None;
      entry = NULL;	/* Not needed, but eliminates compiler warning. */
!     for (p = regProp; (long_u)(p - regProp) < numItems; )
      {
  	entry = p;
  	while (*p != 0 && !isspace(*p))
***************
*** 986,992 ****
  
      if (loose != NULL && returnValue == (int_u)None && !IsSerialName(name))
      {
! 	for (p = regProp; (p - regProp) < numItems; )
  	{
  	    entry = p;
  	    while (*p != 0 && !isspace(*p))
--- 986,992 ----
  
      if (loose != NULL && returnValue == (int_u)None && !IsSerialName(name))
      {
! 	for (p = regProp; (long_u)(p - regProp) < numItems; )
  	{
  	    entry = p;
  	    while (*p != 0 && !isspace(*p))
***************
*** 1056,1062 ****
  	return;
  
      /* Scan the property for the window id.  */
!     for (p = regProp; (p - regProp) < numItems; )
      {
  	if (*p != 0)
  	{
--- 1056,1062 ----
  	return;
  
      /* Scan the property for the window id.  */
!     for (p = regProp; (long_u)(p - regProp) < numItems; )
      {
  	if (*p != 0)
  	{
***************
*** 1196,1202 ****
       * one time;  each iteration through the outer loop handles a
       * single command or result.
       */
!     for (p = propInfo; (p - propInfo) < numItems; )
      {
  	/*
  	 * Ignore leading NULs; each command or result starts with a
--- 1196,1202 ----
       * one time;  each iteration through the outer loop handles a
       * single command or result.
       */
!     for (p = propInfo; (long_u)(p - propInfo) < numItems; )
      {
  	/*
  	 * Ignore leading NULs; each command or result starts with a
***************
*** 1230,1236 ****
  	    serial = (char_u *)"";
  	    script = NULL;
  	    enc = NULL;
! 	    while (p - propInfo < numItems && *p == '-')
  	    {
  		switch (p[1])
  		{
--- 1230,1236 ----
  	    serial = (char_u *)"";
  	    script = NULL;
  	    enc = NULL;
! 	    while ((long_u)(p - propInfo) < numItems && *p == '-')
  	    {
  		switch (p[1])
  		{
***************
*** 1333,1339 ****
  	    res = (char_u *)"";
  	    code = 0;
  	    enc = NULL;
! 	    while ((p-propInfo) < numItems && *p == '-')
  	    {
  		switch (p[1])
  		{
--- 1333,1339 ----
  	    res = (char_u *)"";
  	    code = 0;
  	    enc = NULL;
! 	    while ((long_u)(p - propInfo) < numItems && *p == '-')
  	    {
  		switch (p[1])
  		{
***************
*** 1401,1407 ****
  	    gotWindow = 0;
  	    str = (char_u *)"";
  	    enc = NULL;
! 	    while ((p-propInfo) < numItems && *p == '-')
  	    {
  		switch (p[1])
  		{
--- 1401,1407 ----
  	    gotWindow = 0;
  	    str = (char_u *)"";
  	    enc = NULL;
! 	    while ((long_u)(p - propInfo) < numItems && *p == '-')
  	    {
  		switch (p[1])
  		{
***************
*** 1489,1499 ****
  /*
   * Another X Error handler, just used to check for errors.
   */
- /* ARGSUSED */
      static int
  x_error_check(dpy, error_event)
!     Display	*dpy;
!     XErrorEvent	*error_event;
  {
      got_x_error = TRUE;
      return 0;
--- 1489,1498 ----
  /*
   * Another X Error handler, just used to check for errors.
   */
      static int
  x_error_check(dpy, error_event)
!     Display	*dpy UNUSED;
!     XErrorEvent	*error_event UNUSED;
  {
      got_x_error = TRUE;
      return 0;
*** ../vim-7.2.176/src/farsi.c	2008-06-25 00:25:17.000000000 +0200
--- src/farsi.c	2009-05-16 17:14:41.000000000 +0200
***************
*** 103,109 ****
  	case F_HE:
  		tempc = _HE;
  
! 		if (p_ri && (curwin->w_cursor.col+1 < STRLEN(ml_get_curline())))
  		{
  		    inc_cursor();
  
--- 103,110 ----
  	case F_HE:
  		tempc = _HE;
  
! 		if (p_ri && (curwin->w_cursor.col + 1
! 					 < (colnr_T)STRLEN(ml_get_curline())))
  		{
  		    inc_cursor();
  
***************
*** 344,350 ****
      if (curwin->w_p_rl && p_ri)
  	return;
  
!     if ( (curwin->w_cursor.col < STRLEN(ml_get_curline())))
      {
  	if ((p_ri && curwin->w_cursor.col) || !p_ri)
  	{
--- 345,351 ----
      if (curwin->w_p_rl && p_ri)
  	return;
  
!     if ((curwin->w_cursor.col < (colnr_T)STRLEN(ml_get_curline())))
      {
  	if ((p_ri && curwin->w_cursor.col) || !p_ri)
  	{
***************
*** 565,571 ****
  
      tempc = gchar_cursor();
  
!     if (curwin->w_cursor.col+1 < STRLEN(ml_get_curline()))
      {
  	inc_cursor();
  
--- 566,572 ----
  
      tempc = gchar_cursor();
  
!     if (curwin->w_cursor.col + 1 < (colnr_T)STRLEN(ml_get_curline()))
      {
  	inc_cursor();
  
***************
*** 594,601 ****
  {
      int	tempc;
  
!     if (!curwin->w_cursor.col &&
! 	(curwin->w_cursor.col+1 == STRLEN(ml_get_curline())))
  	return;
  
      if (!curwin->w_cursor.col && p_ri)
--- 595,602 ----
  {
      int	tempc;
  
!     if (curwin->w_cursor.col != 0 &&
! 	(curwin->w_cursor.col + 1 == (colnr_T)STRLEN(ml_get_curline())))
  	return;
  
      if (!curwin->w_cursor.col && p_ri)
***************
*** 663,670 ****
  {
      int	tempc;
  
!     if (!curwin->w_cursor.col &&
! 	(curwin->w_cursor.col+1 == STRLEN(ml_get_curline())))
  	return;
  
      if (!curwin->w_cursor.col && p_ri)
--- 664,671 ----
  {
      int	tempc;
  
!     if (curwin->w_cursor.col != 0 &&
! 	(curwin->w_cursor.col + 1 == (colnr_T)STRLEN(ml_get_curline())))
  	return;
  
      if (!curwin->w_cursor.col && p_ri)
*** ../vim-7.2.176/src/mark.c	2009-04-29 11:00:09.000000000 +0200
--- src/mark.c	2009-05-16 17:14:56.000000000 +0200
***************
*** 884,893 ****
  /*
   * print the jumplist
   */
- /*ARGSUSED*/
      void
  ex_jumps(eap)
!     exarg_T	*eap;
  {
      int		i;
      char_u	*name;
--- 884,892 ----
  /*
   * print the jumplist
   */
      void
  ex_jumps(eap)
!     exarg_T	*eap UNUSED;
  {
      int		i;
      char_u	*name;
***************
*** 933,942 ****
  /*
   * print the changelist
   */
- /*ARGSUSED*/
      void
  ex_changes(eap)
!     exarg_T	*eap;
  {
      int		i;
      char_u	*name;
--- 932,940 ----
  /*
   * print the changelist
   */
      void
  ex_changes(eap)
!     exarg_T	*eap UNUSED;
  {
      int		i;
      char_u	*name;
*** ../vim-7.2.176/src/menu.c	2008-08-17 23:43:53.000000000 +0200
--- src/menu.c	2009-05-16 17:19:57.000000000 +0200
***************
*** 231,237 ****
  		if (skipdigits(menu_path + 7) == p)
  		{
  		    menuarg.iconidx = atoi((char *)menu_path + 7);
! 		    if (menuarg.iconidx >= TOOLBAR_NAME_COUNT)
  			menuarg.iconidx = -1;
  		    else
  			menuarg.icon_builtin = TRUE;
--- 231,237 ----
  		if (skipdigits(menu_path + 7) == p)
  		{
  		    menuarg.iconidx = atoi((char *)menu_path + 7);
! 		    if (menuarg.iconidx >= (int)TOOLBAR_NAME_COUNT)
  			menuarg.iconidx = -1;
  		    else
  			menuarg.icon_builtin = TRUE;
***************
*** 239,245 ****
  	    }
  	    else
  	    {
! 		for (i = 0; i < TOOLBAR_NAME_COUNT; ++i)
  		    if (STRNCMP(toolbar_names[i], menu_path, p - menu_path)
  									 == 0)
  		    {
--- 239,245 ----
  	    }
  	    else
  	    {
! 		for (i = 0; i < (int)TOOLBAR_NAME_COUNT; ++i)
  		    if (STRNCMP(toolbar_names[i], menu_path, p - menu_path)
  									 == 0)
  		    {
***************
*** 1341,1350 ****
   * Function given to ExpandGeneric() to obtain the list of (sub)menus (not
   * entries).
   */
- /*ARGSUSED*/
      char_u *
  get_menu_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      static vimmenu_T	*menu = NULL;
--- 1341,1349 ----
   * Function given to ExpandGeneric() to obtain the list of (sub)menus (not
   * entries).
   */
      char_u *
  get_menu_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      static vimmenu_T	*menu = NULL;
***************
*** 1378,1387 ****
   * Function given to ExpandGeneric() to obtain the list of menus and menu
   * entries.
   */
- /*ARGSUSED*/
      char_u *
  get_menu_names(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      static vimmenu_T	*menu = NULL;
--- 1377,1385 ----
   * Function given to ExpandGeneric() to obtain the list of menus and menu
   * entries.
   */
      char_u *
  get_menu_names(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      static vimmenu_T	*menu = NULL;
***************
*** 1739,1748 ****
  /*
   * Return TRUE if the menu is the tearoff menu.
   */
- /*ARGSUSED*/
      static int
  menu_is_tearoff(name)
!     char_u *name;
  {
  #ifdef FEAT_GUI
      return (STRCMP(name, TEAR_STRING) == 0);
--- 1737,1745 ----
  /*
   * Return TRUE if the menu is the tearoff menu.
   */
      static int
  menu_is_tearoff(name)
!     char_u *name UNUSED;
  {
  #ifdef FEAT_GUI
      return (STRCMP(name, TEAR_STRING) == 0);
*** ../vim-7.2.176/src/version.c	2009-05-16 16:36:25.000000000 +0200
--- src/version.c	2009-05-16 17:22:08.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     177,
  /**/

-- 
(letter from Mark to Mike, about the film's probable certificate)
      For an 'A' we would have to: Lose as many shits as possible; Take Jesus
      Christ out, if possible; Loose "I fart in your general direction"; Lose
      "the oral sex"; Lose "oh, fuck off"; Lose "We make castanets out of your
      testicles"
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.178
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.178
Problem:    Using negative value for device number might not work.
Solution:   Use a separate flag for whether ffv_dev was set.
Files:	    src/misc2.c


*** ../vim-7.2.177/src/misc2.c	2009-04-29 11:00:09.000000000 +0200
--- src/misc2.c	2009-05-16 21:05:10.000000000 +0200
***************
*** 2841,2847 ****
  get_key_name(i)
      int	    i;
  {
!     if (i >= KEY_NAMES_TABLE_LEN)
  	return NULL;
      return  key_names_table[i].name;
  }
--- 2841,2847 ----
  get_key_name(i)
      int	    i;
  {
!     if (i >= (int)KEY_NAMES_TABLE_LEN)
  	return NULL;
      return  key_names_table[i].name;
  }
***************
*** 3869,3875 ****
       * use filename.
       */
  #ifdef UNIX
!     int			ffv_dev;	/* device number (-1 if not set) */
      ino_t		ffv_ino;	/* inode number */
  #endif
      /* The memory for this struct is allocated according to the length of
--- 3869,3876 ----
       * use filename.
       */
  #ifdef UNIX
!     int			ffv_dev_valid;	/* ffv_dev and ffv_ino were set */
!     dev_t		ffv_dev;	/* device number */
      ino_t		ffv_ino;	/* inode number */
  #endif
      /* The memory for this struct is allocated according to the length of
***************
*** 4059,4071 ****
   * This function silently ignores a few errors, vim_findfile() will have
   * limited functionality then.
   */
- /*ARGSUSED*/
      void *
  vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,
  					   search_ctx_arg, tagfile, rel_fname)
      char_u	*path;
      char_u	*filename;
!     char_u	*stopdirs;
      int		level;
      int		free_visited;
      int		find_what;
--- 4060,4071 ----
   * This function silently ignores a few errors, vim_findfile() will have
   * limited functionality then.
   */
      void *
  vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,
  					   search_ctx_arg, tagfile, rel_fname)
      char_u	*path;
      char_u	*filename;
!     char_u	*stopdirs UNUSED;
      int		level;
      int		free_visited;
      int		find_what;
***************
*** 5063,5072 ****
      {
  	if (
  #ifdef UNIX
! 		!url
! 		    ? (vp->ffv_dev == st.st_dev
! 			&& vp->ffv_ino == st.st_ino)
! 		    :
  #endif
  		fnamecmp(vp->ffv_fname, ff_expand_buffer) == 0
  	   )
--- 5063,5071 ----
      {
  	if (
  #ifdef UNIX
! 		!url ? (vp->ffv_dev_valid && vp->ffv_dev == st.st_dev
! 						  && vp->ffv_ino == st.st_ino)
! 		     :
  #endif
  		fnamecmp(vp->ffv_fname, ff_expand_buffer) == 0
  	   )
***************
*** 5091,5104 ****
  #ifdef UNIX
  	if (!url)
  	{
  	    vp->ffv_ino = st.st_ino;
  	    vp->ffv_dev = st.st_dev;
  	    vp->ffv_fname[0] = NUL;
  	}
  	else
  	{
! 	    vp->ffv_ino = 0;
! 	    vp->ffv_dev = -1;
  #endif
  	    STRCPY(vp->ffv_fname, ff_expand_buffer);
  #ifdef UNIX
--- 5090,5103 ----
  #ifdef UNIX
  	if (!url)
  	{
+ 	    vp->ffv_dev_valid = TRUE;
  	    vp->ffv_ino = st.st_ino;
  	    vp->ffv_dev = st.st_dev;
  	    vp->ffv_fname[0] = NUL;
  	}
  	else
  	{
! 	    vp->ffv_dev_valid = FALSE;
  #endif
  	    STRCPY(vp->ffv_fname, ff_expand_buffer);
  #ifdef UNIX
*** ../vim-7.2.177/src/version.c	2009-05-16 17:29:37.000000000 +0200
--- src/version.c	2009-05-16 21:00:15.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     178,
  /**/

-- 
FATAL ERROR! SYSTEM HALTED! - Press any key to continue doing nothing.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.179
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.179
Problem:    Using negative value for device number might not work.
Solution:   Use a separate flag for whether sn_dev was set.
Files:	    src/ex_cmds2.c


*** ../vim-7.2.178/src/ex_cmds2.c	2009-05-14 22:19:19.000000000 +0200
--- src/ex_cmds2.c	2009-05-16 21:13:29.000000000 +0200
***************
*** 28,34 ****
  {
      char_u	*sn_name;
  # ifdef UNIX
!     int		sn_dev;
      ino_t	sn_ino;
  # endif
  # ifdef FEAT_PROFILE
--- 28,35 ----
  {
      char_u	*sn_name;
  # ifdef UNIX
!     int		sn_dev_valid;
!     dev_t	sn_dev;
      ino_t	sn_ino;
  # endif
  # ifdef FEAT_PROFILE
***************
*** 3049,3055 ****
  		    /* Compare dev/ino when possible, it catches symbolic
  		     * links.  Also compare file names, the inode may change
  		     * when the file was edited. */
! 		    ((stat_ok && si->sn_dev != -1)
  			&& (si->sn_dev == st.st_dev
  			    && si->sn_ino == st.st_ino)) ||
  # endif
--- 3050,3056 ----
  		    /* Compare dev/ino when possible, it catches symbolic
  		     * links.  Also compare file names, the inode may change
  		     * when the file was edited. */
! 		    ((stat_ok && si->sn_dev_valid)
  			&& (si->sn_dev == st.st_dev
  			    && si->sn_ino == st.st_ino)) ||
  # endif
***************
*** 3076,3086 ****
  # ifdef UNIX
  	if (stat_ok)
  	{
  	    si->sn_dev = st.st_dev;
  	    si->sn_ino = st.st_ino;
  	}
  	else
! 	    si->sn_dev = -1;
  # endif
  
  	/* Allocate the local script variables to use for this script. */
--- 3077,3088 ----
  # ifdef UNIX
  	if (stat_ok)
  	{
+ 	    si->sn_dev_valid = TRUE;
  	    si->sn_dev = st.st_dev;
  	    si->sn_ino = st.st_ino;
  	}
  	else
! 	    si->sn_dev_valid = FALSE;
  # endif
  
  	/* Allocate the local script variables to use for this script. */
*** ../vim-7.2.178/src/version.c	2009-05-16 21:06:36.000000000 +0200
--- src/version.c	2009-05-16 21:15:08.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     179,
  /**/

-- 
(letter from Mark to Mike, about the film's probable certificate)
      I would like to get back to the Censor and agree to lose the shits, take
      the odd Jesus Christ out and lose Oh fuck off, but to retain 'fart in
      your general direction', 'castanets of your testicles' and 'oral sex'
      and ask him for an 'A' rating on that basis.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.180
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.180
Problem:    Some more compiler warnings when using gcc -Wextra.
Solution:   Add UNUSED and type casts.
Files:	    src/buffer.c, src/ex_cmds.c, src/macros.h, src/main.c,
	    src/menu.c, src/message.c, src/misc1.c, src/mbyte.c,
	    src/normal.c, src/option.c, src/os_unix.c, src/quickfix.c,
	    src/screen.c, src/search.c, src/spell.c, src/syntax.c, src/tag.c,
	    src/term.c, src/ui.c


*** ../vim-7.2.179/src/buffer.c	2009-05-14 22:19:19.000000000 +0200
--- src/buffer.c	2009-05-16 22:21:41.000000000 +0200
***************
*** 2025,2037 ****
   * Return fnum of the found buffer.
   * Return < 0 for error.
   */
- /*ARGSUSED*/
      int
  buflist_findpat(pattern, pattern_end, unlisted, diffmode)
      char_u	*pattern;
      char_u	*pattern_end;	/* pointer to first char after pattern */
      int		unlisted;	/* find unlisted buffers */
!     int		diffmode;	/* find diff-mode buffers only */
  {
      buf_T	*buf;
      regprog_T	*prog;
--- 2025,2036 ----
   * Return fnum of the found buffer.
   * Return < 0 for error.
   */
      int
  buflist_findpat(pattern, pattern_end, unlisted, diffmode)
      char_u	*pattern;
      char_u	*pattern_end;	/* pointer to first char after pattern */
      int		unlisted;	/* find unlisted buffers */
!     int		diffmode UNUSED; /* find diff-mode buffers only */
  {
      buf_T	*buf;
      regprog_T	*prog;
***************
*** 2539,2545 ****
  /*
   * List all know file names (for :files and :buffers command).
   */
- /*ARGSUSED*/
      void
  buflist_list(eap)
      exarg_T	*eap;
--- 2538,2543 ----
***************
*** 3346,3359 ****
   * If maxwidth is not zero, the string will be filled at any middle marker
   * or truncated if too long, fillchar is used for all whitespace.
   */
- /*ARGSUSED*/
      int
  build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar, maxwidth, hltab, tabtab)
      win_T	*wp;
      char_u	*out;		/* buffer to write into != NameBuff */
      size_t	outlen;		/* length of out[] */
      char_u	*fmt;
!     int		use_sandbox;	/* "fmt" was set insecurely, use sandbox */
      int		fillchar;
      int		maxwidth;
      struct stl_hlrec *hltab;	/* return: HL attributes (can be NULL) */
--- 3344,3356 ----
   * If maxwidth is not zero, the string will be filled at any middle marker
   * or truncated if too long, fillchar is used for all whitespace.
   */
      int
  build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar, maxwidth, hltab, tabtab)
      win_T	*wp;
      char_u	*out;		/* buffer to write into != NameBuff */
      size_t	outlen;		/* length of out[] */
      char_u	*fmt;
!     int		use_sandbox UNUSED; /* "fmt" was set insecurely, use sandbox */
      int		fillchar;
      int		maxwidth;
      struct stl_hlrec *hltab;	/* return: HL attributes (can be NULL) */
*** ../vim-7.2.179/src/ex_cmds.c	2009-05-16 16:36:25.000000000 +0200
--- src/ex_cmds.c	2009-05-16 22:22:46.000000000 +0200
***************
*** 2255,2266 ****
   *
   * Return the string in allocated memory (NULL when out of memory).
   */
- /*ARGSUSED*/
      char_u *
  viminfo_readstring(virp, off, convert)
      vir_T	*virp;
      int		off;		    /* offset for virp->vir_line */
!     int		convert;	    /* convert the string */
  {
      char_u	*retval;
      char_u	*s, *d;
--- 2255,2265 ----
   *
   * Return the string in allocated memory (NULL when out of memory).
   */
      char_u *
  viminfo_readstring(virp, off, convert)
      vir_T	*virp;
      int		off;		    /* offset for virp->vir_line */
!     int		convert UNUSED;	    /* convert the string */
  {
      char_u	*retval;
      char_u	*s, *d;
***************
*** 2736,2742 ****
   * May set eap->forceit if a dialog says it's OK to overwrite.
   * Return OK if it's OK, FAIL if it is not.
   */
- /*ARGSUSED*/
      static int
  check_overwrite(eap, buf, fname, ffname, other)
      exarg_T	*eap;
--- 2735,2740 ----
*** ../vim-7.2.179/src/macros.h	2009-02-21 20:27:00.000000000 +0100
--- src/macros.h	2009-05-16 21:52:56.000000000 +0200
***************
*** 284,290 ****
  # define mb_cptr2len(p)	    (enc_utf8 ? utf_ptr2len(p) : (*mb_ptr2len)(p))
  
  # define MB_COPY_CHAR(f, t) if (has_mbyte) mb_copy_char(&f, &t); else *t++ = *f++
! # define MB_CHARLEN(p)	    (has_mbyte ? mb_charlen(p) : STRLEN(p))
  # define PTR2CHAR(p)	    (has_mbyte ? mb_ptr2char(p) : (int)*(p))
  #else
  # define mb_ptr_adv(p)		++p
--- 284,290 ----
  # define mb_cptr2len(p)	    (enc_utf8 ? utf_ptr2len(p) : (*mb_ptr2len)(p))
  
  # define MB_COPY_CHAR(f, t) if (has_mbyte) mb_copy_char(&f, &t); else *t++ = *f++
! # define MB_CHARLEN(p)	    (has_mbyte ? mb_charlen(p) : (int)STRLEN(p))
  # define PTR2CHAR(p)	    (has_mbyte ? mb_ptr2char(p) : (int)*(p))
  #else
  # define mb_ptr_adv(p)		++p
*** ../vim-7.2.179/src/main.c	2008-11-28 21:26:50.000000000 +0100
--- src/main.c	2009-05-16 22:25:59.000000000 +0200
***************
*** 1505,1514 ****
   *
   * Also find the --server... arguments and --socketid and --windowid
   */
- /*ARGSUSED*/
      static void
  early_arg_scan(parmp)
!     mparm_T	*parmp;
  {
  #if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER) \
  	|| !defined(FEAT_NETBEANS_INTG)
--- 1505,1513 ----
   *
   * Also find the --server... arguments and --socketid and --windowid
   */
      static void
  early_arg_scan(parmp)
!     mparm_T	*parmp UNUSED;
  {
  #if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER) \
  	|| !defined(FEAT_NETBEANS_INTG)
***************
*** 2380,2389 ****
   * Create the requested number of windows and edit buffers in them.
   * Also does recovery if "recoverymode" set.
   */
- /*ARGSUSED*/
      static void
  create_windows(parmp)
!     mparm_T	*parmp;
  {
  #ifdef FEAT_WINDOWS
      int		dorewind;
--- 2379,2387 ----
   * Create the requested number of windows and edit buffers in them.
   * Also does recovery if "recoverymode" set.
   */
      static void
  create_windows(parmp)
!     mparm_T	*parmp UNUSED;
  {
  #ifdef FEAT_WINDOWS
      int		dorewind;
***************
*** 3851,3860 ****
   * return an allocated string.  Otherwise return "data".
   * "*tofree" is set to the result when it needs to be freed later.
   */
- /*ARGSUSED*/
      char_u *
  serverConvert(client_enc, data, tofree)
!     char_u *client_enc;
      char_u *data;
      char_u **tofree;
  {
--- 3849,3857 ----
   * return an allocated string.  Otherwise return "data".
   * "*tofree" is set to the result when it needs to be freed later.
   */
      char_u *
  serverConvert(client_enc, data, tofree)
!     char_u *client_enc UNUSED;
      char_u *data;
      char_u **tofree;
  {
*** ../vim-7.2.179/src/menu.c	2009-05-16 17:29:37.000000000 +0200
--- src/menu.c	2009-05-16 22:29:31.000000000 +0200
***************
*** 2340,2349 ****
   * This function is also defined without the +multi_lang feature, in which
   * case the commands are ignored.
   */
- /*ARGSUSED*/
      void
  ex_menutranslate(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_MULTI_LANG
      char_u		*arg = eap->arg;
--- 2340,2348 ----
   * This function is also defined without the +multi_lang feature, in which
   * case the commands are ignored.
   */
      void
  ex_menutranslate(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_MULTI_LANG
      char_u		*arg = eap->arg;
*** ../vim-7.2.179/src/message.c	2009-04-22 14:42:26.000000000 +0200
--- src/message.c	2009-05-16 22:30:47.000000000 +0200
***************
*** 818,827 ****
  /*
   * ":messages" command.
   */
- /*ARGSUSED*/
      void
  ex_messages(eap)
!     exarg_T	*eap;
  {
      struct msg_hist *p;
      char_u	    *s;
--- 818,826 ----
  /*
   * ":messages" command.
   */
      void
  ex_messages(eap)
!     exarg_T	*eap UNUSED;
  {
      struct msg_hist *p;
      char_u	    *s;
***************
*** 3290,3304 ****
   * A '&' in a button name becomes a shortcut, so each '&' should be before a
   * different letter.
   */
- /* ARGSUSED */
      int
  do_dialog(type, title, message, buttons, dfltbutton, textfield)
!     int		type;
!     char_u	*title;
      char_u	*message;
      char_u	*buttons;
      int		dfltbutton;
!     char_u	*textfield;	/* IObuff for inputdialog(), NULL otherwise */
  {
      int		oldState;
      int		retval = 0;
--- 3289,3303 ----
   * A '&' in a button name becomes a shortcut, so each '&' should be before a
   * different letter.
   */
      int
  do_dialog(type, title, message, buttons, dfltbutton, textfield)
!     int		type UNUSED;
!     char_u	*title UNUSED;
      char_u	*message;
      char_u	*buttons;
      int		dfltbutton;
!     char_u	*textfield UNUSED;	/* IObuff for inputdialog(), NULL
! 					   otherwise */
  {
      int		oldState;
      int		retval = 0;
***************
*** 4021,4027 ****
  	if (*p != '%')
  	{
  	    char    *q = strchr(p + 1, '%');
! 	    size_t  n = (q == NULL) ? STRLEN(p) : (q - p);
  
  	    /* Copy up to the next '%' or NUL without any changes. */
  	    if (str_l < str_m)
--- 4020,4026 ----
  	if (*p != '%')
  	{
  	    char    *q = strchr(p + 1, '%');
! 	    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);
  
  	    /* Copy up to the next '%' or NUL without any changes. */
  	    if (str_l < str_m)
***************
*** 4268,4274 ****
  				  precision <= (size_t)0x7fffffffL ? precision
  						       : (size_t)0x7fffffffL);
  #endif
! 			str_arg_l = (q == NULL) ? precision : q - str_arg;
  		    }
  		    break;
  
--- 4267,4274 ----
  				  precision <= (size_t)0x7fffffffL ? precision
  						       : (size_t)0x7fffffffL);
  #endif
! 			str_arg_l = (q == NULL) ? precision
! 						      : (size_t)(q - str_arg);
  		    }
  		    break;
  
***************
*** 4368,4374 ****
  					    get_a_arg(arg_idx);
  #else
  # if defined(FEAT_EVAL)
! 					    tvs != NULL ? tv_nr(tvs, &arg_idx) :
  # endif
  						va_arg(ap, unsigned int);
  #endif
--- 4368,4375 ----
  					    get_a_arg(arg_idx);
  #else
  # if defined(FEAT_EVAL)
! 					    tvs != NULL ? (unsigned)
! 							tv_nr(tvs, &arg_idx) :
  # endif
  						va_arg(ap, unsigned int);
  #endif
***************
*** 4381,4387 ****
  					    get_a_arg(arg_idx);
  #else
  # if defined(FEAT_EVAL)
! 					    tvs != NULL ? tv_nr(tvs, &arg_idx) :
  # endif
  						va_arg(ap, unsigned long int);
  #endif
--- 4382,4389 ----
  					    get_a_arg(arg_idx);
  #else
  # if defined(FEAT_EVAL)
! 					    tvs != NULL ? (unsigned long)
! 							tv_nr(tvs, &arg_idx) :
  # endif
  						va_arg(ap, unsigned long int);
  #endif
***************
*** 4704,4710 ****
  			size_t avail = str_m - str_l;
  
  			vim_memset(str + str_l, zero_padding ? '0' : ' ',
! 					     (size_t)pn > avail ? avail : pn);
  		    }
  		    str_l += pn;
  		}
--- 4706,4713 ----
  			size_t avail = str_m - str_l;
  
  			vim_memset(str + str_l, zero_padding ? '0' : ' ',
! 					     (size_t)pn > avail ? avail
! 								: (size_t)pn);
  		    }
  		    str_l += pn;
  		}
***************
*** 4731,4737 ****
  			size_t avail = str_m - str_l;
  
  			mch_memmove(str + str_l, str_arg,
! 					     (size_t)zn > avail ? avail : zn);
  		    }
  		    str_l += zn;
  		}
--- 4734,4741 ----
  			size_t avail = str_m - str_l;
  
  			mch_memmove(str + str_l, str_arg,
! 					     (size_t)zn > avail ? avail
! 								: (size_t)zn);
  		    }
  		    str_l += zn;
  		}
***************
*** 4746,4752 ****
  			size_t avail = str_m-str_l;
  
  			vim_memset(str + str_l, '0',
! 					     (size_t)zn > avail ? avail : zn);
  		    }
  		    str_l += zn;
  		}
--- 4750,4757 ----
  			size_t avail = str_m-str_l;
  
  			vim_memset(str + str_l, '0',
! 					     (size_t)zn > avail ? avail
! 								: (size_t)zn);
  		    }
  		    str_l += zn;
  		}
***************
*** 4765,4771 ****
  
  			mch_memmove(str + str_l,
  				str_arg + zero_padding_insertion_ind,
! 				(size_t)sn > avail ? avail : sn);
  		    }
  		    str_l += sn;
  		}
--- 4770,4776 ----
  
  			mch_memmove(str + str_l,
  				str_arg + zero_padding_insertion_ind,
! 				(size_t)sn > avail ? avail : (size_t)sn);
  		    }
  		    str_l += sn;
  		}
***************
*** 4785,4791 ****
  			size_t avail = str_m - str_l;
  
  			vim_memset(str + str_l, ' ',
! 					     (size_t)pn > avail ? avail : pn);
  		    }
  		    str_l += pn;
  		}
--- 4790,4797 ----
  			size_t avail = str_m - str_l;
  
  			vim_memset(str + str_l, ' ',
! 					     (size_t)pn > avail ? avail
! 								: (size_t)pn);
  		    }
  		    str_l += pn;
  		}
*** ../vim-7.2.179/src/misc1.c	2009-05-15 21:31:11.000000000 +0200
--- src/misc1.c	2009-05-16 21:25:34.000000000 +0200
***************
*** 4147,4156 ****
  /*
   * Function given to ExpandGeneric() to obtain an environment variable name.
   */
- /*ARGSUSED*/
      char_u *
  get_env_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
  # if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
--- 4147,4155 ----
  /*
   * Function given to ExpandGeneric() to obtain an environment variable name.
   */
      char_u *
  get_env_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
  # if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
***************
*** 4742,4750 ****
  	 * If it is then restrict the search to below this line and try again.
  	 */
  	line = ml_get(pos->lnum);
! 	for (p = line; *p && (unsigned)(p - line) < pos->col; ++p)
  	    p = skip_string(p);
! 	if ((unsigned)(p - line) <= pos->col)
  	    break;
  	cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;
  	if (cur_maxcomment <= 0)
--- 4741,4749 ----
  	 * If it is then restrict the search to below this line and try again.
  	 */
  	line = ml_get(pos->lnum);
! 	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
  	    p = skip_string(p);
! 	if ((colnr_T)(p - line) <= pos->col)
  	    break;
  	cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;
  	if (cur_maxcomment <= 0)
***************
*** 6275,6281 ****
       * check for that.
       */
      if ((State & INSERT)
! 	    && curwin->w_cursor.col < STRLEN(linecopy)
  	    && linecopy[curwin->w_cursor.col] == ')')
  	linecopy[curwin->w_cursor.col] = NUL;
  
--- 6274,6280 ----
       * check for that.
       */
      if ((State & INSERT)
! 	    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)
  	    && linecopy[curwin->w_cursor.col] == ')')
  	linecopy[curwin->w_cursor.col] = NUL;
  
*** ../vim-7.2.179/src/mbyte.c	2008-11-28 21:26:50.000000000 +0100
--- src/mbyte.c	2009-05-16 22:29:02.000000000 +0200
***************
*** 1015,1024 ****
   * Return length in bytes of character "c".
   * Returns 1 for a single-byte character.
   */
- /* ARGSUSED */
      int
  latin_char2len(c)
!     int		c;
  {
      return 1;
  }
--- 1015,1023 ----
   * Return length in bytes of character "c".
   * Returns 1 for a single-byte character.
   */
      int
  latin_char2len(c)
!     int		c UNUSED;
  {
      return 1;
  }
***************
*** 1248,1257 ****
   * Return the number of display cells character at "*p" occupies.
   * This doesn't take care of unprintable characters, use ptr2cells() for that.
   */
- /*ARGSUSED*/
      int
  latin_ptr2cells(p)
!     char_u	*p;
  {
      return 1;
  }
--- 1247,1255 ----
   * Return the number of display cells character at "*p" occupies.
   * This doesn't take care of unprintable characters, use ptr2cells() for that.
   */
      int
  latin_ptr2cells(p)
!     char_u	*p UNUSED;
  {
      return 1;
  }
***************
*** 1293,1302 ****
   * Return the number of display cells character "c" occupies.
   * Only takes care of multi-byte chars, not "^C" and such.
   */
- /*ARGSUSED*/
      int
  latin_char2cells(c)
!     int		c;
  {
      return 1;
  }
--- 1291,1299 ----
   * Return the number of display cells character "c" occupies.
   * Only takes care of multi-byte chars, not "^C" and such.
   */
      int
  latin_char2cells(c)
!     int		c UNUSED;
  {
      return 1;
  }
***************
*** 1318,1328 ****
   * Return number of display cells for char at ScreenLines[off].
   * We make sure that the offset used is less than "max_off".
   */
- /*ARGSUSED*/
      int
  latin_off2cells(off, max_off)
!     unsigned	off;
!     unsigned	max_off;
  {
      return 1;
  }
--- 1315,1324 ----
   * Return number of display cells for char at ScreenLines[off].
   * We make sure that the offset used is less than "max_off".
   */
      int
  latin_off2cells(off, max_off)
!     unsigned	off UNUSED;
!     unsigned	max_off UNUSED;
  {
      return 1;
  }
***************
*** 2419,2429 ****
   * Return offset from "p" to the first byte of the character it points into.
   * Returns 0 when already at the first byte of a character.
   */
- /*ARGSUSED*/
      int
  latin_head_off(base, p)
!     char_u	*base;
!     char_u	*p;
  {
      return 0;
  }
--- 2415,2424 ----
   * Return offset from "p" to the first byte of the character it points into.
   * Returns 0 when already at the first byte of a character.
   */
      int
  latin_head_off(base, p)
!     char_u	*base UNUSED;
!     char_u	*p UNUSED;
  {
      return 0;
  }
***************
*** 3131,3137 ****
  	else
  	    s = p + 1;
      }
!     for (i = 0; s[i] != NUL && i < sizeof(buf) - 1; ++i)
      {
  	if (s[i] == '_' || s[i] == '-')
  	    buf[i] = '-';
--- 3126,3132 ----
  	else
  	    s = p + 1;
      }
!     for (i = 0; s[i] != NUL && i < (int)sizeof(buf) - 1; ++i)
      {
  	if (s[i] == '_' || s[i] == '-')
  	    buf[i] = '-';
***************
*** 3582,3590 ****
   * Callback invoked when the user finished preediting.
   * Put the final string into the input buffer.
   */
- /*ARGSUSED0*/
      static void
! im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)
  {
      int	slen = (int)STRLEN(str);
      int	add_to_input = TRUE;
--- 3577,3586 ----
   * Callback invoked when the user finished preediting.
   * Put the final string into the input buffer.
   */
      static void
! im_commit_cb(GtkIMContext *context UNUSED,
! 	     const gchar *str,
! 	     gpointer data UNUSED)
  {
      int	slen = (int)STRLEN(str);
      int	add_to_input = TRUE;
***************
*** 3670,3678 ****
  /*
   * Callback invoked after start to the preedit.
   */
- /*ARGSUSED*/
      static void
! im_preedit_start_cb(GtkIMContext *context, gpointer data)
  {
  #ifdef XIM_DEBUG
      xim_log("im_preedit_start_cb()\n");
--- 3666,3673 ----
  /*
   * Callback invoked after start to the preedit.
   */
      static void
! im_preedit_start_cb(GtkIMContext *context UNUSED, gpointer data UNUSED)
  {
  #ifdef XIM_DEBUG
      xim_log("im_preedit_start_cb()\n");
***************
*** 3687,3695 ****
  /*
   * Callback invoked after end to the preedit.
   */
- /*ARGSUSED*/
      static void
! im_preedit_end_cb(GtkIMContext *context, gpointer data)
  {
  #ifdef XIM_DEBUG
      xim_log("im_preedit_end_cb()\n");
--- 3682,3689 ----
  /*
   * Callback invoked after end to the preedit.
   */
      static void
! im_preedit_end_cb(GtkIMContext *context UNUSED, gpointer data UNUSED)
  {
  #ifdef XIM_DEBUG
      xim_log("im_preedit_end_cb()\n");
***************
*** 3748,3756 ****
   * remaining input from within the "retrieve_surrounding" signal handler, this
   * might not be necessary.  Gotta ask on vim-dev for opinions.
   */
- /*ARGSUSED1*/
      static void
! im_preedit_changed_cb(GtkIMContext *context, gpointer data)
  {
      char    *preedit_string = NULL;
      int	    cursor_index    = 0;
--- 3742,3749 ----
   * remaining input from within the "retrieve_surrounding" signal handler, this
   * might not be necessary.  Gotta ask on vim-dev for opinions.
   */
      static void
! im_preedit_changed_cb(GtkIMContext *context, gpointer data UNUSED)
  {
      char    *preedit_string = NULL;
      int	    cursor_index    = 0;
***************
*** 4616,4626 ****
      }
  }
  
- /*ARGSUSED*/
      void
  im_set_position(row, col)
!     int		row;
!     int		col;
  {
      xim_set_preedit();
  }
--- 4609,4618 ----
      }
  }
  
      void
  im_set_position(row, col)
!     int		row UNUSED;
!     int		col UNUSED;
  {
      xim_set_preedit();
  }
***************
*** 4927,4938 ****
  static void xim_instantiate_cb __ARGS((Display *display, XPointer client_data, XPointer	call_data));
  static void xim_destroy_cb __ARGS((XIM im, XPointer client_data, XPointer call_data));
  
- /*ARGSUSED*/
      static void
  xim_instantiate_cb(display, client_data, call_data)
      Display	*display;
!     XPointer	client_data;
!     XPointer	call_data;
  {
      Window	x11_window;
      Display	*x11_display;
--- 4919,4929 ----
  static void xim_instantiate_cb __ARGS((Display *display, XPointer client_data, XPointer	call_data));
  static void xim_destroy_cb __ARGS((XIM im, XPointer client_data, XPointer call_data));
  
      static void
  xim_instantiate_cb(display, client_data, call_data)
      Display	*display;
!     XPointer	client_data UNUSED;
!     XPointer	call_data UNUSED;
  {
      Window	x11_window;
      Display	*x11_display;
***************
*** 4952,4963 ****
  					 xim_instantiate_cb, NULL);
  }
  
- /*ARGSUSED*/
      static void
  xim_destroy_cb(im, client_data, call_data)
!     XIM		im;
!     XPointer	client_data;
!     XPointer	call_data;
  {
      Window	x11_window;
      Display	*x11_display;
--- 4943,4953 ----
  					 xim_instantiate_cb, NULL);
  }
  
      static void
  xim_destroy_cb(im, client_data, call_data)
!     XIM		im UNUSED;
!     XPointer	client_data UNUSED;
!     XPointer	call_data UNUSED;
  {
      Window	x11_window;
      Display	*x11_display;
***************
*** 5276,5284 ****
      }
  }
  
- /*ARGSUSED*/
      static void
! preedit_start_cbproc(XIC thexic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("xim_decide_input_style()\n");
--- 5266,5275 ----
      }
  }
  
      static void
! preedit_start_cbproc(XIC thexic UNUSED,
! 	             XPointer client_data UNUSED,
! 		     XPointer call_data UNUSED)
  {
  #ifdef XIM_DEBUG
      xim_log("xim_decide_input_style()\n");
***************
*** 5310,5318 ****
  static GSList *key_press_event_queue = NULL;
  static gboolean processing_queued_event = FALSE;
  
- /*ARGSUSED*/
      static void
! preedit_draw_cbproc(XIC thexic, XPointer client_data, XPointer call_data)
  {
      XIMPreeditDrawCallbackStruct *draw_data;
      XIMText	*text;
--- 5301,5310 ----
  static GSList *key_press_event_queue = NULL;
  static gboolean processing_queued_event = FALSE;
  
      static void
! preedit_draw_cbproc(XIC thexic UNUSED,
! 		    XPointer client_data UNUSED,
! 		    XPointer call_data)
  {
      XIMPreeditDrawCallbackStruct *draw_data;
      XIMText	*text;
***************
*** 5451,5468 ****
      return -1;
  }
  
- /*ARGSUSED*/
      static void
! preedit_caret_cbproc(XIC thexic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("preedit_caret_cbproc()\n");
  #endif
  }
  
- /*ARGSUSED*/
      static void
! preedit_done_cbproc(XIC thexic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("preedit_done_cbproc()\n");
--- 5443,5462 ----
      return -1;
  }
  
      static void
! preedit_caret_cbproc(XIC thexic UNUSED,
! 		     XPointer client_data UNUSED,
! 		     XPointer call_data UNUSED)
  {
  #ifdef XIM_DEBUG
      xim_log("preedit_caret_cbproc()\n");
  #endif
  }
  
      static void
! preedit_done_cbproc(XIC thexic UNUSED,
! 		    XPointer client_data UNUSED,
! 		    XPointer call_data UNUSED)
  {
  #ifdef XIM_DEBUG
      xim_log("preedit_done_cbproc()\n");
***************
*** 5501,5509 ****
      }
  }
  
- /*ARGSUSED*/
      int
! xim_queue_key_press_event(GdkEventKey *event, int down)
  {
  #ifdef XIM_DEBUG
      xim_log("xim_queue_key_press_event()\n");
--- 5495,5502 ----
      }
  }
  
      int
! xim_queue_key_press_event(GdkEventKey *event, int down UNUSED)
  {
  #ifdef XIM_DEBUG
      xim_log("xim_queue_key_press_event()\n");
***************
*** 5519,5527 ****
      return TRUE;
  }
  
- /*ARGSUSED*/
      static void
! preedit_callback_setup(GdkIC *ic)
  {
      XIC xxic;
      XVaNestedList preedit_attr;
--- 5512,5519 ----
      return TRUE;
  }
  
      static void
! preedit_callback_setup(GdkIC *ic UNUSED)
  {
      XIC xxic;
      XVaNestedList preedit_attr;
***************
*** 5546,5554 ****
      XFree(preedit_attr);
  }
  
- /*ARGSUSED*/
      static void
! reset_state_setup(GdkIC *ic)
  {
  #ifdef USE_X11R6_XIM
      /* don't change the input context when we call reset */
--- 5538,5545 ----
      XFree(preedit_attr);
  }
  
      static void
! reset_state_setup(GdkIC *ic UNUSED)
  {
  #ifdef USE_X11R6_XIM
      /* don't change the input context when we call reset */
*** ../vim-7.2.179/src/normal.c	2009-05-15 21:31:11.000000000 +0200
--- src/normal.c	2009-05-16 22:31:10.000000000 +0200
***************
*** 9243,9252 ****
  }
  
  #ifdef FEAT_SNIFF
- /*ARGSUSED*/
      static void
  nv_sniff(cap)
!     cmdarg_T	*cap;
  {
      ProcessSniffRequests();
  }
--- 9243,9251 ----
  }
  
  #ifdef FEAT_SNIFF
      static void
  nv_sniff(cap)
!     cmdarg_T	*cap UNUSED;
  {
      ProcessSniffRequests();
  }
***************
*** 9262,9271 ****
  #endif
  
  #ifdef FEAT_DND
- /*ARGSUSED*/
      static void
  nv_drop(cap)
!     cmdarg_T	*cap;
  {
      do_put('~', BACKWARD, 1L, PUT_CURSEND);
  }
--- 9261,9269 ----
  #endif
  
  #ifdef FEAT_DND
      static void
  nv_drop(cap)
!     cmdarg_T	*cap UNUSED;
  {
      do_put('~', BACKWARD, 1L, PUT_CURSEND);
  }
***************
*** 9277,9283 ****
   * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the
   * input buffer.  "did_cursorhold" is set to avoid retriggering.
   */
- /*ARGSUSED*/
      static void
  nv_cursorhold(cap)
      cmdarg_T	*cap;
--- 9275,9280 ----
*** ../vim-7.2.179/src/option.c	2009-05-15 21:31:11.000000000 +0200
--- src/option.c	2009-05-17 12:13:52.000000000 +0200
***************
*** 387,392 ****
--- 387,395 ----
      char_u	*def_val[2];	/* default values for variable (vi and vim) */
  #ifdef FEAT_EVAL
      scid_T	scriptID;	/* script in which the option was last set */
+ # define SCRIPTID_INIT , 0
+ #else
+ # define SCRIPTID_INIT
  #endif
  };
  
***************
*** 477,483 ****
  #else
  			    (char_u *)224L,
  #endif
! 					    (char_u *)0L}},
      {"antialias",   "anti", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
  #if defined(FEAT_GUI) && defined(MACOS_X)
  			    (char_u *)&p_antialias, PV_NONE,
--- 480,486 ----
  #else
  			    (char_u *)224L,
  #endif
! 					    (char_u *)0L} SCRIPTID_INIT},
      {"antialias",   "anti", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
  #if defined(FEAT_GUI) && defined(MACOS_X)
  			    (char_u *)&p_antialias, PV_NONE,
***************
*** 486,520 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)FALSE}
  #endif
! 			    },
      {"arabic",	    "arab", P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_ARABIC
  			    (char_u *)VAR_WIN, PV_ARAB,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"arabicshape", "arshape", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
  #ifdef FEAT_ARABIC
  			    (char_u *)&p_arshape, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"allowrevins", "ari",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)&p_ari, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"altkeymap",   "akm",  P_BOOL|P_VI_DEF,
  #ifdef FEAT_FKMAP
  			    (char_u *)&p_altkeymap, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"ambiwidth",  "ambw",  P_STRING|P_VI_DEF|P_RCLR,
  #if defined(FEAT_MBYTE)
  			    (char_u *)&p_ambw, PV_NONE,
--- 489,523 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)FALSE}
  #endif
! 			    SCRIPTID_INIT},
      {"arabic",	    "arab", P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_ARABIC
  			    (char_u *)VAR_WIN, PV_ARAB,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"arabicshape", "arshape", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
  #ifdef FEAT_ARABIC
  			    (char_u *)&p_arshape, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"allowrevins", "ari",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)&p_ari, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"altkeymap",   "akm",  P_BOOL|P_VI_DEF,
  #ifdef FEAT_FKMAP
  			    (char_u *)&p_altkeymap, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"ambiwidth",  "ambw",  P_STRING|P_VI_DEF|P_RCLR,
  #if defined(FEAT_MBYTE)
  			    (char_u *)&p_ambw, PV_NONE,
***************
*** 523,549 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
  #ifdef FEAT_AUTOCHDIR
      {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_acd, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
  #endif
      {"autoindent",  "ai",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ai, PV_AI,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"autoprint",   "ap",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"autoread",    "ar",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ar, PV_AR,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"autowrite",   "aw",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_aw, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"autowriteall","awa",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_awa, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"background",  "bg",   P_STRING|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_bg, PV_NONE,
  			    {
--- 526,552 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
  #ifdef FEAT_AUTOCHDIR
      {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_acd, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
  #endif
      {"autoindent",  "ai",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ai, PV_AI,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"autoprint",   "ap",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"autoread",    "ar",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ar, PV_AR,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"autowrite",   "aw",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_aw, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"autowriteall","awa",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_awa, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"background",  "bg",   P_STRING|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_bg, PV_NONE,
  			    {
***************
*** 552,564 ****
  #else
  			    (char_u *)"light",
  #endif
! 					    (char_u *)0L}},
      {"backspace",   "bs",   P_STRING|P_VI_DEF|P_VIM|P_COMMA|P_NODUP,
  			    (char_u *)&p_bs, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"backup",	    "bk",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_bk, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"backupcopy",  "bkc",  P_STRING|P_VIM|P_COMMA|P_NODUP,
  			    (char_u *)&p_bkc, PV_NONE,
  #ifdef UNIX
--- 555,567 ----
  #else
  			    (char_u *)"light",
  #endif
! 					    (char_u *)0L} SCRIPTID_INIT},
      {"backspace",   "bs",   P_STRING|P_VI_DEF|P_VIM|P_COMMA|P_NODUP,
  			    (char_u *)&p_bs, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"backup",	    "bk",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_bk, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"backupcopy",  "bkc",  P_STRING|P_VIM|P_COMMA|P_NODUP,
  			    (char_u *)&p_bkc, PV_NONE,
  #ifdef UNIX
***************
*** 566,575 ****
  #else
  			    {(char_u *)"auto", (char_u *)"auto"}
  #endif
! 			    },
      {"backupdir",   "bdir", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
  			    (char_u *)&p_bdir, PV_NONE,
! 			    {(char_u *)DFLT_BDIR, (char_u *)0L}},
      {"backupext",   "bex",  P_STRING|P_VI_DEF|P_NFNAME,
  			    (char_u *)&p_bex, PV_NONE,
  			    {
--- 569,578 ----
  #else
  			    {(char_u *)"auto", (char_u *)"auto"}
  #endif
! 			    SCRIPTID_INIT},
      {"backupdir",   "bdir", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
  			    (char_u *)&p_bdir, PV_NONE,
! 			    {(char_u *)DFLT_BDIR, (char_u *)0L} SCRIPTID_INIT},
      {"backupext",   "bex",  P_STRING|P_VI_DEF|P_NFNAME,
  			    (char_u *)&p_bex, PV_NONE,
  			    {
***************
*** 578,584 ****
  #else
  			    (char_u *)"~",
  #endif
! 					    (char_u *)0L}},
      {"backupskip",  "bsk",  P_STRING|P_VI_DEF|P_COMMA,
  #ifdef FEAT_WILDIGN
  			    (char_u *)&p_bsk, PV_NONE,
--- 581,587 ----
  #else
  			    (char_u *)"~",
  #endif
! 					    (char_u *)0L} SCRIPTID_INIT},
      {"backupskip",  "bsk",  P_STRING|P_VI_DEF|P_COMMA,
  #ifdef FEAT_WILDIGN
  			    (char_u *)&p_bsk, PV_NONE,
***************
*** 587,626 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
  #ifdef FEAT_BEVAL
      {"balloondelay","bdlay",P_NUM|P_VI_DEF,
  			    (char_u *)&p_bdlay, PV_NONE,
! 			    {(char_u *)600L, (char_u *)0L}},
      {"ballooneval", "beval",P_BOOL|P_VI_DEF|P_NO_MKRC,
  			    (char_u *)&p_beval, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
  # ifdef FEAT_EVAL
      {"balloonexpr", "bexpr", P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  			    (char_u *)&p_bexpr, PV_BEXPR,
! 			    {(char_u *)"", (char_u *)0L}},
  # endif
  #endif
      {"beautify",    "bf",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"binary",	    "bin",  P_BOOL|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_bin, PV_BIN,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"bioskey",	    "biosk",P_BOOL|P_VI_DEF,
  #ifdef MSDOS
  			    (char_u *)&p_biosk, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"bomb",	    NULL,   P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_bomb, PV_BOMB,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"breakat",	    "brk",  P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
  #ifdef FEAT_LINEBREAK
  			    (char_u *)&p_breakat, PV_NONE,
--- 590,629 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
  #ifdef FEAT_BEVAL
      {"balloondelay","bdlay",P_NUM|P_VI_DEF,
  			    (char_u *)&p_bdlay, PV_NONE,
! 			    {(char_u *)600L, (char_u *)0L} SCRIPTID_INIT},
      {"ballooneval", "beval",P_BOOL|P_VI_DEF|P_NO_MKRC,
  			    (char_u *)&p_beval, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
  # ifdef FEAT_EVAL
      {"balloonexpr", "bexpr", P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  			    (char_u *)&p_bexpr, PV_BEXPR,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
  # endif
  #endif
      {"beautify",    "bf",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"binary",	    "bin",  P_BOOL|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_bin, PV_BIN,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"bioskey",	    "biosk",P_BOOL|P_VI_DEF,
  #ifdef MSDOS
  			    (char_u *)&p_biosk, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"bomb",	    NULL,   P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_bomb, PV_BOMB,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"breakat",	    "brk",  P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
  #ifdef FEAT_LINEBREAK
  			    (char_u *)&p_breakat, PV_NONE,
***************
*** 629,635 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"browsedir",   "bsdir",P_STRING|P_VI_DEF,
  #ifdef FEAT_BROWSE
  			    (char_u *)&p_bsdir, PV_NONE,
--- 632,638 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"browsedir",   "bsdir",P_STRING|P_VI_DEF,
  #ifdef FEAT_BROWSE
  			    (char_u *)&p_bsdir, PV_NONE,
***************
*** 638,644 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"bufhidden",   "bh",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
  #if defined(FEAT_QUICKFIX)
  			    (char_u *)&p_bh, PV_BH,
--- 641,647 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"bufhidden",   "bh",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
  #if defined(FEAT_QUICKFIX)
  			    (char_u *)&p_bh, PV_BH,
***************
*** 647,657 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"buflisted",   "bl",   P_BOOL|P_VI_DEF|P_NOGLOB,
  			    (char_u *)&p_bl, PV_BL,
  			    {(char_u *)1L, (char_u *)0L}
! 			    },
      {"buftype",	    "bt",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
  #if defined(FEAT_QUICKFIX)
  			    (char_u *)&p_bt, PV_BT,
--- 650,660 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"buflisted",   "bl",   P_BOOL|P_VI_DEF|P_NOGLOB,
  			    (char_u *)&p_bl, PV_BL,
  			    {(char_u *)1L, (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"buftype",	    "bt",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
  #if defined(FEAT_QUICKFIX)
  			    (char_u *)&p_bt, PV_BT,
***************
*** 660,666 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"casemap",	    "cmp",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_cmp, PV_NONE,
--- 663,669 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"casemap",	    "cmp",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_cmp, PV_NONE,
***************
*** 669,675 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"cdpath",	    "cd",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SEARCHPATH
  			    (char_u *)&p_cdpath, PV_NONE,
--- 672,678 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"cdpath",	    "cd",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SEARCHPATH
  			    (char_u *)&p_cdpath, PV_NONE,
***************
*** 678,684 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"cedit",	    NULL,   P_STRING,
  #ifdef FEAT_CMDWIN
  			    (char_u *)&p_cedit, PV_NONE,
--- 681,687 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"cedit",	    NULL,   P_STRING,
  #ifdef FEAT_CMDWIN
  			    (char_u *)&p_cedit, PV_NONE,
***************
*** 687,693 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"charconvert",  "ccv", P_STRING|P_VI_DEF|P_SECURE,
  #if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
  			    (char_u *)&p_ccv, PV_NONE,
--- 690,696 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"charconvert",  "ccv", P_STRING|P_VI_DEF|P_SECURE,
  #if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
  			    (char_u *)&p_ccv, PV_NONE,
***************
*** 696,709 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"cindent",	    "cin",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_CINDENT
  			    (char_u *)&p_cin, PV_CIN,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"cinkeys",	    "cink", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_CINDENT
  			    (char_u *)&p_cink, PV_CINK,
--- 699,712 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"cindent",	    "cin",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_CINDENT
  			    (char_u *)&p_cin, PV_CIN,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"cinkeys",	    "cink", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_CINDENT
  			    (char_u *)&p_cink, PV_CINK,
***************
*** 712,725 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"cinoptions",  "cino", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_CINDENT
  			    (char_u *)&p_cino, PV_CINO,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"cinwords",    "cinw", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
  			    (char_u *)&p_cinw, PV_CINW,
--- 715,728 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"cinoptions",  "cino", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_CINDENT
  			    (char_u *)&p_cino, PV_CINO,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"cinwords",    "cinw", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
  			    (char_u *)&p_cinw, PV_CINW,
***************
*** 729,735 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"clipboard",   "cb",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_CLIPBOARD
  			    (char_u *)&p_cb, PV_NONE,
--- 732,738 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"clipboard",   "cb",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_CLIPBOARD
  			    (char_u *)&p_cb, PV_NONE,
***************
*** 743,762 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #endif
! 			    },
      {"cmdheight",   "ch",   P_NUM|P_VI_DEF|P_RALL,
  			    (char_u *)&p_ch, PV_NONE,
! 			    {(char_u *)1L, (char_u *)0L}},
      {"cmdwinheight", "cwh", P_NUM|P_VI_DEF,
  #ifdef FEAT_CMDWIN
  			    (char_u *)&p_cwh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)7L, (char_u *)0L}},
      {"columns",	    "co",   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
  			    (char_u *)&Columns, PV_NONE,
! 			    {(char_u *)80L, (char_u *)0L}},
      {"comments",    "com",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_COMMENTS
  			    (char_u *)&p_com, PV_COM,
--- 746,765 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"cmdheight",   "ch",   P_NUM|P_VI_DEF|P_RALL,
  			    (char_u *)&p_ch, PV_NONE,
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"cmdwinheight", "cwh", P_NUM|P_VI_DEF,
  #ifdef FEAT_CMDWIN
  			    (char_u *)&p_cwh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)7L, (char_u *)0L} SCRIPTID_INIT},
      {"columns",	    "co",   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
  			    (char_u *)&Columns, PV_NONE,
! 			    {(char_u *)80L, (char_u *)0L} SCRIPTID_INIT},
      {"comments",    "com",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_COMMENTS
  			    (char_u *)&p_com, PV_COM,
***************
*** 766,772 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"commentstring", "cms", P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_FOLDING
  			    (char_u *)&p_cms, PV_CMS,
--- 769,775 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"commentstring", "cms", P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_FOLDING
  			    (char_u *)&p_cms, PV_CMS,
***************
*** 775,786 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
  			    /* P_PRI_MKRC isn't needed here, optval_default()
  			     * always returns TRUE for 'compatible' */
      {"compatible",  "cp",   P_BOOL|P_RALL,
  			    (char_u *)&p_cp, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)FALSE}},
      {"complete",    "cpt",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_cpt, PV_CPT,
--- 778,789 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
  			    /* P_PRI_MKRC isn't needed here, optval_default()
  			     * always returns TRUE for 'compatible' */
      {"compatible",  "cp",   P_BOOL|P_RALL,
  			    (char_u *)&p_cp, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)FALSE} SCRIPTID_INIT},
      {"complete",    "cpt",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_cpt, PV_CPT,
***************
*** 789,795 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"completefunc", "cfu", P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
  #ifdef FEAT_COMPL_FUNC
  			    (char_u *)&p_cfu, PV_CFU,
--- 792,798 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"completefunc", "cfu", P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
  #ifdef FEAT_COMPL_FUNC
  			    (char_u *)&p_cfu, PV_CFU,
***************
*** 798,804 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"completeopt",   "cot",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_cot, PV_NONE,
--- 801,807 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"completeopt",   "cot",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_cot, PV_NONE,
***************
*** 807,840 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"confirm",     "cf",   P_BOOL|P_VI_DEF,
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  			    (char_u *)&p_confirm, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"conskey",	    "consk",P_BOOL|P_VI_DEF,
  #ifdef MSDOS
  			    (char_u *)&p_consk, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"copyindent",  "ci",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_ci, PV_CI,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"cpoptions",   "cpo",  P_STRING|P_VIM|P_RALL|P_FLAGLIST,
  			    (char_u *)&p_cpo, PV_NONE,
! 			    {(char_u *)CPO_VI, (char_u *)CPO_VIM}},
      {"cscopepathcomp", "cspc", P_NUM|P_VI_DEF|P_VIM,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_cspc, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L}},
      {"cscopeprg",   "csprg", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_csprg, PV_NONE,
--- 810,844 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"confirm",     "cf",   P_BOOL|P_VI_DEF,
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  			    (char_u *)&p_confirm, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"conskey",	    "consk",P_BOOL|P_VI_DEF,
  #ifdef MSDOS
  			    (char_u *)&p_consk, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"copyindent",  "ci",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_ci, PV_CI,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"cpoptions",   "cpo",  P_STRING|P_VIM|P_RALL|P_FLAGLIST,
  			    (char_u *)&p_cpo, PV_NONE,
! 			    {(char_u *)CPO_VI, (char_u *)CPO_VIM}
! 			    SCRIPTID_INIT},
      {"cscopepathcomp", "cspc", P_NUM|P_VI_DEF|P_VIM,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_cspc, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"cscopeprg",   "csprg", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_csprg, PV_NONE,
***************
*** 843,849 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"cscopequickfix", "csqf", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)
  			    (char_u *)&p_csqf, PV_NONE,
--- 847,853 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"cscopequickfix", "csqf", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)
  			    (char_u *)&p_csqf, PV_NONE,
***************
*** 852,896 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"cscopetag",   "cst",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_cst, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L}},
      {"cscopetagorder", "csto", P_NUM|P_VI_DEF|P_VIM,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_csto, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L}},
      {"cscopeverbose", "csverb", P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_csverbose, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L}},
      {"cursorcolumn", "cuc", P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_SYN_HL
  			    (char_u *)VAR_WIN, PV_CUC,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"cursorline",   "cul", P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_SYN_HL
  			    (char_u *)VAR_WIN, PV_CUL,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"debug",	    NULL,   P_STRING|P_VI_DEF,
  			    (char_u *)&p_debug, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"define",	    "def",  P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_FIND_ID
  			    (char_u *)&p_def, PV_DEF,
--- 856,900 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"cscopetag",   "cst",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_cst, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"cscopetagorder", "csto", P_NUM|P_VI_DEF|P_VIM,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_csto, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"cscopeverbose", "csverb", P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_CSCOPE
  			    (char_u *)&p_csverbose, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"cursorcolumn", "cuc", P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_SYN_HL
  			    (char_u *)VAR_WIN, PV_CUC,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"cursorline",   "cul", P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_SYN_HL
  			    (char_u *)VAR_WIN, PV_CUL,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"debug",	    NULL,   P_STRING|P_VI_DEF,
  			    (char_u *)&p_debug, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"define",	    "def",  P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_FIND_ID
  			    (char_u *)&p_def, PV_DEF,
***************
*** 899,926 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"delcombine", "deco",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_deco, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_dict, PV_DICT,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"diff",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN|P_NOGLOB,
  #ifdef FEAT_DIFF
  			    (char_u *)VAR_WIN, PV_DIFF,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"diffexpr",    "dex",  P_STRING|P_VI_DEF|P_SECURE,
  #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
  			    (char_u *)&p_dex, PV_NONE,
--- 903,930 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"delcombine", "deco",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_deco, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_dict, PV_DICT,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"diff",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN|P_NOGLOB,
  #ifdef FEAT_DIFF
  			    (char_u *)VAR_WIN, PV_DIFF,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"diffexpr",    "dex",  P_STRING|P_VI_DEF|P_SECURE,
  #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
  			    (char_u *)&p_dex, PV_NONE,
***************
*** 929,935 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"diffopt",	    "dip",  P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN|P_COMMA|P_NODUP,
  #ifdef FEAT_DIFF
  			    (char_u *)&p_dip, PV_NONE,
--- 933,939 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"diffopt",	    "dip",  P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN|P_COMMA|P_NODUP,
  #ifdef FEAT_DIFF
  			    (char_u *)&p_dip, PV_NONE,
***************
*** 938,957 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)NULL}
  #endif
! 			    },
      {"digraph",	    "dg",   P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_DIGRAPHS
  			    (char_u *)&p_dg, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"directory",   "dir",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
  			    (char_u *)&p_dir, PV_NONE,
! 			    {(char_u *)DFLT_DIR, (char_u *)0L}},
      {"display",	    "dy",   P_STRING|P_VI_DEF|P_COMMA|P_RALL|P_NODUP,
  			    (char_u *)&p_dy, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"eadirection", "ead",  P_STRING|P_VI_DEF,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)&p_ead, PV_NONE,
--- 942,961 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)NULL}
  #endif
! 			    SCRIPTID_INIT},
      {"digraph",	    "dg",   P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_DIGRAPHS
  			    (char_u *)&p_dg, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"directory",   "dir",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
  			    (char_u *)&p_dir, PV_NONE,
! 			    {(char_u *)DFLT_DIR, (char_u *)0L} SCRIPTID_INIT},
      {"display",	    "dy",   P_STRING|P_VI_DEF|P_COMMA|P_RALL|P_NODUP,
  			    (char_u *)&p_dy, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"eadirection", "ead",  P_STRING|P_VI_DEF,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)&p_ead, PV_NONE,
***************
*** 960,969 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"edcompatible","ed",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ed, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"encoding",    "enc",  P_STRING|P_VI_DEF|P_RCLR,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_enc, PV_NONE,
--- 964,973 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"edcompatible","ed",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ed, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"encoding",    "enc",  P_STRING|P_VI_DEF|P_RCLR,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_enc, PV_NONE,
***************
*** 972,990 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"endofline",   "eol",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_eol, PV_EOL,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"equalalways", "ea",   P_BOOL|P_VI_DEF|P_RALL,
  			    (char_u *)&p_ea, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"equalprg",    "ep",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_ep, PV_EP,
! 			    {(char_u *)"", (char_u *)0L}},
      {"errorbells",  "eb",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_eb, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"errorfile",   "ef",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_ef, PV_NONE,
--- 976,994 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"endofline",   "eol",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_eol, PV_EOL,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"equalalways", "ea",   P_BOOL|P_VI_DEF|P_RALL,
  			    (char_u *)&p_ea, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"equalprg",    "ep",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_ep, PV_EP,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"errorbells",  "eb",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_eb, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"errorfile",   "ef",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_ef, PV_NONE,
***************
*** 993,1024 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"errorformat", "efm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_efm, PV_EFM,
! 			    {(char_u *)DFLT_EFM, (char_u *)0L},
  #else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"esckeys",	    "ek",   P_BOOL|P_VIM,
  			    (char_u *)&p_ek, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE}},
      {"eventignore", "ei",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_AUTOCMD
  			    (char_u *)&p_ei, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"expandtab",   "et",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_et, PV_ET,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"exrc",	    "ex",   P_BOOL|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_exrc, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"fileencoding","fenc", P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_RBUF|P_NO_MKRC,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_fenc, PV_FENC,
--- 997,1028 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"errorformat", "efm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_efm, PV_EFM,
! 			    {(char_u *)DFLT_EFM, (char_u *)0L}
  #else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"esckeys",	    "ek",   P_BOOL|P_VIM,
  			    (char_u *)&p_ek, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
      {"eventignore", "ei",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_AUTOCMD
  			    (char_u *)&p_ei, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"expandtab",   "et",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_et, PV_ET,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"exrc",	    "ex",   P_BOOL|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_exrc, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"fileencoding","fenc", P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_RBUF|P_NO_MKRC,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_fenc, PV_FENC,
***************
*** 1027,1033 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"fileencodings","fencs", P_STRING|P_VI_DEF|P_COMMA,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_fencs, PV_NONE,
--- 1031,1037 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"fileencodings","fencs", P_STRING|P_VI_DEF|P_COMMA,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_fencs, PV_NONE,
***************
*** 1036,1048 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"fileformat",  "ff",   P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_NO_MKRC,
  			    (char_u *)&p_ff, PV_FF,
! 			    {(char_u *)DFLT_FF, (char_u *)0L}},
      {"fileformats", "ffs",  P_STRING|P_VIM|P_COMMA|P_NODUP,
  			    (char_u *)&p_ffs, PV_NONE,
! 			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}},
      {"filetype",    "ft",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
  #ifdef FEAT_AUTOCMD
  			    (char_u *)&p_ft, PV_FT,
--- 1040,1053 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"fileformat",  "ff",   P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_NO_MKRC,
  			    (char_u *)&p_ff, PV_FF,
! 			    {(char_u *)DFLT_FF, (char_u *)0L} SCRIPTID_INIT},
      {"fileformats", "ffs",  P_STRING|P_VIM|P_COMMA|P_NODUP,
  			    (char_u *)&p_ffs, PV_NONE,
! 			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}
! 			    SCRIPTID_INIT},
      {"filetype",    "ft",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
  #ifdef FEAT_AUTOCMD
  			    (char_u *)&p_ft, PV_FT,
***************
*** 1051,1057 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"fillchars",   "fcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
  #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
  			    (char_u *)&p_fcs, PV_NONE,
--- 1056,1062 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"fillchars",   "fcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
  #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
  			    (char_u *)&p_fcs, PV_NONE,
***************
*** 1060,1086 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #endif
! 			    },
      {"fkmap",	    "fk",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_FKMAP
  			    (char_u *)&p_fkmap, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"flash",	    "fl",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
  #ifdef FEAT_FOLDING
      {"foldclose",   "fcl",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP|P_RWIN,
  			    (char_u *)&p_fcl, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"foldcolumn",  "fdc",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDC,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"foldenable",  "fen",  P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FEN,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"foldexpr",    "fde",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  # ifdef FEAT_EVAL
  			    (char_u *)VAR_WIN, PV_FDE,
--- 1065,1091 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"fkmap",	    "fk",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_FKMAP
  			    (char_u *)&p_fkmap, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"flash",	    "fl",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
  #ifdef FEAT_FOLDING
      {"foldclose",   "fcl",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP|P_RWIN,
  			    (char_u *)&p_fcl, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"foldcolumn",  "fdc",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDC,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"foldenable",  "fen",  P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FEN,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"foldexpr",    "fde",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  # ifdef FEAT_EVAL
  			    (char_u *)VAR_WIN, PV_FDE,
***************
*** 1089,1121 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  # endif
! 			    },
      {"foldignore",  "fdi",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDI,
! 			    {(char_u *)"#", (char_u *)NULL}},
      {"foldlevel",   "fdl",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDL,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"foldlevelstart","fdls", P_NUM|P_VI_DEF,
  			    (char_u *)&p_fdls, PV_NONE,
! 			    {(char_u *)-1L, (char_u *)0L}},
      {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
  						       P_RWIN|P_COMMA|P_NODUP,
  			    (char_u *)VAR_WIN, PV_FMR,
! 			    {(char_u *)"{{{,}}}", (char_u *)NULL}},
      {"foldmethod",  "fdm",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDM,
! 			    {(char_u *)"manual", (char_u *)NULL}},
      {"foldminlines","fml",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FML,
! 			    {(char_u *)1L, (char_u *)0L}},
      {"foldnestmax", "fdn",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDN,
! 			    {(char_u *)20L, (char_u *)0L}},
      {"foldopen",    "fdo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_fdo, PV_NONE,
  		 {(char_u *)"block,hor,mark,percent,quickfix,search,tag,undo",
! 							       (char_u *)0L}},
      {"foldtext",    "fdt",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  # ifdef FEAT_EVAL
  			    (char_u *)VAR_WIN, PV_FDT,
--- 1094,1127 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  # endif
! 			    SCRIPTID_INIT},
      {"foldignore",  "fdi",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDI,
! 			    {(char_u *)"#", (char_u *)NULL} SCRIPTID_INIT},
      {"foldlevel",   "fdl",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDL,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"foldlevelstart","fdls", P_NUM|P_VI_DEF,
  			    (char_u *)&p_fdls, PV_NONE,
! 			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
      {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
  						       P_RWIN|P_COMMA|P_NODUP,
  			    (char_u *)VAR_WIN, PV_FMR,
! 			    {(char_u *)"{{{,}}}", (char_u *)NULL}
! 			    SCRIPTID_INIT},
      {"foldmethod",  "fdm",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDM,
! 			    {(char_u *)"manual", (char_u *)NULL} SCRIPTID_INIT},
      {"foldminlines","fml",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FML,
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"foldnestmax", "fdn",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDN,
! 			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
      {"foldopen",    "fdo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_fdo, PV_NONE,
  		 {(char_u *)"block,hor,mark,percent,quickfix,search,tag,undo",
! 						 (char_u *)0L} SCRIPTID_INIT},
      {"foldtext",    "fdt",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  # ifdef FEAT_EVAL
  			    (char_u *)VAR_WIN, PV_FDT,
***************
*** 1124,1130 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  # endif
! 			    },
  #endif
      {"formatexpr", "fex",   P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  #ifdef FEAT_EVAL
--- 1130,1136 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  # endif
! 			    SCRIPTID_INIT},
  #endif
      {"formatexpr", "fex",   P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  #ifdef FEAT_EVAL
***************
*** 1134,1149 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"formatoptions","fo",  P_STRING|P_ALLOCED|P_VIM|P_FLAGLIST,
  			    (char_u *)&p_fo, PV_FO,
! 			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}},
      {"formatlistpat","flp", P_STRING|P_ALLOCED|P_VI_DEF,
  			    (char_u *)&p_flp, PV_FLP,
! 			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*", (char_u *)0L}},
      {"formatprg",   "fp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_fp, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"fsync",       "fs",   P_BOOL|P_SECURE|P_VI_DEF,
  #ifdef HAVE_FSYNC
  			    (char_u *)&p_fs, PV_NONE,
--- 1140,1157 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"formatoptions","fo",  P_STRING|P_ALLOCED|P_VIM|P_FLAGLIST,
  			    (char_u *)&p_fo, PV_FO,
! 			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}
! 			    SCRIPTID_INIT},
      {"formatlistpat","flp", P_STRING|P_ALLOCED|P_VI_DEF,
  			    (char_u *)&p_flp, PV_FLP,
! 			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*",
! 						 (char_u *)0L} SCRIPTID_INIT},
      {"formatprg",   "fp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_fp, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"fsync",       "fs",   P_BOOL|P_SECURE|P_VI_DEF,
  #ifdef HAVE_FSYNC
  			    (char_u *)&p_fs, PV_NONE,
***************
*** 1152,1173 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}
  #endif
! 			    },
      {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_gd, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"graphic",	    "gr",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"grepformat",  "gfm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_gefm, PV_NONE,
! 			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L},
  #else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"grepprg",	    "gp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_gp, PV_GP,
--- 1160,1181 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_gd, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"graphic",	    "gr",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"grepformat",  "gfm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_gefm, PV_NONE,
! 			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L}
  #else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"grepprg",	    "gp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_gp, PV_GP,
***************
*** 1185,1199 ****
  			    (char_u *)"SEARCH/NUMBERS ",
  #   else
  			    (char_u *)"grep -n ",
! #endif
! #endif
  # endif
! 			    (char_u *)0L},
  #else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"guicursor",    "gcr",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef CURSOR_SHAPE
  			    (char_u *)&p_guicursor, PV_NONE,
--- 1193,1207 ----
  			    (char_u *)"SEARCH/NUMBERS ",
  #   else
  			    (char_u *)"grep -n ",
! #   endif
! #  endif
  # endif
! 			    (char_u *)0L}
  #else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"guicursor",    "gcr",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef CURSOR_SHAPE
  			    (char_u *)&p_guicursor, PV_NONE,
***************
*** 1208,1214 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 				    },
      {"guifont",	    "gfn",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
  #ifdef FEAT_GUI
  			    (char_u *)&p_guifont, PV_NONE,
--- 1216,1222 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"guifont",	    "gfn",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
  #ifdef FEAT_GUI
  			    (char_u *)&p_guifont, PV_NONE,
***************
*** 1217,1223 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 				    },
      {"guifontset",  "gfs",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA,
  #if defined(FEAT_GUI) && defined(FEAT_XFONTSET)
  			    (char_u *)&p_guifontset, PV_NONE,
--- 1225,1231 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"guifontset",  "gfs",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA,
  #if defined(FEAT_GUI) && defined(FEAT_XFONTSET)
  			    (char_u *)&p_guifontset, PV_NONE,
***************
*** 1226,1232 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 				    },
      {"guifontwide", "gfw",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
  #if defined(FEAT_GUI) && defined(FEAT_MBYTE)
  			    (char_u *)&p_guifontwide, PV_NONE,
--- 1234,1240 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"guifontwide", "gfw",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
  #if defined(FEAT_GUI) && defined(FEAT_MBYTE)
  			    (char_u *)&p_guifontwide, PV_NONE,
***************
*** 1235,1248 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 				    },
      {"guiheadroom", "ghr",  P_NUM|P_VI_DEF,
  #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
  			    (char_u *)&p_ghr, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)50L, (char_u *)0L}},
      {"guioptions",  "go",   P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
  #if defined(FEAT_GUI)
  			    (char_u *)&p_go, PV_NONE,
--- 1243,1256 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"guiheadroom", "ghr",  P_NUM|P_VI_DEF,
  #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
  			    (char_u *)&p_ghr, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)50L, (char_u *)0L} SCRIPTID_INIT},
      {"guioptions",  "go",   P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
  #if defined(FEAT_GUI)
  			    (char_u *)&p_go, PV_NONE,
***************
*** 1255,1268 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 				    },
      {"guipty",	    NULL,   P_BOOL|P_VI_DEF,
  #if defined(FEAT_GUI)
  			    (char_u *)&p_guipty, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"guitablabel",  "gtl", P_STRING|P_VI_DEF|P_RWIN,
  #if defined(FEAT_GUI_TABLINE)
  			    (char_u *)&p_gtl, PV_NONE,
--- 1263,1276 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"guipty",	    NULL,   P_BOOL|P_VI_DEF,
  #if defined(FEAT_GUI)
  			    (char_u *)&p_guipty, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"guitablabel",  "gtl", P_STRING|P_VI_DEF|P_RWIN,
  #if defined(FEAT_GUI_TABLINE)
  			    (char_u *)&p_gtl, PV_NONE,
***************
*** 1271,1277 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 				    },
      {"guitabtooltip",  "gtt", P_STRING|P_VI_DEF|P_RWIN,
  #if defined(FEAT_GUI_TABLINE)
  			    (char_u *)&p_gtt, PV_NONE,
--- 1279,1285 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"guitabtooltip",  "gtt", P_STRING|P_VI_DEF|P_RWIN,
  #if defined(FEAT_GUI_TABLINE)
  			    (char_u *)&p_gtt, PV_NONE,
***************
*** 1280,1299 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 				    },
      {"hardtabs",    "ht",   P_NUM|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"helpfile",    "hf",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_hf, PV_NONE,
! 			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}},
      {"helpheight",  "hh",   P_NUM|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_hh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)20L, (char_u *)0L}},
      {"helplang",    "hlg",  P_STRING|P_VI_DEF|P_COMMA,
  #ifdef FEAT_MULTI_LANG
  			    (char_u *)&p_hlg, PV_NONE,
--- 1288,1308 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"hardtabs",    "ht",   P_NUM|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"helpfile",    "hf",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_hf, PV_NONE,
! 			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"helpheight",  "hh",   P_NUM|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_hh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
      {"helplang",    "hlg",  P_STRING|P_VI_DEF|P_COMMA,
  #ifdef FEAT_MULTI_LANG
  			    (char_u *)&p_hlg, PV_NONE,
***************
*** 1302,1365 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
!     },
      {"hidden",	    "hid",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_hid, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"highlight",   "hl",   P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
  			    (char_u *)&p_hl, PV_NONE,
! 			    {(char_u *)HIGHLIGHT_INIT, (char_u *)0L}},
      {"history",	    "hi",   P_NUM|P_VIM,
  			    (char_u *)&p_hi, PV_NONE,
! 			    {(char_u *)0L, (char_u *)20L}},
      {"hkmap",	    "hk",   P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)&p_hkmap, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"hkmapp",	    "hkp",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)&p_hkmapp, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"hlsearch",    "hls",  P_BOOL|P_VI_DEF|P_VIM|P_RALL,
  			    (char_u *)&p_hls, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"icon",	    NULL,   P_BOOL|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_icon, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"iconstring",  NULL,   P_STRING|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_iconstring, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"ignorecase",  "ic",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ic, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"imactivatekey","imak",P_STRING|P_VI_DEF,
  #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
  			    (char_u *)&p_imak, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"imcmdline",   "imc",  P_BOOL|P_VI_DEF,
  #ifdef USE_IM_CONTROL
  			    (char_u *)&p_imcmdline, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"imdisable",   "imd",  P_BOOL|P_VI_DEF,
  #ifdef USE_IM_CONTROL
  			    (char_u *)&p_imdisable, PV_NONE,
--- 1311,1375 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"hidden",	    "hid",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_hid, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"highlight",   "hl",   P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
  			    (char_u *)&p_hl, PV_NONE,
! 			    {(char_u *)HIGHLIGHT_INIT, (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"history",	    "hi",   P_NUM|P_VIM,
  			    (char_u *)&p_hi, PV_NONE,
! 			    {(char_u *)0L, (char_u *)20L} SCRIPTID_INIT},
      {"hkmap",	    "hk",   P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)&p_hkmap, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"hkmapp",	    "hkp",  P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)&p_hkmapp, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"hlsearch",    "hls",  P_BOOL|P_VI_DEF|P_VIM|P_RALL,
  			    (char_u *)&p_hls, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"icon",	    NULL,   P_BOOL|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_icon, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"iconstring",  NULL,   P_STRING|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_iconstring, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"ignorecase",  "ic",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ic, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"imactivatekey","imak",P_STRING|P_VI_DEF,
  #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
  			    (char_u *)&p_imak, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"imcmdline",   "imc",  P_BOOL|P_VI_DEF,
  #ifdef USE_IM_CONTROL
  			    (char_u *)&p_imcmdline, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"imdisable",   "imd",  P_BOOL|P_VI_DEF,
  #ifdef USE_IM_CONTROL
  			    (char_u *)&p_imdisable, PV_NONE,
***************
*** 1371,1377 ****
  #else
  			    {(char_u *)FALSE, (char_u *)0L}
  #endif
! 			    },
      {"iminsert",    "imi",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_iminsert, PV_IMI,
  #ifdef B_IMODE_IM
--- 1381,1387 ----
  #else
  			    {(char_u *)FALSE, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"iminsert",    "imi",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_iminsert, PV_IMI,
  #ifdef B_IMODE_IM
***************
*** 1379,1385 ****
  #else
  			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
  #endif
! 			    },
      {"imsearch",    "ims",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_imsearch, PV_IMS,
  #ifdef B_IMODE_IM
--- 1389,1395 ----
  #else
  			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"imsearch",    "ims",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_imsearch, PV_IMS,
  #ifdef B_IMODE_IM
***************
*** 1387,1393 ****
  #else
  			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
  #endif
! 			    },
      {"include",	    "inc",  P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_FIND_ID
  			    (char_u *)&p_inc, PV_INC,
--- 1397,1403 ----
  #else
  			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"include",	    "inc",  P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_FIND_ID
  			    (char_u *)&p_inc, PV_INC,
***************
*** 1396,1402 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"includeexpr", "inex", P_STRING|P_ALLOCED|P_VI_DEF,
  #if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
  			    (char_u *)&p_inex, PV_INEX,
--- 1406,1412 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"includeexpr", "inex", P_STRING|P_ALLOCED|P_VI_DEF,
  #if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
  			    (char_u *)&p_inex, PV_INEX,
***************
*** 1405,1414 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"incsearch",   "is",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_is, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"indentexpr", "inde",  P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
  			    (char_u *)&p_inde, PV_INDE,
--- 1415,1424 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"incsearch",   "is",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_is, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"indentexpr", "inde",  P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
  			    (char_u *)&p_inde, PV_INDE,
***************
*** 1417,1423 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"indentkeys", "indk",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
  			    (char_u *)&p_indk, PV_INDK,
--- 1427,1433 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"indentkeys", "indk",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
  			    (char_u *)&p_indk, PV_INDK,
***************
*** 1426,1438 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"infercase",   "inf",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_inf, PV_INF,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"insertmode",  "im",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_im, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"isfname",	    "isf",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_isf, PV_NONE,
  			    {
--- 1436,1448 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"infercase",   "inf",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_inf, PV_INF,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"insertmode",  "im",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_im, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"isfname",	    "isf",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_isf, PV_NONE,
  			    {
***************
*** 1455,1461 ****
  #  endif
  # endif
  #endif
! 				(char_u *)0L}},
      {"isident",	    "isi",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_isi, PV_NONE,
  			    {
--- 1465,1471 ----
  #  endif
  # endif
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"isident",	    "isi",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_isi, PV_NONE,
  			    {
***************
*** 1472,1478 ****
  			    (char_u *)"@,48-57,_,192-255",
  # endif
  #endif
! 				(char_u *)0L}},
      {"iskeyword",   "isk",  P_STRING|P_ALLOCED|P_VIM|P_COMMA|P_NODUP,
  			    (char_u *)&p_isk, PV_ISK,
  			    {
--- 1482,1488 ----
  			    (char_u *)"@,48-57,_,192-255",
  # endif
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"iskeyword",   "isk",  P_STRING|P_ALLOCED|P_VIM|P_COMMA|P_NODUP,
  			    (char_u *)&p_isk, PV_ISK,
  			    {
***************
*** 1491,1497 ****
  				ISK_LATIN1
  # endif
  #endif
! 				}},
      {"isprint",	    "isp",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
  			    (char_u *)&p_isp, PV_NONE,
  			    {
--- 1501,1507 ----
  				ISK_LATIN1
  # endif
  #endif
! 			    } SCRIPTID_INIT},
      {"isprint",	    "isp",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
  			    (char_u *)&p_isp, PV_NONE,
  			    {
***************
*** 1507,1516 ****
  			    ISP_LATIN1,
  # endif
  #endif
! 				(char_u *)0L}},
      {"joinspaces",  "js",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_js, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"key",	    NULL,   P_STRING|P_ALLOCED|P_VI_DEF|P_NO_MKRC,
  #ifdef FEAT_CRYPT
  			    (char_u *)&p_key, PV_KEY,
--- 1517,1526 ----
  			    ISP_LATIN1,
  # endif
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"joinspaces",  "js",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_js, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"key",	    NULL,   P_STRING|P_ALLOCED|P_VI_DEF|P_NO_MKRC,
  #ifdef FEAT_CRYPT
  			    (char_u *)&p_key, PV_KEY,
***************
*** 1519,1525 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME|P_PRI_MKRC,
  #ifdef FEAT_KEYMAP
  			    (char_u *)&p_keymap, PV_KMAP,
--- 1529,1535 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME|P_PRI_MKRC,
  #ifdef FEAT_KEYMAP
  			    (char_u *)&p_keymap, PV_KMAP,
***************
*** 1528,1541 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #endif
! 	},
      {"keymodel",    "km",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_VISUAL
  			    (char_u *)&p_km, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_kp, PV_KP,
  			    {
--- 1538,1551 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"keymodel",    "km",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_VISUAL
  			    (char_u *)&p_km, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_kp, PV_KP,
  			    {
***************
*** 1556,1562 ****
  # endif
  #endif
  #endif
! 				(char_u *)0L}},
      {"langmap",     "lmap", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_LANGMAP
  			    (char_u *)&p_langmap, PV_NONE,
--- 1566,1572 ----
  # endif
  #endif
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"langmap",     "lmap", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_LANGMAP
  			    (char_u *)&p_langmap, PV_NONE,
***************
*** 1565,1595 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL,
  #endif
! 				(char_u *)0L}},
      {"langmenu",    "lm",   P_STRING|P_VI_DEF|P_NFNAME,
  #if defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)
  			    (char_u *)&p_lm, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"laststatus",  "ls",   P_NUM|P_VI_DEF|P_RALL,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_ls, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L}},
      {"lazyredraw",  "lz",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_lz, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"linebreak",   "lbr",  P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_LINEBREAK
  			    (char_u *)VAR_WIN, PV_LBR,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"lines",	    NULL,   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
  			    (char_u *)&Rows, PV_NONE,
  			    {
--- 1575,1605 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL,
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"langmenu",    "lm",   P_STRING|P_VI_DEF|P_NFNAME,
  #if defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)
  			    (char_u *)&p_lm, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"laststatus",  "ls",   P_NUM|P_VI_DEF|P_RALL,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_ls, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"lazyredraw",  "lz",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_lz, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"linebreak",   "lbr",  P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_LINEBREAK
  			    (char_u *)VAR_WIN, PV_LBR,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"lines",	    NULL,   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
  			    (char_u *)&Rows, PV_NONE,
  			    {
***************
*** 1598,1604 ****
  #else
  			    (char_u *)24L,
  #endif
! 					    (char_u *)0L}},
      {"linespace",   "lsp",  P_NUM|P_VI_DEF|P_RCLR,
  #ifdef FEAT_GUI
  			    (char_u *)&p_linespace, PV_NONE,
--- 1608,1614 ----
  #else
  			    (char_u *)24L,
  #endif
! 					    (char_u *)0L} SCRIPTID_INIT},
      {"linespace",   "lsp",  P_NUM|P_VI_DEF|P_RCLR,
  #ifdef FEAT_GUI
  			    (char_u *)&p_linespace, PV_NONE,
***************
*** 1610,1623 ****
  #else
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"lisp",	    NULL,   P_BOOL|P_VI_DEF,
  #ifdef FEAT_LISP
  			    (char_u *)&p_lisp, PV_LISP,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"lispwords",   "lw",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_LISP
  			    (char_u *)&p_lispwords, PV_NONE,
--- 1620,1633 ----
  #else
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"lisp",	    NULL,   P_BOOL|P_VI_DEF,
  #ifdef FEAT_LISP
  			    (char_u *)&p_lisp, PV_LISP,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"lispwords",   "lw",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_LISP
  			    (char_u *)&p_lispwords, PV_NONE,
***************
*** 1626,1649 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #endif
! 			    },
      {"list",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_LIST,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"listchars",   "lcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
  			    (char_u *)&p_lcs, PV_NONE,
! 			    {(char_u *)"eol:$", (char_u *)0L}},
      {"loadplugins", "lpl",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_lpl, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
  #ifdef FEAT_GUI_MAC
      {"macatsui",    NULL,   P_BOOL|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_macatsui, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
  #endif
      {"magic",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_magic, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"makeef",	    "mef",  P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_mef, PV_NONE,
--- 1636,1659 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"list",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_LIST,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"listchars",   "lcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
  			    (char_u *)&p_lcs, PV_NONE,
! 			    {(char_u *)"eol:$", (char_u *)0L} SCRIPTID_INIT},
      {"loadplugins", "lpl",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_lpl, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
  #ifdef FEAT_GUI_MAC
      {"macatsui",    NULL,   P_BOOL|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_macatsui, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
  #endif
      {"magic",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_magic, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"makeef",	    "mef",  P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_mef, PV_NONE,
***************
*** 1652,1658 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"makeprg",	    "mp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_mp, PV_MP,
--- 1662,1668 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"makeprg",	    "mp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_mp, PV_MP,
***************
*** 1665,1713 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"matchpairs",  "mps",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_mps, PV_MPS,
! 			    {(char_u *)"(:),{:},[:]", (char_u *)0L}},
      {"matchtime",   "mat",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_mat, PV_NONE,
! 			    {(char_u *)5L, (char_u *)0L}},
      {"maxcombine",  "mco",  P_NUM|P_VI_DEF,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_mco, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)2, (char_u *)0L}},
      {"maxfuncdepth", "mfd", P_NUM|P_VI_DEF,
  #ifdef FEAT_EVAL
  			    (char_u *)&p_mfd, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)100L, (char_u *)0L}},
      {"maxmapdepth", "mmd",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_mmd, PV_NONE,
! 			    {(char_u *)1000L, (char_u *)0L}},
      {"maxmem",	    "mm",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_mm, PV_NONE,
! 			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}},
      {"maxmempattern","mmp", P_NUM|P_VI_DEF,
  			    (char_u *)&p_mmp, PV_NONE,
! 			    {(char_u *)1000L, (char_u *)0L}},
      {"maxmemtot",   "mmt",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_mmt, PV_NONE,
! 			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}},
      {"menuitems",   "mis",  P_NUM|P_VI_DEF,
  #ifdef FEAT_MENU
  			    (char_u *)&p_mis, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)25L, (char_u *)0L}},
      {"mesg",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"mkspellmem",  "msm",  P_STRING|P_VI_DEF|P_EXPAND|P_SECURE,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_msm, PV_NONE,
--- 1675,1726 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"matchpairs",  "mps",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_mps, PV_MPS,
! 			    {(char_u *)"(:),{:},[:]", (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"matchtime",   "mat",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_mat, PV_NONE,
! 			    {(char_u *)5L, (char_u *)0L} SCRIPTID_INIT},
      {"maxcombine",  "mco",  P_NUM|P_VI_DEF,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_mco, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)2, (char_u *)0L} SCRIPTID_INIT},
      {"maxfuncdepth", "mfd", P_NUM|P_VI_DEF,
  #ifdef FEAT_EVAL
  			    (char_u *)&p_mfd, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)100L, (char_u *)0L} SCRIPTID_INIT},
      {"maxmapdepth", "mmd",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_mmd, PV_NONE,
! 			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
      {"maxmem",	    "mm",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_mm, PV_NONE,
! 			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"maxmempattern","mmp", P_NUM|P_VI_DEF,
  			    (char_u *)&p_mmp, PV_NONE,
! 			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
      {"maxmemtot",   "mmt",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_mmt, PV_NONE,
! 			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"menuitems",   "mis",  P_NUM|P_VI_DEF,
  #ifdef FEAT_MENU
  			    (char_u *)&p_mis, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)25L, (char_u *)0L} SCRIPTID_INIT},
      {"mesg",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"mkspellmem",  "msm",  P_STRING|P_VI_DEF|P_EXPAND|P_SECURE,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_msm, PV_NONE,
***************
*** 1716,1737 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
!     },
      {"modeline",    "ml",   P_BOOL|P_VIM,
  			    (char_u *)&p_ml, PV_ML,
! 			    {(char_u *)FALSE, (char_u *)TRUE}},
      {"modelines",   "mls",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_mls, PV_NONE,
! 			    {(char_u *)5L, (char_u *)0L}},
      {"modifiable",  "ma",   P_BOOL|P_VI_DEF|P_NOGLOB,
  			    (char_u *)&p_ma, PV_MA,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"modified",    "mod",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_mod, PV_MOD,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"more",	    NULL,   P_BOOL|P_VIM,
  			    (char_u *)&p_more, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE}},
      {"mouse",	    NULL,   P_STRING|P_VI_DEF|P_FLAGLIST,
  			    (char_u *)&p_mouse, PV_NONE,
  			    {
--- 1729,1750 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"modeline",    "ml",   P_BOOL|P_VIM,
  			    (char_u *)&p_ml, PV_ML,
! 			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
      {"modelines",   "mls",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_mls, PV_NONE,
! 			    {(char_u *)5L, (char_u *)0L} SCRIPTID_INIT},
      {"modifiable",  "ma",   P_BOOL|P_VI_DEF|P_NOGLOB,
  			    (char_u *)&p_ma, PV_MA,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"modified",    "mod",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_mod, PV_MOD,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"more",	    NULL,   P_BOOL|P_VIM,
  			    (char_u *)&p_more, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
      {"mouse",	    NULL,   P_STRING|P_VI_DEF|P_FLAGLIST,
  			    (char_u *)&p_mouse, PV_NONE,
  			    {
***************
*** 1740,1760 ****
  #else
  				(char_u *)"",
  #endif
! 				(char_u *)0L}},
      {"mousefocus",   "mousef", P_BOOL|P_VI_DEF,
  #ifdef FEAT_GUI
  			    (char_u *)&p_mousef, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"mousehide",   "mh",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_GUI
  			    (char_u *)&p_mh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"mousemodel",  "mousem", P_STRING|P_VI_DEF,
  			    (char_u *)&p_mousem, PV_NONE,
  			    {
--- 1753,1773 ----
  #else
  				(char_u *)"",
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"mousefocus",   "mousef", P_BOOL|P_VI_DEF,
  #ifdef FEAT_GUI
  			    (char_u *)&p_mousef, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"mousehide",   "mh",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_GUI
  			    (char_u *)&p_mh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"mousemodel",  "mousem", P_STRING|P_VI_DEF,
  			    (char_u *)&p_mousem, PV_NONE,
  			    {
***************
*** 1767,1773 ****
  				(char_u *)"extend",
  # endif
  #endif
! 				(char_u *)0L}},
      {"mouseshape",  "mouses",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_MOUSESHAPE
  			    (char_u *)&p_mouseshape, PV_NONE,
--- 1780,1786 ----
  				(char_u *)"extend",
  # endif
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"mouseshape",  "mouses",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_MOUSESHAPE
  			    (char_u *)&p_mouseshape, PV_NONE,
***************
*** 1776,1808 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"mousetime",   "mouset",	P_NUM|P_VI_DEF,
  			    (char_u *)&p_mouset, PV_NONE,
! 			    {(char_u *)500L, (char_u *)0L}},
      {"mzquantum",  "mzq",   P_NUM,
  #ifdef FEAT_MZSCHEME
  			    (char_u *)&p_mzq, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)100L, (char_u *)100L}},
      {"novice",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"nrformats",   "nf",   P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_nf, PV_NF,
! 			    {(char_u *)"octal,hex", (char_u *)0L}},
      {"number",	    "nu",   P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_NU,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"numberwidth", "nuw",  P_NUM|P_RWIN|P_VIM,
  #ifdef FEAT_LINEBREAK
  			    (char_u *)VAR_WIN, PV_NUW,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)8L, (char_u *)4L}},
      {"omnifunc",    "ofu",  P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
  #ifdef FEAT_COMPL_FUNC
  			    (char_u *)&p_ofu, PV_OFU,
--- 1789,1822 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"mousetime",   "mouset",	P_NUM|P_VI_DEF,
  			    (char_u *)&p_mouset, PV_NONE,
! 			    {(char_u *)500L, (char_u *)0L} SCRIPTID_INIT},
      {"mzquantum",  "mzq",   P_NUM,
  #ifdef FEAT_MZSCHEME
  			    (char_u *)&p_mzq, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)100L, (char_u *)100L} SCRIPTID_INIT},
      {"novice",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"nrformats",   "nf",   P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_nf, PV_NF,
! 			    {(char_u *)"octal,hex", (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"number",	    "nu",   P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_NU,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"numberwidth", "nuw",  P_NUM|P_RWIN|P_VIM,
  #ifdef FEAT_LINEBREAK
  			    (char_u *)VAR_WIN, PV_NUW,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)8L, (char_u *)4L} SCRIPTID_INIT},
      {"omnifunc",    "ofu",  P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
  #ifdef FEAT_COMPL_FUNC
  			    (char_u *)&p_ofu, PV_OFU,
***************
*** 1811,1820 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"open",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"opendevice",  "odev", P_BOOL|P_VI_DEF,
  #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
  			    (char_u *)&p_odev, PV_NONE,
--- 1825,1834 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"open",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"opendevice",  "odev", P_BOOL|P_VI_DEF,
  #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
  			    (char_u *)&p_odev, PV_NONE,
***************
*** 1822,1834 ****
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)FALSE, (char_u *)FALSE}
! 			    },
      {"operatorfunc", "opfunc", P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_opfunc, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} },
      {"optimize",    "opt",  P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"osfiletype",  "oft",  P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_OSFILETYPE
  			    (char_u *)&p_oft, PV_OFT,
--- 1836,1848 ----
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)FALSE, (char_u *)FALSE}
! 			    SCRIPTID_INIT},
      {"operatorfunc", "opfunc", P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_opfunc, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"optimize",    "opt",  P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"osfiletype",  "oft",  P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_OSFILETYPE
  			    (char_u *)&p_oft, PV_OFT,
***************
*** 1837,1853 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"paragraphs",  "para", P_STRING|P_VI_DEF,
  			    (char_u *)&p_para, PV_NONE,
  			    {(char_u *)"IPLPPPQPP TPHPLIPpLpItpplpipbp",
! 				(char_u *)0L}},
      {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
  			    (char_u *)&p_paste, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
  			    (char_u *)&p_pt, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"patchexpr",   "pex",  P_STRING|P_VI_DEF|P_SECURE,
  #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
  			    (char_u *)&p_pex, PV_NONE,
--- 1851,1867 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"paragraphs",  "para", P_STRING|P_VI_DEF,
  			    (char_u *)&p_para, PV_NONE,
  			    {(char_u *)"IPLPPPQPP TPHPLIPpLpItpplpipbp",
! 				(char_u *)0L} SCRIPTID_INIT},
      {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
  			    (char_u *)&p_paste, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
  			    (char_u *)&p_pt, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"patchexpr",   "pex",  P_STRING|P_VI_DEF|P_SECURE,
  #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
  			    (char_u *)&p_pex, PV_NONE,
***************
*** 1856,1865 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"patchmode",   "pm",   P_STRING|P_VI_DEF|P_NFNAME,
  			    (char_u *)&p_pm, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_path, PV_PATH,
  			    {
--- 1870,1879 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"patchmode",   "pm",   P_STRING|P_VI_DEF|P_NFNAME,
  			    (char_u *)&p_pm, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_path, PV_PATH,
  			    {
***************
*** 1872,1895 ****
  			    (char_u *)".,/usr/include,,",
  # endif
  #endif
! 				(char_u *)0L}},
      {"preserveindent", "pi", P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_pi, PV_PI,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"previewheight", "pvh", P_NUM|P_VI_DEF,
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  			    (char_u *)&p_pvh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)12L, (char_u *)0L}},
      {"previewwindow", "pvw", P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  			    (char_u *)VAR_WIN, PV_PVW,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"printdevice", "pdev", P_STRING|P_VI_DEF|P_SECURE,
  #ifdef FEAT_PRINTER
  			    (char_u *)&p_pdev, PV_NONE,
--- 1886,1909 ----
  			    (char_u *)".,/usr/include,,",
  # endif
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"preserveindent", "pi", P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_pi, PV_PI,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"previewheight", "pvh", P_NUM|P_VI_DEF,
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  			    (char_u *)&p_pvh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
      {"previewwindow", "pvw", P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  			    (char_u *)VAR_WIN, PV_PVW,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"printdevice", "pdev", P_STRING|P_VI_DEF|P_SECURE,
  #ifdef FEAT_PRINTER
  			    (char_u *)&p_pdev, PV_NONE,
***************
*** 1898,1904 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"printencoding", "penc", P_STRING|P_VI_DEF,
  #ifdef FEAT_POSTSCRIPT
  			    (char_u *)&p_penc, PV_NONE,
--- 1912,1918 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"printencoding", "penc", P_STRING|P_VI_DEF,
  #ifdef FEAT_POSTSCRIPT
  			    (char_u *)&p_penc, PV_NONE,
***************
*** 1907,1913 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"printexpr", "pexpr",  P_STRING|P_VI_DEF,
  #ifdef FEAT_POSTSCRIPT
  			    (char_u *)&p_pexpr, PV_NONE,
--- 1921,1927 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"printexpr", "pexpr",  P_STRING|P_VI_DEF,
  #ifdef FEAT_POSTSCRIPT
  			    (char_u *)&p_pexpr, PV_NONE,
***************
*** 1916,1922 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"printfont", "pfn",    P_STRING|P_VI_DEF,
  #ifdef FEAT_PRINTER
  			    (char_u *)&p_pfn, PV_NONE,
--- 1930,1936 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"printfont", "pfn",    P_STRING|P_VI_DEF,
  #ifdef FEAT_PRINTER
  			    (char_u *)&p_pfn, PV_NONE,
***************
*** 1931,1937 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"printheader", "pheader",  P_STRING|P_VI_DEF|P_GETTEXT,
  #ifdef FEAT_PRINTER
  			    (char_u *)&p_header, PV_NONE,
--- 1945,1951 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"printheader", "pheader",  P_STRING|P_VI_DEF|P_GETTEXT,
  #ifdef FEAT_PRINTER
  			    (char_u *)&p_header, PV_NONE,
***************
*** 1940,1946 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
     {"printmbcharset", "pmbcs",  P_STRING|P_VI_DEF,
  #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
  			    (char_u *)&p_pmcs, PV_NONE,
--- 1954,1960 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
     {"printmbcharset", "pmbcs",  P_STRING|P_VI_DEF,
  #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
  			    (char_u *)&p_pmcs, PV_NONE,
***************
*** 1949,1955 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"printmbfont", "pmbfn",  P_STRING|P_VI_DEF,
  #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
  			    (char_u *)&p_pmfn, PV_NONE,
--- 1963,1969 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"printmbfont", "pmbfn",  P_STRING|P_VI_DEF,
  #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
  			    (char_u *)&p_pmfn, PV_NONE,
***************
*** 1958,1964 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"printoptions", "popt", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_PRINTER
  			    (char_u *)&p_popt, PV_NONE,
--- 1972,1978 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"printoptions", "popt", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_PRINTER
  			    (char_u *)&p_popt, PV_NONE,
***************
*** 1967,1983 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"prompt",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_prompt, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"pumheight",   "ph",   P_NUM|P_VI_DEF,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_ph, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L}},
      {"quoteescape", "qe",   P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_TEXTOBJ
  			    (char_u *)&p_qe, PV_QE,
--- 1981,1997 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"prompt",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_prompt, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"pumheight",   "ph",   P_NUM|P_VI_DEF,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_ph, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"quoteescape", "qe",   P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_TEXTOBJ
  			    (char_u *)&p_qe, PV_QE,
***************
*** 1986,2032 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"readonly",    "ro",   P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
  			    (char_u *)&p_ro, PV_RO,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"redraw",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"redrawtime",  "rdt",  P_NUM|P_VI_DEF,
  #ifdef FEAT_RELTIME
  			    (char_u *)&p_rdt, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)2000L, (char_u *)0L}},
      {"remap",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_remap, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"report",	    NULL,   P_NUM|P_VI_DEF,
  			    (char_u *)&p_report, PV_NONE,
! 			    {(char_u *)2L, (char_u *)0L}},
      {"restorescreen", "rs", P_BOOL|P_VI_DEF,
  #ifdef WIN3264
  			    (char_u *)&p_rs, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"revins",	    "ri",   P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)&p_ri, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"rightleft",   "rl",   P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)VAR_WIN, PV_RL,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"rightleftcmd", "rlc", P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)VAR_WIN, PV_RLC,
--- 2000,2046 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"readonly",    "ro",   P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
  			    (char_u *)&p_ro, PV_RO,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"redraw",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"redrawtime",  "rdt",  P_NUM|P_VI_DEF,
  #ifdef FEAT_RELTIME
  			    (char_u *)&p_rdt, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)2000L, (char_u *)0L} SCRIPTID_INIT},
      {"remap",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_remap, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"report",	    NULL,   P_NUM|P_VI_DEF,
  			    (char_u *)&p_report, PV_NONE,
! 			    {(char_u *)2L, (char_u *)0L} SCRIPTID_INIT},
      {"restorescreen", "rs", P_BOOL|P_VI_DEF,
  #ifdef WIN3264
  			    (char_u *)&p_rs, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"revins",	    "ri",   P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)&p_ri, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"rightleft",   "rl",   P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)VAR_WIN, PV_RL,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"rightleftcmd", "rlc", P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN,
  #ifdef FEAT_RIGHTLEFT
  			    (char_u *)VAR_WIN, PV_RLC,
***************
*** 2035,2074 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"ruler",	    "ru",   P_BOOL|P_VI_DEF|P_VIM|P_RSTAT,
  #ifdef FEAT_CMDL_INFO
  			    (char_u *)&p_ru, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"rulerformat", "ruf",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
  #ifdef FEAT_STL_OPT
  			    (char_u *)&p_ruf, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"runtimepath", "rtp",  P_STRING|P_VI_DEF|P_EXPAND|P_COMMA|P_NODUP|P_SECURE,
  			    (char_u *)&p_rtp, PV_NONE,
! 			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}},
      {"scroll",	    "scr",  P_NUM|P_NO_MKRC|P_VI_DEF,
  			    (char_u *)VAR_WIN, PV_SCROLL,
! 			    {(char_u *)12L, (char_u *)0L}},
      {"scrollbind",  "scb",  P_BOOL|P_VI_DEF,
  #ifdef FEAT_SCROLLBIND
  			    (char_u *)VAR_WIN, PV_SCBIND,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"scrolljump",  "sj",   P_NUM|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sj, PV_NONE,
! 			    {(char_u *)1L, (char_u *)0L}},
      {"scrolloff",   "so",   P_NUM|P_VI_DEF|P_VIM|P_RALL,
  			    (char_u *)&p_so, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"scrollopt",   "sbo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SCROLLBIND
  			    (char_u *)&p_sbo, PV_NONE,
--- 2049,2089 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"ruler",	    "ru",   P_BOOL|P_VI_DEF|P_VIM|P_RSTAT,
  #ifdef FEAT_CMDL_INFO
  			    (char_u *)&p_ru, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"rulerformat", "ruf",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
  #ifdef FEAT_STL_OPT
  			    (char_u *)&p_ruf, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"runtimepath", "rtp",  P_STRING|P_VI_DEF|P_EXPAND|P_COMMA|P_NODUP|P_SECURE,
  			    (char_u *)&p_rtp, PV_NONE,
! 			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"scroll",	    "scr",  P_NUM|P_NO_MKRC|P_VI_DEF,
  			    (char_u *)VAR_WIN, PV_SCROLL,
! 			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
      {"scrollbind",  "scb",  P_BOOL|P_VI_DEF,
  #ifdef FEAT_SCROLLBIND
  			    (char_u *)VAR_WIN, PV_SCBIND,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"scrolljump",  "sj",   P_NUM|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sj, PV_NONE,
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"scrolloff",   "so",   P_NUM|P_VI_DEF|P_VIM|P_RALL,
  			    (char_u *)&p_so, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"scrollopt",   "sbo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SCROLLBIND
  			    (char_u *)&p_sbo, PV_NONE,
***************
*** 2077,2103 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"sections",    "sect", P_STRING|P_VI_DEF,
  			    (char_u *)&p_sections, PV_NONE,
! 			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}},
      {"secure",	    NULL,   P_BOOL|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_secure, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"selection",   "sel",  P_STRING|P_VI_DEF,
  #ifdef FEAT_VISUAL
  			    (char_u *)&p_sel, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"inclusive", (char_u *)0L}},
      {"selectmode",  "slm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_VISUAL
  			    (char_u *)&p_slm, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"sessionoptions", "ssop", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SESSION
  			    (char_u *)&p_ssop, PV_NONE,
--- 2092,2120 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"sections",    "sect", P_STRING|P_VI_DEF,
  			    (char_u *)&p_sections, PV_NONE,
! 			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"secure",	    NULL,   P_BOOL|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_secure, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"selection",   "sel",  P_STRING|P_VI_DEF,
  #ifdef FEAT_VISUAL
  			    (char_u *)&p_sel, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"inclusive", (char_u *)0L}
! 			    SCRIPTID_INIT},
      {"selectmode",  "slm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_VISUAL
  			    (char_u *)&p_slm, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"sessionoptions", "ssop", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SESSION
  			    (char_u *)&p_ssop, PV_NONE,
***************
*** 2107,2113 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"shell",	    "sh",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_sh, PV_NONE,
  			    {
--- 2124,2130 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"shell",	    "sh",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_sh, PV_NONE,
  			    {
***************
*** 2136,2142 ****
  #  endif
  # endif
  #endif /* VMS */
! 				(char_u *)0L}},
      {"shellcmdflag","shcf", P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_shcf, PV_NONE,
  			    {
--- 2153,2159 ----
  #  endif
  # endif
  #endif /* VMS */
! 				(char_u *)0L} SCRIPTID_INIT},
      {"shellcmdflag","shcf", P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_shcf, PV_NONE,
  			    {
***************
*** 2149,2155 ****
  			    (char_u *)"-c",
  # endif
  #endif
! 				(char_u *)0L}},
      {"shellpipe",   "sp",   P_STRING|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_sp, PV_NONE,
--- 2166,2172 ----
  			    (char_u *)"-c",
  # endif
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"shellpipe",   "sp",   P_STRING|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_sp, PV_NONE,
***************
*** 2168,2197 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
!     },
      {"shellquote",  "shq",  P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_shq, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"shellredir",  "srr",  P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_srr, PV_NONE,
! 			    {(char_u *)">", (char_u *)0L}},
      {"shellslash",  "ssl",   P_BOOL|P_VI_DEF,
  #ifdef BACKSLASH_IN_FILENAME
  			    (char_u *)&p_ssl, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"shelltemp",   "stmp", P_BOOL,
  			    (char_u *)&p_stmp, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE}},
      {"shelltype",   "st",   P_NUM|P_VI_DEF,
  #ifdef AMIGA
  			    (char_u *)&p_st, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L}},
      {"shellxquote", "sxq",  P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_sxq, PV_NONE,
  			    {
--- 2185,2214 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"shellquote",  "shq",  P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_shq, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"shellredir",  "srr",  P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_srr, PV_NONE,
! 			    {(char_u *)">", (char_u *)0L} SCRIPTID_INIT},
      {"shellslash",  "ssl",   P_BOOL|P_VI_DEF,
  #ifdef BACKSLASH_IN_FILENAME
  			    (char_u *)&p_ssl, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"shelltemp",   "stmp", P_BOOL,
  			    (char_u *)&p_stmp, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
      {"shelltype",   "st",   P_NUM|P_VI_DEF,
  #ifdef AMIGA
  			    (char_u *)&p_st, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"shellxquote", "sxq",  P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_sxq, PV_NONE,
  			    {
***************
*** 2200,2229 ****
  #else
  			    (char_u *)"",
  #endif
! 				(char_u *)0L}},
      {"shiftround",  "sr",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sr, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"shiftwidth",  "sw",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_sw, PV_SW,
! 			    {(char_u *)8L, (char_u *)0L}},
      {"shortmess",   "shm",  P_STRING|P_VIM|P_FLAGLIST,
  			    (char_u *)&p_shm, PV_NONE,
! 			    {(char_u *)"", (char_u *)"filnxtToO"}},
      {"shortname",   "sn",   P_BOOL|P_VI_DEF,
  #ifdef SHORT_FNAME
  			    (char_u *)NULL, PV_NONE,
  #else
  			    (char_u *)&p_sn, PV_SN,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"showbreak",   "sbr",  P_STRING|P_VI_DEF|P_RALL,
  #ifdef FEAT_LINEBREAK
  			    (char_u *)&p_sbr, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"showcmd",	    "sc",   P_BOOL|P_VIM,
  #ifdef FEAT_CMDL_INFO
  			    (char_u *)&p_sc, PV_NONE,
--- 2217,2247 ----
  #else
  			    (char_u *)"",
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"shiftround",  "sr",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sr, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"shiftwidth",  "sw",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_sw, PV_SW,
! 			    {(char_u *)8L, (char_u *)0L} SCRIPTID_INIT},
      {"shortmess",   "shm",  P_STRING|P_VIM|P_FLAGLIST,
  			    (char_u *)&p_shm, PV_NONE,
! 			    {(char_u *)"", (char_u *)"filnxtToO"}
! 			    SCRIPTID_INIT},
      {"shortname",   "sn",   P_BOOL|P_VI_DEF,
  #ifdef SHORT_FNAME
  			    (char_u *)NULL, PV_NONE,
  #else
  			    (char_u *)&p_sn, PV_SN,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"showbreak",   "sbr",  P_STRING|P_VI_DEF|P_RALL,
  #ifdef FEAT_LINEBREAK
  			    (char_u *)&p_sbr, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"showcmd",	    "sc",   P_BOOL|P_VIM,
  #ifdef FEAT_CMDL_INFO
  			    (char_u *)&p_sc, PV_NONE,
***************
*** 2236,2293 ****
  #else
  				(char_u *)TRUE
  #endif
! 				}},
      {"showfulltag", "sft",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_sft, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"showmatch",   "sm",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_sm, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"showmode",    "smd",  P_BOOL|P_VIM,
  			    (char_u *)&p_smd, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE}},
      {"showtabline", "stal", P_NUM|P_VI_DEF|P_RALL,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_stal, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L}},
      {"sidescroll",  "ss",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_ss, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"sidescrolloff", "siso", P_NUM|P_VI_DEF|P_VIM|P_RBUF,
  			    (char_u *)&p_siso, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"slowopen",    "slow", P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"smartcase",   "scs",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_scs, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"smartindent", "si",   P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_SMARTINDENT
  			    (char_u *)&p_si, PV_SI,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"smarttab",    "sta",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sta, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"softtabstop", "sts",  P_NUM|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sts, PV_STS,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"sourceany",   NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"spell",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_SPELL
  			    (char_u *)VAR_WIN, PV_SPELL,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"spellcapcheck", "spc", P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_spc, PV_SPC,
--- 2254,2311 ----
  #else
  				(char_u *)TRUE
  #endif
! 				} SCRIPTID_INIT},
      {"showfulltag", "sft",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_sft, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"showmatch",   "sm",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_sm, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"showmode",    "smd",  P_BOOL|P_VIM,
  			    (char_u *)&p_smd, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
      {"showtabline", "stal", P_NUM|P_VI_DEF|P_RALL,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_stal, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"sidescroll",  "ss",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_ss, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"sidescrolloff", "siso", P_NUM|P_VI_DEF|P_VIM|P_RBUF,
  			    (char_u *)&p_siso, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"slowopen",    "slow", P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"smartcase",   "scs",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_scs, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"smartindent", "si",   P_BOOL|P_VI_DEF|P_VIM,
  #ifdef FEAT_SMARTINDENT
  			    (char_u *)&p_si, PV_SI,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"smarttab",    "sta",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sta, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"softtabstop", "sts",  P_NUM|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sts, PV_STS,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"sourceany",   NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"spell",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_SPELL
  			    (char_u *)VAR_WIN, PV_SPELL,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"spellcapcheck", "spc", P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_spc, PV_SPC,
***************
*** 2296,2302 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"spellfile",   "spf",  P_STRING|P_EXPAND|P_ALLOCED|P_VI_DEF|P_SECURE|P_COMMA,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_spf, PV_SPF,
--- 2314,2320 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"spellfile",   "spf",  P_STRING|P_EXPAND|P_ALLOCED|P_VI_DEF|P_SECURE|P_COMMA,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_spf, PV_SPF,
***************
*** 2305,2311 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"spelllang",   "spl",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_RBUF|P_EXPAND,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_spl, PV_SPL,
--- 2323,2329 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"spelllang",   "spl",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_RBUF|P_EXPAND,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_spl, PV_SPL,
***************
*** 2314,2320 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE|P_COMMA,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_sps, PV_NONE,
--- 2332,2338 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE|P_COMMA,
  #ifdef FEAT_SPELL
  			    (char_u *)&p_sps, PV_NONE,
***************
*** 2323,2357 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
!     },
      {"splitbelow",  "sb",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_sb, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"splitright",  "spr",  P_BOOL|P_VI_DEF,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)&p_spr, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"startofline", "sol",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sol, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"statusline"  ,"stl",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
  #ifdef FEAT_STL_OPT
  			    (char_u *)&p_stl, PV_STL,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"suffixes",    "su",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_su, PV_NONE,
  			    {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
! 				(char_u *)0L}},
      {"suffixesadd", "sua",  P_STRING|P_VI_DEF|P_ALLOCED|P_COMMA|P_NODUP,
  #ifdef FEAT_SEARCHPATH
  			    (char_u *)&p_sua, PV_SUA,
--- 2341,2375 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"splitbelow",  "sb",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_sb, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"splitright",  "spr",  P_BOOL|P_VI_DEF,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)&p_spr, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"startofline", "sol",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sol, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"statusline"  ,"stl",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
  #ifdef FEAT_STL_OPT
  			    (char_u *)&p_stl, PV_STL,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"suffixes",    "su",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_su, PV_NONE,
  			    {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
! 				(char_u *)0L} SCRIPTID_INIT},
      {"suffixesadd", "sua",  P_STRING|P_VI_DEF|P_ALLOCED|P_COMMA|P_NODUP,
  #ifdef FEAT_SEARCHPATH
  			    (char_u *)&p_sua, PV_SUA,
***************
*** 2360,2375 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"swapfile",    "swf",  P_BOOL|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_swf, PV_SWF,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"swapsync",    "sws",  P_STRING|P_VI_DEF,
  			    (char_u *)&p_sws, PV_NONE,
! 			    {(char_u *)"fsync", (char_u *)0L}},
      {"switchbuf",   "swb",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_swb, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"synmaxcol",   "smc",  P_NUM|P_VI_DEF|P_RBUF,
  #ifdef FEAT_SYN_HL
  			    (char_u *)&p_smc, PV_SMC,
--- 2378,2393 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"swapfile",    "swf",  P_BOOL|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_swf, PV_SWF,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"swapsync",    "sws",  P_STRING|P_VI_DEF,
  			    (char_u *)&p_sws, PV_NONE,
! 			    {(char_u *)"fsync", (char_u *)0L} SCRIPTID_INIT},
      {"switchbuf",   "swb",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_swb, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"synmaxcol",   "smc",  P_NUM|P_VI_DEF|P_RBUF,
  #ifdef FEAT_SYN_HL
  			    (char_u *)&p_smc, PV_SMC,
***************
*** 2378,2384 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"syntax",	    "syn",  P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
  #ifdef FEAT_SYN_HL
  			    (char_u *)&p_syn, PV_SYN,
--- 2396,2402 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"syntax",	    "syn",  P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
  #ifdef FEAT_SYN_HL
  			    (char_u *)&p_syn, PV_SYN,
***************
*** 2387,2410 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"tabline",	    "tal",  P_STRING|P_VI_DEF|P_RALL,
  #ifdef FEAT_STL_OPT
  			    (char_u *)&p_tal, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"tabpagemax",  "tpm",  P_NUM|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_tpm, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)10L, (char_u *)0L}},
      {"tabstop",	    "ts",   P_NUM|P_VI_DEF|P_RBUF,
  			    (char_u *)&p_ts, PV_TS,
! 			    {(char_u *)8L, (char_u *)0L}},
      {"tagbsearch",  "tbs",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_tbs, PV_NONE,
  #ifdef VMS	/* binary searching doesn't appear to work on VMS */
--- 2405,2428 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"tabline",	    "tal",  P_STRING|P_VI_DEF|P_RALL,
  #ifdef FEAT_STL_OPT
  			    (char_u *)&p_tal, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"tabpagemax",  "tpm",  P_NUM|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_tpm, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)10L, (char_u *)0L} SCRIPTID_INIT},
      {"tabstop",	    "ts",   P_NUM|P_VI_DEF|P_RBUF,
  			    (char_u *)&p_ts, PV_TS,
! 			    {(char_u *)8L, (char_u *)0L} SCRIPTID_INIT},
      {"tagbsearch",  "tbs",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_tbs, PV_NONE,
  #ifdef VMS	/* binary searching doesn't appear to work on VMS */
***************
*** 2412,2424 ****
  #else
  			    {(char_u *)TRUE, (char_u *)0L}
  #endif
! 			    },
      {"taglength",   "tl",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_tl, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"tagrelative", "tr",   P_BOOL|P_VIM,
  			    (char_u *)&p_tr, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE}},
      {"tags",	    "tag",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_tags, PV_TAGS,
  			    {
--- 2430,2442 ----
  #else
  			    {(char_u *)TRUE, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"taglength",   "tl",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_tl, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"tagrelative", "tr",   P_BOOL|P_VIM,
  			    (char_u *)&p_tr, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
      {"tags",	    "tag",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_tags, PV_TAGS,
  			    {
***************
*** 2427,2446 ****
  #else
  			    (char_u *)"./tags,tags",
  #endif
! 				(char_u *)0L}},
      {"tagstack",    "tgst", P_BOOL|P_VI_DEF,
  			    (char_u *)&p_tgst, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"term",	    NULL,   P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
  			    (char_u *)&T_NAME, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"termbidi", "tbidi",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_ARABIC
  			    (char_u *)&p_tbidi, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"termencoding", "tenc", P_STRING|P_VI_DEF|P_RCLR,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_tenc, PV_NONE,
--- 2445,2464 ----
  #else
  			    (char_u *)"./tags,tags",
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"tagstack",    "tgst", P_BOOL|P_VI_DEF,
  			    (char_u *)&p_tgst, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"term",	    NULL,   P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
  			    (char_u *)&T_NAME, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"termbidi", "tbidi",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_ARABIC
  			    (char_u *)&p_tbidi, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"termencoding", "tenc", P_STRING|P_VI_DEF|P_RCLR,
  #ifdef FEAT_MBYTE
  			    (char_u *)&p_tenc, PV_NONE,
***************
*** 2449,2461 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"terse",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_terse, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"textauto",    "ta",   P_BOOL|P_VIM,
  			    (char_u *)&p_ta, PV_NONE,
! 			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}},
      {"textmode",    "tx",   P_BOOL|P_VI_DEF|P_NO_MKRC,
  			    (char_u *)&p_tx, PV_TX,
  			    {
--- 2467,2480 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"terse",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_terse, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"textauto",    "ta",   P_BOOL|P_VIM,
  			    (char_u *)&p_ta, PV_NONE,
! 			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}
! 			    SCRIPTID_INIT},
      {"textmode",    "tx",   P_BOOL|P_VI_DEF|P_NO_MKRC,
  			    (char_u *)&p_tx, PV_TX,
  			    {
***************
*** 2464,2503 ****
  #else
  			    (char_u *)FALSE,
  #endif
! 				(char_u *)0L}},
      {"textwidth",   "tw",   P_NUM|P_VI_DEF|P_VIM,
  			    (char_u *)&p_tw, PV_TW,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"thesaurus",   "tsr",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_tsr, PV_TSR,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"tildeop",	    "top",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_to, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"timeout",	    "to",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_timeout, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"timeoutlen",  "tm",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_tm, PV_NONE,
! 			    {(char_u *)1000L, (char_u *)0L}},
      {"title",	    NULL,   P_BOOL|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_title, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"titlelen",    NULL,   P_NUM|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_titlelen, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)85L, (char_u *)0L}},
      {"titleold",    NULL,   P_STRING|P_VI_DEF|P_GETTEXT|P_SECURE|P_NO_MKRC,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_titleold, PV_NONE,
--- 2483,2522 ----
  #else
  			    (char_u *)FALSE,
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"textwidth",   "tw",   P_NUM|P_VI_DEF|P_VIM,
  			    (char_u *)&p_tw, PV_TW,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"thesaurus",   "tsr",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_tsr, PV_TSR,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"tildeop",	    "top",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_to, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"timeout",	    "to",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_timeout, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"timeoutlen",  "tm",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_tm, PV_NONE,
! 			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
      {"title",	    NULL,   P_BOOL|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_title, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"titlelen",    NULL,   P_NUM|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_titlelen, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)85L, (char_u *)0L} SCRIPTID_INIT},
      {"titleold",    NULL,   P_STRING|P_VI_DEF|P_GETTEXT|P_SECURE|P_NO_MKRC,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_titleold, PV_NONE,
***************
*** 2507,2555 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"titlestring", NULL,   P_STRING|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_titlestring, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
  #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
      {"toolbar",     "tb",   P_STRING|P_COMMA|P_VI_DEF|P_NODUP,
  			    (char_u *)&p_toolbar, PV_NONE,
! 			    {(char_u *)"icons,tooltips", (char_u *)0L}},
  #endif
  #if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
      {"toolbariconsize",	"tbis", P_STRING|P_VI_DEF,
  			    (char_u *)&p_tbis, PV_NONE,
! 			    {(char_u *)"small", (char_u *)0L}},
  #endif
      {"ttimeout",    NULL,   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_ttimeout, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"ttimeoutlen", "ttm",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_ttm, PV_NONE,
! 			    {(char_u *)-1L, (char_u *)0L}},
      {"ttybuiltin",  "tbi",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_tbi, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"ttyfast",	    "tf",   P_BOOL|P_NO_MKRC|P_VI_DEF,
  			    (char_u *)&p_tf, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"ttymouse",    "ttym", P_STRING|P_NODEFAULT|P_NO_MKRC|P_VI_DEF,
  #if defined(FEAT_MOUSE) && (defined(UNIX) || defined(VMS))
  			    (char_u *)&p_ttym, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"ttyscroll",   "tsl",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_ttyscroll, PV_NONE,
! 			    {(char_u *)999L, (char_u *)0L}},
      {"ttytype",	    "tty",  P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
  			    (char_u *)&T_NAME, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"undolevels",  "ul",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_ul, PV_NONE,
  			    {
--- 2526,2575 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"titlestring", NULL,   P_STRING|P_VI_DEF,
  #ifdef FEAT_TITLE
  			    (char_u *)&p_titlestring, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
  #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
      {"toolbar",     "tb",   P_STRING|P_COMMA|P_VI_DEF|P_NODUP,
  			    (char_u *)&p_toolbar, PV_NONE,
! 			    {(char_u *)"icons,tooltips", (char_u *)0L}
! 			    SCRIPTID_INIT},
  #endif
  #if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
      {"toolbariconsize",	"tbis", P_STRING|P_VI_DEF,
  			    (char_u *)&p_tbis, PV_NONE,
! 			    {(char_u *)"small", (char_u *)0L} SCRIPTID_INIT},
  #endif
      {"ttimeout",    NULL,   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_ttimeout, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"ttimeoutlen", "ttm",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_ttm, PV_NONE,
! 			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
      {"ttybuiltin",  "tbi",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_tbi, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"ttyfast",	    "tf",   P_BOOL|P_NO_MKRC|P_VI_DEF,
  			    (char_u *)&p_tf, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"ttymouse",    "ttym", P_STRING|P_NODEFAULT|P_NO_MKRC|P_VI_DEF,
  #if defined(FEAT_MOUSE) && (defined(UNIX) || defined(VMS))
  			    (char_u *)&p_ttym, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"ttyscroll",   "tsl",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_ttyscroll, PV_NONE,
! 			    {(char_u *)999L, (char_u *)0L} SCRIPTID_INIT},
      {"ttytype",	    "tty",  P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
  			    (char_u *)&T_NAME, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"undolevels",  "ul",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_ul, PV_NONE,
  			    {
***************
*** 2558,2576 ****
  #else
  			    (char_u *)100L,
  #endif
! 				(char_u *)0L}},
      {"updatecount", "uc",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_uc, PV_NONE,
! 			    {(char_u *)200L, (char_u *)0L}},
      {"updatetime",  "ut",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_ut, PV_NONE,
! 			    {(char_u *)4000L, (char_u *)0L}},
      {"verbose",	    "vbs",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_verbose, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"verbosefile", "vfile", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_vfile, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}},
      {"viewdir",     "vdir", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_SESSION
  			    (char_u *)&p_vdir, PV_NONE,
--- 2578,2596 ----
  #else
  			    (char_u *)100L,
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"updatecount", "uc",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_uc, PV_NONE,
! 			    {(char_u *)200L, (char_u *)0L} SCRIPTID_INIT},
      {"updatetime",  "ut",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_ut, PV_NONE,
! 			    {(char_u *)4000L, (char_u *)0L} SCRIPTID_INIT},
      {"verbose",	    "vbs",  P_NUM|P_VI_DEF,
  			    (char_u *)&p_verbose, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"verbosefile", "vfile", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_vfile, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"viewdir",     "vdir", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_SESSION
  			    (char_u *)&p_vdir, PV_NONE,
***************
*** 2579,2585 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"viewoptions", "vop",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SESSION
  			    (char_u *)&p_vop, PV_NONE,
--- 2599,2605 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"viewoptions", "vop",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SESSION
  			    (char_u *)&p_vop, PV_NONE,
***************
*** 2588,2594 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"viminfo",	    "vi",   P_STRING|P_COMMA|P_NODUP|P_SECURE,
  #ifdef FEAT_VIMINFO
  			    (char_u *)&p_viminfo, PV_NONE,
--- 2608,2614 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"viminfo",	    "vi",   P_STRING|P_COMMA|P_NODUP|P_SECURE,
  #ifdef FEAT_VIMINFO
  			    (char_u *)&p_viminfo, PV_NONE,
***************
*** 2606,2612 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"virtualedit", "ve",   P_STRING|P_COMMA|P_NODUP|P_VI_DEF|P_VIM,
  #ifdef FEAT_VIRTUALEDIT
  			    (char_u *)&p_ve, PV_NONE,
--- 2626,2632 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"virtualedit", "ve",   P_STRING|P_COMMA|P_NODUP|P_VI_DEF|P_VIM,
  #ifdef FEAT_VIRTUALEDIT
  			    (char_u *)&p_ve, PV_NONE,
***************
*** 2615,2665 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    },
      {"visualbell",  "vb",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_vb, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"w300",	    NULL,   P_NUM|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"w1200",	    NULL,   P_NUM|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"w9600",	    NULL,   P_NUM|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"warn",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_warn, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"weirdinvert", "wiv",  P_BOOL|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_wiv, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"whichwrap",   "ww",   P_STRING|P_VIM|P_COMMA|P_FLAGLIST,
  			    (char_u *)&p_ww, PV_NONE,
! 			    {(char_u *)"", (char_u *)"b,s"}},
      {"wildchar",    "wc",   P_NUM|P_VIM,
  			    (char_u *)&p_wc, PV_NONE,
! 			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}},
      {"wildcharm",   "wcm",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_wcm, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"wildignore",  "wig",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_WILDIGN
  			    (char_u *)&p_wig, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L}},
      {"wildmenu",    "wmnu", P_BOOL|P_VI_DEF,
  #ifdef FEAT_WILDMENU
  			    (char_u *)&p_wmnu, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"wildmode",    "wim",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_wim, PV_NONE,
! 			    {(char_u *)"full", (char_u *)0L}},
      {"wildoptions", "wop",  P_STRING|P_VI_DEF,
  #ifdef FEAT_CMDL_COMPL
  			    (char_u *)&p_wop, PV_NONE,
--- 2635,2686 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"visualbell",  "vb",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_vb, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"w300",	    NULL,   P_NUM|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"w1200",	    NULL,   P_NUM|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"w9600",	    NULL,   P_NUM|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"warn",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_warn, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"weirdinvert", "wiv",  P_BOOL|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_wiv, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"whichwrap",   "ww",   P_STRING|P_VIM|P_COMMA|P_FLAGLIST,
  			    (char_u *)&p_ww, PV_NONE,
! 			    {(char_u *)"", (char_u *)"b,s"} SCRIPTID_INIT},
      {"wildchar",    "wc",   P_NUM|P_VIM,
  			    (char_u *)&p_wc, PV_NONE,
! 			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}
! 			    SCRIPTID_INIT},
      {"wildcharm",   "wcm",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_wcm, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"wildignore",  "wig",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_WILDIGN
  			    (char_u *)&p_wig, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"wildmenu",    "wmnu", P_BOOL|P_VI_DEF,
  #ifdef FEAT_WILDMENU
  			    (char_u *)&p_wmnu, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"wildmode",    "wim",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_wim, PV_NONE,
! 			    {(char_u *)"full", (char_u *)0L} SCRIPTID_INIT},
      {"wildoptions", "wop",  P_STRING|P_VI_DEF,
  #ifdef FEAT_CMDL_COMPL
  			    (char_u *)&p_wop, PV_NONE,
***************
*** 2668,2674 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"winaltkeys",  "wak",  P_STRING|P_VI_DEF,
  #ifdef FEAT_WAK
  			    (char_u *)&p_wak, PV_NONE,
--- 2689,2695 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"winaltkeys",  "wak",  P_STRING|P_VI_DEF,
  #ifdef FEAT_WAK
  			    (char_u *)&p_wak, PV_NONE,
***************
*** 2677,2743 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    },
      {"window",	    "wi",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_window, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"winheight",   "wh",   P_NUM|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_wh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L}},
      {"winfixheight", "wfh", P_BOOL|P_VI_DEF|P_RSTAT,
  #ifdef FEAT_WINDOWS
  			    (char_u *)VAR_WIN, PV_WFH,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"winfixwidth", "wfw", P_BOOL|P_VI_DEF|P_RSTAT,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)VAR_WIN, PV_WFW,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"winminheight", "wmh", P_NUM|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_wmh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L}},
      {"winminwidth", "wmw", P_NUM|P_VI_DEF,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)&p_wmw, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L}},
      {"winwidth",   "wiw",   P_NUM|P_VI_DEF,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)&p_wiw, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)20L, (char_u *)0L}},
      {"wrap",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_WRAP,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"wrapmargin",  "wm",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_wm, PV_WM,
! 			    {(char_u *)0L, (char_u *)0L}},
      {"wrapscan",    "ws",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ws, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"write",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_write, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}},
      {"writeany",    "wa",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_wa, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}},
      {"writebackup", "wb",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_wb, PV_NONE,
  			    {
--- 2698,2764 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"window",	    "wi",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_window, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"winheight",   "wh",   P_NUM|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_wh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"winfixheight", "wfh", P_BOOL|P_VI_DEF|P_RSTAT,
  #ifdef FEAT_WINDOWS
  			    (char_u *)VAR_WIN, PV_WFH,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"winfixwidth", "wfw", P_BOOL|P_VI_DEF|P_RSTAT,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)VAR_WIN, PV_WFW,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"winminheight", "wmh", P_NUM|P_VI_DEF,
  #ifdef FEAT_WINDOWS
  			    (char_u *)&p_wmh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"winminwidth", "wmw", P_NUM|P_VI_DEF,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)&p_wmw, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"winwidth",   "wiw",   P_NUM|P_VI_DEF,
  #ifdef FEAT_VERTSPLIT
  			    (char_u *)&p_wiw, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
! 			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
      {"wrap",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_WRAP,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"wrapmargin",  "wm",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_wm, PV_WM,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"wrapscan",    "ws",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ws, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"write",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_write, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"writeany",    "wa",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_wa, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"writebackup", "wb",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_wb, PV_NONE,
  			    {
***************
*** 2746,2760 ****
  #else
  			    (char_u *)FALSE,
  #endif
! 				(char_u *)0L}},
      {"writedelay",  "wd",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_wd, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}},
  
  /* terminal output codes */
  #define p_term(sss, vvv)   {sss, NULL, P_STRING|P_VI_DEF|P_RALL|P_SECURE, \
  			    (char_u *)&vvv, PV_NONE, \
! 			    {(char_u *)"", (char_u *)0L}},
  
      p_term("t_AB", T_CAB)
      p_term("t_AF", T_CAF)
--- 2767,2781 ----
  #else
  			    (char_u *)FALSE,
  #endif
! 				(char_u *)0L} SCRIPTID_INIT},
      {"writedelay",  "wd",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_wd, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
  
  /* terminal output codes */
  #define p_term(sss, vvv)   {sss, NULL, P_STRING|P_VI_DEF|P_RALL|P_SECURE, \
  			    (char_u *)&vvv, PV_NONE, \
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
  
      p_term("t_AB", T_CAB)
      p_term("t_AF", T_CAF)
***************
*** 2815,2821 ****
  
  /* terminal key codes are not in here */
  
!     {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL}}	/* end marker */
  };
  
  #define PARAM_COUNT (sizeof(options) / sizeof(struct vimoption))
--- 2836,2843 ----
  
  /* terminal key codes are not in here */
  
!     /* end marker */
!     {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL} SCRIPTID_INIT}
  };
  
  #define PARAM_COUNT (sizeof(options) / sizeof(struct vimoption))
***************
*** 9917,9923 ****
  	regmatch->rm_ic = ic;
  	if (xp->xp_context != EXPAND_BOOL_SETTINGS)
  	{
! 	    for (match = 0; match < sizeof(names) / sizeof(char *); ++match)
  		if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))
  		{
  		    if (loop == 0)
--- 9939,9946 ----
  	regmatch->rm_ic = ic;
  	if (xp->xp_context != EXPAND_BOOL_SETTINGS)
  	{
! 	    for (match = 0; match < (int)(sizeof(names) / sizeof(char *));
! 								      ++match)
  		if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))
  		{
  		    if (loop == 0)
*** ../vim-7.2.179/src/os_unix.c	2009-05-16 16:36:25.000000000 +0200
--- src/os_unix.c	2009-05-17 12:17:01.000000000 +0200
***************
*** 821,827 ****
  #endif
  
  #if defined(SIGINT)
- /* ARGSUSED */
      static RETSIGTYPE
  catch_sigint SIGDEFARG(sigarg)
  {
--- 821,826 ----
***************
*** 833,839 ****
  #endif
  
  #if defined(SIGPWR)
- /* ARGSUSED */
      static RETSIGTYPE
  catch_sigpwr SIGDEFARG(sigarg)
  {
--- 832,837 ----
***************
*** 853,859 ****
  /*
   * signal function for alarm().
   */
- /* ARGSUSED */
      static RETSIGTYPE
  sig_alarm SIGDEFARG(sigarg)
  {
--- 851,856 ----
***************
*** 1087,1093 ****
  /*
   * signal handler for SIGCONT
   */
- /* ARGSUSED */
      static RETSIGTYPE
  sigcont_handler SIGDEFARG(sigarg)
  {
--- 1084,1089 ----
***************
*** 1436,1446 ****
  /*
   * Another X Error handler, just used to check for errors.
   */
- /* ARGSUSED */
      static int
  x_error_check(dpy, error_event)
!     Display *dpy;
!     XErrorEvent	*error_event;
  {
      got_x_error = TRUE;
      return 0;
--- 1432,1441 ----
  /*
   * Another X Error handler, just used to check for errors.
   */
      static int
  x_error_check(dpy, error_event)
!     Display *dpy UNUSED;
!     XErrorEvent	*error_event UNUSED;
  {
      got_x_error = TRUE;
      return 0;
***************
*** 1453,1467 ****
   */
  static int x_IOerror_check __ARGS((Display *dpy));
  
- /* ARGSUSED */
      static int
  x_IOerror_check(dpy)
!     Display *dpy;
  {
      /* This function should not return, it causes exit().  Longjump instead. */
      LONGJMP(lc_jump_env, 1);
-     /*NOTREACHED*/
-     return 0;
  }
  # endif
  
--- 1448,1459 ----
   */
  static int x_IOerror_check __ARGS((Display *dpy));
  
      static int
  x_IOerror_check(dpy)
!     Display *dpy UNUSED;
  {
      /* This function should not return, it causes exit().  Longjump instead. */
      LONGJMP(lc_jump_env, 1);
  }
  # endif
  
***************
*** 1470,1479 ****
   */
  static int x_IOerror_handler __ARGS((Display *dpy));
  
- /* ARGSUSED */
      static int
  x_IOerror_handler(dpy)
!     Display *dpy;
  {
      xterm_dpy = NULL;
      x11_window = 0;
--- 1462,1470 ----
   */
  static int x_IOerror_handler __ARGS((Display *dpy));
  
      static int
  x_IOerror_handler(dpy)
!     Display *dpy UNUSED;
  {
      xterm_dpy = NULL;
      x11_window = 0;
***************
*** 1482,1489 ****
  
      /* This function should not return, it causes exit().  Longjump instead. */
      LONGJMP(x_jump_env, 1);
-     /*NOTREACHED*/
-     return 0;
  }
  #endif
  
--- 1473,1478 ----
***************
*** 1919,1928 ****
  
  #else  /* FEAT_X11 */
  
- /*ARGSUSED*/
      static int
  get_x11_title(test_only)
!     int	    test_only;
  {
      return FALSE;
  }
--- 1908,1916 ----
  
  #else  /* FEAT_X11 */
  
      static int
  get_x11_title(test_only)
!     int	    test_only UNUSED;
  {
      return FALSE;
  }
***************
*** 2497,2507 ****
   * file name to remain exactly the same.
   * Only required for file systems where case is ignored and preserved.
   */
- /*ARGSUSED*/
      void
  fname_case(name, len)
      char_u	*name;
!     int		len;	    /* buffer size, only used when name gets longer */
  {
      struct stat st;
      char_u	*slash, *tail;
--- 2485,2494 ----
   * file name to remain exactly the same.
   * Only required for file systems where case is ignored and preserved.
   */
      void
  fname_case(name, len)
      char_u	*name;
!     int		len UNUSED;  /* buffer size, only used when name gets longer */
  {
      struct stat st;
      char_u	*slash, *tail;
***************
*** 5141,5147 ****
  
  #define SHELL_SPECIAL (char_u *)"\t \"&'$;<>()\\|"
  
- /* ARGSUSED */
      int
  mch_expand_wildcards(num_pat, pat, num_file, file, flags)
      int		   num_pat;
--- 5128,5133 ----
***************
*** 6068,6074 ****
  /*
   * Gets info from sysmouse and adds special keys to input buf.
   */
- /* ARGSUSED */
      static RETSIGTYPE
  sig_sysmouse SIGDEFARG(sigarg)
  {
--- 6054,6059 ----
***************
*** 6632,6642 ****
   * This is our chance to ask the user if they want to save,
   * or abort the logout
   */
- /*ARGSUSED*/
      static void
  xsmp_handle_interaction(smc_conn, client_data)
      SmcConn	smc_conn;
!     SmPointer	client_data;
  {
      cmdmod_T	save_cmdmod;
      int		cancel_shutdown = False;
--- 6617,6626 ----
   * This is our chance to ask the user if they want to save,
   * or abort the logout
   */
      static void
  xsmp_handle_interaction(smc_conn, client_data)
      SmcConn	smc_conn;
!     SmPointer	client_data UNUSED;
  {
      cmdmod_T	save_cmdmod;
      int		cancel_shutdown = False;
***************
*** 6669,6684 ****
  /*
   * Callback that starts save-yourself.
   */
- /*ARGSUSED*/
      static void
  xsmp_handle_save_yourself(smc_conn, client_data, save_type,
  					       shutdown, interact_style, fast)
      SmcConn	smc_conn;
!     SmPointer	client_data;
!     int		save_type;
      Bool	shutdown;
!     int		interact_style;
!     Bool	fast;
  {
      /* Handle already being in saveyourself */
      if (xsmp.save_yourself)
--- 6653,6667 ----
  /*
   * Callback that starts save-yourself.
   */
      static void
  xsmp_handle_save_yourself(smc_conn, client_data, save_type,
  					       shutdown, interact_style, fast)
      SmcConn	smc_conn;
!     SmPointer	client_data UNUSED;
!     int		save_type UNUSED;
      Bool	shutdown;
!     int		interact_style UNUSED;
!     Bool	fast UNUSED;
  {
      /* Handle already being in saveyourself */
      if (xsmp.save_yourself)
***************
*** 6712,6722 ****
  /*
   * Callback to warn us of imminent death.
   */
- /*ARGSUSED*/
      static void
  xsmp_die(smc_conn, client_data)
!     SmcConn	smc_conn;
!     SmPointer	client_data;
  {
      xsmp_close();
  
--- 6695,6704 ----
  /*
   * Callback to warn us of imminent death.
   */
      static void
  xsmp_die(smc_conn, client_data)
!     SmcConn	smc_conn UNUSED;
!     SmPointer	client_data UNUSED;
  {
      xsmp_close();
  
***************
*** 6728,6738 ****
  /*
   * Callback to tell us that save-yourself has completed.
   */
- /*ARGSUSED*/
      static void
  xsmp_save_complete(smc_conn, client_data)
!     SmcConn	smc_conn;
!     SmPointer	client_data;
  {
      xsmp.save_yourself = False;
  }
--- 6710,6719 ----
  /*
   * Callback to tell us that save-yourself has completed.
   */
      static void
  xsmp_save_complete(smc_conn, client_data)
!     SmcConn	smc_conn UNUSED;
!     SmPointer	client_data UNUSED;
  {
      xsmp.save_yourself = False;
  }
***************
*** 6742,6752 ****
   * Callback to tell us that an instigated shutdown was cancelled
   * (maybe even by us)
   */
- /*ARGSUSED*/
      static void
  xsmp_shutdown_cancelled(smc_conn, client_data)
      SmcConn	smc_conn;
!     SmPointer	client_data;
  {
      if (xsmp.save_yourself)
  	SmcSaveYourselfDone(smc_conn, True);
--- 6723,6732 ----
   * Callback to tell us that an instigated shutdown was cancelled
   * (maybe even by us)
   */
      static void
  xsmp_shutdown_cancelled(smc_conn, client_data)
      SmcConn	smc_conn;
!     SmPointer	client_data UNUSED;
  {
      if (xsmp.save_yourself)
  	SmcSaveYourselfDone(smc_conn, True);
***************
*** 6758,6770 ****
  /*
   * Callback to tell us that a new ICE connection has been established.
   */
- /*ARGSUSED*/
      static void
  xsmp_ice_connection(iceConn, clientData, opening, watchData)
      IceConn	iceConn;
!     IcePointer	clientData;
      Bool	opening;
!     IcePointer	*watchData;
  {
      /* Intercept creation of ICE connection fd */
      if (opening)
--- 6738,6749 ----
  /*
   * Callback to tell us that a new ICE connection has been established.
   */
      static void
  xsmp_ice_connection(iceConn, clientData, opening, watchData)
      IceConn	iceConn;
!     IcePointer	clientData UNUSED;
      Bool	opening;
!     IcePointer	*watchData UNUSED;
  {
      /* Intercept creation of ICE connection fd */
      if (opening)
*** ../vim-7.2.179/src/quickfix.c	2009-05-13 18:54:14.000000000 +0200
--- src/quickfix.c	2009-05-16 22:31:49.000000000 +0200
***************
*** 2240,2246 ****
   * ":cclose": close the window showing the list of errors.
   * ":lclose": close the window showing the location list
   */
- /*ARGSUSED*/
      void
  ex_cclose(eap)
      exarg_T	*eap;
--- 2240,2245 ----
***************
*** 3211,3217 ****
  			break;
  		    col = regmatch.endpos[0].col
  					    + (col == regmatch.endpos[0].col);
! 		    if (col > STRLEN(ml_get_buf(buf, lnum, FALSE)))
  			break;
  		}
  		line_breakcheck();
--- 3210,3216 ----
  			break;
  		    col = regmatch.endpos[0].col
  					    + (col == regmatch.endpos[0].col);
! 		    if (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))
  			break;
  		}
  		line_breakcheck();
*** ../vim-7.2.179/src/screen.c	2009-05-13 12:46:36.000000000 +0200
--- src/screen.c	2009-05-16 21:51:13.000000000 +0200
***************
*** 270,280 ****
   * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
   * may become invalid and the whole window will have to be redrawn.
   */
- /*ARGSUSED*/
      void
  redrawWinline(lnum, invalid)
      linenr_T	lnum;
!     int		invalid;	/* window line height is invalid now */
  {
  #ifdef FEAT_FOLDING
      int		i;
--- 270,279 ----
   * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
   * may become invalid and the whole window will have to be redrawn.
   */
      void
  redrawWinline(lnum, invalid)
      linenr_T	lnum;
!     int		invalid UNUSED;	/* window line height is invalid now */
  {
  #ifdef FEAT_FOLDING
      int		i;
***************
*** 2413,2419 ****
  			&& (lnume < bot->lnum
  			    || (lnume == bot->lnum
  				&& (bot->col - (*p_sel == 'e'))
! 		>= STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
  	{
  	    if (VIsual_mode == Ctrl_V)
  	    {
--- 2412,2418 ----
  			&& (lnume < bot->lnum
  			    || (lnume == bot->lnum
  				&& (bot->col - (*p_sel == 'e'))
! 		>= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
  	{
  	    if (VIsual_mode == Ctrl_V)
  	    {
***************
*** 2549,2562 ****
   *
   * Return the number of last row the line occupies.
   */
- /* ARGSUSED */
      static int
  win_line(wp, lnum, startrow, endrow, nochange)
      win_T	*wp;
      linenr_T	lnum;
      int		startrow;
      int		endrow;
!     int		nochange;		/* not updating for changed text */
  {
      int		col;			/* visual column on screen */
      unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
--- 2548,2560 ----
   *
   * Return the number of last row the line occupies.
   */
      static int
  win_line(wp, lnum, startrow, endrow, nochange)
      win_T	*wp;
      linenr_T	lnum;
      int		startrow;
      int		endrow;
!     int		nochange UNUSED;	/* not updating for changed text */
  {
      int		col;			/* visual column on screen */
      unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
***************
*** 6098,6104 ****
  				fillchar, maxwidth, hltab, tabtab);
      len = (int)STRLEN(buf);
  
!     while (width < maxwidth && len < sizeof(buf) - 1)
      {
  #ifdef FEAT_MBYTE
  	len += (*mb_char2bytes)(fillchar, buf + len);
--- 6096,6102 ----
  				fillchar, maxwidth, hltab, tabtab);
      len = (int)STRLEN(buf);
  
!     while (width < maxwidth && len < (int)sizeof(buf) - 1)
      {
  #ifdef FEAT_MBYTE
  	len += (*mb_char2bytes)(fillchar, buf + len);
***************
*** 8655,8661 ****
   *
   * Return OK for success, FAIL if the lines are not deleted.
   */
- /*ARGSUSED*/
      int
  screen_del_lines(off, row, line_count, end, force, wp)
      int		off;
--- 8653,8658 ----
***************
*** 8663,8669 ****
      int		line_count;
      int		end;
      int		force;		/* even when line_count > p_ttyscroll */
!     win_T	*wp;		/* NULL or window to use width from */
  {
      int		j;
      int		i;
--- 8660,8666 ----
      int		line_count;
      int		end;
      int		force;		/* even when line_count > p_ttyscroll */
!     win_T	*wp UNUSED;	/* NULL or window to use width from */
  {
      int		j;
      int		i;
*** ../vim-7.2.179/src/search.c	2009-05-15 21:31:11.000000000 +0200
--- src/search.c	2009-05-16 22:33:05.000000000 +0200
***************
*** 4527,4538 ****
   * Find identifiers or defines in included files.
   * if p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
   */
- /*ARGSUSED*/
      void
  find_pattern_in_path(ptr, dir, len, whole, skip_comments,
  				    type, count, action, start_lnum, end_lnum)
      char_u	*ptr;		/* pointer to search pattern */
!     int		dir;		/* direction of expansion */
      int		len;		/* length of search pattern */
      int		whole;		/* match whole words only */
      int		skip_comments;	/* don't match inside comments */
--- 4527,4537 ----
   * Find identifiers or defines in included files.
   * if p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
   */
      void
  find_pattern_in_path(ptr, dir, len, whole, skip_comments,
  				    type, count, action, start_lnum, end_lnum)
      char_u	*ptr;		/* pointer to search pattern */
!     int		dir UNUSED;	/* direction of expansion */
      int		len;		/* length of search pattern */
      int		whole;		/* match whole words only */
      int		skip_comments;	/* don't match inside comments */
*** ../vim-7.2.179/src/spell.c	2009-05-13 18:54:14.000000000 +0200
--- src/spell.c	2009-05-16 22:10:19.000000000 +0200
***************
*** 950,957 ****
   */
  #ifndef FEAT_MBYTE
  /* Non-multi-byte implementation. */
! # define SPELL_TOFOLD(c) ((c) < 256 ? spelltab.st_fold[c] : (c))
! # define SPELL_TOUPPER(c) ((c) < 256 ? spelltab.st_upper[c] : (c))
  # define SPELL_ISUPPER(c) ((c) < 256 ? spelltab.st_isu[c] : FALSE)
  #else
  # if defined(HAVE_WCHAR_H)
--- 950,957 ----
   */
  #ifndef FEAT_MBYTE
  /* Non-multi-byte implementation. */
! # define SPELL_TOFOLD(c) ((c) < 256 ? (int)spelltab.st_fold[c] : (c))
! # define SPELL_TOUPPER(c) ((c) < 256 ? (int)spelltab.st_upper[c] : (c))
  # define SPELL_ISUPPER(c) ((c) < 256 ? spelltab.st_isu[c] : FALSE)
  #else
  # if defined(HAVE_WCHAR_H)
***************
*** 962,979 ****
   * the "w" library function for characters above 255 if available. */
  # ifdef HAVE_TOWLOWER
  #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
! 	    : (c) < 256 ? spelltab.st_fold[c] : towlower(c))
  # else
  #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
! 	    : (c) < 256 ? spelltab.st_fold[c] : (c))
  # endif
  
  # ifdef HAVE_TOWUPPER
  #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
! 	    : (c) < 256 ? spelltab.st_upper[c] : towupper(c))
  # else
  #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
! 	    : (c) < 256 ? spelltab.st_upper[c] : (c))
  # endif
  
  # ifdef HAVE_ISWUPPER
--- 962,979 ----
   * the "w" library function for characters above 255 if available. */
  # ifdef HAVE_TOWLOWER
  #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
! 	    : (c) < 256 ? (int)spelltab.st_fold[c] : (int)towlower(c))
  # else
  #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
! 	    : (c) < 256 ? (int)spelltab.st_fold[c] : (c))
  # endif
  
  # ifdef HAVE_TOWUPPER
  #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
! 	    : (c) < 256 ? (int)spelltab.st_upper[c] : (int)towupper(c))
  # else
  #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
! 	    : (c) < 256 ? (int)spelltab.st_upper[c] : (c))
  # endif
  
  # ifdef HAVE_ISWUPPER
***************
*** 8052,8058 ****
      /* time_t can be up to 8 bytes in size, more than long_u, thus we
       * can't use put_bytes() here. */
      for (i = 7; i >= 0; --i)
! 	if (i + 1 > sizeof(time_t))
  	    /* ">>" doesn't work well when shifting more bits than avail */
  	    putc(0, fd);
  	else
--- 8052,8058 ----
      /* time_t can be up to 8 bytes in size, more than long_u, thus we
       * can't use put_bytes() here. */
      for (i = 7; i >= 0; --i)
! 	if (i + 1 > (int)sizeof(time_t))
  	    /* ">>" doesn't work well when shifting more bits than avail */
  	    putc(0, fd);
  	else
***************
*** 10541,10550 ****
  /*
   * ":spellrepall"
   */
- /*ARGSUSED*/
      void
  ex_spellrepall(eap)
!     exarg_T *eap;
  {
      pos_T	pos = curwin->w_cursor;
      char_u	*frompat;
--- 10541,10549 ----
  /*
   * ":spellrepall"
   */
      void
  ex_spellrepall(eap)
!     exarg_T *eap UNUSED;
  {
      pos_T	pos = curwin->w_cursor;
      char_u	*frompat;
***************
*** 15604,15613 ****
  /*
   * ":spellinfo"
   */
- /*ARGSUSED*/
      void
  ex_spellinfo(eap)
!     exarg_T *eap;
  {
      int		lpi;
      langp_T	*lp;
--- 15603,15611 ----
  /*
   * ":spellinfo"
   */
      void
  ex_spellinfo(eap)
!     exarg_T *eap UNUSED;
  {
      int		lpi;
      langp_T	*lp;
***************
*** 16153,16159 ****
   */
      int
  expand_spelling(lnum, pat, matchp)
!     linenr_T	lnum;
      char_u	*pat;
      char_u	***matchp;
  {
--- 16151,16157 ----
   */
      int
  expand_spelling(lnum, pat, matchp)
!     linenr_T	lnum UNUSED;
      char_u	*pat;
      char_u	***matchp;
  {
*** ../vim-7.2.179/src/syntax.c	2008-08-09 19:37:33.000000000 +0200
--- src/syntax.c	2009-05-16 22:14:19.000000000 +0200
***************
*** 3224,3234 ****
  /*
   * Handle ":syntax case" command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_case(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	    /* not used */
  {
      char_u	*arg = eap->arg;
      char_u	*next;
--- 3224,3233 ----
  /*
   * Handle ":syntax case" command.
   */
      static void
  syn_cmd_case(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	*next;
***************
*** 3249,3259 ****
  /*
   * Handle ":syntax spell" command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_spell(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	    /* not used */
  {
      char_u	*arg = eap->arg;
      char_u	*next;
--- 3248,3257 ----
  /*
   * Handle ":syntax spell" command.
   */
      static void
  syn_cmd_spell(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	*next;
***************
*** 3517,3527 ****
  /*
   * Handle ":syntax on" command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_on(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	/* not used */
  {
      syn_cmd_onoff(eap, "syntax");
  }
--- 3515,3524 ----
  /*
   * Handle ":syntax on" command.
   */
      static void
  syn_cmd_on(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      syn_cmd_onoff(eap, "syntax");
  }
***************
*** 3529,3539 ****
  /*
   * Handle ":syntax enable" command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_enable(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	/* not used */
  {
      set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"enable");
      syn_cmd_onoff(eap, "syntax");
--- 3526,3535 ----
  /*
   * Handle ":syntax enable" command.
   */
      static void
  syn_cmd_enable(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"enable");
      syn_cmd_onoff(eap, "syntax");
***************
*** 3543,3553 ****
  /*
   * Handle ":syntax reset" command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_reset(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	/* not used */
  {
      eap->nextcmd = check_nextcmd(eap->arg);
      if (!eap->skip)
--- 3539,3548 ----
  /*
   * Handle ":syntax reset" command.
   */
      static void
  syn_cmd_reset(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      eap->nextcmd = check_nextcmd(eap->arg);
      if (!eap->skip)
***************
*** 3561,3571 ****
  /*
   * Handle ":syntax manual" command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_manual(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	/* not used */
  {
      syn_cmd_onoff(eap, "manual");
  }
--- 3556,3565 ----
  /*
   * Handle ":syntax manual" command.
   */
      static void
  syn_cmd_manual(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      syn_cmd_onoff(eap, "manual");
  }
***************
*** 3573,3583 ****
  /*
   * Handle ":syntax off" command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_off(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	/* not used */
  {
      syn_cmd_onoff(eap, "nosyntax");
  }
--- 3567,3576 ----
  /*
   * Handle ":syntax off" command.
   */
      static void
  syn_cmd_off(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      syn_cmd_onoff(eap, "nosyntax");
  }
***************
*** 4461,4471 ****
  /*
   * Handle ":syntax include [@{group-name}] filename" command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_include(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	    /* not used */
  {
      char_u	*arg = eap->arg;
      int		sgl_id = 1;
--- 4454,4463 ----
  /*
   * Handle ":syntax include [@{group-name}] filename" command.
   */
      static void
  syn_cmd_include(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      int		sgl_id = 1;
***************
*** 4532,4542 ****
  /*
   * Handle ":syntax keyword {group-name} [{option}] keyword .." command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_keyword(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	    /* not used */
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
--- 4524,4533 ----
  /*
   * Handle ":syntax keyword {group-name} [{option}] keyword .." command.
   */
      static void
  syn_cmd_keyword(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
***************
*** 5275,5285 ****
   * Handle ":syntax cluster {cluster-name} [contains={groupname},..]
   *		[add={groupname},..] [remove={groupname},..]".
   */
- /* ARGSUSED */
      static void
  syn_cmd_cluster(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	    /* not used */
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
--- 5266,5275 ----
   * Handle ":syntax cluster {cluster-name} [contains={groupname},..]
   *		[add={groupname},..] [remove={groupname},..]".
   */
      static void
  syn_cmd_cluster(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
***************
*** 5464,5474 ****
  /*
   * Handle ":syntax sync .." command.
   */
- /* ARGSUSED */
      static void
  syn_cmd_sync(eap, syncing)
      exarg_T	*eap;
!     int		syncing;	    /* not used */
  {
      char_u	*arg_start = eap->arg;
      char_u	*arg_end;
--- 5454,5463 ----
  /*
   * Handle ":syntax sync .." command.
   */
      static void
  syn_cmd_sync(eap, syncing)
      exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg_start = eap->arg;
      char_u	*arg_end;
***************
*** 6099,6108 ****
   * Function given to ExpandGeneric() to obtain the list syntax names for
   * expansion.
   */
- /*ARGSUSED*/
      char_u *
  get_syntax_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      if (expand_what == EXP_SUBCMD)
--- 6088,6096 ----
   * Function given to ExpandGeneric() to obtain the list syntax names for
   * expansion.
   */
      char_u *
  get_syntax_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      if (expand_what == EXP_SUBCMD)
***************
*** 7744,7757 ****
  /*
   * Get the font or fontset for one highlight group.
   */
- /*ARGSUSED*/
      static void
  hl_do_font(idx, arg, do_normal, do_menu, do_tooltip)
      int		idx;
      char_u	*arg;
!     int		do_normal;	/* set normal font */
!     int		do_menu;	/* set menu font */
!     int		do_tooltip;	/* set tooltip font */
  {
  # ifdef FEAT_XFONTSET
      /* If 'guifontset' is not empty, first try using the name as a
--- 7732,7744 ----
  /*
   * Get the font or fontset for one highlight group.
   */
      static void
  hl_do_font(idx, arg, do_normal, do_menu, do_tooltip)
      int		idx;
      char_u	*arg;
!     int		do_normal;		/* set normal font */
!     int		do_menu UNUSED;		/* set menu font */
!     int		do_tooltip UNUSED;	/* set tooltip font */
  {
  # ifdef FEAT_XFONTSET
      /* If 'guifontset' is not empty, first try using the name as a
***************
*** 9150,9159 ****
   * Function given to ExpandGeneric() to obtain the list of group names.
   * Also used for synIDattr() function.
   */
- /*ARGSUSED*/
      char_u *
  get_highlight_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
  #ifdef FEAT_CMDL_COMPL
--- 9137,9145 ----
   * Function given to ExpandGeneric() to obtain the list of group names.
   * Also used for synIDattr() function.
   */
      char_u *
  get_highlight_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
  #ifdef FEAT_CMDL_COMPL
*** ../vim-7.2.179/src/tag.c	2009-05-15 21:31:11.000000000 +0200
--- src/tag.c	2009-05-16 22:16:31.000000000 +0200
***************
*** 100,106 ****
   * Tag for preview window is remembered separately, to avoid messing up the
   * normal tagstack.
   */
! static taggy_T ptag_entry = {NULL};
  #endif
  
  /*
--- 100,106 ----
   * Tag for preview window is remembered separately, to avoid messing up the
   * normal tagstack.
   */
! static taggy_T ptag_entry = {NULL, {INIT_POS_T(0, 0, 0), 0}, 0, 0};
  #endif
  
  /*
***************
*** 3791,3797 ****
  		--end;
  	}
  	len = (int)(end - start);
! 	if (len > sizeof(buf) - 1)
  	    len = sizeof(buf) - 1;
  	vim_strncpy(buf, start, len);
      }
--- 3791,3797 ----
  		--end;
  	}
  	len = (int)(end - start);
! 	if (len > (int)sizeof(buf) - 1)
  	    len = sizeof(buf) - 1;
  	vim_strncpy(buf, start, len);
      }
*** ../vim-7.2.179/src/term.c	2009-01-22 18:32:55.000000000 +0100
--- src/term.c	2009-05-16 22:18:08.000000000 +0200
***************
*** 2906,2912 ****
      int	    i;
      int	    shift;
  
!     for (i = 1; i <= sizeof(long_u); i++)
      {
  	shift = 8 * (sizeof(long_u) - i);
  	dst[i - 1] = (char_u) ((val >> shift) & 0xff);
--- 2906,2912 ----
      int	    i;
      int	    shift;
  
!     for (i = 1; i <= (int)sizeof(long_u); i++)
      {
  	shift = 8 * (sizeof(long_u) - i);
  	dst[i - 1] = (char_u) ((val >> shift) & 0xff);
***************
*** 2937,2943 ****
      len = get_bytes_from_buf(buf, bytes, (int)sizeof(long_u));
      if (len != -1)
      {
! 	for (i = 0; i < sizeof(long_u); i++)
  	{
  	    shift = 8 * (sizeof(long_u) - 1 - i);
  	    *val += (long_u)bytes[i] << shift;
--- 2937,2943 ----
      len = get_bytes_from_buf(buf, bytes, (int)sizeof(long_u));
      if (len != -1)
      {
! 	for (i = 0; i < (int)sizeof(long_u); i++)
  	{
  	    shift = 8 * (sizeof(long_u) - 1 - i);
  	    *val += (long_u)bytes[i] << shift;
*** ../vim-7.2.179/src/ui.c	2008-11-28 21:26:50.000000000 +0100
--- src/ui.c	2009-05-16 22:33:55.000000000 +0200
***************
*** 320,329 ****
   * The gui_set_shellsize() or mch_set_shellsize() function will try to set the
   * new size.  If this is not possible, it will adjust Rows and Columns.
   */
- /*ARGSUSED*/
      void
  ui_set_shellsize(mustset)
!     int		mustset;	/* set by the user */
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
--- 320,328 ----
   * The gui_set_shellsize() or mch_set_shellsize() function will try to set the
   * new size.  If this is not possible, it will adjust Rows and Columns.
   */
      void
  ui_set_shellsize(mustset)
!     int		mustset UNUSED;	/* set by the user */
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 1127,1136 ****
   * available for pasting.
   * When "both" is TRUE also copy to the '+' register.
   */
- /*ARGSUSED*/
      void
  clip_copy_modeless_selection(both)
!     int		both;
  {
      char_u	*buffer;
      char_u	*bufp;
--- 1126,1134 ----
   * available for pasting.
   * When "both" is TRUE also copy to the '+' register.
   */
      void
  clip_copy_modeless_selection(both)
!     int		both UNUSED;
  {
      char_u	*buffer;
      char_u	*bufp;
***************
*** 1701,1710 ****
      return (int)maxlen;
  }
  
- /*ARGSUSED*/
      void
  fill_input_buf(exit_on_error)
!     int	exit_on_error;
  {
  #if defined(UNIX) || defined(OS2) || defined(VMS) || defined(MACOS_X_UNIX)
      int		len;
--- 1699,1707 ----
      return (int)maxlen;
  }
  
      void
  fill_input_buf(exit_on_error)
!     int	exit_on_error UNUSED;
  {
  #if defined(UNIX) || defined(OS2) || defined(VMS) || defined(MACOS_X_UNIX)
      int		len;
***************
*** 1992,2002 ****
  
  static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
  
- /* ARGSUSED */
      static void
  clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,
  			      format)
!     Widget	w;
      XtPointer	success;
      Atom	*sel_atom;
      Atom	*type;
--- 1989,1998 ----
  
  static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
  
      static void
  clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,
  			      format)
!     Widget	w UNUSED;
      XtPointer	success;
      Atom	*sel_atom;
      Atom	*type;
***************
*** 2202,2211 ****
  
  static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
  
- /* ARGSUSED */
      static Boolean
  clip_x11_convert_selection_cb(w, sel_atom, target, type, value, length, format)
!     Widget	w;
      Atom	*sel_atom;
      Atom	*target;
      Atom	*type;
--- 2198,2206 ----
  
  static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
  
      static Boolean
  clip_x11_convert_selection_cb(w, sel_atom, target, type, value, length, format)
!     Widget	w UNUSED;
      Atom	*sel_atom;
      Atom	*target;
      Atom	*type;
***************
*** 2332,2341 ****
  
  static void  clip_x11_lose_ownership_cb __ARGS((Widget, Atom *));
  
- /* ARGSUSED */
      static void
  clip_x11_lose_ownership_cb(w, sel_atom)
!     Widget  w;
      Atom    *sel_atom;
  {
      if (*sel_atom == clip_plus.sel_atom)
--- 2327,2335 ----
  
  static void  clip_x11_lose_ownership_cb __ARGS((Widget, Atom *));
  
      static void
  clip_x11_lose_ownership_cb(w, sel_atom)
!     Widget  w UNUSED;
      Atom    *sel_atom;
  {
      if (*sel_atom == clip_plus.sel_atom)
***************
*** 2368,2377 ****
   * Send the current selection to the clipboard.  Do nothing for X because we
   * will fill in the selection only when requested by another app.
   */
- /*ARGSUSED*/
      void
  clip_x11_set_selection(cbd)
!     VimClipboard *cbd;
  {
  }
  #endif
--- 2362,2370 ----
   * Send the current selection to the clipboard.  Do nothing for X because we
   * will fill in the selection only when requested by another app.
   */
      void
  clip_x11_set_selection(cbd)
!     VimClipboard *cbd UNUSED;
  {
  }
  #endif
***************
*** 2922,2932 ****
   * Find the window at screen position "*rowp" and "*colp".  The positions are
   * updated to become relative to the top-left of the window.
   */
- /*ARGSUSED*/
      win_T *
  mouse_find_win(rowp, colp)
      int		*rowp;
!     int		*colp;
  {
      frame_T	*fp;
  
--- 2915,2924 ----
   * Find the window at screen position "*rowp" and "*colp".  The positions are
   * updated to become relative to the top-left of the window.
   */
      win_T *
  mouse_find_win(rowp, colp)
      int		*rowp;
!     int		*colp UNUSED;
  {
      frame_T	*fp;
  
*** ../vim-7.2.179/src/version.c	2009-05-16 21:16:12.000000000 +0200
--- src/version.c	2009-05-17 13:06:38.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     180,
  /**/

-- 
Wi n0t trei a h0liday in Sweden thi yer?
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.181
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.181
Problem:    Some more compiler warnings when using gcc -Wextra.
Solution:   Add UNUSED and type casts.
Files:	    src/if_mzsch.c, src/gui.c, src/gui_gtk.c, src/gui_gtk_x11.c,
	    src/gui_gtk_f.c, src/gui_beval.c, src/netbeans.c


*** ../vim-7.2.180/src/if_mzsch.c	2007-07-06 19:43:08.000000000 +0200
--- src/if_mzsch.c	2009-05-16 22:24:18.000000000 +0200
***************
*** 667,679 ****
      static void CALLBACK
  timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
  # elif defined(FEAT_GUI_GTK)
- /*ARGSUSED*/
      static gint
! timer_proc(gpointer data)
  # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
- /* ARGSUSED */
      static void
! timer_proc(XtPointer timed_out, XtIntervalId *interval_id)
  # elif defined(FEAT_GUI_MAC)
      pascal void
  timer_proc(EventLoopTimerRef theTimer, void *userData)
--- 667,677 ----
      static void CALLBACK
  timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
  # elif defined(FEAT_GUI_GTK)
      static gint
! timer_proc(gpointer data UNUSED)
  # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
      static void
! timer_proc(XtPointer timed_out UNUSED, XtIntervalId *interval_id UNUSED)
  # elif defined(FEAT_GUI_MAC)
      pascal void
  timer_proc(EventLoopTimerRef theTimer, void *userData)
*** ../vim-7.2.180/src/gui.c	2008-12-03 18:50:09.000000000 +0100
--- src/gui.c	2009-05-17 15:52:18.000000000 +0200
***************
*** 678,688 ****
   * Return OK when able to set the font.  When it failed FAIL is returned and
   * the fonts are unchanged.
   */
- /*ARGSUSED*/
      int
  gui_init_font(font_list, fontset)
      char_u	*font_list;
!     int		fontset;
  {
  #define FONTLEN 320
      char_u	font_name[FONTLEN];
--- 678,687 ----
   * Return OK when able to set the font.  When it failed FAIL is returned and
   * the fonts are unchanged.
   */
      int
  gui_init_font(font_list, fontset)
      char_u	*font_list;
!     int		fontset UNUSED;
  {
  #define FONTLEN 320
      char_u	font_name[FONTLEN];
***************
*** 1138,1147 ****
   * Position the various GUI components (text area, menu).  The vertical
   * scrollbars are NOT handled here.  See gui_update_scrollbars().
   */
- /*ARGSUSED*/
      static void
  gui_position_components(total_width)
!     int	    total_width;
  {
      int	    text_area_x;
      int	    text_area_y;
--- 1137,1145 ----
   * Position the various GUI components (text area, menu).  The vertical
   * scrollbars are NOT handled here.  See gui_update_scrollbars().
   */
      static void
  gui_position_components(total_width)
!     int	    total_width UNUSED;
  {
      int	    text_area_x;
      int	    text_area_y;
***************
*** 1374,1383 ****
   * If "fit_to_display" is TRUE then the size may be reduced to fit the window
   * on the screen.
   */
- /*ARGSUSED*/
      void
  gui_set_shellsize(mustset, fit_to_display, direction)
!     int		mustset;		/* set by the user */
      int		fit_to_display;
      int		direction;		/* RESIZE_HOR, RESIZE_VER */
  {
--- 1372,1380 ----
   * If "fit_to_display" is TRUE then the size may be reduced to fit the window
   * on the screen.
   */
      void
  gui_set_shellsize(mustset, fit_to_display, direction)
!     int		mustset UNUSED;		/* set by the user */
      int		fit_to_display;
      int		direction;		/* RESIZE_HOR, RESIZE_VER */
  {
***************
*** 3120,3126 ****
   * If "oldval" is not NULL, "oldval" is the previous value, the new value is
   * in p_go.
   */
- /*ARGSUSED*/
      void
  gui_init_which_components(oldval)
      char_u	*oldval;
--- 3117,3122 ----
***************
*** 4411,4417 ****
      if (curwin->w_p_wrap)
  	return FALSE;
  
!     if (curwin->w_leftcol == scrollbar_value)
  	return FALSE;
  
      curwin->w_leftcol = (colnr_T)scrollbar_value;
--- 4407,4413 ----
      if (curwin->w_p_wrap)
  	return FALSE;
  
!     if ((long_u)curwin->w_leftcol == scrollbar_value)
  	return FALSE;
  
      curwin->w_leftcol = (colnr_T)scrollbar_value;
***************
*** 4424,4430 ****
  	    && longest_lnum < curwin->w_botline
  	    && !virtual_active())
      {
! 	if (scrollbar_value > scroll_line_len(curwin->w_cursor.lnum))
  	{
  	    curwin->w_cursor.lnum = longest_lnum;
  	    curwin->w_cursor.col = 0;
--- 4420,4426 ----
  	    && longest_lnum < curwin->w_botline
  	    && !virtual_active())
      {
! 	if (scrollbar_value > (long_u)scroll_line_len(curwin->w_cursor.lnum))
  	{
  	    curwin->w_cursor.lnum = longest_lnum;
  	    curwin->w_cursor.col = 0;
***************
*** 4670,4676 ****
  /*
   * Find window where the mouse pointer "y" coordinate is in.
   */
- /*ARGSUSED*/
      static win_T *
  xy2win(x, y)
      int		x;
--- 4666,4671 ----
***************
*** 5124,5130 ****
   * of dropped files, they will be freed in this function, and caller can't use
   * fnames after call this function.
   */
- /*ARGSUSED*/
      void
  gui_handle_drop(x, y, modifiers, fnames, count)
      int		x;
--- 5119,5124 ----
*** ../vim-7.2.180/src/gui_gtk.c	2008-07-31 22:29:28.000000000 +0200
--- src/gui_gtk.c	2009-05-17 16:06:30.000000000 +0200
***************
*** 285,298 ****
      return image;
  }
  
- /*ARGSUSED*/
      static gint
! toolbar_button_focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
! {
!     /* When we're in a GtkPlug, we don't have window focus events, only widget focus.
!      * To emulate stand-alone gvim, if a button gets focus (e.g., <Tab> into GtkPlug)
!      * immediately pass it to mainwin.
!      */
      if (gtk_socket_id != 0)
  	gtk_widget_grab_focus(gui.drawarea);
  
--- 285,298 ----
      return image;
  }
  
      static gint
! toolbar_button_focus_in_event(GtkWidget *widget UNUSED,
! 			      GdkEventFocus *event UNUSED,
! 			      gpointer data UNUSED)
! {
!     /* When we're in a GtkPlug, we don't have window focus events, only widget
!      * focus.  To emulate stand-alone gvim, if a button gets focus (e.g.,
!      * <Tab> into GtkPlug) immediately pass it to mainwin. */
      if (gtk_socket_id != 0)
  	gtk_widget_grab_focus(gui.drawarea);
  
***************
*** 585,593 ****
      gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
  }
  
- /*ARGSUSED*/
      static void
! menu_item_activate(GtkWidget *widget, gpointer data)
  {
      gui_menu_cb((vimmenu_T *)data);
  
--- 585,592 ----
      gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
  }
  
      static void
! menu_item_activate(GtkWidget *widget UNUSED, gpointer data)
  {
      gui_menu_cb((vimmenu_T *)data);
  
***************
*** 1202,1210 ****
  #endif
  
  #ifndef USE_FILE_CHOOSER
- /*ARGSUSED*/
      static void
! browse_ok_cb(GtkWidget *widget, gpointer cbdata)
  {
      gui_T *vw = (gui_T *)cbdata;
  
--- 1201,1208 ----
  #endif
  
  #ifndef USE_FILE_CHOOSER
      static void
! browse_ok_cb(GtkWidget *widget UNUSED, gpointer cbdata)
  {
      gui_T *vw = (gui_T *)cbdata;
  
***************
*** 1218,1226 ****
  	gtk_main_quit();
  }
  
- /*ARGSUSED*/
      static void
! browse_cancel_cb(GtkWidget *widget, gpointer cbdata)
  {
      gui_T *vw = (gui_T *)cbdata;
  
--- 1216,1223 ----
  	gtk_main_quit();
  }
  
      static void
! browse_cancel_cb(GtkWidget *widget UNUSED, gpointer cbdata)
  {
      gui_T *vw = (gui_T *)cbdata;
  
***************
*** 1234,1242 ****
  	gtk_main_quit();
  }
  
- /*ARGSUSED*/
      static gboolean
! browse_destroy_cb(GtkWidget * widget)
  {
      if (gui.browse_fname != NULL)
      {
--- 1231,1238 ----
  	gtk_main_quit();
  }
  
      static gboolean
! browse_destroy_cb(GtkWidget *widget UNUSED)
  {
      if (gui.browse_fname != NULL)
      {
***************
*** 1262,1275 ****
   * initdir			initial directory, NULL for current dir
   * filter			not used (file name filter)
   */
- /*ARGSUSED*/
      char_u *
! gui_mch_browse(int saving,
  	       char_u *title,
  	       char_u *dflt,
! 	       char_u *ext,
  	       char_u *initdir,
! 	       char_u *filter)
  {
  #ifdef USE_FILE_CHOOSER
      GtkWidget		*fc;
--- 1258,1270 ----
   * initdir			initial directory, NULL for current dir
   * filter			not used (file name filter)
   */
      char_u *
! gui_mch_browse(int saving UNUSED,
  	       char_u *title,
  	       char_u *dflt,
! 	       char_u *ext UNUSED,
  	       char_u *initdir,
! 	       char_u *filter UNUSED)
  {
  #ifdef USE_FILE_CHOOSER
      GtkWidget		*fc;
***************
*** 1377,1383 ****
   * dflt				default name
   * initdir			initial directory, NULL for current dir
   */
- /*ARGSUSED*/
      char_u *
  gui_mch_browsedir(
  	       char_u *title,
--- 1372,1377 ----
***************
*** 1460,1466 ****
  }
  
  # ifdef FEAT_GUI_GNOME
- /* ARGSUSED */
      static int
  gui_gnome_dialog( int	type,
  		char_u	*title,
--- 1454,1459 ----
***************
*** 1611,1617 ****
      GtkWidget	*dialog;
  } CancelData;
  
- /* ARGSUSED */
      static void
  dlg_button_clicked(GtkWidget * widget, ButtonData *data)
  {
--- 1604,1609 ----
***************
*** 1622,1628 ****
  /*
   * This makes the Escape key equivalent to the cancel button.
   */
- /*ARGSUSED*/
      static int
  dlg_key_press_event(GtkWidget *widget, GdkEventKey *event, CancelData *data)
  {
--- 1614,1619 ----
***************
*** 1655,1661 ****
  	gtk_main_quit();
  }
  
- /* ARGSUSED */
      int
  gui_mch_dialog(	int	type,		/* type of dialog */
  		char_u	*title,		/* title of dialog */
--- 1646,1651 ----
***************
*** 2215,2221 ****
      GtkDialog	*dialog;	    /* Widget of the dialog */
  } DialogInfo;
  
- /*ARGSUSED2*/
      static gboolean
  dialog_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)
  {
--- 2205,2210 ----
***************
*** 2398,2411 ****
   * Note: The push_in output argument seems to affect scrolling of huge
   * menus that don't fit on the screen.	Leave it at the default for now.
   */
- /*ARGSUSED0*/
      static void
! popup_menu_position_func(GtkMenu *menu,
  			 gint *x, gint *y,
  # ifdef HAVE_GTK2
! 			 gboolean *push_in,
  # endif
! 			 gpointer user_data)
  {
      gdk_window_get_origin(gui.drawarea->window, x, y);
  
--- 2387,2399 ----
   * Note: The push_in output argument seems to affect scrolling of huge
   * menus that don't fit on the screen.	Leave it at the default for now.
   */
      static void
! popup_menu_position_func(GtkMenu *menu UNUSED,
  			 gint *x, gint *y,
  # ifdef HAVE_GTK2
! 			 gboolean *push_in UNUSED,
  # endif
! 			 gpointer user_data UNUSED)
  {
      gdk_window_get_origin(gui.drawarea->window, x, y);
  
***************
*** 2464,2476 ****
      GtkWidget *all;	/* 'Replace All' action button */
  } SharedFindReplace;
  
! static SharedFindReplace find_widgets = { NULL, };
! static SharedFindReplace repl_widgets = { NULL, };
  
- /* ARGSUSED */
      static int
  find_key_press_event(
! 		GtkWidget	*widget,
  		GdkEventKey	*event,
  		SharedFindReplace *frdp)
  {
--- 2452,2463 ----
      GtkWidget *all;	/* 'Replace All' action button */
  } SharedFindReplace;
  
! static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
! static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
  
      static int
  find_key_press_event(
! 		GtkWidget	*widget UNUSED,
  		GdkEventKey	*event,
  		SharedFindReplace *frdp)
  {
***************
*** 2962,2970 ****
  /*
   * Callback for actions of the find and replace dialogs
   */
- /*ARGSUSED*/
      static void
! find_replace_cb(GtkWidget *widget, gpointer data)
  {
      int			flags;
      char_u		*find_text;
--- 2949,2956 ----
  /*
   * Callback for actions of the find and replace dialogs
   */
      static void
! find_replace_cb(GtkWidget *widget UNUSED, gpointer data)
  {
      int			flags;
      char_u		*find_text;
***************
*** 3010,3018 ****
  }
  
  /* our usual callback function */
- /*ARGSUSED*/
      static void
! entry_activate_cb(GtkWidget *widget, gpointer data)
  {
      gtk_widget_grab_focus(GTK_WIDGET(data));
  }
--- 2996,3003 ----
  }
  
  /* our usual callback function */
      static void
! entry_activate_cb(GtkWidget *widget UNUSED, gpointer data)
  {
      gtk_widget_grab_focus(GTK_WIDGET(data));
  }
***************
*** 3055,3064 ****
  /*
   * ":helpfind"
   */
- /*ARGSUSED*/
      void
  ex_helpfind(eap)
!     exarg_T	*eap;
  {
      /* This will fail when menus are not loaded.  Well, it's only for
       * backwards compatibility anyway. */
--- 3040,3048 ----
  /*
   * ":helpfind"
   */
      void
  ex_helpfind(eap)
!     exarg_T	*eap UNUSED;
  {
      /* This will fail when menus are not loaded.  Well, it's only for
       * backwards compatibility anyway. */
*** ../vim-7.2.180/src/gui_gtk_x11.c	2008-11-28 21:26:50.000000000 +0100
--- src/gui_gtk_x11.c	2009-05-17 15:53:02.000000000 +0200
***************
*** 619,627 ****
   * Doesn't seem possible, since check_copy_area() relies on
   * this information.  --danielk
   */
- /*ARGSUSED*/
      static gint
! visibility_event(GtkWidget *widget, GdkEventVisibility *event, gpointer data)
  {
      gui.visibility = event->state;
      /*
--- 625,634 ----
   * Doesn't seem possible, since check_copy_area() relies on
   * this information.  --danielk
   */
      static gint
! visibility_event(GtkWidget *widget UNUSED,
! 		 GdkEventVisibility *event,
! 		 gpointer data UNUSED)
  {
      gui.visibility = event->state;
      /*
***************
*** 638,646 ****
  /*
   * Redraw the corresponding portions of the screen.
   */
- /*ARGSUSED*/
      static gint
! expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)
  {
      /* Skip this when the GUI isn't set up yet, will redraw later. */
      if (gui.starting)
--- 645,654 ----
  /*
   * Redraw the corresponding portions of the screen.
   */
      static gint
! expose_event(GtkWidget *widget UNUSED,
! 	     GdkEventExpose *event,
! 	     gpointer data UNUSED)
  {
      /* Skip this when the GUI isn't set up yet, will redraw later. */
      if (gui.starting)
***************
*** 668,676 ****
  /*
   * Handle changes to the "Comm" property
   */
- /*ARGSUSED2*/
      static gint
! property_event(GtkWidget *widget, GdkEventProperty *event, gpointer data)
  {
      if (event->type == GDK_PROPERTY_NOTIFY
  	    && event->state == (int)GDK_PROPERTY_NEW_VALUE
--- 676,685 ----
  /*
   * Handle changes to the "Comm" property
   */
      static gint
! property_event(GtkWidget *widget,
! 	       GdkEventProperty *event,
! 	       gpointer data UNUSED)
  {
      if (event->type == GDK_PROPERTY_NOTIFY
  	    && event->state == (int)GDK_PROPERTY_NEW_VALUE
***************
*** 740,748 ****
      blink_state = BLINK_NONE;
  }
  
- /*ARGSUSED*/
      static gint
! blink_cb(gpointer data)
  {
      if (blink_state == BLINK_ON)
      {
--- 749,756 ----
      blink_state = BLINK_NONE;
  }
  
      static gint
! blink_cb(gpointer data UNUSED)
  {
      if (blink_state == BLINK_ON)
      {
***************
*** 781,789 ****
      }
  }
  
- /*ARGSUSED*/
      static gint
! enter_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
  {
      if (blink_state == BLINK_NONE)
  	gui_mch_start_blink();
--- 789,798 ----
      }
  }
  
      static gint
! enter_notify_event(GtkWidget *widget UNUSED,
! 		   GdkEventCrossing *event UNUSED,
! 		   gpointer data UNUSED)
  {
      if (blink_state == BLINK_NONE)
  	gui_mch_start_blink();
***************
*** 795,803 ****
      return FALSE;
  }
  
- /*ARGSUSED*/
      static gint
! leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
  {
      if (blink_state != BLINK_NONE)
  	gui_mch_stop_blink();
--- 804,813 ----
      return FALSE;
  }
  
      static gint
! leave_notify_event(GtkWidget *widget UNUSED,
! 		   GdkEventCrossing *event UNUSED,
! 		   gpointer data UNUSED)
  {
      if (blink_state != BLINK_NONE)
  	gui_mch_stop_blink();
***************
*** 805,813 ****
      return FALSE;
  }
  
- /*ARGSUSED*/
      static gint
! focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
  {
      gui_focus_change(TRUE);
  
--- 815,824 ----
      return FALSE;
  }
  
      static gint
! focus_in_event(GtkWidget *widget,
! 	       GdkEventFocus *event UNUSED,
! 	       gpointer data UNUSED)
  {
      gui_focus_change(TRUE);
  
***************
*** 826,834 ****
      return TRUE;
  }
  
- /*ARGSUSED*/
      static gint
! focus_out_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
  {
      gui_focus_change(FALSE);
  
--- 837,846 ----
      return TRUE;
  }
  
      static gint
! focus_out_event(GtkWidget *widget UNUSED,
! 	        GdkEventFocus *event UNUSED,
! 		gpointer data UNUSED)
  {
      gui_focus_change(FALSE);
  
***************
*** 956,964 ****
  /*
   * Main keyboard handler:
   */
- /*ARGSUSED*/
      static gint
! key_press_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
  {
  #ifdef HAVE_GTK2
      /* 256 bytes is way over the top, but for safety let's reduce it only
--- 968,977 ----
  /*
   * Main keyboard handler:
   */
      static gint
! key_press_event(GtkWidget *widget UNUSED,
! 		GdkEventKey *event,
! 		gpointer data UNUSED)
  {
  #ifdef HAVE_GTK2
      /* 256 bytes is way over the top, but for safety let's reduce it only
***************
*** 1225,1233 ****
  }
  
  #if defined(FEAT_XIM) && defined(HAVE_GTK2)
- /*ARGSUSED0*/
      static gboolean
! key_release_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
  {
      /*
       * GTK+ 2 input methods may do fancy stuff on key release events too.
--- 1238,1247 ----
  }
  
  #if defined(FEAT_XIM) && defined(HAVE_GTK2)
      static gboolean
! key_release_event(GtkWidget *widget UNUSED,
! 		  GdkEventKey *event,
! 		  gpointer data UNUSED)
  {
      /*
       * GTK+ 2 input methods may do fancy stuff on key release events too.
***************
*** 1243,1253 ****
   * Selection handlers:
   */
  
- /*ARGSUSED*/
      static gint
! selection_clear_event(GtkWidget		*widget,
  		      GdkEventSelection	*event,
! 		      gpointer		user_data)
  {
      if (event->selection == clip_plus.gtk_sel_atom)
  	clip_lose_selection(&clip_plus);
--- 1257,1266 ----
   * Selection handlers:
   */
  
      static gint
! selection_clear_event(GtkWidget		*widget UNUSED,
  		      GdkEventSelection	*event,
! 		      gpointer		user_data UNUSED)
  {
      if (event->selection == clip_plus.gtk_sel_atom)
  	clip_lose_selection(&clip_plus);
***************
*** 1265,1276 ****
  #define RS_FAIL	2	/* selection_received_cb() called and failed */
  static int received_selection = RS_NONE;
  
- /*ARGSUSED*/
      static void
! selection_received_cb(GtkWidget		*widget,
  		      GtkSelectionData	*data,
! 		      guint		time_,
! 		      gpointer		user_data)
  {
      VimClipboard    *cbd;
      char_u	    *text;
--- 1278,1288 ----
  #define RS_FAIL	2	/* selection_received_cb() called and failed */
  static int received_selection = RS_NONE;
  
      static void
! selection_received_cb(GtkWidget		*widget UNUSED,
  		      GtkSelectionData	*data,
! 		      guint		time_ UNUSED,
! 		      gpointer		user_data UNUSED)
  {
      VimClipboard    *cbd;
      char_u	    *text;
***************
*** 1414,1426 ****
   * Prepare our selection data for passing it to the external selection
   * client.
   */
- /*ARGSUSED*/
      static void
! selection_get_cb(GtkWidget	    *widget,
  		 GtkSelectionData   *selection_data,
  		 guint		    info,
! 		 guint		    time_,
! 		 gpointer	    user_data)
  {
      char_u	    *string;
      char_u	    *tmpbuf;
--- 1426,1437 ----
   * Prepare our selection data for passing it to the external selection
   * client.
   */
      static void
! selection_get_cb(GtkWidget	    *widget UNUSED,
  		 GtkSelectionData   *selection_data,
  		 guint		    info,
! 		 guint		    time_ UNUSED,
! 		 gpointer	    user_data UNUSED)
  {
      char_u	    *string;
      char_u	    *tmpbuf;
***************
*** 1678,1684 ****
  
  	offshoot = dx > dy ? dx : dy;
  
! 	/* Make a linearly declaying timer delay with a threshold of 5 at a
  	 * distance of 127 pixels from the main window.
  	 *
  	 * One could think endlessly about the most ergonomic variant here.
--- 1689,1695 ----
  
  	offshoot = dx > dy ? dx : dy;
  
! 	/* Make a linearly decaying timer delay with a threshold of 5 at a
  	 * distance of 127 pixels from the main window.
  	 *
  	 * One could think endlessly about the most ergonomic variant here.
***************
*** 1707,1715 ****
  /*
   * Timer used to recognize multiple clicks of the mouse button.
   */
- /*ARGSUSED0*/
      static gint
! motion_repeat_timer_cb(gpointer data)
  {
      int		    x;
      int		    y;
--- 1718,1725 ----
  /*
   * Timer used to recognize multiple clicks of the mouse button.
   */
      static gint
! motion_repeat_timer_cb(gpointer data UNUSED)
  {
      int		    x;
      int		    y;
***************
*** 1749,1757 ****
      return FALSE;
  }
  
- /*ARGSUSED2*/
      static gint
! motion_notify_event(GtkWidget *widget, GdkEventMotion *event, gpointer data)
  {
      if (event->is_hint)
      {
--- 1759,1768 ----
      return FALSE;
  }
  
      static gint
! motion_notify_event(GtkWidget *widget,
! 		    GdkEventMotion *event,
! 		    gpointer data UNUSED)
  {
      if (event->is_hint)
      {
***************
*** 1777,1785 ****
   * by our own timeout mechanism instead of the one provided by GTK+ itself.
   * This is due to the way the generic VIM code is recognizing multiple clicks.
   */
- /*ARGSUSED2*/
      static gint
! button_press_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
  {
      int button;
      int repeated_click = FALSE;
--- 1788,1797 ----
   * by our own timeout mechanism instead of the one provided by GTK+ itself.
   * This is due to the way the generic VIM code is recognizing multiple clicks.
   */
      static gint
! button_press_event(GtkWidget *widget,
! 		   GdkEventButton *event,
! 		   gpointer data UNUSED)
  {
      int button;
      int repeated_click = FALSE;
***************
*** 1855,1863 ****
   * GTK+ 2 doesn't handle mouse buttons 4, 5, 6 and 7 the same way as GTK+ 1.
   * Instead, it abstracts scrolling via the new GdkEventScroll.
   */
- /*ARGSUSED2*/
      static gboolean
! scroll_event(GtkWidget *widget, GdkEventScroll *event, gpointer data)
  {
      int	    button;
      int_u   vim_modifiers;
--- 1867,1876 ----
   * GTK+ 2 doesn't handle mouse buttons 4, 5, 6 and 7 the same way as GTK+ 1.
   * Instead, it abstracts scrolling via the new GdkEventScroll.
   */
      static gboolean
! scroll_event(GtkWidget *widget,
! 	     GdkEventScroll *event,
! 	     gpointer data UNUSED)
  {
      int	    button;
      int_u   vim_modifiers;
***************
*** 1896,1904 ****
  #endif /* HAVE_GTK2 */
  
  
- /*ARGSUSED*/
      static gint
! button_release_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
  {
      int x, y;
      int_u vim_modifiers;
--- 1909,1918 ----
  #endif /* HAVE_GTK2 */
  
  
      static gint
! button_release_event(GtkWidget *widget UNUSED,
! 		     GdkEventButton *event,
! 		     gpointer data UNUSED)
  {
      int x, y;
      int_u vim_modifiers;
***************
*** 2100,2106 ****
  /*
   * DND receiver.
   */
- /*ARGSUSED2*/
      static void
  drag_data_received_cb(GtkWidget		*widget,
  		      GdkDragContext	*context,
--- 2114,2119 ----
***************
*** 2109,2115 ****
  		      GtkSelectionData	*data,
  		      guint		info,
  		      guint		time_,
! 		      gpointer		user_data)
  {
      GdkModifierType state;
  
--- 2122,2128 ----
  		      GtkSelectionData	*data,
  		      guint		info,
  		      guint		time_,
! 		      gpointer		user_data UNUSED)
  {
      GdkModifierType state;
  
***************
*** 2143,2149 ****
   * be abandoned and pop up a dialog asking the user for confirmation if
   * necessary.
   */
- /*ARGSUSED0*/
      static void
  sm_client_check_changed_any(GnomeClient	    *client,
  			    gint	    key,
--- 2156,2161 ----
***************
*** 2251,2257 ****
   * for confirmation if necessary.  Save the current editing session and tell
   * the session manager how to restart Vim.
   */
- /*ARGSUSED1*/
      static gboolean
  sm_client_save_yourself(GnomeClient	    *client,
  			gint		    phase,
--- 2263,2268 ----
***************
*** 2339,2345 ****
   * here since "save_yourself" has been emitted before (unless serious trouble
   * is happening).
   */
- /*ARGSUSED0*/
      static void
  sm_client_die(GnomeClient *client, gpointer data)
  {
--- 2350,2355 ----
***************
*** 2379,2388 ****
  /*
   * GTK tells us that XSMP needs attention
   */
- /*ARGSUSED*/
      static gboolean
  local_xsmp_handle_requests(source, condition, data)
!     GIOChannel		*source;
      GIOCondition	condition;
      gpointer		data;
  {
--- 2389,2397 ----
  /*
   * GTK tells us that XSMP needs attention
   */
      static gboolean
  local_xsmp_handle_requests(source, condition, data)
!     GIOChannel		*source UNUSED;
      GIOCondition	condition;
      gpointer		data;
  {
***************
*** 2480,2495 ****
   * WM_SAVE_YOURSELF hack it actually stores the session...  And yes,
   * it should work with KDE as well.
   */
- /*ARGSUSED1*/
      static GdkFilterReturn
! global_event_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
  {
      XEvent *xevent = (XEvent *)xev;
  
      if (xevent != NULL
  	    && xevent->type == ClientMessage
  	    && xevent->xclient.message_type == GET_X_ATOM(wm_protocols_atom)
! 	    && xevent->xclient.data.l[0] == GET_X_ATOM(save_yourself_atom))
      {
  	out_flush();
  	ml_sync_all(FALSE, FALSE); /* preserve all swap files */
--- 2489,2506 ----
   * WM_SAVE_YOURSELF hack it actually stores the session...  And yes,
   * it should work with KDE as well.
   */
      static GdkFilterReturn
! global_event_filter(GdkXEvent *xev,
! 		    GdkEvent *event UNUSED,
! 		    gpointer data UNUSED)
  {
      XEvent *xevent = (XEvent *)xev;
  
      if (xevent != NULL
  	    && xevent->type == ClientMessage
  	    && xevent->xclient.message_type == GET_X_ATOM(wm_protocols_atom)
! 	    && (long_u)xevent->xclient.data.l[0]
! 					    == GET_X_ATOM(save_yourself_atom))
      {
  	out_flush();
  	ml_sync_all(FALSE, FALSE); /* preserve all swap files */
***************
*** 2512,2518 ****
  /*
   * GDK handler for X ClientMessage events.
   */
- /*ARGSUSED2*/
      static GdkFilterReturn
  gdk_wm_protocols_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
  {
--- 2523,2528 ----
***************
*** 2558,2566 ****
  /*
   * Setup the window icon & xcmdsrv comm after the main window has been realized.
   */
- /*ARGSUSED*/
      static void
! mainwin_realize(GtkWidget *widget, gpointer data)
  {
  /* If you get an error message here, you still need to unpack the runtime
   * archive! */
--- 2568,2575 ----
  /*
   * Setup the window icon & xcmdsrv comm after the main window has been realized.
   */
      static void
! mainwin_realize(GtkWidget *widget UNUSED, gpointer data UNUSED)
  {
  /* If you get an error message here, you still need to unpack the runtime
   * archive! */
***************
*** 2712,2722 ****
  }
  
  #ifdef HAVE_GTK_MULTIHEAD
- /*ARGSUSED1*/
      static void
  mainwin_screen_changed_cb(GtkWidget  *widget,
! 			  GdkScreen  *previous_screen,
! 			  gpointer   data)
  {
      if (!gtk_widget_has_screen(widget))
  	return;
--- 2721,2730 ----
  }
  
  #ifdef HAVE_GTK_MULTIHEAD
      static void
  mainwin_screen_changed_cb(GtkWidget  *widget,
! 			  GdkScreen  *previous_screen UNUSED,
! 			  gpointer   data UNUSED)
  {
      if (!gtk_widget_has_screen(widget))
  	return;
***************
*** 2757,2765 ****
   * Don't try to set any VIM scrollbar sizes anywhere here. I'm relying on the
   * fact that the main VIM engine doesn't take them into account anywhere.
   */
- /*ARGSUSED1*/
      static void
! drawarea_realize_cb(GtkWidget *widget, gpointer data)
  {
      GtkWidget *sbar;
  
--- 2765,2772 ----
   * Don't try to set any VIM scrollbar sizes anywhere here. I'm relying on the
   * fact that the main VIM engine doesn't take them into account anywhere.
   */
      static void
! drawarea_realize_cb(GtkWidget *widget, gpointer data UNUSED)
  {
      GtkWidget *sbar;
  
***************
*** 2789,2797 ****
  /*
   * Properly clean up on shutdown.
   */
- /*ARGSUSED0*/
      static void
! drawarea_unrealize_cb(GtkWidget *widget, gpointer data)
  {
      /* Don't write messages to the GUI anymore */
      full_screen = FALSE;
--- 2796,2803 ----
  /*
   * Properly clean up on shutdown.
   */
      static void
! drawarea_unrealize_cb(GtkWidget *widget UNUSED, gpointer data UNUSED)
  {
      /* Don't write messages to the GUI anymore */
      full_screen = FALSE;
***************
*** 2827,2837 ****
  #endif
  }
  
- /*ARGSUSED0*/
      static void
! drawarea_style_set_cb(GtkWidget	*widget,
! 		      GtkStyle	*previous_style,
! 		      gpointer	data)
  {
      gui_mch_new_colors();
  }
--- 2833,2842 ----
  #endif
  }
  
      static void
! drawarea_style_set_cb(GtkWidget	*widget UNUSED,
! 		      GtkStyle	*previous_style UNUSED,
! 		      gpointer	data UNUSED)
  {
      gui_mch_new_colors();
  }
***************
*** 2840,2848 ****
   * Callback routine for the "delete_event" signal on the toplevel window.
   * Tries to vim gracefully, or refuses to exit with changed buffers.
   */
- /*ARGSUSED*/
      static gint
! delete_event_cb(GtkWidget *widget, GdkEventAny *event, gpointer data)
  {
      gui_shell_closed();
      return TRUE;
--- 2845,2854 ----
   * Callback routine for the "delete_event" signal on the toplevel window.
   * Tries to vim gracefully, or refuses to exit with changed buffers.
   */
      static gint
! delete_event_cb(GtkWidget *widget UNUSED,
! 		GdkEventAny *event UNUSED,
! 		gpointer data UNUSED)
  {
      gui_shell_closed();
      return TRUE;
***************
*** 2964,2970 ****
  
      /* At start-up, don't try to set the hints until the initial
       * values have been used (those that dictate our initial size)
!      * Let forced (i.e., correct) values thruogh always.
       */
      if (!(force_width && force_height)  &&  init_window_hints_state > 0)
      {
--- 2970,2976 ----
  
      /* At start-up, don't try to set the hints until the initial
       * values have been used (those that dictate our initial size)
!      * Let forced (i.e., correct) values through always.
       */
      if (!(force_width && force_height)  &&  init_window_hints_state > 0)
      {
***************
*** 3142,3150 ****
  /*
   * Handle selecting an item in the tab line popup menu.
   */
- /*ARGSUSED*/
      static void
! tabline_menu_handler(GtkMenuItem *item, gpointer user_data)
  {
      /* Add the string cmd into input buffer */
      send_tabline_menu_event(clicked_page, (int)(long)user_data);
--- 3148,3155 ----
  /*
   * Handle selecting an item in the tab line popup menu.
   */
      static void
! tabline_menu_handler(GtkMenuItem *item UNUSED, gpointer user_data)
  {
      /* Add the string cmd into input buffer */
      send_tabline_menu_event(clicked_page, (int)(long)user_data);
***************
*** 3244,3256 ****
  /*
   * Handle selecting one of the tabs.
   */
- /*ARGSUSED*/
      static void
  on_select_tab(
! 	GtkNotebook	*notebook,
! 	GtkNotebookPage *page,
  	gint		idx,
! 	gpointer	data)
  {
      if (!ignore_tabline_evt)
      {
--- 3249,3260 ----
  /*
   * Handle selecting one of the tabs.
   */
      static void
  on_select_tab(
! 	GtkNotebook	*notebook UNUSED,
! 	GtkNotebookPage *page UNUSED,
  	gint		idx,
! 	gpointer	data UNUSED)
  {
      if (!ignore_tabline_evt)
      {
***************
*** 3784,3790 ****
  #endif
  
      if (gtk_socket_id != 0)
! 	/* make sure keybord input can go to the drawarea */
  	GTK_WIDGET_SET_FLAGS(gui.drawarea, GTK_CAN_FOCUS);
  
      /*
--- 3788,3794 ----
  #endif
  
      if (gtk_socket_id != 0)
! 	/* make sure keyboard input can go to the drawarea */
  	GTK_WIDGET_SET_FLAGS(gui.drawarea, GTK_CAN_FOCUS);
  
      /*
***************
*** 3922,3931 ****
  /*
   * This signal informs us about the need to rearrange our sub-widgets.
   */
- /*ARGSUSED*/
      static gint
! form_configure_event(GtkWidget *widget, GdkEventConfigure *event,
! 		     gpointer data)
  {
      int usable_height = event->height;
  
--- 3926,3935 ----
  /*
   * This signal informs us about the need to rearrange our sub-widgets.
   */
      static gint
! form_configure_event(GtkWidget *widget UNUSED,
! 		     GdkEventConfigure *event,
! 		     gpointer data UNUSED)
  {
      int usable_height = event->height;
  
***************
*** 3948,3956 ****
   * We can't do much more here than to trying to preserve what had been done,
   * since the window is already inevitably going away.
   */
- /*ARGSUSED0*/
      static void
! mainwin_destroy_cb(GtkObject *object, gpointer data)
  {
      /* Don't write messages to the GUI anymore */
      full_screen = FALSE;
--- 3952,3959 ----
   * We can't do much more here than to trying to preserve what had been done,
   * since the window is already inevitably going away.
   */
      static void
! mainwin_destroy_cb(GtkObject *object UNUSED, gpointer data UNUSED)
  {
      /* Don't write messages to the GUI anymore */
      full_screen = FALSE;
***************
*** 3980,3988 ****
   * scrollbar init.), actually do the standard hinst and stop the timer.
   * We'll not let the default hints be set while this timer's active.
   */
- /*ARGSUSED*/
      static gboolean
! check_startup_plug_hints(gpointer data)
  {
      if (init_window_hints_state == 1)
      {
--- 3983,3990 ----
   * scrollbar init.), actually do the standard hinst and stop the timer.
   * We'll not let the default hints be set while this timer's active.
   */
      static gboolean
! check_startup_plug_hints(gpointer data UNUSED)
  {
      if (init_window_hints_state == 1)
      {
***************
*** 4055,4061 ****
  	    Columns = w;
  	if (mask & HeightValue)
  	{
! 	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
  		p_window = h - 1;
  	    Rows = h;
  	}
--- 4057,4063 ----
  	    Columns = w;
  	if (mask & HeightValue)
  	{
! 	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
  		p_window = h - 1;
  	    Rows = h;
  	}
***************
*** 4229,4237 ****
  }
  
  
- /*ARGSUSED0*/
      void
! gui_mch_exit(int rc)
  {
      if (gui.mainwin != NULL)
  	gtk_widget_destroy(gui.mainwin);
--- 4231,4238 ----
  }
  
  
      void
! gui_mch_exit(int rc UNUSED)
  {
      if (gui.mainwin != NULL)
  	gtk_widget_destroy(gui.mainwin);
***************
*** 4286,4292 ****
   * report the new size through form_configure_event().  That caused the window
   * layout to be messed up.
   */
- /*ARGSUSED0*/
      static gboolean
  force_shell_resize_idle(gpointer data)
  {
--- 4287,4292 ----
***************
*** 4314,4325 ****
  /*
   * Set the windows size.
   */
- /*ARGSUSED2*/
      void
  gui_mch_set_shellsize(int width, int height,
! 		      int min_width,  int min_height,
! 		      int base_width, int base_height,
! 		      int direction)
  {
  #ifndef HAVE_GTK2
      /* Hack: When the form already is at the desired size, the window might
--- 4314,4324 ----
  /*
   * Set the windows size.
   */
      void
  gui_mch_set_shellsize(int width, int height,
! 		      int min_width UNUSED,  int min_height UNUSED,
! 		      int base_width UNUSED, int base_height UNUSED,
! 		      int direction UNUSED)
  {
  #ifndef HAVE_GTK2
      /* Hack: When the form already is at the desired size, the window might
***************
*** 4413,4421 ****
  }
  
  #if defined(FEAT_TITLE) || defined(PROTO)
- /*ARGSUSED*/
      void
! gui_mch_settitle(char_u *title, char_u *icon)
  {
  # ifdef HAVE_GTK2
      if (title != NULL && output_conv.vc_type != CONV_NONE)
--- 4412,4419 ----
  }
  
  #if defined(FEAT_TITLE) || defined(PROTO)
      void
! gui_mch_settitle(char_u *title, char_u *icon UNUSED)
  {
  # ifdef HAVE_GTK2
      if (title != NULL && output_conv.vc_type != CONV_NONE)
***************
*** 4493,4499 ****
   * Get a font structure for highlighting.
   * "cbdata" is a pointer to the global gui structure.
   */
- /*ARGSUSED*/
      static void
  font_sel_ok(GtkWidget *wgt, gpointer cbdata)
  {
--- 4491,4496 ----
***************
*** 4509,4515 ****
  	gtk_main_quit();
  }
  
- /*ARGSUSED*/
      static void
  font_sel_cancel(GtkWidget *wgt, gpointer cbdata)
  {
--- 4506,4511 ----
***************
*** 4520,4526 ****
  	gtk_main_quit();
  }
  
- /*ARGSUSED*/
      static void
  font_sel_destroy(GtkWidget *wgt, gpointer cbdata)
  {
--- 4516,4521 ----
***************
*** 4620,4626 ****
  /*
   * Try to load the requested fontset.
   */
- /*ARGSUSED2*/
      GuiFontset
  gui_mch_get_fontset(char_u *name, int report_error, int fixed_width)
  {
--- 4615,4620 ----
***************
*** 4863,4869 ****
      styled_font[1] = &gui.ital_font;
      styled_font[2] = &gui.boldital_font;
  
!     /* First free whatever was freviously there. */
      for (i = 0; i < 3; ++i)
  	if (*styled_font[i])
  	{
--- 4857,4863 ----
      styled_font[1] = &gui.ital_font;
      styled_font[2] = &gui.boldital_font;
  
!     /* First free whatever was previously there. */
      for (i = 0; i < 3; ++i)
  	if (*styled_font[i])
  	{
***************
*** 5012,5020 ****
   * Initialize Vim to use the font or fontset with the given name.
   * Return FAIL if the font could not be loaded, OK otherwise.
   */
- /*ARGSUSED1*/
      int
! gui_mch_init_font(char_u *font_name, int fontset)
  {
  #ifdef HAVE_GTK2
      PangoFontDescription    *font_desc;
--- 5006,5013 ----
   * Initialize Vim to use the font or fontset with the given name.
   * Return FAIL if the font could not be loaded, OK otherwise.
   */
      int
! gui_mch_init_font(char_u *font_name, int fontset UNUSED)
  {
  #ifdef HAVE_GTK2
      PangoFontDescription    *font_desc;
***************
*** 5326,5334 ****
  /*
   * Return the name of font "font" in allocated memory.
   */
- /*ARGSUSED*/
      char_u *
! gui_mch_get_fontname(GuiFont font, char_u *name)
  {
  # ifdef HAVE_GTK2
      if (font != NOFONT)
--- 5319,5326 ----
  /*
   * Return the name of font "font" in allocated memory.
   */
      char_u *
! gui_mch_get_fontname(GuiFont font, char_u *name UNUSED)
  {
  # ifdef HAVE_GTK2
      if (font != NOFONT)
***************
*** 5732,5738 ****
  {
      int			i;
      int			offset;
!     const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
      int			y = FILL_Y(row + 1) - 1;
  
      /* Undercurl: draw curl at the bottom of the character cell. */
--- 5724,5730 ----
  {
      int			i;
      int			offset;
!     static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
      int			y = FILL_Y(row + 1) - 1;
  
      /* Undercurl: draw curl at the bottom of the character cell. */
***************
*** 6402,6408 ****
  /*
   * Callback function, used when data is available on the SNiFF connection.
   */
- /* ARGSUSED */
      static void
  sniff_request_cb(
      gpointer	data,
--- 6394,6399 ----
***************
*** 6711,6719 ****
  /*
   * Disown the selection.
   */
- /*ARGSUSED*/
      void
! clip_mch_lose_selection(VimClipboard *cbd)
  {
      /* WEIRD: when using NULL to actually disown the selection, we lose the
       * selection the first time we own it. */
--- 6702,6709 ----
  /*
   * Disown the selection.
   */
      void
! clip_mch_lose_selection(VimClipboard *cbd UNUSED)
  {
      /* WEIRD: when using NULL to actually disown the selection, we lose the
       * selection the first time we own it. */
***************
*** 6741,6749 ****
   * Send the current selection to the clipboard.  Do nothing for X because we
   * will fill in the selection only when requested by another app.
   */
- /*ARGSUSED*/
      void
! clip_mch_set_selection(VimClipboard *cbd)
  {
  }
  
--- 6731,6738 ----
   * Send the current selection to the clipboard.  Do nothing for X because we
   * will fill in the selection only when requested by another app.
   */
      void
! clip_mch_set_selection(VimClipboard *cbd UNUSED)
  {
  }
  
***************
*** 6950,6956 ****
  	    else
  		id &= ~1;	/* they are always even (why?) */
  	}
! 	else if (shape < sizeof(mshape_ids) / sizeof(int))
  	    id = mshape_ids[shape];
  	else
  	    return;
--- 6939,6945 ----
  	    else
  		id &= ~1;	/* they are always even (why?) */
  	}
! 	else if (shape < (int)(sizeof(mshape_ids) / sizeof(int)))
  	    id = mshape_ids[shape];
  	else
  	    return;
*** ../vim-7.2.180/src/gui_gtk_f.c	2007-05-10 19:50:33.000000000 +0200
--- src/gui_gtk_f.c	2009-05-17 15:48:51.000000000 +0200
***************
*** 227,240 ****
  
      if (!form_type)
      {
! 	GtkTypeInfo form_info =
! 	{
! 	    "GtkForm",
! 	    sizeof(GtkForm),
! 	    sizeof(GtkFormClass),
! 	    (GtkClassInitFunc) gtk_form_class_init,
! 	    (GtkObjectInitFunc) gtk_form_init
! 	};
  
  	form_type = gtk_type_unique(GTK_TYPE_CONTAINER, &form_info);
      }
--- 227,239 ----
  
      if (!form_type)
      {
! 	GtkTypeInfo form_info;
! 
! 	form_info.type_name = "GtkForm";
! 	form_info.object_size = sizeof(GtkForm);
! 	form_info.class_size = sizeof(GtkFormClass);
! 	form_info.class_init_func = (GtkClassInitFunc)gtk_form_class_init;
! 	form_info.object_init_func = (GtkObjectInitFunc)gtk_form_init;
  
  	form_type = gtk_type_unique(GTK_TYPE_CONTAINER, &form_info);
      }
***************
*** 611,620 ****
      }
  }
  
- /*ARGSUSED1*/
      static void
  gtk_form_forall(GtkContainer	*container,
! 		gboolean	include_internals,
  		GtkCallback	callback,
  		gpointer	callback_data)
  {
--- 610,618 ----
      }
  }
  
      static void
  gtk_form_forall(GtkContainer	*container,
! 		gboolean	include_internals UNUSED,
  		GtkCallback	callback,
  		gpointer	callback_data)
  {
***************
*** 786,794 ****
   * them or discards them, depending on whether we are obscured
   * or not.
   */
- /*ARGSUSED1*/
      static GdkFilterReturn
! gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
  {
      XEvent *xevent;
      GtkForm *form;
--- 784,791 ----
   * them or discards them, depending on whether we are obscured
   * or not.
   */
      static GdkFilterReturn
! gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event UNUSED, gpointer data)
  {
      XEvent *xevent;
      GtkForm *form;
***************
*** 821,829 ****
   * there is no corresponding event in GTK, so we have
   * to get the events from a filter
   */
- /*ARGSUSED1*/
      static GdkFilterReturn
! gtk_form_main_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
  {
      XEvent *xevent;
      GtkForm *form;
--- 818,827 ----
   * there is no corresponding event in GTK, so we have
   * to get the events from a filter
   */
      static GdkFilterReturn
! gtk_form_main_filter(GdkXEvent *gdk_xevent,
! 		     GdkEvent *event UNUSED,
! 		     gpointer data)
  {
      XEvent *xevent;
      GtkForm *form;
***************
*** 911,919 ****
  #endif
  }
  
- /*ARGSUSED0*/
      static void
! gtk_form_child_map(GtkWidget *widget, gpointer user_data)
  {
      GtkFormChild *child;
  
--- 909,916 ----
  #endif
  }
  
      static void
! gtk_form_child_map(GtkWidget *widget UNUSED, gpointer user_data)
  {
      GtkFormChild *child;
  
***************
*** 923,931 ****
      gdk_window_show(child->window);
  }
  
- /*ARGSUSED0*/
      static void
! gtk_form_child_unmap(GtkWidget *widget, gpointer user_data)
  {
      GtkFormChild *child;
  
--- 920,927 ----
      gdk_window_show(child->window);
  }
  
      static void
! gtk_form_child_unmap(GtkWidget *widget UNUSED, gpointer user_data)
  {
      GtkFormChild *child;
  
*** ../vim-7.2.180/src/gui_beval.c	2009-03-18 12:20:35.000000000 +0100
--- src/gui_beval.c	2009-05-17 15:53:22.000000000 +0200
***************
*** 15,21 ****
  /*
   * Common code, invoked when the mouse is resting for a moment.
   */
- /*ARGSUSED*/
      void
  general_beval_cb(beval, state)
      BalloonEval *beval;
--- 15,20 ----
***************
*** 551,559 ****
      return FALSE; /* continue emission */
  }
  
- /*ARGSUSED*/
      static gint
! mainwin_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)
  {
      BalloonEval *beval = (BalloonEval *)data;
  
--- 550,557 ----
      return FALSE; /* continue emission */
  }
  
      static gint
! mainwin_event_cb(GtkWidget *widget UNUSED, GdkEvent *event, gpointer data)
  {
      BalloonEval *beval = (BalloonEval *)data;
  
***************
*** 663,671 ****
      return FALSE; /* don't call me again */
  }
  
- /*ARGSUSED2*/
      static gint
! balloon_expose_event_cb(GtkWidget *widget, GdkEventExpose *event, gpointer data)
  {
      gtk_paint_flat_box(widget->style, widget->window,
  		       GTK_STATE_NORMAL, GTK_SHADOW_OUT,
--- 661,670 ----
      return FALSE; /* don't call me again */
  }
  
      static gint
! balloon_expose_event_cb(GtkWidget *widget,
! 			GdkEventExpose *event,
! 			gpointer data UNUSED)
  {
      gtk_paint_flat_box(widget->style, widget->window,
  		       GTK_STATE_NORMAL, GTK_SHADOW_OUT,
***************
*** 676,682 ****
  }
  
  # ifndef HAVE_GTK2
- /*ARGSUSED2*/
      static void
  balloon_draw_cb(GtkWidget *widget, GdkRectangle *area, gpointer data)
  {
--- 675,680 ----
***************
*** 726,732 ****
  /*
   * The X event handler. All it does is call the real event handler.
   */
- /*ARGSUSED*/
      static void
  pointerEventEH(w, client_data, event, unused)
      Widget	w;
--- 724,729 ----
***************
*** 877,883 ****
      }
  }
  
- /*ARGSUSED*/
      static void
  timerRoutine(dx, id)
      XtPointer	    dx;
--- 874,879 ----
*** ../vim-7.2.180/src/netbeans.c	2009-02-21 22:12:43.000000000 +0100
--- src/netbeans.c	2009-05-17 15:51:14.000000000 +0200
***************
*** 700,706 ****
  /*
   * Read and process a command from netbeans.
   */
- /*ARGSUSED*/
  #if defined(FEAT_GUI_W32) || defined(PROTO)
  /* Use this one when generating prototypes, the others are static. */
      void
--- 700,705 ----
***************
*** 708,719 ****
  #else
  # ifdef FEAT_GUI_MOTIF
      static void
! messageFromNetbeans(XtPointer clientData, int *unused1, XtInputId *unused2)
  # endif
  # ifdef FEAT_GUI_GTK
      static void
! messageFromNetbeans(gpointer clientData, gint unused1,
! 						    GdkInputCondition unused2)
  # endif
  #endif
  {
--- 707,721 ----
  #else
  # ifdef FEAT_GUI_MOTIF
      static void
! messageFromNetbeans(XtPointer clientData UNUSED
! 		    int *unused1 UNUSED,
! 		    XtInputId *unused2 UNUSED)
  # endif
  # ifdef FEAT_GUI_GTK
      static void
! messageFromNetbeans(gpointer clientData UNUSED,
! 		    gint unused1 UNUSED,
! 		    GdkInputCondition unused2 UNUSED)
  # endif
  #endif
  {
***************
*** 1585,1591 ****
--- 1587,1595 ----
  			    buf_delsign(buf->bufp, id);
  			}
  			else
+ 			{
  			    nbdebug(("    No sign on line %d\n", i));
+ 			}
  		    }
  
  		    nbdebug(("    Deleting lines %d through %d\n", del_from_lnum, del_to_lnum));
***************
*** 2144,2150 ****
--- 2148,2156 ----
  #endif
  	    }
  	    else
+ 	    {
  		nbdebug(("    BAD POSITION in setDot: %s\n", s));
+ 	    }
  
  	    /* gui_update_cursor(TRUE, FALSE); */
  	    /* update_curbuf(NOT_VALID); */
***************
*** 2744,2754 ****
   * cursor and sends it to the debugger for evaluation.  The debugger should
   * respond with a showBalloon command when there is a useful result.
   */
- /*ARGSUSED*/
      void
  netbeans_beval_cb(
  	BalloonEval	*beval,
! 	int		 state)
  {
      win_T	*wp;
      char_u	*text;
--- 2750,2759 ----
   * cursor and sends it to the debugger for evaluation.  The debugger should
   * respond with a showBalloon command when there is a useful result.
   */
      void
  netbeans_beval_cb(
  	BalloonEval	*beval,
! 	int		 state UNUSED)
  {
      win_T	*wp;
      char_u	*text;
***************
*** 3061,3069 ****
  /*
   * Send netbeans an unmodufied command.
   */
- /*ARGSUSED*/
      void
! netbeans_unmodified(buf_T *bufp)
  {
  #if 0
      char_u	buf[128];
--- 3066,3073 ----
  /*
   * Send netbeans an unmodufied command.
   */
      void
! netbeans_unmodified(buf_T *bufp UNUSED)
  {
  #if 0
      char_u	buf[128];
***************
*** 3370,3382 ****
   * buf->signmapused[]	maps buffer-local annotation IDs to an index in
   *			globalsignmap[].
   */
- /*ARGSUSED*/
      static void
  addsigntype(
      nbbuf_T	*buf,
      int		typeNum,
      char_u	*typeName,
!     char_u	*tooltip,
      char_u	*glyphFile,
      int		use_fg,
      int		fg,
--- 3374,3385 ----
   * buf->signmapused[]	maps buffer-local annotation IDs to an index in
   *			globalsignmap[].
   */
      static void
  addsigntype(
      nbbuf_T	*buf,
      int		typeNum,
      char_u	*typeName,
!     char_u	*tooltip UNUSED,
      char_u	*glyphFile,
      int		use_fg,
      int		fg,
*** ../vim-7.2.180/src/version.c	2009-05-17 13:30:58.000000000 +0200
--- src/version.c	2009-05-17 16:07:26.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     181,
  /**/

-- 
I am always surprised in the Linux world how quickly solutions can be
obtained.  (Imagine sending an email to Bill Gates, asking why Windows
crashed, and how to fix it...  and then getting an answer that fixed the
problem... <0>_<0> !)		              -- Mark Langdon

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.182
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.182 (after 7.2.181)
Problem:    Compilation problems after previous patch for Motif.  Gvim with
	    GTK crashes on startup.
Solution:   Add comma.  Init form structure to zeroes.
Files:	    src/netbeans.c, src/gui_gtk_f.c


*** ../vim-7.2.181/src/netbeans.c	2009-05-17 16:23:20.000000000 +0200
--- src/netbeans.c	2009-05-17 22:34:11.000000000 +0200
***************
*** 707,713 ****
  #else
  # ifdef FEAT_GUI_MOTIF
      static void
! messageFromNetbeans(XtPointer clientData UNUSED
  		    int *unused1 UNUSED,
  		    XtInputId *unused2 UNUSED)
  # endif
--- 707,713 ----
  #else
  # ifdef FEAT_GUI_MOTIF
      static void
! messageFromNetbeans(XtPointer clientData UNUSED,
  		    int *unused1 UNUSED,
  		    XtInputId *unused2 UNUSED)
  # endif
*** ../vim-7.2.181/src/gui_gtk_f.c	2009-05-17 16:23:20.000000000 +0200
--- src/gui_gtk_f.c	2009-05-17 23:20:41.000000000 +0200
***************
*** 229,234 ****
--- 229,235 ----
      {
  	GtkTypeInfo form_info;
  
+ 	vim_memset(&form_info, 0, sizeof(form_info));
  	form_info.type_name = "GtkForm";
  	form_info.object_size = sizeof(GtkForm);
  	form_info.class_size = sizeof(GtkFormClass);
*** ../vim-7.2.181/src/version.c	2009-05-17 16:23:20.000000000 +0200
--- src/version.c	2009-05-17 23:21:41.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     182,
  /**/

-- 
We apologise again for the fault in the subtitles.  Those responsible for
sacking the people who have just been sacked have been sacked.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.183
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.183
Problem:    Configure problem for sys/sysctl.h on OpenBSD. (Dasn)
Solution:   Add separate check for this header file.  Also switch to newer
	    version of autoconf.
Files:	    src/auto/configure, src/configure.in


*** ../vim-7.2.182/src/auto/configure	2009-05-14 22:19:19.000000000 +0200
--- src/auto/configure	2009-05-16 13:32:16.000000000 +0200
***************
*** 1,6 ****
  #! /bin/sh
  # Guess values for system-dependent variables and create Makefiles.
! # Generated by GNU Autoconf 2.62.
  #
  # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
  # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
--- 1,6 ----
  #! /bin/sh
  # Guess values for system-dependent variables and create Makefiles.
! # Generated by GNU Autoconf 2.63.
  #
  # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
  # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
***************
*** 635,772 ****
  # include <unistd.h>
  #endif"
  
! ac_subst_vars='SHELL
! PATH_SEPARATOR
! PACKAGE_NAME
! PACKAGE_TARNAME
! PACKAGE_VERSION
! PACKAGE_STRING
! PACKAGE_BUGREPORT
! exec_prefix
! prefix
! program_transform_name
! bindir
! sbindir
! libexecdir
! datarootdir
! datadir
! sysconfdir
! sharedstatedir
! localstatedir
! includedir
! oldincludedir
! docdir
! infodir
! htmldir
! dvidir
! pdfdir
! psdir
! libdir
! localedir
! mandir
! DEFS
! ECHO_C
! ECHO_N
! ECHO_T
! LIBS
! build_alias
! host_alias
! target_alias
! SET_MAKE
! CC
! CFLAGS
! LDFLAGS
! CPPFLAGS
! ac_ct_CC
! EXEEXT
! OBJEXT
! CPP
! GREP
! EGREP
! AWK
! STRIP
! CPP_MM
! OS_EXTRA_SRC
! OS_EXTRA_OBJ
! VIMNAME
! EXNAME
! VIEWNAME
! line_break
! dovimdiff
! dogvimdiff
! compiledby
! vi_cv_path_mzscheme
! MZSCHEME_SRC
! MZSCHEME_OBJ
! MZSCHEME_PRO
! MZSCHEME_LIBS
! MZSCHEME_CFLAGS
! vi_cv_path_perl
! vi_cv_perllib
! shrpenv
! PERL_SRC
! PERL_OBJ
! PERL_PRO
! PERL_CFLAGS
! PERL_LIBS
! vi_cv_path_python
! PYTHON_CONFDIR
! PYTHON_LIBS
! PYTHON_GETPATH_CFLAGS
! PYTHON_CFLAGS
! PYTHON_SRC
! PYTHON_OBJ
! vi_cv_path_tcl
! TCL_SRC
! TCL_OBJ
! TCL_PRO
! TCL_CFLAGS
! TCL_LIBS
! vi_cv_path_ruby
! RUBY_SRC
! RUBY_OBJ
! RUBY_PRO
! RUBY_CFLAGS
! RUBY_LIBS
! WORKSHOP_SRC
! WORKSHOP_OBJ
! NETBEANS_SRC
! NETBEANS_OBJ
! SNIFF_SRC
! SNIFF_OBJ
! xmkmfpath
! XMKMF
! X_CFLAGS
! X_PRE_LIBS
! X_LIBS
! X_EXTRA_LIBS
! X_LIB
! GTK_CONFIG
! GTK12_CONFIG
! PKG_CONFIG
! GTK_CFLAGS
! GTK_LIBS
! GTK_LIBNAME
! GNOME_LIBS
! GNOME_LIBDIR
! GNOME_INCLUDEDIR
! GNOME_CONFIG
! MOTIF_LIBNAME
! NARROW_PROTO
! GUI_INC_LOC
! GUI_LIB_LOC
! GUITYPE
! GUI_X_LIBS
! HANGULIN_SRC
! HANGULIN_OBJ
! TAGPRG
! INSTALL_LANGS
! INSTALL_TOOL_LANGS
! MSGFMT
! MAKEMO
! DEPEND_CFLAGS_FILTER
  LIBOBJS
! LTLIBOBJS'
  ac_subst_files=''
  ac_user_opts='
  enable_option_checking
--- 635,772 ----
  # include <unistd.h>
  #endif"
  
! ac_subst_vars='LTLIBOBJS
  LIBOBJS
! DEPEND_CFLAGS_FILTER
! MAKEMO
! MSGFMT
! INSTALL_TOOL_LANGS
! INSTALL_LANGS
! TAGPRG
! HANGULIN_OBJ
! HANGULIN_SRC
! GUI_X_LIBS
! GUITYPE
! GUI_LIB_LOC
! GUI_INC_LOC
! NARROW_PROTO
! MOTIF_LIBNAME
! GNOME_CONFIG
! GNOME_INCLUDEDIR
! GNOME_LIBDIR
! GNOME_LIBS
! GTK_LIBNAME
! GTK_LIBS
! GTK_CFLAGS
! PKG_CONFIG
! GTK12_CONFIG
! GTK_CONFIG
! X_LIB
! X_EXTRA_LIBS
! X_LIBS
! X_PRE_LIBS
! X_CFLAGS
! XMKMF
! xmkmfpath
! SNIFF_OBJ
! SNIFF_SRC
! NETBEANS_OBJ
! NETBEANS_SRC
! WORKSHOP_OBJ
! WORKSHOP_SRC
! RUBY_LIBS
! RUBY_CFLAGS
! RUBY_PRO
! RUBY_OBJ
! RUBY_SRC
! vi_cv_path_ruby
! TCL_LIBS
! TCL_CFLAGS
! TCL_PRO
! TCL_OBJ
! TCL_SRC
! vi_cv_path_tcl
! PYTHON_OBJ
! PYTHON_SRC
! PYTHON_CFLAGS
! PYTHON_GETPATH_CFLAGS
! PYTHON_LIBS
! PYTHON_CONFDIR
! vi_cv_path_python
! PERL_LIBS
! PERL_CFLAGS
! PERL_PRO
! PERL_OBJ
! PERL_SRC
! shrpenv
! vi_cv_perllib
! vi_cv_path_perl
! MZSCHEME_CFLAGS
! MZSCHEME_LIBS
! MZSCHEME_PRO
! MZSCHEME_OBJ
! MZSCHEME_SRC
! vi_cv_path_mzscheme
! compiledby
! dogvimdiff
! dovimdiff
! line_break
! VIEWNAME
! EXNAME
! VIMNAME
! OS_EXTRA_OBJ
! OS_EXTRA_SRC
! CPP_MM
! STRIP
! AWK
! EGREP
! GREP
! CPP
! OBJEXT
! EXEEXT
! ac_ct_CC
! CPPFLAGS
! LDFLAGS
! CFLAGS
! CC
! SET_MAKE
! target_alias
! host_alias
! build_alias
! LIBS
! ECHO_T
! ECHO_N
! ECHO_C
! DEFS
! mandir
! localedir
! libdir
! psdir
! pdfdir
! dvidir
! htmldir
! infodir
! docdir
! oldincludedir
! includedir
! localstatedir
! sharedstatedir
! sysconfdir
! datadir
! datarootdir
! libexecdir
! sbindir
! bindir
! program_transform_name
! prefix
! exec_prefix
! PACKAGE_BUGREPORT
! PACKAGE_STRING
! PACKAGE_VERSION
! PACKAGE_TARNAME
! PACKAGE_NAME
! PATH_SEPARATOR
! SHELL'
  ac_subst_files=''
  ac_user_opts='
  enable_option_checking
***************
*** 1253,1261 ****
  if test -n "$ac_unrecognized_opts"; then
    case $enable_option_checking in
      no) ;;
!     fatal) { $as_echo "$as_me: error: Unrecognized options: $ac_unrecognized_opts" >&2
     { (exit 1); exit 1; }; } ;;
!     *)     $as_echo "$as_me: WARNING: Unrecognized options: $ac_unrecognized_opts" >&2 ;;
    esac
  fi
  
--- 1253,1261 ----
  if test -n "$ac_unrecognized_opts"; then
    case $enable_option_checking in
      no) ;;
!     fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
     { (exit 1); exit 1; }; } ;;
!     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
    esac
  fi
  
***************
*** 1308,1314 ****
  ac_pwd=`pwd` && test -n "$ac_pwd" &&
  ac_ls_di=`ls -di .` &&
  ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
!   { $as_echo "$as_me: error: Working directory cannot be determined" >&2
     { (exit 1); exit 1; }; }
  test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
    { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
--- 1308,1314 ----
  ac_pwd=`pwd` && test -n "$ac_pwd" &&
  ac_ls_di=`ls -di .` &&
  ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
!   { $as_echo "$as_me: error: working directory cannot be determined" >&2
     { (exit 1); exit 1; }; }
  test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
    { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
***************
*** 1587,1593 ****
  if $ac_init_version; then
    cat <<\_ACEOF
  configure
! generated by GNU Autoconf 2.62
  
  Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
  2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
--- 1587,1593 ----
  if $ac_init_version; then
    cat <<\_ACEOF
  configure
! generated by GNU Autoconf 2.63
  
  Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
  2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
***************
*** 1601,1607 ****
  running configure, to aid debugging if configure makes a mistake.
  
  It was created by $as_me, which was
! generated by GNU Autoconf 2.62.  Invocation command line was
  
    $ $0 $@
  
--- 1601,1607 ----
  running configure, to aid debugging if configure makes a mistake.
  
  It was created by $as_me, which was
! generated by GNU Autoconf 2.63.  Invocation command line was
  
    $ $0 $@
  
***************
*** 1724,1731 ****
      case $ac_val in #(
      *${as_nl}*)
        case $ac_var in #(
!       *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
! $as_echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
        esac
        case $ac_var in #(
        _ | IFS | as_nl) ;; #(
--- 1724,1731 ----
      case $ac_val in #(
      *${as_nl}*)
        case $ac_var in #(
!       *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
! $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
        esac
        case $ac_var in #(
        _ | IFS | as_nl) ;; #(
***************
*** 1928,1933 ****
--- 1928,1935 ----
    fi
  done
  if $ac_cache_corrupted; then
+   { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+ $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
    { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
  $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
    { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
***************
*** 2084,2095 ****
    else
      case $cross_compiling:$ac_tool_warned in
  yes:)
! { $as_echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
! whose name does not start with the host triplet.  If you think this
! configuration is useful to you, please write to autoconf@gnu.org." >&5
! $as_echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
! whose name does not start with the host triplet.  If you think this
! configuration is useful to you, please write to autoconf@gnu.org." >&2;}
  ac_tool_warned=yes ;;
  esac
      CC=$ac_ct_CC
--- 2086,2093 ----
    else
      case $cross_compiling:$ac_tool_warned in
  yes:)
! { $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
! $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
  ac_tool_warned=yes ;;
  esac
      CC=$ac_ct_CC
***************
*** 2288,2299 ****
    else
      case $cross_compiling:$ac_tool_warned in
  yes:)
! { $as_echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
! whose name does not start with the host triplet.  If you think this
! configuration is useful to you, please write to autoconf@gnu.org." >&5
! $as_echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
! whose name does not start with the host triplet.  If you think this
! configuration is useful to you, please write to autoconf@gnu.org." >&2;}
  ac_tool_warned=yes ;;
  esac
      CC=$ac_ct_CC
--- 2286,2293 ----
    else
      case $cross_compiling:$ac_tool_warned in
  yes:)
! { $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
! $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
  ac_tool_warned=yes ;;
  esac
      CC=$ac_ct_CC
***************
*** 2303,2313 ****
  fi
  
  
! test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: no acceptable C compiler found in \$PATH
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }
  
  # Provide some information about the compiler.
  $as_echo "$as_me:$LINENO: checking for C compiler version" >&5
--- 2297,2309 ----
  fi
  
  
! test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
! $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
! { { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: no acceptable C compiler found in \$PATH
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }; }
  
  # Provide some information about the compiler.
  $as_echo "$as_me:$LINENO: checking for C compiler version" >&5
***************
*** 2437,2447 ****
    $as_echo "$as_me: failed program was:" >&5
  sed 's/^/| /' conftest.$ac_ext >&5
  
  { { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: C compiler cannot create executables
  See \`config.log' for more details." >&2;}
!    { (exit 77); exit 77; }; }
  fi
  
  ac_exeext=$ac_cv_exeext
--- 2433,2445 ----
    $as_echo "$as_me: failed program was:" >&5
  sed 's/^/| /' conftest.$ac_ext >&5
  
+ { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+ $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
  { { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: C compiler cannot create executables
  See \`config.log' for more details." >&2;}
!    { (exit 77); exit 77; }; }; }
  fi
  
  ac_exeext=$ac_cv_exeext
***************
*** 2469,2481 ****
      if test "$cross_compiling" = maybe; then
  	cross_compiling=yes
      else
! 	{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
  If you meant to cross compile, use \`--host'.
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: cannot run C compiled programs.
  If you meant to cross compile, use \`--host'.
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }
      fi
    fi
  fi
--- 2467,2481 ----
      if test "$cross_compiling" = maybe; then
  	cross_compiling=yes
      else
! 	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
! $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
! { { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
  If you meant to cross compile, use \`--host'.
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: cannot run C compiled programs.
  If you meant to cross compile, use \`--host'.
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }; }
      fi
    fi
  fi
***************
*** 2518,2528 ****
    esac
  done
  else
!   { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }
  fi
  
  rm -f conftest$ac_cv_exeext
--- 2518,2530 ----
    esac
  done
  else
!   { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
! $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
! { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }; }
  fi
  
  rm -f conftest$ac_cv_exeext
***************
*** 2576,2586 ****
    $as_echo "$as_me: failed program was:" >&5
  sed 's/^/| /' conftest.$ac_ext >&5
  
  { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }
  fi
  
  rm -f conftest.$ac_cv_objext conftest.$ac_ext
--- 2578,2590 ----
    $as_echo "$as_me: failed program was:" >&5
  sed 's/^/| /' conftest.$ac_ext >&5
  
+ { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+ $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
  { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }; }
  fi
  
  rm -f conftest.$ac_cv_objext conftest.$ac_ext
***************
*** 3148,3158 ****
  if $ac_preproc_ok; then
    :
  else
!   { { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }
  fi
  
  ac_ext=c
--- 3152,3164 ----
  if $ac_preproc_ok; then
    :
  else
!   { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
! $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
! { { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
  See \`config.log' for more details." >&5
  $as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
  See \`config.log' for more details." >&2;}
!    { (exit 1); exit 1; }; }; }
  fi
  
  ac_ext=c
***************
*** 4016,4023 ****
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
--- 4022,4030 ----
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
***************
*** 4154,4160 ****
  $as_echo "$ac_cv_header_Carbon_Carbon_h" >&6; }
  
  fi
! if test $ac_cv_header_Carbon_Carbon_h = yes; then
    CARBON=yes
  fi
  
--- 4161,4167 ----
  $as_echo "$ac_cv_header_Carbon_Carbon_h" >&6; }
  
  fi
! if test "x$ac_cv_header_Carbon_Carbon_h" = x""yes; then
    CARBON=yes
  fi
  
***************
*** 4484,4490 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_selinux_is_selinux_enabled" >&5
  $as_echo "$ac_cv_lib_selinux_is_selinux_enabled" >&6; }
! if test $ac_cv_lib_selinux_is_selinux_enabled = yes; then
    LIBS="$LIBS -lselinux"
  	   cat >>confdefs.h <<\_ACEOF
  #define HAVE_SELINUX 1
--- 4491,4497 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_selinux_is_selinux_enabled" >&5
  $as_echo "$ac_cv_lib_selinux_is_selinux_enabled" >&6; }
! if test "x$ac_cv_lib_selinux_is_selinux_enabled" = x""yes; then
    LIBS="$LIBS -lselinux"
  	   cat >>confdefs.h <<\_ACEOF
  #define HAVE_SELINUX 1
***************
*** 5891,5897 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_socket" >&5
  $as_echo "$ac_cv_lib_socket_socket" >&6; }
! if test $ac_cv_lib_socket_socket = yes; then
    cat >>confdefs.h <<_ACEOF
  #define HAVE_LIBSOCKET 1
  _ACEOF
--- 5898,5904 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_socket" >&5
  $as_echo "$ac_cv_lib_socket_socket" >&6; }
! if test "x$ac_cv_lib_socket_socket" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define HAVE_LIBSOCKET 1
  _ACEOF
***************
*** 5966,5972 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
  $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
! if test $ac_cv_lib_nsl_gethostbyname = yes; then
    cat >>confdefs.h <<_ACEOF
  #define HAVE_LIBNSL 1
  _ACEOF
--- 5973,5979 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
  $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
! if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define HAVE_LIBNSL 1
  _ACEOF
***************
*** 6203,6210 ****
    have_x=disabled
  else
    case $x_includes,$x_libraries in #(
!     *\'*) { { $as_echo "$as_me:$LINENO: error: Cannot use X directory names containing '" >&5
! $as_echo "$as_me: error: Cannot use X directory names containing '" >&2;}
     { (exit 1); exit 1; }; };; #(
      *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then
    $as_echo_n "(cached) " >&6
--- 6210,6217 ----
    have_x=disabled
  else
    case $x_includes,$x_libraries in #(
!     *\'*) { { $as_echo "$as_me:$LINENO: error: cannot use X directory names containing '" >&5
! $as_echo "$as_me: error: cannot use X directory names containing '" >&2;}
     { (exit 1); exit 1; }; };; #(
      *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then
    $as_echo_n "(cached) " >&6
***************
*** 6242,6248 ****
  	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
      esac
      case $ac_im_usrlibdir in
! 	/usr/lib | /lib) ;;
  	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
      esac
    fi
--- 6249,6255 ----
  	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
      esac
      case $ac_im_usrlibdir in
! 	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
  	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
      esac
    fi
***************
*** 6682,6688 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
  $as_echo "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
! if test $ac_cv_lib_dnet_dnet_ntoa = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
  fi
  
--- 6689,6695 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
  $as_echo "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
! if test "x$ac_cv_lib_dnet_dnet_ntoa" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
  fi
  
***************
*** 6752,6758 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
  $as_echo "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
! if test $ac_cv_lib_dnet_stub_dnet_ntoa = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
  fi
  
--- 6759,6765 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
  $as_echo "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
! if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
  fi
  
***************
*** 6924,6930 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
  $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
! if test $ac_cv_lib_nsl_gethostbyname = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
  fi
  
--- 6931,6937 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
  $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
! if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
  fi
  
***************
*** 6994,7000 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_bsd_gethostbyname" >&5
  $as_echo "$ac_cv_lib_bsd_gethostbyname" >&6; }
! if test $ac_cv_lib_bsd_gethostbyname = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lbsd"
  fi
  
--- 7001,7007 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_bsd_gethostbyname" >&5
  $as_echo "$ac_cv_lib_bsd_gethostbyname" >&6; }
! if test "x$ac_cv_lib_bsd_gethostbyname" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lbsd"
  fi
  
***************
*** 7160,7166 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_connect" >&5
  $as_echo "$ac_cv_lib_socket_connect" >&6; }
! if test $ac_cv_lib_socket_connect = yes; then
    X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
  fi
  
--- 7167,7173 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_connect" >&5
  $as_echo "$ac_cv_lib_socket_connect" >&6; }
! if test "x$ac_cv_lib_socket_connect" = x""yes; then
    X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
  fi
  
***************
*** 7319,7325 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix_remove" >&5
  $as_echo "$ac_cv_lib_posix_remove" >&6; }
! if test $ac_cv_lib_posix_remove = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
  fi
  
--- 7326,7332 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix_remove" >&5
  $as_echo "$ac_cv_lib_posix_remove" >&6; }
! if test "x$ac_cv_lib_posix_remove" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
  fi
  
***************
*** 7478,7484 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ipc_shmat" >&5
  $as_echo "$ac_cv_lib_ipc_shmat" >&6; }
! if test $ac_cv_lib_ipc_shmat = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
  fi
  
--- 7485,7491 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ipc_shmat" >&5
  $as_echo "$ac_cv_lib_ipc_shmat" >&6; }
! if test "x$ac_cv_lib_ipc_shmat" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
  fi
  
***************
*** 7559,7565 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
  $as_echo "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
! if test $ac_cv_lib_ICE_IceConnectionNumber = yes; then
    X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
  fi
  
--- 7566,7572 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
  $as_echo "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
! if test "x$ac_cv_lib_ICE_IceConnectionNumber" = x""yes; then
    X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
  fi
  
***************
*** 7727,7733 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&5
  $as_echo "$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&6; }
! if test $ac_cv_lib_Xdmcp__XdmcpAuthDoIt = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"
  fi
  
--- 7734,7740 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&5
  $as_echo "$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&6; }
! if test "x$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"
  fi
  
***************
*** 7797,7803 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceOpenConnection" >&5
  $as_echo "$ac_cv_lib_ICE_IceOpenConnection" >&6; }
! if test $ac_cv_lib_ICE_IceOpenConnection = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"
  fi
  
--- 7804,7810 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceOpenConnection" >&5
  $as_echo "$ac_cv_lib_ICE_IceOpenConnection" >&6; }
! if test "x$ac_cv_lib_ICE_IceOpenConnection" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"
  fi
  
***************
*** 7868,7874 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&5
  $as_echo "$ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&6; }
! if test $ac_cv_lib_Xpm_XpmCreatePixmapFromData = yes; then
    X_PRE_LIBS="$X_PRE_LIBS -lXpm"
  fi
  
--- 7875,7881 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&5
  $as_echo "$ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&6; }
! if test "x$ac_cv_lib_Xpm_XpmCreatePixmapFromData" = x""yes; then
    X_PRE_LIBS="$X_PRE_LIBS -lXpm"
  fi
  
***************
*** 9251,9257 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
  $as_echo "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
! if test $ac_cv_lib_Xext_XShapeQueryExtension = yes; then
    GUI_X_LIBS="-lXext"
  fi
  
--- 9258,9264 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
  $as_echo "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
! if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = x""yes; then
    GUI_X_LIBS="-lXext"
  fi
  
***************
*** 9320,9326 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_w_wslen" >&5
  $as_echo "$ac_cv_lib_w_wslen" >&6; }
! if test $ac_cv_lib_w_wslen = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"
  fi
  
--- 9327,9333 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_w_wslen" >&5
  $as_echo "$ac_cv_lib_w_wslen" >&6; }
! if test "x$ac_cv_lib_w_wslen" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"
  fi
  
***************
*** 9389,9395 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlsym" >&5
  $as_echo "$ac_cv_lib_dl_dlsym" >&6; }
! if test $ac_cv_lib_dl_dlsym = yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"
  fi
  
--- 9396,9402 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlsym" >&5
  $as_echo "$ac_cv_lib_dl_dlsym" >&6; }
! if test "x$ac_cv_lib_dl_dlsym" = x""yes; then
    X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"
  fi
  
***************
*** 9458,9464 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&5
  $as_echo "$ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&6; }
! if test $ac_cv_lib_Xmu_XmuCreateStippledPixmap = yes; then
    GUI_X_LIBS="-lXmu $GUI_X_LIBS"
  fi
  
--- 9465,9471 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&5
  $as_echo "$ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&6; }
! if test "x$ac_cv_lib_Xmu_XmuCreateStippledPixmap" = x""yes; then
    GUI_X_LIBS="-lXmu $GUI_X_LIBS"
  fi
  
***************
*** 9528,9534 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xp_XpEndJob" >&5
  $as_echo "$ac_cv_lib_Xp_XpEndJob" >&6; }
! if test $ac_cv_lib_Xp_XpEndJob = yes; then
    GUI_X_LIBS="-lXp $GUI_X_LIBS"
  fi
  
--- 9535,9541 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xp_XpEndJob" >&5
  $as_echo "$ac_cv_lib_Xp_XpEndJob" >&6; }
! if test "x$ac_cv_lib_Xp_XpEndJob" = x""yes; then
    GUI_X_LIBS="-lXp $GUI_X_LIBS"
  fi
  
***************
*** 9699,9706 ****
  $as_echo "$ac_res" >&6; }
  
  fi
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
--- 9706,9714 ----
  $as_echo "$ac_res" >&6; }
  
  fi
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
***************
*** 9852,9859 ****
  $as_echo "$ac_res" >&6; }
  
  fi
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
--- 9860,9868 ----
  $as_echo "$ac_res" >&6; }
  
  fi
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
***************
*** 10098,10105 ****
  $as_echo "$ac_res" >&6; }
  
  fi
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
--- 10107,10115 ----
  $as_echo "$ac_res" >&6; }
  
  fi
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
***************
*** 10539,10545 ****
  $as_echo "$ac_cv_header_elf_h" >&6; }
  
  fi
! if test $ac_cv_header_elf_h = yes; then
    HAS_ELF=1
  fi
  
--- 10549,10555 ----
  $as_echo "$ac_cv_header_elf_h" >&6; }
  
  fi
! if test "x$ac_cv_header_elf_h" = x""yes; then
    HAS_ELF=1
  fi
  
***************
*** 10605,10611 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_elf_main" >&5
  $as_echo "$ac_cv_lib_elf_main" >&6; }
! if test $ac_cv_lib_elf_main = yes; then
    cat >>confdefs.h <<_ACEOF
  #define HAVE_LIBELF 1
  _ACEOF
--- 10615,10621 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_elf_main" >&5
  $as_echo "$ac_cv_lib_elf_main" >&6; }
! if test "x$ac_cv_lib_elf_main" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define HAVE_LIBELF 1
  _ACEOF
***************
*** 10679,10686 ****
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
  _ACEOF
--- 10689,10697 ----
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
  _ACEOF
***************
*** 10966,10972 ****
  
  
  
- 
  for ac_header in stdarg.h stdlib.h string.h sys/select.h sys/utsname.h \
  	termcap.h fcntl.h sgtty.h sys/ioctl.h sys/time.h sys/types.h termio.h \
  	iconv.h langinfo.h math.h unistd.h stropts.h errno.h \
--- 10977,10982 ----
***************
*** 10974,10980 ****
  	sys/stream.h termios.h libc.h sys/statfs.h \
  	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
  	libgen.h util/debug.h util/msg18n.h frame.h \
! 	sys/acl.h sys/access.h sys/sysctl.h sys/sysinfo.h wchar.h wctype.h
  do
  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
  if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
--- 10984,10990 ----
  	sys/stream.h termios.h libc.h sys/statfs.h \
  	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
  	libgen.h util/debug.h util/msg18n.h frame.h \
! 	sys/acl.h sys/access.h sys/sysinfo.h wchar.h wctype.h
  do
  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
  if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
***************
*** 11108,11115 ****
  $as_echo "$ac_res" >&6; }
  
  fi
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
--- 11118,11126 ----
  $as_echo "$ac_res" >&6; }
  
  fi
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
***************
*** 11172,11179 ****
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
--- 11183,11256 ----
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
!   cat >>confdefs.h <<_ACEOF
! #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
! _ACEOF
! 
! fi
! 
! done
! 
! 
! 
! for ac_header in sys/sysctl.h
! do
! as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
! { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
! $as_echo_n "checking for $ac_header... " >&6; }
! if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
!   $as_echo_n "(cached) " >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! /* confdefs.h.  */
! _ACEOF
! cat confdefs.h >>conftest.$ac_ext
! cat >>conftest.$ac_ext <<_ACEOF
! /* end confdefs.h.  */
! #if defined HAVE_SYS_PARAM_H
! #  include <sys/param.h>
! #endif
! 
! #include <$ac_header>
! _ACEOF
! rm -f conftest.$ac_objext
! if { (ac_try="$ac_compile"
! case "(($ac_try" in
!   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
!   *) ac_try_echo=$ac_try;;
! esac
! eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
! $as_echo "$ac_try_echo") >&5
!   (eval "$ac_compile") 2>conftest.er1
!   ac_status=$?
!   grep -v '^ *+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
!   (exit $ac_status); } && {
! 	 test -z "$ac_c_werror_flag" ||
! 	 test ! -s conftest.err
!        } && test -s conftest.$ac_objext; then
!   eval "$as_ac_Header=yes"
! else
!   $as_echo "$as_me: failed program was:" >&5
! sed 's/^/| /' conftest.$ac_ext >&5
! 
! 	eval "$as_ac_Header=no"
! fi
! 
! rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
! fi
! ac_res=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
! 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
! $as_echo "$ac_res" >&6; }
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
***************
*** 11372,11379 ****
  $as_echo "$ac_res" >&6; }
  
  fi
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
--- 11449,11457 ----
  $as_echo "$ac_res" >&6; }
  
  fi
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
***************
*** 11770,11776 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_mode_t" >&5
  $as_echo "$ac_cv_type_mode_t" >&6; }
! if test $ac_cv_type_mode_t = yes; then
    :
  else
  
--- 11848,11854 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_mode_t" >&5
  $as_echo "$ac_cv_type_mode_t" >&6; }
! if test "x$ac_cv_type_mode_t" = x""yes; then
    :
  else
  
***************
*** 11874,11880 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
  $as_echo "$ac_cv_type_off_t" >&6; }
! if test $ac_cv_type_off_t = yes; then
    :
  else
  
--- 11952,11958 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
  $as_echo "$ac_cv_type_off_t" >&6; }
! if test "x$ac_cv_type_off_t" = x""yes; then
    :
  else
  
***************
*** 11978,11984 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
  $as_echo "$ac_cv_type_pid_t" >&6; }
! if test $ac_cv_type_pid_t = yes; then
    :
  else
  
--- 12056,12062 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
  $as_echo "$ac_cv_type_pid_t" >&6; }
! if test "x$ac_cv_type_pid_t" = x""yes; then
    :
  else
  
***************
*** 12082,12088 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
  $as_echo "$ac_cv_type_size_t" >&6; }
! if test $ac_cv_type_size_t = yes; then
    :
  else
  
--- 12160,12166 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
  $as_echo "$ac_cv_type_size_t" >&6; }
! if test "x$ac_cv_type_size_t" = x""yes; then
    :
  else
  
***************
*** 12286,12292 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_ino_t" >&5
  $as_echo "$ac_cv_type_ino_t" >&6; }
! if test $ac_cv_type_ino_t = yes; then
    :
  else
  
--- 12364,12370 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_ino_t" >&5
  $as_echo "$ac_cv_type_ino_t" >&6; }
! if test "x$ac_cv_type_ino_t" = x""yes; then
    :
  else
  
***************
*** 12390,12396 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_dev_t" >&5
  $as_echo "$ac_cv_type_dev_t" >&6; }
! if test $ac_cv_type_dev_t = yes; then
    :
  else
  
--- 12468,12474 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_type_dev_t" >&5
  $as_echo "$ac_cv_type_dev_t" >&6; }
! if test "x$ac_cv_type_dev_t" = x""yes; then
    :
  else
  
***************
*** 12680,12687 ****
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! if test `eval 'as_val=${'$as_ac_Lib'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_LIB${libname}" | $as_tr_cpp` 1
  _ACEOF
--- 12758,12766 ----
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! as_val=`eval 'as_val=${'$as_ac_Lib'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_LIB${libname}" | $as_tr_cpp` 1
  _ACEOF
***************
*** 13929,13936 ****
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! if test `eval 'as_val=${'$as_ac_var'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
  _ACEOF
--- 14008,14016 ----
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! as_val=`eval 'as_val=${'$as_ac_var'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
  _ACEOF
***************
*** 14313,14319 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_strtod" >&5
  $as_echo "$ac_cv_lib_m_strtod" >&6; }
! if test $ac_cv_lib_m_strtod = yes; then
    cat >>confdefs.h <<_ACEOF
  #define HAVE_LIBM 1
  _ACEOF
--- 14393,14399 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_strtod" >&5
  $as_echo "$ac_cv_lib_m_strtod" >&6; }
! if test "x$ac_cv_lib_m_strtod" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define HAVE_LIBM 1
  _ACEOF
***************
*** 14473,14479 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix1e_acl_get_file" >&5
  $as_echo "$ac_cv_lib_posix1e_acl_get_file" >&6; }
! if test $ac_cv_lib_posix1e_acl_get_file = yes; then
    LIBS="$LIBS -lposix1e"
  else
    { $as_echo "$as_me:$LINENO: checking for acl_get_file in -lacl" >&5
--- 14553,14559 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix1e_acl_get_file" >&5
  $as_echo "$ac_cv_lib_posix1e_acl_get_file" >&6; }
! if test "x$ac_cv_lib_posix1e_acl_get_file" = x""yes; then
    LIBS="$LIBS -lposix1e"
  else
    { $as_echo "$as_me:$LINENO: checking for acl_get_file in -lacl" >&5
***************
*** 14541,14547 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_acl_acl_get_file" >&5
  $as_echo "$ac_cv_lib_acl_acl_get_file" >&6; }
! if test $ac_cv_lib_acl_acl_get_file = yes; then
    LIBS="$LIBS -lacl"
  		  { $as_echo "$as_me:$LINENO: checking for fgetxattr in -lattr" >&5
  $as_echo_n "checking for fgetxattr in -lattr... " >&6; }
--- 14621,14627 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_acl_acl_get_file" >&5
  $as_echo "$ac_cv_lib_acl_acl_get_file" >&6; }
! if test "x$ac_cv_lib_acl_acl_get_file" = x""yes; then
    LIBS="$LIBS -lacl"
  		  { $as_echo "$as_me:$LINENO: checking for fgetxattr in -lattr" >&5
  $as_echo_n "checking for fgetxattr in -lattr... " >&6; }
***************
*** 14608,14614 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_attr_fgetxattr" >&5
  $as_echo "$ac_cv_lib_attr_fgetxattr" >&6; }
! if test $ac_cv_lib_attr_fgetxattr = yes; then
    LIBS="$LIBS -lattr"
  fi
  
--- 14688,14694 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_attr_fgetxattr" >&5
  $as_echo "$ac_cv_lib_attr_fgetxattr" >&6; }
! if test "x$ac_cv_lib_attr_fgetxattr" = x""yes; then
    LIBS="$LIBS -lattr"
  fi
  
***************
*** 15746,15752 ****
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_xpg4__xpg4_setrunelocale" >&5
  $as_echo "$ac_cv_lib_xpg4__xpg4_setrunelocale" >&6; }
! if test $ac_cv_lib_xpg4__xpg4_setrunelocale = yes; then
    LIBS="$LIBS -lxpg4"
  fi
  
--- 15826,15832 ----
  fi
  { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_xpg4__xpg4_setrunelocale" >&5
  $as_echo "$ac_cv_lib_xpg4__xpg4_setrunelocale" >&6; }
! if test "x$ac_cv_lib_xpg4__xpg4_setrunelocale" = x""yes; then
    LIBS="$LIBS -lxpg4"
  fi
  
***************
*** 16045,16052 ****
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! if test `eval 'as_val=${'$as_ac_var'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
  _ACEOF
--- 16125,16133 ----
  		 $as_echo "$as_val"'`
  	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
  $as_echo "$ac_res" >&6; }
! as_val=`eval 'as_val=${'$as_ac_var'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
  _ACEOF
***************
*** 16246,16252 ****
  $as_echo "$ac_cv_header_dlfcn_h" >&6; }
  
  fi
! if test $ac_cv_header_dlfcn_h = yes; then
    DLL=dlfcn.h
  else
    if test "${ac_cv_header_dl_h+set}" = set; then
--- 16327,16333 ----
  $as_echo "$ac_cv_header_dlfcn_h" >&6; }
  
  fi
! if test "x$ac_cv_header_dlfcn_h" = x""yes; then
    DLL=dlfcn.h
  else
    if test "${ac_cv_header_dl_h+set}" = set; then
***************
*** 16376,16382 ****
  $as_echo "$ac_cv_header_dl_h" >&6; }
  
  fi
! if test $ac_cv_header_dl_h = yes; then
    DLL=dl.h
  fi
  
--- 16457,16463 ----
  $as_echo "$ac_cv_header_dl_h" >&6; }
  
  fi
! if test "x$ac_cv_header_dl_h" = x""yes; then
    DLL=dl.h
  fi
  
***************
*** 16895,16902 ****
  $as_echo "$ac_res" >&6; }
  
  fi
! if test `eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'` = yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
--- 16976,16984 ----
  $as_echo "$ac_res" >&6; }
  
  fi
! as_val=`eval 'as_val=${'$as_ac_Header'}
! 		 $as_echo "$as_val"'`
!    if test "x$as_val" = x""yes; then
    cat >>confdefs.h <<_ACEOF
  #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
  _ACEOF
***************
*** 16986,16993 ****
      case $ac_val in #(
      *${as_nl}*)
        case $ac_var in #(
!       *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
! $as_echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
        esac
        case $ac_var in #(
        _ | IFS | as_nl) ;; #(
--- 17068,17075 ----
      case $ac_val in #(
      *${as_nl}*)
        case $ac_var in #(
!       *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
! $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
        esac
        case $ac_var in #(
        _ | IFS | as_nl) ;; #(
***************
*** 17379,17385 ****
  # values after options handling.
  ac_log="
  This file was extended by $as_me, which was
! generated by GNU Autoconf 2.62.  Invocation command line was
  
    CONFIG_FILES    = $CONFIG_FILES
    CONFIG_HEADERS  = $CONFIG_HEADERS
--- 17461,17467 ----
  # values after options handling.
  ac_log="
  This file was extended by $as_me, which was
! generated by GNU Autoconf 2.63.  Invocation command line was
  
    CONFIG_FILES    = $CONFIG_FILES
    CONFIG_HEADERS  = $CONFIG_HEADERS
***************
*** 17392,17397 ****
--- 17474,17488 ----
  
  _ACEOF
  
+ case $ac_config_files in *"
+ "*) set x $ac_config_files; shift; ac_config_files=$*;;
+ esac
+ 
+ case $ac_config_headers in *"
+ "*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+ esac
+ 
+ 
  cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  # Files that config.status was made for.
  config_files="$ac_config_files"
***************
*** 17404,17419 ****
  \`$as_me' instantiates files from templates according to the
  current configuration.
  
! Usage: $0 [OPTIONS] [FILE]...
  
    -h, --help       print this help, then exit
    -V, --version    print version number and configuration settings, then exit
!   -q, --quiet      do not print progress messages
    -d, --debug      don't remove temporary files
        --recheck    update $as_me by reconfiguring in the same conditions
!   --file=FILE[:TEMPLATE]
                     instantiate the configuration file FILE
!   --header=FILE[:TEMPLATE]
                     instantiate the configuration header FILE
  
  Configuration files:
--- 17495,17511 ----
  \`$as_me' instantiates files from templates according to the
  current configuration.
  
! Usage: $0 [OPTION]... [FILE]...
  
    -h, --help       print this help, then exit
    -V, --version    print version number and configuration settings, then exit
!   -q, --quiet, --silent
!                    do not print progress messages
    -d, --debug      don't remove temporary files
        --recheck    update $as_me by reconfiguring in the same conditions
!       --file=FILE[:TEMPLATE]
                     instantiate the configuration file FILE
!       --header=FILE[:TEMPLATE]
                     instantiate the configuration header FILE
  
  Configuration files:
***************
*** 17428,17434 ****
  cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  ac_cs_version="\\
  config.status
! configured by $0, generated by GNU Autoconf 2.62,
    with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
  
  Copyright (C) 2008 Free Software Foundation, Inc.
--- 17520,17526 ----
  cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  ac_cs_version="\\
  config.status
! configured by $0, generated by GNU Autoconf 2.63,
    with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
  
  Copyright (C) 2008 Free Software Foundation, Inc.
***************
*** 17625,17631 ****
  $as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
     { (exit 1); exit 1; }; }
  
!   if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X` = $ac_delim_num; then
      break
    elif $ac_last_try; then
      { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
--- 17717,17724 ----
  $as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
     { (exit 1); exit 1; }; }
  
!   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
!   if test $ac_delim_n = $ac_delim_num; then
      break
    elif $ac_last_try; then
      { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
***************
*** 17830,17838 ****
    }
    split(mac1, mac2, "(") #)
    macro = mac2[1]
    if (D_is_set[macro]) {
      # Preserve the white space surrounding the "#".
-     prefix = substr(line, 1, index(line, defundef) - 1)
      print prefix "define", macro P[macro] D[macro]
      next
    } else {
--- 17923,17931 ----
    }
    split(mac1, mac2, "(") #)
    macro = mac2[1]
+   prefix = substr(line, 1, index(line, defundef) - 1)
    if (D_is_set[macro]) {
      # Preserve the white space surrounding the "#".
      print prefix "define", macro P[macro] D[macro]
      next
    } else {
***************
*** 17840,17846 ****
      # in the case of _POSIX_SOURCE, which is predefined and required
      # on some systems where configure will not decide to define it.
      if (defundef == "undef") {
!       print "/*", line, "*/"
        next
      }
    }
--- 17933,17939 ----
      # in the case of _POSIX_SOURCE, which is predefined and required
      # on some systems where configure will not decide to define it.
      if (defundef == "undef") {
!       print "/*", prefix defundef, macro, "*/"
        next
      }
    }
***************
*** 17864,17871 ****
    esac
    case $ac_mode$ac_tag in
    :[FHL]*:*);;
!   :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
! $as_echo "$as_me: error: Invalid tag $ac_tag." >&2;}
     { (exit 1); exit 1; }; };;
    :[FH]-) ac_tag=-:-;;
    :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
--- 17957,17964 ----
    esac
    case $ac_mode$ac_tag in
    :[FHL]*:*);;
!   :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
! $as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
     { (exit 1); exit 1; }; };;
    :[FH]-) ac_tag=-:-;;
    :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
***************
*** 18183,18190 ****
    $ac_cs_success || { (exit 1); exit 1; }
  fi
  if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
!   { $as_echo "$as_me:$LINENO: WARNING: Unrecognized options: $ac_unrecognized_opts" >&5
! $as_echo "$as_me: WARNING: Unrecognized options: $ac_unrecognized_opts" >&2;}
  fi
  
  
--- 18276,18283 ----
    $ac_cs_success || { (exit 1); exit 1; }
  fi
  if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
!   { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
! $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
  fi
  
  
*** ../vim-7.2.182/src/configure.in	2009-05-14 22:19:19.000000000 +0200
--- src/configure.in	2009-05-16 13:32:00.000000000 +0200
***************
*** 2100,2106 ****
  	sys/stream.h termios.h libc.h sys/statfs.h \
  	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
  	libgen.h util/debug.h util/msg18n.h frame.h \
! 	sys/acl.h sys/access.h sys/sysctl.h sys/sysinfo.h wchar.h wctype.h)
  
  dnl sys/ptem.h depends on sys/stream.h on Solaris
  AC_CHECK_HEADERS(sys/ptem.h, [], [],
--- 2100,2106 ----
  	sys/stream.h termios.h libc.h sys/statfs.h \
  	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
  	libgen.h util/debug.h util/msg18n.h frame.h \
! 	sys/acl.h sys/access.h sys/sysinfo.h wchar.h wctype.h)
  
  dnl sys/ptem.h depends on sys/stream.h on Solaris
  AC_CHECK_HEADERS(sys/ptem.h, [], [],
***************
*** 2108,2113 ****
--- 2108,2119 ----
  #  include <sys/stream.h>
  #endif])
  
+ dnl sys/sysctl.h depends on sys/param.h on OpenBSD
+ AC_CHECK_HEADERS(sys/sysctl.h, [], [],
+ [#if defined HAVE_SYS_PARAM_H
+ #  include <sys/param.h>
+ #endif])
+ 
  
  dnl pthread_np.h may exist but can only be used after including pthread.h
  AC_MSG_CHECKING([for pthread_np.h])
*** ../vim-7.2.182/src/version.c	2009-05-17 23:25:16.000000000 +0200
--- src/version.c	2009-05-21 15:16:01.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     183,
  /**/

-- 
CART DRIVER: Bring out your dead!
   There are legs stick out of windows and doors.  Two MEN are fighting in the
   mud - covered from head to foot in it.  Another MAN is on his hands in
   knees shovelling mud into his mouth.  We just catch sight of a MAN falling
   into a well.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.184
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.184
Problem:    Some more compiler warnings when using gcc -Wextra.
Solution:   Add UNUSED and type casts.  Autoconf check for wchar_t.
Files:	    src/auto/configure, src/config.h.in, src/configure.in,
	    src/gui_athena.c, src/gui_x11.c, src/gui.c, src/gui_beval.c,
	    src/gui_at_sb.c, src/gui_at_fs.c, src/gui_motif.c,
	    src/gui_xmdlg.c, src/gui_xmebw.c, src/if_python.c, src/window.c,
	    src/workshop.c


*** ../vim-7.2.183/src/auto/configure	2009-05-21 15:19:59.000000000 +0200
--- src/auto/configure	2009-05-21 16:05:01.000000000 +0200
***************
*** 7977,7982 ****
--- 7977,8058 ----
  
      LDFLAGS="$ac_save_LDFLAGS"
  
+     { $as_echo "$as_me:$LINENO: checking size of wchar_t is 2 bytes" >&5
+ $as_echo_n "checking size of wchar_t is 2 bytes... " >&6; }
+     if test "${ac_cv_small_wchar_t+set}" = set; then
+   $as_echo_n "(cached) " >&6
+ else
+   if test "$cross_compiling" = yes; then
+   { { $as_echo "$as_me:$LINENO: error: failed to compile test program" >&5
+ $as_echo "$as_me: error: failed to compile test program" >&2;}
+    { (exit 1); exit 1; }; }
+ else
+   cat >conftest.$ac_ext <<_ACEOF
+ /* confdefs.h.  */
+ _ACEOF
+ cat confdefs.h >>conftest.$ac_ext
+ cat >>conftest.$ac_ext <<_ACEOF
+ /* end confdefs.h.  */
+ 
+ #include <X11/Xlib.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ 		main()
+ 		{
+ 		  if (sizeof(wchar_t) <= 2)
+ 		    exit(1);
+ 		  exit(0);
+ 		}
+ _ACEOF
+ rm -f conftest$ac_exeext
+ if { (ac_try="$ac_link"
+ case "(($ac_try" in
+   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+   *) ac_try_echo=$ac_try;;
+ esac
+ eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+ $as_echo "$ac_try_echo") >&5
+   (eval "$ac_link") 2>&5
+   ac_status=$?
+   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+   { (case "(($ac_try" in
+   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+   *) ac_try_echo=$ac_try;;
+ esac
+ eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+ $as_echo "$ac_try_echo") >&5
+   (eval "$ac_try") 2>&5
+   ac_status=$?
+   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_small_wchar_t="no"
+ else
+   $as_echo "$as_me: program exited with status $ac_status" >&5
+ $as_echo "$as_me: failed program was:" >&5
+ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+ ( exit $ac_status )
+ ac_cv_small_wchar_t="yes"
+ fi
+ rm -rf conftest.dSYM
+ rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+ fi
+ 
+ 
+ fi
+ 
+     { $as_echo "$as_me:$LINENO: result: $ac_cv_small_wchar_t" >&5
+ $as_echo "$ac_cv_small_wchar_t" >&6; }
+     if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+       cat >>confdefs.h <<\_ACEOF
+ #define SMALL_WCHAR_T 1
+ _ACEOF
+ 
+     fi
+ 
    fi
  fi
  
***************
*** 15417,15423 ****
  
  
  
- 
  bcopy_test_prog='
  #include "confdefs.h"
  #ifdef HAVE_STRING_H
--- 15493,15498 ----
*** ../vim-7.2.183/src/config.h.in	2009-05-14 22:19:19.000000000 +0200
--- src/config.h.in	2009-05-21 15:44:24.000000000 +0200
***************
*** 39,44 ****
--- 39,47 ----
  /* Defined to the size of an int */
  #undef SIZEOF_INT
  
+ /* Define when wchar_t is only 2 bytes. */
+ #undef SMALL_WCHAR_T
+ 
  /*
   * If we cannot trust one of the following from the libraries, we use our
   * own safe but probably slower vim_memmove().
*** ../vim-7.2.183/src/configure.in	2009-05-21 15:19:59.000000000 +0200
--- src/configure.in	2009-05-21 16:04:56.000000000 +0200
***************
*** 1193,1198 ****
--- 1193,1220 ----
  
      LDFLAGS="$ac_save_LDFLAGS"
  
+     AC_MSG_CHECKING(size of wchar_t is 2 bytes)
+     AC_CACHE_VAL(ac_cv_small_wchar_t,
+ 	[AC_TRY_RUN([
+ #include <X11/Xlib.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ 		main()
+ 		{
+ 		  if (sizeof(wchar_t) <= 2)
+ 		    exit(1);
+ 		  exit(0);
+ 		}],
+ 		ac_cv_small_wchar_t="no",
+ 		ac_cv_small_wchar_t="yes",
+ 		AC_MSG_ERROR(failed to compile test program))])
+     AC_MSG_RESULT($ac_cv_small_wchar_t)
+     if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+       AC_DEFINE(SMALL_WCHAR_T)
+     fi
+ 
    fi
  fi
  
***************
*** 2881,2887 ****
  AC_MSG_RESULT($ac_cv_sizeof_int)
  AC_DEFINE_UNQUOTED(SIZEOF_INT, $ac_cv_sizeof_int)
  
- 
  dnl Check for memmove() before bcopy(), makes memmove() be used when both are
  dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
  
--- 2903,2908 ----
*** ../vim-7.2.183/src/gui_athena.c	2008-06-24 23:00:51.000000000 +0200
--- src/gui_athena.c	2009-05-21 16:39:43.000000000 +0200
***************
*** 86,95 ****
   * Scrollbar callback (XtNjumpProc) for when the scrollbar is dragged with the
   * left or middle mouse button.
   */
- /* ARGSUSED */
      static void
  gui_athena_scroll_cb_jump(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data, call_data;
  {
      scrollbar_T *sb, *sb_info;
--- 86,94 ----
   * Scrollbar callback (XtNjumpProc) for when the scrollbar is dragged with the
   * left or middle mouse button.
   */
      static void
  gui_athena_scroll_cb_jump(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data, call_data;
  {
      scrollbar_T *sb, *sb_info;
***************
*** 122,131 ****
   * Scrollbar callback (XtNscrollProc) for paging up or down with the left or
   * right mouse buttons.
   */
- /* ARGSUSED */
      static void
  gui_athena_scroll_cb_scroll(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data, call_data;
  {
      scrollbar_T *sb, *sb_info;
--- 121,129 ----
   * Scrollbar callback (XtNscrollProc) for paging up or down with the left or
   * right mouse buttons.
   */
      static void
  gui_athena_scroll_cb_scroll(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data, call_data;
  {
      scrollbar_T *sb, *sb_info;
***************
*** 492,498 ****
      if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
      {
  	if (menu->iconidx >= 0 && menu->iconidx
! 		   < (sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
  	    xpm = built_in_pixmaps[menu->iconidx];
  	else
  	    xpm = tb_blank_xpm;
--- 490,496 ----
      if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
      {
  	if (menu->iconidx >= 0 && menu->iconidx
! 	      < (int)(sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
  	    xpm = built_in_pixmaps[menu->iconidx];
  	else
  	    xpm = tb_blank_xpm;
***************
*** 763,769 ****
      XtGetValues(XtParent(widget), args, n);
  
      retval = num_children;
!     for (i = 0; i < num_children; ++i)
      {
  	Widget	current = children[i];
  	vimmenu_T	*menu = NULL;
--- 761,767 ----
      XtGetValues(XtParent(widget), args, n);
  
      retval = num_children;
!     for (i = 0; i < (int)num_children; ++i)
      {
  	Widget	current = children[i];
  	vimmenu_T	*menu = NULL;
***************
*** 780,790 ****
      return retval;
  }
  
- /* ARGSUSED */
      void
  gui_mch_add_menu(menu, idx)
      vimmenu_T	*menu;
!     int		idx;
  {
      char_u	*pullright_name;
      Dimension	height, space, border;
--- 778,787 ----
      return retval;
  }
  
      void
  gui_mch_add_menu(menu, idx)
      vimmenu_T	*menu;
!     int		idx UNUSED;
  {
      char_u	*pullright_name;
      Dimension	height, space, border;
***************
*** 869,875 ****
  	    XtVaGetValues(parent->submenu_id, XtNchildren, &children,
  					      XtNnumChildren, &num_children,
  					      NULL);
! 	    for (i = 0; i < num_children; ++i)
  	    {
  		XtVaSetValues(children[i],
  			      XtNrightMargin, puller_width,
--- 866,872 ----
  	    XtVaGetValues(parent->submenu_id, XtNchildren, &children,
  					      XtNnumChildren, &num_children,
  					      NULL);
! 	    for (i = 0; i < (int)num_children; ++i)
  	    {
  		XtVaSetValues(children[i],
  			      XtNrightMargin, puller_width,
***************
*** 913,919 ****
      XtVaGetValues(id, XtNchildren, &children,
  		      XtNnumChildren, &num_children,
  		      NULL);
!     for (i = 0; i < num_children; ++i)
      {
  	if (children[i] == ignore)
  	    continue;
--- 910,916 ----
      XtVaGetValues(id, XtNchildren, &children,
  		      XtNnumChildren, &num_children,
  		      NULL);
!     for (i = 0; i < (int)num_children; ++i)
      {
  	if (children[i] == ignore)
  	    continue;
***************
*** 1175,1185 ****
      return pname;
  }
  
- /* ARGSUSED */
      void
  gui_mch_add_menu_item(menu, idx)
      vimmenu_T	*menu;
!     int		idx;
  {
      vimmenu_T	*parent = menu->parent;
  
--- 1172,1181 ----
      return pname;
  }
  
      void
  gui_mch_add_menu_item(menu, idx)
      vimmenu_T	*menu;
!     int		idx UNUSED;
  {
      vimmenu_T	*parent = menu->parent;
  
***************
*** 1444,1450 ****
  		XtNchildren,	    &children,
  		XtNnumChildren,	    &numChildren,
  		NULL);
! 	for (i = 0; i < numChildren; i++)
  	{
  	    whgt = 0;
  
--- 1440,1446 ----
  		XtNchildren,	    &children,
  		XtNnumChildren,	    &numChildren,
  		NULL);
! 	for (i = 0; i < (int)numChildren; i++)
  	{
  	    whgt = 0;
  
***************
*** 1473,1482 ****
  #endif
  
  
- /* ARGSUSED */
      void
  gui_mch_toggle_tearoffs(enable)
!     int		enable;
  {
      /* no tearoff menus */
  }
--- 1469,1477 ----
  #endif
  
  
      void
  gui_mch_toggle_tearoffs(enable)
!     int		enable UNUSED;
  {
      /* no tearoff menus */
  }
***************
*** 1537,1543 ****
  	    else
  		get_left_margin = True;
  
! 	    for (i = 0; i < num_children; ++i)
  	    {
  		if (children[i] == menu->id)
  		    continue;
--- 1532,1538 ----
  	    else
  		get_left_margin = True;
  
! 	    for (i = 0; i < (int)num_children; ++i)
  	    {
  		if (children[i] == menu->id)
  		    continue;
***************
*** 1645,1655 ****
      }
  }
  
- /*ARGSUSED*/
      static void
  gui_athena_menu_timeout(client_data, id)
      XtPointer	    client_data;
!     XtIntervalId    *id;
  {
      Widget  w = (Widget)client_data;
      Widget  popup;
--- 1640,1649 ----
      }
  }
  
      static void
  gui_athena_menu_timeout(client_data, id)
      XtPointer	    client_data;
!     XtIntervalId    *id UNUSED;
  {
      Widget  w = (Widget)client_data;
      Widget  popup;
***************
*** 1678,1689 ****
   *
   * This is called when XtPopup() is called.
   */
- /*ARGSUSED*/
      static void
  gui_athena_popup_callback(w, client_data, call_data)
      Widget	w;
      XtPointer	client_data;
!     XtPointer	call_data;
  {
      /* Assumption: XtIsSubclass(XtParent(w),simpleMenuWidgetClass) */
      vimmenu_T	*menu = (vimmenu_T *)client_data;
--- 1672,1682 ----
   *
   * This is called when XtPopup() is called.
   */
      static void
  gui_athena_popup_callback(w, client_data, call_data)
      Widget	w;
      XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      /* Assumption: XtIsSubclass(XtParent(w),simpleMenuWidgetClass) */
      vimmenu_T	*menu = (vimmenu_T *)client_data;
***************
*** 1711,1717 ****
  		     NULL);
  }
  
- /* ARGSUSED */
      static void
  gui_athena_popdown_submenus_action(w, event, args, nargs)
      Widget	w;
--- 1704,1709 ----
***************
*** 1756,1762 ****
      return False;
  }
  
- /* ARGSUSED */
      static void
  gui_athena_delayed_arm_action(w, event, args, nargs)
      Widget	w;
--- 1748,1753 ----
***************
*** 1837,1843 ****
       * (XtIsSubclass(popup,simpleMenuWidgetClass) == True) */
  }
  
- /* ARGSUSED */
      void
  gui_mch_show_popupmenu(menu)
      vimmenu_T *menu;
--- 1828,1833 ----
***************
*** 2046,2060 ****
   * Put up a file requester.
   * Returns the selected name in allocated memory, or NULL for Cancel.
   */
- /* ARGSUSED */
      char_u *
  gui_mch_browse(saving, title, dflt, ext, initdir, filter)
!     int		saving;		/* select file to write */
!     char_u	*title;		/* not used (title for the window) */
!     char_u	*dflt;		/* not used (default name) */
!     char_u	*ext;		/* not used (extension added) */
      char_u	*initdir;	/* initial directory, NULL for current dir */
!     char_u	*filter;	/* not used (file name filter) */
  {
      Position x, y;
      char_u	dirbuf[MAXPATHL];
--- 2036,2049 ----
   * Put up a file requester.
   * Returns the selected name in allocated memory, or NULL for Cancel.
   */
      char_u *
  gui_mch_browse(saving, title, dflt, ext, initdir, filter)
!     int		saving UNUSED;	/* select file to write */
!     char_u	*title;		/* title for the window */
!     char_u	*dflt;		/* default name */
!     char_u	*ext UNUSED;	/* extension added */
      char_u	*initdir;	/* initial directory, NULL for current dir */
!     char_u	*filter UNUSED;	/* file name filter */
  {
      Position x, y;
      char_u	dirbuf[MAXPATHL];
***************
*** 2100,2112 ****
   * Callback function for the textfield.  When CR is hit this works like
   * hitting the "OK" button, ESC like "Cancel".
   */
- /* ARGSUSED */
      static void
  keyhit_callback(w, client_data, event, cont)
!     Widget		w;
!     XtPointer		client_data;
      XEvent		*event;
!     Boolean		*cont;
  {
      char	buf[2];
  
--- 2089,2100 ----
   * Callback function for the textfield.  When CR is hit this works like
   * hitting the "OK" button, ESC like "Cancel".
   */
      static void
  keyhit_callback(w, client_data, event, cont)
!     Widget		w UNUSED;
!     XtPointer		client_data UNUSED;
      XEvent		*event;
!     Boolean		*cont UNUSED;
  {
      char	buf[2];
  
***************
*** 2119,2130 ****
      }
  }
  
- /* ARGSUSED */
      static void
  butproc(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data;
!     XtPointer	call_data;
  {
      dialogStatus = (int)(long)client_data + 1;
  }
--- 2107,2117 ----
      }
  }
  
      static void
  butproc(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      dialogStatus = (int)(long)client_data + 1;
  }
***************
*** 2132,2158 ****
  /*
   * Function called when dialog window closed.
   */
- /*ARGSUSED*/
      static void
  dialog_wm_handler(w, client_data, event, dum)
!     Widget	w;
!     XtPointer	client_data;
      XEvent	*event;
!     Boolean	*dum;
  {
      if (event->type == ClientMessage
! 	    && ((XClientMessageEvent *)event)->data.l[0] == dialogatom)
  	dialogStatus = 0;
  }
  
- /* ARGSUSED */
      int
  gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield)
!     int		type;
      char_u	*title;
      char_u	*message;
      char_u	*buttons;
!     int		dfltbutton;
      char_u	*textfield;
  {
      char_u		*buts;
--- 2119,2143 ----
  /*
   * Function called when dialog window closed.
   */
      static void
  dialog_wm_handler(w, client_data, event, dum)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      if (event->type == ClientMessage
! 	    && (Atom)((XClientMessageEvent *)event)->data.l[0] == dialogatom)
  	dialogStatus = 0;
  }
  
      int
  gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield)
!     int		type UNUSED;
      char_u	*title;
      char_u	*message;
      char_u	*buttons;
!     int		dfltbutton UNUSED;
      char_u	*textfield;
  {
      char_u		*buts;
*** ../vim-7.2.183/src/gui_x11.c	2009-02-24 04:11:07.000000000 +0100
--- src/gui_x11.c	2009-05-21 16:47:02.000000000 +0200
***************
*** 570,591 ****
   * Call-back routines.
   */
  
- /* ARGSUSED */
      static void
  gui_x11_timer_cb(timed_out, interval_id)
      XtPointer	    timed_out;
!     XtIntervalId    *interval_id;
  {
      *((int *)timed_out) = TRUE;
  }
  
- /* ARGSUSED */
      static void
  gui_x11_visibility_cb(w, dud, event, dum)
!     Widget	w;
!     XtPointer	dud;
      XEvent	*event;
!     Boolean	*dum;
  {
      if (event->type != VisibilityNotify)
  	return;
--- 570,589 ----
   * Call-back routines.
   */
  
      static void
  gui_x11_timer_cb(timed_out, interval_id)
      XtPointer	    timed_out;
!     XtIntervalId    *interval_id UNUSED;
  {
      *((int *)timed_out) = TRUE;
  }
  
      static void
  gui_x11_visibility_cb(w, dud, event, dum)
!     Widget	w UNUSED;
!     XtPointer	dud UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      if (event->type != VisibilityNotify)
  	return;
***************
*** 603,615 ****
      gui_mch_update();
  }
  
- /* ARGSUSED */
      static void
  gui_x11_expose_cb(w, dud, event, dum)
!     Widget	w;
!     XtPointer	dud;
      XEvent	*event;
!     Boolean	*dum;
  {
      XExposeEvent	*gevent;
      int			new_x;
--- 601,612 ----
      gui_mch_update();
  }
  
      static void
  gui_x11_expose_cb(w, dud, event, dum)
!     Widget	w UNUSED;
!     XtPointer	dud UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      XExposeEvent	*gevent;
      int			new_x;
***************
*** 680,692 ****
  }
  #endif
  
- /* ARGSUSED */
      static void
  gui_x11_resize_window_cb(w, dud, event, dum)
!     Widget	w;
!     XtPointer	dud;
      XEvent	*event;
!     Boolean	*dum;
  {
      static int lastWidth, lastHeight;
  
--- 677,688 ----
  }
  #endif
  
      static void
  gui_x11_resize_window_cb(w, dud, event, dum)
!     Widget	w UNUSED;
!     XtPointer	dud UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      static int lastWidth, lastHeight;
  
***************
*** 727,761 ****
  #endif
  }
  
- /* ARGSUSED */
      static void
  gui_x11_focus_change_cb(w, data, event, dum)
!     Widget	w;
!     XtPointer	data;
      XEvent	*event;
!     Boolean	*dum;
  {
      gui_focus_change(event->type == FocusIn);
  }
  
- /* ARGSUSED */
      static void
  gui_x11_enter_cb(w, data, event, dum)
!     Widget	w;
!     XtPointer	data;
!     XEvent	*event;
!     Boolean	*dum;
  {
      gui_focus_change(TRUE);
  }
  
- /* ARGSUSED */
      static void
  gui_x11_leave_cb(w, data, event, dum)
!     Widget	w;
!     XtPointer	data;
!     XEvent	*event;
!     Boolean	*dum;
  {
      gui_focus_change(FALSE);
  }
--- 723,754 ----
  #endif
  }
  
      static void
  gui_x11_focus_change_cb(w, data, event, dum)
!     Widget	w UNUSED;
!     XtPointer	data UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      gui_focus_change(event->type == FocusIn);
  }
  
      static void
  gui_x11_enter_cb(w, data, event, dum)
!     Widget	w UNUSED;
!     XtPointer	data UNUSED;
!     XEvent	*event UNUSED;
!     Boolean	*dum UNUSED;
  {
      gui_focus_change(TRUE);
  }
  
      static void
  gui_x11_leave_cb(w, data, event, dum)
!     Widget	w UNUSED;
!     XtPointer	data UNUSED;
!     XEvent	*event UNUSED;
!     Boolean	*dum UNUSED;
  {
      gui_focus_change(FALSE);
  }
***************
*** 766,778 ****
  # endif
  #endif
  
- /* ARGSUSED */
      void
  gui_x11_key_hit_cb(w, dud, event, dum)
!     Widget	w;
!     XtPointer	dud;
      XEvent	*event;
!     Boolean	*dum;
  {
      XKeyPressedEvent	*ev_press;
  #ifdef FEAT_XIM
--- 759,770 ----
  # endif
  #endif
  
      void
  gui_x11_key_hit_cb(w, dud, event, dum)
!     Widget	w UNUSED;
!     XtPointer	dud UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      XKeyPressedEvent	*ev_press;
  #ifdef FEAT_XIM
***************
*** 1078,1090 ****
  #endif
  }
  
- /* ARGSUSED */
      static void
  gui_x11_mouse_cb(w, dud, event, dum)
!     Widget	w;
!     XtPointer	dud;
      XEvent	*event;
!     Boolean	*dum;
  {
      static XtIntervalId timer = (XtIntervalId)0;
      static int	timed_out = TRUE;
--- 1070,1081 ----
  #endif
  }
  
      static void
  gui_x11_mouse_cb(w, dud, event, dum)
!     Widget	w UNUSED;
!     XtPointer	dud UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      static XtIntervalId timer = (XtIntervalId)0;
      static int	timed_out = TRUE;
***************
*** 1210,1220 ****
      while (arg < *argc)
      {
  	/* Look for argv[arg] in cmdline_options[] table */
! 	for (i = 0; i < XtNumber(cmdline_options); i++)
  	    if (strcmp(argv[arg], cmdline_options[i].option) == 0)
  		break;
  
! 	if (i < XtNumber(cmdline_options))
  	{
  	    /* Remember finding "-rv" or "-reverse" */
  	    if (strcmp("-rv", argv[arg]) == 0
--- 1201,1211 ----
      while (arg < *argc)
      {
  	/* Look for argv[arg] in cmdline_options[] table */
! 	for (i = 0; i < (int)XtNumber(cmdline_options); i++)
  	    if (strcmp(argv[arg], cmdline_options[i].option) == 0)
  		break;
  
! 	if (i < (int)XtNumber(cmdline_options))
  	{
  	    /* Remember finding "-rv" or "-reverse" */
  	    if (strcmp("-rv", argv[arg]) == 0
***************
*** 1319,1330 ****
  
  static void local_xsmp_handle_requests __ARGS((XtPointer c, int *s, XtInputId *i));
  
- /*ARGSUSED*/
      static void
  local_xsmp_handle_requests(c, s, i)
!     XtPointer	c;
!     int		*s;
!     XtInputId	*i;
  {
      if (xsmp_handle_requests() == FAIL)
  	XtRemoveInput(_xsmp_xtinputid);
--- 1310,1320 ----
  
  static void local_xsmp_handle_requests __ARGS((XtPointer c, int *s, XtInputId *i));
  
      static void
  local_xsmp_handle_requests(c, s, i)
!     XtPointer	c UNUSED;
!     int		*s UNUSED;
!     XtInputId	*i UNUSED;
  {
      if (xsmp_handle_requests() == FAIL)
  	XtRemoveInput(_xsmp_xtinputid);
***************
*** 1438,1444 ****
  	    Columns = w;
  	if (mask & HeightValue)
  	{
! 	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
  		p_window = h - 1;
  	    Rows = h;
  	}
--- 1428,1434 ----
  	    Columns = w;
  	if (mask & HeightValue)
  	{
! 	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
  		p_window = h - 1;
  	    Rows = h;
  	}
***************
*** 1753,1762 ****
  }
  #endif
  
- /*ARGSUSED*/
      void
  gui_mch_exit(rc)
!     int		rc;
  {
  #if 0
      /* Lesstif gives an error message here, and so does Solaris.  The man page
--- 1743,1751 ----
  }
  #endif
  
      void
  gui_mch_exit(rc)
!     int		rc UNUSED;
  {
  #if 0
      /* Lesstif gives an error message here, and so does Solaris.  The man page
***************
*** 1799,1805 ****
  	NULL);
  }
  
- /*ARGSUSED*/
      void
  gui_mch_set_shellsize(width, height, min_width, min_height,
  		    base_width, base_height, direction)
--- 1788,1793 ----
***************
*** 1809,1815 ****
      int		min_height;
      int		base_width;
      int		base_height;
!     int		direction;
  {
  #ifdef FEAT_XIM
      height += xim_get_status_area_height(),
--- 1797,1803 ----
      int		min_height;
      int		base_width;
      int		base_height;
!     int		direction UNUSED;
  {
  #ifdef FEAT_XIM
      height += xim_get_status_area_height(),
***************
*** 1847,1857 ****
   * If "fontset" is TRUE, load the "font_name" as a fontset.
   * Return FAIL if the font could not be loaded, OK otherwise.
   */
- /*ARGSUSED*/
      int
  gui_mch_init_font(font_name, do_fontset)
      char_u	*font_name;
!     int		do_fontset;
  {
      XFontStruct	*font = NULL;
  
--- 1835,1844 ----
   * If "fontset" is TRUE, load the "font_name" as a fontset.
   * Return FAIL if the font could not be loaded, OK otherwise.
   */
      int
  gui_mch_init_font(font_name, do_fontset)
      char_u	*font_name;
!     int		do_fontset UNUSED;
  {
      XFontStruct	*font = NULL;
  
***************
*** 2029,2038 ****
   * Return the name of font "font" in allocated memory.
   * Don't know how to get the actual name, thus use the provided name.
   */
- /*ARGSUSED*/
      char_u *
  gui_mch_get_fontname(font, name)
!     GuiFont font;
      char_u  *name;
  {
      if (name == NULL)
--- 2016,2024 ----
   * Return the name of font "font" in allocated memory.
   * Don't know how to get the actual name, thus use the provided name.
   */
      char_u *
  gui_mch_get_fontname(font, name)
!     GuiFont font UNUSED;
      char_u  *name;
  {
      if (name == NULL)
***************
*** 2521,2527 ****
  {
      int			i;
      int			offset;
!     const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
  
      XSetForeground(gui.dpy, gui.text_gc, prev_sp_color);
      for (i = FILL_X(col); i < FILL_X(col + cells); ++i)
--- 2507,2513 ----
  {
      int			i;
      int			offset;
!     static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
  
      XSetForeground(gui.dpy, gui.text_gc, prev_sp_color);
      for (i = FILL_X(col); i < FILL_X(col + cells); ++i)
***************
*** 2569,2576 ****
  # ifdef FEAT_XFONTSET
  	    if (current_fontset != NULL)
  	    {
! 		if (c >= 0x10000 && sizeof(wchar_t) <= 2)
  		    c = 0xbf;		/* show chars > 0xffff as ? */
  		((wchar_t *)buf)[wlen] = c;
  	    }
  	    else
--- 2555,2564 ----
  # ifdef FEAT_XFONTSET
  	    if (current_fontset != NULL)
  	    {
! #  ifdef SMALL_WCHAR_T
! 		if (c >= 0x10000)
  		    c = 0xbf;		/* show chars > 0xffff as ? */
+ #  endif
  		((wchar_t *)buf)[wlen] = c;
  	    }
  	    else
***************
*** 3136,3146 ****
      /* Nothing to do in X */
  }
  
- /* ARGSUSED */
      void
  gui_x11_menu_cb(w, client_data, call_data)
!     Widget	w;
!     XtPointer	client_data, call_data;
  {
      gui_menu_cb((vimmenu_T *)client_data);
  }
--- 3124,3134 ----
      /* Nothing to do in X */
  }
  
      void
  gui_x11_menu_cb(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      gui_menu_cb((vimmenu_T *)client_data);
  }
***************
*** 3153,3165 ****
   * Function called when window closed.	Works like ":qa".
   * Should put up a requester!
   */
- /*ARGSUSED*/
      static void
  gui_x11_wm_protocol_handler(w, client_data, event, dum)
!     Widget	w;
!     XtPointer	client_data;
      XEvent	*event;
!     Boolean	*dum;
  {
      /*
       * Only deal with Client messages.
--- 3141,3152 ----
   * Function called when window closed.	Works like ":qa".
   * Should put up a requester!
   */
      static void
  gui_x11_wm_protocol_handler(w, client_data, event, dum)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      /*
       * Only deal with Client messages.
***************
*** 3172,3178 ****
       * exit.  That can be cancelled though, thus Vim shouldn't exit here.
       * Just sync our swap files.
       */
!     if (((XClientMessageEvent *)event)->data.l[0] ==
  						  wm_atoms[SAVE_YOURSELF_IDX])
      {
  	out_flush();
--- 3159,3165 ----
       * exit.  That can be cancelled though, thus Vim shouldn't exit here.
       * Just sync our swap files.
       */
!     if ((Atom)((XClientMessageEvent *)event)->data.l[0] ==
  						  wm_atoms[SAVE_YOURSELF_IDX])
      {
  	out_flush();
***************
*** 3185,3191 ****
  	return;
      }
  
!     if (((XClientMessageEvent *)event)->data.l[0] !=
  						  wm_atoms[DELETE_WINDOW_IDX])
  	return;
  
--- 3172,3178 ----
  	return;
      }
  
!     if ((Atom)((XClientMessageEvent *)event)->data.l[0] !=
  						  wm_atoms[DELETE_WINDOW_IDX])
  	return;
  
***************
*** 3196,3208 ****
  /*
   * Function called when property changed. Check for incoming commands
   */
- /*ARGSUSED*/
      static void
  gui_x11_send_event_handler(w, client_data, event, dum)
!     Widget	w;
!     XtPointer	client_data;
      XEvent	*event;
!     Boolean	*dum;
  {
      XPropertyEvent *e = (XPropertyEvent *) event;
  
--- 3183,3194 ----
  /*
   * Function called when property changed. Check for incoming commands
   */
      static void
  gui_x11_send_event_handler(w, client_data, event, dum)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
      XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      XPropertyEvent *e = (XPropertyEvent *) event;
  
***************
*** 3277,3287 ****
      }
  }
  
- /* ARGSUSED */
      static void
  gui_x11_blink_cb(timed_out, interval_id)
!     XtPointer	    timed_out;
!     XtIntervalId    *interval_id;
  {
      if (blink_state == BLINK_ON)
      {
--- 3263,3272 ----
      }
  }
  
      static void
  gui_x11_blink_cb(timed_out, interval_id)
!     XtPointer	    timed_out UNUSED;
!     XtIntervalId    *interval_id UNUSED;
  {
      if (blink_state == BLINK_ON)
      {
*** ../vim-7.2.183/src/gui.c	2009-05-17 16:23:20.000000000 +0200
--- src/gui.c	2009-05-21 16:37:39.000000000 +0200
***************
*** 3119,3125 ****
   */
      void
  gui_init_which_components(oldval)
!     char_u	*oldval;
  {
  #ifdef FEAT_MENU
      static int	prev_menu_is_active = -1;
--- 3119,3125 ----
   */
      void
  gui_init_which_components(oldval)
!     char_u	*oldval UNUSED;
  {
  #ifdef FEAT_MENU
      static int	prev_menu_is_active = -1;
***************
*** 4668,4675 ****
   */
      static win_T *
  xy2win(x, y)
!     int		x;
!     int		y;
  {
  #ifdef FEAT_WINDOWS
      int		row;
--- 4668,4675 ----
   */
      static win_T *
  xy2win(x, y)
!     int		x UNUSED;
!     int		y UNUSED;
  {
  #ifdef FEAT_WINDOWS
      int		row;
***************
*** 5121,5128 ****
   */
      void
  gui_handle_drop(x, y, modifiers, fnames, count)
!     int		x;
!     int		y;
      int_u	modifiers;
      char_u	**fnames;
      int		count;
--- 5121,5128 ----
   */
      void
  gui_handle_drop(x, y, modifiers, fnames, count)
!     int		x UNUSED;
!     int		y UNUSED;
      int_u	modifiers;
      char_u	**fnames;
      int		count;
*** ../vim-7.2.183/src/gui_beval.c	2009-05-17 16:23:20.000000000 +0200
--- src/gui_beval.c	2009-05-21 15:03:02.000000000 +0200
***************
*** 18,24 ****
      void
  general_beval_cb(beval, state)
      BalloonEval *beval;
!     int state;
  {
      win_T	*wp;
      int		col;
--- 18,24 ----
      void
  general_beval_cb(beval, state)
      BalloonEval *beval;
!     int		state UNUSED;
  {
      win_T	*wp;
      int		col;
***************
*** 726,735 ****
   */
      static void
  pointerEventEH(w, client_data, event, unused)
!     Widget	w;
      XtPointer	client_data;
      XEvent	*event;
!     Boolean	*unused;
  {
      BalloonEval *beval = (BalloonEval *)client_data;
      pointerEvent(beval, event);
--- 726,735 ----
   */
      static void
  pointerEventEH(w, client_data, event, unused)
!     Widget	w UNUSED;
      XtPointer	client_data;
      XEvent	*event;
!     Boolean	*unused UNUSED;
  {
      BalloonEval *beval = (BalloonEval *)client_data;
      pointerEvent(beval, event);
***************
*** 877,883 ****
      static void
  timerRoutine(dx, id)
      XtPointer	    dx;
!     XtIntervalId    *id;
  {
      BalloonEval *beval = (BalloonEval *)dx;
  
--- 877,883 ----
      static void
  timerRoutine(dx, id)
      XtPointer	    dx;
!     XtIntervalId    *id UNUSED;
  {
      BalloonEval *beval = (BalloonEval *)dx;
  
*** ../vim-7.2.183/src/gui_at_sb.c	2008-11-28 21:26:50.000000000 +0100
--- src/gui_at_sb.c	2009-05-21 16:38:53.000000000 +0200
***************
*** 198,207 ****
      /* extension	*/  NULL
    },
    { /* simple fields */
!     /* change_sensitive	*/  XtInheritChangeSensitive
    },
    { /* scrollbar fields */
!     /* ignore	    */	0
    }
  };
  
--- 198,210 ----
      /* extension	*/  NULL
    },
    { /* simple fields */
!     /* change_sensitive	*/  XtInheritChangeSensitive,
! #ifndef OLDXAW
!     /* extension */	    NULL
! #endif
    },
    { /* scrollbar fields */
!     /* empty	    */	    0
    }
  };
  
***************
*** 241,247 ****
  
      if (bottom <= 0 || bottom <= top)
  	return;
!     if ((sw = sbw->scrollbar.shadow_width) < 0)
  	sw = 0;
      margin = MARGIN (sbw);
      floor = sbw->scrollbar.length - margin + 2;
--- 244,251 ----
  
      if (bottom <= 0 || bottom <= top)
  	return;
!     sw = sbw->scrollbar.shadow_width;
!     if (sw < 0)
  	sw = 0;
      margin = MARGIN (sbw);
      floor = sbw->scrollbar.length - margin + 2;
***************
*** 516,528 ****
      }
  }
  
- /* ARGSUSED */
      static void
  Initialize(request, new, args, num_args)
!     Widget	request;	/* what the client asked for */
      Widget	new;		/* what we're going to give him */
!     ArgList	args;
!     Cardinal	*num_args;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) new;
  
--- 520,531 ----
      }
  }
  
      static void
  Initialize(request, new, args, num_args)
!     Widget	request UNUSED;	/* what the client asked for */
      Widget	new;		/* what we're going to give him */
!     ArgList	args UNUSED;
!     Cardinal	*num_args UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) new;
  
***************
*** 556,569 ****
  	(w, valueMask, attributes);
  }
  
- /* ARGSUSED */
      static Boolean
  SetValues(current, request, desired, args, num_args)
!     Widget  current,	    /* what I am */
! 	    request,	    /* what he wants me to be */
! 	    desired;	    /* what I will become */
!     ArgList args;
!     Cardinal *num_args;
  {
      ScrollbarWidget	sbw = (ScrollbarWidget) current;
      ScrollbarWidget	dsbw = (ScrollbarWidget) desired;
--- 559,571 ----
  	(w, valueMask, attributes);
  }
  
      static Boolean
  SetValues(current, request, desired, args, num_args)
!     Widget  current;	    /* what I am */
!     Widget  request UNUSED; /* what he wants me to be */
!     Widget  desired;	    /* what I will become */
!     ArgList args UNUSED;
!     Cardinal *num_args UNUSED;
  {
      ScrollbarWidget	sbw = (ScrollbarWidget) current;
      ScrollbarWidget	dsbw = (ScrollbarWidget) desired;
***************
*** 609,615 ****
  }
  
  
- /* ARGSUSED */
      static void
  Redisplay(w, event, region)
      Widget w;
--- 611,616 ----
***************
*** 789,799 ****
      }
  }
  
- /* ARGSUSED */
      static void
  RepeatNotify(client_data, idp)
      XtPointer client_data;
!     XtIntervalId *idp;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) client_data;
      int		    call_data;
--- 790,799 ----
      }
  }
  
      static void
  RepeatNotify(client_data, idp)
      XtPointer client_data;
!     XtIntervalId *idp UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) client_data;
      int		    call_data;
***************
*** 839,884 ****
      return (num < small) ? small : ((num > big) ? big : num);
  }
  
- /* ARGSUSED */
      static void
  ScrollOneLineUp(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params;
!     Cardinal	*num_params;
  {
      ScrollSome(w, event, -ONE_LINE_DATA);
  }
  
- /* ARGSUSED */
      static void
  ScrollOneLineDown(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params;
!     Cardinal	*num_params;
  {
      ScrollSome(w, event, ONE_LINE_DATA);
  }
  
- /* ARGSUSED */
      static void
  ScrollPageDown(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params;
!     Cardinal	*num_params;
  {
      ScrollSome(w, event, ONE_PAGE_DATA);
  }
  
- /* ARGSUSED */
      static void
  ScrollPageUp(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params;
!     Cardinal	*num_params;
  {
      ScrollSome(w, event, -ONE_PAGE_DATA);
  }
--- 839,880 ----
      return (num < small) ? small : ((num > big) ? big : num);
  }
  
      static void
  ScrollOneLineUp(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollSome(w, event, -ONE_LINE_DATA);
  }
  
      static void
  ScrollOneLineDown(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollSome(w, event, ONE_LINE_DATA);
  }
  
      static void
  ScrollPageDown(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollSome(w, event, ONE_PAGE_DATA);
  }
  
      static void
  ScrollPageUp(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollSome(w, event, -ONE_PAGE_DATA);
  }
***************
*** 901,913 ****
      XtCallCallbacks(w, XtNscrollProc, (XtPointer)call_data);
  }
  
- /* ARGSUSED */
      static void
  NotifyScroll(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params;
!     Cardinal	*num_params;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      Position	    x, y, loc;
--- 897,908 ----
      XtCallCallbacks(w, XtNscrollProc, (XtPointer)call_data);
  }
  
      static void
  NotifyScroll(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      Position	    x, y, loc;
***************
*** 991,1003 ****
  					   delay, RepeatNotify, (XtPointer)w);
  }
  
- /* ARGSUSED */
      static void
  EndScroll(w, event, params, num_params)
      Widget w;
!     XEvent *event;	/* unused */
!     String *params;	/* unused */
!     Cardinal *num_params;   /* unused */
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
  
--- 986,997 ----
  					   delay, RepeatNotify, (XtPointer)w);
  }
  
      static void
  EndScroll(w, event, params, num_params)
      Widget w;
!     XEvent *event UNUSED;
!     String *params UNUSED;
!     Cardinal *num_params UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
  
***************
*** 1023,1035 ****
      return PICKLENGTH(sbw, x / width, y / height);
  }
  
- /* ARGSUSED */
      static void
  MoveThumb(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params;	/* unused */
!     Cardinal	*num_params;	/* unused */
  {
      ScrollbarWidget	sbw = (ScrollbarWidget)w;
      Position		x, y;
--- 1017,1028 ----
      return PICKLENGTH(sbw, x / width, y / height);
  }
  
      static void
  MoveThumb(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollbarWidget	sbw = (ScrollbarWidget)w;
      Position		x, y;
***************
*** 1069,1081 ****
  }
  
  
- /* ARGSUSED */
      static void
  NotifyThumb(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params;	/* unused */
!     Cardinal	*num_params;	/* unused */
  {
      ScrollbarWidget sbw = (ScrollbarWidget)w;
      /* Use a union to avoid a warning for the weird conversion from float to
--- 1062,1073 ----
  }
  
  
      static void
  NotifyThumb(w, event, params, num_params)
      Widget	w;
      XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget)w;
      /* Use a union to avoid a warning for the weird conversion from float to
***************
*** 1096,1102 ****
      XtCallCallbacks(w, XtNjumpProc, (XtPointer)&sbw->scrollbar.top);
  }
  
- /* ARGSUSED */
      static void
  AllocTopShadowGC(w)
      Widget w;
--- 1088,1093 ----
***************
*** 1110,1116 ****
      sbw->scrollbar.top_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
  }
  
- /* ARGSUSED */
      static void
  AllocBotShadowGC(w)
      Widget w;
--- 1101,1106 ----
***************
*** 1124,1134 ****
      sbw->scrollbar.bot_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
  }
  
- /* ARGSUSED */
      static void
  _Xaw3dDrawShadows(gw, event, region, out)
      Widget  gw;
!     XEvent  *event;
      Region  region;
      int	    out;
  {
--- 1114,1123 ----
      sbw->scrollbar.bot_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
  }
  
      static void
  _Xaw3dDrawShadows(gw, event, region, out)
      Widget  gw;
!     XEvent  *event UNUSED;
      Region  region;
      int	    out;
  {
*** ../vim-7.2.183/src/gui_at_fs.c	2006-05-13 15:51:07.000000000 +0200
--- src/gui_at_fs.c	2009-05-21 16:38:36.000000000 +0200
***************
*** 829,835 ****
      text.format = FMT8BIT;
  
  #ifdef XtNinternational
!     if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
      {
  	XawTextReplace(selFileField, (XawTextPosition)0,
  				    (XawTextPosition)WcsLen((wchar_t *)&SFtextBuffer[0]), &text);
--- 829,835 ----
      text.format = FMT8BIT;
  
  #ifdef XtNinternational
!     if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
      {
  	XawTextReplace(selFileField, (XawTextPosition)0,
  				    (XawTextPosition)WcsLen((wchar_t *)&SFtextBuffer[0]), &text);
***************
*** 851,867 ****
  #endif
  }
  
- /* ARGSUSED */
      static void
  SFbuttonPressList(w, n, event)
!     Widget		w;
!     int			n;
!     XButtonPressedEvent	*event;
  {
      SFbuttonPressed = 1;
  }
  
- /* ARGSUSED */
      static void
  SFbuttonReleaseList(w, n, event)
      Widget		 w;
--- 851,865 ----
  #endif
  }
  
      static void
  SFbuttonPressList(w, n, event)
!     Widget		w UNUSED;
!     int			n UNUSED;
!     XButtonPressedEvent	*event UNUSED;
  {
      SFbuttonPressed = 1;
  }
  
      static void
  SFbuttonReleaseList(w, n, event)
      Widget		 w;
***************
*** 989,999 ****
      return result;
  }
  
- /* ARGSUSED */
      static void
  SFdirModTimer(cl, id)
!     XtPointer		cl;
!     XtIntervalId	*id;
  {
      static int		n = -1;
      static int		f = 0;
--- 987,996 ----
      return result;
  }
  
      static void
  SFdirModTimer(cl, id)
!     XtPointer		cl UNUSED;
!     XtIntervalId	*id UNUSED;
  {
      static int		n = -1;
      static int		f = 0;
***************
*** 1596,1606 ****
  
  static void SFscrollTimer __ARGS((XtPointer p, XtIntervalId *id));
  
- /* ARGSUSED */
      static void
  SFscrollTimer(p, id)
      XtPointer		p;
!     XtIntervalId	*id;
  {
      SFDir	*dir;
      int		save;
--- 1593,1602 ----
  
  static void SFscrollTimer __ARGS((XtPointer p, XtIntervalId *id));
  
      static void
  SFscrollTimer(p, id)
      XtPointer		p;
!     XtIntervalId	*id UNUSED;
  {
      SFDir	*dir;
      int		save;
***************
*** 1695,1704 ****
      }
  }
  
- /* ARGSUSED */
      static void
  SFenterList(w, n, event)
!     Widget		w;
      int			n;
      XEnterWindowEvent	*event;
  {
--- 1691,1699 ----
      }
  }
  
      static void
  SFenterList(w, n, event)
!     Widget		w UNUSED;
      int			n;
      XEnterWindowEvent	*event;
  {
***************
*** 1719,1730 ****
      }
  }
  
- /* ARGSUSED */
      static void
  SFleaveList(w, n, event)
!     Widget	w;
      int		n;
!     XEvent	*event;
  {
      if (SFcurrentInvert[n] != -1)
      {
--- 1714,1724 ----
      }
  }
  
      static void
  SFleaveList(w, n, event)
!     Widget	w UNUSED;
      int		n;
!     XEvent	*event UNUSED;
  {
      if (SFcurrentInvert[n] != -1)
      {
***************
*** 1733,1742 ****
      }
  }
  
- /* ARGSUSED */
      static void
  SFmotionList(w, n, event)
!     Widget		w;
      int			n;
      XMotionEvent	*event;
  {
--- 1727,1735 ----
      }
  }
  
      static void
  SFmotionList(w, n, event)
!     Widget		w UNUSED;
      int			n;
      XMotionEvent	*event;
  {
***************
*** 1754,1760 ****
      }
  }
  
- /* ARGSUSED */
      static void
  SFvFloatSliderMovedCallback(w, n, fnew)
      Widget	w;
--- 1747,1752 ----
***************
*** 1767,1776 ****
      SFvSliderMovedCallback(w, (int)(long)n, nw);
  }
  
- /* ARGSUSED */
      static void
  SFvSliderMovedCallback(w, n, nw)
!     Widget	w;
      int		n;
      int		nw;
  {
--- 1759,1767 ----
      SFvSliderMovedCallback(w, (int)(long)n, nw);
  }
  
      static void
  SFvSliderMovedCallback(w, n, nw)
!     Widget	w UNUSED;
      int		n;
      int		nw;
  {
***************
*** 1853,1862 ****
      }
  }
  
- /* ARGSUSED */
      static void
  SFvAreaSelectedCallback(w, n, pnew)
!     Widget		w;
      XtPointer	n;
      XtPointer	pnew;
  {
--- 1844,1852 ----
      }
  }
  
      static void
  SFvAreaSelectedCallback(w, n, pnew)
!     Widget	w;
      XtPointer	n;
      XtPointer	pnew;
  {
***************
*** 1914,1923 ****
      SFvSliderMovedCallback(w, (int)(long)n, nw);
  }
  
- /* ARGSUSED */
      static void
  SFhSliderMovedCallback(w, n, nw)
!     Widget	w;
      XtPointer	n;
      XtPointer	nw;
  {
--- 1904,1912 ----
      SFvSliderMovedCallback(w, (int)(long)n, nw);
  }
  
      static void
  SFhSliderMovedCallback(w, n, nw)
!     Widget	w UNUSED;
      XtPointer	n;
      XtPointer	nw;
  {
***************
*** 1933,1942 ****
      SFdrawList((int)(long)n, SF_DO_NOT_SCROLL);
  }
  
- /* ARGSUSED */
      static void
  SFhAreaSelectedCallback(w, n, pnew)
!     Widget		w;
      XtPointer	n;
      XtPointer	pnew;
  {
--- 1922,1930 ----
      SFdrawList((int)(long)n, SF_DO_NOT_SCROLL);
  }
  
      static void
  SFhAreaSelectedCallback(w, n, pnew)
!     Widget	w;
      XtPointer	n;
      XtPointer	pnew;
  {
***************
*** 1994,2004 ****
      }
  }
  
- /* ARGSUSED */
      static void
  SFpathSliderMovedCallback(w, client_data, nw)
!     Widget		w;
!     XtPointer	client_data;
      XtPointer	nw;
  {
      SFDir		*dir;
--- 1982,1991 ----
      }
  }
  
      static void
  SFpathSliderMovedCallback(w, client_data, nw)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
      XtPointer	nw;
  {
      SFDir		*dir;
***************
*** 2031,2041 ****
      XawTextSetInsertionPoint(selFileField, pos);
  }
  
- /* ARGSUSED */
      static void
  SFpathAreaSelectedCallback(w, client_data, pnew)
      Widget	w;
!     XtPointer	client_data;
      XtPointer	pnew;
  {
      int		nw = (int)(long)pnew;
--- 2018,2027 ----
      XawTextSetInsertionPoint(selFileField, pos);
  }
  
      static void
  SFpathAreaSelectedCallback(w, client_data, pnew)
      Widget	w;
!     XtPointer	client_data UNUSED;
      XtPointer	pnew;
  {
      int		nw = (int)(long)pnew;
***************
*** 2206,2218 ****
  
  static void SFexposeList __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
  
- /* ARGSUSED */
      static void
  SFexposeList(w, n, event, cont)
!     Widget	w;
      XtPointer	n;
      XEvent	*event;
!     Boolean	*cont;
  {
      if ((event->type == NoExpose) || event->xexpose.count)
  	return;
--- 2192,2203 ----
  
  static void SFexposeList __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
  
      static void
  SFexposeList(w, n, event, cont)
!     Widget	w UNUSED;
      XtPointer	n;
      XEvent	*event;
!     Boolean	*cont UNUSED;
  {
      if ((event->type == NoExpose) || event->xexpose.count)
  	return;
***************
*** 2222,2234 ****
  
  static void SFmodVerifyCallback __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *cont));
  
- /* ARGSUSED */
      static void
  SFmodVerifyCallback(w, client_data, event, cont)
!     Widget		w;
!     XtPointer		client_data;
      XEvent		*event;
!     Boolean		*cont;
  {
      char	buf[2];
  
--- 2207,2218 ----
  
  static void SFmodVerifyCallback __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *cont));
  
      static void
  SFmodVerifyCallback(w, client_data, event, cont)
!     Widget		w UNUSED;
!     XtPointer		client_data UNUSED;
      XEvent		*event;
!     Boolean		*cont UNUSED;
  {
      char	buf[2];
  
***************
*** 2241,2251 ****
  
  static void SFokCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
  
- /* ARGSUSED */
      static void
  SFokCallback(w, cl, cd)
!     Widget	w;
!     XtPointer	cl, cd;
  {
      SFstatus = SEL_FILE_OK;
  }
--- 2225,2235 ----
  
  static void SFokCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
  
      static void
  SFokCallback(w, cl, cd)
!     Widget	w UNUSED;
!     XtPointer	cl UNUSED;
!     XtPointer	cd UNUSED;
  {
      SFstatus = SEL_FILE_OK;
  }
***************
*** 2258,2268 ****
  
  static void SFcancelCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
  
- /* ARGSUSED */
      static void
  SFcancelCallback(w, cl, cd)
!     Widget	w;
!     XtPointer	cl, cd;
  {
      SFstatus = SEL_FILE_CANCEL;
  }
--- 2242,2252 ----
  
  static void SFcancelCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
  
      static void
  SFcancelCallback(w, cl, cd)
!     Widget	w UNUSED;
!     XtPointer	cl UNUSED;
!     XtPointer	cd UNUSED;
  {
      SFstatus = SEL_FILE_CANCEL;
  }
***************
*** 2275,2290 ****
  
  static void SFdismissAction __ARGS((Widget w, XEvent *event, String *params, Cardinal *num_params));
  
- /* ARGSUSED */
      static void
  SFdismissAction(w, event, params, num_params)
!     Widget	w;
!     XEvent *event;
!     String *params;
!     Cardinal *num_params;
  {
!     if (event->type == ClientMessage &&
! 	    event->xclient.data.l[0] != SFwmDeleteWindow)
  	return;
  
      SFstatus = SEL_FILE_CANCEL;
--- 2259,2273 ----
  
  static void SFdismissAction __ARGS((Widget w, XEvent *event, String *params, Cardinal *num_params));
  
      static void
  SFdismissAction(w, event, params, num_params)
!     Widget	w UNUSED;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
!     if (event->type == ClientMessage
! 	    && (Atom)event->xclient.data.l[0] != SFwmDeleteWindow)
  	return;
  
      SFstatus = SEL_FILE_CANCEL;
***************
*** 2703,2709 ****
  SFtextChanged()
  {
  #if defined(FEAT_XFONTSET) && defined(XtNinternational)
!     if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
      {
  	wchar_t *wcbuf=(wchar_t *)SFtextBuffer;
  
--- 2686,2692 ----
  SFtextChanged()
  {
  #if defined(FEAT_XFONTSET) && defined(XtNinternational)
!     if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
      {
  	wchar_t *wcbuf=(wchar_t *)SFtextBuffer;
  
***************
*** 2749,2755 ****
  #if defined(FEAT_XFONTSET) && defined(XtNinternational)
      char *buf;
  
!     if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
      {
  	wchar_t *wcbuf;
  	int mbslength;
--- 2732,2738 ----
  #if defined(FEAT_XFONTSET) && defined(XtNinternational)
      char *buf;
  
!     if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
      {
  	wchar_t *wcbuf;
  	int mbslength;
*** ../vim-7.2.183/src/gui_motif.c	2008-06-20 11:39:30.000000000 +0200
--- src/gui_motif.c	2009-05-21 17:15:05.000000000 +0200
***************
*** 117,126 ****
   * Call-back routines.
   */
  
- /* ARGSUSED */
      static void
  scroll_cb(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data, call_data;
  {
      scrollbar_T *sb;
--- 117,125 ----
   * Call-back routines.
   */
  
      static void
  scroll_cb(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data, call_data;
  {
      scrollbar_T *sb;
***************
*** 136,146 ****
  }
  
  #ifdef FEAT_GUI_TABLINE
- /*ARGSUSED*/
      static void
  tabline_cb(w, client_data, call_data)
!     Widget	w;
!     XtPointer	client_data, call_data;
  {
      XmNotebookCallbackStruct *nptr;
  
--- 135,145 ----
  }
  
  #ifdef FEAT_GUI_TABLINE
      static void
  tabline_cb(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
!     XtPointer	call_data;
  {
      XmNotebookCallbackStruct *nptr;
  
***************
*** 149,159 ****
  	send_tabline_event(nptr->page_number);
  }
  
- /*ARGSUSED*/
      static void
  tabline_button_cb(w, client_data, call_data)
      Widget	w;
!     XtPointer	client_data, call_data;
  {
      int		cmd, tab_idx;
  
--- 148,158 ----
  	send_tabline_event(nptr->page_number);
  }
  
      static void
  tabline_button_cb(w, client_data, call_data)
      Widget	w;
!     XtPointer	client_data UNUSED;
!     XtPointer	call_data UNUSED;
  {
      int		cmd, tab_idx;
  
***************
*** 166,176 ****
  /*
   * Tabline single mouse click timeout handler
   */
- /*ARGSUSED*/
      static void
  motif_tabline_timer_cb (timed_out, interval_id)
      XtPointer		timed_out;
!     XtIntervalId	*interval_id;
  {
      *((int *)timed_out) = TRUE;
  }
--- 165,174 ----
  /*
   * Tabline single mouse click timeout handler
   */
      static void
  motif_tabline_timer_cb (timed_out, interval_id)
      XtPointer		timed_out;
!     XtIntervalId	*interval_id UNUSED;
  {
      *((int *)timed_out) = TRUE;
  }
***************
*** 203,215 ****
      return FALSE;
  }
  
- /*ARGSUSED*/
      static void
  tabline_menu_cb(w, closure, e, continue_dispatch)
      Widget	w;
!     XtPointer	closure;
      XEvent	*e;
!     Boolean	*continue_dispatch;
  {
      Widget			tab_w;
      XButtonPressedEvent		*event;
--- 201,212 ----
      return FALSE;
  }
  
      static void
  tabline_menu_cb(w, closure, e, continue_dispatch)
      Widget	w;
!     XtPointer	closure UNUSED;
      XEvent	*e;
!     Boolean	*continue_dispatch UNUSED;
  {
      Widget			tab_w;
      XButtonPressedEvent		*event;
***************
*** 277,287 ****
      XtManageChild(tabLine_menu);
  }
  
- /*ARGSUSED*/
      static void
  tabline_balloon_cb(beval, state)
      BalloonEval	*beval;
!     int		state;
  {
      int		nr;
      tabpage_T	*tp;
--- 274,283 ----
      XtManageChild(tabLine_menu);
  }
  
      static void
  tabline_balloon_cb(beval, state)
      BalloonEval	*beval;
!     int		state UNUSED;
  {
      int		nr;
      tabpage_T	*tp;
***************
*** 642,654 ****
  #endif
  }
  
- /*ARGSUSED*/
      void
  gui_mch_set_text_area_pos(x, y, w, h)
!     int	    x;
!     int	    y;
!     int	    w;
!     int	    h;
  {
  #ifdef FEAT_TOOLBAR
      /* Give keyboard focus to the textArea instead of the toolbar. */
--- 638,649 ----
  #endif
  }
  
      void
  gui_mch_set_text_area_pos(x, y, w, h)
!     int	    x UNUSED;
!     int	    y UNUSED;
!     int	    w UNUSED;
!     int	    h UNUSED;
  {
  #ifdef FEAT_TOOLBAR
      /* Give keyboard focus to the textArea instead of the toolbar. */
***************
*** 1261,1267 ****
      if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
      {
  	if (menu->iconidx >= 0 && menu->iconidx
! 		   < (sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
  	    xpm = built_in_pixmaps[menu->iconidx];
  	else
  	    xpm = tb_blank_xpm;
--- 1256,1262 ----
      if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
      {
  	if (menu->iconidx >= 0 && menu->iconidx
! 	       < (int)(sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
  	    xpm = built_in_pixmaps[menu->iconidx];
  	else
  	    xpm = tb_blank_xpm;
***************
*** 1716,1725 ****
      }
  }
  
- /* ARGSUSED */
      void
  gui_mch_show_popupmenu(menu)
!     vimmenu_T *menu;
  {
  #ifdef MOTIF_POPUP
      XmMenuPosition(menu->submenu_id, gui_x11_get_last_mouse_event());
--- 1711,1719 ----
      }
  }
  
      void
  gui_mch_show_popupmenu(menu)
!     vimmenu_T *menu UNUSED;
  {
  #ifdef MOTIF_POPUP
      XmMenuPosition(menu->submenu_id, gui_x11_get_last_mouse_event());
***************
*** 2046,2054 ****
  /*
   * Callback routine for dialog mnemonic processing.
   */
- /*ARGSUSED*/
      static void
! mnemonic_event(Widget w, XtPointer call_data, XKeyEvent *event)
  {
      do_mnemonic(w, event->keycode);
  }
--- 2040,2047 ----
  /*
   * Callback routine for dialog mnemonic processing.
   */
      static void
! mnemonic_event(Widget w, XtPointer call_data UNUSED, XKeyEvent *event)
  {
      do_mnemonic(w, event->keycode);
  }
***************
*** 2287,2299 ****
   * Put up a file requester.
   * Returns the selected name in allocated memory, or NULL for Cancel.
   */
- /* ARGSUSED */
      char_u *
  gui_mch_browse(saving, title, dflt, ext, initdir, filter)
!     int		saving;		/* select file to write */
      char_u	*title;		/* title for the window */
      char_u	*dflt;		/* default name */
!     char_u	*ext;		/* not used (extension added) */
      char_u	*initdir;	/* initial directory, NULL for current dir */
      char_u	*filter;	/* file name filter */
  {
--- 2280,2291 ----
   * Put up a file requester.
   * Returns the selected name in allocated memory, or NULL for Cancel.
   */
      char_u *
  gui_mch_browse(saving, title, dflt, ext, initdir, filter)
!     int		saving UNUSED;	/* select file to write */
      char_u	*title;		/* title for the window */
      char_u	*dflt;		/* default name */
!     char_u	*ext UNUSED;	/* not used (extension added) */
      char_u	*initdir;	/* initial directory, NULL for current dir */
      char_u	*filter;	/* file name filter */
  {
***************
*** 2413,2424 ****
  /*
   * Process callback from Dialog cancel actions.
   */
- /* ARGSUSED */
      static void
  DialogCancelCB(w, client_data, call_data)
!     Widget	w;		/*  widget id		*/
!     XtPointer	client_data;	/*  data from application   */
!     XtPointer	call_data;	/*  data from widget class  */
  {
      if (browse_fname != NULL)
      {
--- 2405,2415 ----
  /*
   * Process callback from Dialog cancel actions.
   */
      static void
  DialogCancelCB(w, client_data, call_data)
!     Widget	w UNUSED;		/*  widget id		*/
!     XtPointer	client_data UNUSED;	/*  data from application   */
!     XtPointer	call_data UNUSED;	/*  data from widget class  */
  {
      if (browse_fname != NULL)
      {
***************
*** 2431,2442 ****
  /*
   * Process callback from Dialog actions.
   */
- /* ARGSUSED */
      static void
  DialogAcceptCB(w, client_data, call_data)
!     Widget	w;		/*  widget id		*/
!     XtPointer	client_data;	/*  data from application   */
!     XtPointer	call_data;	/*  data from widget class  */
  {
      XmFileSelectionBoxCallbackStruct *fcb;
  
--- 2422,2432 ----
  /*
   * Process callback from Dialog actions.
   */
      static void
  DialogAcceptCB(w, client_data, call_data)
!     Widget	w UNUSED;		/*  widget id		*/
!     XtPointer	client_data UNUSED;	/*  data from application   */
!     XtPointer	call_data;		/*  data from widget class  */
  {
      XmFileSelectionBoxCallbackStruct *fcb;
  
***************
*** 2467,2479 ****
   * Callback function for the textfield.  When CR is hit this works like
   * hitting the "OK" button, ESC like "Cancel".
   */
- /* ARGSUSED */
      static void
  keyhit_callback(w, client_data, event, cont)
      Widget		w;
!     XtPointer		client_data;
      XEvent		*event;
!     Boolean		*cont;
  {
      char	buf[2];
      KeySym	key_sym;
--- 2457,2468 ----
   * Callback function for the textfield.  When CR is hit this works like
   * hitting the "OK" button, ESC like "Cancel".
   */
      static void
  keyhit_callback(w, client_data, event, cont)
      Widget		w;
!     XtPointer		client_data UNUSED;
      XEvent		*event;
!     Boolean		*cont UNUSED;
  {
      char	buf[2];
      KeySym	key_sym;
***************
*** 2490,2501 ****
  	XmTextFieldClearSelection(w, XtLastTimestampProcessed(gui.dpy));
  }
  
- /* ARGSUSED */
      static void
  butproc(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data;
!     XtPointer	call_data;
  {
      dialogStatus = (int)(long)client_data + 1;
  }
--- 2479,2489 ----
  	XmTextFieldClearSelection(w, XtLastTimestampProcessed(gui.dpy));
  }
  
      static void
  butproc(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      dialogStatus = (int)(long)client_data + 1;
  }
***************
*** 2567,2576 ****
  }
  #endif
  
- /* ARGSUSED */
      int
  gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield)
!     int		type;
      char_u	*title;
      char_u	*message;
      char_u	*button_names;
--- 2555,2563 ----
  }
  #endif
  
      int
  gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield)
!     int		type UNUSED;
      char_u	*title;
      char_u	*message;
      char_u	*button_names;
***************
*** 3197,3203 ****
  		XmNchildren, &children,
  		XmNnumChildren, &numChildren, NULL);
  	borders += tst + tmh;
! 	for (i = 0; i < numChildren; i++)
  	{
  	    whgt = 0;
  	    XtVaGetValues(children[i], XmNheight, &whgt, NULL);
--- 3184,3190 ----
  		XmNchildren, &children,
  		XmNnumChildren, &numChildren, NULL);
  	borders += tst + tmh;
! 	for (i = 0; i < (int)numChildren; i++)
  	{
  	    whgt = 0;
  	    XtVaGetValues(children[i], XmNheight, &whgt, NULL);
***************
*** 3237,3249 ****
   * I have to use footer help for backwards compatability.  Hopefully both will
   * get implemented and the user will have a choice.
   */
- /*ARGSUSED*/
      static void
  toolbarbutton_enter_cb(w, client_data, event, cont)
!     Widget	w;
      XtPointer	client_data;
!     XEvent	*event;
!     Boolean	*cont;
  {
      vimmenu_T	*menu = (vimmenu_T *) client_data;
  
--- 3224,3235 ----
   * I have to use footer help for backwards compatability.  Hopefully both will
   * get implemented and the user will have a choice.
   */
      static void
  toolbarbutton_enter_cb(w, client_data, event, cont)
!     Widget	w UNUSED;
      XtPointer	client_data;
!     XEvent	*event UNUSED;
!     Boolean	*cont UNUSED;
  {
      vimmenu_T	*menu = (vimmenu_T *) client_data;
  
***************
*** 3254,3266 ****
      }
  }
  
- /*ARGSUSED*/
      static void
  toolbarbutton_leave_cb(w, client_data, event, cont)
!     Widget	w;
!     XtPointer	client_data;
!     XEvent	*event;
!     Boolean	*cont;
  {
      gui_mch_set_footer((char_u *) "");
  }
--- 3240,3251 ----
      }
  }
  
      static void
  toolbarbutton_leave_cb(w, client_data, event, cont)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
!     XEvent	*event UNUSED;
!     Boolean	*cont UNUSED;
  {
      gui_mch_set_footer((char_u *) "");
  }
***************
*** 3492,3501 ****
  /*
   * Set the fontlist for Widget "id" to use gui.menu_fontset or gui.menu_font.
   */
- /*ARGSUSED*/
      void
  gui_motif_menu_fontlist(id)
!     Widget  id;
  {
  #ifdef FEAT_MENU
  #ifdef FONTSET_ALWAYS
--- 3477,3485 ----
  /*
   * Set the fontlist for Widget "id" to use gui.menu_fontset or gui.menu_font.
   */
      void
  gui_motif_menu_fontlist(id)
!     Widget  id UNUSED;
  {
  #ifdef FEAT_MENU
  #ifdef FONTSET_ALWAYS
***************
*** 3566,3573 ****
      Widget cancel;
  } SharedFindReplace;
  
! static SharedFindReplace find_widgets = { NULL };
! static SharedFindReplace repl_widgets = { NULL };
  
  static void find_replace_destroy_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
  static void find_replace_dismiss_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
--- 3550,3557 ----
      Widget cancel;
  } SharedFindReplace;
  
! static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
! static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
  
  static void find_replace_destroy_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
  static void find_replace_dismiss_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
***************
*** 3576,3587 ****
  static void find_replace_keypress __ARGS((Widget w, SharedFindReplace * frdp, XKeyEvent * event));
  static void find_replace_dialog_create __ARGS((char_u *entry_text, int do_replace));
  
- /*ARGSUSED*/
      static void
  find_replace_destroy_callback(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data;
!     XtPointer	call_data;
  {
      SharedFindReplace *cd = (SharedFindReplace *)client_data;
  
--- 3560,3570 ----
  static void find_replace_keypress __ARGS((Widget w, SharedFindReplace * frdp, XKeyEvent * event));
  static void find_replace_dialog_create __ARGS((char_u *entry_text, int do_replace));
  
      static void
  find_replace_destroy_callback(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      SharedFindReplace *cd = (SharedFindReplace *)client_data;
  
***************
*** 3590,3601 ****
  	cd->dialog = (Widget)0;
  }
  
- /*ARGSUSED*/
      static void
  find_replace_dismiss_callback(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data;
!     XtPointer	call_data;
  {
      SharedFindReplace *cd = (SharedFindReplace *)client_data;
  
--- 3573,3583 ----
  	cd->dialog = (Widget)0;
  }
  
      static void
  find_replace_dismiss_callback(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      SharedFindReplace *cd = (SharedFindReplace *)client_data;
  
***************
*** 3603,3624 ****
  	XtUnmanageChild(cd->dialog);
  }
  
- /*ARGSUSED*/
      static void
  entry_activate_callback(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data;
!     XtPointer	call_data;
  {
      XmProcessTraversal((Widget)client_data, XmTRAVERSE_CURRENT);
  }
  
- /*ARGSUSED*/
      static void
  find_replace_callback(w, client_data, call_data)
!     Widget	w;
      XtPointer	client_data;
!     XtPointer	call_data;
  {
      long_u	flags = (long_u)client_data;
      char	*find_text, *repl_text;
--- 3585,3604 ----
  	XtUnmanageChild(cd->dialog);
  }
  
      static void
  entry_activate_callback(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      XmProcessTraversal((Widget)client_data, XmTRAVERSE_CURRENT);
  }
  
      static void
  find_replace_callback(w, client_data, call_data)
!     Widget	w UNUSED;
      XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      long_u	flags = (long_u)client_data;
      char	*find_text, *repl_text;
***************
*** 3668,3677 ****
  	XtFree(repl_text);
  }
  
- /*ARGSUSED*/
      static void
  find_replace_keypress(w, frdp, event)
!     Widget		w;
      SharedFindReplace	*frdp;
      XKeyEvent		*event;
  {
--- 3648,3656 ----
  	XtFree(repl_text);
  }
  
      static void
  find_replace_keypress(w, frdp, event)
!     Widget		w UNUSED;
      SharedFindReplace	*frdp;
      XKeyEvent		*event;
  {
*** ../vim-7.2.183/src/gui_xmdlg.c	2008-11-28 21:26:50.000000000 +0100
--- src/gui_xmdlg.c	2009-05-21 17:01:52.000000000 +0200
***************
*** 448,454 ****
  
  	    items[i] = XmStringCreateLocalized(list[ENCODING][i]);
  
! 	    if (i < n_items)
  	    {
  		/* recycle old button */
  		XtVaSetValues(children[i],
--- 448,454 ----
  
  	    items[i] = XmStringCreateLocalized(list[ENCODING][i]);
  
! 	    if (i < (int)n_items)
  	    {
  		/* recycle old button */
  		XtVaSetValues(children[i],
***************
*** 481,487 ****
  
  	/* Destroy all the outstanding menu items.
  	 */
! 	for (i = count[ENCODING]; i < n_items; ++i)
  	{
  	    XtUnmanageChild(children[i]);
  	    XtDestroyWidget(children[i]);
--- 481,487 ----
  
  	/* Destroy all the outstanding menu items.
  	 */
! 	for (i = count[ENCODING]; i < (int)n_items; ++i)
  	{
  	    XtUnmanageChild(children[i]);
  	    XtDestroyWidget(children[i]);
***************
*** 544,552 ****
      }
  }
  
- /*ARGSUSED*/
      static void
! stoggle_callback(Widget w,
  	SharedFontSelData *data,
  	XmToggleButtonCallbackStruct *call_data)
  {
--- 544,551 ----
      }
  }
  
      static void
! stoggle_callback(Widget w UNUSED,
  	SharedFontSelData *data,
  	XmToggleButtonCallbackStruct *call_data)
  {
***************
*** 709,719 ****
      }
  }
  
- /*ARGSUSED*/
      static void
  encoding_callback(Widget w,
  	SharedFontSelData *data,
! 	XtPointer dummy)
  {
      XmString str;
      XmListCallbackStruct fake_data;
--- 708,717 ----
      }
  }
  
      static void
  encoding_callback(Widget w,
  	SharedFontSelData *data,
! 	XtPointer dummy UNUSED)
  {
      XmString str;
      XmListCallbackStruct fake_data;
***************
*** 752,762 ****
      do_choice(w, data, call_data, SIZE);
  }
  
- /*ARGSUSED*/
      static void
! cancel_callback(Widget w,
  	SharedFontSelData *data,
! 	XmListCallbackStruct *call_data)
  {
      if (data->sel[ENCODING])
      {
--- 750,759 ----
      do_choice(w, data, call_data, SIZE);
  }
  
      static void
! cancel_callback(Widget w UNUSED,
  	SharedFontSelData *data,
! 	XmListCallbackStruct *call_data UNUSED)
  {
      if (data->sel[ENCODING])
      {
***************
*** 789,799 ****
      data->exit = True;
  }
  
- /*ARGSUSED*/
      static void
! ok_callback(Widget w,
  	SharedFontSelData *data,
! 	XmPushButtonCallbackStruct *call_data)
  {
      char    *pattern;
      char    **name;
--- 786,795 ----
      data->exit = True;
  }
  
      static void
! ok_callback(Widget w UNUSED,
  	SharedFontSelData *data,
! 	XmPushButtonCallbackStruct *call_data UNUSED)
  {
      char    *pattern;
      char    **name;
*** ../vim-7.2.183/src/gui_xmebw.c	2008-11-28 21:26:50.000000000 +0100
--- src/gui_xmebw.c	2009-05-21 17:06:17.000000000 +0200
***************
*** 235,247 ****
      return tmp;
  }
  
- /*ARGSUSED*/
      static int
  alloc_color(Display	*display,
  	Colormap	colormap,
  	char		*colorname,
  	XColor		*xcolor,
! 	void		*closure)
  {
      int status;
  
--- 235,246 ----
      return tmp;
  }
  
      static int
  alloc_color(Display	*display,
  	Colormap	colormap,
  	char		*colorname,
  	XColor		*xcolor,
! 	void		*closure UNUSED)
  {
      int status;
  
***************
*** 595,603 ****
  		       XtHeight(eb), eb->primitive.highlight_thickness);
  }
  
- /*ARGSUSED*/
      static void
! draw_pixmap(XmEnhancedButtonWidget eb, XEvent *event, Region region)
  {
      Pixmap	pix;
      GC		gc = eb->label.normal_GC;
--- 594,603 ----
  		       XtHeight(eb), eb->primitive.highlight_thickness);
  }
  
      static void
! draw_pixmap(XmEnhancedButtonWidget eb,
! 	    XEvent *event UNUSED,
! 	    Region region UNUSED)
  {
      Pixmap	pix;
      GC		gc = eb->label.normal_GC;
***************
*** 641,647 ****
      height = eb->core.height - 2 * y;
      if (h < height)
  	height = h;
!     if (depth == eb->core.depth)
  	XCopyArea(XtDisplay(eb), pix, XtWindow(eb), gc, 0, 0,
  		width, height, x, y);
      else if (depth == 1)
--- 641,647 ----
      height = eb->core.height - 2 * y;
      if (h < height)
  	height = h;
!     if (depth == (int)eb->core.depth)
  	XCopyArea(XtDisplay(eb), pix, XtWindow(eb), gc, 0, 0,
  		width, height, x, y);
      else if (depth == 1)
***************
*** 731,739 ****
  	eb->label.normal_GC = tmp_gc;
  }
  
- /*ARGSUSED*/
      static void
! Enter(Widget wid, XEvent *event, String *params, Cardinal *num_params)
  {
      XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget) wid;
      XmPushButtonCallbackStruct call_value;
--- 731,741 ----
  	eb->label.normal_GC = tmp_gc;
  }
  
      static void
! Enter(Widget wid,
!       XEvent *event,
!       String *params UNUSED,
!       Cardinal *num_params UNUSED)
  {
      XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget) wid;
      XmPushButtonCallbackStruct call_value;
***************
*** 818,826 ****
      }
  }
  
- /*ARGSUSED*/
      static void
! Leave(Widget wid, XEvent *event, String *params, Cardinal *num_params)
  {
      XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget)wid;
      XmPushButtonCallbackStruct call_value;
--- 820,830 ----
      }
  }
  
      static void
! Leave(Widget wid,
!       XEvent *event,
!       String *params UNUSED,
!       Cardinal *num_params UNUSED)
  {
      XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget)wid;
      XmPushButtonCallbackStruct call_value;
***************
*** 976,984 ****
      }
  }
  
- /*ARGSUSED*/
      static void
! Initialize(Widget rq, Widget ebw, ArgList args, Cardinal *n)
  {
      XmEnhancedButtonWidget  request = (XmEnhancedButtonWidget)rq;
      XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget)ebw;
--- 980,987 ----
      }
  }
  
      static void
! Initialize(Widget rq, Widget ebw, ArgList args UNUSED, Cardinal *n UNUSED)
  {
      XmEnhancedButtonWidget  request = (XmEnhancedButtonWidget)rq;
      XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget)ebw;
***************
*** 1056,1064 ****
      free_pixmaps((XmEnhancedButtonWidget)w);
  }
  
- /*ARGSUSED*/
      static Boolean
! SetValues(Widget current, Widget request, Widget new, ArgList args, Cardinal *n)
  {
      XmEnhancedButtonWidget  cur = (XmEnhancedButtonWidget) current;
      XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget) new;
--- 1059,1070 ----
      free_pixmaps((XmEnhancedButtonWidget)w);
  }
  
      static Boolean
! SetValues(Widget current,
! 	  Widget request UNUSED,
! 	  Widget new,
! 	  ArgList args UNUSED,
! 	  Cardinal *n UNUSED)
  {
      XmEnhancedButtonWidget  cur = (XmEnhancedButtonWidget) current;
      XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget) new;
***************
*** 1108,1114 ****
  		if ((win_x < 0) || (win_y < 0))
  		    return False;
  
! 		if ((win_x > r_width) || (win_y > r_height))
  		    return False;
  		draw_highlight(eb);
  		draw_shadows(eb);
--- 1114,1120 ----
  		if ((win_x < 0) || (win_y < 0))
  		    return False;
  
! 		if ((win_x > (int)r_width) || (win_y > (int)r_height))
  		    return False;
  		draw_highlight(eb);
  		draw_shadows(eb);
*** ../vim-7.2.183/src/if_python.c	2009-01-13 18:10:21.000000000 +0100
--- src/if_python.c	2009-05-21 17:27:50.000000000 +0200
***************
*** 1096,1104 ****
  
  /* Vim module - Implementation
   */
- /*ARGSUSED*/
      static PyObject *
! VimCommand(PyObject *self, PyObject *args)
  {
      char *cmd;
      PyObject *result;
--- 1096,1103 ----
  
  /* Vim module - Implementation
   */
      static PyObject *
! VimCommand(PyObject *self UNUSED, PyObject *args)
  {
      char *cmd;
      PyObject *result;
***************
*** 1242,1250 ****
  }
  #endif
  
- /*ARGSUSED*/
      static PyObject *
! VimEval(PyObject *self, PyObject *args)
  {
  #ifdef FEAT_EVAL
      char	*expr;
--- 1241,1248 ----
  }
  #endif
  
      static PyObject *
! VimEval(PyObject *self UNUSED, PyObject *args)
  {
  #ifdef FEAT_EVAL
      char	*expr;
***************
*** 1894,1902 ****
  /* Buffer list object - Implementation
   */
  
- /*ARGSUSED*/
      static PyInt
! BufListLength(PyObject *self)
  {
      buf_T	*b = firstbuf;
      PyInt	n = 0;
--- 1892,1899 ----
  /* Buffer list object - Implementation
   */
  
      static PyInt
! BufListLength(PyObject *self UNUSED)
  {
      buf_T	*b = firstbuf;
      PyInt	n = 0;
***************
*** 1910,1918 ****
      return n;
  }
  
- /*ARGSUSED*/
      static PyObject *
! BufListItem(PyObject *self, PyInt n)
  {
      buf_T *b;
  
--- 1907,1914 ----
      return n;
  }
  
      static PyObject *
! BufListItem(PyObject *self UNUSED, PyInt n)
  {
      buf_T *b;
  
***************
*** 2210,2218 ****
  
  /* Window list object - Implementation
   */
- /*ARGSUSED*/
      static PyInt
! WinListLength(PyObject *self)
  {
      win_T	*w = firstwin;
      PyInt	n = 0;
--- 2206,2213 ----
  
  /* Window list object - Implementation
   */
      static PyInt
! WinListLength(PyObject *self UNUSED)
  {
      win_T	*w = firstwin;
      PyInt	n = 0;
***************
*** 2226,2234 ****
      return n;
  }
  
- /*ARGSUSED*/
      static PyObject *
! WinListItem(PyObject *self, PyInt n)
  {
      win_T *w;
  
--- 2221,2228 ----
      return n;
  }
  
      static PyObject *
! WinListItem(PyObject *self UNUSED, PyInt n)
  {
      win_T *w;
  
***************
*** 2274,2282 ****
  
  /* Current items object - Implementation
   */
- /*ARGSUSED*/
      static PyObject *
! CurrentGetattr(PyObject *self, char *name)
  {
      if (strcmp(name, "buffer") == 0)
  	return (PyObject *)BufferNew(curbuf);
--- 2268,2275 ----
  
  /* Current items object - Implementation
   */
      static PyObject *
! CurrentGetattr(PyObject *self UNUSED, char *name)
  {
      if (strcmp(name, "buffer") == 0)
  	return (PyObject *)BufferNew(curbuf);
***************
*** 2295,2303 ****
      }
  }
  
- /*ARGSUSED*/
      static int
! CurrentSetattr(PyObject *self, char *name, PyObject *value)
  {
      if (strcmp(name, "line") == 0)
      {
--- 2288,2295 ----
      }
  }
  
      static int
! CurrentSetattr(PyObject *self UNUSED, char *name, PyObject *value)
  {
      if (strcmp(name, "line") == 0)
      {
*** ../vim-7.2.183/src/window.c	2009-02-22 02:36:36.000000000 +0100
--- src/window.c	2009-05-21 15:14:54.000000000 +0200
***************
*** 1163,1174 ****
   * WSP_NEWLOC may be specified in flags to prevent the location list from
   * being copied.
   */
- /*ARGSUSED*/
      static void
  win_init(newp, oldp, flags)
      win_T	*newp;
      win_T	*oldp;
!     int		 flags;
  {
      int		i;
  
--- 1163,1173 ----
   * WSP_NEWLOC may be specified in flags to prevent the location list from
   * being copied.
   */
      static void
  win_init(newp, oldp, flags)
      win_T	*newp;
      win_T	*oldp;
!     int		 flags UNUSED;
  {
      int		i;
  
***************
*** 1268,1278 ****
   * Must be called when there is just one window, filling the whole screen
   * (excluding the command line).
   */
- /*ARGSUSED*/
      int
  make_windows(count, vertical)
      int		count;
!     int		vertical;	/* split windows vertically if TRUE */
  {
      int		maxcount;
      int		todo;
--- 1267,1276 ----
   * Must be called when there is just one window, filling the whole screen
   * (excluding the command line).
   */
      int
  make_windows(count, vertical)
      int		count;
!     int		vertical UNUSED;  /* split windows vertically if TRUE */
  {
      int		maxcount;
      int		todo;
***************
*** 2353,2363 ****
   * Remove a window and its frame from the tree of frames.
   * Returns a pointer to the window that got the freed up space.
   */
- /*ARGSUSED*/
      static win_T *
  winframe_remove(win, dirp, tp)
      win_T	*win;
!     int		*dirp;		/* set to 'v' or 'h' for direction if 'ea' */
      tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
  {
      frame_T	*frp, *frp2, *frp3;
--- 2351,2360 ----
   * Remove a window and its frame from the tree of frames.
   * Returns a pointer to the window that got the freed up space.
   */
      static win_T *
  winframe_remove(win, dirp, tp)
      win_T	*win;
!     int		*dirp UNUSED;	/* set to 'v' or 'h' for direction if 'ea' */
      tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
  {
      frame_T	*frp, *frp2, *frp3;
***************
*** 3500,3509 ****
   * FAIL.
   * Careful: When OK is returned need to get a new tab page very very soon!
   */
- /*ARGSUSED*/
      static int
  leave_tabpage(new_curbuf)
!     buf_T	*new_curbuf;	    /* what is going to be the new curbuf,
  				       NULL if unknown */
  {
      tabpage_T	*tp = curtab;
--- 3497,3505 ----
   * FAIL.
   * Careful: When OK is returned need to get a new tab page very very soon!
   */
      static int
  leave_tabpage(new_curbuf)
!     buf_T	*new_curbuf UNUSED;    /* what is going to be the new curbuf,
  				       NULL if unknown */
  {
      tabpage_T	*tp = curtab;
***************
*** 3545,3555 ****
   * Start using tab page "tp".
   * Only to be used after leave_tabpage() or freeing the current tab page.
   */
- /*ARGSUSED*/
      static void
  enter_tabpage(tp, old_curbuf)
      tabpage_T	*tp;
!     buf_T	*old_curbuf;
  {
      int		old_off = tp->tp_firstwin->w_winrow;
      win_T	*next_prevwin = tp->tp_prevwin;
--- 3541,3550 ----
   * Start using tab page "tp".
   * Only to be used after leave_tabpage() or freeing the current tab page.
   */
      static void
  enter_tabpage(tp, old_curbuf)
      tabpage_T	*tp;
!     buf_T	*old_curbuf UNUSED;
  {
      int		old_off = tp->tp_firstwin->w_winrow;
      win_T	*next_prevwin = tp->tp_prevwin;
***************
*** 4157,4166 ****
  /*
   * allocate a window structure and link it in the window list
   */
- /*ARGSUSED*/
      static win_T *
  win_alloc(after)
!     win_T	*after;
  {
      win_T	*newwin;
  
--- 4152,4160 ----
  /*
   * allocate a window structure and link it in the window list
   */
      static win_T *
  win_alloc(after)
!     win_T	*after UNUSED;
  {
      win_T	*newwin;
  
*** ../vim-7.2.183/src/workshop.c	2008-11-28 11:47:14.000000000 +0100
--- src/workshop.c	2009-05-21 17:12:55.000000000 +0200
***************
*** 204,215 ****
   * Function:
   *	Load a given file into the WorkShop buffer.
   */
- /*ARGSUSED*/
      void
  workshop_load_file(
  	char	*filename,		/* the file to load */
  	int	 line,			/* an optional line number (or 0) */
! 	char	*frameid)		/* used for multi-frame support */
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
--- 204,214 ----
   * Function:
   *	Load a given file into the WorkShop buffer.
   */
      void
  workshop_load_file(
  	char	*filename,		/* the file to load */
  	int	 line,			/* an optional line number (or 0) */
! 	char	*frameid UNUSED)	/* used for multi-frame support */
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
***************
*** 263,272 ****
      load_window(filename, lineno);
  }
  
- /*ARGSUSED*/
      void
  workshop_front_file(
! 	char	*filename)
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
--- 262,270 ----
      load_window(filename, lineno);
  }
  
      void
  workshop_front_file(
! 	char	*filename UNUSED)
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
***************
*** 538,546 ****
   * breakpoints have moved when a program has been recompiled and
   * reloaded into dbx.
   */
- /*ARGSUSED*/
      void
! workshop_moved_marks(char *filename)
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
--- 536,543 ----
   * breakpoints have moved when a program has been recompiled and
   * reloaded into dbx.
   */
      void
! workshop_moved_marks(char *filename UNUSED)
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
***************
*** 575,585 ****
      return (int)h;
  }
  
- /*ARGSUSED*/
      void
  workshop_footer_message(
! 	char		*message,
! 	int		 severity)	/* severity is currently unused */
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
--- 572,581 ----
      return (int)h;
  }
  
      void
  workshop_footer_message(
! 	char	*message,
! 	int	severity UNUSED)	/* severity is currently unused */
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
***************
*** 687,701 ****
   * command. The globals curMenuName and curMenuPriority contain the name and
   * priority of the parent menu tree.
   */
- /*ARGSUSED*/
      void
  workshop_menu_item(
  	char		*label,
  	char		*verb,
! 	char		*accelerator,
  	char		*acceleratorText,
! 	char		*name,
! 	char		*filepos,
  	char		*sensitive)
  {
      char		 cbuf[BUFSIZ];
--- 683,696 ----
   * command. The globals curMenuName and curMenuPriority contain the name and
   * priority of the parent menu tree.
   */
      void
  workshop_menu_item(
  	char		*label,
  	char		*verb,
! 	char		*accelerator UNUSED,
  	char		*acceleratorText,
! 	char		*name UNUSED,
! 	char		*filepos UNUSED,
  	char		*sensitive)
  {
      char		 cbuf[BUFSIZ];
***************
*** 810,822 ****
      workshopInitDone = True;
  }
  
- /*ARGSUSED*/
      void
  workshop_toolbar_button(
  	char	*label,
  	char	*verb,
! 	char	*senseVerb,
! 	char	*filepos,
  	char	*help,
  	char	*sense,
  	char	*file,
--- 805,816 ----
      workshopInitDone = True;
  }
  
      void
  workshop_toolbar_button(
  	char	*label,
  	char	*verb,
! 	char	*senseVerb UNUSED,
! 	char	*filepos UNUSED,
  	char	*help,
  	char	*sense,
  	char	*file,
***************
*** 968,974 ****
  	    if (strcmp(option, "syntax") == 0)
  		vim_snprintf(cbuf, sizeof(cbuf), "syntax %s", value);
  	    else if (strcmp(option, "savefiles") == 0)
! 		; /* XXX - Not yet implemented */
  	    break;
  
  	case 'l':
--- 962,970 ----
  	    if (strcmp(option, "syntax") == 0)
  		vim_snprintf(cbuf, sizeof(cbuf), "syntax %s", value);
  	    else if (strcmp(option, "savefiles") == 0)
! 	    {
! 		/* XXX - Not yet implemented */
! 	    }
  	    break;
  
  	case 'l':
***************
*** 1098,1107 ****
  /*
   * A button in the toolbar has been pushed.
   */
- /*ARGSUSED*/
      int
  workshop_get_positions(
! 	void		*clientData,	/* unused */
  	char	       **filename,	/* output data */
  	int		*curLine,	/* output data */
  	int		*curCol,	/* output data */
--- 1094,1102 ----
  /*
   * A button in the toolbar has been pushed.
   */
      int
  workshop_get_positions(
! 	void		*clientData UNUSED,
  	char	       **filename,	/* output data */
  	int		*curLine,	/* output data */
  	int		*curCol,	/* output data */
***************
*** 1526,1534 ****
  	return NULL;
  }
  
- /*ARGSUSED*/
      void
! workshop_save_sensitivity(char *filename)
  {
  }
  
--- 1521,1528 ----
  	return NULL;
  }
  
      void
! workshop_save_sensitivity(char *filename UNUSED)
  {
  }
  
*** ../vim-7.2.183/src/version.c	2009-05-21 15:19:59.000000000 +0200
--- src/version.c	2009-05-21 23:19:40.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     184,
  /**/

-- 
CART DRIVER: Bring out your dead!
LARGE MAN:   Here's one!
CART DRIVER: Ninepence.
BODY:        I'm not dead!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.185
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.185
Problem:    Some more compiler warnings when using gcc -Wextra.
Solution:   Add UNUSED and type casts.
Files:	    src/Makefile, src/if_tlc.c, src/if_ruby.c


*** ../vim-7.2.184/src/Makefile	2009-05-21 23:25:47.000000000 +0200
--- src/Makefile	2009-05-22 18:18:44.000000000 +0200
***************
*** 105,112 ****
  # 4. "make test"  {{{1
  #	This is optional.  This will run Vim scripts on a number of test
  #	files, and compare the produced output with the expected output.
! #	If all is well, you will get the "ALL DONE" message in the end.  See
! #	below (search for "/^test").
  #
  # 5. "make install"  {{{1
  #	If the new Vim seems to be working OK you can install it and the
--- 105,112 ----
  # 4. "make test"  {{{1
  #	This is optional.  This will run Vim scripts on a number of test
  #	files, and compare the produced output with the expected output.
! #	If all is well, you will get the "ALL DONE" message in the end.  If a
! #	test fails you get "TEST FAILURE".  See below (search for "/^test").
  #
  # 5. "make install"  {{{1
  #	If the new Vim seems to be working OK you can install it and the
***************
*** 533,538 ****
--- 533,543 ----
  #CFLAGS = -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes
  #CFLAGS = -g -O2 '-DSTARTUPTIME="vimstartup"' -fno-strength-reduce -Wall -Wmissing-prototypes
  
+ # Use this with GCC to check for mistakes, unused arguments, etc.
+ #CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code
+ #PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
+ #MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code
+ 
  # EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
  # allocated memory (and makes every malloc()/free() very slow).
  # Electric Fence is free (search ftp sites).
***************
*** 551,562 ****
  # }}}
  
  # LINT - for running lint
! #  For standard lint
! #LINT = lint
! #LINT_OPTIONS = -beprxzF
! #  For splint  (see cleanlint.vim for filtering the output)
! LINT = splint
! LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999
  
  # PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
  # Might not work with GUI or Perl.
--- 556,568 ----
  # }}}
  
  # LINT - for running lint
! #  For standard Unix lint
! LINT = lint
! LINT_OPTIONS = -beprxzF
! #  For splint
! #  It doesn't work well, crashes on include files and non-ascii characters.
! #LINT = splint
! #LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999
  
  # PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
  # Might not work with GUI or Perl.
***************
*** 1743,1749 ****
  # messages.  Don't worry about that.
  # If there is a real error, there will be a difference between "test.out" and
  # a "test99.ok" file.
! # If everything is alright, the final message will be "ALL DONE".
  #
  test check:
  	$(MAKE) -f Makefile $(VIMTARGET)
--- 1749,1756 ----
  # messages.  Don't worry about that.
  # If there is a real error, there will be a difference between "test.out" and
  # a "test99.ok" file.
! # If everything is alright, the final message will be "ALL DONE".  If not you
! # get "TEST FAILURE".
  #
  test check:
  	$(MAKE) -f Makefile $(VIMTARGET)
***************
*** 2427,2433 ****
  	$(CCC) -o $@ if_xcmdsrv.c
  
  objects/if_mzsch.o: if_mzsch.c
! 	$(CCC) -o $@ if_mzsch.c
  
  objects/if_perl.o: auto/if_perl.c
  	$(CCC) -o $@ auto/if_perl.c
--- 2434,2440 ----
  	$(CCC) -o $@ if_xcmdsrv.c
  
  objects/if_mzsch.o: if_mzsch.c
! 	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
  
  objects/if_perl.o: auto/if_perl.c
  	$(CCC) -o $@ auto/if_perl.c
***************
*** 2436,2442 ****
  	$(CCC) -o $@ if_perlsfio.c
  
  objects/if_python.o: if_python.c
! 	$(CCC) -o $@ if_python.c
  
  objects/if_ruby.o: if_ruby.c
  	$(CCC) -o $@ if_ruby.c
--- 2443,2449 ----
  	$(CCC) -o $@ if_perlsfio.c
  
  objects/if_python.o: if_python.c
! 	$(CCC) -o $@ $(PYTHON_CFLAGS_EXTRA) if_python.c
  
  objects/if_ruby.o: if_ruby.c
  	$(CCC) -o $@ if_ruby.c
*** ../vim-7.2.184/src/if_ruby.c	2007-09-13 15:00:49.000000000 +0200
--- src/if_ruby.c	2009-05-22 15:32:04.000000000 +0200
***************
*** 492,498 ****
      }
  }
  
! static VALUE vim_message(VALUE self, VALUE str)
  {
      char *buff, *p;
  
--- 492,498 ----
      }
  }
  
! static VALUE vim_message(VALUE self UNUSED, VALUE str)
  {
      char *buff, *p;
  
***************
*** 505,524 ****
      return Qnil;
  }
  
! static VALUE vim_set_option(VALUE self, VALUE str)
  {
      do_set((char_u *)STR2CSTR(str), 0);
      update_screen(NOT_VALID);
      return Qnil;
  }
  
! static VALUE vim_command(VALUE self, VALUE str)
  {
      do_cmdline_cmd((char_u *)STR2CSTR(str));
      return Qnil;
  }
  
! static VALUE vim_evaluate(VALUE self, VALUE str)
  {
  #ifdef FEAT_EVAL
      char_u *value = eval_to_string((char_u *)STR2CSTR(str), NULL, TRUE);
--- 505,524 ----
      return Qnil;
  }
  
! static VALUE vim_set_option(VALUE self UNUSED, VALUE str)
  {
      do_set((char_u *)STR2CSTR(str), 0);
      update_screen(NOT_VALID);
      return Qnil;
  }
  
! static VALUE vim_command(VALUE self UNUSED, VALUE str)
  {
      do_cmdline_cmd((char_u *)STR2CSTR(str));
      return Qnil;
  }
  
! static VALUE vim_evaluate(VALUE self UNUSED, VALUE str)
  {
  #ifdef FEAT_EVAL
      char_u *value = eval_to_string((char_u *)STR2CSTR(str), NULL, TRUE);
***************
*** 580,586 ****
      return INT2NUM(n);
  }
  
! static VALUE buffer_s_aref(VALUE self, VALUE num)
  {
      buf_T *b;
      int n = NUM2INT(num);
--- 580,586 ----
      return INT2NUM(n);
  }
  
! static VALUE buffer_s_aref(VALUE self UNUSED, VALUE num)
  {
      buf_T *b;
      int n = NUM2INT(num);
***************
*** 629,635 ****
--- 629,637 ----
  	return line ? rb_str_new2(line) : Qnil;
      }
      rb_raise(rb_eIndexError, "index %d out of buffer", n);
+ #ifndef __GNUC__
      return Qnil; /* For stop warning */
+ #endif
  }
  
  static VALUE buffer_aref(VALUE self, VALUE num)
***************
*** 668,674 ****
--- 670,678 ----
      else
      {
  	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+ #ifndef __GNUC__
  	return Qnil; /* For stop warning */
+ #endif
      }
      return str;
  }
***************
*** 789,795 ****
      return get_buffer_line(curbuf, curwin->w_cursor.lnum);
  }
  
! static VALUE set_current_line(VALUE self, VALUE str)
  {
      return set_buffer_line(curbuf, curwin->w_cursor.lnum, str);
  }
--- 793,799 ----
      return get_buffer_line(curbuf, curwin->w_cursor.lnum);
  }
  
! static VALUE set_current_line(VALUE self UNUSED, VALUE str)
  {
      return set_buffer_line(curbuf, curwin->w_cursor.lnum, str);
  }
***************
*** 815,821 ****
  #endif
  }
  
! static VALUE window_s_aref(VALUE self, VALUE num)
  {
      win_T *w;
      int n = NUM2INT(num);
--- 819,825 ----
  #endif
  }
  
! static VALUE window_s_aref(VALUE self UNUSED, VALUE num)
  {
      win_T *w;
      int n = NUM2INT(num);
***************
*** 897,903 ****
      return Qnil;
  }
  
! static VALUE f_p(int argc, VALUE *argv, VALUE self)
  {
      int i;
      VALUE str = rb_str_new("", 0);
--- 901,907 ----
      return Qnil;
  }
  
! static VALUE f_p(int argc, VALUE *argv, VALUE self UNUSED)
  {
      int i;
      VALUE str = rb_str_new("", 0);
*** ../vim-7.2.184/src/version.c	2009-05-21 23:25:38.000000000 +0200
--- src/version.c	2009-05-22 18:18:58.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     185,
  /**/

-- 
BODY:        I'm not dead!
CART DRIVER: 'Ere.  He says he's not dead.
LARGE MAN:   Yes he is.
BODY:        I'm not!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.186
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.186
Problem:    Some more compiler warnings when using gcc -Wextra.
Solution:   Now with the intended if_tcl.c changes.
Files:	    src/if_tcl.c


*** ../vim-7.2.185/src/if_tcl.c	2007-05-10 20:55:34.000000000 +0200
--- src/if_tcl.c	2009-05-22 15:29:53.000000000 +0200
***************
*** 290,299 ****
   */
  #define TCL_EXIT	5
  
- /* ARGSUSED */
      static int
  exitcmd(dummy, interp, objc, objv)
!     ClientData dummy;
      Tcl_Interp *interp;
      int objc;
      Tcl_Obj *CONST objv[];
--- 290,298 ----
   */
  #define TCL_EXIT	5
  
      static int
  exitcmd(dummy, interp, objc, objv)
!     ClientData dummy UNUSED;
      Tcl_Interp *interp;
      int objc;
      Tcl_Obj *CONST objv[];
***************
*** 315,324 ****
      return TCL_ERROR;
  }
  
- /* ARGSUSED */
      static int
  catchcmd(dummy, interp, objc, objv)
!     ClientData	dummy;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
--- 314,322 ----
      return TCL_ERROR;
  }
  
      static int
  catchcmd(dummy, interp, objc, objv)
!     ClientData	dummy UNUSED;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
***************
*** 356,365 ****
  /*
   *  "::vim::beep" - what Vi[m] does best :-)
   */
- /* ARGSUSED */
      static int
  beepcmd(dummy, interp, objc, objv)
!     ClientData dummy;
      Tcl_Interp *interp;
      int objc;
      Tcl_Obj *CONST objv[];
--- 354,362 ----
  /*
   *  "::vim::beep" - what Vi[m] does best :-)
   */
      static int
  beepcmd(dummy, interp, objc, objv)
!     ClientData dummy UNUSED;
      Tcl_Interp *interp;
      int objc;
      Tcl_Obj *CONST objv[];
***************
*** 378,387 ****
   *  "::vim::buffer {N}" - create buffer command for buffer N.
   *  "::vim::buffer new" - create a new buffer (not implemented)
   */
- /* ARGSUSED */
      static int
  buffercmd(dummy, interp, objc, objv)
!     ClientData dummy;
      Tcl_Interp *interp;
      int objc;
      Tcl_Obj *CONST objv[];
--- 375,383 ----
   *  "::vim::buffer {N}" - create buffer command for buffer N.
   *  "::vim::buffer new" - create a new buffer (not implemented)
   */
      static int
  buffercmd(dummy, interp, objc, objv)
!     ClientData dummy UNUSED;
      Tcl_Interp *interp;
      int objc;
      Tcl_Obj *CONST objv[];
***************
*** 475,484 ****
  /*
   * "::vim::window list" - create list of window commands.
   */
- /* ARGSUSED */
      static int
  windowcmd(dummy, interp, objc, objv)
!     ClientData	dummy;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
--- 471,479 ----
  /*
   * "::vim::window list" - create list of window commands.
   */
      static int
  windowcmd(dummy, interp, objc, objv)
!     ClientData	dummy UNUSED;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
***************
*** 1130,1139 ****
  }
  
  
- /* ARGSUSED */
      static int
  commandcmd(dummy, interp, objc, objv)
!     ClientData	dummy;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
--- 1125,1133 ----
  }
  
  
      static int
  commandcmd(dummy, interp, objc, objv)
!     ClientData	dummy UNUSED;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
***************
*** 1145,1154 ****
      return err;
  }
  
- /* ARGSUSED */
      static int
  optioncmd(dummy, interp, objc, objv)
!     ClientData	dummy;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
--- 1139,1147 ----
      return err;
  }
  
      static int
  optioncmd(dummy, interp, objc, objv)
!     ClientData	dummy UNUSED;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
***************
*** 1160,1169 ****
      return err;
  }
  
- /* ARGSUSED */
      static int
  exprcmd(dummy, interp, objc, objv)
!     ClientData	dummy;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
--- 1153,1161 ----
      return err;
  }
  
      static int
  exprcmd(dummy, interp, objc, objv)
!     ClientData	dummy UNUSED;
      Tcl_Interp	*interp;
      int		objc;
      Tcl_Obj	*CONST objv[];
***************
*** 1584,1594 ****
      I/O Channel
  ********************************************/
  
- /* ARGSUSED */
      static int
  channel_close(instance, interp)
      ClientData	instance;
!     Tcl_Interp	*interp;
  {
      int		err = 0;
  
--- 1576,1585 ----
      I/O Channel
  ********************************************/
  
      static int
  channel_close(instance, interp)
      ClientData	instance;
!     Tcl_Interp	*interp UNUSED;
  {
      int		err = 0;
  
***************
*** 1602,1613 ****
      return err;
  }
  
- /* ARGSUSED */
      static int
  channel_input(instance, buf, bufsiz, errptr)
!     ClientData	instance;
!     char	*buf;
!     int		bufsiz;
      int		*errptr;
  {
  
--- 1593,1603 ----
      return err;
  }
  
      static int
  channel_input(instance, buf, bufsiz, errptr)
!     ClientData	instance UNUSED;
!     char	*buf UNUSED;
!     int		bufsiz UNUSED;
      int		*errptr;
  {
  
***************
*** 1659,1679 ****
      return result;
  }
  
- /* ARGSUSED */
      static void
  channel_watch(instance, mask)
!     ClientData	instance;
!     int		mask;
  {
      Tcl_SetErrno(EINVAL);
  }
  
- /* ARGSUSED */
      static int
  channel_gethandle(instance, direction, handleptr)
!     ClientData	instance;
!     int		direction;
!     ClientData	*handleptr;
  {
      Tcl_SetErrno(EINVAL);
      return EINVAL;
--- 1649,1667 ----
      return result;
  }
  
      static void
  channel_watch(instance, mask)
!     ClientData	instance UNUSED;
!     int		mask UNUSED;
  {
      Tcl_SetErrno(EINVAL);
  }
  
      static int
  channel_gethandle(instance, direction, handleptr)
!     ClientData	instance UNUSED;
!     int		direction UNUSED;
!     ClientData	*handleptr UNUSED;
  {
      Tcl_SetErrno(EINVAL);
      return EINVAL;
***************
*** 1691,1697 ****
      NULL,   /* set option */
      NULL,   /* get option */
      channel_watch,
!     channel_gethandle
  };
  
  /**********************************
--- 1679,1692 ----
      NULL,   /* set option */
      NULL,   /* get option */
      channel_watch,
!     channel_gethandle,
!     NULL,
!     NULL,
!     NULL,
!     NULL,
!     NULL,
!     NULL,
!     NULL
  };
  
  /**********************************
*** ../vim-7.2.185/src/version.c	2009-05-22 18:20:23.000000000 +0200
--- src/version.c	2009-05-22 21:07:21.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     186,
  /**/

-- 
ARTHUR: Old woman!
DENNIS: Man!
ARTHUR: Man.  I'm sorry.  Old man, What knight live in that castle over there?
DENNIS: I'm thirty-seven.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.187
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.187 (after 7.2.186)
Problem:    Doesn't build with older versions of TCL. (Yongwei Wu)
Solution:   Add #ifdefs. (Dominique Pelle)
Files:	    src/if_tcl.c


*** ../vim-7.2.186/src/if_tcl.c	2009-05-22 21:07:45.000000000 +0200
--- src/if_tcl.c	2009-05-23 14:23:51.000000000 +0200
***************
*** 161,167 ****
  # endif
  
  /*
!  * Declare HANDLE for perl.dll and function pointers.
   */
  static HANDLE hTclLib = NULL;
  Tcl_Interp* (*dll_Tcl_CreateInterp)();
--- 161,167 ----
  # endif
  
  /*
!  * Declare HANDLE for tcl.dll and function pointers.
   */
  static HANDLE hTclLib = NULL;
  Tcl_Interp* (*dll_Tcl_CreateInterp)();
***************
*** 182,188 ****
   * Make all runtime-links of tcl.
   *
   * 1. Get module handle using LoadLibraryEx.
!  * 2. Get pointer to perl function by GetProcAddress.
   * 3. Repeat 2, until get all functions will be used.
   *
   * Parameter 'libname' provides name of DLL.
--- 182,188 ----
   * Make all runtime-links of tcl.
   *
   * 1. Get module handle using LoadLibraryEx.
!  * 2. Get pointer to tcl function by GetProcAddress.
   * 3. Repeat 2, until get all functions will be used.
   *
   * Parameter 'libname' provides name of DLL.
***************
*** 1670,1692 ****
  
  static Tcl_ChannelType channel_type =
  {
!     "vimmessage",
!     NULL,   /* blockmode */
!     channel_close,
!     channel_input,
!     channel_output,
!     NULL,   /* seek */
!     NULL,   /* set option */
!     NULL,   /* get option */
!     channel_watch,
!     channel_gethandle,
!     NULL,
!     NULL,
!     NULL,
!     NULL,
!     NULL,
!     NULL,
!     NULL
  };
  
  /**********************************
--- 1670,1700 ----
  
  static Tcl_ChannelType channel_type =
  {
!     "vimmessage",	/* typeName */
!     NULL,		/* version */
!     channel_close,	/* closeProc */
!     channel_input,	/* inputProc */
!     channel_output,	/* outputProc */
!     NULL,		/* seekProc */
!     NULL,		/* setOptionProc */
!     NULL,		/* getOptionProc */
!     channel_watch,	/* watchProc */
!     channel_gethandle,	/* getHandleProc */
!     NULL,		/* close2Proc */
!     NULL,		/* blockModeProc */
! #ifdef TCL_CHANNEL_VERSION_2
!     NULL,		/* flushProc */
!     NULL,		/* handlerProc */
! #endif
! #ifdef TCL_CHANNEL_VERSION_3
!     NULL,		/* wideSeekProc */
! #endif
! #ifdef TCL_CHANNEL_VERSION_4
!     NULL,		/* threadActionProc */
! #endif
! #ifdef TCL_CHANNEL_VERSION_5
!     NULL		/* truncateProc */
! #endif
  };
  
  /**********************************
*** ../vim-7.2.186/src/version.c	2009-05-22 21:07:45.000000000 +0200
--- src/version.c	2009-05-23 14:25:04.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     187,
  /**/

-- 
Friends?  I have lots of friends!  In fact, I have every episode ever made.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.188
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.188
Problem:    Crash with specific use of function calls. (Meikel Brandmeyer)
Solution:   Make sure the items referenced by a function call are not freed
	    twice.  (based on patch from Nico Weber)
Files:	    src/eval.c


*** ../vim-7.2.187/src/eval.c	2009-05-16 17:29:37.000000000 +0200
--- src/eval.c	2009-05-22 20:04:22.000000000 +0200
***************
*** 129,136 ****
--- 129,139 ----
  /*
   * When recursively copying lists and dicts we need to remember which ones we
   * have done to avoid endless recursiveness.  This unique ID is used for that.
+  * The last bit is used for previous_funccal, ignored when comparing.
   */
  static int current_copyID = 0;
+ #define COPYID_INC 2
+ #define COPYID_MASK (~0x1)
  
  /*
   * Array to hold the hashtab with variables local to each sourced script.
***************
*** 439,444 ****
--- 442,448 ----
  static void list_remove __ARGS((list_T *l, listitem_T *item, listitem_T *item2));
  static char_u *list2string __ARGS((typval_T *tv, int copyID));
  static int list_join __ARGS((garray_T *gap, list_T *l, char_u *sep, int echo, int copyID));
+ static int free_unref_items __ARGS((int copyID));
  static void set_ref_in_ht __ARGS((hashtab_T *ht, int copyID));
  static void set_ref_in_list __ARGS((list_T *l, int copyID));
  static void set_ref_in_item __ARGS((typval_T *tv, int copyID));
***************
*** 6494,6507 ****
      int
  garbage_collect()
  {
!     dict_T	*dd;
!     list_T	*ll;
!     int		copyID = ++current_copyID;
      buf_T	*buf;
      win_T	*wp;
      int		i;
      funccall_T	*fc, **pfc;
!     int		did_free = FALSE;
  #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
  #endif
--- 6498,6510 ----
      int
  garbage_collect()
  {
!     int		copyID;
      buf_T	*buf;
      win_T	*wp;
      int		i;
      funccall_T	*fc, **pfc;
!     int		did_free;
!     int		did_free_funccal = FALSE;
  #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
  #endif
***************
*** 6511,6520 ****
--- 6514,6538 ----
      may_garbage_collect = FALSE;
      garbage_collect_at_exit = FALSE;
  
+     /* We advance by two because we add one for items referenced through
+      * previous_funccal. */
+     current_copyID += COPYID_INC;
+     copyID = current_copyID;
+ 
      /*
       * 1. Go through all accessible variables and mark all lists and dicts
       *    with copyID.
       */
+ 
+     /* Don't free variables in the previous_funccal list unless they are only
+      * referenced through previous_funccal.  This must be first, because if
+      * the item is referenced elsewhere it must not be freed. */
+     for (fc = previous_funccal; fc != NULL; fc = fc->caller)
+     {
+ 	set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1);
+ 	set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1);
+     }
+ 
      /* script-local variables */
      for (i = 1; i <= ga_scripts.ga_len; ++i)
  	set_ref_in_ht(&SCRIPT_VARS(i), copyID);
***************
*** 6546,6556 ****
      /* v: vars */
      set_ref_in_ht(&vimvarht, copyID);
  
      /*
!      * 2. Go through the list of dicts and free items without the copyID.
       */
      for (dd = first_dict; dd != NULL; )
! 	if (dd->dv_copyID != copyID)
  	{
  	    /* Free the Dictionary and ordinary items it contains, but don't
  	     * recurse into Lists and Dictionaries, they will be in the list
--- 6564,6610 ----
      /* v: vars */
      set_ref_in_ht(&vimvarht, copyID);
  
+     /* Free lists and dictionaries that are not referenced. */
+     did_free = free_unref_items(copyID);
+ 
+     /* check if any funccal can be freed now */
+     for (pfc = &previous_funccal; *pfc != NULL; )
+     {
+ 	if (can_free_funccal(*pfc, copyID))
+ 	{
+ 	    fc = *pfc;
+ 	    *pfc = fc->caller;
+ 	    free_funccal(fc, TRUE);
+ 	    did_free = TRUE;
+ 	    did_free_funccal = TRUE;
+ 	}
+ 	else
+ 	    pfc = &(*pfc)->caller;
+     }
+     if (did_free_funccal)
+ 	/* When a funccal was freed some more items might be garbage
+ 	 * collected, so run again. */
+ 	(void)garbage_collect();
+ 
+     return did_free;
+ }
+ 
+ /*
+  * Free lists and dictionaries that are no longer referenced.
+  */
+     static int
+ free_unref_items(copyID)
+     int copyID;
+ {
+     dict_T	*dd;
+     list_T	*ll;
+     int		did_free = FALSE;
+ 
      /*
!      * Go through the list of dicts and free items without the copyID.
       */
      for (dd = first_dict; dd != NULL; )
! 	if ((dd->dv_copyID & COPYID_MASK) != (copyID & COPYID_MASK))
  	{
  	    /* Free the Dictionary and ordinary items it contains, but don't
  	     * recurse into Lists and Dictionaries, they will be in the list
***************
*** 6565,6576 ****
  	    dd = dd->dv_used_next;
  
      /*
!      * 3. Go through the list of lists and free items without the copyID.
!      *    But don't free a list that has a watcher (used in a for loop), these
!      *    are not referenced anywhere.
       */
      for (ll = first_list; ll != NULL; )
! 	if (ll->lv_copyID != copyID && ll->lv_watch == NULL)
  	{
  	    /* Free the List and ordinary items it contains, but don't recurse
  	     * into Lists and Dictionaries, they will be in the list of dicts
--- 6619,6631 ----
  	    dd = dd->dv_used_next;
  
      /*
!      * Go through the list of lists and free items without the copyID.
!      * But don't free a list that has a watcher (used in a for loop), these
!      * are not referenced anywhere.
       */
      for (ll = first_list; ll != NULL; )
! 	if ((ll->lv_copyID & COPYID_MASK) != (copyID & COPYID_MASK)
! 						      && ll->lv_watch == NULL)
  	{
  	    /* Free the List and ordinary items it contains, but don't recurse
  	     * into Lists and Dictionaries, they will be in the list of dicts
***************
*** 6584,6603 ****
  	else
  	    ll = ll->lv_used_next;
  
-     /* check if any funccal can be freed now */
-     for (pfc = &previous_funccal; *pfc != NULL; )
-     {
- 	if (can_free_funccal(*pfc, copyID))
- 	{
- 	    fc = *pfc;
- 	    *pfc = fc->caller;
- 	    free_funccal(fc, TRUE);
- 	    did_free = TRUE;
- 	}
- 	else
- 	    pfc = &(*pfc)->caller;
-     }
- 
      return did_free;
  }
  
--- 6639,6644 ----
***************
*** 18842,18847 ****
--- 18883,18889 ----
  {
      hash_init(&dict->dv_hashtab);
      dict->dv_refcount = DO_NOT_FREE_CNT;
+     dict->dv_copyID = 0;
      dict_var->di_tv.vval.v_dict = dict;
      dict_var->di_tv.v_type = VAR_DICT;
      dict_var->di_tv.v_lock = VAR_FIXED;
***************
*** 21294,21301 ****
      current_funccal = fc->caller;
      --depth;
  
!     /* if the a:000 list and the a: dict are not referenced we can free the
!      * funccall_T and what's in it. */
      if (fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT
  	    && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT
  	    && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)
--- 21336,21343 ----
      current_funccal = fc->caller;
      --depth;
  
!     /* If the a:000 list and the l: and a: dicts are not referenced we can
!      * free the funccall_T and what's in it. */
      if (fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT
  	    && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT
  	    && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)
***************
*** 21334,21340 ****
  
  /*
   * Return TRUE if items in "fc" do not have "copyID".  That means they are not
!  * referenced from anywhere.
   */
      static int
  can_free_funccal(fc, copyID)
--- 21376,21382 ----
  
  /*
   * Return TRUE if items in "fc" do not have "copyID".  That means they are not
!  * referenced from anywhere that is in use.
   */
      static int
  can_free_funccal(fc, copyID)
*** ../vim-7.2.187/src/version.c	2009-05-23 14:27:43.000000000 +0200
--- src/version.c	2009-05-24 13:20:49.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     188,
  /**/

-- 
ARTHUR:    ... and I am your king ....
OLD WOMAN: Ooooh!  I didn't know we had a king.  I thought we were an
           autonomous collective ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.189
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.189
Problem:    Possible hang for deleting auto-indent. (Dominique Pelle)
Solution:   Make sure the position is not beyond the end of the line.
Files:	    src/edit.c


*** ../vim-7.2.188/src/edit.c	2009-05-16 16:36:25.000000000 +0200
--- src/edit.c	2009-05-26 10:53:05.000000000 +0200
***************
*** 6420,6432 ****
  
  	/* If we just did an auto-indent, remove the white space from the end
  	 * of the line, and put the cursor back.
! 	 * Do this when ESC was used or moving the cursor up/down. */
  	if (did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL
! 			&& curwin->w_cursor.lnum != end_insert_pos->lnum)))
  	{
  	    pos_T	tpos = curwin->w_cursor;
  
  	    curwin->w_cursor = *end_insert_pos;
  	    for (;;)
  	    {
  		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
--- 6420,6436 ----
  
  	/* If we just did an auto-indent, remove the white space from the end
  	 * of the line, and put the cursor back.
! 	 * Do this when ESC was used or moving the cursor up/down.
! 	 * Check for the old position still being valid, just in case the text
! 	 * got changed unexpectedly. */
  	if (did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL
! 			&& curwin->w_cursor.lnum != end_insert_pos->lnum))
! 		&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)
  	{
  	    pos_T	tpos = curwin->w_cursor;
  
  	    curwin->w_cursor = *end_insert_pos;
+ 	    check_cursor_col();  /* make sure it is not past the line */
  	    for (;;)
  	    {
  		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
***************
*** 6434,6440 ****
  		cc = gchar_cursor();
  		if (!vim_iswhite(cc))
  		    break;
! 		(void)del_char(TRUE);
  	    }
  	    if (curwin->w_cursor.lnum != tpos.lnum)
  		curwin->w_cursor = tpos;
--- 6438,6445 ----
  		cc = gchar_cursor();
  		if (!vim_iswhite(cc))
  		    break;
! 		if (del_char(TRUE) == FAIL)
! 		    break;  /* should not happen */
  	    }
  	    if (curwin->w_cursor.lnum != tpos.lnum)
  		curwin->w_cursor = tpos;
*** ../vim-7.2.188/src/version.c	2009-05-24 13:40:17.000000000 +0200
--- src/version.c	2009-05-26 10:50:53.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     189,
  /**/

-- 
FIRST VILLAGER: We have found a witch.  May we burn her?
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.190
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.190
Problem:    The register executed by @@ isn't restored.
Solution:   Mark the executable register in the viminfo file.
Files:	    src/ops.c


*** ../vim-7.2.189/src/ops.c	2009-05-13 12:46:36.000000000 +0200
--- src/ops.c	2009-05-26 18:05:23.000000000 +0200
***************
*** 1143,1148 ****
--- 1143,1150 ----
      return OK;
  }
  
+ static int execreg_lastc = NUL;
+ 
  /*
   * execute a yank register: copy it into the stuff buffer
   *
***************
*** 1155,1161 ****
      int	    addcr;		/* always add '\n' to end of line */
      int	    silent;		/* set "silent" flag in typeahead buffer */
  {
-     static int	lastc = NUL;
      long	i;
      char_u	*p;
      int		retval = OK;
--- 1157,1162 ----
***************
*** 1163,1174 ****
  
      if (regname == '@')			/* repeat previous one */
      {
! 	if (lastc == NUL)
  	{
  	    EMSG(_("E748: No previously used register"));
  	    return FAIL;
  	}
! 	regname = lastc;
      }
  					/* check for valid regname */
      if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))
--- 1164,1175 ----
  
      if (regname == '@')			/* repeat previous one */
      {
! 	if (execreg_lastc == NUL)
  	{
  	    EMSG(_("E748: No previously used register"));
  	    return FAIL;
  	}
! 	regname = execreg_lastc;
      }
  					/* check for valid regname */
      if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))
***************
*** 1176,1182 ****
  	emsg_invreg(regname);
  	return FAIL;
      }
!     lastc = regname;
  
  #ifdef FEAT_CLIPBOARD
      regname = may_get_selection(regname);
--- 1177,1183 ----
  	emsg_invreg(regname);
  	return FAIL;
      }
!     execreg_lastc = regname;
  
  #ifdef FEAT_CLIPBOARD
      regname = may_get_selection(regname);
***************
*** 5337,5347 ****
--- 5338,5351 ----
  
      /* We only get here (hopefully) if line[0] == '"' */
      str = virp->vir_line + 1;
+ 
+     /* If the line starts with "" this is the y_previous register. */
      if (*str == '"')
      {
  	set_prev = TRUE;
  	str++;
      }
+ 
      if (!ASCII_ISALNUM(*str) && *str != '-')
      {
  	if (viminfo_error("E577: ", _("Illegal register name"), virp->vir_line))
***************
*** 5351,5356 ****
--- 5355,5368 ----
      get_yank_register(*str++, FALSE);
      if (!force && y_current->y_array != NULL)
  	do_it = FALSE;
+ 
+     if (*str == '@')
+     {
+ 	/* "x@: register x used for @@ */
+ 	if (force || execreg_lastc == NUL)
+ 	    execreg_lastc = str[-1];
+     }
+ 
      size = 0;
      limit = 100;	/* Optimized for registers containing <= 100 lines */
      if (do_it)
***************
*** 5360,5366 ****
  	vim_free(y_current->y_array);
  	array = y_current->y_array =
  		       (char_u **)alloc((unsigned)(limit * sizeof(char_u *)));
! 	str = skipwhite(str);
  	if (STRNCMP(str, "CHAR", 4) == 0)
  	    y_current->y_type = MCHAR;
  #ifdef FEAT_VISUAL
--- 5372,5378 ----
  	vim_free(y_current->y_array);
  	array = y_current->y_array =
  		       (char_u **)alloc((unsigned)(limit * sizeof(char_u *)));
! 	str = skipwhite(skiptowhite(str));
  	if (STRNCMP(str, "CHAR", 4) == 0)
  	    y_current->y_type = MCHAR;
  #ifdef FEAT_VISUAL
***************
*** 5443,5448 ****
--- 5455,5461 ----
      max_kbyte = get_viminfo_parameter('s');
      if (max_kbyte == 0)
  	return;
+ 
      for (i = 0; i < NUM_REGISTERS; i++)
      {
  	if (y_regs[i].y_array == NULL)
***************
*** 5497,5503 ****
  	if (y_previous == &y_regs[i])
  	    fprintf(fp, "\"");
  	c = get_register_name(i);
! 	fprintf(fp, "\"%c\t%s\t%d\n", c, type,
  #ifdef FEAT_VISUAL
  		    (int)y_regs[i].y_width
  #else
--- 5510,5519 ----
  	if (y_previous == &y_regs[i])
  	    fprintf(fp, "\"");
  	c = get_register_name(i);
! 	fprintf(fp, "\"%c", c);
! 	if (c == execreg_lastc)
! 	    fprintf(fp, "@");
! 	fprintf(fp, "\t%s\t%d\n", type,
  #ifdef FEAT_VISUAL
  		    (int)y_regs[i].y_width
  #else
*** ../vim-7.2.189/src/version.c	2009-05-26 11:01:43.000000000 +0200
--- src/version.c	2009-05-26 18:10:13.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     190,
  /**/

-- 
If you had to identify, in one word, the reason why the
human race has not achieved, and never will achieve, its
full potential, that word would be "meetings."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.191
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.191
Problem:    Mzscheme interface doesn't work on Ubuntu.
Solution:   Change autoconf rules.  Define missing macro.  Some changes to
	    avoid gcc warnings.  Remove per-buffer namespace. (Sergey Khorev)
Files:	    runtime/doc/if_mzsch.txt, src/Makefile, src/Make_ming.mak,
	    src/Make_mvc.mak, src/auto/configure, src/configure.in,
	    src/config.mk.in, src/eval.c, src/if_mzsch.c, src/if_mzsch.h,
	    src/main.c, src/proto/if_mzsch.pro


*** ../vim-7.2.190/runtime/doc/if_mzsch.txt	2008-08-09 19:36:48.000000000 +0200
--- runtime/doc/if_mzsch.txt	2009-05-26 18:49:53.000000000 +0200
***************
*** 1,4 ****
! *if_mzsch.txt*  For Vim version 7.2.  Last change: 2008 Jun 28
  
  
  		  VIM REFERENCE MANUAL    by Sergey Khorev
--- 1,4 ----
! *if_mzsch.txt*  For Vim version 7.2.  Last change: 2009 May 26
  
  
  		  VIM REFERENCE MANUAL    by Sergey Khorev
***************
*** 42,51 ****
  
  							*:mzfile* *:mzf*
  :[range]mzf[ile] {file}	Execute the MzScheme script in {file}.  {not in Vi}
- 			All statements are executed in the namespace of the
- 			buffer that was current during :mzfile start.
- 			If you want to access other namespaces, use
- 			'parameterize'.
  
  All of these commands do essentially the same thing - they execute a piece of
  MzScheme code, with the "current range" set to the given line
--- 42,47 ----
***************
*** 54,61 ****
  In the case of :mzscheme, the code to execute is in the command-line.
  In the case of :mzfile, the code to execute is the contents of the given file.
  
- Each buffer has its own MzScheme namespace. Global namespace is bound to
- the "global-namespace" value from the 'vimext' module.
  MzScheme interface defines exception exn:vim, derived from exn.
  It is raised for various Vim errors.
  
--- 50,55 ----
***************
*** 79,118 ****
  e.g.: >
  	:mzscheme (require (prefix vim- vimext))
  <
! All the examples below assume this naming scheme.  Note that you need to do
! this again for every buffer.
  
- The auto-instantiation can be achieved with autocommands, e.g. you can put
- something like this in your .vimrc (EOFs should not have indentation): >
-     function s:MzRequire()
- 	if has("mzscheme")
- 	    :mz << EOF
- 	    (require (prefix vim- vimext))
- 	    (let ((buf (vim-get-buff-by-name (vim-eval "expand(\"<afile>\")"))))
- 	      (when (and buf (not (eq? buf (vim-curr-buff))))
- 		(parameterize ((current-namespace (vim-get-buff-namespace buf)))
- 		  (namespace-attach-module vim-global-namespace 'vimext)
- 		  (namespace-require '(prefix vim vimext)))))
-     EOF
- 	endif
-     endfunction
- 
-     function s:MzStartup()
- 	if has("mzscheme")
- 	    au BufNew,BufNewFile,BufAdd,BufReadPre * :call s:MzRequire()
- 	    :mz << EOF
- 	    (current-library-collection-paths
- 		(cons
- 		    (build-path (find-system-path 'addon-dir) (version) "collects")
- 		    (current-library-collection-paths)))
-     EOF
- 	endif
-     endfunction
- 
-     call s:MzStartup()
- <
- 
- The global namespace just instantiated this module with the prefix "vimext:".
  							*mzscheme-sandbox*
  When executed in the |sandbox|, access to some filesystem and Vim interface
  procedures is restricted.
--- 73,80 ----
  e.g.: >
  	:mzscheme (require (prefix vim- vimext))
  <
! All the examples below assume this naming scheme. 
  
  							*mzscheme-sandbox*
  When executed in the |sandbox|, access to some filesystem and Vim interface
  procedures is restricted.
***************
*** 121,135 ****
  2. Examples						*mzscheme-examples*
  >
  	:mzscheme (display "Hello")
  	:mzscheme (vim-set-buff-line 10 "This is line #10")
  <
  Inline script usage: >
  	function! <SID>SetFirstLine()
  	    :mz << EOF
  	    (display "!!!")
  	    (vim-set-buff-line 1 "This is line #1")
  	    (vim-beep)
! 	    EOF
  	endfunction
  
  	nmap <F9> :call <SID>SetFirstLine() <CR>
--- 83,102 ----
  2. Examples						*mzscheme-examples*
  >
  	:mzscheme (display "Hello")
+ 	:mz (display (string-append "Using MzScheme version " (version)))
+ 	:mzscheme (require (prefix vim- vimext)) ; for MzScheme < 4.x
+ 	:mzscheme (require (prefix-in vim- 'vimext)) ; MzScheme 4.x
  	:mzscheme (vim-set-buff-line 10 "This is line #10")
  <
  Inline script usage: >
  	function! <SID>SetFirstLine()
  	    :mz << EOF
  	    (display "!!!")
+ 	    (require (prefix vim- vimext))
+ 	    ; for newer versions (require (prefix-in vim- 'vimext))
  	    (vim-set-buff-line 1 "This is line #1")
  	    (vim-beep)
! 	EOF
  	endfunction
  
  	nmap <F9> :call <SID>SetFirstLine() <CR>
***************
*** 137,153 ****
  File execution: >
  	:mzfile supascript.scm
  <
! Accessing the current buffer namespace from an MzScheme program running in
! another buffer within |:mzfile|-executed script : >
! 	; Move to the window below
! 	(vim-command "wincmd j")
! 	; execute in the context of buffer, to which window belongs
! 	; assume that buffer has 'textstring' defined
! 	(parameterize ((current-namespace
! 			(vim-get-buff-namespace (vim-curr-buff))))
! 	 (eval '(vim-set-buff-line 1 textstring)))
! <
  
  ==============================================================================
  3. Threads						*mzscheme-threads*
  
--- 104,136 ----
  File execution: >
  	:mzfile supascript.scm
  <
! Vim exception handling: >
! 	:mz << EOF
! 	(require (prefix vim- vimext))
! 	; for newer versions (require (prefix-in vim- 'vimext))
! 	(with-handlers
! 	  ([exn:vim? (lambda (e) (display (exn-message e)))])
! 	  (vim-eval "nonsense-string"))
! 	EOF
! <
! Auto-instantiation of vimext module (can be placed in your |vimrc|): >
!     function! MzRequire()
! 	:redir => l:mzversion
! 	:mz (version)
! 	:redir END
! 	if strpart(l:mzversion, 1, 1) < "4"
! 	    " MzScheme versions < 4.x:
! 	    :mz (require (prefix vim- vimext))
! 	else
! 	    " newer versions:
! 	    :mz (require (prefix-in vim- 'vimext))
! 	endif
!     endfunction
  
+     if has("mzscheme")
+ 	silent call MzRequire()
+     endif
+ <
  ==============================================================================
  3. Threads						*mzscheme-threads*
  
***************
*** 168,178 ****
  Common
  ------
      (command {command-string})	    Perform the vim ":Ex" style command.
!     (eval {expr-string})	    Evaluate the vim expression to a string.
! 				    A |List| is turned into a string by
! 				    joining the items and inserting line
! 				    breaks.
! 				    NOTE clashes with MzScheme eval
      (range-start)		    Start/End of the range passed with
      (range-end)			    the Scheme command.
      (beep)			    beep
--- 151,161 ----
  Common
  ------
      (command {command-string})	    Perform the vim ":Ex" style command.
!     (eval {expr-string})	    Evaluate the vim expression into
! 				    respective MzScheme object: |Lists| are
! 				    represented as Scheme lists,
! 				    |Dictionaries| as hash tables.
! 				    NOTE the name clashes with MzScheme eval
      (range-start)		    Start/End of the range passed with
      (range-end)			    the Scheme command.
      (beep)			    beep
***************
*** 186,192 ****
  				    be set. The symbol 'global can be passed
  				    as {buffer-or-window}. Then |:setglobal|
  				    will be used.
-     global-namespace		    The MzScheme main namespace.
  
  Buffers							 *mzscheme-buffer*
  -------
--- 169,174 ----
***************
*** 228,234 ****
  					if there is no such buffer.
      (get-buff-by-num {buffernum})   Get a buffer by its number (return #f if
  				    there is no buffer with this number).
-     (get-buff-namespace [buffer])   Get buffer namespace.
  
  Windows							    *mzscheme-window*
  ------
--- 210,215 ----
***************
*** 250,256 ****
      (set-cursor (line . col) [window])  Set cursor position.
  
  ==============================================================================
! 5. Dynamic loading					*mzscheme-dynamic*
  
  On MS-Windows the MzScheme libraries can be loaded dynamically. The |:version|
  output then includes |+mzscheme/dyn|.
--- 231,237 ----
      (set-cursor (line . col) [window])  Set cursor position.
  
  ==============================================================================
! 5. Dynamic loading				    *mzscheme-dynamic* *E812*
  
  On MS-Windows the MzScheme libraries can be loaded dynamically. The |:version|
  output then includes |+mzscheme/dyn|.
*** ../vim-7.2.190/src/Makefile	2009-05-26 18:12:19.000000000 +0200
--- src/Makefile	2009-05-26 22:54:48.000000000 +0200
***************
*** 536,542 ****
  # Use this with GCC to check for mistakes, unused arguments, etc.
  #CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code
  #PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
! #MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code
  
  # EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
  # allocated memory (and makes every malloc()/free() very slow).
--- 536,542 ----
  # Use this with GCC to check for mistakes, unused arguments, etc.
  #CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code
  #PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
! #MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter
  
  # EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
  # allocated memory (and makes every malloc()/free() very slow).
***************
*** 2200,2205 ****
--- 2200,2206 ----
  	-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c
  	-rm -f conftest* *~ auto/link.sed
  	-rm -rf $(APPDIR)
+ 	-rm -rf mzscheme_base.c
  	if test -d $(PODIR); then \
  		cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \
  	fi
***************
*** 2433,2440 ****
  objects/if_xcmdsrv.o: if_xcmdsrv.c
  	$(CCC) -o $@ if_xcmdsrv.c
  
! objects/if_mzsch.o: if_mzsch.c
  	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
  
  objects/if_perl.o: auto/if_perl.c
  	$(CCC) -o $@ auto/if_perl.c
--- 2434,2444 ----
  objects/if_xcmdsrv.o: if_xcmdsrv.c
  	$(CCC) -o $@ if_xcmdsrv.c
  
! objects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)
  	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
+  
+ mzscheme_base.c:
+ 	$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base
  
  objects/if_perl.o: auto/if_perl.c
  	$(CCC) -o $@ auto/if_perl.c
*** ../vim-7.2.190/src/Make_ming.mak	2007-08-12 15:24:29.000000000 +0200
--- src/Make_ming.mak	2009-05-26 18:54:15.000000000 +0200
***************
*** 115,122 ****
--- 115,135 ----
  MZSCHEME_VER=205_000
  endif
  
+ ifndef MZSCHEME_PRECISE_GC
+ MZSCHEME_PRECISE_GC=no
+ endif
+ 
+ # for version 4.x we need to generate byte-code for Scheme base
+ ifndef MZSCHEME_GENERATE_BASE
+ MZSCHEME_GENERATE_BASE=no
+ endif
+ 
  ifeq (no,$(DYNAMIC_MZSCHEME))
+ ifeq (yes,$(MZSCHEME_PRECISE_GC))
+ MZSCHEME_LIB=-lmzsch$(MZSCHEME_VER)
+ else
  MZSCHEME_LIB = -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
+ endif
  # the modern MinGW can dynamically link to dlls directly.
  # point MZSCHEME_DLLS to where you put libmzschXXXXXXX.dll and libgcXXXXXXX.dll
  ifndef MZSCHEME_DLLS
***************
*** 410,415 ****
--- 423,435 ----
  ifdef MZSCHEME
  OBJ += $(OUTDIR)/if_mzsch.o
  MZSCHEME_INCL = if_mzsch.h
+ ifeq (yes,$(MZSCHEME_GENERATE_BASE))
+ CFLAGS += -DINCLUDE_MZSCHEME_BASE
+ MZ_EXTRA_DEP += mzscheme_base.c
+ endif
+ ifeq (yes,$(MZSCHEME_PRECISE_GC))
+ CFLAGS += -DMZ_PRECISE_GC
+ endif
  endif
  ifdef PYTHON
  OBJ += $(OUTDIR)/if_python.o
***************
*** 588,593 ****
--- 608,619 ----
  $(OUTDIR)/netbeans.o:	netbeans.c $(INCL) $(NBDEBUG_INCL) $(NBDEBUG_SRC)
  	$(CC) -c $(CFLAGS) netbeans.c -o $(OUTDIR)/netbeans.o
  
+ $(OUTDIR)/if_mzsch.o:	if_mzsch.c $(INCL) if_mzsch.h $(MZ_EXTRA_DEP)
+ 	$(CC) -c $(CFLAGS) if_mzsch.c -o $(OUTDIR)/if_mzsch.o
+ 
+ mzscheme_base.c:
+ 	$(MZSCHEME)/mzc --c-mods mzscheme_base.c ++lib scheme/base
+ 
  pathdef.c: $(INCL)
  ifneq (sh.exe, $(SHELL))
  	@echo creating pathdef.c
*** ../vim-7.2.190/src/Make_mvc.mak	2009-02-04 18:34:54.000000000 +0100
--- src/Make_mvc.mak	2009-05-26 18:54:51.000000000 +0200
***************
*** 34,39 ****
--- 34,40 ----
  #	  MZSCHEME=[Path to MzScheme directory]
  #	  DYNAMIC_MZSCHEME=yes (to load the MzScheme DLLs dynamically)
  #	  MZSCHEME_VER=[version, 205_000, ...]
+ #	  MZSCHEME_DEBUG=no
  #
  #	Perl interface:
  #	  PERL=[Path to Perl directory]
***************
*** 621,635 ****
--- 622,658 ----
  MZSCHEME_VER = 205_000
  !endif
  CFLAGS = $(CFLAGS) -DFEAT_MZSCHEME -I $(MZSCHEME)\include
+ !if EXIST("$(MZSCHEME)\collects\scheme\base.ss")
+ # for MzScheme 4.x we need to include byte code for basic Scheme stuff
+ MZSCHEME_EXTRA_DEP = mzscheme_base.c
+ CFLAGS = $(CFLAGS) -DINCLUDE_MZSCHEME_BASE
+ !endif
+ !if EXIST("$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib") \
+ 	&& !EXIST("$(MZSCHEME)\lib\msvc\libmzgc$(MZSCHEME_VER).lib")
+ !message Building with Precise GC
+ MZSCHEME_PRECISE_GC = yes
+ CFLAGS = $(CFLAGS) -DMZ_PRECISE_GC
+ !endif
  !if "$(DYNAMIC_MZSCHEME)" == "yes"
+ !if "$(MZSCHEME_PRECISE_GC)" == "yes"
+ !error MzScheme with Precise GC cannot be loaded dynamically
+ !endif
  !message MzScheme DLLs will be loaded dynamically
  CFLAGS = $(CFLAGS) -DDYNAMIC_MZSCHEME \
  		-DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" \
  		-DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
  !else
+ !if "$(MZSCHEME_DEBUG)" == "yes"
+ CFLAGS = $(CFLAGS) -DMZSCHEME_FORCE_GC
+ !endif
+ !if "$(MZSCHEME_PRECISE_GC)" == "yes"
+ # Precise GC does not use separate dll
+ MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib
+ !else
  MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\libmzgc$(MZSCHEME_VER).lib \
  		$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib
  !endif
+ !endif
  MZSCHEME_OBJ = $(OUTDIR)\if_mzsch.obj
  !endif
  
***************
*** 930,938 ****
  $(OUTDIR)/if_perlsfio.obj: $(OUTDIR) if_perlsfio.c  $(INCL)
  	$(CC) $(CFLAGS) $(PERL_INC) if_perlsfio.c
  
! $(OUTDIR)/if_mzsch.obj: $(OUTDIR) if_mzsch.c  $(INCL)
  	$(CC) $(CFLAGS) if_mzsch.c \
  		-DMZSCHEME_COLLECTS=\"$(MZSCHEME:\=\\)\\collects\"
  
  $(OUTDIR)/if_python.obj: $(OUTDIR) if_python.c  $(INCL)
  	$(CC) $(CFLAGS) $(PYTHON_INC) if_python.c
--- 953,963 ----
  $(OUTDIR)/if_perlsfio.obj: $(OUTDIR) if_perlsfio.c  $(INCL)
  	$(CC) $(CFLAGS) $(PERL_INC) if_perlsfio.c
  
! $(OUTDIR)/if_mzsch.obj: $(OUTDIR) if_mzsch.c  $(INCL) $(MZSCHEME_EXTRA_DEP)
  	$(CC) $(CFLAGS) if_mzsch.c \
  		-DMZSCHEME_COLLECTS=\"$(MZSCHEME:\=\\)\\collects\"
+ mzscheme_base.c:
+ 	$(MZSCHEME)\mzc --c-mods mzscheme_base.c ++lib scheme/base
  
  $(OUTDIR)/if_python.obj: $(OUTDIR) if_python.c  $(INCL)
  	$(CC) $(CFLAGS) $(PYTHON_INC) if_python.c
*** ../vim-7.2.190/src/auto/configure	2009-05-21 23:25:38.000000000 +0200
--- src/auto/configure	2009-05-26 19:12:29.000000000 +0200
***************
*** 701,706 ****
--- 701,708 ----
  shrpenv
  vi_cv_perllib
  vi_cv_path_perl
+ MZSCHEME_MZC
+ MZSCHEME_EXTRA
  MZSCHEME_CFLAGS
  MZSCHEME_LIBS
  MZSCHEME_PRO
***************
*** 4641,4648 ****
  $as_echo "\"$PLTHOME\"" >&6; }
  	vi_cv_path_mzscheme_pfx="$PLTHOME"
      else
! 	{ $as_echo "$as_me:$LINENO: result: \"not set\"" >&5
! $as_echo "\"not set\"" >&6; }
  		# Extract the first word of "mzscheme", so it can be a program name with args.
  set dummy mzscheme; ac_word=$2
  { $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
--- 4643,4650 ----
  $as_echo "\"$PLTHOME\"" >&6; }
  	vi_cv_path_mzscheme_pfx="$PLTHOME"
      else
! 	{ $as_echo "$as_me:$LINENO: result: not set" >&5
! $as_echo "not set" >&6; }
  		# Extract the first word of "mzscheme", so it can be a program name with args.
  set dummy mzscheme; ac_word=$2
  { $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
***************
*** 4697,4712 ****
  if test "${vi_cv_path_mzscheme_pfx+set}" = set; then
    $as_echo_n "(cached) " >&6
  else
!    vi_cv_path_mzscheme_pfx=`
! 	    ${vi_cv_path_mzscheme} -evm \
! 	    "(display (simplify-path		\
  	       (build-path (call-with-values	\
  		(lambda () (split-path (find-system-path (quote exec-file)))) \
! 		(lambda (base name must-be-dir?) base)) (quote up))))"`
  fi
  { $as_echo "$as_me:$LINENO: result: $vi_cv_path_mzscheme_pfx" >&5
  $as_echo "$vi_cv_path_mzscheme_pfx" >&6; }
! 	    	    vi_cv_path_mzscheme_pfx=`echo "$vi_cv_path_mzscheme_pfx" | sed 's+/$++'`
  	fi
      fi
    fi
--- 4699,4714 ----
  if test "${vi_cv_path_mzscheme_pfx+set}" = set; then
    $as_echo_n "(cached) " >&6
  else
!   	    	    echo "(display (simplify-path		\
  	       (build-path (call-with-values	\
  		(lambda () (split-path (find-system-path (quote exec-file)))) \
! 		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
! 	    	     vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
! 		sed -e 's+/$++'`
  fi
  { $as_echo "$as_me:$LINENO: result: $vi_cv_path_mzscheme_pfx" >&5
  $as_echo "$vi_cv_path_mzscheme_pfx" >&6; }
! 	    rm -f mzdirs.scm
  	fi
      fi
    fi
***************
*** 4716,4736 ****
      { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include" >&5
  $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include... " >&6; }
      if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
!       { $as_echo "$as_me:$LINENO: result: \"yes\"" >&5
! $as_echo "\"yes\"" >&6; }
      else
!       { $as_echo "$as_me:$LINENO: result: \"no\"" >&5
! $as_echo "\"no\"" >&6; }
!       { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include" >&5
! $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include... " >&6; }
        if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
! 	{ $as_echo "$as_me:$LINENO: result: \"yes\"" >&5
! $as_echo "\"yes\"" >&6; }
! 	SCHEME_INC=/plt
        else
! 	{ $as_echo "$as_me:$LINENO: result: \"no\"" >&5
! $as_echo "\"no\"" >&6; }
! 	vi_cv_path_mzscheme_pfx=
        fi
      fi
    fi
--- 4718,4749 ----
      { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include" >&5
  $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include... " >&6; }
      if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
!       SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
!       { $as_echo "$as_me:$LINENO: result: yes" >&5
! $as_echo "yes" >&6; }
      else
!       { $as_echo "$as_me:$LINENO: result: no" >&5
! $as_echo "no" >&6; }
!       { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt" >&5
! $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt... " >&6; }
        if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
! 	{ $as_echo "$as_me:$LINENO: result: yes" >&5
! $as_echo "yes" >&6; }
! 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
        else
! 	{ $as_echo "$as_me:$LINENO: result: no" >&5
! $as_echo "no" >&6; }
! 	{ $as_echo "$as_me:$LINENO: checking if scheme.h can be found in /usr/include/plt/" >&5
! $as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
! 	if test -f /usr/include/plt/scheme.h; then
! 	  { $as_echo "$as_me:$LINENO: result: yes" >&5
! $as_echo "yes" >&6; }
! 	  SCHEME_INC=/usr/include/plt
! 	else
! 	  { $as_echo "$as_me:$LINENO: result: no" >&5
! $as_echo "no" >&6; }
! 	  vi_cv_path_mzscheme_pfx=
! 	fi
        fi
      fi
    fi
***************
*** 4738,4758 ****
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      if test "x$MACOSX" = "xyes"; then
        MZSCHEME_LIBS="-framework PLT_MzScheme"
      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
!       MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
        if test "$GCC" = yes; then
! 			MZSCHEME_LIBS="$MZSCHEME_LIBS -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
        elif test "`(uname) 2>/dev/null`" = SunOS &&
  			       uname -r | grep '^5' >/dev/null; then
! 	MZSCHEME_LIBS="$MZSCHEME_LIBS -R ${vi_cv_path_mzscheme_pfx}/lib"
        fi
      fi
      if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
        SCHEME_COLLECTS=lib/plt/
      fi
!     MZSCHEME_CFLAGS="-I${vi_cv_path_mzscheme_pfx}/include${SCHEME_INC}   \
        -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
      MZSCHEME_SRC="if_mzsch.c"
      MZSCHEME_OBJ="objects/if_mzsch.o"
--- 4751,4784 ----
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      if test "x$MACOSX" = "xyes"; then
        MZSCHEME_LIBS="-framework PLT_MzScheme"
+     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
+       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
+       MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
!             if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
!         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
! 	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
!       else
!         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
!       fi
        if test "$GCC" = yes; then
! 			MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
        elif test "`(uname) 2>/dev/null`" = SunOS &&
  			       uname -r | grep '^5' >/dev/null; then
! 	MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${vi_cv_path_mzscheme_pfx}/lib"
        fi
      fi
      if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
        SCHEME_COLLECTS=lib/plt/
      fi
!     if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
!             MZSCHEME_EXTRA="mzscheme_base.c"
!       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
!       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
!     fi
!     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
        -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
      MZSCHEME_SRC="if_mzsch.c"
      MZSCHEME_OBJ="objects/if_mzsch.o"
***************
*** 4767,4772 ****
--- 4793,4800 ----
  
  
  
+ 
+ 
  fi
  
  
*** ../vim-7.2.190/src/configure.in	2009-05-21 23:25:38.000000000 +0200
--- src/configure.in	2009-05-26 18:57:35.000000000 +0200
***************
*** 414,420 ****
  	AC_MSG_RESULT("$PLTHOME")
  	vi_cv_path_mzscheme_pfx="$PLTHOME"
      else
! 	AC_MSG_RESULT("not set")
  	dnl -- try to find MzScheme executable
  	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
  
--- 414,420 ----
  	AC_MSG_RESULT("$PLTHOME")
  	vi_cv_path_mzscheme_pfx="$PLTHOME"
      else
! 	AC_MSG_RESULT(not set)
  	dnl -- try to find MzScheme executable
  	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
  
***************
*** 430,443 ****
  	if test "X$vi_cv_path_mzscheme" != "X"; then
  	    dnl -- find where MzScheme thinks it was installed
  	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
! 	    [ vi_cv_path_mzscheme_pfx=`
! 	    ${vi_cv_path_mzscheme} -evm \
! 	    "(display (simplify-path		\
  	       (build-path (call-with-values	\
  		(lambda () (split-path (find-system-path (quote exec-file)))) \
! 		(lambda (base name must-be-dir?) base)) (quote up))))"` ])
! 	    dnl Remove a trailing slash.
! 	    vi_cv_path_mzscheme_pfx=`echo "$vi_cv_path_mzscheme_pfx" | sed 's+/$++'`
  	fi
      fi
    fi
--- 430,445 ----
  	if test "X$vi_cv_path_mzscheme" != "X"; then
  	    dnl -- find where MzScheme thinks it was installed
  	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
! 	    dnl different versions of MzScheme differ in command line processing
! 	    dnl use universal approach
! 	    echo "(display (simplify-path		\
  	       (build-path (call-with-values	\
  		(lambda () (split-path (find-system-path (quote exec-file)))) \
! 		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
! 	    dnl Remove a trailing slash
! 	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
! 		sed -e 's+/$++'` ])
! 	    rm -f mzdirs.scm
  	fi
      fi
    fi
***************
*** 446,461 ****
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
      if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
!       AC_MSG_RESULT("yes")
      else
!       AC_MSG_RESULT("no")
!       AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include)
        if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
! 	AC_MSG_RESULT("yes")
! 	SCHEME_INC=/plt
        else
! 	AC_MSG_RESULT("no")
! 	vi_cv_path_mzscheme_pfx=
        fi
      fi
    fi
--- 448,471 ----
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
      if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
!       SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
!       AC_MSG_RESULT(yes)
      else
!       AC_MSG_RESULT(no)
!       AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
        if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
! 	AC_MSG_RESULT(yes)
! 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
        else
! 	AC_MSG_RESULT(no)
! 	AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
! 	if test -f /usr/include/plt/scheme.h; then
! 	  AC_MSG_RESULT(yes)
! 	  SCHEME_INC=/usr/include/plt
! 	else
! 	  AC_MSG_RESULT(no)
! 	  vi_cv_path_mzscheme_pfx=
! 	fi
        fi
      fi
    fi
***************
*** 463,485 ****
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      if test "x$MACOSX" = "xyes"; then
        MZSCHEME_LIBS="-framework PLT_MzScheme"
      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
!       MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
        if test "$GCC" = yes; then
  	dnl Make Vim remember the path to the library.  For when it's not in
  	dnl $LD_LIBRARY_PATH.
! 	MZSCHEME_LIBS="$MZSCHEME_LIBS -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
        elif test "`(uname) 2>/dev/null`" = SunOS &&
  			       uname -r | grep '^5' >/dev/null; then
! 	MZSCHEME_LIBS="$MZSCHEME_LIBS -R ${vi_cv_path_mzscheme_pfx}/lib"
        fi
      fi
      if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
        SCHEME_COLLECTS=lib/plt/
      fi
!     MZSCHEME_CFLAGS="-I${vi_cv_path_mzscheme_pfx}/include${SCHEME_INC}   \
        -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
      MZSCHEME_SRC="if_mzsch.c"
      MZSCHEME_OBJ="objects/if_mzsch.o"
--- 473,510 ----
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      if test "x$MACOSX" = "xyes"; then
        MZSCHEME_LIBS="-framework PLT_MzScheme"
+     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
+       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
+       MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
!       dnl Using shared objects
!       if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
!         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
! 	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
!       else
!         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
!       fi
        if test "$GCC" = yes; then
  	dnl Make Vim remember the path to the library.  For when it's not in
  	dnl $LD_LIBRARY_PATH.
! 	MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
        elif test "`(uname) 2>/dev/null`" = SunOS &&
  			       uname -r | grep '^5' >/dev/null; then
! 	MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${vi_cv_path_mzscheme_pfx}/lib"
        fi
      fi
      if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
        SCHEME_COLLECTS=lib/plt/
      fi
!     if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
!       dnl need to generate bytecode for MzScheme base
!       MZSCHEME_EXTRA="mzscheme_base.c"
!       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
!       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
!     fi
!     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
        -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
      MZSCHEME_SRC="if_mzsch.c"
      MZSCHEME_OBJ="objects/if_mzsch.o"
***************
*** 491,496 ****
--- 516,523 ----
    AC_SUBST(MZSCHEME_PRO)
    AC_SUBST(MZSCHEME_LIBS)
    AC_SUBST(MZSCHEME_CFLAGS)
+   AC_SUBST(MZSCHEME_EXTRA)
+   AC_SUBST(MZSCHEME_MZC)
  fi
  
  
*** ../vim-7.2.190/src/config.mk.in	2008-06-25 00:49:03.000000000 +0200
--- src/config.mk.in	2009-05-26 18:57:49.000000000 +0200
***************
*** 41,46 ****
--- 41,48 ----
  MZSCHEME_OBJ	= @MZSCHEME_OBJ@
  MZSCHEME_CFLAGS	= @MZSCHEME_CFLAGS@
  MZSCHEME_PRO	= @MZSCHEME_PRO@
+ MZSCHEME_EXTRA  = @MZSCHEME_EXTRA@
+ MZSCHEME_MZC	= @MZSCHEME_MZC@
  
  PERL		= @vi_cv_path_perl@
  PERLLIB		= @vi_cv_perllib@
*** ../vim-7.2.190/src/eval.c	2009-05-24 13:40:17.000000000 +0200
--- src/eval.c	2009-05-26 18:58:20.000000000 +0200
***************
*** 5866,5872 ****
      return item1 == NULL && item2 == NULL;
  }
  
! #if defined(FEAT_PYTHON) || defined(PROTO)
  /*
   * Return the dictitem that an entry in a hashtable points to.
   */
--- 5866,5872 ----
      return item1 == NULL && item2 == NULL;
  }
  
! #if defined(FEAT_PYTHON) || defined(FEAT_MZSCHEME) || defined(PROTO)
  /*
   * Return the dictitem that an entry in a hashtable points to.
   */
*** ../vim-7.2.190/src/if_mzsch.c	2009-05-17 16:23:20.000000000 +0200
--- src/if_mzsch.c	2009-05-26 19:24:18.000000000 +0200
***************
*** 4,9 ****
--- 4,11 ----
   * Original work by Brent Fulgham <bfulgham@debian.org>
   * (Based on lots of help from Matthew Flatt)
   *
+  * TODO Convert byte-strings to char strings?
+  *
   * This consists of six parts:
   * 1. MzScheme interpreter main program
   * 2. Routines that handle the external interface between MzScheme and
***************
*** 18,24 ****
   *    garbage collector will do it self
   * 2. Requires at least NORMAL features. I can't imagine why one may want
   *    to build with SMALL or TINY features but with MzScheme interface.
!  * 3. I don't use K&R-style functions. Anyway, MzScheme headers are ANSI.
   */
  
  #include "vim.h"
--- 20,26 ----
   *    garbage collector will do it self
   * 2. Requires at least NORMAL features. I can't imagine why one may want
   *    to build with SMALL or TINY features but with MzScheme interface.
!  * 3. I don't use K&R-style functions. Anyways, MzScheme headers are ANSI.
   */
  
  #include "vim.h"
***************
*** 29,42 ****
   * depend". */
  #if defined(FEAT_MZSCHEME) || defined(PROTO)
  
  /* Base data structures */
  #define SCHEME_VIMBUFFERP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_buffer_type)
  #define SCHEME_VIMWINDOWP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_window_type)
  
  typedef struct
  {
!     Scheme_Type	    tag;
!     Scheme_Env	    *env;
      buf_T	    *buf;
  } vim_mz_buffer;
  
--- 31,45 ----
   * depend". */
  #if defined(FEAT_MZSCHEME) || defined(PROTO)
  
+ #include <assert.h>
+ 
  /* Base data structures */
  #define SCHEME_VIMBUFFERP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_buffer_type)
  #define SCHEME_VIMWINDOWP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_window_type)
  
  typedef struct
  {
!     Scheme_Object   so;
      buf_T	    *buf;
  } vim_mz_buffer;
  
***************
*** 44,50 ****
  
  typedef struct
  {
!     Scheme_Type	    tag;
      win_T	    *win;
  } vim_mz_window;
  
--- 47,53 ----
  
  typedef struct
  {
!     Scheme_Object   so;
      win_T	    *win;
  } vim_mz_window;
  
***************
*** 67,85 ****
      Scheme_Object   *port;
  } Port_Info;
  
- /* info for closed prim */
- /*
-  * data have different means:
-  * for do_eval it is char*
-  * for do_apply is Apply_Onfo*
-  * for do_load is Port_Info*
-  */
- typedef struct
- {
-     void	*data;
-     Scheme_Env	*env;
- } Cmd_Info;
- 
  /* info for do_apply */
  typedef struct
  {
--- 70,75 ----
***************
*** 122,128 ****
  static Scheme_Object *insert_buffer_line_list(void *, int, Scheme_Object **);
  static Scheme_Object *get_range_start(void *, int, Scheme_Object **);
  static Scheme_Object *get_range_end(void *, int, Scheme_Object **);
- static Scheme_Object *get_buffer_namespace(void *, int, Scheme_Object **);
  static vim_mz_buffer *get_vim_curr_buffer(void);
  
  /*  Window-related commands */
--- 112,117 ----
***************
*** 163,170 ****
  static int do_mzscheme_command(exarg_T *, void *, Scheme_Closed_Prim *what);
  static void startup_mzscheme(void);
  static char *string_to_line(Scheme_Object *obj);
- static int mzscheme_io_init(void);
- static void mzscheme_interface_init(vim_mz_buffer *self);
  static void do_output(char *mesg, long len);
  static void do_printf(char *format, ...);
  static void do_flush(void);
--- 152,157 ----
***************
*** 174,192 ****
  static Scheme_Object *do_eval(void *, int noargc, Scheme_Object **noargv);
  static Scheme_Object *do_load(void *, int noargc, Scheme_Object **noargv);
  static Scheme_Object *do_apply(void *, int noargc, Scheme_Object **noargv);
! static void register_vim_exn(Scheme_Env *env);
  static vim_mz_buffer *get_buffer_arg(const char *fname, int argnum,
  	int argc, Scheme_Object **argv);
  static vim_mz_window *get_window_arg(const char *fname, int argnum,
  	int argc, Scheme_Object **argv);
- static void add_vim_exn(Scheme_Env *env);
  static int line_in_range(linenr_T, buf_T *);
  static void check_line_range(linenr_T, buf_T *);
  static void mz_fix_cursor(int lo, int hi, int extra);
  
! static int eval_in_namespace(void *, Scheme_Closed_Prim *, Scheme_Env *,
! 		Scheme_Object **ret);
! static void make_modules(Scheme_Env *);
  
  #ifdef DYNAMIC_MZSCHEME
  
--- 161,212 ----
  static Scheme_Object *do_eval(void *, int noargc, Scheme_Object **noargv);
  static Scheme_Object *do_load(void *, int noargc, Scheme_Object **noargv);
  static Scheme_Object *do_apply(void *, int noargc, Scheme_Object **noargv);
! static void register_vim_exn(void);
  static vim_mz_buffer *get_buffer_arg(const char *fname, int argnum,
  	int argc, Scheme_Object **argv);
  static vim_mz_window *get_window_arg(const char *fname, int argnum,
  	int argc, Scheme_Object **argv);
  static int line_in_range(linenr_T, buf_T *);
  static void check_line_range(linenr_T, buf_T *);
  static void mz_fix_cursor(int lo, int hi, int extra);
  
! static int eval_with_exn_handling(void *, Scheme_Closed_Prim *,
! 	    Scheme_Object **ret);
! static void make_modules(void);
! static void init_exn_catching_apply(void);
! static int mzscheme_env_main(Scheme_Env *env, int argc, char **argv);
! static int mzscheme_init(void);
! #ifdef FEAT_EVAL
! static Scheme_Object *vim_to_mzscheme(typval_T *vim_value, int depth,
! 	Scheme_Hash_Table *visited);
! #endif
! 
! #ifdef MZ_PRECISE_GC
! static int buffer_size_proc(void *obj)
! {
!     return gcBYTES_TO_WORDS(sizeof(vim_mz_buffer));
! }
! static int buffer_mark_proc(void *obj)
! {
!     return buffer_size_proc(obj);
! }
! static int buffer_fixup_proc(void *obj)
! {
!     return buffer_size_proc(obj);
! }
! static int window_size_proc(void *obj)
! {
!     return gcBYTES_TO_WORDS(sizeof(vim_mz_window));
! }
! static int window_mark_proc(void *obj)
! {
!     return window_size_proc(obj);
! }
! static int window_fixup_proc(void *obj)
! {
!     return window_size_proc(obj);
! }
! #endif
  
  #ifdef DYNAMIC_MZSCHEME
  
***************
*** 260,267 ****
      (Scheme_Closed_Prim *prim, void *data, const char *name, mzshort mina,
       mzshort maxa);
  static Scheme_Object *(*dll_scheme_make_integer_value)(long i);
- static Scheme_Object *(*dll_scheme_make_namespace)(int argc,
- 	Scheme_Object *argv[]);
  static Scheme_Object *(*dll_scheme_make_pair)(Scheme_Object *car,
  	Scheme_Object *cdr);
  static Scheme_Object *(*dll_scheme_make_prim_w_arity)(Scheme_Prim *prim,
--- 280,285 ----
***************
*** 311,316 ****
--- 329,345 ----
  static Scheme_Object *(*dll_scheme_char_string_to_path)
      (Scheme_Object *s);
  # endif
+ static Scheme_Hash_Table *(*dll_scheme_make_hash_table)(int type);
+ static void (*dll_scheme_hash_set)(Scheme_Hash_Table *table,
+ 	Scheme_Object *key, Scheme_Object *value);
+ static Scheme_Object *(*dll_scheme_hash_get)(Scheme_Hash_Table *table,
+ 	Scheme_Object *key);
+ static Scheme_Object *(*dll_scheme_make_double)(double d);
+ # ifdef INCLUDE_MZSCHEME_BASE
+ static Scheme_Object *(*dll_scheme_make_sized_byte_string)(char *chars,
+ 	long len, int copy);
+ static Scheme_Object *(*dll_scheme_namespace_require)(Scheme_Object *req);
+ # endif
  
  /* arrays are imported directly */
  # define scheme_eof dll_scheme_eof
***************
*** 368,374 ****
  # define scheme_lookup_global dll_scheme_lookup_global
  # define scheme_make_closed_prim_w_arity dll_scheme_make_closed_prim_w_arity
  # define scheme_make_integer_value dll_scheme_make_integer_value
- # define scheme_make_namespace dll_scheme_make_namespace
  # define scheme_make_pair dll_scheme_make_pair
  # define scheme_make_prim_w_arity dll_scheme_make_prim_w_arity
  # if MZSCHEME_VERSION_MAJOR < 299
--- 397,402 ----
***************
*** 403,408 ****
--- 431,444 ----
  #  define scheme_char_string_to_path \
      dll_scheme_char_string_to_path
  # endif
+ # define scheme_make_hash_table dll_scheme_make_hash_table
+ # define scheme_hash_set dll_scheme_hash_set
+ # define scheme_hash_get dll_scheme_hash_get
+ # define scheme_make_double dll_scheme_make_double
+ # ifdef INCLUDE_MZSCHEME_BASE
+ #  define scheme_make_sized_byte_string dll_scheme_make_sized_byte_string
+ #  define scheme_namespace_require dll_scheme_namespace_require
+ # endif
  
  typedef struct
  {
***************
*** 468,474 ****
      {"scheme_make_closed_prim_w_arity",
  	(void **)&dll_scheme_make_closed_prim_w_arity},
      {"scheme_make_integer_value", (void **)&dll_scheme_make_integer_value},
-     {"scheme_make_namespace", (void **)&dll_scheme_make_namespace},
      {"scheme_make_pair", (void **)&dll_scheme_make_pair},
      {"scheme_make_prim_w_arity", (void **)&dll_scheme_make_prim_w_arity},
  # if MZSCHEME_VERSION_MAJOR < 299
--- 504,509 ----
***************
*** 502,510 ****
      {"scheme_current_config", (void **)&dll_scheme_current_config},
      {"scheme_char_string_to_byte_string",
  	(void **)&dll_scheme_char_string_to_byte_string},
!     {"scheme_char_string_to_path",
! 	(void **)&dll_scheme_char_string_to_path},
  # endif
      {NULL, NULL}};
  
  static HINSTANCE hMzGC = 0;
--- 537,552 ----
      {"scheme_current_config", (void **)&dll_scheme_current_config},
      {"scheme_char_string_to_byte_string",
  	(void **)&dll_scheme_char_string_to_byte_string},
!     {"scheme_char_string_to_path", (void **)&dll_scheme_char_string_to_path},
  # endif
+     {"scheme_make_hash_table", (void **)&dll_scheme_make_hash_table},
+     {"scheme_hash_set", (void **)&dll_scheme_hash_set},
+     {"scheme_hash_get", (void **)&dll_scheme_hash_get},
+     {"scheme_make_double", (void **)&dll_scheme_make_double},
+ # ifdef INCLUDE_MZSCHEME_BASE
+     {"scheme_make_sized_byte_string", (void **)&dll_scheme_make_sized_byte_string},
+     {"scheme_namespace_require", (void **)&dll_scheme_namespace_require},
+ #endif
      {NULL, NULL}};
  
  static HINSTANCE hMzGC = 0;
***************
*** 592,597 ****
--- 634,644 ----
  }
  #endif /* DYNAMIC_MZSCHEME */
  
+ /* need to put it here for dynamic stuff to work */
+ #ifdef INCLUDE_MZSCHEME_BASE
+ # include "mzscheme_base.c"
+ #endif
+ 
  /*
   *========================================================================
   *  1. MzScheme interpreter startup
***************
*** 601,621 ****
  static Scheme_Type mz_buffer_type;
  static Scheme_Type mz_window_type;
  
! static int initialized = 0;
  
  /* global environment */
  static Scheme_Env    *environment = NULL;
  /* output/error handlers */
  static Scheme_Object *curout = NULL;
  static Scheme_Object *curerr = NULL;
! /* vim:exn exception */
  static Scheme_Object *exn_catching_apply = NULL;
  static Scheme_Object *exn_p = NULL;
  static Scheme_Object *exn_message = NULL;
  static Scheme_Object *vim_exn = NULL; /* Vim Error exception */
!  /* values for exn:vim - constructor, predicate, accessors etc */
! static Scheme_Object *vim_exn_names = NULL;
! static Scheme_Object *vim_exn_values = NULL;
  
  static long range_start;
  static long range_end;
--- 648,669 ----
  static Scheme_Type mz_buffer_type;
  static Scheme_Type mz_window_type;
  
! static int initialized = FALSE;
  
  /* global environment */
  static Scheme_Env    *environment = NULL;
  /* output/error handlers */
  static Scheme_Object *curout = NULL;
  static Scheme_Object *curerr = NULL;
! /* exn:vim exception */
  static Scheme_Object *exn_catching_apply = NULL;
  static Scheme_Object *exn_p = NULL;
  static Scheme_Object *exn_message = NULL;
  static Scheme_Object *vim_exn = NULL; /* Vim Error exception */
! 
! #if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
! static void *stack_base = NULL;
! #endif
  
  static long range_start;
  static long range_end;
***************
*** 668,677 ****
  timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
  # elif defined(FEAT_GUI_GTK)
      static gint
! timer_proc(gpointer data UNUSED)
  # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
      static void
! timer_proc(XtPointer timed_out UNUSED, XtIntervalId *interval_id UNUSED)
  # elif defined(FEAT_GUI_MAC)
      pascal void
  timer_proc(EventLoopTimerRef theTimer, void *userData)
--- 716,725 ----
  timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
  # elif defined(FEAT_GUI_GTK)
      static gint
! timer_proc(gpointer data)
  # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
      static void
! timer_proc(XtPointer timed_out, XtIntervalId *interval_id)
  # elif defined(FEAT_GUI_MAC)
      pascal void
  timer_proc(EventLoopTimerRef theTimer, void *userData)
***************
*** 751,762 ****
  #endif
  }
  
      static void
  startup_mzscheme(void)
  {
!     Scheme_Object *proc_make_security_guard;
! 
!     scheme_set_stack_base(NULL, 1);
  
      MZ_REGISTER_STATIC(environment);
      MZ_REGISTER_STATIC(curout);
--- 799,862 ----
  #endif
  }
  
+     void
+ mzscheme_main(void)
+ {
+ #if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR >= 400
+     /* use trampoline for precise GC in MzScheme >= 4.x */
+     scheme_main_setup(TRUE, mzscheme_env_main, 0, NULL);
+ #else
+     mzscheme_env_main(NULL, 0, NULL);
+ #endif
+ }
+ 
+     static int
+ mzscheme_env_main(Scheme_Env *env, int argc, char **argv)
+ {
+     /* neither argument nor return values are used */
+ #ifdef MZ_PRECISE_GC
+ # if MZSCHEME_VERSION_MAJOR < 400
+     /*
+      * Starting from version 4.x, embedding applications must use
+      * scheme_main_setup/scheme_main_stack_setup trampolines
+      * rather than setting stack base directly with scheme_set_stack_base
+      */
+     Scheme_Object   *dummy = NULL;
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, dummy);
+ 
+     stack_base = &__gc_var_stack__;
+ # else
+     /* environment has been created by us by Scheme */
+     environment = env;
+ # endif
+     /*
+      * In 4.x, all activities must be performed inside trampoline
+      * so we are forced to initialise GC immediately
+      * This can be postponed in 3.x but I see no point in implementing
+      * a feature which will work in older versions only.
+      * One would better use conservative GC if he needs dynamic MzScheme
+      */
+     mzscheme_init();
+ #else
+     int dummy = 0;
+     stack_base = (void *)&dummy;
+ #endif
+     main_loop(FALSE, FALSE);
+ #if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR < 400
+     /* releasing dummy */
+     MZ_GC_REG();
+     MZ_GC_UNREG();
+ #endif
+     return 0;
+ }
+ 
      static void
  startup_mzscheme(void)
  {
! #if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
!     scheme_set_stack_base(stack_base, 1);
! #endif
  
      MZ_REGISTER_STATIC(environment);
      MZ_REGISTER_STATIC(curout);
***************
*** 765,774 ****
      MZ_REGISTER_STATIC(exn_p);
      MZ_REGISTER_STATIC(exn_message);
      MZ_REGISTER_STATIC(vim_exn);
-     MZ_REGISTER_STATIC(vim_exn_names);
-     MZ_REGISTER_STATIC(vim_exn_values);
  
      environment = scheme_basic_env();
  
      /* redirect output */
      scheme_console_output = do_output;
--- 865,899 ----
      MZ_REGISTER_STATIC(exn_p);
      MZ_REGISTER_STATIC(exn_message);
      MZ_REGISTER_STATIC(vim_exn);
  
+ #if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
+     /* in newer versions of precise GC the initial env has been created */
      environment = scheme_basic_env();
+ #endif
+     MZ_GC_CHECK();
+ 
+ #ifdef INCLUDE_MZSCHEME_BASE
+     {
+ 	/*
+ 	 * versions 4.x do not provide Scheme bindings by defaults
+ 	 * we need to add them explicitly
+ 	 */
+ 	Scheme_Object *scheme_base_symbol = NULL;
+ 	MZ_GC_DECL_REG(1);
+ 	MZ_GC_VAR_IN_REG(0, scheme_base_symbol);
+ 	MZ_GC_REG();
+ 	/* invoke function from generated and included base.c */
+ 	declare_modules(environment);
+ 	scheme_base_symbol = scheme_intern_symbol("scheme/base");
+ 	MZ_GC_CHECK();
+ 	scheme_namespace_require(scheme_base_symbol);
+ 	MZ_GC_CHECK();
+ 	MZ_GC_UNREG();
+     }
+ #endif
+     register_vim_exn();
+     /* use new environment to initialise exception handling */
+     init_exn_catching_apply();
  
      /* redirect output */
      scheme_console_output = do_output;
***************
*** 776,823 ****
  
  #ifdef MZSCHEME_COLLECTS
      /* setup 'current-library-collection-paths' parameter */
-     scheme_set_param(scheme_config, MZCONFIG_COLLECTION_PATHS,
- 	    scheme_make_pair(
  # if MZSCHEME_VERSION_MAJOR >= 299
! 		scheme_char_string_to_path(
! 		    scheme_byte_string_to_char_string(
! 			scheme_make_byte_string(MZSCHEME_COLLECTS))),
  # else
! 		scheme_make_string(MZSCHEME_COLLECTS),
  # endif
- 		scheme_null));
  #endif
  #ifdef HAVE_SANDBOX
!     /* setup sandbox guards */
!     proc_make_security_guard = scheme_lookup_global(
! 	    scheme_intern_symbol("make-security-guard"),
! 	    environment);
!     if (proc_make_security_guard != NULL)
!     {
! 	Scheme_Object *args[3];
! 	Scheme_Object *guard;
! 	args[0] = scheme_get_param(scheme_config, MZCONFIG_SECURITY_GUARD);
! 	args[1] = scheme_make_prim_w_arity(sandbox_file_guard,
! 		"sandbox-file-guard", 3, 3);
! 	args[2] = scheme_make_prim_w_arity(sandbox_network_guard,
! 		"sandbox-network-guard", 4, 4);
! 	guard = scheme_apply(proc_make_security_guard, 3, args);
! 	scheme_set_param(scheme_config, MZCONFIG_SECURITY_GUARD, guard);
      }
  #endif
      /* Create buffer and window types for use in Scheme code */
      mz_buffer_type = scheme_make_type("<vim-buffer>");
      mz_window_type = scheme_make_type("<vim-window>");
  
!     register_vim_exn(environment);
!     make_modules(environment);
  
      /*
       * setup callback to receive notifications
       * whether thread scheduling is (or not) required
       */
      scheme_notify_multithread = notify_multithread;
-     initialized = 1;
  }
  
  /*
--- 901,1031 ----
  
  #ifdef MZSCHEME_COLLECTS
      /* setup 'current-library-collection-paths' parameter */
  # if MZSCHEME_VERSION_MAJOR >= 299
!     {
! 	Scheme_Object	*coll_byte_string = NULL;
! 	Scheme_Object	*coll_char_string = NULL;
! 	Scheme_Object	*coll_path = NULL;
! 	Scheme_Object	*coll_pair = NULL;
! 	Scheme_Config	*config = NULL;
! 
! 	MZ_GC_DECL_REG(5);
! 	MZ_GC_VAR_IN_REG(0, coll_byte_string);
! 	MZ_GC_VAR_IN_REG(1, coll_char_string);
! 	MZ_GC_VAR_IN_REG(2, coll_path);
! 	MZ_GC_VAR_IN_REG(3, coll_pair);
! 	MZ_GC_VAR_IN_REG(4, config);
! 	MZ_GC_REG();
! 	coll_byte_string = scheme_make_byte_string(MZSCHEME_COLLECTS);
! 	MZ_GC_CHECK();
! 	coll_char_string = scheme_byte_string_to_char_string(coll_byte_string);
! 	MZ_GC_CHECK();
! 	coll_path = scheme_char_string_to_path(coll_char_string);
! 	MZ_GC_CHECK();
! 	coll_pair = scheme_make_pair(coll_path, scheme_null);
! 	MZ_GC_CHECK();
! 	config = scheme_config;
! 	MZ_GC_CHECK();
! 	scheme_set_param(config, MZCONFIG_COLLECTION_PATHS, coll_pair);
! 	MZ_GC_CHECK();
! 	MZ_GC_UNREG();
!     }
  # else
!     {
! 	Scheme_Object	*coll_string = NULL;
! 	Scheme_Object	*coll_pair = NULL;
! 	Scheme_Config	*config = NULL;
! 
! 	MZ_GC_DECL_REG(3);
! 	MZ_GC_VAR_IN_REG(0, coll_string);
! 	MZ_GC_VAR_IN_REG(1, coll_pair);
! 	MZ_GC_VAR_IN_REG(2, config);
! 	MZ_GC_REG();
! 	coll_string = scheme_make_string(MZSCHEME_COLLECTS);
! 	MZ_GC_CHECK();
! 	coll_pair = scheme_make_pair(coll_string, scheme_null);
! 	MZ_GC_CHECK();
! 	config = scheme_config;
! 	MZ_GC_CHECK();
! 	scheme_set_param(config, MZCONFIG_COLLECTION_PATHS, coll_pair);
! 	MZ_GC_CHECK();
! 	MZ_GC_UNREG();
!     }
  # endif
  #endif
  #ifdef HAVE_SANDBOX
!     {
! 	Scheme_Object	*make_security_guard = NULL;
! 	MZ_GC_DECL_REG(1);
! 	MZ_GC_VAR_IN_REG(0, make_security_guard);
! 	MZ_GC_REG();
! 
! #if MZSCHEME_VERSION_MAJOR < 400
! 	{
! 	    Scheme_Object	*make_security_guard_symbol = NULL;
! 	    MZ_GC_DECL_REG(1);
! 	    MZ_GC_VAR_IN_REG(0, make_security_guard_symbol);
! 	    MZ_GC_REG();
! 	    make_security_guard_symbol = scheme_intern_symbol("make-security-guard");
! 	    MZ_GC_CHECK();
! 	    make_security_guard = scheme_lookup_global(
! 		    make_security_guard_symbol, environment);
! 	    MZ_GC_UNREG();
! 	}
! #else
! 	make_security_guard = scheme_builtin_value("make-security-guard");
! 	MZ_GC_CHECK();
! #endif
! 
! 	/* setup sandbox guards */
! 	if (make_security_guard != NULL)
! 	{
! 	    Scheme_Object   *args[3] = {NULL, NULL, NULL};
! 	    Scheme_Object   *guard = NULL;
! 	    Scheme_Config   *config = NULL;
! 	    MZ_GC_DECL_REG(5);
! 	    MZ_GC_ARRAY_VAR_IN_REG(0, args, 3);
! 	    MZ_GC_VAR_IN_REG(3, guard);
! 	    MZ_GC_VAR_IN_REG(4, config);
! 	    MZ_GC_REG();
! 	    config = scheme_config;
! 	    MZ_GC_CHECK();
! 	    args[0] = scheme_get_param(config, MZCONFIG_SECURITY_GUARD);
! 	    MZ_GC_CHECK();
! 	    args[1] = scheme_make_prim_w_arity(sandbox_file_guard,
! 		    "sandbox-file-guard", 3, 3);
! 	    args[2] = scheme_make_prim_w_arity(sandbox_network_guard,
! 		    "sandbox-network-guard", 4, 4);
! 	    guard = scheme_apply(make_security_guard, 3, args);
! 	    MZ_GC_CHECK();
! 	    scheme_set_param(config, MZCONFIG_SECURITY_GUARD, guard);
! 	    MZ_GC_CHECK();
! 	    MZ_GC_UNREG();
! 	}
! 	MZ_GC_UNREG();
      }
  #endif
      /* Create buffer and window types for use in Scheme code */
      mz_buffer_type = scheme_make_type("<vim-buffer>");
+     MZ_GC_CHECK();
      mz_window_type = scheme_make_type("<vim-window>");
+     MZ_GC_CHECK();
+ #ifdef MZ_PRECISE_GC
+     GC_register_traversers(mz_buffer_type,
+ 	    buffer_size_proc, buffer_mark_proc, buffer_fixup_proc,
+ 	    TRUE, TRUE);
+     GC_register_traversers(mz_window_type,
+ 	    window_size_proc, window_mark_proc, window_fixup_proc,
+ 	    TRUE, TRUE);
+ #endif
  
!     make_modules();
  
      /*
       * setup callback to receive notifications
       * whether thread scheduling is (or not) required
       */
      scheme_notify_multithread = notify_multithread;
  }
  
  /*
***************
*** 827,897 ****
      static int
  mzscheme_init(void)
  {
-     int do_require = FALSE;
- 
      if (!initialized)
      {
- 	do_require = TRUE;
  #ifdef DYNAMIC_MZSCHEME
  	if (!mzscheme_enabled(TRUE))
  	{
! 	    EMSG(_("???: Sorry, this command is disabled, the MzScheme library could not be loaded."));
  	    return -1;
  	}
  #endif
  	startup_mzscheme();
! 
! 	if (mzscheme_io_init())
! 	    return -1;
! 
!     }
!     /* recreate ports each call effectivelly clearing these ones */
!     curout = scheme_make_string_output_port();
!     curerr = scheme_make_string_output_port();
!     scheme_set_param(scheme_config, MZCONFIG_OUTPUT_PORT, curout);
!     scheme_set_param(scheme_config, MZCONFIG_ERROR_PORT, curerr);
! 
!     if (do_require)
!     {
! 	/* auto-instantiate in basic env */
! 	eval_in_namespace("(require (prefix vimext: vimext))", do_eval,
! 		environment, NULL);
      }
- 
-     return 0;
- }
- 
- /*
-  * This routine fills the namespace with various important routines that can
-  * be used within MzScheme.
-  */
-     static void
- mzscheme_interface_init(vim_mz_buffer *mzbuff)
- {
-     Scheme_Object   *attach;
- 
-     mzbuff->env = (Scheme_Env *)scheme_make_namespace(0, NULL);
- 
-     /*
-      * attach instantiated modules from global namespace
-      * so they can be easily instantiated in the buffer namespace
-      */
-     attach = scheme_lookup_global(
- 	    scheme_intern_symbol("namespace-attach-module"),
- 	    environment);
- 
-     if (attach != NULL)
      {
! 	Scheme_Object   *ret;
! 	Scheme_Object	*args[2];
! 
! 	args[0] = (Scheme_Object *)environment;
! 	args[1] = scheme_intern_symbol("vimext");
! 
! 	ret = (Scheme_Object *)mzvim_apply(attach, 2, args);
      }
  
!     add_vim_exn(mzbuff->env);
  }
  
  /*
--- 1035,1072 ----
      static int
  mzscheme_init(void)
  {
      if (!initialized)
      {
  #ifdef DYNAMIC_MZSCHEME
  	if (!mzscheme_enabled(TRUE))
  	{
! 	    EMSG(_("E812: Sorry, this command is disabled, the MzScheme libraries could not be loaded."));
  	    return -1;
  	}
  #endif
  	startup_mzscheme();
! 	initialized = TRUE;
      }
      {
! 	Scheme_Config	*config = NULL;
! 	MZ_GC_DECL_REG(1);
! 	MZ_GC_VAR_IN_REG(0, config);
! 	MZ_GC_REG();
! 	config = scheme_config;
! 	MZ_GC_CHECK();
! 	/* recreate ports each call effectivelly clearing these ones */
! 	curout = scheme_make_string_output_port();
! 	MZ_GC_CHECK();
! 	curerr = scheme_make_string_output_port();
! 	MZ_GC_CHECK();
! 	scheme_set_param(config, MZCONFIG_OUTPUT_PORT, curout);
! 	MZ_GC_CHECK();
! 	scheme_set_param(config, MZCONFIG_ERROR_PORT, curerr);
! 	MZ_GC_CHECK();
! 	MZ_GC_UNREG();
      }
  
!     return 0;
  }
  
  /*
***************
*** 901,928 ****
   */
  
  /*
!  * Evaluate command in namespace with exception handling
   */
      static int
! eval_in_namespace(void *data, Scheme_Closed_Prim *what, Scheme_Env *env,
! 		Scheme_Object **ret)
  {
!     Scheme_Object   *value;
!     Scheme_Object   *exn;
!     Cmd_Info	    info;   /* closure info */
! 
!     info.data = data;
!     info.env = env;
! 
!     scheme_set_param(scheme_config, MZCONFIG_ENV,
! 	    (Scheme_Object *) env);
!     /*
!      * ensure all evaluations will be in current buffer namespace,
!      * the second argument to scheme_eval_string isn't enough!
!      */
!     value = _apply_thunk_catch_exceptions(
! 	    scheme_make_closed_prim_w_arity(what, &info, "mzvim", 0, 0),
! 	    &exn);
  
      if (!value)
      {
--- 1076,1100 ----
   */
  
  /*
!  * Evaluate command with exception handling
   */
      static int
! eval_with_exn_handling(void *data, Scheme_Closed_Prim *what, Scheme_Object **ret)
  {
!     Scheme_Object   *value = NULL;
!     Scheme_Object   *exn = NULL;
!     Scheme_Object   *prim = NULL;
! 
!     MZ_GC_DECL_REG(3);
!     MZ_GC_VAR_IN_REG(0, value);
!     MZ_GC_VAR_IN_REG(1, exn);
!     MZ_GC_VAR_IN_REG(2, prim);
!     MZ_GC_REG();
! 
!     prim = scheme_make_closed_prim_w_arity(what, data, "mzvim", 0, 0);
!     MZ_GC_CHECK();
!     value = _apply_thunk_catch_exceptions(prim, &exn);
!     MZ_GC_CHECK();
  
      if (!value)
      {
***************
*** 930,938 ****
  	/* Got an exn? */
  	if (value)
  	{
! 	    scheme_display(value, curerr);  /*  Send to stderr-vim */
  	    do_flush();
  	}
  	/* `raise' was called on some arbitrary value */
  	return FAIL;
      }
--- 1102,1112 ----
  	/* Got an exn? */
  	if (value)
  	{
! 	    scheme_display(value, curerr);   /*  Send to stderr-vim */
! 	    MZ_GC_CHECK();
  	    do_flush();
  	}
+ 	MZ_GC_UNREG();
  	/* `raise' was called on some arbitrary value */
  	return FAIL;
      }
***************
*** 941,949 ****
--- 1115,1127 ----
  	*ret = value;
      /* Print any result, as long as it's not a void */
      else if (!SCHEME_VOIDP(value))
+     {
  	scheme_display(value, curout);  /* Send to stdout-vim */
+ 	MZ_GC_CHECK();
+     }
  
      do_flush();
+     MZ_GC_UNREG();
      return OK;
  }
  
***************
*** 957,963 ****
      range_start = eap->line1;
      range_end = eap->line2;
  
!     return eval_in_namespace(data, what, get_vim_curr_buffer()->env, NULL);
  }
  
  /*
--- 1135,1141 ----
      range_start = eap->line1;
      range_end = eap->line2;
  
!     return eval_with_exn_handling(data, what, NULL);
  }
  
  /*
***************
*** 974,979 ****
--- 1152,1158 ----
  	bp->buf = INVALID_BUFFER_VALUE;
  	buf->b_mzscheme_ref = NULL;
  	scheme_gc_ptr_ok(bp);
+ 	MZ_GC_CHECK();
      }
  }
  
***************
*** 990,995 ****
--- 1169,1175 ----
  	wp->win = INVALID_WINDOW_VALUE;
  	win->w_mzscheme_ref = NULL;
  	scheme_gc_ptr_ok(wp);
+ 	MZ_GC_CHECK();
      }
  }
  
***************
*** 1014,1031 ****
      }
  }
  
- /* eval MzScheme string */
-     void *
- mzvim_eval_string(char_u *str)
- {
-     Scheme_Object *ret = NULL;
-     if (mzscheme_init())
- 	return FAIL;
- 
-     eval_in_namespace(str, do_eval, get_vim_curr_buffer()->env, &ret);
-     return ret;
- }
- 
  /*
   * apply MzScheme procedure with arguments,
   * handling errors
--- 1194,1199 ----
***************
*** 1033,1075 ****
      Scheme_Object *
  mzvim_apply(Scheme_Object *proc, int argc, Scheme_Object **argv)
  {
-     Apply_Info	data;
-     Scheme_Object *ret = NULL;
- 
      if (mzscheme_init())
  	return FAIL;
  
!     data.proc = proc;
!     data.argc = argc;
!     data.argv = argv;
! 
!     eval_in_namespace(&data, do_apply, get_vim_curr_buffer()->env, &ret);
!     return ret;
  }
  
      static Scheme_Object *
  do_load(void *data, int noargc, Scheme_Object **noargv)
  {
!     Cmd_Info	    *info = (Cmd_Info *)data;
!     Scheme_Object   *result = scheme_void;
!     Scheme_Object   *expr;
!     char_u	    *file = scheme_malloc_fail_ok(
! 					  scheme_malloc_atomic, MAXPATHL + 1);
!     Port_Info	    *pinfo = (Port_Info *)(info->data);
  
      /* make Vim expansion */
!     expand_env((char_u *)pinfo->name, file, MAXPATHL);
!     /* scheme_load looks strange working with namespaces and error handling*/
      pinfo->port = scheme_open_input_file(file, "mzfile");
!     scheme_count_lines(pinfo->port); /* to get accurate read error location*/
  
      /* Like REPL but print only last result */
      while (!SCHEME_EOFP(expr = scheme_read(pinfo->port)))
! 	result = scheme_eval(expr, info->env);
  
      /* errors will be caught in do_mzscheme_comamnd and ex_mzfile */
      scheme_close_input_port(pinfo->port);
      pinfo->port = NULL;
      return result;
  }
  
--- 1201,1265 ----
      Scheme_Object *
  mzvim_apply(Scheme_Object *proc, int argc, Scheme_Object **argv)
  {
      if (mzscheme_init())
  	return FAIL;
+     else
+     {
+ 	Apply_Info	data = {NULL, 0, NULL};
+ 	Scheme_Object	*ret = NULL;
  
! 	MZ_GC_DECL_REG(5);
! 	MZ_GC_VAR_IN_REG(0, ret);
! 	MZ_GC_VAR_IN_REG(1, data.proc);
! 	MZ_GC_ARRAY_VAR_IN_REG(2, data.argv, argc);
! 	MZ_GC_REG();
! 
! 	data.proc = proc;
! 	data.argc = argc;
! 	data.argv = argv;
! 
! 	eval_with_exn_handling(&data, do_apply, &ret);
! 	MZ_GC_UNREG();
! 	return ret;
!     }
  }
  
      static Scheme_Object *
  do_load(void *data, int noargc, Scheme_Object **noargv)
  {
!     Scheme_Object   *expr = NULL;
!     Scheme_Object   *result = NULL;
!     char	    *file = NULL;
!     Port_Info	    *pinfo = (Port_Info *)data;
! 
!     MZ_GC_DECL_REG(3);
!     MZ_GC_VAR_IN_REG(0, expr);
!     MZ_GC_VAR_IN_REG(1, result);
!     MZ_GC_VAR_IN_REG(2, file);
!     MZ_GC_REG();
! 
!     file = (char *)scheme_malloc_fail_ok(scheme_malloc_atomic, MAXPATHL + 1);
!     MZ_GC_CHECK();
  
      /* make Vim expansion */
!     expand_env((char_u *)pinfo->name, (char_u *)file, MAXPATHL);
      pinfo->port = scheme_open_input_file(file, "mzfile");
!     MZ_GC_CHECK();
!     scheme_count_lines(pinfo->port);  /* to get accurate read error location*/
!     MZ_GC_CHECK();
  
      /* Like REPL but print only last result */
      while (!SCHEME_EOFP(expr = scheme_read(pinfo->port)))
!     {
! 	result = scheme_eval(expr, environment);
! 	MZ_GC_CHECK();
!     }
  
      /* errors will be caught in do_mzscheme_comamnd and ex_mzfile */
      scheme_close_input_port(pinfo->port);
+     MZ_GC_CHECK();
      pinfo->port = NULL;
+     MZ_GC_UNREG();
      return result;
  }
  
***************
*** 1077,1089 ****
      void
  ex_mzfile(exarg_T *eap)
  {
!     Port_Info	pinfo;
  
      pinfo.name = (char *)eap->arg;
-     pinfo.port = NULL;
      if (do_mzscheme_command(eap, &pinfo, do_load) != OK
  	    && pinfo.port != NULL)	/* looks like port was not closed */
  	scheme_close_input_port(pinfo.port);
  }
  
  
--- 1267,1286 ----
      void
  ex_mzfile(exarg_T *eap)
  {
!     Port_Info	pinfo = {NULL, NULL};
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, pinfo.port);
!     MZ_GC_REG();
  
      pinfo.name = (char *)eap->arg;
      if (do_mzscheme_command(eap, &pinfo, do_load) != OK
  	    && pinfo.port != NULL)	/* looks like port was not closed */
+     {
  	scheme_close_input_port(pinfo.port);
+ 	MZ_GC_CHECK();
+     }
+     MZ_GC_UNREG();
  }
  
  
***************
*** 1103,1116 ****
  		"(with-handlers ([void (lambda (exn) (cons #f exn))]) "
  		"(cons #t (thunk))))";
  
! 	/* make sure we have a namespace with the standard syntax: */
! 	Scheme_Env *env = (Scheme_Env *)scheme_make_namespace(0, NULL);
! 	add_vim_exn(env);
! 
! 	exn_catching_apply = scheme_eval_string(e, env);
! 	exn_p = scheme_lookup_global(scheme_intern_symbol("exn?"), env);
! 	exn_message = scheme_lookup_global(
! 		scheme_intern_symbol("exn-message"), env);
      }
  }
  
--- 1300,1311 ----
  		"(with-handlers ([void (lambda (exn) (cons #f exn))]) "
  		"(cons #t (thunk))))";
  
! 	exn_catching_apply = scheme_eval_string(e, environment);
! 	MZ_GC_CHECK();
! 	exn_p = scheme_builtin_value("exn?");
! 	MZ_GC_CHECK();
! 	exn_message = scheme_builtin_value("exn-message");
! 	MZ_GC_CHECK();
      }
  }
  
***************
*** 1124,1131 ****
  {
      Scheme_Object *v;
  
-     init_exn_catching_apply();
- 
      v = _scheme_apply(exn_catching_apply, 1, &f);
      /* v is a pair: (cons #t value) or (cons #f exn) */
  
--- 1319,1324 ----
***************
*** 1141,1148 ****
      static Scheme_Object *
  extract_exn_message(Scheme_Object *v)
  {
-     init_exn_catching_apply();
- 
      if (SCHEME_TRUEP(_scheme_apply(exn_p, 1, &v)))
  	return _scheme_apply(exn_message, 1, &v);
      else
--- 1334,1339 ----
***************
*** 1152,1167 ****
      static Scheme_Object *
  do_eval(void *s, int noargc, Scheme_Object **noargv)
  {
!     Cmd_Info	*info = (Cmd_Info *)s;
! 
!     return scheme_eval_string_all((char *)(info->data), info->env, TRUE);
  }
  
      static Scheme_Object *
  do_apply(void *a, int noargc, Scheme_Object **noargv)
  {
!     Apply_Info	*info = (Apply_Info *)(((Cmd_Info *)a)->data);
! 
      return scheme_apply(info->proc, info->argc, info->argv);
  }
  
--- 1343,1355 ----
      static Scheme_Object *
  do_eval(void *s, int noargc, Scheme_Object **noargv)
  {
!     return scheme_eval_string_all((char *)s, environment, TRUE);
  }
  
      static Scheme_Object *
  do_apply(void *a, int noargc, Scheme_Object **noargv)
  {
!     Apply_Info	*info = (Apply_Info *)a;
      return scheme_apply(info->proc, info->argc, info->argv);
  }
  
***************
*** 1219,1224 ****
--- 1407,1413 ----
      long length;
  
      buff = scheme_get_sized_string_output(curerr, &length);
+     MZ_GC_CHECK();
      if (length)
      {
  	do_err_output(buff, length);
***************
*** 1226,1242 ****
      }
  
      buff = scheme_get_sized_string_output(curout, &length);
      if (length)
  	do_output(buff, length);
  }
  
-     static int
- mzscheme_io_init(void)
- {
-     /* Nothing needed so far... */
-     return 0;
- }
- 
  /*
   *========================================================================
   *  4. Implementation of the Vim Features for MzScheme
--- 1415,1425 ----
      }
  
      buff = scheme_get_sized_string_output(curout, &length);
+     MZ_GC_CHECK();
      if (length)
  	do_output(buff, length);
  }
  
  /*
   *========================================================================
   *  4. Implementation of the Vim Features for MzScheme
***************
*** 1263,1284 ****
  vim_eval(void *data, int argc, Scheme_Object **argv)
  {
  #ifdef FEAT_EVAL
!     Vim_Prim	    *prim = (Vim_Prim *)data;
!     char	    *expr;
!     char	    *str;
!     Scheme_Object   *result;
  
!     expr = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
  
!     str = (char *)eval_to_string((char_u *)expr, NULL, TRUE);
  
!     if (str == NULL)
  	raise_vim_exn(_("invalid expression"));
  
!     result = scheme_make_string(str);
! 
!     vim_free(str);
  
      return result;
  #else
      raise_vim_exn(_("expressions disabled at compile time"));
--- 1446,1475 ----
  vim_eval(void *data, int argc, Scheme_Object **argv)
  {
  #ifdef FEAT_EVAL
!     Vim_Prim		*prim = (Vim_Prim *)data;
!     char		*expr;
!     Scheme_Object	*result;
!     /* hash table to store visited values to avoid infinite loops */
!     Scheme_Hash_Table	*visited = NULL;
!     typval_T		*vim_result;
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, visited);
!     MZ_GC_REG();
  
!     visited = scheme_make_hash_table(SCHEME_hash_ptr);
!     MZ_GC_CHECK();
  
!     expr = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
!     vim_result = eval_expr((char_u *)expr, NULL);
  
!     if (vim_result == NULL)
  	raise_vim_exn(_("invalid expression"));
  
!     result = vim_to_mzscheme(vim_result, 1, visited);
!     free_tv(vim_result);
  
+     MZ_GC_UNREG();
      return result;
  #else
      raise_vim_exn(_("expressions disabled at compile time"));
***************
*** 1318,1324 ****
      Vim_Prim	    *prim = (Vim_Prim *)data;
      char_u	    *name;
      long	    value;
!     char_u	    *strval;
      int		    rc;
      Scheme_Object   *rval;
      int		    opt_flags = 0;
--- 1509,1515 ----
      Vim_Prim	    *prim = (Vim_Prim *)data;
      char_u	    *name;
      long	    value;
!     char	    *strval;
      int		    rc;
      Scheme_Object   *rval;
      int		    opt_flags = 0;
***************
*** 1333,1338 ****
--- 1524,1530 ----
  	{
  	    MZ_REGISTER_STATIC(M_global);
  	    M_global = scheme_intern_symbol("global");
+ 	    MZ_GC_CHECK();
  	}
  
  	if (argv[1] == M_global)
***************
*** 1354,1360 ****
  	    scheme_wrong_type(prim->name, "vim-buffer/window", 1, argc, argv);
      }
  
!     rc = get_option_value(name, &value, &strval, opt_flags);
      curbuf = save_curb;
      curwin = save_curw;
  
--- 1546,1552 ----
  	    scheme_wrong_type(prim->name, "vim-buffer/window", 1, argc, argv);
      }
  
!     rc = get_option_value(name, &value, (char_u **)&strval, opt_flags);
      curbuf = save_curb;
      curwin = save_curw;
  
***************
*** 1364,1369 ****
--- 1556,1562 ----
  	return scheme_make_integer_value(value);
      case 0:
  	rval = scheme_make_string(strval);
+ 	MZ_GC_CHECK();
  	vim_free(strval);
  	return rval;
      case -1:
***************
*** 1393,1398 ****
--- 1586,1592 ----
  	{
  	    MZ_REGISTER_STATIC(M_global);
  	    M_global = scheme_intern_symbol("global");
+ 	    MZ_GC_CHECK();
  	}
  
  	if (argv[1] == M_global)
***************
*** 1463,1469 ****
--- 1657,1666 ----
  
      for (w = firstwin; w != NULL; w = w->w_next)
  	if (w->w_buffer == buf->buf)
+ 	{
  	    list = scheme_make_pair(window_new(w), list);
+ 	    MZ_GC_CHECK();
+ 	}
  
      return list;
  }
***************
*** 1471,1477 ****
      static Scheme_Object *
  window_new(win_T *win)
  {
!     vim_mz_window *self;
  
      /* We need to handle deletion of windows underneath us.
       * If we add a "w_mzscheme_ref" field to the win_T structure,
--- 1668,1678 ----
      static Scheme_Object *
  window_new(win_T *win)
  {
!     vim_mz_window *self = NULL;
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, self);
!     MZ_GC_REG();
  
      /* We need to handle deletion of windows underneath us.
       * If we add a "w_mzscheme_ref" field to the win_T structure,
***************
*** 1485,1497 ****
  	return win->w_mzscheme_ref;
  
      self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_window));
- 
      vim_memset(self, 0, sizeof(vim_mz_window));
      scheme_dont_gc_ptr(self);	/* because win isn't visible to GC */
      win->w_mzscheme_ref = self;
      self->win = win;
!     self->tag = mz_window_type;
  
      return (Scheme_Object *)(self);
  }
  
--- 1686,1699 ----
  	return win->w_mzscheme_ref;
  
      self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_window));
      vim_memset(self, 0, sizeof(vim_mz_window));
      scheme_dont_gc_ptr(self);	/* because win isn't visible to GC */
+     MZ_GC_CHECK();
      win->w_mzscheme_ref = self;
      self->win = win;
!     self->so.type = mz_window_type;
  
+     MZ_GC_UNREG();
      return (Scheme_Object *)(self);
  }
  
***************
*** 1660,1666 ****
  /*
   *===========================================================================
   *  6. Vim Buffer-related Manipulation Functions
-  *     Note that each buffer should have its own private namespace.
   *===========================================================================
   */
  
--- 1862,1867 ----
***************
*** 1669,1682 ****
  mzscheme_open_buffer(void *data, int argc, Scheme_Object **argv)
  {
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     char	    *fname;
      int		    num = 0;
      Scheme_Object   *onum;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
!     fname = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
      /* TODO make open existing file */
      num = buflist_add(fname, BLN_LISTED | BLN_CURBUF);
  
--- 1870,1883 ----
  mzscheme_open_buffer(void *data, int argc, Scheme_Object **argv)
  {
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     char_u	    *fname;
      int		    num = 0;
      Scheme_Object   *onum;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
!     fname = (char_u *)SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
      /* TODO make open existing file */
      num = buflist_add(fname, BLN_LISTED | BLN_CURBUF);
  
***************
*** 1712,1718 ****
      buf_T	*buf;
      char_u	*fname;
  
!     fname = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
  
      for (buf = firstbuf; buf; buf = buf->b_next)
  	if (buf->b_ffname == NULL || buf->b_sfname == NULL)
--- 1913,1919 ----
      buf_T	*buf;
      char_u	*fname;
  
!     fname = (char_u *)SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
  
      for (buf = firstbuf; buf; buf = buf->b_next)
  	if (buf->b_ffname == NULL || buf->b_sfname == NULL)
***************
*** 1783,1789 ****
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf = get_buffer_arg(prim->name, 0, argc, argv);
  
!     return scheme_make_string(buf->buf->b_ffname);
  }
  
  /* (curr-buff) */
--- 1984,1990 ----
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf = get_buffer_arg(prim->name, 0, argc, argv);
  
!     return scheme_make_string((char *)buf->buf->b_ffname);
  }
  
  /* (curr-buff) */
***************
*** 1796,1802 ****
      static Scheme_Object *
  buffer_new(buf_T *buf)
  {
!     vim_mz_buffer *self;
  
      /* We need to handle deletion of buffers underneath us.
       * If we add a "b_mzscheme_ref" field to the buf_T structure,
--- 1997,2007 ----
      static Scheme_Object *
  buffer_new(buf_T *buf)
  {
!     vim_mz_buffer *self = NULL;
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, self);
!     MZ_GC_REG();
  
      /* We need to handle deletion of buffers underneath us.
       * If we add a "b_mzscheme_ref" field to the buf_T structure,
***************
*** 1806,1820 ****
  	return buf->b_mzscheme_ref;
  
      self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_buffer));
- 
      vim_memset(self, 0, sizeof(vim_mz_buffer));
!     scheme_dont_gc_ptr(self);	/* because buf isn't visible to GC */
      buf->b_mzscheme_ref = self;
      self->buf = buf;
!     self->tag = mz_buffer_type;
! 
!     mzscheme_interface_init(self);	/* Set up namespace */
  
      return (Scheme_Object *)(self);
  }
  
--- 2011,2024 ----
  	return buf->b_mzscheme_ref;
  
      self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_buffer));
      vim_memset(self, 0, sizeof(vim_mz_buffer));
!     scheme_dont_gc_ptr(self); /* because buf isn't visible to GC */
!     MZ_GC_CHECK();
      buf->b_mzscheme_ref = self;
      self->buf = buf;
!     self->so.type = mz_buffer_type;
  
+     MZ_GC_UNREG();
      return (Scheme_Object *)(self);
  }
  
***************
*** 1845,1858 ****
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
      int		    linenr;
!     char	    *line;
  
      buf = get_buffer_arg(prim->name, 1, argc, argv);
      linenr = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
      line = ml_get_buf(buf->buf, (linenr_T)linenr, FALSE);
  
      raise_if_error();
!     return scheme_make_string(line);
  }
  
  
--- 2049,2062 ----
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
      int		    linenr;
!     char_u	    *line;
  
      buf = get_buffer_arg(prim->name, 1, argc, argv);
      linenr = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
      line = ml_get_buf(buf->buf, (linenr_T)linenr, FALSE);
  
      raise_if_error();
!     return scheme_make_string((char *)line);
  }
  
  
***************
*** 1869,1875 ****
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
      int		    i, hi, lo, n;
!     Scheme_Object   *list;
  
      buf = get_buffer_arg(prim->name, 2, argc, argv);
      list = scheme_null;
--- 2073,2083 ----
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
      int		    i, hi, lo, n;
!     Scheme_Object   *list = NULL;
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, list);
!     MZ_GC_REG();
  
      buf = get_buffer_arg(prim->name, 2, argc, argv);
      list = scheme_null;
***************
*** 1897,1904 ****
  
  	/* Set the list item */
  	list = scheme_make_pair(str, list);
      }
! 
      return list;
  }
  
--- 2105,2113 ----
  
  	/* Set the list item */
  	list = scheme_make_pair(str, list);
+ 	MZ_GC_CHECK();
      }
!     MZ_GC_UNREG();
      return list;
  }
  
***************
*** 1925,1935 ****
       */
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
!     Scheme_Object   *line;
      char	    *save;
-     buf_T	    *savebuf;
      int		    n;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
--- 2134,2147 ----
       */
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
!     Scheme_Object   *line = NULL;
      char	    *save;
      int		    n;
  
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, line);
+     MZ_GC_REG();
+ 
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
***************
*** 1943,1949 ****
  
      if (SCHEME_FALSEP(line))
      {
! 	savebuf = curbuf;
  	curbuf = buf->buf;
  
  	if (u_savedel((linenr_T)n, 1L) == FAIL)
--- 2155,2162 ----
  
      if (SCHEME_FALSEP(line))
      {
! 	buf_T	    *savebuf = curbuf;
! 
  	curbuf = buf->buf;
  
  	if (u_savedel((linenr_T)n, 1L) == FAIL)
***************
*** 1962,1994 ****
  
  	curbuf = savebuf;
  
  	raise_if_error();
  	return scheme_void;
      }
  
!     /* Otherwise it's a line */
!     save = string_to_line(line);
!     savebuf = curbuf;
  
!     curbuf = buf->buf;
  
-     if (u_savesub((linenr_T)n) == FAIL)
-     {
- 	curbuf = savebuf;
- 	raise_vim_exn(_("cannot save undo information"));
-     }
-     else if (ml_replace((linenr_T)n, (char_u *)save, TRUE) == FAIL)
-     {
  	curbuf = savebuf;
- 	raise_vim_exn(_("cannot replace line"));
-     }
-     else
- 	changed_bytes((linenr_T)n, 0);
  
!     curbuf = savebuf;
  
!     raise_if_error();
!     return scheme_void;
  }
  
  /*
--- 2175,2230 ----
  
  	curbuf = savebuf;
  
+ 	MZ_GC_UNREG();
  	raise_if_error();
  	return scheme_void;
      }
+     else
+     {
+ 	/* Otherwise it's a line */
+ 	buf_T	    *savebuf = curbuf;
  
! 	save = string_to_line(line);
  
! 	curbuf = buf->buf;
! 
! 	if (u_savesub((linenr_T)n) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    vim_free(save);
! 	    raise_vim_exn(_("cannot save undo information"));
! 	}
! 	else if (ml_replace((linenr_T)n, (char_u *)save, TRUE) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    vim_free(save);
! 	    raise_vim_exn(_("cannot replace line"));
! 	}
! 	else
! 	{
! 	    vim_free(save);
! 	    changed_bytes((linenr_T)n, 0);
! 	}
  
  	curbuf = savebuf;
  
! 	/* Check that the cursor is not beyond the end of the line now. */
! 	if (buf->buf == curwin->w_buffer)
! 	    check_cursor_col();
  
! 	MZ_GC_UNREG();
! 	raise_if_error();
! 	return scheme_void;
!     }
! }
! 
!     static void
! free_array(char **array)
! {
!     char **curr = array;
!     while (*curr != NULL)
! 	vim_free(*curr++);
!     vim_free(array);
  }
  
  /*
***************
*** 2013,2027 ****
       *	  3. Anything else - this is an error.
       */
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     vim_mz_buffer   *buf;
!     Scheme_Object   *line_list;
!     Scheme_Object   *line;
!     Scheme_Object   *rest;
!     char	    **array;
!     buf_T	    *savebuf;
      int		    i, old_len, new_len, hi, lo;
      long	    extra;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
--- 2249,2263 ----
       *	  3. Anything else - this is an error.
       */
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     vim_mz_buffer   *buf = NULL;
!     Scheme_Object   *line_list = NULL;
      int		    i, old_len, new_len, hi, lo;
      long	    extra;
  
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, line_list);
+     MZ_GC_REG();
+ 
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
***************
*** 2047,2053 ****
  
      if (SCHEME_FALSEP(line_list) || SCHEME_NULLP(line_list))
      {
! 	savebuf = curbuf;
  	curbuf = buf->buf;
  
  	if (u_savedel((linenr_T)lo, (long)old_len) == FAIL)
--- 2283,2289 ----
  
      if (SCHEME_FALSEP(line_list) || SCHEME_NULLP(line_list))
      {
! 	buf_T	*savebuf = curbuf;
  	curbuf = buf->buf;
  
  	if (u_savedel((linenr_T)lo, (long)old_len) == FAIL)
***************
*** 2070,2167 ****
  
  	curbuf = savebuf;
  
  	raise_if_error();
  	return scheme_void;
      }
  
!     /* List */
!     new_len = scheme_proper_list_length(line_list);
!     if (new_len < 0)	/* improper or cyclic list */
! 	scheme_wrong_type(prim->name, "proper list",
! 		2, argc, argv);
  
!     /* Using MzScheme allocator, so we don't need to free this and
!      * can safely keep pointers to GC collected strings
!      */
!     array = (char **)scheme_malloc_fail_ok(scheme_malloc,
! 		(unsigned)(new_len * sizeof(char *)));
  
!     rest = line_list;
!     for (i = 0; i < new_len; ++i)
!     {
! 	line = SCHEME_CAR(rest);
! 	rest = SCHEME_CDR(rest);
! 	if (!SCHEME_STRINGP(line))
! 	    scheme_wrong_type(prim->name, "string-list", 2, argc, argv);
! 	array[i] = string_to_line(line);
!     }
  
!     savebuf = curbuf;
!     curbuf = buf->buf;
  
!     if (u_save((linenr_T)(lo-1), (linenr_T)hi) == FAIL)
!     {
! 	curbuf = savebuf;
! 	raise_vim_exn(_("cannot save undo information"));
!     }
  
!     /*
!      * If the size of the range is reducing (ie, new_len < old_len) we
!      * need to delete some old_len. We do this at the start, by
!      * repeatedly deleting line "lo".
!      */
!     for (i = 0; i < old_len - new_len; ++i)
!     {
! 	if (ml_delete((linenr_T)lo, FALSE) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    raise_vim_exn(_("cannot delete line"));
! 	}
! 	extra--;
!     }
  
!     /*
!      * For as long as possible, replace the existing old_len with the
!      * new old_len. This is a more efficient operation, as it requires
!      * less memory allocation and freeing.
!      */
!     for (i = 0; i < old_len && i < new_len; i++)
! 	if (ml_replace((linenr_T)(lo+i), (char_u *)array[i], TRUE) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    raise_vim_exn(_("cannot replace line"));
! 	}
  
!     /*
!      * Now we may need to insert the remaining new_len.  We don't need to
!      * free the string passed back because MzScheme has control of that
!      * memory.
!      */
!     while (i < new_len)
!     {
! 	if (ml_append((linenr_T)(lo + i - 1),
! 		(char_u *)array[i], 0, FALSE) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    raise_vim_exn(_("cannot insert line"));
  	}
- 	++i;
- 	++extra;
-     }
  
!     /*
!      * Adjust marks. Invalidate any which lie in the
!      * changed range, and move any in the remainder of the buffer.
!      */
!     mark_adjust((linenr_T)lo, (linenr_T)(hi - 1), (long)MAXLNUM, (long)extra);
!     changed_lines((linenr_T)lo, 0, (linenr_T)hi, (long)extra);
  
!     if (buf->buf == curwin->w_buffer)
! 	mz_fix_cursor(lo, hi, extra);
!     curbuf = savebuf;
  
!     raise_if_error();
!     return scheme_void;
  }
  
  /*
--- 2306,2426 ----
  
  	curbuf = savebuf;
  
+ 	MZ_GC_UNREG();
  	raise_if_error();
  	return scheme_void;
      }
+     else
+     {
+ 	buf_T	*savebuf = curbuf;
  
! 	/* List */
! 	new_len = scheme_proper_list_length(line_list);
! 	MZ_GC_CHECK();
! 	if (new_len < 0)	/* improper or cyclic list */
! 	    scheme_wrong_type(prim->name, "proper list",
! 		    2, argc, argv);
! 	else
! 	{
! 	    char		**array = NULL;
! 	    Scheme_Object   *line = NULL;
! 	    Scheme_Object   *rest = NULL;
! 
! 	    MZ_GC_DECL_REG(2);
! 	    MZ_GC_VAR_IN_REG(0, line);
! 	    MZ_GC_VAR_IN_REG(1, rest);
! 	    MZ_GC_REG();
  
! 	    array = (char **)alloc(new_len * sizeof(char *));
! 	    vim_memset(array, 0, new_len * sizeof(char *));
  
! 	    rest = line_list;
! 	    for (i = 0; i < new_len; ++i)
! 	    {
! 		line = SCHEME_CAR(rest);
! 		rest = SCHEME_CDR(rest);
! 		if (!SCHEME_STRINGP(line))
! 		{
! 		    free_array(array);
! 		    scheme_wrong_type(prim->name, "string-list", 2, argc, argv);
! 		}
! 		array[i] = string_to_line(line);
! 	    }
  
! 	    curbuf = buf->buf;
  
! 	    if (u_save((linenr_T)(lo-1), (linenr_T)hi) == FAIL)
! 	    {
! 		curbuf = savebuf;
! 		free_array(array);
! 		raise_vim_exn(_("cannot save undo information"));
! 	    }
  
! 	    /*
! 	     * If the size of the range is reducing (ie, new_len < old_len) we
! 	     * need to delete some old_len. We do this at the start, by
! 	     * repeatedly deleting line "lo".
! 	     */
! 	    for (i = 0; i < old_len - new_len; ++i)
! 	    {
! 		if (ml_delete((linenr_T)lo, FALSE) == FAIL)
! 		{
! 		    curbuf = savebuf;
! 		    free_array(array);
! 		    raise_vim_exn(_("cannot delete line"));
! 		}
! 		extra--;
! 	    }
  
! 	    /*
! 	     * For as long as possible, replace the existing old_len with the
! 	     * new old_len. This is a more efficient operation, as it requires
! 	     * less memory allocation and freeing.
! 	     */
! 	    for (i = 0; i < old_len && i < new_len; i++)
! 		if (ml_replace((linenr_T)(lo+i), (char_u *)array[i], TRUE) == FAIL)
! 		{
! 		    curbuf = savebuf;
! 		    free_array(array);
! 		    raise_vim_exn(_("cannot replace line"));
! 		}
  
! 	    /*
! 	     * Now we may need to insert the remaining new_len.  We don't need to
! 	     * free the string passed back because MzScheme has control of that
! 	     * memory.
! 	     */
! 	    while (i < new_len)
! 	    {
! 		if (ml_append((linenr_T)(lo + i - 1),
! 			    (char_u *)array[i], 0, FALSE) == FAIL)
! 		{
! 		    curbuf = savebuf;
! 		    free_array(array);
! 		    raise_vim_exn(_("cannot insert line"));
! 		}
! 		++i;
! 		++extra;
! 	    }
! 	    MZ_GC_UNREG();
! 	    free_array(array);
  	}
  
! 	/*
! 	 * Adjust marks. Invalidate any which lie in the
! 	 * changed range, and move any in the remainder of the buffer.
! 	 */
! 	mark_adjust((linenr_T)lo, (linenr_T)(hi - 1), (long)MAXLNUM, (long)extra);
! 	changed_lines((linenr_T)lo, 0, (linenr_T)hi, (long)extra);
  
! 	if (buf->buf == curwin->w_buffer)
! 	    mz_fix_cursor(lo, hi, extra);
! 	curbuf = savebuf;
  
! 	MZ_GC_UNREG();
! 	raise_if_error();
! 	return scheme_void;
!     }
  }
  
  /*
***************
*** 2179,2193 ****
  insert_buffer_line_list(void *data, int argc, Scheme_Object **argv)
  {
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     vim_mz_buffer   *buf;
!     Scheme_Object   *list;
!     Scheme_Object   *line;
!     Scheme_Object   *rest;
!     char	    **array;
!     char	    *str;
!     buf_T	    *savebuf;
      int		    i, n, size;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
--- 2438,2452 ----
  insert_buffer_line_list(void *data, int argc, Scheme_Object **argv)
  {
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     vim_mz_buffer   *buf = NULL;
!     Scheme_Object   *list = NULL;
!     char	    *str = NULL;
      int		    i, n, size;
  
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, list);
+     MZ_GC_REG();
+ 
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
***************
*** 2206,2294 ****
  	check_line_range(n, buf->buf);
      if (SCHEME_STRINGP(list))
      {
! 	str = string_to_line(list);
  
! 	savebuf = curbuf;
  	curbuf = buf->buf;
  
  	if (u_save((linenr_T)n, (linenr_T)(n+1)) == FAIL)
  	{
  	    curbuf = savebuf;
  	    raise_vim_exn(_("cannot save undo information"));
  	}
  	else if (ml_append((linenr_T)n, (char_u *)str, 0, FALSE) == FAIL)
  	{
  	    curbuf = savebuf;
  	    raise_vim_exn(_("cannot insert line"));
  	}
  	else
  	    appended_lines_mark((linenr_T)n, 1L);
  
  	curbuf = savebuf;
  	update_screen(VALID);
  
  	raise_if_error();
  	return scheme_void;
      }
  
      /* List */
      size = scheme_proper_list_length(list);
      if (size < 0)	/* improper or cyclic list */
  	scheme_wrong_type(prim->name, "proper list",
  		2, argc, argv);
! 
!     /* Using MzScheme allocator, so we don't need to free this and
!      * can safely keep pointers to GC collected strings
!      */
!     array = (char **)scheme_malloc_fail_ok(
! 	    scheme_malloc, (unsigned)(size * sizeof(char *)));
! 
!     rest = list;
!     for (i = 0; i < size; ++i)
      {
! 	line = SCHEME_CAR(rest);
! 	rest = SCHEME_CDR(rest);
! 	array[i] = string_to_line(line);
!     }
  
!     savebuf = curbuf;
!     curbuf = buf->buf;
  
!     if (u_save((linenr_T)n, (linenr_T)(n + 1)) == FAIL)
!     {
! 	curbuf = savebuf;
! 	raise_vim_exn(_("cannot save undo information"));
!     }
!     else
!     {
  	for (i = 0; i < size; ++i)
! 	    if (ml_append((linenr_T)(n + i), (char_u *)array[i],
! 			0, FALSE) == FAIL)
! 	    {
! 		curbuf = savebuf;
! 		raise_vim_exn(_("cannot insert line"));
! 	    }
  
! 	if (i > 0)
! 	    appended_lines_mark((linenr_T)n, (long)i);
!     }
  
!     curbuf = savebuf;
!     update_screen(VALID);
  
      raise_if_error();
      return scheme_void;
  }
  
- /* (get-buff-namespace [buffer]) */
-     static Scheme_Object *
- get_buffer_namespace(void *data, int argc, Scheme_Object **argv)
- {
-     Vim_Prim	*prim = (Vim_Prim *)data;
- 
-     return (Scheme_Object *)get_buffer_arg(prim->name, 0, argc, argv)->env;
- }
- 
  /*
   * Predicates
   */
--- 2465,2563 ----
  	check_line_range(n, buf->buf);
      if (SCHEME_STRINGP(list))
      {
! 	buf_T	    *savebuf = curbuf;
  
! 	str = string_to_line(list);
  	curbuf = buf->buf;
  
  	if (u_save((linenr_T)n, (linenr_T)(n+1)) == FAIL)
  	{
  	    curbuf = savebuf;
+ 	    vim_free(str);
  	    raise_vim_exn(_("cannot save undo information"));
  	}
  	else if (ml_append((linenr_T)n, (char_u *)str, 0, FALSE) == FAIL)
  	{
  	    curbuf = savebuf;
+ 	    vim_free(str);
  	    raise_vim_exn(_("cannot insert line"));
  	}
  	else
+ 	{
+ 	    vim_free(str);
  	    appended_lines_mark((linenr_T)n, 1L);
+ 	}
  
  	curbuf = savebuf;
  	update_screen(VALID);
  
+ 	MZ_GC_UNREG();
  	raise_if_error();
  	return scheme_void;
      }
  
      /* List */
      size = scheme_proper_list_length(list);
+     MZ_GC_CHECK();
      if (size < 0)	/* improper or cyclic list */
  	scheme_wrong_type(prim->name, "proper list",
  		2, argc, argv);
!     else
      {
! 	Scheme_Object   *line = NULL;
! 	Scheme_Object   *rest = NULL;
! 	char		**array;
! 	buf_T		*savebuf = curbuf;
! 
! 	MZ_GC_DECL_REG(2);
! 	MZ_GC_VAR_IN_REG(0, line);
! 	MZ_GC_VAR_IN_REG(1, rest);
! 	MZ_GC_REG();
  
! 	array = (char **)alloc(size * sizeof(char *));
! 	vim_memset(array, 0, size * sizeof(char *));
  
! 	rest = list;
  	for (i = 0; i < size; ++i)
! 	{
! 	    line = SCHEME_CAR(rest);
! 	    rest = SCHEME_CDR(rest);
! 	    array[i] = string_to_line(line);
! 	}
  
! 	curbuf = buf->buf;
  
! 	if (u_save((linenr_T)n, (linenr_T)(n + 1)) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    free_array(array);
! 	    raise_vim_exn(_("cannot save undo information"));
! 	}
! 	else
! 	{
! 	    for (i = 0; i < size; ++i)
! 		if (ml_append((linenr_T)(n + i), (char_u *)array[i],
! 			    0, FALSE) == FAIL)
! 		{
! 		    curbuf = savebuf;
! 		    free_array(array);
! 		    raise_vim_exn(_("cannot insert line"));
! 		}
! 
! 	    if (i > 0)
! 		appended_lines_mark((linenr_T)n, (long)i);
! 	}
! 	free_array(array);
! 	MZ_GC_UNREG();
! 	curbuf = savebuf;
! 	update_screen(VALID);
!     }
  
+     MZ_GC_UNREG();
      raise_if_error();
      return scheme_void;
  }
  
  /*
   * Predicates
   */
***************
*** 2343,2383 ****
  /*
   * Convert an MzScheme string into a Vim line.
   *
!  * The result is in allocated memory. All internal nulls are replaced by
!  * newline characters. It is an error for the string to contain newline
!  * characters.
   *
   */
      static char *
  string_to_line(Scheme_Object *obj)
  {
!     char	*str;
      long	len;
      int		i;
  
!     str = scheme_display_to_string(obj, &len);
  
      /* Error checking: String must not contain newlines, as we
       * are replacing a single line, and we must replace it with
       * a single line.
       */
!     if (memchr(str, '\n', len))
  	scheme_signal_error(_("string cannot contain newlines"));
  
      /* Create a copy of the string, with internal nulls replaced by
       * newline characters, as is the vim convention.
       */
      for (i = 0; i < len; ++i)
      {
! 	if (str[i] == '\0')
! 	    str[i] = '\n';
      }
  
!     str[i] = '\0';
  
!     return str;
  }
  
  /*
   * Check to see whether a Vim error has been reported, or a keyboard
   * interrupt (from vim --> got_int) has been detected.
--- 2612,2784 ----
  /*
   * Convert an MzScheme string into a Vim line.
   *
!  * All internal nulls are replaced by newline characters.
!  * It is an error for the string to contain newline characters.
   *
+  * Returns pointer to Vim allocated memory
   */
      static char *
  string_to_line(Scheme_Object *obj)
  {
!     char	*scheme_str = NULL;
!     char	*vim_str = NULL;
      long	len;
      int		i;
  
!     scheme_str = scheme_display_to_string(obj, &len);
  
      /* Error checking: String must not contain newlines, as we
       * are replacing a single line, and we must replace it with
       * a single line.
       */
!     if (memchr(scheme_str, '\n', len))
  	scheme_signal_error(_("string cannot contain newlines"));
  
+     vim_str = (char *)alloc(len + 1);
+ 
      /* Create a copy of the string, with internal nulls replaced by
       * newline characters, as is the vim convention.
       */
      for (i = 0; i < len; ++i)
      {
! 	if (scheme_str[i] == '\0')
! 	    vim_str[i] = '\n';
! 	else
! 	    vim_str[i] = scheme_str[i];
      }
  
!     vim_str[i] = '\0';
  
!     MZ_GC_CHECK();
!     return vim_str;
  }
  
+ #ifdef FEAT_EVAL
+ /*
+  * Convert Vim value into MzScheme, adopted from if_python.c
+  */
+     static Scheme_Object *
+ vim_to_mzscheme(typval_T *vim_value, int depth, Scheme_Hash_Table *visited)
+ {
+     Scheme_Object   *result = NULL;
+     int		    new_value = TRUE;
+ 
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, result);
+     MZ_GC_REG();
+ 
+     /* Avoid infinite recursion */
+     if (depth > 100)
+     {
+ 	MZ_GC_UNREG();
+ 	return scheme_void;
+     }
+ 
+     /* Check if we run into a recursive loop.  The item must be in visited
+      * then and we can use it again.
+      */
+     result = scheme_hash_get(visited, (Scheme_Object *)vim_value);
+     MZ_GC_CHECK();
+     if (result != NULL) /* found, do nothing */
+ 	new_value = FALSE;
+     else if (vim_value->v_type == VAR_STRING)
+     {
+ 	result = scheme_make_string((char *)vim_value->vval.v_string);
+ 	MZ_GC_CHECK();
+     }
+     else if (vim_value->v_type == VAR_NUMBER)
+     {
+ 	result = scheme_make_integer((long)vim_value->vval.v_number);
+ 	MZ_GC_CHECK();
+     }
+ # ifdef FEAT_FLOAT
+     else if (vim_value->v_type == VAR_FLOAT)
+     {
+ 	result = scheme_make_double((double)vim_value->vval.v_float);
+ 	MZ_GC_CHECK();
+     }
+ # endif
+     else if (vim_value->v_type == VAR_LIST)
+     {
+ 	list_T		*list = vim_value->vval.v_list;
+ 	listitem_T	*curr;
+ 
+ 	if (list == NULL || list->lv_first == NULL)
+ 	    result = scheme_null;
+ 	else
+ 	{
+ 	    Scheme_Object   *obj = NULL;
+ 
+ 	    MZ_GC_DECL_REG(1);
+ 	    MZ_GC_VAR_IN_REG(0, obj);
+ 	    MZ_GC_REG();
+ 
+ 	    curr = list->lv_last;
+ 	    obj = vim_to_mzscheme(&curr->li_tv, depth + 1, visited);
+ 	    result = scheme_make_pair(obj, scheme_null);
+ 	    MZ_GC_CHECK();
+ 
+ 	    while (curr != list->lv_first)
+ 	    {
+ 		curr = curr->li_prev;
+ 		obj = vim_to_mzscheme(&curr->li_tv, depth + 1, visited);
+ 		result = scheme_make_pair(obj, result);
+ 		MZ_GC_CHECK();
+ 	    }
+ 	}
+ 	MZ_GC_UNREG();
+     }
+     else if (vim_value->v_type == VAR_DICT)
+     {
+ 	Scheme_Object	  *key = NULL;
+ 	Scheme_Object	  *obj = NULL;
+ 
+ 	MZ_GC_DECL_REG(2);
+ 	MZ_GC_VAR_IN_REG(0, key);
+ 	MZ_GC_VAR_IN_REG(1, obj);
+ 	MZ_GC_REG();
+ 
+ 	result = (Scheme_Object *)scheme_make_hash_table(SCHEME_hash_ptr);
+ 	MZ_GC_CHECK();
+ 	if (vim_value->vval.v_dict != NULL)
+ 	{
+ 	    hashtab_T	*ht = &vim_value->vval.v_dict->dv_hashtab;
+ 	    long_u	todo = ht->ht_used;
+ 	    hashitem_T	*hi;
+ 	    dictitem_T	*di;
+ 
+ 	    for (hi = ht->ht_array; todo > 0; ++hi)
+ 	    {
+ 		if (!HASHITEM_EMPTY(hi))
+ 		{
+ 		    --todo;
+ 
+ 		    di = dict_lookup(hi);
+ 		    obj = vim_to_mzscheme(&di->di_tv, depth + 1, visited);
+ 		    key = scheme_make_string((char *)hi->hi_key);
+ 		    MZ_GC_CHECK();
+ 		    scheme_hash_set((Scheme_Hash_Table *)result, key, obj);
+ 		    MZ_GC_CHECK();
+ 		}
+ 	    }
+ 	}
+ 	MZ_GC_UNREG();
+     }
+     else
+     {
+ 	result = scheme_void;
+ 	new_value = FALSE;
+     }
+     if (new_value)
+     {
+ 	scheme_hash_set(visited, (Scheme_Object *)vim_value, result);
+ 	MZ_GC_CHECK();
+     }
+     MZ_GC_UNREG();
+     return result;
+ }
+ #endif
+ 
  /*
   * Check to see whether a Vim error has been reported, or a keyboard
   * interrupt (from vim --> got_int) has been detected.
***************
*** 2392,2441 ****
   * register Scheme exn:vim
   */
      static void
! register_vim_exn(Scheme_Env *env)
  {
!     Scheme_Object   *exn_name = scheme_intern_symbol("exn:vim");
  
      if (vim_exn == NULL)
  	vim_exn = scheme_make_struct_type(exn_name,
! 		scheme_builtin_value("struct:exn"), NULL, 0, 0, NULL, NULL
  #if MZSCHEME_VERSION_MAJOR >= 299
  		, NULL
  #endif
  		);
  
-     if (vim_exn_values == NULL)
-     {
- 	int	nc = 0;
  
! 	Scheme_Object   **exn_names = scheme_make_struct_names(
! 		exn_name, scheme_null, 0, &nc);
! 	Scheme_Object   **exn_values = scheme_make_struct_values(
! 		vim_exn, exn_names, nc, 0);
! 
! 	vim_exn_names = scheme_make_vector(nc, scheme_false);
! 	vim_exn_values = scheme_make_vector(nc, scheme_false);
! 	/* remember names and values */
! 	mch_memmove(SCHEME_VEC_ELS(vim_exn_names), exn_names,
! 		nc * sizeof(Scheme_Object *));
! 	mch_memmove(SCHEME_VEC_ELS(vim_exn_values), exn_values,
! 		nc * sizeof(Scheme_Object *));
      }
! 
!     add_vim_exn(env);
! }
! 
! /*
!  * Add stuff of exn:vim to env
!  */
!     static void
! add_vim_exn(Scheme_Env *env)
! {
!     int i;
! 
!     for (i = 0; i < SCHEME_VEC_SIZE(vim_exn_values); i++)
! 	scheme_add_global_symbol(SCHEME_VEC_ELS(vim_exn_names)[i],
! 		SCHEME_VEC_ELS(vim_exn_values)[i], env);
  }
  
  /*
--- 2793,2851 ----
   * register Scheme exn:vim
   */
      static void
! register_vim_exn(void)
  {
!     int	nc = 0;
!     int i;
!     Scheme_Object   *struct_exn = NULL;
!     Scheme_Object   *exn_name = NULL;
! 
!     MZ_GC_DECL_REG(2);
!     MZ_GC_VAR_IN_REG(0, struct_exn);
!     MZ_GC_VAR_IN_REG(1, exn_name);
!     MZ_GC_REG();
! 
!     exn_name = scheme_intern_symbol("exn:vim");
!     MZ_GC_CHECK();
!     struct_exn = scheme_builtin_value("struct:exn");
!     MZ_GC_CHECK();
  
      if (vim_exn == NULL)
  	vim_exn = scheme_make_struct_type(exn_name,
! 		struct_exn, NULL, 0, 0, NULL, NULL
  #if MZSCHEME_VERSION_MAJOR >= 299
  		, NULL
  #endif
  		);
  
  
!     {
! 	Scheme_Object   **tmp = NULL;
! 	Scheme_Object   *exn_names[5] = {NULL, NULL, NULL, NULL, NULL};
! 	Scheme_Object   *exn_values[5] = {NULL, NULL, NULL, NULL, NULL};
! 	MZ_GC_DECL_REG(6);
! 	MZ_GC_ARRAY_VAR_IN_REG(0, exn_names, 5);
! 	MZ_GC_ARRAY_VAR_IN_REG(3, exn_values, 5);
! 	MZ_GC_REG();
! 
! 	tmp = scheme_make_struct_names(exn_name, scheme_null, 0, &nc);
! 	assert(nc <= 5);
! 	mch_memmove(exn_names, tmp, nc * sizeof(Scheme_Object *));
! 	MZ_GC_CHECK();
! 
! 	tmp = scheme_make_struct_values(vim_exn, exn_names, nc, 0);
! 	mch_memmove(exn_values, tmp, nc * sizeof(Scheme_Object *));
! 	MZ_GC_CHECK();
! 
! 	for (i = 0; i < nc; i++)
! 	{
! 	    scheme_add_global_symbol(exn_names[i],
! 		    exn_values[i], environment);
! 	    MZ_GC_CHECK();
! 	}
! 	MZ_GC_UNREG();
      }
!     MZ_GC_UNREG();
  }
  
  /*
***************
*** 2444,2469 ****
      void
  raise_vim_exn(const char *add_info)
  {
!     Scheme_Object   *argv[2];
!     char_u	    *fmt = _("Vim error: ~a");
  
      if (add_info != NULL)
      {
! 	Scheme_Object   *info = scheme_make_string(add_info);
! 	argv[0] = scheme_byte_string_to_char_string(scheme_make_string(
! 		scheme_format(fmt, strlen(fmt), 1, &info, NULL)));
  	SCHEME_SET_IMMUTABLE(argv[0]);
      }
      else
  	argv[0] = scheme_make_string(_("Vim error"));
  
  #if MZSCHEME_VERSION_MAJOR < 360
      argv[1] = scheme_current_continuation_marks();
  #else
      argv[1] = scheme_current_continuation_marks(NULL);
  #endif
  
!     scheme_raise(scheme_make_struct_instance(vim_exn, 2, argv));
  }
  
      void
--- 2854,2907 ----
      void
  raise_vim_exn(const char *add_info)
  {
!     char	    *fmt = _("Vim error: ~a");
!     Scheme_Object   *argv[2] = {NULL, NULL};
!     Scheme_Object   *exn = NULL;
! 
!     MZ_GC_DECL_REG(4);
!     MZ_GC_ARRAY_VAR_IN_REG(0, argv, 2);
!     MZ_GC_VAR_IN_REG(3, exn);
!     MZ_GC_REG();
  
      if (add_info != NULL)
      {
! 	char		*c_string = NULL;
! 	Scheme_Object	*byte_string = NULL;
! 	Scheme_Object   *info = NULL;
! 
! 	MZ_GC_DECL_REG(3);
! 	MZ_GC_VAR_IN_REG(0, c_string);
! 	MZ_GC_VAR_IN_REG(1, byte_string);
! 	MZ_GC_VAR_IN_REG(2, info);
! 	MZ_GC_REG();
! 
! 	info = scheme_make_string(add_info);
! 	MZ_GC_CHECK();
! 	c_string = scheme_format(fmt, STRLEN(fmt), 1, &info, NULL);
! 	MZ_GC_CHECK();
! 	byte_string = scheme_make_string(c_string);
! 	MZ_GC_CHECK();
! 	argv[0] = scheme_byte_string_to_char_string(byte_string);
! 	MZ_GC_CHECK();
  	SCHEME_SET_IMMUTABLE(argv[0]);
+ 	MZ_GC_UNREG();
      }
      else
  	argv[0] = scheme_make_string(_("Vim error"));
+     MZ_GC_CHECK();
  
  #if MZSCHEME_VERSION_MAJOR < 360
      argv[1] = scheme_current_continuation_marks();
+     MZ_GC_CHECK();
  #else
      argv[1] = scheme_current_continuation_marks(NULL);
+     MZ_GC_CHECK();
  #endif
  
!     exn = scheme_make_struct_instance(vim_exn, 2, argv);
!     MZ_GC_CHECK();
!     scheme_raise(exn);
!     MZ_GC_UNREG();
  }
  
      void
***************
*** 2570,2575 ****
--- 3008,3015 ----
  	    curwin->w_cursor.lnum = lo;
  	    check_cursor();
  	}
+ 	else
+ 	    check_cursor_col();
  	changed_cline_bef_curs();
      }
      invalidate_botline();
***************
*** 2595,2601 ****
      {mzscheme_open_buffer, "open-buff", 1, 1},
      {get_buffer_by_name, "get-buff-by-name", 1, 1},
      {get_buffer_by_num, "get-buff-by-num", 1, 1},
-     {get_buffer_namespace, "get-buff-namespace", 0, 1},
      /*
       * Window-related commands
       */
--- 3035,3040 ----
***************
*** 2653,2675 ****
  }
  
      static void
! make_modules(Scheme_Env *env)
  {
!     int		i;
!     Scheme_Env	*mod;
! 
!     mod = scheme_primitive_module(scheme_intern_symbol("vimext"), env);
      /* all prims made closed so they can access their own names */
!     for (i = 0; i < sizeof(prims)/sizeof(prims[0]); i++)
      {
  	Vim_Prim *prim = prims + i;
! 	scheme_add_global(prim->name,
! 		scheme_make_closed_prim_w_arity(prim->prim, prim, prim->name,
! 		    prim->mina, prim->maxa),
! 		mod);
      }
-     scheme_add_global("global-namespace", (Scheme_Object *)environment, mod);
      scheme_finish_primitive_module(mod);
  }
  
  #ifdef HAVE_SANDBOX
--- 3092,3126 ----
  }
  
      static void
! make_modules()
  {
!     int		    i;
!     Scheme_Env	    *mod = NULL;
!     Scheme_Object   *vimext_symbol = NULL;
!     Scheme_Object   *closed_prim = NULL;
! 
!     MZ_GC_DECL_REG(3);
!     MZ_GC_VAR_IN_REG(0, mod);
!     MZ_GC_VAR_IN_REG(1, vimext_symbol);
!     MZ_GC_VAR_IN_REG(2, closed_prim);
!     MZ_GC_REG();
! 
!     vimext_symbol = scheme_intern_symbol("vimext");
!     MZ_GC_CHECK();
!     mod = scheme_primitive_module(vimext_symbol, environment);
!     MZ_GC_CHECK();
      /* all prims made closed so they can access their own names */
!     for (i = 0; i < (int)(sizeof(prims)/sizeof(prims[0])); i++)
      {
  	Vim_Prim *prim = prims + i;
! 	closed_prim = scheme_make_closed_prim_w_arity(prim->prim, prim, prim->name,
! 			    prim->mina, prim->maxa);
! 	scheme_add_global(prim->name, closed_prim, mod);
! 	MZ_GC_CHECK();
      }
      scheme_finish_primitive_module(mod);
+     MZ_GC_CHECK();
+     MZ_GC_UNREG();
  }
  
  #ifdef HAVE_SANDBOX
***************
*** 2697,2717 ****
--- 3148,3172 ----
  	{
  	    MZ_REGISTER_STATIC(M_write);
  	    M_write = scheme_intern_symbol("write");
+ 	    MZ_GC_CHECK();
  	}
  	if (M_read == NULL)
  	{
  	    MZ_REGISTER_STATIC(M_read);
  	    M_read = scheme_intern_symbol("read");
+ 	    MZ_GC_CHECK();
  	}
  	if (M_execute == NULL)
  	{
  	    MZ_REGISTER_STATIC(M_execute);
  	    M_execute = scheme_intern_symbol("execute");
+ 	    MZ_GC_CHECK();
  	}
  	if (M_delete == NULL)
  	{
  	    MZ_REGISTER_STATIC(M_delete);
  	    M_delete = scheme_intern_symbol("delete");
+ 	    MZ_GC_CHECK();
  	}
  
  	while (!SCHEME_NULLP(requested_access))
*** ../vim-7.2.190/src/if_mzsch.h	2006-03-24 23:43:11.000000000 +0100
--- src/if_mzsch.h	2009-05-26 19:08:21.000000000 +0200
***************
*** 11,16 ****
--- 11,17 ----
  
  /* #ifdef needed for "make depend" */
  #ifdef FEAT_MZSCHEME
+ # include <schvers.h>
  # include <scheme.h>
  #endif
  
***************
*** 46,49 ****
--- 47,77 ----
  # define scheme_byte_string_to_char_string(obj) (obj)
  #endif
  
+ /* Precise GC macros */
+ #ifndef MZ_GC_DECL_REG
+ # define MZ_GC_DECL_REG(size)            /* empty */
+ #endif
+ #ifndef MZ_GC_VAR_IN_REG
+ # define MZ_GC_VAR_IN_REG(x, v)          /* empty */
+ #endif
+ #ifndef MZ_GC_ARRAY_VAR_IN_REG
+ # define MZ_GC_ARRAY_VAR_IN_REG(x, v, l) /* empty */
+ #endif
+ #ifndef MZ_GC_REG
+ # define MZ_GC_REG()                     /* empty */
+ #endif
+ #ifndef MZ_GC_UNREG
+ # define MZ_GC_UNREG()                   /* empty */
+ #endif
+ 
+ #ifdef MZSCHEME_FORCE_GC
+ /*
+  * force garbage collection to check all references are registered
+  * seg faults will indicate not registered refs
+  */
+ # define MZ_GC_CHECK() scheme_collect_garbage();
+ #else
+ # define MZ_GC_CHECK()			/* empty */
+ #endif
+ 
  #endif /* _IF_MZSCH_H_ */
*** ../vim-7.2.190/src/main.c	2009-05-17 13:30:58.000000000 +0200
--- src/main.c	2009-05-26 19:09:01.000000000 +0200
***************
*** 935,942 ****
--- 935,948 ----
  
      /*
       * Call the main command loop.  This never returns.
+      * For embedded MzScheme the main_loop will be called by Scheme
+      * for proper stack tracking
       */
+ #ifndef FEAT_MZSCHEME
      main_loop(FALSE, FALSE);
+ #else
+     mzscheme_main();
+ #endif
  
      return 0;
  }
*** ../vim-7.2.190/src/proto/if_mzsch.pro	2004-07-12 17:51:52.000000000 +0200
--- src/proto/if_mzsch.pro	2009-05-26 19:09:55.000000000 +0200
***************
*** 15,24 ****
  void *mzvim_eval_string __ARGS((char_u *str));
  struct Scheme_Object *mzvim_apply __ARGS((struct Scheme_Object *, int argc,
      struct Scheme_Object **));
! int mzthreads_allowed (void);
! #ifdef FEAT_GUI_KDE
! void timer_proc (void);
! void mzscheme_kde_start_timer (void);
! void mzscheme_kde_stop_timer (void);
! #endif
  /* vim: set ft=c : */
--- 15,20 ----
  void *mzvim_eval_string __ARGS((char_u *str));
  struct Scheme_Object *mzvim_apply __ARGS((struct Scheme_Object *, int argc,
      struct Scheme_Object **));
! int mzthreads_allowed __ARGS((void));
! void mzscheme_main __ARGS((void));
  /* vim: set ft=c : */
*** ../vim-7.2.190/src/version.c	2009-05-26 18:12:13.000000000 +0200
--- src/version.c	2009-05-26 22:52:53.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     191,
  /**/

-- 
Scientists decoded the first message from an alien civilization:
        SIMPLY SEND 6 TIMES 10 TO THE 50 ATOMS OF HYDROGEN TO THE STAR
SYSTEM AT THE TOP OF THE LIST, CROSS OFF THAT STAR SYSTEM, THEN PUT
YOUR STAR SYSTEM AT THE BOTTOM OF THE LIST AND SEND IT TO 100 OTHER
STAR SYSTEMS.  WITHIN ONE TENTH GALACTIC ROTATION YOU WILL RECEIVE
ENOUGH HYDROGREN TO POWER YOUR CIVILIZATION UNTIL ENTROPY REACHES ITS
MAXIMUM!  IT REALLY WORKS!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.192
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.192 (after 7.2.188)
Problem:    Still a crash in the garbage collector for a very rare situation.
Solution:   Make sure current_copyID is always incremented correctly. (Kent
	    Sibilev)
Files:	    src/eval.c


*** ../vim-7.2.191/src/eval.c	2009-05-26 22:58:43.000000000 +0200
--- src/eval.c	2009-05-29 21:13:47.000000000 +0200
***************
*** 6526,6532 ****
  
      /* Don't free variables in the previous_funccal list unless they are only
       * referenced through previous_funccal.  This must be first, because if
!      * the item is referenced elsewhere it must not be freed. */
      for (fc = previous_funccal; fc != NULL; fc = fc->caller)
      {
  	set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1);
--- 6526,6532 ----
  
      /* Don't free variables in the previous_funccal list unless they are only
       * referenced through previous_funccal.  This must be first, because if
!      * the item is referenced elsewhere the funccal must not be freed. */
      for (fc = previous_funccal; fc != NULL; fc = fc->caller)
      {
  	set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1);
***************
*** 6564,6573 ****
      /* v: vars */
      set_ref_in_ht(&vimvarht, copyID);
  
!     /* Free lists and dictionaries that are not referenced. */
      did_free = free_unref_items(copyID);
  
!     /* check if any funccal can be freed now */
      for (pfc = &previous_funccal; *pfc != NULL; )
      {
  	if (can_free_funccal(*pfc, copyID))
--- 6564,6577 ----
      /* v: vars */
      set_ref_in_ht(&vimvarht, copyID);
  
!     /*
!      * 2. Free lists and dictionaries that are not referenced.
!      */
      did_free = free_unref_items(copyID);
  
!     /*
!      * 3. Check if any funccal can be freed now.
!      */
      for (pfc = &previous_funccal; *pfc != NULL; )
      {
  	if (can_free_funccal(*pfc, copyID))
***************
*** 9286,9292 ****
      if (noref < 0 || noref > 1)
  	EMSG(_(e_invarg));
      else
! 	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? ++current_copyID : 0);
  }
  
  /*
--- 9290,9299 ----
      if (noref < 0 || noref > 1)
  	EMSG(_(e_invarg));
      else
!     {
! 	current_copyID += COPYID_INC;
! 	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? current_copyID : 0);
!     }
  }
  
  /*
***************
*** 18966,18972 ****
      char_u	*s;
      char_u	numbuf[NUMBUFLEN];
  
!     s = echo_string(&v->di_tv, &tofree, numbuf, ++current_copyID);
      list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
  					 s == NULL ? (char_u *)"" : s, first);
      vim_free(tofree);
--- 18973,18980 ----
      char_u	*s;
      char_u	numbuf[NUMBUFLEN];
  
!     current_copyID += COPYID_INC;
!     s = echo_string(&v->di_tv, &tofree, numbuf, current_copyID);
      list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
  					 s == NULL ? (char_u *)"" : s, first);
      vim_free(tofree);
***************
*** 19401,19407 ****
  	    }
  	    else if (eap->cmdidx == CMD_echo)
  		msg_puts_attr((char_u *)" ", echo_attr);
! 	    p = echo_string(&rettv, &tofree, numbuf, ++current_copyID);
  	    if (p != NULL)
  		for ( ; *p != NUL && !got_int; ++p)
  		{
--- 19409,19416 ----
  	    }
  	    else if (eap->cmdidx == CMD_echo)
  		msg_puts_attr((char_u *)" ", echo_attr);
! 	    current_copyID += COPYID_INC;
! 	    p = echo_string(&rettv, &tofree, numbuf, current_copyID);
  	    if (p != NULL)
  		for ( ; *p != NUL && !got_int; ++p)
  		{
*** ../vim-7.2.191/src/version.c	2009-05-26 22:58:43.000000000 +0200
--- src/version.c	2009-06-03 13:21:20.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     192,
  /**/

-- 
Imagine a world without hypothetical situations.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.193
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.193
Problem:    Warning for uninitialized values.
Solution:   Initialize all the struct items.
Files:	    src/eval.c


*** ../vim-7.2.192/src/eval.c	2009-06-03 13:22:22.000000000 +0200
--- src/eval.c	2009-05-29 21:13:47.000000000 +0200
***************
*** 286,292 ****
  #define VV_RO		2	/* read-only */
  #define VV_RO_SBX	4	/* read-only in the sandbox */
  
! #define VV_NAME(s, t)	s, {{t}}, {0}
  
  static struct vimvar
  {
--- 286,292 ----
  #define VV_RO		2	/* read-only */
  #define VV_RO_SBX	4	/* read-only in the sandbox */
  
! #define VV_NAME(s, t)	s, {{t, 0, {0}}, 0, {0}}, {0}
  
  static struct vimvar
  {
*** ../vim-7.2.192/src/version.c	2009-06-03 13:22:23.000000000 +0200
--- src/version.c	2009-06-03 14:25:18.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     193,
  /**/

-- 
No engineer can take a shower without wondering if some sort of Teflon coating
would make showering unnecessary.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.194 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.194 (extra)
Problem:    MSVC: rem commands are echoed.
Solution:   Add commands to switch off echo. (Wang Xu)
Files:	    src/msvc2008.bat


*** ../vim-7.2.193/src/msvc2008.bat	2008-06-24 22:55:23.000000000 +0200
--- src/msvc2008.bat	2009-04-29 18:05:11.000000000 +0200
***************
*** 1,5 ****
--- 1,7 ----
+ @echo off
  rem To be used on MS-Windows for Visual C++ 2008 Express Edition
  rem   aka Microsoft Visual Studio 9.0.
  rem See INSTALLpc.txt for information.
+ @echo on
  
  call "%VS90COMNTOOLS%%vsvars32.bat"
*** ../vim-7.2.193/src/version.c	2009-06-03 14:25:47.000000000 +0200
--- src/version.c	2009-06-03 15:04:30.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     194,
  /**/

-- 
I used to be indecisive, now I'm not sure.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.195
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.195
Problem:    Leaking memory for the command Vim was started with.
Solution:   Remember the pointer and free it.
Files:	    src/gui_gtk_x11.c


*** ../vim-7.2.194/src/gui_gtk_x11.c	2009-05-17 16:23:20.000000000 +0200
--- src/gui_gtk_x11.c	2009-06-03 12:44:31.000000000 +0200
***************
*** 412,417 ****
--- 412,418 ----
  #endif
  #if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
  static const char *restart_command = NULL;
+ static       char *abs_restart_command = NULL;
  #endif
  static int found_iconic_arg = FALSE;
  
***************
*** 449,456 ****
  	char_u buf[MAXPATHL];
  
  	if (mch_FullName((char_u *)argv[0], buf, (int)sizeof(buf), TRUE) == OK)
! 	    /* Tiny leak; doesn't matter, and usually we don't even get here */
! 	    restart_command = (char *)vim_strsave(buf);
      }
  #endif
  
--- 450,459 ----
  	char_u buf[MAXPATHL];
  
  	if (mch_FullName((char_u *)argv[0], buf, (int)sizeof(buf), TRUE) == OK)
! 	{
! 	    abs_restart_command = (char *)vim_strsave(buf);
! 	    restart_command = abs_restart_command;
! 	}
      }
  #endif
  
***************
*** 611,616 ****
--- 614,622 ----
  gui_mch_free_all()
  {
      vim_free(gui_argv);
+ #if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
+     vim_free(abs_restart_command);
+ #endif
  }
  #endif
  
*** ../vim-7.2.194/src/version.c	2009-06-03 15:05:05.000000000 +0200
--- src/version.c	2009-06-03 16:19:00.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     195,
  /**/

-- 
I think that you'll agree that engineers are very effective in their social
interactions.  It's the "normal" people who are nuts.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.196
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.196 (after 7.2.167)
Problem:    Turns out splint doesn't work well enough to be usable.
Solution:   Remove splint support.
Files:	    Filelist, src/cleanlint.vim


*** ../vim-7.2.195/Filelist	2009-05-13 12:46:36.000000000 +0200
--- Filelist	2009-05-21 14:42:46.000000000 +0200
***************
*** 139,145 ****
  		src/INSTALL \
  		src/INSTALLx.txt \
  		src/Makefile \
- 		src/cleanlint.vim \
  		src/auto/configure \
  		src/config.aap.in \
  		src/config.h.in \
--- 139,144 ----
*** ../vim-7.2.195/src/cleanlint.vim	2009-05-13 18:54:14.000000000 +0200
--- src/cleanlint.vim	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,32 ****
- " Vim tool: Filter output of splint
- "
- " Maintainer:	Bram Moolenaar <Bram@vim.org>
- " Last Change:	2009 May 13
- 
- " Usage: redirect output of "make lint" to a file, edit that file with Vim and
- " :call CleanLint()
- " This deletes irrelevant messages.  What remains might be valid warnings.
- 
- fun! CleanLint()
-   g/Assignment of dev_t to __dev_t:/lockmarks d
-   g/Assignment of __dev_t to dev_t:/lockmarks d
-   g/Operands of == have incompatible types (__dev_t, dev_t): /lockmarks d
-   g/Operands of == have incompatible types (char_u, int): /lockmarks d
-   g/Assignment of char to char_u: /lockmarks d
-   g/Assignment of unsigned int to int: /lockmarks d
-   g/Assignment of int to unsigned int: /lockmarks d
-   g/Assignment of unsigned int to long int: /lockmarks d
-   g/Assignment of int to char_u: /lockmarks d
-   g/Function .* expects arg . to be wint_t gets int: /lockmarks d
-   g/Function .* expects arg . to be size_t gets int: /lockmarks d
-   g/Initial value of .* is type char, expects char_u: /lockmarks d
-   g/^ex_cmds.h:.* Function types are inconsistent. Parameter 1 is implicitly temp, but unqualified in assigned function:/lockmarks d
-   g/^ex_docmd.c:.* nospec_str/lockmarks d
-   g/^digraph.c.*Additional initialization errors for digraphdefault not reported/lockmarks d
-   g/Function strncasecmp expects arg 3 to be int gets size_t: /lockmarks d
-   g/^  Types are incompatible/lockmarks d
-   g/ To ignore signs in type comparisons use +ignoresigns/lockmarks d
-   g/ To allow arbitrary integral types to match any integral type, use +matchanyintegral./lockmarks d
-   g/ To allow arbitrary integral types to match long unsigned, use +longintegral./lockmarks d
-   g+ A variable is declared but never used. Use /.@unused@./ in front of declaration to suppress message.+lockmarks d
- endfun
--- 0 ----
*** ../vim-7.2.195/src/version.c	2009-06-03 16:20:09.000000000 +0200
--- src/version.c	2009-06-03 22:04:31.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     196,
  /**/

-- 
It's totally unfair to suggest - as many have - that engineers are socially
inept.  Engineers simply have different objectives when it comes to social
interaction.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.197
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.197
Problem:    Warning for uninitialized values.
Solution:   Initialize all the struct items of typebuf.
Files:	    src/globals.h


*** ../vim-7.2.196/src/globals.h	2009-05-13 12:46:36.000000000 +0200
--- src/globals.h	2009-06-10 15:52:18.000000000 +0200
***************
*** 960,966 ****
  		    ;
  EXTERN typebuf_T typebuf		/* typeahead buffer */
  #ifdef DO_INIT
! 		    = {NULL, NULL}
  #endif
  		    ;
  #ifdef FEAT_EX_EXTRA
--- 967,973 ----
  		    ;
  EXTERN typebuf_T typebuf		/* typeahead buffer */
  #ifdef DO_INIT
! 		    = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}
  #endif
  		    ;
  #ifdef FEAT_EX_EXTRA
*** ../vim-7.2.196/src/version.c	2009-06-03 22:07:38.000000000 +0200
--- src/version.c	2009-06-10 18:14:58.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     197,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
18. Your wife drapes a blond wig over your monitor to remind you of what she
    looks like.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.198
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.198
Problem:    Size of buffer used for tgetent() may be too small.
Solution:   Use the largest known size everywhere.
Files:	    src/vim.h


*** ../vim-7.2.197/src/vim.h	2009-05-14 22:19:19.000000000 +0200
--- src/vim.h	2009-06-07 20:37:48.000000000 +0200
***************
*** 1345,1355 ****
  # define MSG_BUF_CLEN  MSG_BUF_LEN	    /* cell length */
  #endif
  
! #if defined(AMIGA) || defined(__linux__) || defined(__QNX__) || defined(__CYGWIN32__) || defined(_AIX)
! # define TBUFSZ 2048		/* buffer size for termcap entry */
! #else
! # define TBUFSZ 1024		/* buffer size for termcap entry */
! #endif
  
  /*
   * Maximum length of key sequence to be mapped.
--- 1345,1355 ----
  # define MSG_BUF_CLEN  MSG_BUF_LEN	    /* cell length */
  #endif
  
! /* Size of the buffer used for tgetent().  Unfortunately this is largely
!  * undocumented, some systems use 1024.  Using a buffer that is too small
!  * causes a buffer overrun and a crash.  Use the maximum known value to stay
!  * on the safe side. */
! #define TBUFSZ 2048		/* buffer size for termcap entry */
  
  /*
   * Maximum length of key sequence to be mapped.
*** ../vim-7.2.197/src/version.c	2009-06-10 18:15:49.000000000 +0200
--- src/version.c	2009-06-16 11:06:45.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     198,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
7. Finish all your sentences with "in accordance with the prophecy".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.199
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.199
Problem:    Strange character in comment.
Solution:   Change to "message". (Yongwei Wu)
Files:      src/term.c


*** ../vim-7.2.198/src/term.c	2009-05-17 13:30:58.000000000 +0200
--- src/term.c	2009-06-16 11:16:17.000000000 +0200
***************
*** 5555,5561 ****
   * respects the current B/k/< settings of 'cpoption'.
   *
   * This function is called when expanding mappings/abbreviations on the
!  * command-line, and for building the "Ambiguous mapping..." error messge.
   *
   * It uses a growarray to build the translation string since the
   * latter can be wider than the original description. The caller has to
--- 5555,5561 ----
   * respects the current B/k/< settings of 'cpoption'.
   *
   * This function is called when expanding mappings/abbreviations on the
!  * command-line, and for building the "Ambiguous mapping..." error message.
   *
   * It uses a growarray to build the translation string since the
   * latter can be wider than the original description. The caller has to
*** ../vim-7.2.198/src/version.c	2009-06-16 11:08:13.000000000 +0200
--- src/version.c	2009-06-16 14:31:03.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     199,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
10. Ask people what sex they are. Laugh hysterically after they answer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.200
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.200
Problem:    Reading past end of string when navigating the menu bar or
	    resizing the window.
Solution:   Add and use mb_ptr2len_len(). (partly by Dominique Pelle)
	    Also add mb_ptr2cells_len() to prevent more trouble.
Files:	    src/gui_gtk_x11.c, src/os_unix.c, src/globals.h, src/mbyte.c,
	    src/proto/mbyte.pro


*** ../vim-7.2.199/src/gui_gtk_x11.c	2009-06-03 16:20:09.000000000 +0200
--- src/gui_gtk_x11.c	2009-06-16 14:44:19.000000000 +0200
***************
*** 6077,6088 ****
  # ifdef FEAT_MBYTE
  	    if (enc_utf8)
  	    {
! 		c = utf_ptr2char(p);
  		if (c >= 0x10000)	/* show chars > 0xffff as ? */
  		    c = 0xbf;
  		buf[textlen].byte1 = c >> 8;
  		buf[textlen].byte2 = c;
! 		p += utf_ptr2len(p);
  		width += utf_char2cells(c);
  	    }
  	    else
--- 6135,6149 ----
  # ifdef FEAT_MBYTE
  	    if (enc_utf8)
  	    {
! 		int pcc[MAX_MCO];
! 
! 		/* TODO: use the composing characters */
! 		c = utfc_ptr2char_len(p, &pcc, len - (p - s));
  		if (c >= 0x10000)	/* show chars > 0xffff as ? */
  		    c = 0xbf;
  		buf[textlen].byte1 = c >> 8;
  		buf[textlen].byte2 = c;
! 		p += utfc_ptr2len_len(p, len - (p - s));
  		width += utf_char2cells(c);
  	    }
  	    else
***************
*** 6106,6113 ****
  	if (has_mbyte)
  	{
  	    width = 0;
! 	    for (p = s; p < s + len; p += (*mb_ptr2len)(p))
! 		width += (*mb_ptr2cells)(p);
  	}
  	else
  # endif
--- 6167,6174 ----
  	if (has_mbyte)
  	{
  	    width = 0;
! 	    for (p = s; p < s + len; p += (*mb_ptr2len_len)(p, len - (p - s)))
! 		width += (*mb_ptr2cells_len)(p, len - (p - s));
  	}
  	else
  # endif
*** ../vim-7.2.199/src/os_unix.c	2009-05-17 13:30:58.000000000 +0200
--- src/os_unix.c	2009-06-03 12:35:59.000000000 +0200
***************
*** 4305,4311 ****
  				ta_buf[i] = '\n';
  # ifdef FEAT_MBYTE
  			    if (has_mbyte)
! 				i += (*mb_ptr2len)(ta_buf + i) - 1;
  # endif
  			}
  
--- 4305,4312 ----
  				ta_buf[i] = '\n';
  # ifdef FEAT_MBYTE
  			    if (has_mbyte)
! 				i += (*mb_ptr2len_len)(ta_buf + i,
! 							ta_len + len - i) - 1;
  # endif
  			}
  
*** ../vim-7.2.199/src/globals.h	2009-06-10 18:15:49.000000000 +0200
--- src/globals.h	2009-06-12 21:10:30.000000000 +0200
***************
*** 810,820 ****
--- 815,828 ----
   */
  /* length of char in bytes, including following composing chars */
  EXTERN int (*mb_ptr2len) __ARGS((char_u *p)) INIT(= latin_ptr2len);
+ /* idem, with limit on string length */
+ EXTERN int (*mb_ptr2len_len) __ARGS((char_u *p, int size)) INIT(= latin_ptr2len_len);
  /* byte length of char */
  EXTERN int (*mb_char2len) __ARGS((int c)) INIT(= latin_char2len);
  /* convert char to bytes, return the length */
  EXTERN int (*mb_char2bytes) __ARGS((int c, char_u *buf)) INIT(= latin_char2bytes);
  EXTERN int (*mb_ptr2cells) __ARGS((char_u *p)) INIT(= latin_ptr2cells);
+ EXTERN int (*mb_ptr2cells_len) __ARGS((char_u *p, int size)) INIT(= latin_ptr2cells_len);
  EXTERN int (*mb_char2cells) __ARGS((int c)) INIT(= latin_char2cells);
  EXTERN int (*mb_off2cells) __ARGS((unsigned off, unsigned max_off)) INIT(= latin_off2cells);
  EXTERN int (*mb_ptr2char) __ARGS((char_u *p)) INIT(= latin_ptr2char);
*** ../vim-7.2.199/src/mbyte.c	2009-05-17 13:30:58.000000000 +0200
--- src/mbyte.c	2009-06-16 15:01:30.000000000 +0200
***************
*** 127,133 ****
--- 127,136 ----
  static int dbcs_char2len __ARGS((int c));
  static int dbcs_char2bytes __ARGS((int c, char_u *buf));
  static int dbcs_ptr2len __ARGS((char_u *p));
+ static int dbcs_ptr2len_len __ARGS((char_u *p, int size));
+ static int utf_ptr2cells_len __ARGS((char_u *p, int size));
  static int dbcs_char2cells __ARGS((int c));
+ static int dbcs_ptr2cells_len __ARGS((char_u *p, int size));
  static int dbcs_ptr2char __ARGS((char_u *p));
  
  /* Lookup table to quickly get the length in bytes of a UTF-8 character from
***************
*** 606,614 ****
--- 609,619 ----
      if (enc_utf8)
      {
  	mb_ptr2len = utfc_ptr2len;
+ 	mb_ptr2len_len = utfc_ptr2len_len;
  	mb_char2len = utf_char2len;
  	mb_char2bytes = utf_char2bytes;
  	mb_ptr2cells = utf_ptr2cells;
+ 	mb_ptr2cells_len = utf_ptr2cells_len;
  	mb_char2cells = utf_char2cells;
  	mb_off2cells = utf_off2cells;
  	mb_ptr2char = utf_ptr2char;
***************
*** 617,625 ****
--- 622,632 ----
      else if (enc_dbcs != 0)
      {
  	mb_ptr2len = dbcs_ptr2len;
+ 	mb_ptr2len_len = dbcs_ptr2len_len;
  	mb_char2len = dbcs_char2len;
  	mb_char2bytes = dbcs_char2bytes;
  	mb_ptr2cells = dbcs_ptr2cells;
+ 	mb_ptr2cells_len = dbcs_ptr2cells_len;
  	mb_char2cells = dbcs_char2cells;
  	mb_off2cells = dbcs_off2cells;
  	mb_ptr2char = dbcs_ptr2char;
***************
*** 628,636 ****
--- 635,645 ----
      else
      {
  	mb_ptr2len = latin_ptr2len;
+ 	mb_ptr2len_len = latin_ptr2len_len;
  	mb_char2len = latin_char2len;
  	mb_char2bytes = latin_char2bytes;
  	mb_ptr2cells = latin_ptr2cells;
+ 	mb_ptr2cells_len = latin_ptr2cells_len;
  	mb_char2cells = latin_char2cells;
  	mb_off2cells = latin_off2cells;
  	mb_ptr2char = latin_ptr2char;
***************
*** 1069,1075 ****
   * Get byte length of character at "*p" but stop at a NUL.
   * For UTF-8 this includes following composing characters.
   * Returns 0 when *p is NUL.
-  *
   */
      int
  latin_ptr2len(p)
--- 1078,1083 ----
***************
*** 1091,1096 ****
--- 1099,1138 ----
      return len;
  }
  
+ /*
+  * mb_ptr2len_len() function pointer.
+  * Like mb_ptr2len(), but limit to read "size" bytes.
+  * Returns 0 for an empty string.
+  * Returns 1 for an illegal char or an incomplete byte sequence.
+  */
+     int
+ latin_ptr2len_len(p, size)
+     char_u	*p;
+     int		size;
+ {
+     if (size < 1 || *p == NUL)
+ 	return 0;
+     return 1;
+ }
+ 
+     static int
+ dbcs_ptr2len_len(p, size)
+     char_u	*p;
+     int		size;
+ {
+     int		len;
+ 
+     if (size < 1 || *p == NUL)
+ 	return 0;
+     if (size == 1)
+ 	return 1;
+     /* Check that second byte is not missing. */
+     len = MB_BYTE2LEN(*p);
+     if (len == 2 && p[1] == NUL)
+ 	len = 1;
+     return len;
+ }
+ 
  struct interval
  {
      unsigned short first;
***************
*** 1287,1292 ****
--- 1329,1383 ----
  }
  
  /*
+  * mb_ptr2cells_len() function pointer.
+  * Like mb_ptr2cells(), but limit string length to "size".
+  * For an empty string or truncated character returns 1.
+  */
+     int
+ latin_ptr2cells_len(p, size)
+     char_u	*p UNUSED;
+     int		size UNUSED;
+ {
+     return 1;
+ }
+ 
+     static int
+ utf_ptr2cells_len(p, size)
+     char_u	*p;
+     int		size;
+ {
+     int		c;
+ 
+     /* Need to convert to a wide character. */
+     if (size > 0 && *p >= 0x80)
+     {
+ 	if (utf_ptr2len_len(p, size) < utf8len_tab[*p])
+ 	    return 1;
+ 	c = utf_ptr2char(p);
+ 	/* An illegal byte is displayed as <xx>. */
+ 	if (utf_ptr2len(p) == 1 || c == NUL)
+ 	    return 4;
+ 	/* If the char is ASCII it must be an overlong sequence. */
+ 	if (c < 0x80)
+ 	    return char2cells(c);
+ 	return utf_char2cells(c);
+     }
+     return 1;
+ }
+ 
+     static int
+ dbcs_ptr2cells_len(p, size)
+     char_u	*p;
+     int		size;
+ {
+     /* Number of cells is equal to number of bytes, except for euc-jp when
+      * the first byte is 0x8e. */
+     if (size <= 1 || (enc_dbcs == DBCS_JPNU && *p == 0x8e))
+ 	return 1;
+     return MB_BYTE2LEN(*p);
+ }
+ 
+ /*
   * mb_char2cells() function pointer.
   * Return the number of display cells character "c" occupies.
   * Only takes care of multi-byte chars, not "^C" and such.
***************
*** 1716,1721 ****
--- 1807,1813 ----
  /*
   * Return the number of bytes the UTF-8 encoding of the character at "p[size]"
   * takes.  This includes following composing characters.
+  * Returns 0 for an empty string.
   * Returns 1 for an illegal char or an incomplete byte sequence.
   */
      int
***************
*** 1728,1734 ****
      int		prevlen;
  #endif
  
!     if (*p == NUL)
  	return 0;
      if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) /* be quick for ASCII */
  	return 1;
--- 1820,1826 ----
      int		prevlen;
  #endif
  
!     if (size < 1 || *p == NUL)
  	return 0;
      if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) /* be quick for ASCII */
  	return 1;
*** ../vim-7.2.199/src/proto/mbyte.pro	2008-07-13 19:34:19.000000000 +0200
--- src/proto/mbyte.pro	2009-06-16 14:58:39.000000000 +0200
***************
*** 7,16 ****
--- 7,18 ----
  int latin_char2len __ARGS((int c));
  int latin_char2bytes __ARGS((int c, char_u *buf));
  int latin_ptr2len __ARGS((char_u *p));
+ int latin_ptr2len_len __ARGS((char_u *p, int size));
  int utf_char2cells __ARGS((int c));
  int latin_ptr2cells __ARGS((char_u *p));
  int utf_ptr2cells __ARGS((char_u *p));
  int dbcs_ptr2cells __ARGS((char_u *p));
+ int latin_ptr2cells_len __ARGS((char_u *p, int size));
  int latin_char2cells __ARGS((int c));
  int latin_off2cells __ARGS((unsigned off, unsigned max_off));
  int dbcs_off2cells __ARGS((unsigned off, unsigned max_off));
***************
*** 85,90 ****
--- 87,93 ----
  int preedit_get_status __ARGS((void));
  int im_is_preediting __ARGS((void));
  int convert_setup __ARGS((vimconv_T *vcp, char_u *from, char_u *to));
+ int convert_setup_ext __ARGS((vimconv_T *vcp, char_u *from, int from_unicode_is_utf8, char_u *to, int to_unicode_is_utf8));
  int convert_input __ARGS((char_u *ptr, int len, int maxlen));
  int convert_input_safe __ARGS((char_u *ptr, int len, int maxlen, char_u **restp, int *restlenp));
  char_u *string_convert __ARGS((vimconv_T *vcp, char_u *ptr, int *lenp));
*** ../vim-7.2.199/src/version.c	2009-06-16 14:31:56.000000000 +0200
--- src/version.c	2009-06-16 14:37:38.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     200,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
12. Sing along at the opera.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
