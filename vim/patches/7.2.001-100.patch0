To: vim-dev@vim.org
Subject: Patch 7.2.001
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.001
Problem:    Mac: pseudo-ttys don't work properly on Leopard, resulting in the
            shell not to have a prompt, CTRL-C not working, etc.
Solution:   Don't use SVR4 compatible ptys, even though they are detected.
            (Ben Schmidt)
Files:      src/pty.c


*** ../vim-7.2.000/src/pty.c	Wed Aug  6 19:04:29 2008
--- src/pty.c	Fri Aug 15 04:00:34 2008
***************
*** 270,278 ****
  }
  #endif
  
! #if defined(HAVE_SVR4_PTYS) && !defined(PTY_DONE) && !defined(hpux)
  
! /* NOTE: Even though HPUX can have /dev/ptmx, the code below doesn't work! */
  #define PTY_DONE
      int
  OpenPTY(ttyn)
--- 270,279 ----
  }
  #endif
  
! #if defined(HAVE_SVR4_PTYS) && !defined(PTY_DONE) && !defined(hpux) && !defined(MACOS_X)
  
! /* NOTE: Even though HPUX can have /dev/ptmx, the code below doesn't work!
!  * Same for Mac OS X Leopard. */
  #define PTY_DONE
      int
  OpenPTY(ttyn)
*** ../vim-7.2.000/src/version.c	Sat Aug  9 19:37:37 2008
--- src/version.c	Sun Aug 17 22:56:25 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     1,
  /**/

-- 
ARTHUR:       Now stand aside worthy adversary.
BLACK KNIGHT: (Glancing at his shoulder) 'Tis but a scratch.
ARTHUR:       A scratch?  Your arm's off.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.002
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.002
Problem:    Leaking memory when displaying menus.
Solution:   Free allocated memory. (Dominique Pelle)
Files:      src/menu.c


*** ../vim-7.2.001/src/menu.c	Wed Jun 25 00:19:17 2008
--- src/menu.c	Sat Aug 16 05:38:45 2008
***************
*** 1120,1125 ****
--- 1120,1126 ----
  	parent = menu;
  	menu = menu->children;
      }
+     vim_free(path_name);
  
      /* Now we have found the matching menu, and we list the mappings */
  						    /* Highlight title */
*** ../vim-7.2.001/src/version.c	Sun Aug 17 23:01:21 2008
--- src/version.c	Sun Aug 17 23:42:53 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     2,
  /**/

-- 
ARTHUR:       You are indeed brave Sir knight, but the fight is mine.
BLACK KNIGHT: Had enough?
ARTHUR:       You stupid bastard.  You havn't got any arms left.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.003
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.003
Problem:    Typo in translated message.  Message not translated.
Solution:   Correct spelling. Add _(). (Dominique Pelle)
Files:      src/spell.c, src/version.c


*** ../vim-7.2.002/src/spell.c	Tue Jun 24 22:21:31 2008
--- src/spell.c	Sun Aug 10 12:51:38 2008
***************
*** 77,83 ****
  
  /*
   * Do the opposite: based on a maximum end score and a known sound score,
!  * compute the the maximum word score that can be used.
   */
  #define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)
  
--- 77,83 ----
  
  /*
   * Do the opposite: based on a maximum end score and a known sound score,
!  * compute the maximum word score that can be used.
   */
  #define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)
  
***************
*** 625,631 ****
  /* TRUE if a word appears in the list of banned words.  */
  #define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&su->su_banned, word)))
  
! /* Number of suggestions kept when cleaning up.  we need to keep more than
   * what is displayed, because when rescore_suggestions() is called the score
   * may change and wrong suggestions may be removed later. */
  #define SUG_CLEAN_COUNT(su)    ((su)->su_maxcount < 130 ? 150 : (su)->su_maxcount + 20)
--- 625,631 ----
  /* TRUE if a word appears in the list of banned words.  */
  #define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&su->su_banned, word)))
  
! /* Number of suggestions kept when cleaning up.  We need to keep more than
   * what is displayed, because when rescore_suggestions() is called the score
   * may change and wrong suggestions may be removed later. */
  #define SUG_CLEAN_COUNT(su)    ((su)->su_maxcount < 130 ? 150 : (su)->su_maxcount + 20)
***************
*** 5980,5986 ****
  	else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)
  	    MSG(_("Too many compound flags"));
  	else
! 	    MSG(_("Too many posponed prefixes and/or compound flags"));
      }
  
      if (syllable != NULL)
--- 5980,5986 ----
  	else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)
  	    MSG(_("Too many compound flags"));
  	else
! 	    MSG(_("Too many postponed prefixes and/or compound flags"));
      }
  
      if (syllable != NULL)
*** ../vim-7.2.002/src/version.c	Sun Aug 17 23:43:53 2008
--- src/version.c	Mon Aug 25 04:06:52 2008
***************
*** 790,796 ****
      MSG_PUTS(_("\nRISC OS version"));
  #endif
  #ifdef VMS
!     MSG_PUTS("\nOpenVMS version");
  # ifdef HAVE_PATHDEF
      if (*compiled_arch != NUL)
      {
--- 792,798 ----
      MSG_PUTS(_("\nRISC OS version"));
  #endif
  #ifdef VMS
!     MSG_PUTS(_("\nOpenVMS version"));
  # ifdef HAVE_PATHDEF
      if (*compiled_arch != NUL)
      {
*** ../vim-7.2.002/src/version.c	Sun Aug 17 23:43:53 2008
--- src/version.c	Mon Aug 25 04:06:52 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     3,
  /**/

-- 
I learned the customs and mannerisms of engineers by observing them, much the
way Jane Goodall learned about the great apes, but without the hassle of
grooming.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.004
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.004
Problem:    Cscope help message is not translated.
Solution:   Put it in _(). (Dominique Pelle)
Files:      src/if_cscope.c, src/if_cscope.h


*** ../vim-7.2.003/src/if_cscope.c	Tue Jun 24 23:52:06 2008
--- src/if_cscope.c	Mon Aug 25 04:34:19 2008
***************
*** 74,80 ****
      { "add",	cs_add,
  		N_("Add a new database"),     "add file|dir [pre-path] [flags]", 0 },
      { "find",	cs_find,
! 		N_("Query for a pattern"),    FIND_USAGE, 1 },
      { "help",	cs_help,
  		N_("Show this message"),      "help", 0 },
      { "kill",	cs_kill,
--- 74,80 ----
      { "add",	cs_add,
  		N_("Add a new database"),     "add file|dir [pre-path] [flags]", 0 },
      { "find",	cs_find,
! 		N_("Query for a pattern"),    "find c|d|e|f|g|i|s|t name", 1 },
      { "help",	cs_help,
  		N_("Show this message"),      "help", 0 },
      { "kill",	cs_kill,
***************
*** 1180,1186 ****
  	(void)smsg((char_u *)_("%-5s: %-30s (Usage: %s)"),
  				      cmdp->name, _(cmdp->help), cmdp->usage);
  	if (strcmp(cmdp->name, "find") == 0)
! 	    MSG_PUTS(FIND_HELP);
  	cmdp++;
      }
  
--- 1180,1195 ----
  	(void)smsg((char_u *)_("%-5s: %-30s (Usage: %s)"),
  				      cmdp->name, _(cmdp->help), cmdp->usage);
  	if (strcmp(cmdp->name, "find") == 0)
! 	    MSG_PUTS(_("\n"
! 		       "       c: Find functions calling this function\n"
! 		       "       d: Find functions called by this function\n"
! 		       "       e: Find this egrep pattern\n"
! 		       "       f: Find this file\n"
! 		       "       g: Find this definition\n"
! 		       "       i: Find files #including this file\n"
! 		       "       s: Find this C symbol\n"
! 		       "       t: Find assignments to\n"));
! 
  	cmdp++;
      }
  
*** ../vim-7.2.003/src/if_cscope.h	Thu Sep  6 17:38:58 2007
--- src/if_cscope.h	Mon Aug 25 04:34:17 2008
***************
*** 42,58 ****
   * f 7name	Find this file
   * i 8name	Find files #including this file
   */
- #define	FIND_USAGE "find c|d|e|f|g|i|s|t name"
- #define FIND_HELP "\n\
-        c: Find functions calling this function\n\
-        d: Find functions called by this function\n\
-        e: Find this egrep pattern\n\
-        f: Find this file\n\
-        g: Find this definition\n\
-        i: Find files #including this file\n\
-        s: Find this C symbol\n\
-        t: Find assignments to\n"
- 
  
  typedef struct {
      char *  name;
--- 42,47 ----
*** ../vim-7.2.003/src/version.c	Mon Aug 25 04:12:38 2008
--- src/version.c	Mon Aug 25 04:29:53 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     4,
  /**/

-- 
If someone questions your market projections, simply point out that your
target market is "People who are nuts" and "People who will buy any damn
thing".  Nobody is going to tell you there aren't enough of those people
to go around.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.005
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.005
Problem:    A few problems when profiling.  Using flag pointer instead of flag
            value.  Allocating zero bytes.  Not freeing used memory.
Solution:   Remove wrong '&' characters.  Skip dumping when there is nothing
            to dump.  Free used memory. (Dominique Pelle)
Files:      src/eval.c


*** ../vim-7.2.004/src/eval.c	Fri Aug  8 12:36:31 2008
--- src/eval.c	Mon Aug 25 04:40:11 2008
***************
*** 3657,3664 ****
  }
  
  /*
!  * Return TRUE if typeval "tv" is locked: Either tha value is locked itself or
!  * it refers to a List or Dictionary that is locked.
   */
      static int
  tv_islocked(tv)
--- 3657,3664 ----
  }
  
  /*
!  * Return TRUE if typeval "tv" is locked: Either that value is locked itself
!  * or it refers to a List or Dictionary that is locked.
   */
      static int
  tv_islocked(tv)
***************
*** 15838,15847 ****
      if (res == FAIL)
  	res = ITEM_COMPARE_FAIL;
      else
- 	/* return value has wrong type */
  	res = get_tv_number_chk(&rettv, &item_compare_func_err);
      if (item_compare_func_err)
! 	res = ITEM_COMPARE_FAIL;
      clear_tv(&rettv);
      return res;
  }
--- 15838,15846 ----
      if (res == FAIL)
  	res = ITEM_COMPARE_FAIL;
      else
  	res = get_tv_number_chk(&rettv, &item_compare_func_err);
      if (item_compare_func_err)
! 	res = ITEM_COMPARE_FAIL;  /* return value has wrong type */
      clear_tv(&rettv);
      return res;
  }
***************
*** 20590,20595 ****
--- 20589,20597 ----
      int		st_len = 0;
  
      todo = (int)func_hashtab.ht_used;
+     if (todo == 0)
+ 	return;     /* nothing to dump */
+ 
      sorttab = (ufunc_T **)alloc((unsigned)(sizeof(ufunc_T) * todo));
  
      for (hi = func_hashtab.ht_array; todo > 0; ++hi)
***************
*** 20638,20643 ****
--- 20640,20647 ----
  							      prof_self_cmp);
  	prof_sort_list(fd, sorttab, st_len, "SELF", TRUE);
      }
+ 
+     vim_free(sorttab);
  }
  
      static void
***************
*** 21204,21210 ****
  	if (!fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL))
  	    func_do_profile(fp);
  	if (fp->uf_profiling
! 		       || (fc.caller != NULL && &fc.caller->func->uf_profiling))
  	{
  	    ++fp->uf_tm_count;
  	    profile_start(&call_start);
--- 21208,21214 ----
  	if (!fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL))
  	    func_do_profile(fp);
  	if (fp->uf_profiling
! 		       || (fc.caller != NULL && fc.caller->func->uf_profiling))
  	{
  	    ++fp->uf_tm_count;
  	    profile_start(&call_start);
***************
*** 21235,21247 ****
  
  #ifdef FEAT_PROFILE
      if (do_profiling == PROF_YES && (fp->uf_profiling
! 		    || (fc.caller != NULL && &fc.caller->func->uf_profiling)))
      {
  	profile_end(&call_start);
  	profile_sub_wait(&wait_start, &call_start);
  	profile_add(&fp->uf_tm_total, &call_start);
  	profile_self(&fp->uf_tm_self, &call_start, &fp->uf_tm_children);
! 	if (fc.caller != NULL && &fc.caller->func->uf_profiling)
  	{
  	    profile_add(&fc.caller->func->uf_tm_children, &call_start);
  	    profile_add(&fc.caller->func->uf_tml_children, &call_start);
--- 21239,21251 ----
  
  #ifdef FEAT_PROFILE
      if (do_profiling == PROF_YES && (fp->uf_profiling
! 		    || (fc.caller != NULL && fc.caller->func->uf_profiling)))
      {
  	profile_end(&call_start);
  	profile_sub_wait(&wait_start, &call_start);
  	profile_add(&fp->uf_tm_total, &call_start);
  	profile_self(&fp->uf_tm_self, &call_start, &fp->uf_tm_children);
! 	if (fc.caller != NULL && fc.caller->func->uf_profiling)
  	{
  	    profile_add(&fc.caller->func->uf_tm_children, &call_start);
  	    profile_add(&fc.caller->func->uf_tml_children, &call_start);
*** ../vim-7.2.004/src/version.c	Mon Aug 25 04:35:13 2008
--- src/version.c	Mon Aug 25 04:46:44 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     5,
  /**/

-- 
The process for understanding customers primarily involves sitting around with
other marketing people and talking about what you would to if you were dumb
enough to be a customer.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.006
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.006
Problem:    HTML files are not recognized by contents.
Solution:   Add a rule to the scripts file. (Nico Weber)
Files:      runtime/scripts.vim


*** ../vim-7.2.005/runtime/scripts.vim	Sat Aug  9 19:37:09 2008
--- runtime/scripts.vim	Sat Aug 16 04:05:34 2008
***************
*** 234,239 ****
--- 234,243 ----
    elseif s:line1 =~ '\<DTD\s\+XHTML\s'
      set ft=xhtml
  
+     " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
+   elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
+     set ft=html
+ 
      " PDF
    elseif s:line1 =~ '^%PDF-'
      set ft=pdf
*** ../vim-7.2.005/src/version.c	Mon Aug 25 04:48:21 2008
--- src/version.c	Mon Aug 25 05:02:34 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     6,
  /**/

-- 
Never enter the boss's office unless it's absolutely necessary.  Every boss
saves one corner of the desk for useless assignments that are doled out like
Halloween candy to each visitor.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.007 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.007 (extra)
Problem:    Minor issues for VMS.
Solution:   Minor fixes for VMS.  Add float support. (Zoltan Arpadffy)
Files:	    runtime/doc/os_vms.txt, src/os_vms_conf.h, src/Make_vms.mms,
	    src/testdir/Make_vms.mms, src/testdir/test30.in,
	    src/testdir/test54.in


*** ../vim-7.2.006/runtime/doc/os_vms.txt	Sat Aug  9 19:36:50 2008
--- runtime/doc/os_vms.txt	Tue Aug 19 06:29:31 2008
***************
*** 1,4 ****
! *os_vms.txt*    For Vim version 7.2.  Last change: 2006 Nov 18
  
  
  		  VIM REFERENCE MANUAL
--- 1,4 ----
! *os_vms.txt*    For Vim version 7.2.  Last change: 2008 Aug 19
  
  
  		  VIM REFERENCE MANUAL
***************
*** 312,318 ****
  
  8. Useful notes						*vms-notes*
  
! 8.1 backspace/delete
  8.2 Filters
  8.3 VMS file version numbers
  8.4 Directory conversion
--- 312,318 ----
  
  8. Useful notes						*vms-notes*
  
! 8.1 Backspace/delete
  8.2 Filters
  8.3 VMS file version numbers
  8.4 Directory conversion
***************
*** 326,333 ****
  8.12 diff-mode
  8.13 Allow '$' in C keywords
  8.14 VIMTUTOR for beginners
  
! 8.1 backspace/delete
  
  There are backspace/delete key inconsistencies with VMS.
  :fixdel doesn't do the trick, but the solution is: >
--- 326,335 ----
  8.12 diff-mode
  8.13 Allow '$' in C keywords
  8.14 VIMTUTOR for beginners
+ 8.15 Slow start in console mode issue 
+ 8.16 Common VIM directory - different architectures 
  
! 8.1 Backspace/delete
  
  There are backspace/delete key inconsistencies with VMS.
  :fixdel doesn't do the trick, but the solution is: >
***************
*** 663,674 ****
  
  (Thomas.R.Wyant III, Vim 6.1)
  
  ==============================================================================
  
  9. VMS related changes					*vms-changes*
  
! Version 7
  - Improved low level char input (affects just console mode)
  
  Version 6.4 (2005 Oct 15)
  - GTKLIB and Vim build on IA64
--- 665,794 ----
  
  (Thomas.R.Wyant III, Vim 6.1)
  
+ 8.14 Slow start in console mode issue
+ 
+ As GUI/GTK Vim works equally well in console mode, many administartors
+ deploy those executables system wide.
+ Unfortunately, on a remote slow connections GUI/GTK executables behave rather
+ slow when user wants to run Vim just in the console mode - because of X environment detection timeout.
+ 
+ Luckily, there is a simple solution for that. Administrators need to deploy
+ both GUI/GTK build and just console build executables, like below: >
+ 
+     |- vim72
+     |----- doc
+     |----- syntax        
+        vimrc    (system rc files)
+        gvimrc
+        gvim.exe (the remaned GUI or GTK built vim.exe)      
+        vim.exe  (the console only executable) 
+ 
+ Define system symbols like below in for ex in LOGIN.COM or SYLOGIN.COM: >
+ 
+ 	$ define/nolog VIM RF10:[UTIL.VIM72] ! where you VIM directory is
+ 	$ vi*m  :== mcr VIM:VIM.EXE
+ 	$ gvi*m :== mcr VIM:GVIM.EXE
+ 	$ ! or you can try to spawn with
+ 	$ gv*im :== spawn/nowait/input=NLA0 mcr VIM:GVIM.EXE -g -GEOMETRY 80x40
+ 
+ 
+ Like this, users that do not have X environment and want to use Vim just in 
+ console mode can avoid performance problems.
+ 
+ (Zoltan Arpadffy, Vim 7.2)
+ 
+ 8.15 Common VIM directory - different architectures
+ 
+ In a cluster that contains nodes with different architectures like below:
+ 
+ $show cluster
+ View of Cluster from system ID 11655  node: TOR                                                                     18-AUG-2008 11:58:31
+ +---------------------------------+
+ ¦        SYSTEMS        ¦ MEMBERS ¦
+ +-----------------------+---------¦
+ ¦  NODE  ¦   SOFTWARE   ¦  STATUS ¦
+ +--------+--------------+---------¦
+ ¦ TOR    ¦ VMS V7.3-2   ¦ MEMBER  ¦
+ ¦ TITAN2 ¦ VMS V8.3     ¦ MEMBER  ¦
+ ¦ ODIN   ¦ VMS V7.3-2   ¦ MEMBER  ¦
+ +---------------------------------+
+ 
+ It is convinient to have a common VIM directory but execute different
+ executables. 
+ There are more solutions for this problem:
+ 
+ solution 1. all executables in the same directory with different names
+ This is easily done with the following script that can be added
+ to the login.com or sylogin.com: >
+ 
+ 	$ if f$getsyi("NODE_HWTYPE") .eqs. "VAX"
+ 	$ then
+ 	$       say "VAX platform"
+ 	$       vi*m:== mcr vim:VIM.EXE_VAX
+ 	$ endif
+ 	$ if f$getsyi("NODE_HWTYPE") .eqs. "ALPH"
+ 	$ then
+ 	$       say "ALPHA platform"
+ 	$       vi*m :== mcr vim:VIM.EXE_AXP
+ 	$ endif
+ 	$ if f$getsyi("ARCH_NAME") .eqs. "IA64"
+ 	$ then
+ 	$      say "IA64 platform"
+ 	$      vi*m :== mcr vim:VIM.EXE_IA64
+ 	$ endif
+ 
+ solution 2. different directories: >
+ 
+ 	$ if f$getsyi("NODE_HWTYPE") .eqs. "VAX"
+ 	$ then
+ 	$       say "VAX platform"
+ 	$       define/nolog VIM RF10:[UTIL.VAX_EXE] ! VAX executables
+ 	$ endif
+ 	$ if f$getsyi("NODE_HWTYPE") .eqs. "ALPH"
+ 	$ then
+ 	$       say "ALPHA platform"
+ 	$       define/nolog VIM RF10:[UTIL.AXP_EXE] ! AXP executables
+ 	$ endif
+ 	$ if f$getsyi("ARCH_NAME") .eqs. "IA64"
+ 	$ then
+ 	$      say "IA64 platform"
+ 	$      define/nolog VIM RF10:[UTIL.IA64_EXE] ! IA64 executables
+ 	$ endif
+         $! VIMRUNTIME must be defined in order to find runtime files
+ 	$ define/nolog VIMRUNTIME RF10:[UTIL.VIM72]
+ 
+ A good examle for this approach is the [GNU]gnu_tools.com script from GNU_TOOLS.ZIP
+ package downloadable from http://www.polarhome.com/vim/
+ 
+ (Zoltan Arpadffy, Vim 7.2)
+ 
  ==============================================================================
  
  9. VMS related changes					*vms-changes*
  
! Recent changes
! - The following plugins are included into VMS runtime: 
!   genutils 2.4, multiselect 2.2, multvals 3.1, selectbuf 4.3,
!   bufexplorer 7.1.7, taglist 4.5
! - minor changes in vimrc (just in VMS runtime) 
! - make_vms.mms - HUGE model is the default
! - [TESTDIR]make_vms.mms include as many tests possible
! - modify test30 and test54 for VMS
! - enable FLOAT feature in VMS port
! - os_vms.txt updated  
! 
! Version 7.2 (2008 Aug 9)
! - VCF files write corrected
! - CTAGS 5.7 included
! - corrected make_vms.mms (on VAX gave syntax error) 
! 
! Version 7.1 (2007 Jun 15)
! - create TAGS file from menu 
! 
! Version 7 (2006 May 8)
  - Improved low level char input (affects just console mode)
+ - Fixed plugin bug
+ - CTAGS 5.6 included
  
  Version 6.4 (2005 Oct 15)
  - GTKLIB and Vim build on IA64
***************
*** 806,811 ****
--- 926,932 ----
  
  OpenVMS documentation and executables are maintained by:
  Zoltan Arpadffy <arpadffy@polarhome.com>
+ OpenVMS Vim page: http://www.polarhome.com/vim/
  
  This document uses parts and remarks from earlier authors and contributors
  of OS_VMS.TXT:
*** ../vim-7.2.006/src/os_vms_conf.h	Thu May 10 19:26:17 2007
--- src/os_vms_conf.h	Sat Aug 16 05:09:17 2008
***************
*** 114,119 ****
--- 114,121 ----
  #define HAVE_PUTENV
  #define HAVE_SETENV
  #define HAVE_SETJMP_H
+ #define HAVE_MATH_H
+ #define HAVE_FLOAT_FUNCS
  
  #undef	HAVE_DIRENT_H
  #undef	HAVE_SYS_NDIR_H
*** ../vim-7.2.006/src/Make_vms.mms	Mon Oct 29 22:38:54 2007
--- src/Make_vms.mms	Sat Aug 16 05:17:41 2008
***************
*** 2,8 ****
  # Makefile for Vim on OpenVMS
  #
  # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
! # Last change:  2007 Oct 22
  #
  # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
  # with MMS and MMK
--- 2,8 ----
  # Makefile for Vim on OpenVMS
  #
  # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
! # Last change:  2008 Aug 16
  #
  # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
  # with MMS and MMK
***************
*** 36,42 ****
  # BIG    - Many features enabled, as rich as possible. (default)
  # HUGE   - All possible featues enabled.
  # Please select one of these alternatives above.
! MODEL = BIG
  
  # GUI or terminal mode executable.
  # Comment out if you want just the character terminal mode only.
--- 36,42 ----
  # BIG    - Many features enabled, as rich as possible. (default)
  # HUGE   - All possible featues enabled.
  # Please select one of these alternatives above.
! MODEL = HUGE
  
  # GUI or terminal mode executable.
  # Comment out if you want just the character terminal mode only.
*** ../vim-7.2.006/src/testdir/Make_vms.mms	Wed Jun 25 00:34:23 2008
--- src/testdir/Make_vms.mms	Tue Aug 19 06:28:07 2008
***************
*** 4,12 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2008 Jun 19
  #
! # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
  #
  # Execute with:
--- 4,12 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2008 Aug 19
  #
! # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
  #
  # Execute with:
***************
*** 32,37 ****
--- 32,46 ----
  # and directory handling.
  # WANT_UNIX = YES
  
+ # Comment out if you want to run Win32 specific tests as well, but please
+ # be aware, that on OpenVMS will fail, because of cat, rm, etc commands
+ # and directory handling.
+ # WANT_WIN = YES
+ 
+ # Comment out if you want to run spell checker tests. 
+ # They fail because VMS does not support file names.
+ # WANT_SPELL = YES
+ 
  # Comment out if you have gzip on your system
  # HAVE_GZIP = YES
  
***************
*** 53,64 ****
  	 test13.out test14.out test15.out test17.out \
  	 test18.out test19.out test20.out test21.out test22.out \
  	 test23.out test24.out test26.out \
! 	 test28.out test29.out test31.out test32.out \
  	 test33.out test34.out test35.out test36.out test37.out \
  	 test38.out test39.out test40.out test41.out test42.out \
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
! 	 test56.out test57.out test58.out test59.out test60.out \
  	 test61.out test62.out test63.out test64.out test65.out
  
  .IFDEF WANT_GUI
--- 62,73 ----
  	 test13.out test14.out test15.out test17.out \
  	 test18.out test19.out test20.out test21.out test22.out \
  	 test23.out test24.out test26.out \
! 	 test28.out test29.out test30.out test31.out test32.out \
  	 test33.out test34.out test35.out test36.out test37.out \
  	 test38.out test39.out test40.out test41.out test42.out \
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
! 	 test56.out test57.out test60.out \
  	 test61.out test62.out test63.out test64.out test65.out
  
  .IFDEF WANT_GUI
***************
*** 67,73 ****
  .ENDIF
  
  .IFDEF WANT_UNIX
! SCRIPT_UNIX = test10.out test12.out test25.out test27.out test30.out test49.out
  .ENDIF
  
  .IFDEF HAVE_GZIP
--- 76,90 ----
  .ENDIF
  
  .IFDEF WANT_UNIX
! SCRIPT_UNIX = test10.out test12.out test25.out test27.out test49.out
! .ENDIF
! 
! .IFDEF WANT_WIN
! SCRIPT_WIN = test50.out test52.out
! .ENDIF
! 
! .IFDEF WANT_SPELL
! SCRIPT_SPELL = test58.out test59.out 
  .ENDIF
  
  .IFDEF HAVE_GZIP
***************
*** 84,94 ****
  	-@ write sys$output "                "$*" "
  	-@ write sys$output "-----------------------------------------------"
  	-@ create/term/wait mcr $(VIMPROG) $(GUI_OPTION) -u vms.vim --noplugin -s dotest.in $*.in
! 	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then differences test.out $*.ok;
  	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then rename test.out $*.out
  	-@ if "''F$SEARCH("Xdotest.*")'"  .NES. "" then delete/noconfirm/nolog Xdotest.*.*
  
! all : clean nolog $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_GZIP) $(SCRIPT_GDIFF)
  	-@ write sys$output " "
  	-@ write sys$output "-----------------------------------------------"
  	-@ write sys$output "                All done"
--- 101,111 ----
  	-@ write sys$output "                "$*" "
  	-@ write sys$output "-----------------------------------------------"
  	-@ create/term/wait mcr $(VIMPROG) $(GUI_OPTION) -u vms.vim --noplugin -s dotest.in $*.in
! 	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then differences /par test.out $*.ok;
  	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then rename test.out $*.out
  	-@ if "''F$SEARCH("Xdotest.*")'"  .NES. "" then delete/noconfirm/nolog Xdotest.*.*
  
! all : clean nolog $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_WIN) $(SCRIPT_SPELL) $(SCRIPT_GZIP) $(SCRIPT_GDIFF) 
  	-@ write sys$output " "
  	-@ write sys$output "-----------------------------------------------"
  	-@ write sys$output "                All done"
***************
*** 113,118 ****
--- 130,137 ----
  	-@ write sys$output "MAKE_VMS.MMS options:"
  	-@ write sys$output "   WANT_GUI  = ""$(WANT_GUI)"" "
  	-@ write sys$output "   WANT_UNIX = ""$(WANT_UNIX)"" "
+ 	-@ write sys$output "   WANT_WIN  = ""$(WANT_WIN)"" "
+ 	-@ write sys$output "   WANT_SPELL= ""$(WANT_SPELL)"" "
  	-@ write sys$output "   HAVE_GZIP = ""$(HAVE_GZIP)"" "
  	-@ write sys$output "   HAVE_GDIFF= ""$(HAVE_GDIFF)"" "
  	-@ write sys$output "Default vimrc file is VMS.VIM:
***************
*** 122,126 ****
--- 141,153 ----
  clean :
  	-@ if "''F$SEARCH("*.out")'"     .NES. "" then delete/noconfirm/nolog *.out.*
  	-@ if "''F$SEARCH("test.log")'"  .NES. "" then delete/noconfirm/nolog test.log.*
+ 	-@ if "''F$SEARCH("test.ok")'"   .NES. "" then delete/noconfirm/nolog test.ok.*
  	-@ if "''F$SEARCH("Xdotest.*")'" .NES. "" then delete/noconfirm/nolog Xdotest.*.*
  	-@ if "''F$SEARCH("*.*_sw*")'"   .NES. "" then delete/noconfirm/nolog *.*_sw*.*
+ 	-@ if "''F$SEARCH("*.failed")'"  .NES. "" then delete/noconfirm/nolog *.failed.*
+ 	-@ if "''F$SEARCH("*.rej")'"     .NES. "" then delete/noconfirm/nolog *.rej.*
+ 	-@ if "''F$SEARCH("tiny.vim")'"  .NES. "" then delete/noconfirm/nolog tiny.vim.*
+ 	-@ if "''F$SEARCH("small.vim")'" .NES. "" then delete/noconfirm/nolog small.vim.*
+ 	-@ if "''F$SEARCH("mbyte.vim")'" .NES. "" then delete/noconfirm/nolog mbyte.vim.*
+ 	-@ if "''F$SEARCH("viminfo.*")'" .NES. "" then delete/noconfirm/nolog viminfo.*.*
+ 
*** ../vim-7.2.006/src/testdir/test30.in	Sun Jul 13 19:17:14 2008
--- src/testdir/test30.in	Sat Aug 16 04:59:37 2008
***************
*** 24,33 ****
  :set nobin eol
  :bwipe XXUnix XXDos XXMac
  :" create mixed format files
! :!cat XXUnix XXDos >XXUxDs
! :!cat XXUnix XXMac >XXUxMac
! :!cat XXDos XXMac >XXDosMac
! :!cat XXUnix XXDos XXMac >XXUxDsMc
  :"
  :" try reading and writing with 'fileformats' empty
  :set fileformat=unix
--- 24,40 ----
  :set nobin eol
  :bwipe XXUnix XXDos XXMac
  :" create mixed format files
! :if has("vms")
! : !copy XXUnix,XXDos XXUxDs.
! : !copy XXUnix,XXMac XXUxMac.
! : !copy XXDos,XXMac  XXDosMac.
! : !copy XXUnix,XXDos,XXMac XXUxDsMc.
! :else
! : !cat XXUnix XXDos >XXUxDs
! : !cat XXUnix XXMac >XXUxMac
! : !cat XXDos XXMac >XXDosMac
! : !cat XXUnix XXDos XXMac >XXUxDsMc
! :endif
  :"
  :" try reading and writing with 'fileformats' empty
  :set fileformat=unix
*** ../vim-7.2.006/src/testdir/test54.in	Sun Jan  2 12:43:19 2005
--- src/testdir/test54.in	Tue Aug 19 06:26:55 2008
***************
*** 3,10 ****
  STARTTEST
  :so small.vim
  :e xx
! :!rm -f test.out
! :au BufLeave <buffer> :!echo buffer-local autommand in %>> test.out
  :e somefile           " here, autocommand for xx shall write test.out 
  :                     " but autocommand shall not apply to buffer named <buffer>
  :bwipe xx             " here, autocommand shall be auto-deleted
--- 3,15 ----
  STARTTEST
  :so small.vim
  :e xx
! :if has("vms")
! : !del test.out.*
! : au BufLeave <buffer> :!write sys$output "buffer-local autommand in %" > test.out
! :else
! : !rm -f test.out
! : au BufLeave <buffer> :!echo buffer-local autommand in %>> test.out
! :endif
  :e somefile           " here, autocommand for xx shall write test.out 
  :                     " but autocommand shall not apply to buffer named <buffer>
  :bwipe xx             " here, autocommand shall be auto-deleted
*** ../vim-7.2.006/src/version.c	Mon Aug 25 05:03:29 2008
--- src/version.c	Mon Sep  1 16:46:50 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     7,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
8. Don't use any punctuation marks.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.008
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.008
Problem:    With a BufHidden autocommand that invokes ":bunload" the window
	    count for a buffer can be wrong. (Bob Hiestand)
Solution:   Don't call enter_buffer() when already in that buffer.
Files:	    src/buffer.c


*** ../vim-7.2.007/src/buffer.c	Wed Aug  6 18:32:40 2008
--- src/buffer.c	Mon Sep  1 14:25:45 2008
***************
*** 1351,1361 ****
  	}
      }
  #ifdef FEAT_AUTOCMD
  # ifdef FEAT_EVAL
!     /* An autocommand may have deleted buf or aborted the script processing! */
!     if (buf_valid(buf) && !aborting())
  # else
!     if (buf_valid(buf))	    /* an autocommand may have deleted buf! */
  # endif
  #endif
  	enter_buffer(buf);
--- 1351,1362 ----
  	}
      }
  #ifdef FEAT_AUTOCMD
+     /* An autocommand may have deleted "buf", already entered it (e.g., when
+      * it did ":bunload") or aborted the script processing! */
  # ifdef FEAT_EVAL
!     if (buf_valid(buf) && buf != curbuf && !aborting())
  # else
!     if (buf_valid(buf) && buf != curbuf)
  # endif
  #endif
  	enter_buffer(buf);
*** ../vim-7.2.007/src/version.c	Mon Sep  1 16:50:09 2008
--- src/version.c	Mon Sep  1 17:31:28 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     8,
  /**/

-- 
If Pacman had affected us as kids we'd be running around in dark rooms,
munching pills and listening to repetitive music.
                       -- Marcus Brigstocke

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.009
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.009
Problem:    Can't compile with Perl 5.10 on MS-Windows. (Cesar Romani)
Solution:   Add the Perl_sv_free2 function for dynamic loading. (Dan Sharp)
Files:	    src/if_perl.xs


*** ../vim-7.2.008/src/if_perl.xs	Thu Jul 24 16:24:15 2008
--- src/if_perl.xs	Mon Sep  1 14:58:37 2008
***************
*** 136,141 ****
--- 136,144 ----
  #  define Perl_newXS_flags dll_Perl_newXS_flags
  #endif
  # define Perl_sv_free dll_Perl_sv_free
+ # if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
+ #  define Perl_sv_free2 dll_Perl_sv_free2
+ # endif
  # define Perl_sv_isa dll_Perl_sv_isa
  # define Perl_sv_magic dll_Perl_sv_magic
  # define Perl_sv_setiv dll_Perl_sv_setiv
***************
*** 268,273 ****
--- 271,277 ----
  static void (*boot_DynaLoader)_((pTHX_ CV*));
  
  #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
+ static void (*Perl_sv_free2)(pTHX_ SV*);
  static void (*Perl_sys_init3)(int* argc, char*** argv, char*** env);
  static void (*Perl_sys_term)(void);
  static SV** (*Perl_ISv_ptr)(register PerlInterpreter*);
***************
*** 367,372 ****
--- 371,377 ----
      {"Perl_TXpv_ptr", (PERL_PROC*)&Perl_TXpv_ptr},
      {"Perl_Tna_ptr", (PERL_PROC*)&Perl_Tna_ptr},
  #else
+     {"Perl_sv_free2", (PERL_PROC*)&Perl_sv_free2},
      {"Perl_sys_init3", (PERL_PROC*)&Perl_sys_init3},
      {"Perl_sys_term", (PERL_PROC*)&Perl_sys_term},
      {"Perl_ISv_ptr", (PERL_PROC*)&Perl_ISv_ptr},
*** ../vim-7.2.008/src/version.c	Mon Sep  1 17:32:40 2008
--- src/version.c	Mon Sep  1 17:55:24 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     9,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
11. Specify that your drive-through order is "to go".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.010
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.010
Problem:    When using "K" in Visual mode not all characters are properly
	    escaped. (Ben Schmidt)
Solution:   Use a function with the functionality of shellescape(). (Jan
	    Minar)
Files:	    src/mbyte.c, src/misc2.c, src/normal.c


*** ../vim-7.2.009/src/mbyte.c	Wed Aug  6 18:45:36 2008
--- src/mbyte.c	Wed Sep  3 22:34:48 2008
***************
*** 2540,2546 ****
      return (int)(p - q);
  }
  
- #if defined(FEAT_EVAL) || defined(PROTO)
  /*
   * Copy a character from "*fp" to "*tp" and advance the pointers.
   */
--- 2540,2545 ----
***************
*** 2555,2561 ****
      *tp += l;
      *fp += l;
  }
- #endif
  
  /*
   * Return the offset from "p" to the first byte of a character.  When "p" is
--- 2554,2559 ----
*** ../vim-7.2.009/src/misc2.c	Thu Jul 24 20:28:58 2008
--- src/misc2.c	Wed Sep  3 22:05:21 2008
***************
*** 1257,1263 ****
      return escaped_string;
  }
  
- #if !defined(BACKSLASH_IN_FILENAME) || defined(FEAT_EVAL) || defined(PROTO)
  /*
   * Return TRUE when 'shell' has "csh" in the tail.
   */
--- 1257,1262 ----
***************
*** 1266,1274 ****
  {
      return (strstr((char *)gettail(p_sh), "csh") != NULL);
  }
- #endif
  
- #if defined(FEAT_EVAL) || defined(PROTO)
  /*
   * Escape "string" for use as a shell argument with system().
   * This uses single quotes, except when we know we need to use double qoutes
--- 1265,1271 ----
***************
*** 1391,1397 ****
  
      return escaped_string;
  }
- #endif
  
  /*
   * Like vim_strsave(), but make all characters uppercase.
--- 1388,1393 ----
*** ../vim-7.2.009/src/normal.c	Thu Jul 31 22:03:54 2008
--- src/normal.c	Sat Sep  6 15:06:07 2008
***************
*** 5469,5474 ****
--- 5469,5479 ----
  		STRCPY(buf, "he! ");
  	    else
  	    {
+ 		/* An external command will probably use an argument starting
+ 		 * with "-" as an option.  To avoid trouble we skip the "-". */
+ 		while (*ptr == '-')
+ 		    ++ptr;
+ 
  		/* When a count is given, turn it into a range.  Is this
  		 * really what we want? */
  		isman = (STRCMP(kp, "man") == 0);
***************
*** 5511,5547 ****
      /*
       * Now grab the chars in the identifier
       */
!     if (cmdchar == '*')
! 	aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
!     else if (cmdchar == '#')
! 	aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
!     else if (cmdchar == 'K' && !kp_help)
! 	aux_ptr = (char_u *)" \t\\\"|!";
!     else
! 	/* Don't escape spaces and Tabs in a tag with a backslash */
! 	aux_ptr = (char_u *)"\\|\"";
! 
!     p = buf + STRLEN(buf);
!     while (n-- > 0)
!     {
! 	/* put a backslash before \ and some others */
! 	if (vim_strchr(aux_ptr, *ptr) != NULL)
! 	    *p++ = '\\';
! #ifdef FEAT_MBYTE
! 	/* When current byte is a part of multibyte character, copy all bytes
! 	 * of that character. */
! 	if (has_mbyte)
  	{
! 	    int i;
! 	    int len = (*mb_ptr2len)(ptr) - 1;
! 
! 	    for (i = 0; i < len && n >= 1; ++i, --n)
! 		*p++ = *ptr++;
  	}
  #endif
! 	*p++ = *ptr++;
      }
-     *p = NUL;
  
      /*
       * Execute the command.
--- 5516,5572 ----
      /*
       * Now grab the chars in the identifier
       */
!     if (cmdchar == 'K' && !kp_help)
!     {
! 	/* Escape the argument properly for a shell command */
! 	p = vim_strsave_shellescape(ptr, TRUE);
! 	if (p == NULL)
  	{
! 	    vim_free(buf);
! 	    return;
  	}
+ 	buf = (char_u *)vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);
+ 	if (buf == NULL)
+ 	{
+ 	    vim_free(buf);
+ 	    vim_free(p);
+ 	    return;
+ 	}
+ 	STRCAT(buf, p);
+ 	vim_free(p);
+     }
+     else
+     {
+ 	if (cmdchar == '*')
+ 	    aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
+ 	else if (cmdchar == '#')
+ 	    aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
+ 	else
+ 	    /* Don't escape spaces and Tabs in a tag with a backslash */
+ 	    aux_ptr = (char_u *)"\\|\"\n*?[";
+ 
+ 	p = buf + STRLEN(buf);
+ 	while (n-- > 0)
+ 	{
+ 	    /* put a backslash before \ and some others */
+ 	    if (vim_strchr(aux_ptr, *ptr) != NULL)
+ 		*p++ = '\\';
+ #ifdef FEAT_MBYTE
+ 	    /* When current byte is a part of multibyte character, copy all
+ 	     * bytes of that character. */
+ 	    if (has_mbyte)
+ 	    {
+ 		int i;
+ 		int len = (*mb_ptr2len)(ptr) - 1;
+ 
+ 		for (i = 0; i < len && n >= 1; ++i, --n)
+ 		    *p++ = *ptr++;
+ 	    }
  #endif
! 	    *p++ = *ptr++;
! 	}
! 	*p = NUL;
      }
  
      /*
       * Execute the command.
*** ../vim-7.2.009/src/version.c	Mon Sep  1 17:56:05 2008
--- src/version.c	Sat Sep  6 16:26:42 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     10,
  /**/

-- 
Q. What happens to programmers when they die?
A: MS-Windows programmers are reinstalled.  C++ programmers become undefined,
   anyone who refers to them will die as well.  Java programmers reincarnate
   after being garbage collected.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.011
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.011
Problem:    Get an error when inserting a float value from the expression
	    register.
Solution:   Convert the Float to a String automatically in the same place
	    where a List would be converted to a String.
Files:	    src/eval.c


*** ../vim-7.2.010/src/eval.c	Mon Aug 25 04:48:21 2008
--- src/eval.c	Sun Sep  7 13:50:38 2008
***************
*** 1256,1278 ****
  
  /*
   * Top level evaluation function, returning a string.
   * Return pointer to allocated memory, or NULL for failure.
   */
      char_u *
! eval_to_string(arg, nextcmd, dolist)
      char_u	*arg;
      char_u	**nextcmd;
!     int		dolist;		/* turn List into sequence of lines */
  {
      typval_T	tv;
      char_u	*retval;
      garray_T	ga;
  
      if (eval0(arg, &tv, nextcmd, TRUE) == FAIL)
  	retval = NULL;
      else
      {
! 	if (dolist && tv.v_type == VAR_LIST)
  	{
  	    ga_init2(&ga, (int)sizeof(char), 80);
  	    if (tv.vval.v_list != NULL)
--- 1256,1281 ----
  
  /*
   * Top level evaluation function, returning a string.
+  * When "convert" is TRUE convert a List into a sequence of lines and convert
+  * a Float to a String.
   * Return pointer to allocated memory, or NULL for failure.
   */
      char_u *
! eval_to_string(arg, nextcmd, convert)
      char_u	*arg;
      char_u	**nextcmd;
!     int		convert;
  {
      typval_T	tv;
      char_u	*retval;
      garray_T	ga;
+     char_u	numbuf[NUMBUFLEN];
  
      if (eval0(arg, &tv, nextcmd, TRUE) == FAIL)
  	retval = NULL;
      else
      {
! 	if (convert && tv.v_type == VAR_LIST)
  	{
  	    ga_init2(&ga, (int)sizeof(char), 80);
  	    if (tv.vval.v_list != NULL)
***************
*** 1280,1285 ****
--- 1283,1295 ----
  	    ga_append(&ga, NUL);
  	    retval = (char_u *)ga.ga_data;
  	}
+ #ifdef FEAT_FLOAT
+ 	else if (convert && tv.v_type == VAR_FLOAT)
+ 	{
+ 	    vim_snprintf((char *)numbuf, NUMBUFLEN, "%g", tv.vval.v_float);
+ 	    retval = vim_strsave(numbuf);
+ 	}
+ #endif
  	else
  	    retval = vim_strsave(get_tv_string(&tv));
  	clear_tv(&tv);
*** ../vim-7.2.010/src/version.c	Sat Sep  6 16:44:06 2008
--- src/version.c	Sun Sep  7 13:52:00 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     11,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
34. You laugh at people with 14400 baud modems.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.012
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.012
Problem:    Compiler warnings when building with startup timing.
Solution:   Add type casts.
Files:	    src/ex_cmds2.c


*** ../vim-7.2.011/src/ex_cmds2.c	Sun Jul 13 19:36:09 2008
--- src/ex_cmds2.c	Tue Sep  2 11:14:41 2008
***************
*** 3145,3152 ****
  	verbose_leave();
      }
  #ifdef STARTUPTIME
!     vim_snprintf(IObuff, IOSIZE, "sourcing %s", fname);
!     time_msg(IObuff, &tv_start);
      time_pop(&tv_rel);
  #endif
  
--- 3145,3152 ----
  	verbose_leave();
      }
  #ifdef STARTUPTIME
!     vim_snprintf((char *)IObuff, IOSIZE, "sourcing %s", fname);
!     time_msg((char *)IObuff, &tv_start);
      time_pop(&tv_rel);
  #endif
  
*** ../vim-7.2.011/src/version.c	Sun Sep  7 13:54:31 2008
--- src/version.c	Sun Sep  7 15:49:00 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     12,
  /**/

-- 
He who laughs last, thinks slowest.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.013
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.013
Problem:    While waiting for the X selection Vim consumes a lot of CPU time
	    and hangs until a response is received.
Solution:   Sleep a bit when the selection event hasn't been received yet.
	    Time out after a couple of seconds to avoid a hang when the
	    selection owner isn't responding.
Files:	    src/ui.c


*** ../vim-7.2.012/src/ui.c	Mon Jul 14 21:47:49 2008
--- src/ui.c	Sun Sep  7 16:54:35 2008
***************
*** 2110,2115 ****
--- 2110,2117 ----
      int		i;
      int		nbytes = 0;
      char_u	*buffer;
+     time_t	start_time;
+     int		timed_out = FALSE;
  
      for (i =
  #ifdef FEAT_MBYTE
***************
*** 2129,2134 ****
--- 2131,2137 ----
  	    case 3:  type = text_atom;		break;
  	    default: type = XA_STRING;
  	}
+ 	success = FALSE;
  	XtGetSelectionValue(myShell, cbd->sel_atom, type,
  	    clip_x11_request_selection_cb, (XtPointer)&success, CurrentTime);
  
***************
*** 2141,2167 ****
  	 * characters, then they will appear before the one that requested the
  	 * paste!  Don't worry, we will catch up with any other events later.
  	 */
  	for (;;)
  	{
  	    if (XCheckTypedEvent(dpy, SelectionNotify, &event))
  		break;
  	    if (XCheckTypedEvent(dpy, SelectionRequest, &event))
  		/* We may get a SelectionRequest here and if we don't handle
  		 * it we hang.  KDE klipper does this, for example. */
  		XtDispatchEvent(&event);
  
  	    /* Do we need this?  Probably not. */
  	    XSync(dpy, False);
  
! 	    /* Bernhard Walle solved a slow paste response in an X terminal by
! 	     * adding: usleep(10000); here. */
  	}
  
- 	/* this is where clip_x11_request_selection_cb() is actually called */
- 	XtDispatchEvent(&event);
- 
  	if (success)
  	    return;
      }
  
      /* Final fallback position - use the X CUT_BUFFER0 store */
--- 2144,2189 ----
  	 * characters, then they will appear before the one that requested the
  	 * paste!  Don't worry, we will catch up with any other events later.
  	 */
+ 	start_time = time(NULL);
  	for (;;)
  	{
  	    if (XCheckTypedEvent(dpy, SelectionNotify, &event))
+ 	    {
+ 		/* this is where clip_x11_request_selection_cb() is actually
+ 		 * called */
+ 		XtDispatchEvent(&event);
  		break;
+ 	    }
  	    if (XCheckTypedEvent(dpy, SelectionRequest, &event))
  		/* We may get a SelectionRequest here and if we don't handle
  		 * it we hang.  KDE klipper does this, for example. */
  		XtDispatchEvent(&event);
  
+ 	    /* Time out after 2 to 3 seconds to avoid that we hang when the
+ 	     * other process doesn't respond.  Note that the SelectionNotify
+ 	     * event may still come later when the selection owner comes back
+ 	     * to life and the text gets inserted unexpectedly (by xterm).
+ 	     * Don't know how to avoid that :-(. */
+ 	    if (time(NULL) > start_time + 2)
+ 	    {
+ 		timed_out = TRUE;
+ 		break;
+ 	    }
+ 
  	    /* Do we need this?  Probably not. */
  	    XSync(dpy, False);
  
! 	    /* Wait for 1 msec to avoid that we eat up all CPU time. */
! 	    ui_delay(1L, TRUE);
  	}
  
  	if (success)
  	    return;
+ 
+ 	/* don't do a retry with another type after timing out, otherwise we
+ 	 * hang for 15 seconds. */
+ 	if (timed_out)
+ 	    break;
      }
  
      /* Final fallback position - use the X CUT_BUFFER0 store */
*** ../vim-7.2.012/src/version.c	Sun Sep  7 15:49:45 2008
--- src/version.c	Sun Sep  7 21:45:55 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     13,
  /**/

-- 
The users that I support would double-click on a landmine to find out
what happens.				-- A system administrator

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.014
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.014
Problem:    synstack() doesn't work in an emptly line.
Solution:   Accept column zero as a valid position.
Files:	    src/eval.c


*** ../vim-7.2.013/src/eval.c	Sun Sep  7 13:54:31 2008
--- src/eval.c	Sun Sep  7 13:50:38 2008
***************
*** 16667,16673 ****
      col = get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
  
      if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
! 	    && col >= 0 && col < (long)STRLEN(ml_get(lnum))
  	    && rettv_list_alloc(rettv) != FAIL)
      {
  	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL, TRUE);
--- 16667,16673 ----
      col = get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
  
      if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
! 	    && col >= 0 && (col == 0 || col < (long)STRLEN(ml_get(lnum)))
  	    && rettv_list_alloc(rettv) != FAIL)
      {
  	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL, TRUE);
*** ../vim-7.2.013/src/version.c	Sun Sep  7 21:47:51 2008
--- src/version.c	Wed Sep 10 15:36:52 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     14,
  /**/

-- 
Everybody lies, but it doesn't matter since nobody listens.
                                -- Lieberman's Law

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.015
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.015
Problem:    "make all test install" doesn't stop when the test fails. (Daniel
	    Shahaf)
Solution:   When test.log contains failures exit with non-zero status.
Files:	    src/testdir/Makefile


*** ../vim-7.2.014/src/testdir/Makefile	Wed Jun 25 00:22:53 2008
--- src/testdir/Makefile	Sun Sep  7 21:31:49 2008
***************
*** 26,40 ****
  
  .SUFFIXES: .in .out
  
! nongui:	nolog $(SCRIPTS)
! 	@echo
! 	@cat test.log
! 	@echo ALL DONE
  
! gui:	nolog $(SCRIPTS) $(SCRIPTS_GUI)
  	@echo
! 	@cat test.log
! 	@echo ALL DONE
  
  $(SCRIPTS) $(SCRIPTS_GUI): $(VIMPROG)
  
--- 26,42 ----
  
  .SUFFIXES: .in .out
  
! nongui:	nolog $(SCRIPTS) report
! 
! gui:	nolog $(SCRIPTS) $(SCRIPTS_GUI) report
  
! report:
  	@echo
! 	@echo 'Test results:'
! 	@/bin/sh -c "if test -f test.log; \
! 		then cat test.log; echo TEST FAILURE; exit 1; \
! 		else echo ALL DONE; \
! 		fi"
  
  $(SCRIPTS) $(SCRIPTS_GUI): $(VIMPROG)
  
***************
*** 71,74 ****
  test60.out: test60.vim
  
  nolog:
! 	-echo Test results: >test.log
--- 73,76 ----
  test60.out: test60.vim
  
  nolog:
! 	-rm -f test.log
*** ../vim-7.2.014/src/version.c	Wed Sep 10 15:38:13 2008
--- src/version.c	Wed Sep 10 18:23:38 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     15,
  /**/

-- 
Light travels faster than sound.  This is why some people
appear bright until you hear them speak

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.016
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.016
Problem:    The pattern being completed may be in freed memory when the
	    command line is being reallocated. (Dominique Pelle)
Solution:   Keep a pointer to the expand_T in the command line structure.
	    Don't use <S-Tab> as CTRL-P when there are no results.  Clear the
	    completion when using a command line from the history.
Files:	    src/ex_getln.c


*** ../vim-7.2.015/src/ex_getln.c	Fri Aug  8 12:58:59 2008
--- src/ex_getln.c	Wed Sep 10 22:43:41 2008
***************
*** 31,36 ****
--- 31,38 ----
      int		cmdattr;	/* attributes for prompt */
      int		overstrike;	/* Typing mode on the command line.  Shared by
  				   getcmdline() and put_on_cmdline(). */
+     expand_T	*xpc;		/* struct being used for expansion, xp_pattern
+ 				   may point into cmdbuff */
      int		xp_context;	/* type of expansion */
  # ifdef FEAT_EVAL
      char_u	*xp_arg;	/* user-defined expansion arg */
***************
*** 38,44 ****
  # endif
  };
  
! static struct cmdline_info ccline;	/* current cmdline_info */
  
  static int	cmd_showtail;		/* Only show path tail in lists ? */
  
--- 40,50 ----
  # endif
  };
  
! /* The current cmdline_info.  It is initialized in getcmdline() and after that
!  * used by other functions.  When invoking getcmdline() recursively it needs
!  * to be saved with save_cmdline() and restored with restore_cmdline().
!  * TODO: make it local to getcmdline() and pass it around. */
! static struct cmdline_info ccline;
  
  static int	cmd_showtail;		/* Only show path tail in lists ? */
  
***************
*** 238,243 ****
--- 244,250 ----
      }
  
      ExpandInit(&xpc);
+     ccline.xpc = &xpc;
  
  #ifdef FEAT_RIGHTLEFT
      if (curwin->w_p_rl && *curwin->w_p_rlc == 's'
***************
*** 408,416 ****
  #endif
  
  	/*
! 	 * <S-Tab> works like CTRL-P (unless 'wc' is <S-Tab>).
  	 */
! 	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles != -1)
  	    c = Ctrl_P;
  
  #ifdef FEAT_WILDMENU
--- 415,424 ----
  #endif
  
  	/*
! 	 * When there are matching completions to select <S-Tab> works like
! 	 * CTRL-P (unless 'wc' is <S-Tab>).
  	 */
! 	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)
  	    c = Ctrl_P;
  
  #ifdef FEAT_WILDMENU
***************
*** 1513,1518 ****
--- 1521,1527 ----
  		    int		old_firstc;
  
  		    vim_free(ccline.cmdbuff);
+ 		    xpc.xp_context = EXPAND_NOTHING;
  		    if (hiscnt == hislen)
  			p = lookfor;	/* back to the old one */
  		    else
***************
*** 1839,1844 ****
--- 1848,1854 ----
  #endif
  
      ExpandCleanup(&xpc);
+     ccline.xpc = NULL;
  
  #ifdef FEAT_SEARCH_EXTRA
      if (did_incsearch)
***************
*** 2508,2513 ****
--- 2518,2537 ----
      }
      mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen + 1);
      vim_free(p);
+ 
+     if (ccline.xpc != NULL
+ 	    && ccline.xpc->xp_pattern != NULL
+ 	    && ccline.xpc->xp_context != EXPAND_NOTHING
+ 	    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)
+     {
+ 	int i = ccline.xpc->xp_pattern - p;
+ 
+ 	/* If xp_pattern points inside the old cmdbuff it needs to be adjusted
+ 	 * to point into the newly allocated memory. */
+ 	if (i >= 0 && i <= ccline.cmdlen)
+ 	    ccline.xpc->xp_pattern = ccline.cmdbuff + i;
+     }
+ 
      return OK;
  }
  
***************
*** 2875,2880 ****
--- 2899,2905 ----
      prev_ccline = ccline;
      ccline.cmdbuff = NULL;
      ccline.cmdprompt = NULL;
+     ccline.xpc = NULL;
  }
  
  /*
***************
*** 3582,3587 ****
--- 3607,3613 ----
  ExpandInit(xp)
      expand_T	*xp;
  {
+     xp->xp_pattern = NULL;
      xp->xp_backslash = XP_BS_NONE;
  #ifndef BACKSLASH_IN_FILENAME
      xp->xp_shell = FALSE;
*** ../vim-7.2.015/src/version.c	Wed Sep 10 18:25:18 2008
--- src/version.c	Sun Sep 14 14:38:47 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     16,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
53. To find out what time it is, you send yourself an e-mail and check the
    "Date:" field.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.017
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.017
Problem:    strlen() used on text that may not end in a NUL. (Dominique Pelle)
	    Pasting a very big selection doesn't work.
Solution:   Use the length passed to the XtSelectionCallbackProc() function.
	    After getting the SelectionNotify event continue dispatching
	    events until the callback is actually called.  Also dispatch the
	    PropertyNotify event.
Files:	    src/ui.c


*** ../vim-7.2.016/src/ui.c	Sun Sep  7 21:47:51 2008
--- src/ui.c	Sun Sep 14 15:52:19 2008
***************
*** 2020,2026 ****
  
      if (value == NULL || *length == 0)
      {
! 	clip_free_selection(cbd);	/* ???  [what's the query?] */
  	*(int *)success = FALSE;
  	return;
      }
--- 2020,2026 ----
  
      if (value == NULL || *length == 0)
      {
! 	clip_free_selection(cbd);	/* nothing received, clear register */
  	*(int *)success = FALSE;
  	return;
      }
***************
*** 2076,2082 ****
  	text_prop.value = (unsigned char *)value;
  	text_prop.encoding = *type;
  	text_prop.format = *format;
! 	text_prop.nitems = STRLEN(value);
  	status = XmbTextPropertyToTextList(X_DISPLAY, &text_prop,
  							 &text_list, &n_text);
  	if (status != Success || n_text < 1)
--- 2076,2082 ----
  	text_prop.value = (unsigned char *)value;
  	text_prop.encoding = *type;
  	text_prop.format = *format;
! 	text_prop.nitems = len;
  	status = XmbTextPropertyToTextList(X_DISPLAY, &text_prop,
  							 &text_list, &n_text);
  	if (status != Success || n_text < 1)
***************
*** 2131,2137 ****
  	    case 3:  type = text_atom;		break;
  	    default: type = XA_STRING;
  	}
! 	success = FALSE;
  	XtGetSelectionValue(myShell, cbd->sel_atom, type,
  	    clip_x11_request_selection_cb, (XtPointer)&success, CurrentTime);
  
--- 2131,2137 ----
  	    case 3:  type = text_atom;		break;
  	    default: type = XA_STRING;
  	}
! 	success = MAYBE;
  	XtGetSelectionValue(myShell, cbd->sel_atom, type,
  	    clip_x11_request_selection_cb, (XtPointer)&success, CurrentTime);
  
***************
*** 2145,2169 ****
  	 * paste!  Don't worry, we will catch up with any other events later.
  	 */
  	start_time = time(NULL);
! 	for (;;)
  	{
! 	    if (XCheckTypedEvent(dpy, SelectionNotify, &event))
  	    {
! 		/* this is where clip_x11_request_selection_cb() is actually
! 		 * called */
  		XtDispatchEvent(&event);
! 		break;
  	    }
- 	    if (XCheckTypedEvent(dpy, SelectionRequest, &event))
- 		/* We may get a SelectionRequest here and if we don't handle
- 		 * it we hang.  KDE klipper does this, for example. */
- 		XtDispatchEvent(&event);
  
  	    /* Time out after 2 to 3 seconds to avoid that we hang when the
  	     * other process doesn't respond.  Note that the SelectionNotify
  	     * event may still come later when the selection owner comes back
! 	     * to life and the text gets inserted unexpectedly (by xterm).
! 	     * Don't know how to avoid that :-(. */
  	    if (time(NULL) > start_time + 2)
  	    {
  		timed_out = TRUE;
--- 2145,2171 ----
  	 * paste!  Don't worry, we will catch up with any other events later.
  	 */
  	start_time = time(NULL);
! 	while (success == MAYBE)
  	{
! 	    if (XCheckTypedEvent(dpy, SelectionNotify, &event)
! 		    || XCheckTypedEvent(dpy, SelectionRequest, &event)
! 		    || XCheckTypedEvent(dpy, PropertyNotify, &event))
  	    {
! 		/* This is where clip_x11_request_selection_cb() should be
! 		 * called.  It may actually happen a bit later, so we loop
! 		 * until "success" changes.
! 		 * We may get a SelectionRequest here and if we don't handle
! 		 * it we hang.  KDE klipper does this, for example.
! 		 * We need to handle a PropertyNotify for large selections. */
  		XtDispatchEvent(&event);
! 		continue;
  	    }
  
  	    /* Time out after 2 to 3 seconds to avoid that we hang when the
  	     * other process doesn't respond.  Note that the SelectionNotify
  	     * event may still come later when the selection owner comes back
! 	     * to life and the text gets inserted unexpectedly.  Don't know
! 	     * why that happens or how to avoid that :-(. */
  	    if (time(NULL) > start_time + 2)
  	    {
  		timed_out = TRUE;
***************
*** 2177,2183 ****
  	    ui_delay(1L, TRUE);
  	}
  
! 	if (success)
  	    return;
  
  	/* don't do a retry with another type after timing out, otherwise we
--- 2179,2185 ----
  	    ui_delay(1L, TRUE);
  	}
  
! 	if (success == TRUE)
  	    return;
  
  	/* don't do a retry with another type after timing out, otherwise we
*** ../vim-7.2.016/src/version.c	Sun Sep 14 14:41:44 2008
--- src/version.c	Sun Sep 14 15:55:34 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     17,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
54. You start tilting your head sideways to smile. :-)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.018
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.018
Problem:    Memory leak when substitute is aborted.
Solution:   Free the buffer allocated for the new text. (Dominique Pelle)
Files:	    src/ex_cmds.c


*** ../vim-7.2.017/src/ex_cmds.c	Wed Aug  6 15:03:07 2008
--- src/ex_cmds.c	Sun Sep 14 13:45:03 2008
***************
*** 5059,5064 ****
--- 5059,5065 ----
  
  	    if (did_sub)
  		++sub_nlines;
+ 	    vim_free(new_start);	/* for when substitute was cancelled */
  	    vim_free(sub_firstline);	/* free the copy of the original line */
  	    sub_firstline = NULL;
  	}
*** ../vim-7.2.017/src/version.c	Sun Sep 14 15:57:54 2008
--- src/version.c	Sun Sep 14 21:38:25 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     18,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
55. You ask your doctor to implant a gig in your brain.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.019
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.019
Problem:    Completion of ":noautocmd" doesn't work and exists(":noautocmd")
	    returns zero. (Ben Fritz)
Solution:   Add "noautocmd" to the list of modifiers and commands.
Files:	    src/ex_cmds.h, src/ex_docmd.c


*** ../vim-7.2.018/src/ex_cmds.h	Wed Jun 25 00:44:40 2008
--- src/ex_cmds.h	Sat Sep 13 18:37:25 2008
***************
*** 635,640 ****
--- 635,642 ----
  			RANGE|NOTADR|ZEROR|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
  EX(CMD_noremap,		"noremap",	ex_map,
  			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
+ EX(CMD_noautocmd,	"noautocmd",	ex_wrongmodifier,
+ 			NEEDARG|EXTRA|NOTRLCOM),
  EX(CMD_nohlsearch,	"nohlsearch",	ex_nohlsearch,
  			TRLBAR|SBOXOK|CMDWIN),
  EX(CMD_noreabbrev,	"noreabbrev",	ex_abbreviate,
*** ../vim-7.2.018/src/ex_docmd.c	Sat Jul 26 16:04:39 2008
--- src/ex_docmd.c	Mon Sep 15 20:04:53 2008
***************
*** 2978,2983 ****
--- 2979,2985 ----
      {"keepmarks", 3, FALSE},
      {"leftabove", 5, FALSE},
      {"lockmarks", 3, FALSE},
+     {"noautocmd", 3, FALSE},
      {"rightbelow", 6, FALSE},
      {"sandbox", 3, FALSE},
      {"silent", 3, FALSE},
*** ../vim-7.2.018/src/version.c	Sun Sep 14 21:40:26 2008
--- src/version.c	Thu Sep 18 12:39:56 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     19,
  /**/

-- 
Proof techniques #2: Proof by Oddity.
	SAMPLE: To prove that horses have an infinite number of legs.
(1) Horses have an even number of legs.
(2) They have two legs in back and fore legs in front.
(3) This makes a total of six legs, which certainly is an odd number of
    legs for a horse.
(4) But the only number that is both odd and even is infinity.
(5) Therefore, horses must have an infinite number of legs.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.020
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.020
Problem:    Starting the GUI when the executable starts with 'k', but the KDE
	    version no longer exists.
Solution:   Don't have "kvim" start the GUI.
Files:	    src/main.c


*** ../vim-7.2.019/src/main.c	Thu Jul 24 19:34:23 2008
--- src/main.c	Sun Sep 14 13:26:10 2008
***************
*** 1457,1463 ****
  	++initstr;
      }
  
!     if (TOLOWER_ASC(initstr[0]) == 'g' || initstr[0] == 'k')
      {
  	main_start_gui();
  #ifdef FEAT_GUI
--- 1458,1465 ----
  	++initstr;
      }
  
!     /* "gvim" starts the GUI.  Also accept "Gvim" for MS-Windows. */
!     if (TOLOWER_ASC(initstr[0]) == 'g')
      {
  	main_start_gui();
  #ifdef FEAT_GUI
*** ../vim-7.2.019/src/version.c	Thu Sep 18 12:43:21 2008
--- src/version.c	Thu Sep 18 20:54:10 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     20,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
90. Instead of calling you to dinner, your spouse sends e-mail.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.021
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.021
Problem:    When executing autocommands getting the full file name may be
	    slow. (David Kotchan)
Solution:   Postpone calling FullName_save() until autocmd_fname is used.
Files:	    src/ex_docmd.c, src/fileio.c, src/globals.h


*** ../vim-7.2.020/src/ex_docmd.c	Thu Sep 18 12:43:21 2008
--- src/ex_docmd.c	Mon Sep 15 20:04:53 2008
***************
*** 9542,9547 ****
--- 9569,9583 ----
  #ifdef FEAT_AUTOCMD
  	case SPEC_AFILE:	/* file name for autocommand */
  		result = autocmd_fname;
+ 		if (result != NULL && !autocmd_fname_full)
+ 		{
+ 		    /* Still need to turn the fname into a full path.  It is
+ 		     * postponed to avoid a delay when <afile> is not used. */
+ 		    autocmd_fname_full = TRUE;
+ 		    result = FullName_save(autocmd_fname, FALSE);
+ 		    vim_free(autocmd_fname);
+ 		    autocmd_fname = result;
+ 		}
  		if (result == NULL)
  		{
  		    *errormsg = (char_u *)_("E495: no autocommand file name to substitute for \"<afile>\"");
*** ../vim-7.2.020/src/fileio.c	Wed Aug  6 18:43:07 2008
--- src/fileio.c	Tue Sep 16 21:24:26 2008
***************
*** 8523,8528 ****
--- 8523,8529 ----
      char_u	*save_sourcing_name;
      linenr_T	save_sourcing_lnum;
      char_u	*save_autocmd_fname;
+     int		save_autocmd_fname_full;
      int		save_autocmd_bufnr;
      char_u	*save_autocmd_match;
      int		save_autocmd_busy;
***************
*** 8601,8606 ****
--- 8602,8608 ----
       * Save the autocmd_* variables and info about the current buffer.
       */
      save_autocmd_fname = autocmd_fname;
+     save_autocmd_fname_full = autocmd_fname_full;
      save_autocmd_bufnr = autocmd_bufnr;
      save_autocmd_match = autocmd_match;
      save_autocmd_busy = autocmd_busy;
***************
*** 8618,8631 ****
  	if (fname != NULL && *fname != NUL)
  	    autocmd_fname = fname;
  	else if (buf != NULL)
! 	    autocmd_fname = buf->b_fname;
  	else
  	    autocmd_fname = NULL;
      }
      else
  	autocmd_fname = fname_io;
      if (autocmd_fname != NULL)
! 	autocmd_fname = FullName_save(autocmd_fname, FALSE);
  
      /*
       * Set the buffer number to be used for <abuf>.
--- 8620,8634 ----
  	if (fname != NULL && *fname != NUL)
  	    autocmd_fname = fname;
  	else if (buf != NULL)
! 	    autocmd_fname = buf->b_ffname;
  	else
  	    autocmd_fname = NULL;
      }
      else
  	autocmd_fname = fname_io;
      if (autocmd_fname != NULL)
! 	autocmd_fname = vim_strsave(autocmd_fname);
!     autocmd_fname_full = FALSE; /* call FullName_save() later */
  
      /*
       * Set the buffer number to be used for <abuf>.
***************
*** 8810,8815 ****
--- 8813,8819 ----
      sourcing_lnum = save_sourcing_lnum;
      vim_free(autocmd_fname);
      autocmd_fname = save_autocmd_fname;
+     autocmd_fname_full = save_autocmd_fname_full;
      autocmd_bufnr = save_autocmd_bufnr;
      autocmd_match = save_autocmd_match;
  #ifdef FEAT_EVAL
***************
*** 8918,8924 ****
      {
  	apc->curpat = NULL;
  
! 	/* only use a pattern when it has not been removed, has commands and
  	 * the group matches. For buffer-local autocommands only check the
  	 * buffer number. */
  	if (ap->pat != NULL && ap->cmds != NULL
--- 8922,8928 ----
      {
  	apc->curpat = NULL;
  
! 	/* Only use a pattern when it has not been removed, has commands and
  	 * the group matches. For buffer-local autocommands only check the
  	 * buffer number. */
  	if (ap->pat != NULL && ap->cmds != NULL
*** ../vim-7.2.020/src/globals.h	Sat Jul 26 16:04:49 2008
--- src/globals.h	Mon Sep 15 19:59:28 2008
***************
*** 1022,1027 ****
--- 1022,1028 ----
  #endif
  #ifdef FEAT_AUTOCMD
  EXTERN char_u	*autocmd_fname INIT(= NULL); /* fname for <afile> on cmdline */
+ EXTERN int	autocmd_fname_full;	     /* autocmd_fname is full path */
  EXTERN int	autocmd_bufnr INIT(= 0);     /* fnum for <abuf> on cmdline */
  EXTERN char_u	*autocmd_match INIT(= NULL); /* name for <amatch> on cmdline */
  EXTERN int	did_cursorhold INIT(= FALSE); /* set when CursorHold t'gerd */
*** ../vim-7.2.020/src/version.c	Thu Sep 18 20:55:19 2008
--- src/version.c	Thu Sep 18 21:24:30 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     21,
  /**/

-- 
From "know your smileys":
 :----}  You lie like Pinocchio

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.022 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.022 (extra)
Problem:    Testing is not possible when compiling with MingW.
Solution:   Add a MingW specific test Makefile. (Bill McCarthy)
Files:	    Filelist, src/testdir/Make_ming.mak


*** ../vim-7.2.021/Filelist	Sun Jul 13 19:33:31 2008
--- Filelist	Sun Sep 14 21:47:01 2008
***************
*** 285,290 ****
--- 285,291 ----
  		src/proto/os_win32.pro \
  		src/proto/os_mswin.pro \
  		src/testdir/Make_dos.mak \
+ 		src/testdir/Make_ming.mak \
  		src/testdir/dos.vim \
  		src/uninstal.c \
  		src/vim.def \
*** ../vim-7.2.021/src/testdir/Make_ming.mak	Sat Sep 20 16:25:06 2008
--- src/testdir/Make_ming.mak	Sat Sep 20 16:25:58 2008
***************
*** 0 ****
--- 1,91 ----
+ # Makefile to run tests for Vim, on Dos-like machines
+ # with sh.exe or zsh.exe in the path or not.
+ #
+ # Author: Bill McCarthy
+ #
+ # Note that test54 has been removed until it is fixed.
+ #
+ # Requires a set of Unix tools: echo, diff, etc.
+ 
+ ifneq (sh.exe, $(SHELL))
+ DEL = rm -f
+ MV = mv
+ CP = cp
+ DIRSLASH = /
+ else
+ DEL = del
+ MV = rename
+ CP = copy
+ DIRSLASH = \\
+ endif
+ 
+ VIMPROG = ..$(DIRSLASH)vim
+ 
+ # Omitted:
+ # test2		"\\tmp" doesn't work.
+ # test10	'errorformat' is different
+ # test12	can't unlink a swap file
+ # test25	uses symbolic link
+ # test27	can't edit file with "*" in file name
+ # test31	16 bit version runs out of memory...
+ 
+ SCRIPTS16 =	test1.out test19.out test20.out test22.out \
+ 		test23.out test24.out test28.out test29.out \
+ 		test35.out test36.out test43.out \
+ 		test44.out test45.out test46.out test47.out \
+ 		test48.out test51.out test53.out            \
+ 		test55.out test56.out test57.out test58.out test59.out \
+ 		test60.out test61.out test62.out test63.out test64.out
+ 
+ # Had to remove test54 which doesn't work yet.
+ #		                                 test54.out
+ 
+ SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
+ 		test8.out test9.out test11.out test13.out test14.out \
+ 		test15.out test17.out test18.out test21.out test26.out \
+ 		test30.out test31.out test32.out test33.out test34.out \
+ 		test37.out test38.out test39.out test40.out test41.out \
+ 		test42.out test52.out test65.out
+ 
+ SCRIPTS32 =	test50.out
+ 
+ SCRIPTS_GUI = test16.out
+ 
+ .SUFFIXES: .in .out
+ 
+ vimall:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS_GUI) $(SCRIPTS32)
+ 	echo ALL DONE
+ 
+ nongui:	fixff $(SCRIPTS16) $(SCRIPTS)
+ 	echo ALL DONE
+ 
+ small:
+ 	echo ALL DONE
+ 
+ gui:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS_GUI)
+ 	echo ALL DONE
+ 
+ win32:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS32)
+ 	echo ALL DONE
+ 
+ fixff:
+ 	-$(VIMPROG) -u dos.vim --noplugin "+argdo set ff=dos|upd" +q *.in *.ok
+ 
+ clean:
+ 	-$(DEL) *.out
+ 	-$(DEL) test.ok
+ 	-$(DEL) small.vim
+ 	-$(DEL) tiny.vim
+ 	-$(DEL) mbyte.vim
+ 	-$(DEL) X*
+ 	-$(DEL) viminfo
+ 
+ .in.out:
+ 	$(CP) $*.ok test.ok
+ 	$(VIMPROG) -u dos.vim -U NONE --noplugin -s dotest.in $*.in
+ 	diff test.out $*.ok
+ 	-$(DEL) $*.out
+ 	$(MV) test.out $*.out
+ 	-$(DEL) X*
+ 	-$(DEL) test.ok
+ 	-$(DEL) viminfo
*** ../vim-7.2.021/src/version.c	Thu Sep 18 21:29:07 2008
--- src/version.c	Sat Sep 20 16:25:16 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     22,
  /**/

-- 
Where do you want to crash today?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.023
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.023
Problem:    'cursorcolumn' is in the wrong place in a closed fold when the
	    display is shifted left. (Gary Johnson)
Solution:   Subtract w_skipcol or w_leftcol when needed.
Files:	    src/screen.c


*** ../vim-7.2.022/src/screen.c	Thu Jul 24 20:29:09 2008
--- src/screen.c	Fri Sep 26 21:23:06 2008
***************
*** 2439,2447 ****
  
  #ifdef FEAT_SYN_HL
      /* Show 'cursorcolumn' in the fold line. */
!     if (wp->w_p_cuc && (int)wp->w_virtcol + txtcol < W_WIDTH(wp))
! 	ScreenAttrs[off + wp->w_virtcol + txtcol] = hl_combine_attr(
! 		 ScreenAttrs[off + wp->w_virtcol + txtcol], hl_attr(HLF_CUC));
  #endif
  
      SCREEN_LINE(row + W_WINROW(wp), W_WINCOL(wp), (int)W_WIDTH(wp),
--- 2439,2455 ----
  
  #ifdef FEAT_SYN_HL
      /* Show 'cursorcolumn' in the fold line. */
!     if (wp->w_p_cuc)
!     {
! 	txtcol += wp->w_virtcol;
! 	if (wp->w_p_wrap)
! 	    txtcol -= wp->w_skipcol;
! 	else
! 	    txtcol -= wp->w_leftcol;
! 	if (txtcol >= 0 && txtcol < W_WIDTH(wp))
! 	    ScreenAttrs[off + txtcol] = hl_combine_attr(
! 				 ScreenAttrs[off + txtcol], hl_attr(HLF_CUC));
!     }
  #endif
  
      SCREEN_LINE(row + W_WINROW(wp), W_WINCOL(wp), (int)W_WIDTH(wp),
*** ../vim-7.2.022/src/version.c	Sat Sep 20 16:26:10 2008
--- src/version.c	Wed Oct  1 21:07:31 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     23,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
124. You begin conversations with, "Who is your internet service provider?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.024
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.024
Problem:    It's possible to set 'history' to a negative value and that causes
	    an out-of-memory error.
Solution:   Check that 'history' has a positive value. (Doug Kearns)
Files:	    src/option.c


*** ../vim-7.2.023/src/option.c	Thu Jul 24 18:45:15 2008
--- src/option.c	Fri Sep 26 22:20:20 2008
***************
*** 7974,7979 ****
--- 7974,7984 ----
  	else /* curwin->w_p_scr > curwin->w_height */
  	    curwin->w_p_scr = curwin->w_height;
      }
+     if (p_hi < 0)
+     {
+ 	errmsg = e_positive;
+ 	p_hi = 0;
+     }
      if (p_report < 0)
      {
  	errmsg = e_positive;
*** ../vim-7.2.023/src/version.c	Wed Oct  1 21:09:02 2008
--- src/version.c	Thu Oct  2 22:47:22 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     24,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
127. You bring your laptop and cellular phone to church.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.025
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.025
Problem:    When a CursorHold event invokes system() it is retriggered over
	    and over again.
Solution:   Don't reset did_cursorhold when getting K_IGNORE.
Files:	    src/normal.c


*** ../vim-7.2.024/src/normal.c	Sat Sep  6 16:44:06 2008
--- src/normal.c	Sat Sep 27 13:03:34 2008
***************
*** 1132,1138 ****
  	out_flush();
  #endif
  #ifdef FEAT_AUTOCMD
!     did_cursorhold = FALSE;
  #endif
  
      State = NORMAL;
--- 1132,1139 ----
  	out_flush();
  #endif
  #ifdef FEAT_AUTOCMD
!     if (ca.cmdchar != K_IGNORE)
! 	did_cursorhold = FALSE;
  #endif
  
      State = NORMAL;
*** ../vim-7.2.024/src/version.c	Thu Oct  2 22:48:01 2008
--- src/version.c	Thu Oct  2 22:54:41 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     25,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
128. You can access the Net -- via your portable and cellular phone.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.026
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.026 (after 7.2.010)
Problem:    "K" doesn't use the length of the identifier but uses the rest of
	    the line.
Solution:   Copy the desired number of characters first.
Files:	    src/normal.c


*** ../vim-7.2.025/src/normal.c	Thu Oct  2 22:55:17 2008
--- src/normal.c	Sat Nov  1 13:41:03 2008
***************
*** 183,188 ****
--- 183,190 ----
  static void	nv_cursorhold __ARGS((cmdarg_T *cap));
  #endif
  
+ static char *e_noident = N_("E349: No identifier under cursor");
+ 
  /*
   * Function to be called for a Normal or Visual mode command.
   * The argument is a cmdarg_T.
***************
*** 3510,3516 ****
  	if (find_type & FIND_STRING)
  	    EMSG(_("E348: No string under cursor"));
  	else
! 	    EMSG(_("E349: No identifier under cursor"));
  	return 0;
      }
      ptr += col;
--- 3512,3518 ----
  	if (find_type & FIND_STRING)
  	    EMSG(_("E348: No string under cursor"));
  	else
! 	    EMSG(_(e_noident));
  	return 0;
      }
      ptr += col;
***************
*** 5472,5479 ****
  	    {
  		/* An external command will probably use an argument starting
  		 * with "-" as an option.  To avoid trouble we skip the "-". */
! 		while (*ptr == '-')
  		    ++ptr;
  
  		/* When a count is given, turn it into a range.  Is this
  		 * really what we want? */
--- 5474,5490 ----
  	    {
  		/* An external command will probably use an argument starting
  		 * with "-" as an option.  To avoid trouble we skip the "-". */
! 		while (*ptr == '-' && n > 0)
! 		{
  		    ++ptr;
+ 		    --n;
+ 		}
+ 		if (n == 0)
+ 		{
+ 		    EMSG(_(e_noident));	 /* found dashes only */
+ 		    vim_free(buf);
+ 		    return;
+ 		}
  
  		/* When a count is given, turn it into a range.  Is this
  		 * really what we want? */
***************
*** 5520,5526 ****
--- 5531,5539 ----
      if (cmdchar == 'K' && !kp_help)
      {
  	/* Escape the argument properly for a shell command */
+ 	ptr = vim_strnsave(ptr, n);
  	p = vim_strsave_shellescape(ptr, TRUE);
+ 	vim_free(ptr);
  	if (p == NULL)
  	{
  	    vim_free(buf);
*** ../vim-7.2.025/src/version.c	Thu Oct  2 22:55:17 2008
--- src/version.c	Sat Nov  1 13:50:53 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     26,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
161. You get up before the sun rises to check your e-mail, and you
     find yourself in the very same chair long after the sun has set.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.027
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.027
Problem:    Can use cscope commands in the sandbox.
Solution:   Disallow them, they might not be safe.
Files:	    src/ex_cmds.h


*** ../vim-7.2.026/src/ex_cmds.h	Thu Sep 18 12:43:21 2008
--- src/ex_cmds.h	Thu Sep 18 22:18:14 2008
***************
*** 278,284 ****
  EX(CMD_crewind,		"crewind",	ex_cc,
  			RANGE|NOTADR|COUNT|TRLBAR|BANG),
  EX(CMD_cscope,		"cscope",	do_cscope,
! 			EXTRA|NOTRLCOM|SBOXOK|XFILE),
  EX(CMD_cstag,		"cstag",	do_cstag,
  			BANG|TRLBAR|WORD1),
  EX(CMD_cunmap,		"cunmap",	ex_unmap,
--- 278,284 ----
  EX(CMD_crewind,		"crewind",	ex_cc,
  			RANGE|NOTADR|COUNT|TRLBAR|BANG),
  EX(CMD_cscope,		"cscope",	do_cscope,
! 			EXTRA|NOTRLCOM|XFILE),
  EX(CMD_cstag,		"cstag",	do_cstag,
  			BANG|TRLBAR|WORD1),
  EX(CMD_cunmap,		"cunmap",	ex_unmap,
***************
*** 506,512 ****
  EX(CMD_lclose,		"lclose",	ex_cclose,
  			RANGE|NOTADR|COUNT|TRLBAR),
  EX(CMD_lcscope,		"lcscope",	do_cscope,
! 			EXTRA|NOTRLCOM|SBOXOK|XFILE),
  EX(CMD_left,		"left",		ex_align,
  			TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|MODIFY),
  EX(CMD_leftabove,	"leftabove",	ex_wrongmodifier,
--- 506,512 ----
  EX(CMD_lclose,		"lclose",	ex_cclose,
  			RANGE|NOTADR|COUNT|TRLBAR),
  EX(CMD_lcscope,		"lcscope",	do_cscope,
! 			EXTRA|NOTRLCOM|XFILE),
  EX(CMD_left,		"left",		ex_align,
  			TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|MODIFY),
  EX(CMD_leftabove,	"leftabove",	ex_wrongmodifier,
***************
*** 653,658 ****
--- 653,660 ----
  			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
  EX(CMD_open,		"open",		ex_open,
  			RANGE|EXTRA),
+ EX(CMD_oldfiles,	"oldfiles",	ex_oldfiles,
+ 			BANG|TRLBAR|SBOXOK|CMDWIN),
  EX(CMD_omap,		"omap",		ex_map,
  			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
  EX(CMD_omapclear,	"omapclear",	ex_mapclear,
***************
*** 804,810 ****
  EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
  			WORD1|TRLBAR|CMDWIN),
  EX(CMD_scscope,		"scscope",	do_scscope,
! 			EXTRA|NOTRLCOM|SBOXOK),
  EX(CMD_set,		"set",		ex_set,
  			TRLBAR|EXTRA|CMDWIN|SBOXOK),
  EX(CMD_setfiletype,	"setfiletype",	ex_setfiletype,
--- 806,812 ----
  EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
  			WORD1|TRLBAR|CMDWIN),
  EX(CMD_scscope,		"scscope",	do_scscope,
! 			EXTRA|NOTRLCOM),
  EX(CMD_set,		"set",		ex_set,
  			TRLBAR|EXTRA|CMDWIN|SBOXOK),
  EX(CMD_setfiletype,	"setfiletype",	ex_setfiletype,
*** ../vim-7.2.026/src/version.c	Sat Nov  1 13:51:57 2008
--- src/version.c	Thu Nov  6 10:21:21 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     27,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
179. You wonder why your household garbage can doesn't have an
     "empty recycle bin" button.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.028
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.028
Problem:    Confusing error message for missing ().
Solution:   Change "braces" to "parentheses". (Gary Johnson)
Files:	    src/eval.c


*** ../vim-7.2.027/src/eval.c	Wed Sep 10 15:38:13 2008
--- src/eval.c	Tue Sep 30 21:43:38 2008
***************
*** 3287,3293 ****
  
      if (*startarg != '(')
      {
! 	EMSG2(_("E107: Missing braces: %s"), eap->arg);
  	goto end;
      }
  
--- 3293,3299 ----
  
      if (*startarg != '(')
      {
! 	EMSG2(_("E107: Missing parentheses: %s"), eap->arg);
  	goto end;
      }
  
*** ../vim-7.2.027/src/version.c	Thu Nov  6 10:23:03 2008
--- src/version.c	Thu Nov  6 11:02:51 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     28,
  /**/

-- 
Wizards had always known that the act of observation changed the thing that
was observed, and sometimes forgot that it also changed the observer too.
			Terry Pratchett  -  Interesting times

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.029
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.029
Problem:    No completion for ":doautoall".
Solution:   Complete ":doautoall" like ":doautocmd".  (Doug Kearns)
Files:	    src/ex_docmd.c


*** ../vim-7.2.028/src/ex_docmd.c	Thu Sep 18 21:29:07 2008
--- src/ex_docmd.c	Mon Nov  3 21:21:17 2008
***************
*** 3609,3614 ****
--- 3610,3616 ----
  	    return set_context_in_autocmd(xp, arg, FALSE);
  
  	case CMD_doautocmd:
+ 	case CMD_doautoall:
  	    return set_context_in_autocmd(xp, arg, TRUE);
  #endif
  	case CMD_set:
*** ../vim-7.2.028/src/version.c	Thu Nov  6 11:04:50 2008
--- src/version.c	Thu Nov  6 17:14:58 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     29,
  /**/

-- 
Press any key to continue, press any other key to quit.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.030
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.030 (after 7.2.027)
Problem:    Can't compile.
Solution:   Remove prematurely added ex_oldfiles.
Files:	    src/ex_cmds.h


*** ../vim-7.2.029/src/ex_cmds.h	Thu Nov  6 10:23:03 2008
--- src/ex_cmds.h	Thu Nov  6 20:45:07 2008
***************
*** 653,660 ****
  			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
  EX(CMD_open,		"open",		ex_open,
  			RANGE|EXTRA),
- EX(CMD_oldfiles,	"oldfiles",	ex_oldfiles,
- 			BANG|TRLBAR|SBOXOK|CMDWIN),
  EX(CMD_omap,		"omap",		ex_map,
  			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
  EX(CMD_omapclear,	"omapclear",	ex_mapclear,
--- 653,658 ----
*** ../vim-7.2.029/src/version.c	Thu Nov  6 17:16:06 2008
--- src/version.c	Thu Nov  6 20:46:11 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     30,
  /**/

-- 
% cat /usr/include/sys/errno.h
#define	EPERM		1		/* Operation not permitted */
#define	ENOENT		2		/* No such file or directory */
#define	ESRCH		3		/* No such process */
[...]
#define EMACS		666		/* Too many macros */
%

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.031
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.031
Problem:    Information in the viminfo file about previously edited files is
	    not available to the user.  There is no way to get a complete list
	    of files edited in previous Vim sessions.
Solution:   Add v:oldfiles and fill it with the list of old file names when
	    first reading the viminfo file.  Add the ":oldfiles" command,
	    ":browse oldfiles" and the "#<123" special file name.  Increase
	    the default value for 'viminfo' from '20 to '100.
Files:	    runtime/doc/cmdline.txt, runtime/doc/eval.txt,
	    runtime/doc/starting.txt, runtime/doc/usr_21.txt, src/eval.c,
	    src/ex_cmds.c, src/ex_cmds.h, src/ex_docmd.c, src/feature.h,
	    src/fileio.c, src/main.c, src/mark.c, src/misc1.c,
	    src/proto/eval.pro, src/proto/ex_cmds.pro, src/proto/mark.pro,
	    src/option.c, src/structs.h, src/vim.h


*** ../vim-7.2.030/runtime/doc/cmdline.txt	Sat Aug  9 19:36:46 2008
--- runtime/doc/cmdline.txt	Thu Sep 18 22:55:27 2008
***************
*** 1,4 ****
! *cmdline.txt*   For Vim version 7.2.  Last change: 2008 Jul 29
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *cmdline.txt*   For Vim version 7.2.  Last change: 2008 Sep 18
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 157,162 ****
--- 157,167 ----
  				(doesn't work at the expression prompt; some
  				things such as changing the buffer or current
  				window are not allowed to avoid side effects)
+ 				When the result is a |List| the items are used
+ 				as lines.  They can have line breaks inside
+ 				too.
+ 				When the result is a Float it's automatically
+ 				converted to a String.
  		See |registers| about registers.  {not in Vi}
  		Implementation detail: When using the |expression| register
  		and invoking setcmdpos(), this sets the position before
***************
*** 730,748 ****
  In Ex commands, at places where a file name can be used, the following
  characters have a special meaning.  These can also be used in the expression
  function expand() |expand()|.
! 	%	is replaced with the current file name			*:_%*
! 	#	is replaced with the alternate file name		*:_#*
  	#n	(where n is a number) is replaced with the file name of
! 		buffer n.  "#0" is the same as "#"
! 	##	is replaced with all names in the argument list		*:_##*
  		concatenated, separated by spaces.  Each space in a name
  		is preceded with a backslash.
! Note that these give the file name as it was typed.  If an absolute path is
! needed (when using the file name from a different directory), you need to add
! ":p".  See |filename-modifiers|.
  Note that backslashes are inserted before spaces, so that the command will
  correctly interpret the file name.  But this doesn't happen for shell
! commands.  For those you probably have to use quotes: >
  	:!ls "%"
  	:r !spell "%"
  
--- 735,763 ----
  In Ex commands, at places where a file name can be used, the following
  characters have a special meaning.  These can also be used in the expression
  function expand() |expand()|.
! 	%	Is replaced with the current file name.		  *:_%* *c_%*
! 	#	Is replaced with the alternate file name.	  *:_#* *c_#*
  	#n	(where n is a number) is replaced with the file name of
! 		buffer n.  "#0" is the same as "#".
! 	##	Is replaced with all names in the argument list	  *:_##* *c_##*
  		concatenated, separated by spaces.  Each space in a name
  		is preceded with a backslash.
! 	#<n	(where n is a number > 0) is replaced with old	  *:_#<* *c_#<*
! 		file name n.  See |:oldfiles| or |v:oldfiles| to get the
! 		number.							*E809*
! 		{only when compiled with the +eval and +viminfo features}
! 
! Note that these, except "#<n", give the file name as it was typed.  If an
! absolute path is needed (when using the file name from a different directory),
! you need to add ":p".  See |filename-modifiers|.
! 
! The "#<n" item returns an absolute path, but it will start with "~/" for files
! below your home directory.
! 
  Note that backslashes are inserted before spaces, so that the command will
  correctly interpret the file name.  But this doesn't happen for shell
! commands.  For those you probably have to use quotes (this fails for files
! that contain a quote and wildcards): >
  	:!ls "%"
  	:r !spell "%"
  
*** ../vim-7.2.030/runtime/doc/eval.txt	Sat Aug  9 19:36:47 2008
--- runtime/doc/eval.txt	Sun Nov  2 14:25:38 2008
***************
*** 1,4 ****
! *eval.txt*	For Vim version 7.2.  Last change: 2008 Aug 09
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *eval.txt*	For Vim version 7.2.  Last change: 2008 Nov 02
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 1484,1489 ****
--- 1484,1500 ----
  		This is the screen column number, like with |virtcol()|.  The
  		value is zero when there was no mouse button click.
  
+ 					*v:oldfiles* *oldfiles-variable*
+ v:oldfiles	List of file names that is loaded from the |viminfo| file on
+ 		startup.  These are the files that Vim remembers marks for.
+ 		The length of the List is limited by the ' argument of the
+ 		'viminfo' option (default is 100).
+ 		Also see |:oldfiles| and |c_#<|.
+ 		The List can be modified, but this has no effect on what is
+ 		stored in the |viminfo| file later.  If you use values other
+ 		than String this will cause trouble.
+ 		{only when compiled with the +viminfo feature}
+ 
  					*v:operator* *operator-variable*
  v:operator	The last operator given in Normal mode.  This is a single
  		character except for commands starting with <g> or <z>,
*** ../vim-7.2.030/runtime/doc/starting.txt	Sat Aug  9 19:36:52 2008
--- runtime/doc/starting.txt	Sun Nov  9 12:12:19 2008
***************
*** 1,4 ****
! *starting.txt*  For Vim version 7.2.  Last change: 2008 Jun 21
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *starting.txt*  For Vim version 7.2.  Last change: 2008 Nov 09
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 1337,1344 ****
  							*viminfo-read*
  When Vim is started and the 'viminfo' option is non-empty, the contents of
  the viminfo file are read and the info can be used in the appropriate places.
! The marks are not read in at startup (but file marks are).  See
! |initialization| for how to set the 'viminfo' option upon startup.
  
  							*viminfo-write*
  When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo
--- 1335,1343 ----
  							*viminfo-read*
  When Vim is started and the 'viminfo' option is non-empty, the contents of
  the viminfo file are read and the info can be used in the appropriate places.
! The |v:oldfiles| variable is filled.  The marks are not read in at startup
! (but file marks are).  See |initialization| for how to set the 'viminfo'
! option upon startup.
  
  							*viminfo-write*
  When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo
***************
*** 1372,1377 ****
--- 1371,1378 ----
  that start with any string given with the "r" flag in 'viminfo'.  This can be
  used to avoid saving marks for files on removable media (for MS-DOS you would
  use "ra:,rb:", for Amiga "rdf0:,rdf1:,rdf2:").
+ The |v:oldfiles| variable is filled with the file names that the viminfo file
+ has marks for.
  
  							*viminfo-file-marks*
  Uppercase marks ('A to 'Z) are stored when writing the viminfo file.  The
***************
*** 1463,1470 ****
  						   *:rv* *:rviminfo* *E195*
  :rv[iminfo][!] [file]	Read from viminfo file [file] (default: see above).
  			If [!] is given, then any information that is
! 			already set (registers, marks, etc.) will be
! 			overwritten.  {not in Vi}
  
  					*:wv* *:wviminfo* *E137* *E138* *E574*
  :wv[iminfo][!] [file]	Write to viminfo file [file] (default: see above).
--- 1464,1471 ----
  						   *:rv* *:rviminfo* *E195*
  :rv[iminfo][!] [file]	Read from viminfo file [file] (default: see above).
  			If [!] is given, then any information that is
! 			already set (registers, marks, |v:oldfiles|, etc.)
! 			will be overwritten   {not in Vi}
  
  					*:wv* *:wviminfo* *E137* *E138* *E574*
  :wv[iminfo][!] [file]	Write to viminfo file [file] (default: see above).
***************
*** 1479,1482 ****
--- 1480,1499 ----
  			the .viminfo file.
  			{not in Vi}
  
+ 						*:ol* *:oldfiles*
+ :ol[dfiles]		List the files that have marks stored in the viminfo
+ 			file.  This list is read on startup and only changes
+ 			afterwards with ":rviminfo!".  Also see |v:oldfiles|.
+ 			The number can be used with |c_#<|.
+ 			{not in Vi, only when compiled with the +eval feature}
+ 
+ :bro[wse] ol[dfiles][!]
+ 			List file names as with |:oldfiles|, and then prompt
+ 			for a number.  When the number is valid that file from
+ 			the list is edited.
+ 			If you get the |press-enter| prompt you can press "q"
+ 			and still get the prompt to enter a file number.
+ 			Use ! to abondon a modified buffer. |abandon|
+ 			{not when compiled with tiny or small features}
+ 
   vim:tw=78:ts=8:ft=help:norl:
*** ../vim-7.2.030/runtime/doc/usr_21.txt	Sat Aug  9 19:36:53 2008
--- runtime/doc/usr_21.txt	Sun Nov  9 12:14:10 2008
***************
*** 1,4 ****
! *usr_21.txt*	For Vim version 7.2.  Last change: 2007 May 01
  
  		     VIM USER MANUAL - by Bram Moolenaar
  
--- 1,4 ----
! *usr_21.txt*	For Vim version 7.2.  Last change: 2008 Nov 09
  
  		     VIM USER MANUAL - by Bram Moolenaar
  
***************
*** 153,159 ****
  to be lost.  Each item can be remembered only once.
  
  
! GETTING BACK TO WHERE YOU WERE
  
  You are halfway editing a file and it's time to leave for holidays.  You exit
  Vim and go enjoy yourselves, forgetting all about your work.  After a couple
--- 153,159 ----
  to be lost.  Each item can be remembered only once.
  
  
! GETTING BACK TO WHERE YOU STOPPED VIM
  
  You are halfway editing a file and it's time to leave for holidays.  You exit
  Vim and go enjoy yourselves, forgetting all about your work.  After a couple
***************
*** 168,173 ****
--- 168,215 ----
     The |:marks| command is useful to find out where '0 to '9 will take you.
  
  
+ GETTING BACK TO SOME FILE
+ 
+ If you want to go back to a file that you edited recently, but not when
+ exiting Vim, there is a slightly more complicated way.  You can see a list of
+ files by typing the command: >
+ 
+ 	:oldfiles
+ <	1: ~/.viminfo ~
+ 	2: ~/text/resume.txt ~
+ 	3: /tmp/draft ~
+ 
+ Now you would like to edit the second file, which is in the list preceded by
+ "2:".  You type: >
+ 
+ 	:e #<2
+ 
+ Instead of ":e" you can use any command that has a file name argument, the
+ "#<2" item works in the same place as "%" (current file name) and "#"
+ (alternate file name).  So you can also split the window to edit the third
+ file: >
+ 
+ 	:split #<3
+ 
+ That #<123 thing is a bit complicated when you just want to edit a file.
+ Fortunately there is a simpler way: >
+ 
+ 	:browse oldfiles
+ <	1: ~/.viminfo ~
+ 	2: ~/text/resume.txt ~
+ 	3: /tmp/draft ~
+ 	-- More --
+ 
+ You get the same list of files as with |:oldfiles|.  If you want to edit
+ "resume.txt" first press "q" to stop the listing.  You will get a prompt:
+ 
+ 	Type number and <Enter> (empty cancels): ~
+ 
+ Type "2" and press <Enter> to edit the second file.
+ 
+ More info at |:oldfiles|, |v:oldfiles| and |c_#<|.
+ 
+ 
  MOVE INFO FROM ONE VIM TO ANOTHER
  
  You can use the ":wviminfo" and ":rviminfo" commands to save and restore the
*** ../vim-7.2.030/src/eval.c	Thu Nov  6 11:04:50 2008
--- src/eval.c	Sun Nov  9 11:59:39 2008
***************
*** 348,353 ****
--- 348,354 ----
      {VV_NAME("mouse_col",	 VAR_NUMBER), 0},
      {VV_NAME("operator",	 VAR_STRING), VV_RO},
      {VV_NAME("searchforward",	 VAR_NUMBER), 0},
+     {VV_NAME("oldfiles",	 VAR_LIST), 0},
  };
  
  /* shorthand */
***************
*** 355,360 ****
--- 356,362 ----
  #define vv_nr		vv_di.di_tv.vval.v_number
  #define vv_float	vv_di.di_tv.vval.v_float
  #define vv_str		vv_di.di_tv.vval.v_string
+ #define vv_list		vv_di.di_tv.vval.v_list
  #define vv_tv		vv_di.di_tv
  
  /*
***************
*** 426,432 ****
  static long list_idx_of_item __ARGS((list_T *l, listitem_T *item));
  static void list_append __ARGS((list_T *l, listitem_T *item));
  static int list_append_tv __ARGS((list_T *l, typval_T *tv));
- static int list_append_string __ARGS((list_T *l, char_u *str, int len));
  static int list_append_number __ARGS((list_T *l, varnumber_T n));
  static int list_insert_tv __ARGS((list_T *l, typval_T *tv, listitem_T *item));
  static int list_extend __ARGS((list_T	*l1, list_T *l2, listitem_T *bef));
--- 428,433 ----
***************
*** 845,852 ****
  	p = &vimvars[i];
  	if (p->vv_di.di_tv.v_type == VAR_STRING)
  	{
! 	    vim_free(p->vv_di.di_tv.vval.v_string);
! 	    p->vv_di.di_tv.vval.v_string = NULL;
  	}
      }
      hash_clear(&vimvarht);
--- 846,858 ----
  	p = &vimvars[i];
  	if (p->vv_di.di_tv.v_type == VAR_STRING)
  	{
! 	    vim_free(p->vv_string);
! 	    p->vv_string = NULL;
! 	}
! 	else if (p->vv_di.di_tv.v_type == VAR_LIST)
! 	{
! 	    list_unref(p->vv_list);
! 	    p->vv_list = NULL;
  	}
      }
      hash_clear(&vimvarht);
***************
*** 6057,6062 ****
--- 6063,6087 ----
  }
  
  /*
+  * Get list item "l[idx - 1]" as a string.  Returns NULL for failure.
+  */
+     char_u *
+ list_find_str(l, idx)
+     list_T	*l;
+     long	idx;
+ {
+     listitem_T	*li;
+ 
+     li = list_find(l, idx - 1);
+     if (li == NULL)
+     {
+ 	EMSGN(_(e_listidx), idx);
+ 	return NULL;
+     }
+     return get_tv_string(&li->li_tv);
+ }
+ 
+ /*
   * Locate "item" list "l" and return its index.
   * Returns -1 when "item" is not in the list.
   */
***************
*** 6147,6153 ****
   * When "len" >= 0 use "str[len]".
   * Returns FAIL when out of memory.
   */
!     static int
  list_append_string(l, str, len)
      list_T	*l;
      char_u	*str;
--- 6172,6178 ----
   * When "len" >= 0 use "str[len]".
   * Returns FAIL when out of memory.
   */
!     int
  list_append_string(l, str, len)
      list_T	*l;
      char_u	*str;
***************
*** 6507,6512 ****
--- 6532,6540 ----
  	set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID);
      }
  
+     /* v: vars */
+     set_ref_in_ht(&vimvarht, copyID);
+ 
      /*
       * 2. Go through the list of dicts and free items without the copyID.
       */
***************
*** 6597,6603 ****
      {
  	case VAR_DICT:
  	    dd = tv->vval.v_dict;
! 	    if (dd->dv_copyID != copyID)
  	    {
  		/* Didn't see this dict yet. */
  		dd->dv_copyID = copyID;
--- 6625,6631 ----
      {
  	case VAR_DICT:
  	    dd = tv->vval.v_dict;
! 	    if (dd != NULL && dd->dv_copyID != copyID)
  	    {
  		/* Didn't see this dict yet. */
  		dd->dv_copyID = copyID;
***************
*** 6607,6613 ****
  
  	case VAR_LIST:
  	    ll = tv->vval.v_list;
! 	    if (ll->lv_copyID != copyID)
  	    {
  		/* Didn't see this list yet. */
  		ll->lv_copyID = copyID;
--- 6635,6641 ----
  
  	case VAR_LIST:
  	    ll = tv->vval.v_list;
! 	    if (ll != NULL && ll->lv_copyID != copyID)
  	    {
  		/* Didn't see this list yet. */
  		ll->lv_copyID = copyID;
***************
*** 18106,18111 ****
--- 18134,18150 ----
  }
  
  /*
+  * Get List v: variable value.  Caller must take care of reference count when
+  * needed.
+  */
+     list_T *
+ get_vim_var_list(idx)
+     int		idx;
+ {
+     return vimvars[idx].vv_list;
+ }
+ 
+ /*
   * Set v:count, v:count1 and v:prevcount.
   */
      void
***************
*** 18141,18146 ****
--- 18180,18199 ----
  }
  
  /*
+  * Set List v: variable to "val".
+  */
+     void
+ set_vim_var_list(idx, val)
+     int		idx;
+     list_T	*val;
+ {
+     list_unref(vimvars[idx].vv_list);
+     vimvars[idx].vv_list = val;
+     if (val != NULL)
+ 	++val->lv_refcount;
+ }
+ 
+ /*
   * Set v:register if needed.
   */
      void
***************
*** 21900,21905 ****
--- 21953,22014 ----
      }
  }
  
+ /*
+  * List v:oldfiles in a nice way.
+  */
+ /*ARGSUSED*/
+     void
+ ex_oldfiles(eap)
+     exarg_T	*eap;
+ {
+     list_T	*l = vimvars[VV_OLDFILES].vv_list;
+     listitem_T	*li;
+     int		nr = 0;
+ 
+     if (l == NULL)
+ 	msg((char_u *)_("No old files"));
+     else
+     {
+ 	msg_start();
+ 	msg_scroll = TRUE;
+ 	for (li = l->lv_first; li != NULL && !got_int; li = li->li_next)
+ 	{
+ 	    msg_outnum((long)++nr);
+ 	    MSG_PUTS(": ");
+ 	    msg_outtrans(get_tv_string(&li->li_tv));
+ 	    msg_putchar('\n');
+ 	    out_flush();	    /* output one line at a time */
+ 	    ui_breakcheck();
+ 	}
+ 	/* Assume "got_int" was set to truncate the listing. */
+ 	got_int = FALSE;
+ 
+ #ifdef FEAT_BROWSE_CMD
+ 	if (cmdmod.browse)
+ 	{
+ 	    quit_more = FALSE;
+ 	    nr = prompt_for_number(FALSE);
+ 	    msg_starthere();
+ 	    if (nr > 0)
+ 	    {
+ 		char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),
+ 								    (long)nr);
+ 
+ 		if (p != NULL)
+ 		{
+ 		    p = expand_env_save(p);
+ 		    eap->arg = p;
+ 		    eap->cmdidx = CMD_edit;
+ 		    cmdmod.browse = FALSE;
+ 		    do_exedit(eap, NULL);
+ 		    vim_free(p);
+ 		}
+ 	    }
+ 	}
+ #endif
+     }
+ }
+ 
  #endif /* FEAT_EVAL */
  
  
*** ../vim-7.2.030/src/ex_cmds.c	Sun Sep 14 21:40:26 2008
--- src/ex_cmds.c	Sun Sep 14 13:45:03 2008
***************
*** 24,30 ****
  static void do_filter __ARGS((linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out));
  #ifdef FEAT_VIMINFO
  static char_u *viminfo_filename __ARGS((char_u	*));
! static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int want_info, int want_marks, int force_read));
  static int viminfo_encoding __ARGS((vir_T *virp));
  static int read_viminfo_up_to_marks __ARGS((vir_T *virp, int forceit, int writing));
  #endif
--- 24,30 ----
  static void do_filter __ARGS((linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out));
  #ifdef FEAT_VIMINFO
  static char_u *viminfo_filename __ARGS((char_u	*));
! static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int flags));
  static int viminfo_encoding __ARGS((vir_T *virp));
  static int read_viminfo_up_to_marks __ARGS((vir_T *virp, int forceit, int writing));
  #endif
***************
*** 1676,1689 ****
  
  /*
   * read_viminfo() -- Read the viminfo file.  Registers etc. which are already
!  * set are not over-written unless force is TRUE. -- webb
   */
      int
! read_viminfo(file, want_info, want_marks, forceit)
!     char_u	*file;
!     int		want_info;
!     int		want_marks;
!     int		forceit;
  {
      FILE	*fp;
      char_u	*fname;
--- 1676,1687 ----
  
  /*
   * read_viminfo() -- Read the viminfo file.  Registers etc. which are already
!  * set are not over-written unless "flags" includes VIF_FORCEIT. -- webb
   */
      int
! read_viminfo(file, flags)
!     char_u	*file;	    /* file name or NULL to use default name */
!     int		flags;	    /* VIF_WANT_INFO et al. */
  {
      FILE	*fp;
      char_u	*fname;
***************
*** 1691,1697 ****
      if (no_viminfo())
  	return FAIL;
  
!     fname = viminfo_filename(file);	    /* may set to default if NULL */
      if (fname == NULL)
  	return FAIL;
      fp = mch_fopen((char *)fname, READBIN);
--- 1689,1695 ----
      if (no_viminfo())
  	return FAIL;
  
!     fname = viminfo_filename(file);	/* get file name in allocated buffer */
      if (fname == NULL)
  	return FAIL;
      fp = mch_fopen((char *)fname, READBIN);
***************
*** 1701,1708 ****
  	verbose_enter();
  	smsg((char_u *)_("Reading viminfo file \"%s\"%s%s%s"),
  		fname,
! 		want_info ? _(" info") : "",
! 		want_marks ? _(" marks") : "",
  		fp == NULL ? _(" FAILED") : "");
  	verbose_leave();
      }
--- 1699,1707 ----
  	verbose_enter();
  	smsg((char_u *)_("Reading viminfo file \"%s\"%s%s%s"),
  		fname,
! 		(flags & VIF_WANT_INFO) ? _(" info") : "",
! 		(flags & VIF_WANT_MARKS) ? _(" marks") : "",
! 		(flags & VIF_GET_OLDFILES) ? _(" oldfiles") : "",
  		fp == NULL ? _(" FAILED") : "");
  	verbose_leave();
      }
***************
*** 1712,1721 ****
  	return FAIL;
  
      viminfo_errcnt = 0;
!     do_viminfo(fp, NULL, want_info, want_marks, forceit);
  
      fclose(fp);
- 
      return OK;
  }
  
--- 1711,1719 ----
  	return FAIL;
  
      viminfo_errcnt = 0;
!     do_viminfo(fp, NULL, flags);
  
      fclose(fp);
      return OK;
  }
  
***************
*** 1968,1974 ****
      }
  
      viminfo_errcnt = 0;
!     do_viminfo(fp_in, fp_out, !forceit, !forceit, FALSE);
  
      fclose(fp_out);	    /* errors are ignored !? */
      if (fp_in != NULL)
--- 1966,1972 ----
      }
  
      viminfo_errcnt = 0;
!     do_viminfo(fp_in, fp_out, forceit ? 0 : (VIF_WANT_INFO | VIF_WANT_MARKS));
  
      fclose(fp_out);	    /* errors are ignored !? */
      if (fp_in != NULL)
***************
*** 2041,2052 ****
   * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
   */
      static void
! do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)
      FILE	*fp_in;
      FILE	*fp_out;
!     int		want_info;
!     int		want_marks;
!     int		force_read;
  {
      int		count = 0;
      int		eof = FALSE;
--- 2039,2048 ----
   * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
   */
      static void
! do_viminfo(fp_in, fp_out, flags)
      FILE	*fp_in;
      FILE	*fp_out;
!     int		flags;
  {
      int		count = 0;
      int		eof = FALSE;
***************
*** 2061,2068 ****
  
      if (fp_in != NULL)
      {
! 	if (want_info)
! 	    eof = read_viminfo_up_to_marks(&vir, force_read, fp_out != NULL);
  	else
  	    /* Skip info, find start of marks */
  	    while (!(eof = viminfo_readline(&vir))
--- 2057,2065 ----
  
      if (fp_in != NULL)
      {
! 	if (flags & VIF_WANT_INFO)
! 	    eof = read_viminfo_up_to_marks(&vir,
! 					 flags & VIF_FORCEIT, fp_out != NULL);
  	else
  	    /* Skip info, find start of marks */
  	    while (!(eof = viminfo_readline(&vir))
***************
*** 2092,2099 ****
  	write_viminfo_bufferlist(fp_out);
  	count = write_viminfo_marks(fp_out);
      }
!     if (fp_in != NULL && want_marks)
! 	copy_viminfo_marks(&vir, fp_out, count, eof);
  
      vim_free(vir.vir_line);
  #ifdef FEAT_MBYTE
--- 2089,2097 ----
  	write_viminfo_bufferlist(fp_out);
  	count = write_viminfo_marks(fp_out);
      }
!     if (fp_in != NULL
! 	    && (flags & (VIF_WANT_MARKS | VIF_GET_OLDFILES | VIF_FORCEIT)))
! 	copy_viminfo_marks(&vir, fp_out, count, eof, flags);
  
      vim_free(vir.vir_line);
  #ifdef FEAT_MBYTE
*** ../vim-7.2.030/src/ex_cmds.h	Thu Nov  6 20:47:00 2008
--- src/ex_cmds.h	Thu Sep 18 22:18:14 2008
***************
*** 653,658 ****
--- 653,660 ----
  			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
  EX(CMD_open,		"open",		ex_open,
  			RANGE|EXTRA),
+ EX(CMD_oldfiles,	"oldfiles",	ex_oldfiles,
+ 			BANG|TRLBAR|SBOXOK|CMDWIN),
  EX(CMD_omap,		"omap",		ex_map,
  			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
  EX(CMD_omapclear,	"omapclear",	ex_mapclear,
*** ../vim-7.2.030/src/ex_docmd.c	Thu Nov  6 17:16:06 2008
--- src/ex_docmd.c	Mon Nov  3 21:21:17 2008
***************
*** 364,369 ****
--- 364,370 ----
  # define ex_function		ex_ni
  # define ex_delfunction		ex_ni
  # define ex_return		ex_ni
+ # define ex_oldfiles		ex_ni
  #endif
  static char_u	*arg_all __ARGS((void));
  #ifdef FEAT_SESSION
***************
*** 1770,1776 ****
  			}
  			if (checkforcmd(&ea.cmd, "browse", 3))
  			{
! #ifdef FEAT_BROWSE
  			    cmdmod.browse = TRUE;
  #endif
  			    continue;
--- 1771,1777 ----
  			}
  			if (checkforcmd(&ea.cmd, "browse", 3))
  			{
! #ifdef FEAT_BROWSE_CMD
  			    cmdmod.browse = TRUE;
  #endif
  			    continue;
***************
*** 9508,9531 ****
  		    break;
  		}
  		s = src + 1;
  		i = (int)getdigits(&s);
  		*usedlen = (int)(s - src); /* length of what we expand */
  
! 		buf = buflist_findnr(i);
! 		if (buf == NULL)
  		{
! 		    *errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
  		    return NULL;
  		}
! 		if (lnump != NULL)
! 		    *lnump = ECMD_LAST;
! 		if (buf->b_fname == NULL)
  		{
! 		    result = (char_u *)"";
! 		    valid = 0;	    /* Must have ":p:h" to be valid */
  		}
- 		else
- 		    result = buf->b_fname;
  		break;
  
  #ifdef FEAT_SEARCHPATH
--- 9509,9558 ----
  		    break;
  		}
  		s = src + 1;
+ 		if (*s == '<')		/* "#<99" uses v:oldfiles */
+ 		    ++s;
  		i = (int)getdigits(&s);
  		*usedlen = (int)(s - src); /* length of what we expand */
  
! 		if (src[1] == '<')
  		{
! 		    if (*usedlen < 2)
! 		    {
! 			/* Should we give an error message for #<text? */
! 			*usedlen = 1;
! 			return NULL;
! 		    }
! #ifdef FEAT_EVAL
! 		    result = list_find_str(get_vim_var_list(VV_OLDFILES),
! 								     (long)i);
! 		    if (result == NULL)
! 		    {
! 			*errormsg = (char_u *)"";
! 			return NULL;
! 		    }
! #else
! 		    *errormsg = (char_u *)_("E809: #< is not available without the +eval feature");
  		    return NULL;
+ #endif
  		}
! 		else
  		{
! 		    buf = buflist_findnr(i);
! 		    if (buf == NULL)
! 		    {
! 			*errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
! 			return NULL;
! 		    }
! 		    if (lnump != NULL)
! 			*lnump = ECMD_LAST;
! 		    if (buf->b_fname == NULL)
! 		    {
! 			result = (char_u *)"";
! 			valid = 0;	    /* Must have ":p:h" to be valid */
! 		    }
! 		    else
! 			result = buf->b_fname;
  		}
  		break;
  
  #ifdef FEAT_SEARCHPATH
***************
*** 10700,10706 ****
  	p_viminfo = (char_u *)"'100";
      if (eap->cmdidx == CMD_rviminfo)
      {
! 	if (read_viminfo(eap->arg, TRUE, TRUE, eap->forceit) == FAIL)
  	    EMSG(_("E195: Cannot open viminfo file for reading"));
      }
      else
--- 10727,10734 ----
  	p_viminfo = (char_u *)"'100";
      if (eap->cmdidx == CMD_rviminfo)
      {
! 	if (read_viminfo(eap->arg, VIF_WANT_INFO | VIF_WANT_MARKS
! 				  | (eap->forceit ? VIF_FORCEIT : 0)) == FAIL)
  	    EMSG(_("E195: Cannot open viminfo file for reading"));
      }
      else
*** ../vim-7.2.030/src/feature.h	Wed Aug  6 18:45:07 2008
--- src/feature.h	Fri Sep 19 19:14:22 2008
***************
*** 767,775 ****
  
  /*
   * +browse		":browse" command.
   */
! #if defined(FEAT_NORMAL) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC))
! # define FEAT_BROWSE
  #endif
  
  /*
--- 767,779 ----
  
  /*
   * +browse		":browse" command.
+  *			or just the ":browse" command modifier
   */
! #if defined(FEAT_NORMAL)
! # define FEAT_BROWSE_CMD
! # if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
! #  define FEAT_BROWSE
! # endif
  #endif
  
  /*
*** ../vim-7.2.030/src/fileio.c	Thu Sep 18 21:29:07 2008
--- src/fileio.c	Mon Nov  3 21:21:47 2008
***************
*** 2711,2717 ****
  {
      if (!curbuf->b_marks_read && get_viminfo_parameter('\'') > 0
  						  && curbuf->b_ffname != NULL)
! 	read_viminfo(NULL, FALSE, TRUE, FALSE);
  
      /* Always set b_marks_read; needed when 'viminfo' is changed to include
       * the ' parameter after opening a buffer. */
--- 2711,2717 ----
  {
      if (!curbuf->b_marks_read && get_viminfo_parameter('\'') > 0
  						  && curbuf->b_ffname != NULL)
! 	read_viminfo(NULL, VIF_WANT_MARKS);
  
      /* Always set b_marks_read; needed when 'viminfo' is changed to include
       * the ' parameter after opening a buffer. */
***************
*** 9108,9114 ****
  set_context_in_autocmd(xp, arg, doautocmd)
      expand_T	*xp;
      char_u	*arg;
!     int		doautocmd;	/* TRUE for :doautocmd, FALSE for :autocmd */
  {
      char_u	*p;
      int		group;
--- 9109,9115 ----
  set_context_in_autocmd(xp, arg, doautocmd)
      expand_T	*xp;
      char_u	*arg;
!     int		doautocmd;	/* TRUE for :doauto*, FALSE for :autocmd */
  {
      char_u	*p;
      int		group;
*** ../vim-7.2.030/src/main.c	Thu Sep 18 20:55:19 2008
--- src/main.c	Sun Sep 14 13:26:10 2008
***************
*** 645,655 ****
  
  #ifdef FEAT_VIMINFO
      /*
!      * Read in registers, history etc, but not marks, from the viminfo file
       */
      if (*p_viminfo != NUL)
      {
! 	read_viminfo(NULL, TRUE, FALSE, FALSE);
  	TIME_MSG("reading viminfo");
      }
  #endif
--- 645,656 ----
  
  #ifdef FEAT_VIMINFO
      /*
!      * Read in registers, history etc, but not marks, from the viminfo file.
!      * This is where v:oldfiles gets filled.
       */
      if (*p_viminfo != NUL)
      {
! 	read_viminfo(NULL, VIF_WANT_INFO | VIF_GET_OLDFILES);
  	TIME_MSG("reading viminfo");
      }
  #endif
*** ../vim-7.2.030/src/mark.c	Sat Aug  9 19:37:29 2008
--- src/mark.c	Sun Sep 14 13:46:19 2008
***************
*** 1627,1641 ****
  
  /*
   * Handle marks in the viminfo file:
!  * fp_out == NULL   read marks for current buffer only
!  * fp_out != NULL   copy marks for buffers not in buffer list
   */
      void
! copy_viminfo_marks(virp, fp_out, count, eof)
      vir_T	*virp;
      FILE	*fp_out;
      int		count;
      int		eof;
  {
      char_u	*line = virp->vir_line;
      buf_T	*buf;
--- 1627,1643 ----
  
  /*
   * Handle marks in the viminfo file:
!  * fp_out != NULL: copy marks for buffers not in buffer list
!  * fp_out == NULL && (flags & VIF_WANT_MARKS): read marks for curbuf only
!  * fp_out == NULL && (flags & VIF_GET_OLDFILES | VIF_FORCEIT): fill v:oldfiles
   */
      void
! copy_viminfo_marks(virp, fp_out, count, eof, flags)
      vir_T	*virp;
      FILE	*fp_out;
      int		count;
      int		eof;
+     int		flags;
  {
      char_u	*line = virp->vir_line;
      buf_T	*buf;
***************
*** 1647,1656 ****
--- 1649,1671 ----
      char_u	*p;
      char_u	*name_buf;
      pos_T	pos;
+ #ifdef FEAT_EVAL
+     list_T	*list = NULL;
+ #endif
  
      if ((name_buf = alloc(LSIZE)) == NULL)
  	return;
      *name_buf = NUL;
+ 
+ #ifdef FEAT_EVAL
+     if (fp_out == NULL && (flags & (VIF_GET_OLDFILES | VIF_FORCEIT)))
+     {
+ 	list = list_alloc();
+ 	if (list != NULL)
+ 	    set_vim_var_list(VV_OLDFILES, list);
+     }
+ #endif
+ 
      num_marked_files = get_viminfo_parameter('\'');
      while (!eof && (count < num_marked_files || fp_out == NULL))
      {
***************
*** 1681,1686 ****
--- 1696,1706 ----
  	    p++;
  	*p = NUL;
  
+ #ifdef FEAT_EVAL
+ 	if (list != NULL)
+ 	    list_append_string(list, str, -1);
+ #endif
+ 
  	/*
  	 * If fp_out == NULL, load marks for current buffer.
  	 * If fp_out != NULL, copy marks for buffers not in buflist.
***************
*** 1688,1694 ****
  	load_marks = copy_marks_out = FALSE;
  	if (fp_out == NULL)
  	{
! 	    if (curbuf->b_ffname != NULL)
  	    {
  		if (*name_buf == NUL)	    /* only need to do this once */
  		    home_replace(NULL, curbuf->b_ffname, name_buf, LSIZE, TRUE);
--- 1708,1714 ----
  	load_marks = copy_marks_out = FALSE;
  	if (fp_out == NULL)
  	{
! 	    if ((flags & VIF_WANT_MARKS) && curbuf->b_ffname != NULL)
  	    {
  		if (*name_buf == NUL)	    /* only need to do this once */
  		    home_replace(NULL, curbuf->b_ffname, name_buf, LSIZE, TRUE);
*** ../vim-7.2.030/src/misc1.c	Wed Jun 25 00:24:52 2008
--- src/misc1.c	Sun Nov  9 11:47:00 2008
***************
*** 3245,3253 ****
  
      /* When using ":silent" assume that <CR> was entered. */
      if (mouse_used != NULL)
! 	MSG_PUTS(_("Type number or click with mouse (<Enter> cancels): "));
      else
! 	MSG_PUTS(_("Choice number (<Enter> cancels): "));
  
      /* Set the state such that text can be selected/copied/pasted and we still
       * get mouse events. */
--- 3245,3253 ----
  
      /* When using ":silent" assume that <CR> was entered. */
      if (mouse_used != NULL)
! 	MSG_PUTS(_("Type number and <Enter> or click with mouse (empty cancels): "));
      else
! 	MSG_PUTS(_("Type number and <Enter> (empty cancels): "));
  
      /* Set the state such that text can be selected/copied/pasted and we still
       * get mouse events. */
*** ../vim-7.2.030/src/proto/eval.pro	Sun Jan  6 20:06:30 2008
--- src/proto/eval.pro	Sun Nov  9 12:05:56 2008
***************
*** 17,23 ****
  int eval_to_bool __ARGS((char_u *arg, int *error, char_u **nextcmd, int skip));
  char_u *eval_to_string_skip __ARGS((char_u *arg, char_u **nextcmd, int skip));
  int skip_expr __ARGS((char_u **pp));
! char_u *eval_to_string __ARGS((char_u *arg, char_u **nextcmd, int dolist));
  char_u *eval_to_string_safe __ARGS((char_u *arg, char_u **nextcmd, int use_sandbox));
  int eval_to_number __ARGS((char_u *expr));
  list_T *eval_spell_expr __ARGS((char_u *badword, char_u *expr));
--- 17,23 ----
  int eval_to_bool __ARGS((char_u *arg, int *error, char_u **nextcmd, int skip));
  char_u *eval_to_string_skip __ARGS((char_u *arg, char_u **nextcmd, int skip));
  int skip_expr __ARGS((char_u **pp));
! char_u *eval_to_string __ARGS((char_u *arg, char_u **nextcmd, int convert));
  char_u *eval_to_string_safe __ARGS((char_u *arg, char_u **nextcmd, int use_sandbox));
  int eval_to_number __ARGS((char_u *expr));
  list_T *eval_spell_expr __ARGS((char_u *badword, char_u *expr));
***************
*** 46,52 ****
--- 46,54 ----
  void list_unref __ARGS((list_T *l));
  void list_free __ARGS((list_T *l, int recurse));
  dictitem_T *dict_lookup __ARGS((hashitem_T *hi));
+ char_u *list_find_str __ARGS((list_T *l, long idx));
  int list_append_dict __ARGS((list_T *list, dict_T *dict));
+ int list_append_string __ARGS((list_T *l, char_u *str, int len));
  int garbage_collect __ARGS((void));
  dict_T *dict_alloc __ARGS((void));
  int dict_add_nr_str __ARGS((dict_T *d, char *key, long nr, char_u *str));
***************
*** 58,65 ****
--- 60,69 ----
  void set_vim_var_nr __ARGS((int idx, long val));
  long get_vim_var_nr __ARGS((int idx));
  char_u *get_vim_var_str __ARGS((int idx));
+ list_T *get_vim_var_list __ARGS((int idx));
  void set_vcount __ARGS((long count, long count1));
  void set_vim_var_string __ARGS((int idx, char_u *val, int len));
+ void set_vim_var_list __ARGS((int idx, list_T *val));
  void set_reg_var __ARGS((int c));
  char_u *v_exception __ARGS((char_u *oldval));
  char_u *v_throwpoint __ARGS((char_u *oldval));
***************
*** 94,99 ****
--- 98,104 ----
  void write_viminfo_varlist __ARGS((FILE *fp));
  int store_session_globals __ARGS((FILE *fd));
  void last_set_msg __ARGS((scid_T scriptID));
+ void ex_oldfiles __ARGS((exarg_T *eap));
  int modify_fname __ARGS((char_u *src, int *usedlen, char_u **fnamep, char_u **bufp, int *fnamelen));
  char_u *do_string_sub __ARGS((char_u *str, char_u *pat, char_u *sub, char_u *flags));
  /* vim: set ft=c : */
*** ../vim-7.2.030/src/proto/ex_cmds.pro	Sat May  5 20:13:58 2007
--- src/proto/ex_cmds.pro	Sat Sep 13 17:27:21 2008
***************
*** 11,17 ****
  char_u *make_filter_cmd __ARGS((char_u *cmd, char_u *itmp, char_u *otmp));
  void append_redir __ARGS((char_u *buf, char_u *opt, char_u *fname));
  int viminfo_error __ARGS((char *errnum, char *message, char_u *line));
! int read_viminfo __ARGS((char_u *file, int want_info, int want_marks, int forceit));
  void write_viminfo __ARGS((char_u *file, int forceit));
  int viminfo_readline __ARGS((vir_T *virp));
  char_u *viminfo_readstring __ARGS((vir_T *virp, int off, int convert));
--- 11,17 ----
  char_u *make_filter_cmd __ARGS((char_u *cmd, char_u *itmp, char_u *otmp));
  void append_redir __ARGS((char_u *buf, char_u *opt, char_u *fname));
  int viminfo_error __ARGS((char *errnum, char *message, char_u *line));
! int read_viminfo __ARGS((char_u *file, int flags));
  void write_viminfo __ARGS((char_u *file, int forceit));
  int viminfo_readline __ARGS((vir_T *virp));
  char_u *viminfo_readstring __ARGS((vir_T *virp, int off, int convert));
*** ../vim-7.2.030/src/proto/mark.pro	Sat May  5 19:29:37 2007
--- src/proto/mark.pro	Sat Sep 13 18:06:20 2008
***************
*** 26,30 ****
  void write_viminfo_filemarks __ARGS((FILE *fp));
  int removable __ARGS((char_u *name));
  int write_viminfo_marks __ARGS((FILE *fp_out));
! void copy_viminfo_marks __ARGS((vir_T *virp, FILE *fp_out, int count, int eof));
  /* vim: set ft=c : */
--- 26,30 ----
  void write_viminfo_filemarks __ARGS((FILE *fp));
  int removable __ARGS((char_u *name));
  int write_viminfo_marks __ARGS((FILE *fp_out));
! void copy_viminfo_marks __ARGS((vir_T *virp, FILE *fp_out, int count, int eof, int flags));
  /* vim: set ft=c : */
*** ../vim-7.2.030/src/option.c	Thu Oct  2 22:48:01 2008
--- src/option.c	Fri Sep 26 22:20:20 2008
***************
*** 2593,2605 ****
  #ifdef FEAT_VIMINFO
  			    (char_u *)&p_viminfo, PV_NONE,
  #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
! 			    {(char_u *)"", (char_u *)"'20,<50,s10,h,rA:,rB:"}
  #else
  # ifdef AMIGA
  			    {(char_u *)"",
! 				 (char_u *)"'20,<50,s10,h,rdf0:,rdf1:,rdf2:"}
  # else
! 			    {(char_u *)"", (char_u *)"'20,<50,s10,h"}
  # endif
  #endif
  #else
--- 2593,2605 ----
  #ifdef FEAT_VIMINFO
  			    (char_u *)&p_viminfo, PV_NONE,
  #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
! 			    {(char_u *)"", (char_u *)"'100,<50,s10,h,rA:,rB:"}
  #else
  # ifdef AMIGA
  			    {(char_u *)"",
! 				 (char_u *)"'100,<50,s10,h,rdf0:,rdf1:,rdf2:"}
  # else
! 			    {(char_u *)"", (char_u *)"'100,<50,s10,h"}
  # endif
  #endif
  #else
*** ../vim-7.2.030/src/structs.h	Thu Jul 31 22:04:27 2008
--- src/structs.h	Fri Sep 19 19:15:18 2008
***************
*** 459,465 ****
  typedef struct
  {
      int		hide;			/* TRUE when ":hide" was used */
! # ifdef FEAT_BROWSE
      int		browse;			/* TRUE to invoke file dialog */
  # endif
  # ifdef FEAT_WINDOWS
--- 459,465 ----
  typedef struct
  {
      int		hide;			/* TRUE when ":hide" was used */
! # ifdef FEAT_BROWSE_CMD
      int		browse;			/* TRUE to invoke file dialog */
  # endif
  # ifdef FEAT_WINDOWS
*** ../vim-7.2.030/src/vim.h	Sat Aug  9 19:37:40 2008
--- src/vim.h	Sat Sep 13 17:41:24 2008
***************
*** 1728,1734 ****
  #define VV_MOUSE_COL	51
  #define VV_OP		52
  #define VV_SEARCHFORWARD 53
! #define VV_LEN		54	/* number of v: vars */
  
  #ifdef FEAT_CLIPBOARD
  
--- 1728,1735 ----
  #define VV_MOUSE_COL	51
  #define VV_OP		52
  #define VV_SEARCHFORWARD 53
! #define VV_OLDFILES	54
! #define VV_LEN		55	/* number of v: vars */
  
  #ifdef FEAT_CLIPBOARD
  
***************
*** 2054,2057 ****
--- 2055,2064 ----
  #define DOSO_VIMRC	1	/* loading vimrc file */
  #define DOSO_GVIMRC	2	/* loading gvimrc file */
  
+ /* flags for read_viminfo() and children */
+ #define VIF_WANT_INFO		1	/* load non-mark info */
+ #define VIF_WANT_MARKS		2	/* load file marks */
+ #define VIF_FORCEIT		4	/* overwrite info already read */
+ #define VIF_GET_OLDFILES	8	/* load v:oldfiles */
+ 
  #endif /* VIM__H */
*** ../vim-7.2.030/src/version.c	Thu Nov  6 20:47:00 2008
--- src/version.c	Sun Nov  9 13:39:19 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     31,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
217. Your sex life has drastically improved...so what if it's only cyber-sex!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.032
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.032 (after 7.2.031)
Problem:    Can't build with EXITFREE defined. (Dominique Pelle)
Solution:   Change vv_string to vv_str.
Files:	    src/eval.c


*** ../vim-7.2.031/src/eval.c	Sun Nov  9 13:43:25 2008
--- src/eval.c	Sun Nov  9 17:16:06 2008
***************
*** 846,853 ****
  	p = &vimvars[i];
  	if (p->vv_di.di_tv.v_type == VAR_STRING)
  	{
! 	    vim_free(p->vv_string);
! 	    p->vv_string = NULL;
  	}
  	else if (p->vv_di.di_tv.v_type == VAR_LIST)
  	{
--- 846,853 ----
  	p = &vimvars[i];
  	if (p->vv_di.di_tv.v_type == VAR_STRING)
  	{
! 	    vim_free(p->vv_str);
! 	    p->vv_str = NULL;
  	}
  	else if (p->vv_di.di_tv.v_type == VAR_LIST)
  	{
*** ../vim-7.2.031/src/version.c	Sun Nov  9 13:43:25 2008
--- src/version.c	Sun Nov  9 17:21:00 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     32,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
218. Your spouse hands you a gift wrapped magnet with your PC's name
     on it and you accuse him or her of genocide.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.033
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.033
Problem:    When detecting a little endian BOM "ucs-2le" is used, but the text
	    might be "utf-16le".
Solution:   Default to "utf-16le", it also works for "ucs-2le". (Jia Yanwei)
Files:	    src/fileio.c, src/testdir/test42.ok


*** ../vim-7.2.032/src/fileio.c	Sun Nov  9 13:43:25 2008
--- src/fileio.c	Mon Nov  3 21:21:47 2008
***************
*** 5550,5558 ****
  	    name = "ucs-4le";	/* FF FE 00 00 */
  	    len = 4;
  	}
! 	else if (flags == FIO_ALL || flags == (FIO_UCS2 | FIO_ENDIAN_L))
  	    name = "ucs-2le";	/* FF FE */
! 	else if (flags == (FIO_UTF16 | FIO_ENDIAN_L))
  	    name = "utf-16le";	/* FF FE */
      }
      else if (p[0] == 0xfe && p[1] == 0xff
--- 5550,5559 ----
  	    name = "ucs-4le";	/* FF FE 00 00 */
  	    len = 4;
  	}
! 	else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))
  	    name = "ucs-2le";	/* FF FE */
! 	else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))
! 	    /* utf-16le is preferred, it also works for ucs-2le text */
  	    name = "utf-16le";	/* FF FE */
      }
      else if (p[0] == 0xfe && p[1] == 0xff
*** ../vim-7.2.032/src/testdir/test42.ok	Sat Mar  1 13:49:21 2008
--- src/testdir/test42.ok	Sat Nov  1 17:09:29 2008
***************
*** 20,26 ****
  ucs-2
  
  
!   fileencoding=ucs-2le
    bomb
  ucs-2le
  
--- 20,26 ----
  ucs-2
  
  
!   fileencoding=utf-16le
    bomb
  ucs-2le
  
*** ../vim-7.2.032/src/version.c	Sun Nov  9 17:21:10 2008
--- src/version.c	Tue Nov 11 21:54:14 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     33,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
234. You started college as a chemistry major, and walk out four years
     later as an Internet provider.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.034
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.034
Problem:    Memory leak in spell info when deleting buffer.
Solution:   Free the memory. (Dominique Pelle)
Files:	    src/buffer.c


*** ../vim-7.2.033/src/buffer.c	Mon Sep  1 17:32:40 2008
--- src/buffer.c	Wed Nov 12 11:21:49 2008
***************
*** 647,652 ****
--- 647,655 ----
      vim_free(buf->b_start_fenc);
      buf->b_start_fenc = NULL;
  #endif
+ #ifdef FEAT_SPELL
+     ga_clear(&buf->b_langp);
+ #endif
  }
  
  /*
***************
*** 1237,1243 ****
  	 * "buf" if one exists */
  	if ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))
  	    return OK;
! 	/* If 'switchbuf' contians "usetab": jump to first window in any tab
  	 * page containing "buf" if one exists */
  	if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))
  	    return OK;
--- 1240,1246 ----
  	 * "buf" if one exists */
  	if ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))
  	    return OK;
! 	/* If 'switchbuf' contains "usetab": jump to first window in any tab
  	 * page containing "buf" if one exists */
  	if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))
  	    return OK;
***************
*** 3964,3970 ****
      width = vim_strsize(out);
      if (maxwidth > 0 && width > maxwidth)
      {
! 	/* Result is too long, must trunctate somewhere. */
  	l = 0;
  	if (itemcnt == 0)
  	    s = out;
--- 3967,3973 ----
      width = vim_strsize(out);
      if (maxwidth > 0 && width > maxwidth)
      {
! 	/* Result is too long, must truncate somewhere. */
  	l = 0;
  	if (itemcnt == 0)
  	    s = out;
*** ../vim-7.2.033/src/version.c	Tue Nov 11 21:55:29 2008
--- src/version.c	Wed Nov 12 12:51:21 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     34,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
236. You start saving URL's in your digital watch.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.035
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.035
Problem:    Mismatches between alloc/malloc, free/vim_free,
	    realloc/vim_realloc.
Solution:   Use the right function. (Dominique Pelle)
Files:	    src/gui_x11.c, src/mbyte.c, src/misc2.c, src/os_unix.c


*** ../vim-7.2.034/src/gui_x11.c	Fri Jun 20 11:59:25 2008
--- src/gui_x11.c	Wed Nov 12 11:47:03 2008
***************
*** 2450,2456 ****
  	*colorPtr = colortable[closest];
      }
  
!     free(colortable);
      return OK;
  }
  
--- 2450,2456 ----
  	*colorPtr = colortable[closest];
      }
  
!     vim_free(colortable);
      return OK;
  }
  
*** ../vim-7.2.034/src/mbyte.c	Sat Sep  6 16:44:06 2008
--- src/mbyte.c	Wed Nov 12 11:24:14 2008
***************
*** 5384,5390 ****
  			draw_feedback = (char *)alloc(draw_data->chg_first
  							      + text->length);
  		    else
! 			draw_feedback = realloc(draw_feedback,
  					 draw_data->chg_first + text->length);
  		    if (draw_feedback != NULL)
  		    {
--- 5384,5390 ----
  			draw_feedback = (char *)alloc(draw_data->chg_first
  							      + text->length);
  		    else
! 			draw_feedback = vim_realloc(draw_feedback,
  					 draw_data->chg_first + text->length);
  		    if (draw_feedback != NULL)
  		    {
*** ../vim-7.2.034/src/misc2.c	Sat Sep  6 16:44:06 2008
--- src/misc2.c	Wed Nov 12 11:42:51 2008
***************
*** 873,879 ****
  	    /* 3. check for available memory: call mch_avail_mem() */
  	    if (mch_avail_mem(TRUE) < KEEP_ROOM && !releasing)
  	    {
! 		vim_free((char *)p);	/* System is low... no go! */
  		p = NULL;
  	    }
  	    else
--- 873,879 ----
  	    /* 3. check for available memory: call mch_avail_mem() */
  	    if (mch_avail_mem(TRUE) < KEEP_ROOM && !releasing)
  	    {
! 		free((char *)p);	/* System is low... no go! */
  		p = NULL;
  	    }
  	    else
*** ../vim-7.2.034/src/os_unix.c	Wed Aug  6 18:45:01 2008
--- src/os_unix.c	Wed Nov 12 11:55:33 2008
***************
*** 2905,2911 ****
       * Ignore any errors.
       */
  #if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
!     signal_stack = malloc(SIGSTKSZ);
      init_signal_stack();
  #endif
  }
--- 2905,2911 ----
       * Ignore any errors.
       */
  #if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
!     signal_stack = (char *)alloc(SIGSTKSZ);
      init_signal_stack();
  #endif
  }
***************
*** 6814,6820 ****
      if (xsmp_icefd != -1)
      {
  	SmcCloseConnection(xsmp.smcconn, 0, NULL);
! 	vim_free(xsmp.clientid);
  	xsmp.clientid = NULL;
  	xsmp_icefd = -1;
      }
--- 6815,6822 ----
      if (xsmp_icefd != -1)
      {
  	SmcCloseConnection(xsmp.smcconn, 0, NULL);
! 	if (xsmp.clientid != NULL)
! 	    free(xsmp.clientid);
  	xsmp.clientid = NULL;
  	xsmp_icefd = -1;
      }
*** ../vim-7.2.034/src/version.c	Wed Nov 12 12:51:38 2008
--- src/version.c	Wed Nov 12 13:05:40 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     35,
  /**/

-- 
You can tune a file system, but you can't tuna fish
							-- man tunefs

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.036 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.036 (extra)
Problem:    Mismatches between alloc/malloc, free/vim_free,
	    realloc/vim_realloc.
Solution:   Use the right function. (Dominique Pelle)
Files:	    src/gui_riscos.c, src/gui_w48.c, src/mbyte.c, src/os_vms.c,
	    src/os_w32exe.c, src/os_win16.c


*** ../vim-7.2.035/src/gui_riscos.c	Thu May 10 19:33:26 2007
--- src/gui_riscos.c	Wed Nov 12 11:47:54 2008
***************
*** 695,701 ****
  gui_mch_set_shellsize(width, height, min_width, min_height, base_width, base_height, direction)
      int width;		/* In OS units */
      int height;
!     int min_width;	/* Smallest permissable window size (ignored) */
      int min_height;
      int base_width;	/* Space for scroll bars, etc */
      int base_height;
--- 695,701 ----
  gui_mch_set_shellsize(width, height, min_width, min_height, base_width, base_height, direction)
      int width;		/* In OS units */
      int height;
!     int min_width;	/* Smallest permissible window size (ignored) */
      int min_height;
      int base_width;	/* Space for scroll bars, etc */
      int base_height;
***************
*** 863,869 ****
      if (strncmp(file, "ZapFont\015", 8) == 0)
  	return file;	/* Loaded OK! */
  
!     free(file);
      return NULL;	/* Not a valid font file */
  }
  
--- 863,869 ----
      if (strncmp(file, "ZapFont\015", 8) == 0)
  	return file;	/* Loaded OK! */
  
!     vim_free(file);
      return NULL;	/* Not a valid font file */
  }
  
*** ../vim-7.2.035/src/gui_w48.c	Thu Jul 24 20:50:23 2008
--- src/gui_w48.c	Wed Nov 12 11:37:41 2008
***************
*** 3335,3341 ****
  
  /*
   * Convert the string s to the proper format for a filter string by replacing
!  * the \t and \n delimeters with \0.
   * Returns the converted string in allocated memory.
   *
   * Keep in sync with convert_filterW() above!
--- 3335,3341 ----
  
  /*
   * Convert the string s to the proper format for a filter string by replacing
!  * the \t and \n delimiters with \0.
   * Returns the converted string in allocated memory.
   *
   * Keep in sync with convert_filterW() above!
***************
*** 3674,3680 ****
   * Use "prog" as the name of the program and "cmdline" as the arguments.
   * Copy the arguments to allocated memory.
   * Return the number of arguments (including program name).
!  * Return pointers to the arguments in "argvp".
   * Return pointer to buffer in "tofree".
   * Returns zero when out of memory.
   */
--- 3674,3681 ----
   * Use "prog" as the name of the program and "cmdline" as the arguments.
   * Copy the arguments to allocated memory.
   * Return the number of arguments (including program name).
!  * Return pointers to the arguments in "argvp".  Memory is allocated with
!  * malloc(), use free() instead of vim_free().
   * Return pointer to buffer in "tofree".
   * Returns zero when out of memory.
   */
***************
*** 3692,3697 ****
--- 3693,3700 ----
      char	**argv = NULL;
      int		round;
  
+     *tofree = NULL;
+ 
  #ifdef FEAT_MBYTE
      /* Try using the Unicode version first, it takes care of conversion when
       * 'encoding' is changed. */
***************
*** 3802,3816 ****
  	    argv = (char **)malloc((argc + 1) * sizeof(char *));
  	    if (argv == NULL )
  	    {
! 		vim_free(newcmdline);
  		return 0;		   /* malloc error */
  	    }
  	    pnew = newcmdline;
  	}
      }
  
  done:
- 
      argv[argc] = NULL;		/* NULL-terminated list */
      *argvp = argv;
      return argc;
--- 3805,3819 ----
  	    argv = (char **)malloc((argc + 1) * sizeof(char *));
  	    if (argv == NULL )
  	    {
! 		free(newcmdline);
  		return 0;		   /* malloc error */
  	    }
  	    pnew = newcmdline;
+ 	    *tofree = newcmdline;
  	}
      }
  
  done:
      argv[argc] = NULL;		/* NULL-terminated list */
      *argvp = argv;
      return argc;
*** ../vim-7.2.035/src/os_vms.c	Wed Aug  6 18:38:52 2008
--- src/os_vms.c	Wed Nov 12 11:42:12 2008
***************
*** 228,234 ****
      else if ((sbuf = getenv((char *)lognam)))
      {
  	lengte = strlen(sbuf) + 1;
! 	cp = (char_u *)malloc((size_t)lengte);
  	if (cp)
  	    strcpy((char *)cp, sbuf);
  	return cp;
--- 228,234 ----
      else if ((sbuf = getenv((char *)lognam)))
      {
  	lengte = strlen(sbuf) + 1;
! 	cp = (char_u *)alloc((size_t)lengte);
  	if (cp)
  	    strcpy((char *)cp, sbuf);
  	return cp;
***************
*** 381,387 ****
      if (--vms_match_free == 0) {
  	/* add more space to store matches */
  	vms_match_alloced += EXPL_ALLOC_INC;
! 	vms_fmatch = (char_u **)realloc(vms_fmatch,
  		sizeof(char **) * vms_match_alloced);
  	if (!vms_fmatch)
  	    return 0;
--- 381,387 ----
      if (--vms_match_free == 0) {
  	/* add more space to store matches */
  	vms_match_alloced += EXPL_ALLOC_INC;
! 	vms_fmatch = (char_u **)vim_realloc(vms_fmatch,
  		sizeof(char **) * vms_match_alloced);
  	if (!vms_fmatch)
  	    return 0;
***************
*** 460,466 ****
  	    if (--files_free < 1)
  	    {
  		files_alloced += EXPL_ALLOC_INC;
! 		*file = (char_u **)realloc(*file,
  		    sizeof(char_u **) * files_alloced);
  		if (*file == NULL)
  		{
--- 460,466 ----
  	    if (--files_free < 1)
  	    {
  		files_alloced += EXPL_ALLOC_INC;
! 		*file = (char_u **)vim_realloc(*file,
  		    sizeof(char_u **) * files_alloced);
  		if (*file == NULL)
  		{
***************
*** 614,627 ****
      {
  	buflen = len + 128;
  	if (buf)
! 	    buf = (char *)realloc(buf, buflen);
  	else
! 	    buf = (char *)calloc(buflen, sizeof(char));
      }
  
  #ifdef DEBUG
       char		 *tmpbuf = NULL;
!      tmpbuf = (char *)calloc(buflen, sizeof(char));
       strcpy(tmpbuf, instring);
  #endif
  
--- 614,627 ----
      {
  	buflen = len + 128;
  	if (buf)
! 	    buf = (char *)vim_realloc(buf, buflen);
  	else
! 	    buf = (char *)alloc(buflen * sizeof(char));
      }
  
  #ifdef DEBUG
       char		 *tmpbuf = NULL;
!      tmpbuf = (char *)alloc(buflen * sizeof(char));
       strcpy(tmpbuf, instring);
  #endif
  
*** ../vim-7.2.035/src/os_w32exe.c	Fri Jul  1 00:06:20 2005
--- src/os_w32exe.c	Wed Nov 12 11:45:43 2008
***************
*** 129,135 ****
  errout:
  #endif
      free(argv);
!     free(tofree);
  #ifdef FEAT_MBYTE
      free_cmd_argsW();
  #endif
--- 129,136 ----
  errout:
  #endif
      free(argv);
!     if (tofree != NULL)
! 	free(tofree);
  #ifdef FEAT_MBYTE
      free_cmd_argsW();
  #endif
*** ../vim-7.2.035/src/os_win16.c	Wed Jun 25 00:49:34 2008
--- src/os_win16.c	Wed Nov 12 11:45:53 2008
***************
*** 121,127 ****
      pmain(argc, argv);
  
      free(argv);
!     free(tofree);
  
      return 0;
  }
--- 121,128 ----
      pmain(argc, argv);
  
      free(argv);
!     if (tofree != NULL)
! 	free(tofree);
  
      return 0;
  }
*** ../vim-7.2.035/src/version.c	Wed Nov 12 13:07:48 2008
--- src/version.c	Wed Nov 12 13:28:51 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     36,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
239. You think "surfing" is something you do on dry land.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.037
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.037
Problem:    Double free with GTK 1 and compiled with EXITFREE.
Solution:   Don't close display. (Dominique Pelle)
Files:	    src/os_unix.c


*** ../vim-7.2.036/src/os_unix.c	Wed Nov 12 13:07:48 2008
--- src/os_unix.c	Wed Nov 12 11:55:33 2008
***************
*** 2936,2942 ****
      }
  #  endif
  # endif
! # ifdef FEAT_X11
      if (x11_display != NULL
  #  ifdef FEAT_XCLIPBOARD
  	    && x11_display != xterm_dpy
--- 2936,2943 ----
      }
  #  endif
  # endif
!     /* Don't close the display for GTK 1, it is done in exit(). */
! # if defined(FEAT_X11) && (!defined(FEAT_GUI_GTK) || defined(HAVE_GTK2))
      if (x11_display != NULL
  #  ifdef FEAT_XCLIPBOARD
  	    && x11_display != xterm_dpy
*** ../vim-7.2.036/src/version.c	Wed Nov 12 13:35:31 2008
--- src/version.c	Wed Nov 12 14:08:56 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     37,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
240. You think Webster's Dictionary is a directory of WEB sites.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.038
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.038
Problem:    Overlapping arguments to memcpy().
Solution:   Use mch_memmove(). (Dominique Pelle)
Files:	    src/if_xcmdsrv.c


*** ../vim-7.2.037/src/if_xcmdsrv.c	Wed Aug  6 18:38:13 2008
--- src/if_xcmdsrv.c	Wed Nov 12 12:09:01 2008
***************
*** 736,742 ****
  		+ serverReply.ga_len;
  	    e.id = w;
  	    ga_init2(&e.strings, 1, 100);
! 	    memcpy(p, &e, sizeof(e));
  	    serverReply.ga_len++;
  	}
      }
--- 736,742 ----
  		+ serverReply.ga_len;
  	    e.id = w;
  	    ga_init2(&e.strings, 1, 100);
! 	    mch_memmove(p, &e, sizeof(e));
  	    serverReply.ga_len++;
  	}
      }
***************
*** 1018,1024 ****
  	p++;
  	count = numItems - (p - regProp);
  	if (count > 0)
! 	    memcpy(entry, p, count);
  	XChangeProperty(dpy, RootWindow(dpy, 0), registryProperty, XA_STRING,
  			8, PropModeReplace, regProp,
  			(int)(numItems - (p - entry)));
--- 1018,1024 ----
  	p++;
  	count = numItems - (p - regProp);
  	if (count > 0)
! 	    mch_memmove(entry, p, count);
  	XChangeProperty(dpy, RootWindow(dpy, 0), registryProperty, XA_STRING,
  			8, PropModeReplace, regProp,
  			(int)(numItems - (p - entry)));
***************
*** 1072,1078 ****
  		p++;
  		lastHalf = numItems - (p - regProp);
  		if (lastHalf > 0)
! 		    memcpy(entry, p, lastHalf);
  		numItems = (entry - regProp) + lastHalf;
  		p = entry;
  		continue;
--- 1072,1078 ----
  		p++;
  		lastHalf = numItems - (p - regProp);
  		if (lastHalf > 0)
! 		    mch_memmove(entry, p, lastHalf);
  		numItems = (entry - regProp) + lastHalf;
  		p = entry;
  		continue;
*** ../vim-7.2.037/src/version.c	Wed Nov 12 14:09:38 2008
--- src/version.c	Wed Nov 12 14:51:00 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     38,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
241. You try to look for Net Search even when you're in File Manager.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.039
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.039
Problem:    Accessing freed memory on exit when EXITFREE is defined.
Solution:   Call hash_init() on the v: hash table.
Files:	    src/eval.c


*** ../vim-7.2.038/src/eval.c	Sun Nov  9 17:21:10 2008
--- src/eval.c	Wed Nov 12 12:15:14 2008
***************
*** 856,861 ****
--- 856,862 ----
  	}
      }
      hash_clear(&vimvarht);
+     hash_init(&vimvarht);  /* garbage_collect() will access it */
      hash_clear(&compat_hashtab);
  
      /* script-local variables */
*** ../vim-7.2.038/src/version.c	Wed Nov 12 14:52:11 2008
--- src/version.c	Wed Nov 12 15:09:39 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     39,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
242. You turn down a better-paying job because it doesn't come with
     a free e-mail account.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.040
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.040
Problem:    When using ":e ++ff=dos fname" and the file contains a NL without
	    a CR before it and 'ffs' contains "unix" then the fileformat
	    becomes unix.
Solution:   Ignore 'ffs' when using the ++ff argument. (Ben Schmidt)
	    Also remove unreachable code.
Files:	    src/fileio.c


*** ../vim-7.2.039/src/fileio.c	Tue Nov 11 21:55:29 2008
--- src/fileio.c	Wed Nov 12 13:19:42 2008
***************
*** 932,938 ****
--- 932,941 ----
      else
      {
  	if (eap != NULL && eap->force_ff != 0)
+ 	{
  	    fileformat = get_fileformat_force(curbuf, eap);
+ 	    try_unix = try_dos = try_mac = FALSE;
+ 	}
  	else if (curbuf->b_p_bin)
  	    fileformat = EOL_UNIX;		/* binary: use Unix format */
  	else if (*p_ffs == NUL)
***************
*** 2341,2351 ****
  		STRCAT(IObuff, _("[CR missing]"));
  		c = TRUE;
  	    }
- 	    if (ff_error == EOL_MAC)
- 	    {
- 		STRCAT(IObuff, _("[NL found]"));
- 		c = TRUE;
- 	    }
  	    if (split)
  	    {
  		STRCAT(IObuff, _("[long lines split]"));
--- 2344,2349 ----
*** ../vim-7.2.039/src/version.c	Wed Nov 12 15:28:37 2008
--- src/version.c	Wed Nov 12 16:03:44 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     40,
  /**/

-- 
If you're sending someone Styrofoam, what do you pack it in?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.041
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.041
Problem:    In diff mode, when using two tabs, each with two diffed buffers,
	    editing a buffer of the other tab messes up the diff.  (Matt
	    Mzyzik)
Solution:   Only copy options from a window where the buffer was edited that
	    doesn't have 'diff' set or is for the current tab page.
	    Also fix that window options for a buffer are stored with the
	    wrong window.
Files:	    src/buffer.c, src/ex_cmds.c, src/ex_cmds2.c, src/ex_docmd.c,
	    src/ex_getln.c, src/if_sniff.c, src/main.c, src/netbeans.c,
	    src/normal.c, src/popupmnu.c, src/proto/buffer.pro,
	    src/proto/ex_cmds.pro src/quickfix.c, src/window.c


*** ../vim-7.2.040/src/buffer.c	Wed Nov 12 12:51:38 2008
--- src/buffer.c	Wed Nov 12 17:45:01 2008
***************
*** 33,39 ****
  static char_u	*fname_match __ARGS((regprog_T *prog, char_u *name));
  #endif
  static void	buflist_setfpos __ARGS((buf_T *buf, win_T *win, linenr_T lnum, colnr_T col, int copy_options));
! static wininfo_T *find_wininfo __ARGS((buf_T *buf));
  #ifdef UNIX
  static buf_T	*buflist_findname_stat __ARGS((char_u *ffname, struct stat *st));
  static int	otherfile_buf __ARGS((buf_T *buf, char_u *ffname, struct stat *stp));
--- 33,39 ----
  static char_u	*fname_match __ARGS((regprog_T *prog, char_u *name));
  #endif
  static void	buflist_setfpos __ARGS((buf_T *buf, win_T *win, linenr_T lnum, colnr_T col, int copy_options));
! static wininfo_T *find_wininfo __ARGS((buf_T *buf, int skip_diff_buffer));
  #ifdef UNIX
  static buf_T	*buflist_findname_stat __ARGS((char_u *ffname, struct stat *st));
  static int	otherfile_buf __ARGS((buf_T *buf, char_u *ffname, struct stat *stp));
***************
*** 1093,1099 ****
  #endif
  	    setpcmark();
  	    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,
! 						  forceit ? ECMD_FORCEIT : 0);
  
  	    /*
  	     * do_ecmd() may create a new buffer, then we have to delete
--- 1093,1099 ----
  #endif
  	    setpcmark();
  	    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,
! 					  forceit ? ECMD_FORCEIT : 0, curwin);
  
  	    /*
  	     * do_ecmd() may create a new buffer, then we have to delete
***************
*** 1316,1322 ****
      setpcmark();
      if (!cmdmod.keepalt)
  	curwin->w_alt_fnum = curbuf->b_fnum; /* remember alternate file */
!     buflist_altfpos();			 /* remember curpos */
  
  #ifdef FEAT_VISUAL
      /* Don't restart Select mode after switching to another buffer. */
--- 1316,1322 ----
      setpcmark();
      if (!cmdmod.keepalt)
  	curwin->w_alt_fnum = curbuf->b_fnum; /* remember alternate file */
!     buflist_altfpos(curwin);			 /* remember curpos */
  
  #ifdef FEAT_VISUAL
      /* Don't restart Select mode after switching to another buffer. */
***************
*** 2404,2425 ****
      return;
  }
  
  /*
   * Find info for the current window in buffer "buf".
   * If not found, return the info for the most recently used window.
   * Returns NULL when there isn't any info.
   */
      static wininfo_T *
! find_wininfo(buf)
      buf_T	*buf;
  {
      wininfo_T	*wip;
  
      for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)
! 	if (wip->wi_win == curwin)
  	    break;
!     if (wip == NULL)	/* if no fpos for curwin, use the first in the list */
! 	wip = buf->b_wininfo;
      return wip;
  }
  
--- 2404,2473 ----
      return;
  }
  
+ #ifdef FEAT_DIFF
+ static int wininfo_other_tab_diff __ARGS((wininfo_T *wip));
+ 
+ /*
+  * Return TRUE when "wip" has 'diff' set and the diff is only for another tab
+  * page.  That's because a diff is local to a tab page.
+  */
+     static int
+ wininfo_other_tab_diff(wip)
+     wininfo_T	*wip;
+ {
+     win_T	*wp;
+ 
+     if (wip->wi_opt.wo_diff)
+     {
+ 	for (wp = firstwin; wp != NULL; wp = wp->w_next)
+ 	    /* return FALSE when it's a window in the current tab page, thus
+ 	     * the buffer was in diff mode here */
+ 	    if (wip->wi_win == wp)
+ 		return FALSE;
+ 	return TRUE;
+     }
+     return FALSE;
+ }
+ #endif
+ 
  /*
   * Find info for the current window in buffer "buf".
   * If not found, return the info for the most recently used window.
+  * When "skip_diff_buffer" is TRUE avoid windows with 'diff' set that is in
+  * another tab page.
   * Returns NULL when there isn't any info.
   */
+ /*ARGSUSED*/
      static wininfo_T *
! find_wininfo(buf, skip_diff_buffer)
      buf_T	*buf;
+     int		skip_diff_buffer;
  {
      wininfo_T	*wip;
  
      for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)
! 	if (wip->wi_win == curwin
! #ifdef FEAT_DIFF
! 		&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))
! #endif
! 	   )
  	    break;
! 
!     /* If no wininfo for curwin, use the first in the list (that doesn't have
!      * 'diff' set and is in another tab page). */
!     if (wip == NULL)
!     {
! #ifdef FEAT_DIFF
! 	if (skip_diff_buffer)
! 	{
! 	    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)
! 		if (!wininfo_other_tab_diff(wip))
! 		    break;
! 	}
! 	else
! #endif
! 	    wip = buf->b_wininfo;
!     }
      return wip;
  }
  
***************
*** 2440,2446 ****
      clearFolding(curwin);
  #endif
  
!     wip = find_wininfo(buf);
      if (wip != NULL && wip->wi_optset)
      {
  	copy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);
--- 2488,2494 ----
      clearFolding(curwin);
  #endif
  
!     wip = find_wininfo(buf, TRUE);
      if (wip != NULL && wip->wi_optset)
      {
  	copy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);
***************
*** 2472,2478 ****
      wininfo_T	*wip;
      static pos_T no_position = {1, 0};
  
!     wip = find_wininfo(buf);
      if (wip != NULL)
  	return &(wip->wi_fpos);
      else
--- 2520,2526 ----
      wininfo_T	*wip;
      static pos_T no_position = {1, 0};
  
!     wip = find_wininfo(buf, FALSE);
      if (wip != NULL)
  	return &(wip->wi_fpos);
      else
***************
*** 2793,2806 ****
  #endif
  
  /*
!  * Set alternate cursor position for current window.
   * Also save the local window option values.
   */
      void
! buflist_altfpos()
  {
!     buflist_setfpos(curbuf, curwin, curwin->w_cursor.lnum,
! 						  curwin->w_cursor.col, TRUE);
  }
  
  /*
--- 2841,2854 ----
  #endif
  
  /*
!  * Set alternate cursor position for the current buffer and window "win".
   * Also save the local window option values.
   */
      void
! buflist_altfpos(win)
!     win_T *win;
  {
!     buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);
  }
  
  /*
***************
*** 4492,4498 ****
  		      ECMD_ONE,
  		      ((P_HID(curwin->w_buffer)
  			   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)
! 							       + ECMD_OLDBUF);
  #ifdef FEAT_AUTOCMD
  	    if (use_firstwin)
  		++autocmd_no_leave;
--- 4540,4546 ----
  		      ECMD_ONE,
  		      ((P_HID(curwin->w_buffer)
  			   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)
! 						       + ECMD_OLDBUF, curwin);
  #ifdef FEAT_AUTOCMD
  	    if (use_firstwin)
  		++autocmd_no_leave;
*** ../vim-7.2.040/src/ex_cmds.c	Sun Nov  9 13:43:25 2008
--- src/ex_cmds.c	Wed Nov 12 22:41:41 2008
***************
*** 3052,3058 ****
  	retval = 0;	/* it's in the same file */
      }
      else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,
! 		(P_HID(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0)) == OK)
  	retval = -1;	/* opened another file */
      else
  	retval = 1;	/* error encountered */
--- 3052,3059 ----
  	retval = 0;	/* it's in the same file */
      }
      else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,
! 		(P_HID(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),
! 		curwin) == OK)
  	retval = -1;	/* opened another file */
      else
  	retval = 1;	/* error encountered */
***************
*** 3085,3101 ****
   *	 ECMD_OLDBUF: use existing buffer if it exists
   *	ECMD_FORCEIT: ! used for Ex command
   *	 ECMD_ADDBUF: don't edit, just add to buffer list
   *
   * return FAIL for failure, OK otherwise
   */
      int
! do_ecmd(fnum, ffname, sfname, eap, newlnum, flags)
      int		fnum;
      char_u	*ffname;
      char_u	*sfname;
      exarg_T	*eap;			/* can be NULL! */
      linenr_T	newlnum;
      int		flags;
  {
      int		other_file;		/* TRUE if editing another file */
      int		oldbuf;			/* TRUE if using existing buffer */
--- 3086,3106 ----
   *	 ECMD_OLDBUF: use existing buffer if it exists
   *	ECMD_FORCEIT: ! used for Ex command
   *	 ECMD_ADDBUF: don't edit, just add to buffer list
+  *   oldwin: Should be "curwin" when editing a new buffer in the current
+  *           window, NULL when splitting the window first.  When not NULL info
+  *           of the previous buffer for "oldwin" is stored.
   *
   * return FAIL for failure, OK otherwise
   */
      int
! do_ecmd(fnum, ffname, sfname, eap, newlnum, flags, oldwin)
      int		fnum;
      char_u	*ffname;
      char_u	*sfname;
      exarg_T	*eap;			/* can be NULL! */
      linenr_T	newlnum;
      int		flags;
+     win_T	*oldwin;
  {
      int		other_file;		/* TRUE if editing another file */
      int		oldbuf;			/* TRUE if using existing buffer */
***************
*** 3267,3273 ****
  	{
  	    if (!cmdmod.keepalt)
  		curwin->w_alt_fnum = curbuf->b_fnum;
! 	    buflist_altfpos();
  	}
  
  	if (fnum)
--- 3272,3279 ----
  	{
  	    if (!cmdmod.keepalt)
  		curwin->w_alt_fnum = curbuf->b_fnum;
! 	    if (oldwin != NULL)
! 		buflist_altfpos(oldwin);
  	}
  
  	if (fnum)
***************
*** 3371,3377 ****
  
  		/* close the link to the current buffer */
  		u_sync(FALSE);
! 		close_buffer(curwin, curbuf,
  				      (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD);
  
  #ifdef FEAT_AUTOCMD
--- 3377,3383 ----
  
  		/* close the link to the current buffer */
  		u_sync(FALSE);
! 		close_buffer(oldwin, curbuf,
  				      (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD);
  
  #ifdef FEAT_AUTOCMD
***************
*** 5609,5615 ****
  	     */
  	    alt_fnum = curbuf->b_fnum;
  	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,
! 						   ECMD_HIDE + ECMD_SET_HELP);
  	    if (!cmdmod.keepalt)
  		curwin->w_alt_fnum = alt_fnum;
  	    empty_fnum = curbuf->b_fnum;
--- 5615,5627 ----
  	     */
  	    alt_fnum = curbuf->b_fnum;
  	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,
! 			  ECMD_HIDE + ECMD_SET_HELP,
! #ifdef FEAT_WINDOWS
! 			  NULL  /* buffer is still open, don't store info */
! #else
! 			  curwin
! #endif
! 		    );
  	    if (!cmdmod.keepalt)
  		curwin->w_alt_fnum = alt_fnum;
  	    empty_fnum = curbuf->b_fnum;
*** ../vim-7.2.040/src/ex_cmds2.c	Sun Sep  7 15:49:45 2008
--- src/ex_cmds2.c	Wed Nov 12 17:46:41 2008
***************
*** 2132,2139 ****
  	 * argument index. */
  	if (do_ecmd(0, alist_name(&ARGLIST[curwin->w_arg_idx]), NULL,
  		      eap, ECMD_LAST,
! 		      (P_HID(curwin->w_buffer) ? ECMD_HIDE : 0) +
! 				   (eap->forceit ? ECMD_FORCEIT : 0)) == FAIL)
  	    curwin->w_arg_idx = old_arg_idx;
  	/* like Vi: set the mark where the cursor is in the file. */
  	else if (eap->cmdidx != CMD_argdo)
--- 2132,2139 ----
  	 * argument index. */
  	if (do_ecmd(0, alist_name(&ARGLIST[curwin->w_arg_idx]), NULL,
  		      eap, ECMD_LAST,
! 		      (P_HID(curwin->w_buffer) ? ECMD_HIDE : 0)
! 			 + (eap->forceit ? ECMD_FORCEIT : 0), curwin) == FAIL)
  	    curwin->w_arg_idx = old_arg_idx;
  	/* like Vi: set the mark where the cursor is in the file. */
  	else if (eap->cmdidx != CMD_argdo)
*** ../vim-7.2.040/src/ex_docmd.c	Sun Nov  9 13:43:25 2008
--- src/ex_docmd.c	Wed Nov 12 18:04:22 2008
***************
*** 7488,7494 ****
  	/* ":new" or ":tabnew" without argument: edit an new empty buffer */
  	setpcmark();
  	(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,
! 			       ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0));
      }
      else if ((eap->cmdidx != CMD_split
  #ifdef FEAT_VERTSPLIT
--- 7488,7495 ----
  	/* ":new" or ":tabnew" without argument: edit an new empty buffer */
  	setpcmark();
  	(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,
! 		      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),
! 		      old_curwin == NULL ? curwin : NULL);
      }
      else if ((eap->cmdidx != CMD_split
  #ifdef FEAT_VERTSPLIT
***************
*** 7525,7531 ****
  #ifdef FEAT_LISTCMDS
  		    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0 )
  #endif
! 		    ) == FAIL)
  	{
  	    /* Editing the file failed.  If the window was split, close it. */
  #ifdef FEAT_WINDOWS
--- 7526,7532 ----
  #ifdef FEAT_LISTCMDS
  		    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0 )
  #endif
! 		    , old_curwin == NULL ? curwin : NULL) == FAIL)
  	{
  	    /* Editing the file failed.  If the window was split, close it. */
  #ifdef FEAT_WINDOWS
*** ../vim-7.2.040/src/ex_getln.c	Sun Sep 14 14:41:44 2008
--- src/ex_getln.c	Wed Nov 12 18:06:25 2008
***************
*** 6051,6057 ****
  	cmdwin_type = '-';
  
      /* Create the command-line buffer empty. */
!     (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE);
      (void)setfname(curbuf, (char_u *)"[Command Line]", NULL, TRUE);
      set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
      set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
--- 6051,6057 ----
  	cmdwin_type = '-';
  
      /* Create the command-line buffer empty. */
!     (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
      (void)setfname(curbuf, (char_u *)"[Command Line]", NULL, TRUE);
      set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
      set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
*** ../vim-7.2.040/src/if_sniff.c	Sat Aug  9 19:41:16 2008
--- src/if_sniff.c	Wed Nov 12 17:48:46 2008
***************
*** 1114,1120 ****
      char *fname;
  {
      ++no_wait_return;
!     do_ecmd(0, (char_u *)fname, NULL, NULL, ECMD_ONE, ECMD_HIDE+ECMD_OLDBUF);
      curbuf->b_sniff = TRUE;
      --no_wait_return;					/* [ex_docmd.c] */
  }
--- 1114,1121 ----
      char *fname;
  {
      ++no_wait_return;
!     do_ecmd(0, (char_u *)fname, NULL, NULL, ECMD_ONE, ECMD_HIDE+ECMD_OLDBUF,
! 	    curwin);
      curbuf->b_sniff = TRUE;
      --no_wait_return;					/* [ex_docmd.c] */
  }
*** ../vim-7.2.040/src/main.c	Sun Nov  9 13:43:25 2008
--- src/main.c	Wed Nov 12 17:49:06 2008
***************
*** 2588,2594 ****
  # endif
  	    (void)do_ecmd(0, arg_idx < GARGCOUNT
  			  ? alist_name(&GARGLIST[arg_idx]) : NULL,
! 			  NULL, NULL, ECMD_LASTL, ECMD_HIDE);
  # ifdef HAS_SWAP_EXISTS_ACTION
  	    if (swap_exists_did_quit)
  	    {
--- 2588,2594 ----
  # endif
  	    (void)do_ecmd(0, arg_idx < GARGCOUNT
  			  ? alist_name(&GARGLIST[arg_idx]) : NULL,
! 			  NULL, NULL, ECMD_LASTL, ECMD_HIDE, curwin);
  # ifdef HAS_SWAP_EXISTS_ACTION
  	    if (swap_exists_did_quit)
  	    {
*** ../vim-7.2.040/src/netbeans.c	Sun Jul 13 19:18:03 2008
--- src/netbeans.c	Wed Nov 12 17:49:40 2008
***************
*** 1795,1801 ****
  	    buf->displayname = NULL;
  
  	    netbeansReadFile = 0; /* don't try to open disk file */
! 	    do_ecmd(0, NULL, 0, 0, ECMD_ONE, ECMD_HIDE + ECMD_OLDBUF);
  	    netbeansReadFile = 1;
  	    buf->bufp = curbuf;
  	    maketitle();
--- 1795,1801 ----
  	    buf->displayname = NULL;
  
  	    netbeansReadFile = 0; /* don't try to open disk file */
! 	    do_ecmd(0, NULL, 0, 0, ECMD_ONE, ECMD_HIDE + ECMD_OLDBUF, curwin);
  	    netbeansReadFile = 1;
  	    buf->bufp = curbuf;
  	    maketitle();
***************
*** 1960,1966 ****
  
  	    netbeansReadFile = 0; /* don't try to open disk file */
  	    do_ecmd(0, (char_u *)buf->displayname, 0, 0, ECMD_ONE,
! 						     ECMD_HIDE + ECMD_OLDBUF);
  	    netbeansReadFile = 1;
  	    buf->bufp = curbuf;
  	    maketitle();
--- 1960,1966 ----
  
  	    netbeansReadFile = 0; /* don't try to open disk file */
  	    do_ecmd(0, (char_u *)buf->displayname, 0, 0, ECMD_ONE,
! 					     ECMD_HIDE + ECMD_OLDBUF, curwin);
  	    netbeansReadFile = 1;
  	    buf->bufp = curbuf;
  	    maketitle();
***************
*** 1979,1985 ****
  	    vim_free(buf->displayname);
  	    buf->displayname = nb_unquote(args, NULL);
  	    do_ecmd(0, (char_u *)buf->displayname, NULL, NULL, ECMD_ONE,
! 						     ECMD_HIDE + ECMD_OLDBUF);
  	    buf->bufp = curbuf;
  	    buf->initDone = TRUE;
  	    doupdate = 1;
--- 1979,1985 ----
  	    vim_free(buf->displayname);
  	    buf->displayname = nb_unquote(args, NULL);
  	    do_ecmd(0, (char_u *)buf->displayname, NULL, NULL, ECMD_ONE,
! 					     ECMD_HIDE + ECMD_OLDBUF, curwin);
  	    buf->bufp = curbuf;
  	    buf->initDone = TRUE;
  	    doupdate = 1;
*** ../vim-7.2.040/src/normal.c	Sat Nov  1 13:51:57 2008
--- src/normal.c	Wed Nov 12 17:49:50 2008
***************
*** 6050,6056 ****
  	    autowrite(curbuf, FALSE);
  	setpcmark();
  	(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,
! 					       P_HID(curbuf) ? ECMD_HIDE : 0);
  	if (cap->nchar == 'F' && lnum >= 0)
  	{
  	    curwin->w_cursor.lnum = lnum;
--- 6050,6056 ----
  	    autowrite(curbuf, FALSE);
  	setpcmark();
  	(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,
! 				       P_HID(curbuf) ? ECMD_HIDE : 0, curwin);
  	if (cap->nchar == 'F' && lnum >= 0)
  	{
  	    curwin->w_cursor.lnum = lnum;
*** ../vim-7.2.040/src/popupmnu.c	Sun Jul 13 19:33:51 2008
--- src/popupmnu.c	Wed Nov 12 18:08:07 2008
***************
*** 573,579 ****
  		{
  		    /* Don't want to sync undo in the current buffer. */
  		    ++no_u_sync;
! 		    res = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, 0);
  		    --no_u_sync;
  		    if (res == OK)
  		    {
--- 573,579 ----
  		{
  		    /* Don't want to sync undo in the current buffer. */
  		    ++no_u_sync;
! 		    res = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, 0, NULL);
  		    --no_u_sync;
  		    if (res == OK)
  		    {
*** ../vim-7.2.040/src/proto/buffer.pro	Sun May  6 13:57:53 2007
--- src/proto/buffer.pro	Wed Nov 12 17:43:39 2008
***************
*** 33,39 ****
  char_u *getaltfname __ARGS((int errmsg));
  int buflist_add __ARGS((char_u *fname, int flags));
  void buflist_slash_adjust __ARGS((void));
! void buflist_altfpos __ARGS((void));
  int otherfile __ARGS((char_u *ffname));
  void buf_setino __ARGS((buf_T *buf));
  void fileinfo __ARGS((int fullname, int shorthelp, int dont_truncate));
--- 33,39 ----
  char_u *getaltfname __ARGS((int errmsg));
  int buflist_add __ARGS((char_u *fname, int flags));
  void buflist_slash_adjust __ARGS((void));
! void buflist_altfpos __ARGS((win_T *win));
  int otherfile __ARGS((char_u *ffname));
  void buf_setino __ARGS((buf_T *buf));
  void fileinfo __ARGS((int fullname, int shorthelp, int dont_truncate));
*** ../vim-7.2.040/src/proto/ex_cmds.pro	Sun Nov  9 13:43:25 2008
--- src/proto/ex_cmds.pro	Wed Nov 12 17:44:27 2008
***************
*** 27,33 ****
  void do_wqall __ARGS((exarg_T *eap));
  int not_writing __ARGS((void));
  int getfile __ARGS((int fnum, char_u *ffname, char_u *sfname, int setpm, linenr_T lnum, int forceit));
! int do_ecmd __ARGS((int fnum, char_u *ffname, char_u *sfname, exarg_T *eap, linenr_T newlnum, int flags));
  void ex_append __ARGS((exarg_T *eap));
  void ex_change __ARGS((exarg_T *eap));
  void ex_z __ARGS((exarg_T *eap));
--- 27,33 ----
  void do_wqall __ARGS((exarg_T *eap));
  int not_writing __ARGS((void));
  int getfile __ARGS((int fnum, char_u *ffname, char_u *sfname, int setpm, linenr_T lnum, int forceit));
! int do_ecmd __ARGS((int fnum, char_u *ffname, char_u *sfname, exarg_T *eap, linenr_T newlnum, int flags, win_T *oldwin));
  void ex_append __ARGS((exarg_T *eap));
  void ex_change __ARGS((exarg_T *eap));
  void ex_z __ARGS((exarg_T *eap));
*** ../vim-7.2.040/src/quickfix.c	Thu Jul 24 18:44:59 2008
--- src/quickfix.c	Wed Nov 12 18:12:00 2008
***************
*** 1420,1425 ****
--- 1420,1426 ----
      win_T		*win;
      win_T		*altwin;
  #endif
+     win_T		*oldwin = curwin;
      int			print_message = TRUE;
      int			len;
  #ifdef FEAT_FOLDING
***************
*** 1744,1750 ****
  	    }
  	    else
  		ok = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,
! 						   ECMD_HIDE + ECMD_SET_HELP);
  	}
  	else
  	    ok = buflist_getfile(qf_ptr->qf_fnum,
--- 1745,1752 ----
  	    }
  	    else
  		ok = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,
! 					   ECMD_HIDE + ECMD_SET_HELP,
! 					   oldwin == curwin ? curwin : NULL);
  	}
  	else
  	    ok = buflist_getfile(qf_ptr->qf_fnum,
***************
*** 2267,2272 ****
--- 2269,2275 ----
      win_T	*win;
      tabpage_T	*prevtab = curtab;
      buf_T	*qf_buf;
+     win_T	*oldwin = curwin;
  
      if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
      {
***************
*** 2326,2339 ****
  	    win->w_llist->qf_refcount++;
  	}
  
  	if (qf_buf != NULL)
  	    /* Use the existing quickfix buffer */
  	    (void)do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,
! 						     ECMD_HIDE + ECMD_OLDBUF);
  	else
  	{
  	    /* Create a new quickfix buffer */
! 	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE);
  	    /* switch off 'swapfile' */
  	    set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
  	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
--- 2329,2344 ----
  	    win->w_llist->qf_refcount++;
  	}
  
+ 	if (oldwin != curwin)
+ 	    oldwin = NULL;  /* don't store info when in another window */
  	if (qf_buf != NULL)
  	    /* Use the existing quickfix buffer */
  	    (void)do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,
! 					     ECMD_HIDE + ECMD_OLDBUF, oldwin);
  	else
  	{
  	    /* Create a new quickfix buffer */
! 	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, oldwin);
  	    /* switch off 'swapfile' */
  	    set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
  	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
*** ../vim-7.2.040/src/window.c	Wed Aug  6 18:32:11 2008
--- src/window.c	Wed Nov 12 18:12:37 2008
***************
*** 531,537 ****
  # ifdef FEAT_SCROLLBIND
  			curwin->w_p_scb = FALSE;
  # endif
! 			(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL, ECMD_HIDE);
  			if (nchar == 'F' && lnum >= 0)
  			{
  			    curwin->w_cursor.lnum = lnum;
--- 531,538 ----
  # ifdef FEAT_SCROLLBIND
  			curwin->w_p_scb = FALSE;
  # endif
! 			(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,
! 							   ECMD_HIDE, NULL);
  			if (nchar == 'F' && lnum >= 0)
  			{
  			    curwin->w_cursor.lnum = lnum;
*** ../vim-7.2.040/src/version.c	Wed Nov 12 16:04:43 2008
--- src/version.c	Wed Nov 12 16:54:35 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     41,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
260. Co-workers have to E-mail you about the fire alarm to get
     you out of the building.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.042
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.042
Problem:    When using winrestview() in a BufWinEnter autocommand the window
	    is scrolled anyway. (Matt Zyzik)
Solution:   Don't recompute topline when above 'scrolloff' from the bottom.
	    Don't always put the cursor halfway when entering a buffer.  Add
	    "w_topline_was_set".
Files:	    src/buffer.c, src/move.c, src/structs.h


*** ../vim-7.2.041/src/buffer.c	Sat Nov 15 14:10:23 2008
--- src/buffer.c	Sat Nov 15 14:58:52 2008
***************
*** 1401,1406 ****
--- 1401,1409 ----
      curwin->w_cursor.coladd = 0;
  #endif
      curwin->w_set_curswant = TRUE;
+ #ifdef FEAT_AUTOCMD
+     curwin->w_topline_was_set = FALSE;
+ #endif
  
      /* Make sure the buffer is loaded. */
      if (curbuf->b_ml.ml_mfp == NULL)	/* need to load the file */
***************
*** 1440,1446 ****
      maketitle();
  #endif
  #ifdef FEAT_AUTOCMD
!     if (curwin->w_topline == 1)		/* when autocmds didn't change it */
  #endif
  	scroll_cursor_halfway(FALSE);	/* redisplay at correct position */
  
--- 1443,1450 ----
      maketitle();
  #endif
  #ifdef FEAT_AUTOCMD
! 	/* when autocmds didn't change it */
!     if (curwin->w_topline == 1 && !curwin->w_topline_was_set)
  #endif
  	scroll_cursor_halfway(FALSE);	/* redisplay at correct position */
  
*** ../vim-7.2.041/src/move.c	Sun Jul 13 19:25:23 2008
--- src/move.c	Sat Nov 15 14:56:47 2008
***************
*** 280,297 ****
  
  	if (curwin->w_botline <= curbuf->b_ml.ml_line_count)
  	{
! 	    if (curwin->w_cursor.lnum < curwin->w_botline
! 		    && ((long)curwin->w_cursor.lnum
  					     >= (long)curwin->w_botline - p_so
  #ifdef FEAT_FOLDING
  			|| hasAnyFolding(curwin)
  #endif
  			))
! 	    {
  		lineoff_T	loff;
  
! 		/* Cursor is above botline, check if there are 'scrolloff'
! 		 * window lines below the cursor.  If not, need to scroll. */
  		n = curwin->w_empty_rows;
  		loff.lnum = curwin->w_cursor.lnum;
  #ifdef FEAT_FOLDING
--- 280,299 ----
  
  	if (curwin->w_botline <= curbuf->b_ml.ml_line_count)
  	{
! 	    if (curwin->w_cursor.lnum < curwin->w_botline)
! 	    {
! 	      if (((long)curwin->w_cursor.lnum
  					     >= (long)curwin->w_botline - p_so
  #ifdef FEAT_FOLDING
  			|| hasAnyFolding(curwin)
  #endif
  			))
! 	      {
  		lineoff_T	loff;
  
! 		/* Cursor is (a few lines) above botline, check if there are
! 		 * 'scrolloff' window lines below the cursor.  If not, need to
! 		 * scroll. */
  		n = curwin->w_empty_rows;
  		loff.lnum = curwin->w_cursor.lnum;
  #ifdef FEAT_FOLDING
***************
*** 317,322 ****
--- 319,328 ----
  		if (n >= p_so)
  		    /* sufficient context, no need to scroll */
  		    check_botline = FALSE;
+ 	      }
+ 	      else
+ 		  /* sufficient context, no need to scroll */
+ 		  check_botline = FALSE;
  	    }
  	    if (check_botline)
  	    {
***************
*** 509,514 ****
--- 515,523 ----
      /* Approximate the value of w_botline */
      wp->w_botline += lnum - wp->w_topline;
      wp->w_topline = lnum;
+ #ifdef FEAT_AUTOCMD
+     wp->w_topline_was_set = TRUE;
+ #endif
  #ifdef FEAT_DIFF
      wp->w_topfill = 0;
  #endif
*** ../vim-7.2.041/src/structs.h	Sun Nov  9 13:43:25 2008
--- src/structs.h	Sat Nov 15 14:56:42 2008
***************
*** 1784,1793 ****
  #endif
  
      /*
!      * The next three specify the offsets for displaying the buffer:
       */
      linenr_T	w_topline;	    /* buffer line number of the line at the
  				       top of the window */
  #ifdef FEAT_DIFF
      int		w_topfill;	    /* number of filler lines above w_topline */
      int		w_old_topfill;	    /* w_topfill at last redraw */
--- 1784,1798 ----
  #endif
  
      /*
!      * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
!      * displaying the buffer.
       */
      linenr_T	w_topline;	    /* buffer line number of the line at the
  				       top of the window */
+ #ifdef FEAT_AUTOCMD
+     char	w_topline_was_set;  /* flag set to TRUE when topline is set,
+ 				       e.g. by winrestview() */
+ #endif
  #ifdef FEAT_DIFF
      int		w_topfill;	    /* number of filler lines above w_topline */
      int		w_old_topfill;	    /* w_topfill at last redraw */
*** ../vim-7.2.041/src/version.c	Sat Nov 15 14:10:23 2008
--- src/version.c	Sat Nov 15 16:01:29 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     42,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
261. You find diskettes in your pockets when doing laundry.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.043
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.043
Problem:    VMS: Too many characters are escaped in filename and shell
	    commands.
Solution:   Escape fewer characters. (Zoltan Arpadffy)
Files:	    src/vim.h


*** ../vim-7.2.042/src/vim.h	Sun Nov  9 13:43:25 2008
--- src/vim.h	Fri Nov 14 21:41:17 2008
***************
*** 341,348 ****
  #ifdef BACKSLASH_IN_FILENAME
  # define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`%#'\"|!<")
  #else
! # define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
! # define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
  #endif
  
  #define NUMBUFLEN 30	    /* length of a buffer to store a number in ASCII */
--- 341,354 ----
  #ifdef BACKSLASH_IN_FILENAME
  # define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`%#'\"|!<")
  #else
! # ifdef VMS
!     /* VMS allows a lot of characters in the file name */
! #  define PATH_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'\"|!")
! #  define SHELL_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'|!()&")
! # else
! #  define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
! #  define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
! # endif
  #endif
  
  #define NUMBUFLEN 30	    /* length of a buffer to store a number in ASCII */
***************
*** 370,376 ****
     * Define __w64 as an empty token for everything but MSVC 7.x or later.
     */
  # if !defined(_MSC_VER)	|| (_MSC_VER < 1300)
! #  define __w64 
  # endif
  typedef unsigned long __w64	long_u;
  typedef		 long __w64     long_i;
--- 376,382 ----
     * Define __w64 as an empty token for everything but MSVC 7.x or later.
     */
  # if !defined(_MSC_VER)	|| (_MSC_VER < 1300)
! #  define __w64
  # endif
  typedef unsigned long __w64	long_u;
  typedef		 long __w64     long_i;
*** ../vim-7.2.042/src/version.c	Sat Nov 15 16:05:30 2008
--- src/version.c	Thu Nov 20 10:23:51 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     43,
  /**/

-- 
In his lifetime van Gogh painted 486 oil paintings. Oddly enough, 8975
of them are to be found in the United States.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.044
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.044
Problem:    Crash because of STRCPY() being over protective of the destination
	    size. (Dominique Pelle)
Solution:   Add -D_FORTIFY_SOURCE=1 to CFLAGS.  Use an intermediate variable
	    for the pointer to avoid a warning.
Files:	    src/auto/configure, src/configure.in, src/eval.c


*** ../vim-7.2.043/src/auto/configure	Thu Jul 24 17:20:50 2008
--- src/auto/configure	Sun Nov 16 17:08:44 2008
***************
*** 16819,16839 ****
    LDFLAGS="$LDFLAGS -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
  fi
  
- { $as_echo "$as_me:$LINENO: checking for GCC 3 or later" >&5
- $as_echo_n "checking for GCC 3 or later... " >&6; }
  DEPEND_CFLAGS_FILTER=
  if test "$GCC" = yes; then
    gccmajor=`echo "$gccversion" | sed -e 's/^\([1-9]\)\..*$/\1/g'`
    if test "$gccmajor" -gt "2"; then
      DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
!   fi
! fi
! if test "$DEPEND_CFLAGS_FILTER" = ""; then
!   { $as_echo "$as_me:$LINENO: result: no" >&5
  $as_echo "no" >&6; }
! else
!   { $as_echo "$as_me:$LINENO: result: yes" >&5
  $as_echo "yes" >&6; }
  fi
  
  
--- 16819,16847 ----
    LDFLAGS="$LDFLAGS -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
  fi
  
  DEPEND_CFLAGS_FILTER=
  if test "$GCC" = yes; then
+   { $as_echo "$as_me:$LINENO: checking for GCC 3 or later" >&5
+ $as_echo_n "checking for GCC 3 or later... " >&6; }
    gccmajor=`echo "$gccversion" | sed -e 's/^\([1-9]\)\..*$/\1/g'`
    if test "$gccmajor" -gt "2"; then
      DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
!     { $as_echo "$as_me:$LINENO: result: yes" >&5
! $as_echo "yes" >&6; }
!   else
!     { $as_echo "$as_me:$LINENO: result: no" >&5
  $as_echo "no" >&6; }
!   fi
!       { $as_echo "$as_me:$LINENO: checking whether we need -D_FORTIFY_SOURCE=1" >&5
! $as_echo_n "checking whether we need -D_FORTIFY_SOURCE=1... " >&6; }
!   if test "$gccmajor" -gt "3"; then
!     CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=1"
!     { $as_echo "$as_me:$LINENO: result: yes" >&5
  $as_echo "yes" >&6; }
+   else
+     { $as_echo "$as_me:$LINENO: result: no" >&5
+ $as_echo "no" >&6; }
+   fi
  fi
  
  
*** ../vim-7.2.043/src/configure.in	Thu Jul 24 17:20:31 2008
--- src/configure.in	Sun Nov 16 17:08:40 2008
***************
*** 3152,3169 ****
  dnl But only when making dependencies, cproto and lint don't take "-isystem".
  dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
  dnl the number before the version number.
- AC_MSG_CHECKING(for GCC 3 or later)
  DEPEND_CFLAGS_FILTER=
  if test "$GCC" = yes; then
    gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
    if test "$gccmajor" -gt "2"; then
      DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
    fi
- fi
- if test "$DEPEND_CFLAGS_FILTER" = ""; then
-   AC_MSG_RESULT(no)
- else
-   AC_MSG_RESULT(yes)
  fi
  AC_SUBST(DEPEND_CFLAGS_FILTER)
  
--- 3152,3176 ----
  dnl But only when making dependencies, cproto and lint don't take "-isystem".
  dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
  dnl the number before the version number.
  DEPEND_CFLAGS_FILTER=
  if test "$GCC" = yes; then
+   AC_MSG_CHECKING(for GCC 3 or later)
    gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
    if test "$gccmajor" -gt "2"; then
      DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
+     AC_MSG_RESULT(yes)
+   else
+     AC_MSG_RESULT(no)
+   fi
+   dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
+   dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
+   AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
+   if test "$gccmajor" -gt "3"; then
+     CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=1"
+     AC_MSG_RESULT(yes)
+   else
+     AC_MSG_RESULT(no)
    fi
  fi
  AC_SUBST(DEPEND_CFLAGS_FILTER)
  
*** ../vim-7.2.043/src/eval.c	Wed Nov 12 15:28:37 2008
--- src/eval.c	Sun Nov 16 20:46:28 2008
***************
*** 21150,21157 ****
      init_var_dict(&fc.l_avars, &fc.l_avars_var);
      add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "0",
  				(varnumber_T)(argcount - fp->uf_args.ga_len));
      v = &fc.fixvar[fixvar_idx++].var;
!     STRCPY(v->di_key, "000");
      v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
      hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
      v->di_tv.v_type = VAR_LIST;
--- 21150,21160 ----
      init_var_dict(&fc.l_avars, &fc.l_avars_var);
      add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "0",
  				(varnumber_T)(argcount - fp->uf_args.ga_len));
+     /* Use "name" to avoid a warning from some compiler that checks the
+      * destination size. */
      v = &fc.fixvar[fixvar_idx++].var;
!     name = v->di_key;
!     STRCPY(name, "000");
      v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
      hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
      v->di_tv.v_type = VAR_LIST;
*** ../vim-7.2.043/src/version.c	Thu Nov 20 10:26:19 2008
--- src/version.c	Thu Nov 20 10:34:31 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     44,
  /**/

-- 
Error:015 - Unable to exit Windows.  Try the door.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.045
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.045
Problem:    The Python interface has an empty entry in sys.path.
Solution:   Filter out the empty entry. (idea from James Vega)
Files:	    src/if_python.c


*** ../vim-7.2.044/src/if_python.c	Thu Jul 24 16:24:48 2008
--- src/if_python.c	Thu Nov 20 11:03:53 2008
***************
*** 531,536 ****
--- 531,542 ----
  	if (PythonMod_Init())
  	    goto fail;
  
+ 	/* Remove the element from sys.path that was added because of our
+ 	 * argv[0] value in PythonMod_Init().  Previously we used an empty
+ 	 * string, but dependinding on the OS we then get an empty entry or
+ 	 * the current directory in sys.path. */
+ 	PyRun_SimpleString("import sys; sys.path = filter(lambda x: x != '/must>not&exist', sys.path)");
+ 
  	/* the first python thread is vim's, release the lock */
  	Python_SaveThread();
  
***************
*** 2345,2351 ****
  {
      PyObject *mod;
      PyObject *dict;
!     static char *(argv[2]) = {"", NULL};
  
      /* Fixups... */
      BufferType.ob_type = &PyType_Type;
--- 2351,2358 ----
  {
      PyObject *mod;
      PyObject *dict;
!     /* The special value is removed from sys.path in Python_Init(). */
!     static char *(argv[2]) = {"/must>not&exist/foo", NULL};
  
      /* Fixups... */
      BufferType.ob_type = &PyType_Type;
*** ../vim-7.2.044/src/version.c	Thu Nov 20 10:36:04 2008
--- src/version.c	Thu Nov 20 10:58:11 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     45,
  /**/

-- 
press CTRL-ALT-DEL for more information

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.046
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.046
Problem:    Wrong check for filling buffer with encoding. (Danek Duvall)
Solution:   Remove pointers. (Dominique Pelle)
Files:	    src/mbyte.c


*** ../vim-7.2.045/src/mbyte.c	Wed Nov 12 13:07:48 2008
--- src/mbyte.c	Wed Nov 19 21:44:50 2008
***************
*** 3131,3137 ****
  	else
  	    s = p + 1;
      }
!     for (i = 0; s[i] != NUL && s + i < buf + sizeof(buf) - 1; ++i)
      {
  	if (s[i] == '_' || s[i] == '-')
  	    buf[i] = '-';
--- 3131,3137 ----
  	else
  	    s = p + 1;
      }
!     for (i = 0; s[i] != NUL && i < sizeof(buf) - 1; ++i)
      {
  	if (s[i] == '_' || s[i] == '-')
  	    buf[i] = '-';
*** ../vim-7.2.045/src/version.c	Thu Nov 20 11:04:01 2008
--- src/version.c	Thu Nov 20 11:54:23 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     46,
  /**/

-- 
       He was not in the least bit scared to be mashed into a pulp
       Or to have his eyes gouged out and his elbows broken;
       To have his kneecaps split and his body burned away
       And his limbs all hacked and mangled, brave Sir Robin.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.047
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.047
Problem:    Starting Vim with the -nb argument while it's not supported causes
	    the other side to hang.
Solution:   When -nb is used while it's not supported exit Vim. (Xavier de
	    Gaye)
Files:	    src/main.c, src/vim.h


*** ../vim-7.2.046/src/main.c	Sat Nov 15 14:10:23 2008
--- src/main.c	Thu Nov 20 14:09:27 2008
***************
*** 1510,1516 ****
  early_arg_scan(parmp)
      mparm_T	*parmp;
  {
! #if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER)
      int		argc = parmp->argc;
      char	**argv = parmp->argv;
      int		i;
--- 1510,1517 ----
  early_arg_scan(parmp)
      mparm_T	*parmp;
  {
! #if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER) \
! 	|| !defined(FEAT_NETBEANS_INTG)
      int		argc = parmp->argc;
      char	**argv = parmp->argv;
      int		i;
***************
*** 1582,1587 ****
--- 1583,1596 ----
  	else if (STRICMP(argv[i], "--echo-wid") == 0)
  	    echo_wid_arg = TRUE;
  # endif
+ # ifndef FEAT_NETBEANS_INTG
+ 	else if (strncmp(argv[i], "-nb", (size_t)3) == 0)
+         {
+             mch_errmsg(_("'-nb' cannot be used: not enabled at compile time\n"));
+             mch_exit(2);
+         }
+ # endif
+ 
      }
  #endif
  }
*** ../vim-7.2.046/src/vim.h	Thu Nov 20 10:26:19 2008
--- src/vim.h	Thu Nov 20 12:06:14 2008
***************
*** 1986,1991 ****
--- 1986,1994 ----
  # endif
  #endif
  
+ #ifndef FEAT_NETBEANS_INTG
+ # undef NBDEBUG
+ #endif
  #ifdef NBDEBUG /* Netbeans debugging. */
  # include "nbdebug.h"
  #else
*** ../vim-7.2.046/src/version.c	Thu Nov 20 11:55:53 2008
--- src/version.c	Thu Nov 20 14:07:57 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     47,
  /**/

-- 
FIRST HEAD:  Oh! quick! get the sword out I want to cut his head off.
THIRD HEAD:  Oh, cut your own head off.
SECOND HEAD: Yes - do us all a favour.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.048
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.048
Problem:    v:prevcount is changed too often.  Counts are not multiplied when
	    setting v:count.
Solution:   Set v:prevcount properly.  Multiply counts. (idea by Ben Schmidt)
Files:	    src/eval.c, src/normal.c, src/proto/eval.pro


*** ../vim-7.2.047/src/eval.c	Thu Nov 20 10:36:04 2008
--- src/eval.c	Thu Nov 20 15:53:47 2008
***************
*** 18146,18159 ****
  }
  
  /*
!  * Set v:count, v:count1 and v:prevcount.
   */
      void
! set_vcount(count, count1)
      long	count;
      long	count1;
  {
!     vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
      vimvars[VV_COUNT].vv_nr = count;
      vimvars[VV_COUNT1].vv_nr = count1;
  }
--- 18146,18162 ----
  }
  
  /*
!  * Set v:count to "count" and v:count1 to "count1".
!  * When "set_prevcount" is TRUE first set v:prevcount from v:count.
   */
      void
! set_vcount(count, count1, set_prevcount)
      long	count;
      long	count1;
+     int		set_prevcount;
  {
!     if (set_prevcount)
! 	vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
      vimvars[VV_COUNT].vv_nr = count;
      vimvars[VV_COUNT1].vv_nr = count1;
  }
*** ../vim-7.2.047/src/normal.c	Sat Nov 15 14:10:23 2008
--- src/normal.c	Thu Nov 20 16:04:44 2008
***************
*** 580,585 ****
--- 580,588 ----
      static int	old_mapped_len = 0;
  #endif
      int		idx;
+ #ifdef FEAT_EVAL
+     int		set_prevcount = FALSE;
+ #endif
  
      vim_memset(&ca, 0, sizeof(ca));	/* also resets ca.retval */
      ca.oap = oap;
***************
*** 615,621 ****
--- 618,629 ----
      /* When not finishing an operator and no register name typed, reset the
       * count. */
      if (!finish_op && !oap->regname)
+     {
  	ca.opcount = 0;
+ #ifdef FEAT_EVAL
+ 	set_prevcount = TRUE;
+ #endif
+     }
  
  #ifdef FEAT_AUTOCMD
      /* Restore counts from before receiving K_CURSORHOLD.  This means after
***************
*** 719,725 ****
  	     * command, so that v:count can be used in an expression mapping
  	     * right after the count. */
  	    if (toplevel && stuff_empty())
! 		set_vcount(ca.count0, ca.count0 == 0 ? 1 : ca.count0);
  #endif
  	    if (ctrl_w)
  	    {
--- 727,741 ----
  	     * command, so that v:count can be used in an expression mapping
  	     * right after the count. */
  	    if (toplevel && stuff_empty())
! 	    {
! 		long count = ca.count0;
! 
! 		/* multiply with ca.opcount the same way as below */
! 		if (ca.opcount != 0)
! 		    count = ca.opcount * (count == 0 ? 1 : count);
! 		set_vcount(count, count == 0 ? 1 : count, set_prevcount);
! 		set_prevcount = FALSE;  /* only set v:prevcount once */
! 	    }
  #endif
  	    if (ctrl_w)
  	    {
***************
*** 806,812 ****
       * Only set v:count when called from main() and not a stuffed command.
       */
      if (toplevel && stuff_empty())
! 	set_vcount(ca.count0, ca.count1);
  #endif
  
      /*
--- 822,828 ----
       * Only set v:count when called from main() and not a stuffed command.
       */
      if (toplevel && stuff_empty())
! 	set_vcount(ca.count0, ca.count1, set_prevcount);
  #endif
  
      /*
*** ../vim-7.2.047/src/proto/eval.pro	Sun Nov  9 13:43:25 2008
--- src/proto/eval.pro	Thu Nov 20 15:53:54 2008
***************
*** 61,67 ****
  long get_vim_var_nr __ARGS((int idx));
  char_u *get_vim_var_str __ARGS((int idx));
  list_T *get_vim_var_list __ARGS((int idx));
! void set_vcount __ARGS((long count, long count1));
  void set_vim_var_string __ARGS((int idx, char_u *val, int len));
  void set_vim_var_list __ARGS((int idx, list_T *val));
  void set_reg_var __ARGS((int c));
--- 61,67 ----
  long get_vim_var_nr __ARGS((int idx));
  char_u *get_vim_var_str __ARGS((int idx));
  list_T *get_vim_var_list __ARGS((int idx));
! void set_vcount __ARGS((long count, long count1, int set_prevcount));
  void set_vim_var_string __ARGS((int idx, char_u *val, int len));
  void set_vim_var_list __ARGS((int idx, list_T *val));
  void set_reg_var __ARGS((int c));
*** ../vim-7.2.047/src/version.c	Thu Nov 20 14:11:47 2008
--- src/version.c	Thu Nov 20 16:08:19 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     48,
  /**/

-- 
Microsoft's definition of a boolean: TRUE, FALSE, MAYBE
"Embrace and extend"...?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.049 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.049 (extra)
Problem:    Win32: the clipboard doesn't support UTF-16.
Solution:   Change UCS-2 support to UTF-16 support. (Jia Yanwei)
Files:	    src/gui_w32.c, src/gui_w48.c, src/mbyte.c, src/misc1.c,
	    src/os_mswin.c, src/os_win32.c, src/proto/os_mswin.pro


*** ../vim-7.2.048/src/gui_w32.c	Tue Jun 24 23:46:14 2008
--- src/gui_w32.c	Thu Nov 20 16:47:10 2008
***************
*** 992,998 ****
  			    SendMessage(lpdi->hdr.hwndFrom, TTM_SETMAXTIPWIDTH,
  								      0, 500);
  
! 			    tt_text = enc_to_ucs2(str, NULL);
  			    lpdi->lpszText = tt_text;
  			    /* can't show tooltip if failed */
  			}
--- 992,998 ----
  			    SendMessage(lpdi->hdr.hwndFrom, TTM_SETMAXTIPWIDTH,
  								      0, 500);
  
! 			    tt_text = enc_to_utf16(str, NULL);
  			    lpdi->lpszText = tt_text;
  			    /* can't show tooltip if failed */
  			}
***************
*** 1935,1941 ****
      if (buf == NULL)
  	return NULL;
  
!     convbuf = ucs2_to_enc(buf, lenp);
      pImmReleaseContext(hwnd, hIMC);
      vim_free(buf);
      return convbuf;
--- 1935,1941 ----
      if (buf == NULL)
  	return NULL;
  
!     convbuf = utf16_to_enc(buf, lenp);
      pImmReleaseContext(hwnd, hIMC);
      vim_free(buf);
      return convbuf;
***************
*** 2566,2572 ****
  	    {
  		/* 'encoding' differs from active codepage: convert menu name
  		 * and use wide function */
! 		wn = enc_to_ucs2(menu->name, NULL);
  		if (wn != NULL)
  		{
  		    MENUITEMINFOW	infow;
--- 2566,2572 ----
  	    {
  		/* 'encoding' differs from active codepage: convert menu name
  		 * and use wide function */
! 		wn = enc_to_utf16(menu->name, NULL);
  		if (wn != NULL)
  		{
  		    MENUITEMINFOW	infow;
***************
*** 2728,2734 ****
  	{
  	    /* 'encoding' differs from active codepage: convert menu item name
  	     * and use wide function */
! 	    wn = enc_to_ucs2(menu->name, NULL);
  	    if (wn != NULL)
  	    {
  		n = InsertMenuW(parent->submenu_id, (UINT)idx,
--- 2728,2734 ----
  	{
  	    /* 'encoding' differs from active codepage: convert menu item name
  	     * and use wide function */
! 	    wn = enc_to_utf16(menu->name, NULL);
  	    if (wn != NULL)
  	    {
  		n = InsertMenuW(parent->submenu_id, (UINT)idx,
***************
*** 3570,3576 ****
      if (enc_codepage == 0 && (int)GetACP() != enc_codepage)
      {
  	/* Not a codepage, use our own conversion function. */
! 	wn = enc_to_ucs2(lpAnsiIn, NULL);
  	if (wn != NULL)
  	{
  	    wcscpy(lpWCStr, wn);
--- 3570,3576 ----
      if (enc_codepage == 0 && (int)GetACP() != enc_codepage)
      {
  	/* Not a codepage, use our own conversion function. */
! 	wn = enc_to_utf16(lpAnsiIn, NULL);
  	if (wn != NULL)
  	{
  	    wcscpy(lpWCStr, wn);
*** ../vim-7.2.048/src/gui_w48.c	Wed Nov 12 13:35:31 2008
--- src/gui_w48.c	Thu Nov 20 16:42:32 2008
***************
*** 547,553 ****
  	else
  	{
  	    len = 1;
! 	    ws = ucs2_to_enc(wstring, &len);
  	    if (ws == NULL)
  		len = 0;
  	    else
--- 547,553 ----
  	else
  	{
  	    len = 1;
! 	    ws = utf16_to_enc(wstring, &len);
  	    if (ws == NULL)
  		len = 0;
  	    else
***************
*** 2128,2134 ****
      {
  	/* 'encoding' differs from active codepage: convert text and use wide
  	 * function */
! 	wstr = enc_to_ucs2(str, &wlen);
  	if (wstr != NULL)
  	{
  	    n = GetTextExtentPointW(hdc, wstr, wlen, &size);
--- 2128,2134 ----
      {
  	/* 'encoding' differs from active codepage: convert text and use wide
  	 * function */
! 	wstr = enc_to_utf16(str, &wlen);
  	if (wstr != NULL)
  	{
  	    n = GetTextExtentPointW(hdc, wstr, wlen, &size);
***************
*** 2252,2258 ****
      {
  	/* 'encoding' differs from active codepage: convert menu name
  	 * and use wide function */
! 	wn = enc_to_ucs2(item_text, NULL);
  	if (wn != NULL)
  	{
  	    MENUITEMINFOW	infow;
--- 2252,2258 ----
      {
  	/* 'encoding' differs from active codepage: convert menu name
  	 * and use wide function */
! 	wn = enc_to_utf16(item_text, NULL);
  	if (wn != NULL)
  	{
  	    MENUITEMINFOW	infow;
***************
*** 2422,2428 ****
  	if (use_unicode)
  	{
  	    /* Need to go through Unicode. */
! 	    wstr = enc_to_ucs2(NameBuff, NULL);
  	    if (wstr != NULL)
  	    {
  		TCITEMW		tiw;
--- 2422,2428 ----
  	if (use_unicode)
  	{
  	    /* Need to go through Unicode. */
! 	    wstr = enc_to_utf16(NameBuff, NULL);
  	    if (wstr != NULL)
  	    {
  		TCITEMW		tiw;
***************
*** 2521,2528 ****
  	WCHAR	*wbuf;
  	int	n;
  
! 	/* Convert the title from 'encoding' to ucs2. */
! 	wbuf = (WCHAR *)enc_to_ucs2((char_u *)title, NULL);
  	if (wbuf != NULL)
  	{
  	    n = SetWindowTextW(hwnd, wbuf);
--- 2521,2528 ----
  	WCHAR	*wbuf;
  	int	n;
  
! 	/* Convert the title from 'encoding' to UTF-16. */
! 	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
  	if (wbuf != NULL)
  	{
  	    n = SetWindowTextW(hwnd, wbuf);
***************
*** 3222,3228 ****
  	char_u *initdir,
  	char_u *filter)
  {
!     /* We always use the wide function.  This means enc_to_ucs2() must work,
       * otherwise it fails miserably! */
      OPENFILENAMEW	fileStruct;
      WCHAR		fileBuf[MAXPATHL];
--- 3222,3228 ----
  	char_u *initdir,
  	char_u *filter)
  {
!     /* We always use the wide function.  This means enc_to_utf16() must work,
       * otherwise it fails miserably! */
      OPENFILENAMEW	fileStruct;
      WCHAR		fileBuf[MAXPATHL];
***************
*** 3238,3244 ****
  	fileBuf[0] = NUL;
      else
      {
! 	wp = enc_to_ucs2(dflt, NULL);
  	if (wp == NULL)
  	    fileBuf[0] = NUL;
  	else
--- 3238,3244 ----
  	fileBuf[0] = NUL;
      else
      {
! 	wp = enc_to_utf16(dflt, NULL);
  	if (wp == NULL)
  	    fileBuf[0] = NUL;
  	else
***************
*** 3263,3273 ****
  #endif
  
      if (title != NULL)
! 	titlep = enc_to_ucs2(title, NULL);
      fileStruct.lpstrTitle = titlep;
  
      if (ext != NULL)
! 	extp = enc_to_ucs2(ext, NULL);
      fileStruct.lpstrDefExt = extp;
  
      fileStruct.lpstrFile = fileBuf;
--- 3263,3273 ----
  #endif
  
      if (title != NULL)
! 	titlep = enc_to_utf16(title, NULL);
      fileStruct.lpstrTitle = titlep;
  
      if (ext != NULL)
! 	extp = enc_to_utf16(ext, NULL);
      fileStruct.lpstrDefExt = extp;
  
      fileStruct.lpstrFile = fileBuf;
***************
*** 3278,3284 ****
      if (initdir != NULL && *initdir != NUL)
      {
  	/* Must have backslashes here, no matter what 'shellslash' says */
! 	initdirp = enc_to_ucs2(initdir, NULL);
  	if (initdirp != NULL)
  	{
  	    for (wp = initdirp; *wp != NUL; ++wp)
--- 3278,3284 ----
      if (initdir != NULL && *initdir != NUL)
      {
  	/* Must have backslashes here, no matter what 'shellslash' says */
! 	initdirp = enc_to_utf16(initdir, NULL);
  	if (initdirp != NULL)
  	{
  	    for (wp = initdirp; *wp != NUL; ++wp)
***************
*** 3318,3324 ****
      vim_free(extp);
  
      /* Convert from UCS2 to 'encoding'. */
!     p = ucs2_to_enc(fileBuf, NULL);
      if (p != NULL)
  	/* when out of memory we get garbage for non-ASCII chars */
  	STRCPY(fileBuf, p);
--- 3318,3324 ----
      vim_free(extp);
  
      /* Convert from UCS2 to 'encoding'. */
!     p = utf16_to_enc(fileBuf, NULL);
      if (p != NULL)
  	/* when out of memory we get garbage for non-ASCII chars */
  	STRCPY(fileBuf, p);
***************
*** 3518,3524 ****
  	{
  #ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
! 		fnames[i] = ucs2_to_enc(wszFile, NULL);
  	    else
  #endif
  	    {
--- 3518,3524 ----
  	{
  #ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
! 		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
  #endif
  	    {
*** ../vim-7.2.048/src/mbyte.c	Thu Nov 20 11:55:53 2008
--- src/mbyte.c	Thu Nov 20 16:47:41 2008
***************
*** 6101,6107 ****
  
  	    /* 1. codepage/UTF-8  ->  ucs-2. */
  	    if (vcp->vc_cpfrom == 0)
! 		tmp_len = utf8_to_ucs2(ptr, len, NULL, NULL);
  	    else
  		tmp_len = MultiByteToWideChar(vcp->vc_cpfrom, 0,
  							      ptr, len, 0, 0);
--- 6101,6107 ----
  
  	    /* 1. codepage/UTF-8  ->  ucs-2. */
  	    if (vcp->vc_cpfrom == 0)
! 		tmp_len = utf8_to_utf16(ptr, len, NULL, NULL);
  	    else
  		tmp_len = MultiByteToWideChar(vcp->vc_cpfrom, 0,
  							      ptr, len, 0, 0);
***************
*** 6109,6121 ****
  	    if (tmp == NULL)
  		break;
  	    if (vcp->vc_cpfrom == 0)
! 		utf8_to_ucs2(ptr, len, tmp, unconvlenp);
  	    else
  		MultiByteToWideChar(vcp->vc_cpfrom, 0, ptr, len, tmp, tmp_len);
  
  	    /* 2. ucs-2  ->  codepage/UTF-8. */
  	    if (vcp->vc_cpto == 0)
! 		retlen = ucs2_to_utf8(tmp, tmp_len, NULL);
  	    else
  		retlen = WideCharToMultiByte(vcp->vc_cpto, 0,
  						    tmp, tmp_len, 0, 0, 0, 0);
--- 6109,6121 ----
  	    if (tmp == NULL)
  		break;
  	    if (vcp->vc_cpfrom == 0)
! 		utf8_to_utf16(ptr, len, tmp, unconvlenp);
  	    else
  		MultiByteToWideChar(vcp->vc_cpfrom, 0, ptr, len, tmp, tmp_len);
  
  	    /* 2. ucs-2  ->  codepage/UTF-8. */
  	    if (vcp->vc_cpto == 0)
! 		retlen = utf16_to_utf8(tmp, tmp_len, NULL);
  	    else
  		retlen = WideCharToMultiByte(vcp->vc_cpto, 0,
  						    tmp, tmp_len, 0, 0, 0, 0);
***************
*** 6123,6129 ****
  	    if (retval != NULL)
  	    {
  		if (vcp->vc_cpto == 0)
! 		    ucs2_to_utf8(tmp, tmp_len, retval);
  		else
  		    WideCharToMultiByte(vcp->vc_cpto, 0,
  					  tmp, tmp_len, retval, retlen, 0, 0);
--- 6123,6129 ----
  	    if (retval != NULL)
  	    {
  		if (vcp->vc_cpto == 0)
! 		    utf16_to_utf8(tmp, tmp_len, retval);
  		else
  		    WideCharToMultiByte(vcp->vc_cpto, 0,
  					  tmp, tmp_len, retval, retlen, 0, 0);
*** ../vim-7.2.048/src/misc1.c	Sun Nov  9 13:43:25 2008
--- src/misc1.c	Thu Nov 20 16:42:59 2008
***************
*** 8728,8734 ****
  	/* The active codepage differs from 'encoding'.  Attempt using the
  	 * wide function.  If it fails because it is not implemented fall back
  	 * to the non-wide version (for Windows 98) */
! 	wn = enc_to_ucs2(buf, NULL);
  	if (wn != NULL)
  	{
  	    hFind = FindFirstFileW(wn, &wfb);
--- 8728,8734 ----
  	/* The active codepage differs from 'encoding'.  Attempt using the
  	 * wide function.  If it fails because it is not implemented fall back
  	 * to the non-wide version (for Windows 98) */
! 	wn = enc_to_utf16(buf, NULL);
  	if (wn != NULL)
  	{
  	    hFind = FindFirstFileW(wn, &wfb);
***************
*** 8756,8762 ****
  #ifdef WIN3264
  # ifdef FEAT_MBYTE
  	if (wn != NULL)
! 	    p = ucs2_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
  	else
  # endif
  	    p = (char_u *)fb.cFileName;
--- 8756,8762 ----
  #ifdef WIN3264
  # ifdef FEAT_MBYTE
  	if (wn != NULL)
! 	    p = utf16_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
  	else
  # endif
  	    p = (char_u *)fb.cFileName;
***************
*** 8830,8836 ****
  	    if (wn != NULL)
  	    {
  		vim_free(wn);
! 		wn = enc_to_ucs2(buf, NULL);
  		if (wn != NULL)
  		    hFind = FindFirstFileW(wn, &wfb);
  	    }
--- 8830,8836 ----
  	    if (wn != NULL)
  	    {
  		vim_free(wn);
! 		wn = enc_to_utf16(buf, NULL);
  		if (wn != NULL)
  		    hFind = FindFirstFileW(wn, &wfb);
  	    }
*** ../vim-7.2.048/src/os_mswin.c	Sat Aug  9 19:37:30 2008
--- src/os_mswin.c	Thu Nov 20 17:05:10 2008
***************
*** 309,315 ****
  	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	{
  	    /* Convert the title from 'encoding' to the active codepage. */
! 	    WCHAR	*wp = enc_to_ucs2(title, NULL);
  	    int	n;
  
  	    if (wp != NULL)
--- 309,315 ----
  	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	{
  	    /* Convert the title from 'encoding' to the active codepage. */
! 	    WCHAR	*wp = enc_to_utf16(title, NULL);
  	    int	n;
  
  	    if (wp != NULL)
***************
*** 406,415 ****
  	     * - invoke _wfullpath()
  	     * - convert the result from UCS2 to 'encoding'.
  	     */
! 	    wname = enc_to_ucs2(fname, NULL);
  	    if (wname != NULL && _wfullpath(wbuf, wname, MAX_PATH - 1) != NULL)
  	    {
! 		cname = ucs2_to_enc((short_u *)wbuf, NULL);
  		if (cname != NULL)
  		{
  		    vim_strncpy(buf, cname, len - 1);
--- 406,415 ----
  	     * - invoke _wfullpath()
  	     * - convert the result from UCS2 to 'encoding'.
  	     */
! 	    wname = enc_to_utf16(fname, NULL);
  	    if (wname != NULL && _wfullpath(wbuf, wname, MAX_PATH - 1) != NULL)
  	    {
! 		cname = utf16_to_enc((short_u *)wbuf, NULL);
  		if (cname != NULL)
  		{
  		    vim_strncpy(buf, cname, len - 1);
***************
*** 507,513 ****
  # endif
         )
      {
! 	WCHAR	*wp = enc_to_ucs2(buf, NULL);
  	int	n;
  
  	if (wp != NULL)
--- 507,513 ----
  # endif
         )
      {
! 	WCHAR	*wp = enc_to_utf16(buf, NULL);
  	int	n;
  
  	if (wp != NULL)
***************
*** 668,674 ****
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	WCHAR	*p = enc_to_ucs2(path, NULL);
  	int	n;
  
  	if (p != NULL)
--- 668,674 ----
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	WCHAR	*p = enc_to_utf16(path, NULL);
  	int	n;
  
  	if (p != NULL)
***************
*** 891,909 ****
  
  #if defined(FEAT_MBYTE) || defined(PROTO)
  /*
!  * Convert an UTF-8 string to UCS-2.
   * "instr[inlen]" is the input.  "inlen" is in bytes.
!  * When "outstr" is NULL only return the number of UCS-2 words produced.
   * Otherwise "outstr" must be a buffer of sufficient size.
!  * Returns the number of UCS-2 words produced.
   */
      int
! utf8_to_ucs2(char_u *instr, int inlen, short_u *outstr, int *unconvlenp)
  {
      int		outlen = 0;
      char_u	*p = instr;
      int		todo = inlen;
      int		l;
  
      while (todo > 0)
      {
--- 891,910 ----
  
  #if defined(FEAT_MBYTE) || defined(PROTO)
  /*
!  * Convert an UTF-8 string to UTF-16.
   * "instr[inlen]" is the input.  "inlen" is in bytes.
!  * When "outstr" is NULL only return the number of UTF-16 words produced.
   * Otherwise "outstr" must be a buffer of sufficient size.
!  * Returns the number of UTF-16 words produced.
   */
      int
! utf8_to_utf16(char_u *instr, int inlen, short_u *outstr, int *unconvlenp)
  {
      int		outlen = 0;
      char_u	*p = instr;
      int		todo = inlen;
      int		l;
+     int		ch;
  
      while (todo > 0)
      {
***************
*** 917,924 ****
  	    break;
  	}
  
! 	if (outstr != NULL)
! 	    *outstr++ = utf_ptr2char(p);
  	++outlen;
  	p += l;
  	todo -= l;
--- 918,936 ----
  	    break;
  	}
  
! 	ch = utf_ptr2char(p);
! 	if (ch >= 0x10000)
! 	{
! 	    /* non-BMP character, encoding with surrogate pairs */
! 	    ++outlen;
! 	    if (outstr != NULL)
! 	    {
! 		*outstr++ = (0xD800 - (0x10000 >> 10)) + (ch >> 10);
! 		*outstr++ = 0xDC00 | (ch & 0x3FF);
! 	    }
! 	}
! 	else if (outstr != NULL)
! 	    *outstr++ = ch;
  	++outlen;
  	p += l;
  	todo -= l;
***************
*** 928,956 ****
  }
  
  /*
!  * Convert an UCS-2 string to UTF-8.
!  * The input is "instr[inlen]" with "inlen" in number of ucs-2 words.
   * When "outstr" is NULL only return the required number of bytes.
   * Otherwise "outstr" must be a buffer of sufficient size.
   * Return the number of bytes produced.
   */
      int
! ucs2_to_utf8(short_u *instr, int inlen, char_u *outstr)
  {
      int		outlen = 0;
      int		todo = inlen;
      short_u	*p = instr;
      int		l;
  
      while (todo > 0)
      {
  	if (outstr != NULL)
  	{
! 	    l = utf_char2bytes(*p, outstr);
  	    outstr += l;
  	}
  	else
! 	    l = utf_char2len(*p);
  	++p;
  	outlen += l;
  	--todo;
--- 940,981 ----
  }
  
  /*
!  * Convert an UTF-16 string to UTF-8.
!  * The input is "instr[inlen]" with "inlen" in number of UTF-16 words.
   * When "outstr" is NULL only return the required number of bytes.
   * Otherwise "outstr" must be a buffer of sufficient size.
   * Return the number of bytes produced.
   */
      int
! utf16_to_utf8(short_u *instr, int inlen, char_u *outstr)
  {
      int		outlen = 0;
      int		todo = inlen;
      short_u	*p = instr;
      int		l;
+     int		ch, ch2;
  
      while (todo > 0)
      {
+ 	ch = *p;
+ 	if (ch >= 0xD800 && ch <= 0xDBFF && todo > 1)
+ 	{
+ 	    /* surrogate pairs handling */
+ 	    ch2 = p[1];
+ 	    if (ch2 >= 0xDC00 && ch2 <= 0xDFFF)
+ 	    {
+ 		ch = ((ch - 0xD800) << 10) + (ch2 & 0x3FF) + 0x10000;
+ 		++p;
+ 		--todo;
+ 	    }
+ 	}
  	if (outstr != NULL)
  	{
! 	    l = utf_char2bytes(ch, outstr);
  	    outstr += l;
  	}
  	else
! 	    l = utf_char2len(ch);
  	++p;
  	outlen += l;
  	--todo;
***************
*** 1079,1092 ****
   */
  
  /*
!  * Convert "str" from 'encoding' to UCS-2.
   * Input in "str" with length "*lenp".  When "lenp" is NULL, use strlen().
   * Output is returned as an allocated string.  "*lenp" is set to the length of
   * the result.  A trailing NUL is always added.
   * Returns NULL when out of memory.
   */
      short_u *
! enc_to_ucs2(char_u *str, int *lenp)
  {
      vimconv_T	conv;
      WCHAR	*ret;
--- 1104,1117 ----
   */
  
  /*
!  * Convert "str" from 'encoding' to UTF-16.
   * Input in "str" with length "*lenp".  When "lenp" is NULL, use strlen().
   * Output is returned as an allocated string.  "*lenp" is set to the length of
   * the result.  A trailing NUL is always added.
   * Returns NULL when out of memory.
   */
      short_u *
! enc_to_utf16(char_u *str, int *lenp)
  {
      vimconv_T	conv;
      WCHAR	*ret;
***************
*** 1102,1108 ****
  
      if (enc_codepage > 0)
      {
! 	/* We can do any CP### -> UCS-2 in one pass, and we can do it
  	 * without iconv() (convert_* may need iconv). */
  	MultiByteToWideChar_alloc(enc_codepage, 0, str, *lenp, &ret, &length);
      }
--- 1127,1133 ----
  
      if (enc_codepage > 0)
      {
! 	/* We can do any CP### -> UTF-16 in one pass, and we can do it
  	 * without iconv() (convert_* may need iconv). */
  	MultiByteToWideChar_alloc(enc_codepage, 0, str, *lenp, &ret, &length);
      }
***************
*** 1123,1133 ****
  	}
  	convert_setup(&conv, NULL, NULL);
  
! 	length = utf8_to_ucs2(str, *lenp, NULL, NULL);
  	ret = (WCHAR *)alloc((unsigned)((length + 1) * sizeof(WCHAR)));
  	if (ret != NULL)
  	{
! 	    utf8_to_ucs2(str, *lenp, (short_u *)ret, NULL);
  	    ret[length] = 0;
  	}
  
--- 1148,1158 ----
  	}
  	convert_setup(&conv, NULL, NULL);
  
! 	length = utf8_to_utf16(str, *lenp, NULL, NULL);
  	ret = (WCHAR *)alloc((unsigned)((length + 1) * sizeof(WCHAR)));
  	if (ret != NULL)
  	{
! 	    utf8_to_utf16(str, *lenp, (short_u *)ret, NULL);
  	    ret[length] = 0;
  	}
  
***************
*** 1139,1145 ****
  }
  
  /*
!  * Convert an UCS-2 string to 'encoding'.
   * Input in "str" with length (counted in wide characters) "*lenp".  When
   * "lenp" is NULL, use wcslen().
   * Output is returned as an allocated string.  If "*lenp" is not NULL it is
--- 1164,1170 ----
  }
  
  /*
!  * Convert an UTF-16 string to 'encoding'.
   * Input in "str" with length (counted in wide characters) "*lenp".  When
   * "lenp" is NULL, use wcslen().
   * Output is returned as an allocated string.  If "*lenp" is not NULL it is
***************
*** 1147,1153 ****
   * Returns NULL when out of memory.
   */
      char_u *
! ucs2_to_enc(short_u *str, int *lenp)
  {
      vimconv_T	conv;
      char_u	*utf8_str = NULL, *enc_str = NULL;
--- 1172,1178 ----
   * Returns NULL when out of memory.
   */
      char_u *
! utf16_to_enc(short_u *str, int *lenp)
  {
      vimconv_T	conv;
      char_u	*utf8_str = NULL, *enc_str = NULL;
***************
*** 1161,1167 ****
  
      if (enc_codepage > 0)
      {
! 	/* We can do any UCS-2 -> CP### in one pass. */
  	int length;
  
  	WideCharToMultiByte_alloc(enc_codepage, 0, str, *lenp,
--- 1186,1192 ----
  
      if (enc_codepage > 0)
      {
! 	/* We can do any UTF-16 -> CP### in one pass. */
  	int length;
  
  	WideCharToMultiByte_alloc(enc_codepage, 0, str, *lenp,
***************
*** 1171,1180 ****
      }
  
      /* Avoid allocating zero bytes, it generates an error message. */
!     utf8_str = alloc(ucs2_to_utf8(str, *lenp == 0 ? 1 : *lenp, NULL));
      if (utf8_str != NULL)
      {
! 	*lenp = ucs2_to_utf8(str, *lenp, utf8_str);
  
  	/* We might be called before we have p_enc set up. */
  	conv.vc_type = CONV_NONE;
--- 1196,1205 ----
      }
  
      /* Avoid allocating zero bytes, it generates an error message. */
!     utf8_str = alloc(utf16_to_utf8(str, *lenp == 0 ? 1 : *lenp, NULL));
      if (utf8_str != NULL)
      {
! 	*lenp = utf16_to_utf8(str, *lenp, utf8_str);
  
  	/* We might be called before we have p_enc set up. */
  	conv.vc_type = CONV_NONE;
***************
*** 1308,1314 ****
  		    if (hMemWstr[str_size] == NUL)
  			break;
  	    }
! 	    to_free = str = ucs2_to_enc((short_u *)hMemWstr, &str_size);
  	    GlobalUnlock(hMemW);
  	}
      }
--- 1333,1339 ----
  		    if (hMemWstr[str_size] == NUL)
  			break;
  	    }
! 	    to_free = str = utf16_to_enc((short_u *)hMemWstr, &str_size);
  	    GlobalUnlock(hMemW);
  	}
      }
***************
*** 1340,1346 ****
  
  # if defined(FEAT_MBYTE) && defined(WIN3264)
  	    /* The text is in the active codepage.  Convert to 'encoding',
! 	     * going through UCS-2. */
  	    acp_to_enc(str, str_size, &to_free, &maxlen);
  	    if (to_free != NULL)
  	    {
--- 1365,1371 ----
  
  # if defined(FEAT_MBYTE) && defined(WIN3264)
  	    /* The text is in the active codepage.  Convert to 'encoding',
! 	     * going through UTF-16. */
  	    acp_to_enc(str, str_size, &to_free, &maxlen);
  	    if (to_free != NULL)
  	    {
***************
*** 1404,1410 ****
      if (widestr != NULL)
      {
  	++*outlen;	/* Include the 0 after the string */
! 	*out = ucs2_to_enc((short_u *)widestr, outlen);
  	vim_free(widestr);
      }
  }
--- 1429,1435 ----
      if (widestr != NULL)
      {
  	++*outlen;	/* Include the 0 after the string */
! 	*out = utf16_to_enc((short_u *)widestr, outlen);
  	vim_free(widestr);
      }
  }
***************
*** 1466,1474 ****
  	WCHAR		*out;
  	int		len = metadata.txtlen;
  
! 	/* Convert the text to UCS-2. This is put on the clipboard as
  	 * CF_UNICODETEXT. */
! 	out = (WCHAR *)enc_to_ucs2(str, &len);
  	if (out != NULL)
  	{
  	    WCHAR *lpszMemW;
--- 1491,1499 ----
  	WCHAR		*out;
  	int		len = metadata.txtlen;
  
! 	/* Convert the text to UTF-16. This is put on the clipboard as
  	 * CF_UNICODETEXT. */
! 	out = (WCHAR *)enc_to_utf16(str, &len);
  	if (out != NULL)
  	{
  	    WCHAR *lpszMemW;
***************
*** 1488,1494 ****
  	    WideCharToMultiByte(GetACP(), 0, out, len,
  						  str, metadata.txtlen, 0, 0);
  
! 	    /* Allocate memory for the UCS-2 text, add one NUL word to
  	     * terminate the string. */
  	    hMemW = (LPSTR)GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
  						   (len + 1) * sizeof(WCHAR));
--- 1513,1519 ----
  	    WideCharToMultiByte(GetACP(), 0, out, len,
  						  str, metadata.txtlen, 0, 0);
  
! 	    /* Allocate memory for the UTF-16 text, add one NUL word to
  	     * terminate the string. */
  	    hMemW = (LPSTR)GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
  						   (len + 1) * sizeof(WCHAR));
*** ../vim-7.2.048/src/os_win32.c	Thu Jul 24 20:50:30 2008
--- src/os_win32.c	Thu Nov 20 16:44:33 2008
***************
*** 1587,1593 ****
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	WCHAR	*p = enc_to_ucs2(name, NULL);
  	WCHAR	fnamew[_MAX_PATH];
  	WCHAR	*dumw;
  	long	n;
--- 1587,1593 ----
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	WCHAR	*p = enc_to_utf16(name, NULL);
  	WCHAR	fnamew[_MAX_PATH];
  	WCHAR	*dumw;
  	long	n;
***************
*** 2440,2446 ****
  
  	if (GetCurrentDirectoryW(_MAX_PATH, wbuf) != 0)
  	{
! 	    char_u  *p = ucs2_to_enc(wbuf, NULL);
  
  	    if (p != NULL)
  	    {
--- 2440,2446 ----
  
  	if (GetCurrentDirectoryW(_MAX_PATH, wbuf) != 0)
  	{
! 	    char_u  *p = utf16_to_enc(wbuf, NULL);
  
  	    if (p != NULL)
  	    {
***************
*** 2466,2472 ****
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	WCHAR	*p = enc_to_ucs2(name, NULL);
  	long	n;
  
  	if (p != NULL)
--- 2466,2472 ----
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	WCHAR	*p = enc_to_utf16(name, NULL);
  	long	n;
  
  	if (p != NULL)
***************
*** 2495,2501 ****
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	WCHAR	*p = enc_to_ucs2(name, NULL);
  	long	n;
  
  	if (p != NULL)
--- 2495,2501 ----
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	WCHAR	*p = enc_to_utf16(name, NULL);
  	long	n;
  
  	if (p != NULL)
***************
*** 2522,2528 ****
      WCHAR	*p = NULL;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	p = enc_to_ucs2(name, NULL);
  #endif
  
  #ifdef FEAT_MBYTE
--- 2522,2528 ----
      WCHAR	*p = NULL;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	p = enc_to_utf16(name, NULL);
  #endif
  
  #ifdef FEAT_MBYTE
***************
*** 2590,2596 ****
      WCHAR	*wn = NULL;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	wn = enc_to_ucs2(fname, NULL);
      if (wn != NULL)
      {
  	hFile = CreateFileW(wn,		/* file name */
--- 2590,2596 ----
      WCHAR	*wn = NULL;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	wn = enc_to_utf16(fname, NULL);
      if (wn != NULL)
      {
  	hFile = CreateFileW(wn,		/* file name */
***************
*** 4239,4245 ****
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	wn = enc_to_ucs2(name, NULL);
  	if (wn != NULL)
  	{
  	    SetFileAttributesW(wn, FILE_ATTRIBUTE_NORMAL);
--- 4239,4245 ----
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	wn = enc_to_utf16(name, NULL);
  	if (wn != NULL)
  	{
  	    SetFileAttributesW(wn, FILE_ATTRIBUTE_NORMAL);
***************
*** 4382,4389 ****
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	wold = enc_to_ucs2((char_u *)pszOldFile, NULL);
! 	wnew = enc_to_ucs2((char_u *)pszNewFile, NULL);
  	if (wold != NULL && wnew != NULL)
  	    retval = mch_wrename(wold, wnew);
  	vim_free(wold);
--- 4382,4389 ----
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	wold = enc_to_utf16((char_u *)pszOldFile, NULL);
! 	wnew = enc_to_utf16((char_u *)pszNewFile, NULL);
  	if (wold != NULL && wnew != NULL)
  	    retval = mch_wrename(wold, wnew);
  	vim_free(wold);
***************
*** 4492,4498 ****
      WCHAR	*wn = NULL;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	wn = enc_to_ucs2(n, NULL);
  #endif
  
      if (mch_isdir(n))
--- 4492,4498 ----
      WCHAR	*wn = NULL;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	wn = enc_to_utf16(n, NULL);
  #endif
  
      if (mch_isdir(n))
***************
*** 4618,4624 ****
  
  #if defined(FEAT_MBYTE) || defined(PROTO)
  /*
!  * Version of open() that may use ucs2 file name.
   */
      int
  mch_open(char *name, int flags, int mode)
--- 4618,4624 ----
  
  #if defined(FEAT_MBYTE) || defined(PROTO)
  /*
!  * Version of open() that may use UTF-16 file name.
   */
      int
  mch_open(char *name, int flags, int mode)
***************
*** 4630,4636 ****
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	wn = enc_to_ucs2(name, NULL);
  	if (wn != NULL)
  	{
  	    f = _wopen(wn, flags, mode);
--- 4630,4636 ----
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	wn = enc_to_utf16(name, NULL);
  	if (wn != NULL)
  	{
  	    f = _wopen(wn, flags, mode);
***************
*** 4648,4654 ****
  }
  
  /*
!  * Version of fopen() that may use ucs2 file name.
   */
      FILE *
  mch_fopen(char *name, char *mode)
--- 4648,4654 ----
  }
  
  /*
!  * Version of fopen() that may use UTF-16 file name.
   */
      FILE *
  mch_fopen(char *name, char *mode)
***************
*** 4675,4682 ****
  	else if (newMode == 'b')
  	    _set_fmode(_O_BINARY);
  # endif
! 	wn = enc_to_ucs2(name, NULL);
! 	wm = enc_to_ucs2(mode, NULL);
  	if (wn != NULL && wm != NULL)
  	    f = _wfopen(wn, wm);
  	vim_free(wn);
--- 4675,4682 ----
  	else if (newMode == 'b')
  	    _set_fmode(_O_BINARY);
  # endif
! 	wn = enc_to_utf16(name, NULL);
! 	wm = enc_to_utf16(mode, NULL);
  	if (wn != NULL && wm != NULL)
  	    f = _wfopen(wn, wm);
  	vim_free(wn);
***************
*** 4776,4783 ****
      int			len;
  
      /* Convert the file names to wide characters. */
!     fromw = enc_to_ucs2(from, NULL);
!     tow = enc_to_ucs2(to, NULL);
      if (fromw != NULL && tow != NULL)
      {
  	/* Open the file for reading. */
--- 4776,4783 ----
      int			len;
  
      /* Convert the file names to wide characters. */
!     fromw = enc_to_utf16(from, NULL);
!     tow = enc_to_utf16(to, NULL);
      if (fromw != NULL && tow != NULL)
      {
  	/* Open the file for reading. */
***************
*** 5122,5128 ****
      for (i = 0; i < used_file_count; ++i)
      {
  	idx = used_file_indexes[i];
! 	str = ucs2_to_enc(ArglistW[idx], NULL);
  	if (str != NULL)
  	{
  #ifdef FEAT_DIFF
--- 5122,5128 ----
      for (i = 0; i < used_file_count; ++i)
      {
  	idx = used_file_indexes[i];
! 	str = utf16_to_enc(ArglistW[idx], NULL);
  	if (str != NULL)
  	{
  #ifdef FEAT_DIFF
*** ../vim-7.2.048/src/proto/os_mswin.pro	Sat May  5 19:07:50 2007
--- src/proto/os_mswin.pro	Thu Nov 20 16:41:00 2008
***************
*** 22,35 ****
  int can_end_termcap_mode __ARGS((int give_msg));
  int mch_screenmode __ARGS((char_u *arg));
  int mch_libcall __ARGS((char_u *libname, char_u *funcname, char_u *argstring, int argint, char_u **string_result, int *number_result));
! int utf8_to_ucs2 __ARGS((char_u *instr, int inlen, short_u *outstr, int *unconvlenp));
! int ucs2_to_utf8 __ARGS((short_u *instr, int inlen, char_u *outstr));
  void MultiByteToWideChar_alloc __ARGS((UINT cp, DWORD flags, LPCSTR in, int inlen, LPWSTR *out, int *outlen));
  void WideCharToMultiByte_alloc __ARGS((UINT cp, DWORD flags, LPCWSTR in, int inlen, LPSTR *out, int *outlen, LPCSTR def, LPBOOL useddef));
  int clip_mch_own_selection __ARGS((VimClipboard *cbd));
  void clip_mch_lose_selection __ARGS((VimClipboard *cbd));
! short_u *enc_to_ucs2 __ARGS((char_u *str, int *lenp));
! char_u *ucs2_to_enc __ARGS((short_u *str, int *lenp));
  void clip_mch_request_selection __ARGS((VimClipboard *cbd));
  void acp_to_enc __ARGS((char_u *str, int str_size, char_u **out, int *outlen));
  void clip_mch_set_selection __ARGS((VimClipboard *cbd));
--- 22,35 ----
  int can_end_termcap_mode __ARGS((int give_msg));
  int mch_screenmode __ARGS((char_u *arg));
  int mch_libcall __ARGS((char_u *libname, char_u *funcname, char_u *argstring, int argint, char_u **string_result, int *number_result));
! int utf8_to_utf16 __ARGS((char_u *instr, int inlen, short_u *outstr, int *unconvlenp));
! int utf16_to_utf8 __ARGS((short_u *instr, int inlen, char_u *outstr));
  void MultiByteToWideChar_alloc __ARGS((UINT cp, DWORD flags, LPCSTR in, int inlen, LPWSTR *out, int *outlen));
  void WideCharToMultiByte_alloc __ARGS((UINT cp, DWORD flags, LPCWSTR in, int inlen, LPSTR *out, int *outlen, LPCSTR def, LPBOOL useddef));
  int clip_mch_own_selection __ARGS((VimClipboard *cbd));
  void clip_mch_lose_selection __ARGS((VimClipboard *cbd));
! short_u *enc_to_utf16 __ARGS((char_u *str, int *lenp));
! char_u *utf16_to_enc __ARGS((short_u *str, int *lenp));
  void clip_mch_request_selection __ARGS((VimClipboard *cbd));
  void acp_to_enc __ARGS((char_u *str, int str_size, char_u **out, int *outlen));
  void clip_mch_set_selection __ARGS((VimClipboard *cbd));
*** ../vim-7.2.048/src/version.c	Thu Nov 20 16:11:03 2008
--- src/version.c	Thu Nov 20 17:08:07 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     49,
  /**/

-- 
FIRST HEAD: All right! All right! We'll kill him first and then have tea and
            biscuits.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.050
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.050
Problem:    Warnings for not checking return value of fwrite(). (Chip Campbell)
Solution:   Use the return value.
Files:	    src/spell.c


*** ../vim-7.2.049/src/spell.c	Mon Aug 25 04:12:38 2008
--- src/spell.c	Thu Nov 20 17:28:01 2008
***************
*** 7926,7931 ****
--- 7926,7933 ----
      char_u	*p;
      int		rr;
      int		retval = OK;
+     int		fwv = 1;  /* collect return value of fwrite() to avoid
+ 			     warnings from picky compiler */
  
      fd = mch_fopen((char *)fname, "w");
      if (fd == NULL)
***************
*** 7936,7946 ****
  
      /* <HEADER>: <fileID> <versionnr> */
  							    /* <fileID> */
!     if (fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd) != 1)
!     {
! 	EMSG(_(e_write));
! 	retval = FAIL;
!     }
      putc(VIMSPELLVERSION, fd);				    /* <versionnr> */
  
      /*
--- 7938,7944 ----
  
      /* <HEADER>: <fileID> <versionnr> */
  							    /* <fileID> */
!     fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);
      putc(VIMSPELLVERSION, fd);				    /* <versionnr> */
  
      /*
***************
*** 7955,7961 ****
  
  	i = (int)STRLEN(spin->si_info);
  	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
! 	fwrite(spin->si_info, (size_t)i, (size_t)1, fd); /* <infotext> */
      }
  
      /* SN_REGION: <regionname> ...
--- 7953,7959 ----
  
  	i = (int)STRLEN(spin->si_info);
  	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
! 	fwv &= fwrite(spin->si_info, (size_t)i, (size_t)1, fd); /* <infotext> */
      }
  
      /* SN_REGION: <regionname> ...
***************
*** 7966,7972 ****
  	putc(SNF_REQUIRED, fd);				/* <sectionflags> */
  	l = spin->si_region_count * 2;
  	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
! 	fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);
  							/* <regionname> ... */
  	regionmask = (1 << spin->si_region_count) - 1;
      }
--- 7964,7970 ----
  	putc(SNF_REQUIRED, fd);				/* <sectionflags> */
  	l = spin->si_region_count * 2;
  	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
! 	fwv &= fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);
  							/* <regionname> ... */
  	regionmask = (1 << spin->si_region_count) - 1;
      }
***************
*** 8016,8022 ****
  	}
  
  	put_bytes(fd, (long_u)l, 2);			/* <folcharslen> */
! 	fwrite(folchars, (size_t)l, (size_t)1, fd);	/* <folchars> */
      }
  
      /* SN_MIDWORD: <midword> */
--- 8014,8020 ----
  	}
  
  	put_bytes(fd, (long_u)l, 2);			/* <folcharslen> */
! 	fwv &= fwrite(folchars, (size_t)l, (size_t)1, fd); /* <folchars> */
      }
  
      /* SN_MIDWORD: <midword> */
***************
*** 8027,8033 ****
  
  	i = (int)STRLEN(spin->si_midword);
  	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
! 	fwrite(spin->si_midword, (size_t)i, (size_t)1, fd); /* <midword> */
      }
  
      /* SN_PREFCOND: <prefcondcnt> <prefcond> ... */
--- 8025,8032 ----
  
  	i = (int)STRLEN(spin->si_midword);
  	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
! 	fwv &= fwrite(spin->si_midword, (size_t)i, (size_t)1, fd);
! 							/* <midword> */
      }
  
      /* SN_PREFCOND: <prefcondcnt> <prefcond> ... */
***************
*** 8113,8119 ****
  		p = rr == 1 ? ftp->ft_from : ftp->ft_to;
  		l = (int)STRLEN(p);
  		putc(l, fd);
! 		fwrite(p, l, (size_t)1, fd);
  	    }
  	}
  
--- 8112,8118 ----
  		p = rr == 1 ? ftp->ft_from : ftp->ft_to;
  		l = (int)STRLEN(p);
  		putc(l, fd);
! 		fwv &= fwrite(p, l, (size_t)1, fd);
  	    }
  	}
  
***************
*** 8131,8141 ****
  							/* <sectionlen> */
  
  	put_bytes(fd, (long_u)l, 2);			/* <sofofromlen> */
! 	fwrite(spin->si_sofofr, l, (size_t)1, fd);	/* <sofofrom> */
  
  	l = (int)STRLEN(spin->si_sofoto);
  	put_bytes(fd, (long_u)l, 2);			/* <sofotolen> */
! 	fwrite(spin->si_sofoto, l, (size_t)1, fd);	/* <sofoto> */
      }
  
      /* SN_WORDS: <word> ...
--- 8130,8140 ----
  							/* <sectionlen> */
  
  	put_bytes(fd, (long_u)l, 2);			/* <sofofromlen> */
! 	fwv &= fwrite(spin->si_sofofr, l, (size_t)1, fd); /* <sofofrom> */
  
  	l = (int)STRLEN(spin->si_sofoto);
  	put_bytes(fd, (long_u)l, 2);			/* <sofotolen> */
! 	fwv &= fwrite(spin->si_sofoto, l, (size_t)1, fd); /* <sofoto> */
      }
  
      /* SN_WORDS: <word> ...
***************
*** 8160,8166 ****
  		    l = (int)STRLEN(hi->hi_key) + 1;
  		    len += l;
  		    if (round == 2)			/* <word> */
! 			fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);
  		    --todo;
  		}
  	    if (round == 1)
--- 8159,8165 ----
  		    l = (int)STRLEN(hi->hi_key) + 1;
  		    len += l;
  		    if (round == 2)			/* <word> */
! 			fwv &= fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);
  		    --todo;
  		}
  	    if (round == 1)
***************
*** 8176,8182 ****
  	putc(0, fd);					/* <sectionflags> */
  	l = spin->si_map.ga_len;
  	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
! 	fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);
  							/* <mapstr> */
      }
  
--- 8175,8181 ----
  	putc(0, fd);					/* <sectionflags> */
  	l = spin->si_map.ga_len;
  	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
! 	fwv &= fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);
  							/* <mapstr> */
      }
  
***************
*** 8232,8241 ****
  	{
  	    p = ((char_u **)(spin->si_comppat.ga_data))[i];
  	    putc((int)STRLEN(p), fd);			/* <comppatlen> */
! 	    fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);/* <comppattext> */
  	}
  							/* <compflags> */
! 	fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),
  							       (size_t)1, fd);
      }
  
--- 8231,8241 ----
  	{
  	    p = ((char_u **)(spin->si_comppat.ga_data))[i];
  	    putc((int)STRLEN(p), fd);			/* <comppatlen> */
! 	    fwv &= fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);
! 							/* <comppattext> */
  	}
  							/* <compflags> */
! 	fwv &= fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),
  							       (size_t)1, fd);
      }
  
***************
*** 8259,8265 ****
  
  	l = (int)STRLEN(spin->si_syllable);
  	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
! 	fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd); /* <syllable> */
      }
  
      /* end of <SECTIONS> */
--- 8259,8266 ----
  
  	l = (int)STRLEN(spin->si_syllable);
  	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
! 	fwv &= fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd);
! 							/* <syllable> */
      }
  
      /* end of <SECTIONS> */
***************
*** 8295,8307 ****
  	(void)put_node(fd, tree, 0, regionmask, round == 3);
      }
  
!     /* Write another byte to check for errors. */
      if (putc(0, fd) == EOF)
  	retval = FAIL;
  
      if (fclose(fd) == EOF)
  	retval = FAIL;
  
      return retval;
  }
  
--- 8296,8313 ----
  	(void)put_node(fd, tree, 0, regionmask, round == 3);
      }
  
!     /* Write another byte to check for errors (file system full). */
      if (putc(0, fd) == EOF)
  	retval = FAIL;
  
      if (fclose(fd) == EOF)
  	retval = FAIL;
  
+     if (fwv != 1)
+ 	retval = FAIL;
+     if (retval == FAIL)
+ 	EMSG(_(e_write));
+ 
      return retval;
  }
  
***************
*** 9890,9895 ****
--- 9896,9902 ----
      char_u	*p;
      int		len;
      int		totlen;
+     int		x = 1;  /* collect return value of fwrite() */
  
      if (fd != NULL)
  	put_bytes(fd, (long_u)gap->ga_len, 2);	    /* <prefcondcnt> */
***************
*** 9906,9912 ****
  	    if (fd != NULL)
  	    {
  		fputc(len, fd);
! 		fwrite(p, (size_t)len, (size_t)1, fd);
  	    }
  	    totlen += len;
  	}
--- 9913,9919 ----
  	    if (fd != NULL)
  	    {
  		fputc(len, fd);
! 		x &= fwrite(p, (size_t)len, (size_t)1, fd);
  	    }
  	    totlen += len;
  	}
*** ../vim-7.2.049/src/version.c	Thu Nov 20 17:09:09 2008
--- src/version.c	Fri Nov 28 10:06:13 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     50,
  /**/

-- 
You got to work at a mill?  Lucky!  I got sent back to work in the
acid-mines for my daily crust of stale bread... which not even the
birds would eat.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.051
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.051
Problem:    Can't avoid 'wildignore' and 'suffixes' for glob() and globpath().
Solution:   Add an extra argument to these functions. (Ingo Karkat)
Files:	    src/eval.c, src/ex_getln.c, src/proto/ex_getln.pro,
	    runtime/doc/eval.txt, runtime/doc/options.txt


*** ../vim-7.2.050/src/eval.c	Thu Nov 20 16:11:03 2008
--- src/eval.c	Thu Nov 27 22:15:40 2008
***************
*** 7564,7571 ****
      {"getwinposx",	0, 0, f_getwinposx},
      {"getwinposy",	0, 0, f_getwinposy},
      {"getwinvar",	2, 2, f_getwinvar},
!     {"glob",		1, 1, f_glob},
!     {"globpath",	2, 2, f_globpath},
      {"has",		1, 1, f_has},
      {"has_key",		2, 2, f_has_key},
      {"haslocaldir",	0, 0, f_haslocaldir},
--- 7564,7571 ----
      {"getwinposx",	0, 0, f_getwinposx},
      {"getwinposy",	0, 0, f_getwinposy},
      {"getwinvar",	2, 2, f_getwinvar},
!     {"glob",		1, 2, f_glob},
!     {"globpath",	2, 3, f_globpath},
      {"has",		1, 1, f_has},
      {"has_key",		2, 2, f_has_key},
      {"haslocaldir",	0, 0, f_haslocaldir},
***************
*** 9557,9563 ****
      else
      {
  	/* When the optional second argument is non-zero, don't remove matches
! 	 * for 'suffixes' and 'wildignore' */
  	if (argvars[1].v_type != VAR_UNKNOWN
  				    && get_tv_number_chk(&argvars[1], &error))
  	    flags |= WILD_KEEP_ALL;
--- 9557,9563 ----
      else
      {
  	/* When the optional second argument is non-zero, don't remove matches
! 	 * for 'wildignore' and don't put matches for 'suffixes' at the end. */
  	if (argvars[1].v_type != VAR_UNKNOWN
  				    && get_tv_number_chk(&argvars[1], &error))
  	    flags |= WILD_KEEP_ALL;
***************
*** 11323,11335 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
      expand_T	xpc;
  
!     ExpandInit(&xpc);
!     xpc.xp_context = EXPAND_FILES;
!     rettv->v_type = VAR_STRING;
!     rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
! 				     NULL, WILD_USE_NL|WILD_SILENT, WILD_ALL);
  }
  
  /*
--- 11323,11347 ----
      typval_T	*argvars;
      typval_T	*rettv;
  {
+     int		flags = WILD_SILENT|WILD_USE_NL;
      expand_T	xpc;
+     int		error = FALSE;
  
!     /* When the optional second argument is non-zero, don't remove matches
!     * for 'wildignore' and don't put matches for 'suffixes' at the end. */
!     if (argvars[1].v_type != VAR_UNKNOWN
! 				&& get_tv_number_chk(&argvars[1], &error))
! 	flags |= WILD_KEEP_ALL;
!     rettv->v_type = VAR_STRING;
!     if (!error)
!     {
! 	ExpandInit(&xpc);
! 	xpc.xp_context = EXPAND_FILES;
! 	rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
! 						       NULL, flags, WILD_ALL);
!     }
!     else
! 	rettv->vval.v_string = NULL;
  }
  
  /*
***************
*** 11340,11353 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
      char_u	buf1[NUMBUFLEN];
      char_u	*file = get_tv_string_buf_chk(&argvars[1], buf1);
  
      rettv->v_type = VAR_STRING;
!     if (file == NULL)
  	rettv->vval.v_string = NULL;
      else
! 	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file);
  }
  
  /*
--- 11352,11373 ----
      typval_T	*argvars;
      typval_T	*rettv;
  {
+     int		flags = 0;
      char_u	buf1[NUMBUFLEN];
      char_u	*file = get_tv_string_buf_chk(&argvars[1], buf1);
+     int		error = FALSE;
  
+     /* When the optional second argument is non-zero, don't remove matches
+     * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+     if (argvars[2].v_type != VAR_UNKNOWN
+ 				&& get_tv_number_chk(&argvars[2], &error))
+ 	flags |= WILD_KEEP_ALL;
      rettv->v_type = VAR_STRING;
!     if (file == NULL || error)
  	rettv->vval.v_string = NULL;
      else
! 	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file,
! 								       flags);
  }
  
  /*
*** ../vim-7.2.050/src/ex_getln.c	Sat Nov 15 14:10:23 2008
--- src/ex_getln.c	Thu Nov 20 18:37:20 2008
***************
*** 2524,2530 ****
  	    && ccline.xpc->xp_context != EXPAND_NOTHING
  	    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)
      {
! 	int i = ccline.xpc->xp_pattern - p;
  
  	/* If xp_pattern points inside the old cmdbuff it needs to be adjusted
  	 * to point into the newly allocated memory. */
--- 2524,2530 ----
  	    && ccline.xpc->xp_context != EXPAND_NOTHING
  	    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)
      {
! 	int i = (int)(ccline.xpc->xp_pattern - p);
  
  	/* If xp_pattern points inside the old cmdbuff it needs to be adjusted
  	 * to point into the newly allocated memory. */
***************
*** 4897,4903 ****
      if (s == NULL)
  	return FAIL;
      sprintf((char *)s, "%s/%s*.vim", dirname, pat);
!     all = globpath(p_rtp, s);
      vim_free(s);
      if (all == NULL)
  	return FAIL;
--- 4897,4903 ----
      if (s == NULL)
  	return FAIL;
      sprintf((char *)s, "%s/%s*.vim", dirname, pat);
!     all = globpath(p_rtp, s, 0);
      vim_free(s);
      if (all == NULL)
  	return FAIL;
***************
*** 4938,4946 ****
   * newlines.  Returns NULL for an error or no matches.
   */
      char_u *
! globpath(path, file)
      char_u	*path;
      char_u	*file;
  {
      expand_T	xpc;
      char_u	*buf;
--- 4938,4947 ----
   * newlines.  Returns NULL for an error or no matches.
   */
      char_u *
! globpath(path, file, expand_options)
      char_u	*path;
      char_u	*file;
+     int		expand_options;
  {
      expand_T	xpc;
      char_u	*buf;
***************
*** 4969,4978 ****
  	{
  	    add_pathsep(buf);
  	    STRCAT(buf, file);
! 	    if (ExpandFromContext(&xpc, buf, &num_p, &p, WILD_SILENT) != FAIL
! 								 && num_p > 0)
  	    {
! 		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT);
  		for (len = 0, i = 0; i < num_p; ++i)
  		    len += (int)STRLEN(p[i]) + 1;
  
--- 4970,4979 ----
  	{
  	    add_pathsep(buf);
  	    STRCAT(buf, file);
! 	    if (ExpandFromContext(&xpc, buf, &num_p, &p,
! 			     WILD_SILENT|expand_options) != FAIL && num_p > 0)
  	    {
! 		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT|expand_options);
  		for (len = 0, i = 0; i < num_p; ++i)
  		    len += (int)STRLEN(p[i]) + 1;
  
*** ../vim-7.2.050/src/proto/ex_getln.pro	Wed May 28 16:49:01 2008
--- src/proto/ex_getln.pro	Thu Nov 20 18:27:57 2008
***************
*** 31,37 ****
  void set_cmd_context __ARGS((expand_T *xp, char_u *str, int len, int col));
  int expand_cmdline __ARGS((expand_T *xp, char_u *str, int col, int *matchcount, char_u ***matches));
  int ExpandGeneric __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file, char_u *((*func)(expand_T *, int))));
! char_u *globpath __ARGS((char_u *path, char_u *file));
  void init_history __ARGS((void));
  int get_histtype __ARGS((char_u *name));
  void add_to_history __ARGS((int histype, char_u *new_entry, int in_map, int sep));
--- 31,37 ----
  void set_cmd_context __ARGS((expand_T *xp, char_u *str, int len, int col));
  int expand_cmdline __ARGS((expand_T *xp, char_u *str, int col, int *matchcount, char_u ***matches));
  int ExpandGeneric __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file, char_u *((*func)(expand_T *, int))));
! char_u *globpath __ARGS((char_u *path, char_u *file, int expand_options));
  void init_history __ARGS((void));
  int get_histtype __ARGS((char_u *name));
  void add_to_history __ARGS((int histype, char_u *new_entry, int in_map, int sep));
*** ../vim-7.2.050/runtime/doc/eval.txt	Sun Nov  9 13:43:25 2008
--- runtime/doc/eval.txt	Thu Nov 27 22:17:13 2008
***************
*** 1,4 ****
! *eval.txt*	For Vim version 7.2.  Last change: 2008 Nov 02
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *eval.txt*	For Vim version 7.2.  Last change: 2008 Nov 27
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 1706,1712 ****
  exists( {expr})			Number	TRUE if {expr} exists
  extend({expr1}, {expr2} [, {expr3}])
  				List/Dict insert items of {expr2} into {expr1}
! expand( {expr})			String	expand special keywords in {expr}
  feedkeys( {string} [, {mode}])	Number	add key sequence to typeahead buffer
  filereadable( {file})		Number	TRUE if {file} is a readable file
  filewritable( {file})		Number	TRUE if {file} is a writable file
--- 1709,1715 ----
  exists( {expr})			Number	TRUE if {expr} exists
  extend({expr1}, {expr2} [, {expr3}])
  				List/Dict insert items of {expr2} into {expr1}
! expand( {expr} [, {flag}])	String	expand special keywords in {expr}
  feedkeys( {string} [, {mode}])	Number	add key sequence to typeahead buffer
  filereadable( {file})		Number	TRUE if {file} is a readable file
  filewritable( {file})		Number	TRUE if {file} is a writable file
***************
*** 1758,1765 ****
  getwinposx()			Number	X coord in pixels of GUI Vim window
  getwinposy()			Number	Y coord in pixels of GUI Vim window
  getwinvar( {nr}, {varname})	any	variable {varname} in window {nr}
! glob( {expr})			String	expand file wildcards in {expr}
! globpath( {path}, {expr})	String	do glob({expr}) for all dirs in {path}
  has( {feature})			Number	TRUE if feature {feature} supported
  has_key( {dict}, {key})		Number	TRUE if {dict} has entry {key}
  haslocaldir()			Number	TRUE if current window executed |:lcd|
--- 1761,1769 ----
  getwinposx()			Number	X coord in pixels of GUI Vim window
  getwinposy()			Number	Y coord in pixels of GUI Vim window
  getwinvar( {nr}, {varname})	any	variable {varname} in window {nr}
! glob( {expr} [, {flag}])	String	expand file wildcards in {expr}
! globpath( {path}, {expr} [, {flag}])
! 				String	do glob({expr}) for all dirs in {path}
  has( {feature})			Number	TRUE if feature {feature} supported
  has_key( {dict}, {key})		Number	TRUE if {dict} has entry {key}
  haslocaldir()			Number	TRUE if current window executed |:lcd|
***************
*** 3286,3299 ****
  			:let list_is_on = getwinvar(2, '&list')
  			:echo "myvar = " . getwinvar(1, 'myvar')
  <
! 							*glob()*
! glob({expr})	Expand the file wildcards in {expr}.  See |wildcards| for the
  		use of special characters.
  		The result is a String.
  		When there are several matches, they are separated by <NL>
  		characters.
! 		The 'wildignore' option applies: Names matching one of the
! 		patterns in 'wildignore' will be skipped.
  		If the expansion fails, the result is an empty string.
  		A name for a non-existing file is not included.
  
--- 3290,3305 ----
  			:let list_is_on = getwinvar(2, '&list')
  			:echo "myvar = " . getwinvar(1, 'myvar')
  <
! glob({expr} [, {flag}])					*glob()*
! 		Expand the file wildcards in {expr}.  See |wildcards| for the
  		use of special characters.
  		The result is a String.
  		When there are several matches, they are separated by <NL>
  		characters.
! 		Unless the optional {flag} argument is given and is non-zero,
! 		the 'suffixes' and 'wildignore' options apply: Names matching
! 		one of the patterns in 'wildignore' will be skipped and
! 		'suffixes' affect the ordering of matches.
  		If the expansion fails, the result is an empty string.
  		A name for a non-existing file is not included.
  
***************
*** 3307,3326 ****
  		See |expand()| for expanding special Vim variables.  See
  		|system()| for getting the raw output of an external command.
  
! globpath({path}, {expr})				*globpath()*
  		Perform glob() on all directories in {path} and concatenate
  		the results.  Example: >
  			:echo globpath(&rtp, "syntax/c.vim")
  <		{path} is a comma-separated list of directory names.  Each
  		directory name is prepended to {expr} and expanded like with
! 		glob().  A path separator is inserted when needed.
  		To add a comma inside a directory name escape it with a
  		backslash.  Note that on MS-Windows a directory may have a
  		trailing backslash, remove it if you put a comma after it.
  		If the expansion fails for one of the directories, there is no
  		error message.
! 		The 'wildignore' option applies: Names matching one of the
! 		patterns in 'wildignore' will be skipped.
  
  		The "**" item can be used to search in a directory tree.
  		For example, to find all "README.txt" files in the directories
--- 3313,3334 ----
  		See |expand()| for expanding special Vim variables.  See
  		|system()| for getting the raw output of an external command.
  
! globpath({path}, {expr} [, {flag}])			*globpath()*
  		Perform glob() on all directories in {path} and concatenate
  		the results.  Example: >
  			:echo globpath(&rtp, "syntax/c.vim")
  <		{path} is a comma-separated list of directory names.  Each
  		directory name is prepended to {expr} and expanded like with
! 		|glob()|.  A path separator is inserted when needed.
  		To add a comma inside a directory name escape it with a
  		backslash.  Note that on MS-Windows a directory may have a
  		trailing backslash, remove it if you put a comma after it.
  		If the expansion fails for one of the directories, there is no
  		error message.
! 		Unless the optional {flag} argument is given and is non-zero,
! 		the 'suffixes' and 'wildignore' options apply: Names matching
! 		one of the patterns in 'wildignore' will be skipped and
! 		'suffixes' affect the ordering of matches.
  
  		The "**" item can be used to search in a directory tree.
  		For example, to find all "README.txt" files in the directories
*** ../vim-7.2.050/runtime/doc/options.txt	Sat Aug  9 19:36:49 2008
--- runtime/doc/options.txt	Tue Nov 25 23:43:55 2008
***************
*** 1,4 ****
! *options.txt*	For Vim version 7.2.  Last change: 2008 Aug 06
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *options.txt*	For Vim version 7.2.  Last change: 2008 Nov 25
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 7472,7478 ****
  			{not available when compiled without the |+wildignore|
  			feature}
  	A list of file patterns.  A file that matches with one of these
! 	patterns is ignored when completing file or directory names.
  	The pattern is used like with |:autocmd|, see |autocmd-patterns|.
  	Also see 'suffixes'.
  	Example: >
--- 7481,7489 ----
  			{not available when compiled without the |+wildignore|
  			feature}
  	A list of file patterns.  A file that matches with one of these
! 	patterns is ignored when completing file or directory names, and
! 	influences the result of |expand()|, |glob()| and |globpath()| unless
! 	a flag is passed to disable this.
  	The pattern is used like with |:autocmd|, see |autocmd-patterns|.
  	Also see 'suffixes'.
  	Example: >
*** ../vim-7.2.050/src/version.c	Fri Nov 28 10:08:05 2008
--- src/version.c	Fri Nov 28 10:55:44 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     51,
  /**/

-- 
Not too long ago, unzipping in public was illegal...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.052
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.052
Problem:    synIDattr() doesn't support "sp" for special color.
Solution:   Recognize "sp" and "sp#".  (Matt Wozniski)
Files:	    runtime/doc/eval.txt, src/eval.c


*** ../vim-7.2.051/runtime/doc/eval.txt	Fri Nov 28 10:59:57 2008
--- runtime/doc/eval.txt	Thu Nov 27 22:17:13 2008
***************
*** 5348,5357 ****
  		"fg"		foreground color (GUI: color name used to set
  				the color, cterm: color number as a string,
  				term: empty string)
! 		"bg"		background color (like "fg")
  		"fg#"		like "fg", but for the GUI and the GUI is
  				running the name in "#RRGGBB" form
  		"bg#"		like "fg#" for "bg"
  		"bold"		"1" if bold
  		"italic"	"1" if italic
  		"reverse"	"1" if reverse
--- 5359,5370 ----
  		"fg"		foreground color (GUI: color name used to set
  				the color, cterm: color number as a string,
  				term: empty string)
! 		"bg"		background color (as with "fg")
! 		"sp"		special color (as with "fg") |highlight-guisp|
  		"fg#"		like "fg", but for the GUI and the GUI is
  				running the name in "#RRGGBB" form
  		"bg#"		like "fg#" for "bg"
+ 		"sp#"		like "fg#" for "sp"
  		"bold"		"1" if bold
  		"italic"	"1" if italic
  		"reverse"	"1" if reverse
*** ../vim-7.2.051/src/eval.c	Fri Nov 28 10:59:57 2008
--- src/eval.c	Thu Nov 27 22:15:40 2008
***************
*** 16648,16655 ****
  		p = highlight_has_attr(id, HL_INVERSE, modec);
  		break;
  
! 	case 's':					/* standout */
! 		p = highlight_has_attr(id, HL_STANDOUT, modec);
  		break;
  
  	case 'u':
--- 16648,16658 ----
  		p = highlight_has_attr(id, HL_INVERSE, modec);
  		break;
  
! 	case 's':
! 		if (TOLOWER_ASC(what[1]) == 'p')	/* sp[#] */
! 		    p = highlight_color(id, what, modec);
! 		else					/* standout */
! 		    p = highlight_has_attr(id, HL_STANDOUT, modec);
  		break;
  
  	case 'u':
*** ../vim-7.2.051/src/version.c	Fri Nov 28 10:59:57 2008
--- src/version.c	Fri Nov 28 11:13:45 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     52,
  /**/

-- 
Not too long ago, a keyboard was something to make music with...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.053
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.053
Problem:    Crash when using WorkShop command ":ws foo". (Dominique Pelle)
Solution:   Avoid using a NULL pointer.
Files:	    src/workshop.c


*** ../vim-7.2.052/src/workshop.c	Tue Jun 24 23:34:50 2008
--- src/workshop.c	Thu Nov 27 22:31:27 2008
***************
*** 1121,1128 ****
  				      ? (char *)curbuf->b_sfname : "<None>");
  #endif
  
!     strcpy(ffname, (char *) curbuf->b_ffname);
!     *filename = ffname;		/* copy so nobody can change b_ffname */
      *curLine = curwin->w_cursor.lnum;
      *curCol = curwin->w_cursor.col;
  
--- 1121,1132 ----
  				      ? (char *)curbuf->b_sfname : "<None>");
  #endif
  
!     if (curbuf->b_ffname == NULL)
! 	ffname[0] = NUL;
!     else
! 	/* copy so nobody can change b_ffname */
! 	strcpy(ffname, (char *) curbuf->b_ffname);
!     *filename = ffname;
      *curLine = curwin->w_cursor.lnum;
      *curCol = curwin->w_cursor.col;
  
*** ../vim-7.2.052/src/version.c	Fri Nov 28 11:15:10 2008
--- src/version.c	Fri Nov 28 11:44:23 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     53,
  /**/

-- 
What the word 'politics' means: 'Poli' in Latin meaning 'many' and 'tics'
meaning 'bloodsucking creatures'.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.054
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.054
Problem:    Compilation warnings for format in getchar.c.
Solution:   Use fputs() instead of fprintf().  (Dominique Pelle)
Files:	    src/getchar.c


*** ../vim-7.2.053/src/getchar.c	Tue Jul 22 18:58:23 2008
--- src/getchar.c	Thu Nov 27 22:38:24 2008
***************
*** 4702,4708 ****
  			return FAIL;
  		    if (mp->m_noremap != REMAP_YES && fprintf(fd, "nore") < 0)
  			return FAIL;
! 		    if (fprintf(fd, cmd) < 0)
  			return FAIL;
  		    if (buf != NULL && fputs(" <buffer>", fd) < 0)
  			return FAIL;
--- 4702,4708 ----
  			return FAIL;
  		    if (mp->m_noremap != REMAP_YES && fprintf(fd, "nore") < 0)
  			return FAIL;
! 		    if (fputs(cmd, fd) < 0)
  			return FAIL;
  		    if (buf != NULL && fputs(" <buffer>", fd) < 0)
  			return FAIL;
***************
*** 4801,4807 ****
  	    }
  	    if (IS_SPECIAL(c) || modifiers)	/* special key */
  	    {
! 		if (fprintf(fd, (char *)get_special_key_name(c, modifiers)) < 0)
  		    return FAIL;
  		continue;
  	    }
--- 4801,4807 ----
  	    }
  	    if (IS_SPECIAL(c) || modifiers)	/* special key */
  	    {
! 		if (fputs((char *)get_special_key_name(c, modifiers), fd) < 0)
  		    return FAIL;
  		continue;
  	    }
*** ../vim-7.2.053/src/version.c	Fri Nov 28 11:47:14 2008
--- src/version.c	Fri Nov 28 12:02:48 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     54,
  /**/

-- 
Not too long ago, compress was something you did to garbage...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.055
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.055
Problem:    Various compiler warnings with strict checking.
Solution:   Avoid the warnings by using return values and renaming.
Files:	    src/diff.c, src/eval.c, src/ex_cmds.c, src/ex_docmd.c,
	    src/fileio.c, src/fold.c, src/globals.h, src/gui.c,
	    src/gui_at_sb.c, src/gui_gtk_x11.c, src/gui_xmdlg.c,
	    src/gui_xmebw.c, src/main.c, src/mbyte.c, src/message.c,
	    src/netbeans.c, src/option.c, src/os_unix.c, src/spell.c,
	    src/ui.c, src/window.c


*** ../vim-7.2.054/src/diff.c	Fri Jan 18 17:39:32 2008
--- src/diff.c	Fri Nov 28 17:23:35 2008
***************
*** 661,666 ****
--- 665,671 ----
      char_u	*tmp_diff;
      FILE	*fd;
      int		ok;
+     int		io_error = FALSE;
  
      /* Delete all diffblocks. */
      diff_clear(curtab);
***************
*** 697,714 ****
      {
  	ok = FALSE;
  	fd = mch_fopen((char *)tmp_orig, "w");
! 	if (fd != NULL)
  	{
! 	    fwrite("line1\n", (size_t)6, (size_t)1, fd);
  	    fclose(fd);
  	    fd = mch_fopen((char *)tmp_new, "w");
! 	    if (fd != NULL)
  	    {
! 		fwrite("line2\n", (size_t)6, (size_t)1, fd);
  		fclose(fd);
  		diff_file(tmp_orig, tmp_new, tmp_diff);
  		fd = mch_fopen((char *)tmp_diff, "r");
! 		if (fd != NULL)
  		{
  		    char_u	linebuf[LBUFLEN];
  
--- 702,727 ----
      {
  	ok = FALSE;
  	fd = mch_fopen((char *)tmp_orig, "w");
! 	if (fd == NULL)
! 	    io_error = TRUE;
! 	else
  	{
! 	    if (fwrite("line1\n", (size_t)6, (size_t)1, fd) != 1)
! 		io_error = TRUE;
  	    fclose(fd);
  	    fd = mch_fopen((char *)tmp_new, "w");
! 	    if (fd == NULL)
! 		io_error = TRUE;
! 	    else
  	    {
! 		if (fwrite("line2\n", (size_t)6, (size_t)1, fd) != 1)
! 		    io_error = TRUE;
  		fclose(fd);
  		diff_file(tmp_orig, tmp_new, tmp_diff);
  		fd = mch_fopen((char *)tmp_diff, "r");
! 		if (fd == NULL)
! 		    io_error = TRUE;
! 		else
  		{
  		    char_u	linebuf[LBUFLEN];
  
***************
*** 761,766 ****
--- 774,781 ----
      }
      if (!ok)
      {
+ 	if (io_error)
+ 	    EMSG(_("E810: Cannot read or write temp files"));
  	EMSG(_("E97: Cannot create diffs"));
  	diff_a_works = MAYBE;
  #if defined(MSWIN) || defined(MSDOS)
***************
*** 925,934 ****
      {
  # ifdef TEMPDIRNAMES
  	if (vim_tempdir != NULL)
! 	    mch_chdir((char *)vim_tempdir);
  	else
  # endif
! 	    mch_chdir("/tmp");
  	shorten_fnames(TRUE);
      }
  #endif
--- 940,949 ----
      {
  # ifdef TEMPDIRNAMES
  	if (vim_tempdir != NULL)
! 	    ignored = mch_chdir((char *)vim_tempdir);
  	else
  # endif
! 	    ignored = mch_chdir("/tmp");
  	shorten_fnames(TRUE);
      }
  #endif
*** ../vim-7.2.054/src/eval.c	Fri Nov 28 11:15:10 2008
--- src/eval.c	Fri Nov 28 12:23:13 2008
***************
*** 10641,10647 ****
  # ifdef FEAT_WINDOWS
  	    win_T	*wp;
  # endif
! 	    int		n = 1;
  
  	    if (row >= 0 && col >= 0)
  	    {
--- 10641,10647 ----
  # ifdef FEAT_WINDOWS
  	    win_T	*wp;
  # endif
! 	    int		winnr = 1;
  
  	    if (row >= 0 && col >= 0)
  	    {
***************
*** 10651,10659 ****
  		(void)mouse_comp_pos(win, &row, &col, &lnum);
  # ifdef FEAT_WINDOWS
  		for (wp = firstwin; wp != win; wp = wp->w_next)
! 		    ++n;
  # endif
! 		vimvars[VV_MOUSE_WIN].vv_nr = n;
  		vimvars[VV_MOUSE_LNUM].vv_nr = lnum;
  		vimvars[VV_MOUSE_COL].vv_nr = col + 1;
  	    }
--- 10651,10659 ----
  		(void)mouse_comp_pos(win, &row, &col, &lnum);
  # ifdef FEAT_WINDOWS
  		for (wp = firstwin; wp != win; wp = wp->w_next)
! 		    ++winnr;
  # endif
! 		vimvars[VV_MOUSE_WIN].vv_nr = winnr;
  		vimvars[VV_MOUSE_LNUM].vv_nr = lnum;
  		vimvars[VV_MOUSE_COL].vv_nr = col + 1;
  	    }
*** ../vim-7.2.054/src/ex_cmds.c	Sat Nov 15 14:10:23 2008
--- src/ex_cmds.c	Fri Nov 28 17:24:08 2008
***************
*** 1941,1947 ****
  	     * root.
  	     */
  	    if (fp_out != NULL)
! 		(void)fchown(fileno(fp_out), st_old.st_uid, st_old.st_gid);
  #endif
  	}
      }
--- 1941,1947 ----
  	     * root.
  	     */
  	    if (fp_out != NULL)
! 		ignored = fchown(fileno(fp_out), st_old.st_uid, st_old.st_gid);
  #endif
  	}
      }
*** ../vim-7.2.054/src/ex_docmd.c	Sat Nov 15 14:10:23 2008
--- src/ex_docmd.c	Fri Nov 28 17:26:13 2008
***************
*** 8753,8760 ****
  		else if (*dirnow != NUL
  			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
  		{
! 		    (void)mch_chdir((char *)globaldir);
! 		    shorten_fnames(TRUE);
  		}
  
  		failed |= (makeopens(fd, dirnow) == FAIL);
--- 8753,8760 ----
  		else if (*dirnow != NUL
  			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
  		{
! 		    if (mch_chdir((char *)globaldir) == OK)
! 			shorten_fnames(TRUE);
  		}
  
  		failed |= (makeopens(fd, dirnow) == FAIL);
*** ../vim-7.2.054/src/fileio.c	Wed Nov 12 16:04:43 2008
--- src/fileio.c	Fri Nov 28 17:35:54 2008
***************
*** 2214,2220 ****
      {
  	/* Use stderr for stdin, makes shell commands work. */
  	close(0);
! 	dup(2);
      }
  #endif
  
--- 2214,2220 ----
      {
  	/* Use stderr for stdin, makes shell commands work. */
  	close(0);
! 	ignored = dup(2);
      }
  #endif
  
***************
*** 3449,3455 ****
  		{
  # ifdef UNIX
  #  ifdef HAVE_FCHOWN
! 		    fchown(fd, st_old.st_uid, st_old.st_gid);
  #  endif
  		    if (mch_stat((char *)IObuff, &st) < 0
  			    || st.st_uid != st_old.st_uid
--- 3449,3455 ----
  		{
  # ifdef UNIX
  #  ifdef HAVE_FCHOWN
! 		    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);
  #  endif
  		    if (mch_stat((char *)IObuff, &st) < 0
  			    || st.st_uid != st_old.st_uid
***************
*** 4365,4371 ****
  		|| st.st_uid != st_old.st_uid
  		|| st.st_gid != st_old.st_gid)
  	{
! 	    fchown(fd, st_old.st_uid, st_old.st_gid);
  	    if (perm >= 0)	/* set permission again, may have changed */
  		(void)mch_setperm(wfname, perm);
  	}
--- 4365,4371 ----
  		|| st.st_uid != st_old.st_uid
  		|| st.st_gid != st_old.st_gid)
  	{
! 	    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);
  	    if (perm >= 0)	/* set permission again, may have changed */
  		(void)mch_setperm(wfname, perm);
  	}
***************
*** 6030,6038 ****
  	{
  	    tbuf[FGETS_SIZE - 2] = NUL;
  #ifdef USE_CR
! 	    fgets_cr((char *)tbuf, FGETS_SIZE, fp);
  #else
! 	    fgets((char *)tbuf, FGETS_SIZE, fp);
  #endif
  	} while (tbuf[FGETS_SIZE - 2] != NUL && tbuf[FGETS_SIZE - 2] != '\n');
      }
--- 6030,6038 ----
  	{
  	    tbuf[FGETS_SIZE - 2] = NUL;
  #ifdef USE_CR
! 	    ignoredp = fgets_cr((char *)tbuf, FGETS_SIZE, fp);
  #else
! 	    ignoredp = fgets((char *)tbuf, FGETS_SIZE, fp);
  #endif
  	} while (tbuf[FGETS_SIZE - 2] != NUL && tbuf[FGETS_SIZE - 2] != '\n');
      }
*** ../vim-7.2.054/src/fold.c	Wed Aug  6 18:59:40 2008
--- src/fold.c	Fri Nov 28 12:24:16 2008
***************
*** 48,54 ****
  static int foldFind __ARGS((garray_T *gap, linenr_T lnum, fold_T **fpp));
  static int foldLevelWin __ARGS((win_T *wp, linenr_T lnum));
  static void checkupdate __ARGS((win_T *wp));
! static void setFoldRepeat __ARGS((linenr_T lnum, long count, int open));
  static linenr_T setManualFold __ARGS((linenr_T lnum, int opening, int recurse, int *donep));
  static linenr_T setManualFoldWin __ARGS((win_T *wp, linenr_T lnum, int opening, int recurse, int *donep));
  static void foldOpenNested __ARGS((fold_T *fpr));
--- 48,54 ----
  static int foldFind __ARGS((garray_T *gap, linenr_T lnum, fold_T **fpp));
  static int foldLevelWin __ARGS((win_T *wp, linenr_T lnum));
  static void checkupdate __ARGS((win_T *wp));
! static void setFoldRepeat __ARGS((linenr_T lnum, long count, int do_open));
  static linenr_T setManualFold __ARGS((linenr_T lnum, int opening, int recurse, int *donep));
  static linenr_T setManualFoldWin __ARGS((win_T *wp, linenr_T lnum, int opening, int recurse, int *donep));
  static void foldOpenNested __ARGS((fold_T *fpr));
***************
*** 1241,1250 ****
   * Repeat "count" times.
   */
      static void
! setFoldRepeat(lnum, count, open)
      linenr_T	lnum;
      long	count;
!     int		open;
  {
      int		done;
      long	n;
--- 1241,1250 ----
   * Repeat "count" times.
   */
      static void
! setFoldRepeat(lnum, count, do_open)
      linenr_T	lnum;
      long	count;
!     int		do_open;
  {
      int		done;
      long	n;
***************
*** 1252,1258 ****
      for (n = 0; n < count; ++n)
      {
  	done = DONE_NOTHING;
! 	(void)setManualFold(lnum, open, FALSE, &done);
  	if (!(done & DONE_ACTION))
  	{
  	    /* Only give an error message when no fold could be opened. */
--- 1252,1258 ----
      for (n = 0; n < count; ++n)
      {
  	done = DONE_NOTHING;
! 	(void)setManualFold(lnum, do_open, FALSE, &done);
  	if (!(done & DONE_ACTION))
  	{
  	    /* Only give an error message when no fold could be opened. */
*** ../vim-7.2.054/src/globals.h	Thu Sep 18 21:29:07 2008
--- src/globals.h	Fri Nov 28 17:35:50 2008
***************
*** 1549,1554 ****
--- 1549,1562 ----
  EXTERN time_t starttime;
  
  /*
+  * Some compilers warn for not using a return value, but in some situations we
+  * can't do anything useful with the value.  Assign to this variable to avoid
+  * the warning.
+  */
+ EXTERN int ignored;
+ EXTERN char *ignoredp;
+ 
+ /*
   * Optional Farsi support.  Include it here, so EXTERN and INIT are defined.
   */
  #ifdef FEAT_FKMAP
*** ../vim-7.2.054/src/gui.c	Wed Aug  6 14:37:26 2008
--- src/gui.c	Fri Nov 28 18:48:31 2008
***************
*** 139,145 ****
  		/* The read returns when the child closes the pipe (or when
  		 * the child dies for some reason). */
  		close(pipefd[1]);
! 		(void)read(pipefd[0], &dummy, (size_t)1);
  		close(pipefd[0]);
  	    }
  
--- 139,145 ----
  		/* The read returns when the child closes the pipe (or when
  		 * the child dies for some reason). */
  		close(pipefd[1]);
! 		ignored = (int)read(pipefd[0], &dummy, (size_t)1);
  		close(pipefd[0]);
  	    }
  
*** ../vim-7.2.054/src/gui_at_sb.c	Sun Jun 13 21:37:13 2004
--- src/gui_at_sb.c	Fri Nov 28 12:19:19 2008
***************
*** 1078,1083 ****
--- 1078,1089 ----
      Cardinal	*num_params;	/* unused */
  {
      ScrollbarWidget sbw = (ScrollbarWidget)w;
+     /* Use a union to avoid a warning for the weird conversion from float to
+      * XtPointer.  Comes from Xaw/Scrollbar.c. */
+     union {
+ 	XtPointer xtp;
+ 	float xtf;
+     } xtpf;
  
      if (LookAhead(w, event))
  	return;
***************
*** 1085,1091 ****
      /* thumbProc is not pretty, but is necessary for backwards
         compatibility on those architectures for which it work{s,ed};
         the intent is to pass a (truncated) float by value. */
!     XtCallCallbacks(w, XtNthumbProc, *(XtPointer*)&sbw->scrollbar.top);
      XtCallCallbacks(w, XtNjumpProc, (XtPointer)&sbw->scrollbar.top);
  }
  
--- 1091,1098 ----
      /* thumbProc is not pretty, but is necessary for backwards
         compatibility on those architectures for which it work{s,ed};
         the intent is to pass a (truncated) float by value. */
!     xtpf.xtf = sbw->scrollbar.top;
!     XtCallCallbacks(w, XtNthumbProc, xtpf.xtp);
      XtCallCallbacks(w, XtNjumpProc, (XtPointer)&sbw->scrollbar.top);
  }
  
*** ../vim-7.2.054/src/gui_gtk_x11.c	Tue Jul  8 12:46:08 2008
--- src/gui_gtk_x11.c	Fri Nov 28 21:06:38 2008
***************
*** 4070,4083 ****
  
  	if (mask & (XValue | YValue))
  	{
! 	    int w, h;
! 	    gui_mch_get_screen_dimensions(&w, &h);
! 	    h += p_ghr + get_menu_tool_height();
! 	    w += get_menu_tool_width();
  	    if (mask & XNegative)
! 		x += w - pixel_width;
  	    if (mask & YNegative)
! 		y += h - pixel_height;
  #ifdef HAVE_GTK2
  	    gtk_window_move(GTK_WINDOW(gui.mainwin), x, y);
  #else
--- 4070,4083 ----
  
  	if (mask & (XValue | YValue))
  	{
! 	    int ww, hh;
! 	    gui_mch_get_screen_dimensions(&ww, &hh);
! 	    hh += p_ghr + get_menu_tool_height();
! 	    ww += get_menu_tool_width();
  	    if (mask & XNegative)
! 		x += ww - pixel_width;
  	    if (mask & YNegative)
! 		y += hh - pixel_height;
  #ifdef HAVE_GTK2
  	    gtk_window_move(GTK_WINDOW(gui.mainwin), x, y);
  #else
*** ../vim-7.2.054/src/gui_xmdlg.c	Tue Jun 24 23:39:32 2008
--- src/gui_xmdlg.c	Fri Nov 28 21:04:08 2008
***************
*** 369,378 ****
      char	buf[TEMP_BUF_SIZE];
      XmString	items[MAX_ENTRIES_IN_LIST];
      int		i;
!     int		index;
  
!     for (index = (int)ENCODING; index < (int)NONE; ++index)
! 	count[index] = 0;
  
      /* First we insert the wild char into every single list. */
      if (fix != ENCODING)
--- 369,378 ----
      char	buf[TEMP_BUF_SIZE];
      XmString	items[MAX_ENTRIES_IN_LIST];
      int		i;
!     int		idx;
  
!     for (idx = (int)ENCODING; idx < (int)NONE; ++idx)
! 	count[idx] = 0;
  
      /* First we insert the wild char into every single list. */
      if (fix != ENCODING)
***************
*** 503,516 ****
      /*
       * Now loop trough the remaining lists and set them up.
       */
!     for (index = (int)NAME; index < (int)NONE; ++index)
      {
  	Widget w;
  
! 	if (fix == (enum ListSpecifier)index)
  	    continue;
  
! 	switch ((enum ListSpecifier)index)
  	{
  	    case NAME:
  		w = data->list[NAME];
--- 503,516 ----
      /*
       * Now loop trough the remaining lists and set them up.
       */
!     for (idx = (int)NAME; idx < (int)NONE; ++idx)
      {
  	Widget w;
  
! 	if (fix == (enum ListSpecifier)idx)
  	    continue;
  
! 	switch ((enum ListSpecifier)idx)
  	{
  	    case NAME:
  		w = data->list[NAME];
***************
*** 525,545 ****
  		w = (Widget)0;	/* for lint */
  	}
  
! 	for (i = 0; i < count[index]; ++i)
  	{
! 	    items[i] = XmStringCreateLocalized(list[index][i]);
! 	    XtFree(list[index][i]);
  	}
  	XmListDeleteAllItems(w);
! 	XmListAddItems(w, items, count[index], 1);
! 	if (data->sel[index])
  	{
  	    XmStringFree(items[0]);
! 	    items[0] = XmStringCreateLocalized(data->sel[index]);
  	    XmListSelectItem(w, items[0], False);
  	    XmListSetBottomItem(w, items[0]);
  	}
! 	for (i = 0; i < count[index]; ++i)
  	    XmStringFree(items[i]);
      }
  }
--- 525,545 ----
  		w = (Widget)0;	/* for lint */
  	}
  
! 	for (i = 0; i < count[idx]; ++i)
  	{
! 	    items[i] = XmStringCreateLocalized(list[idx][i]);
! 	    XtFree(list[idx][i]);
  	}
  	XmListDeleteAllItems(w);
! 	XmListAddItems(w, items, count[idx], 1);
! 	if (data->sel[idx])
  	{
  	    XmStringFree(items[0]);
! 	    items[0] = XmStringCreateLocalized(data->sel[idx]);
  	    XmListSelectItem(w, items[0], False);
  	    XmListSetBottomItem(w, items[0]);
  	}
! 	for (i = 0; i < count[idx]; ++i)
  	    XmStringFree(items[i]);
      }
  }
***************
*** 695,708 ****
  	int	    n;
  	XmString    str;
  	Arg	    args[4];
! 	char	    *msg = _("no specific match");
  
  	n = 0;
! 	str = XmStringCreateLocalized(msg);
  	XtSetArg(args[n], XmNlabelString, str); ++n;
  	XtSetValues(data->sample, args, n);
  	apply_fontlist(data->sample);
! 	XmTextSetString(data->name, msg);
  	XmStringFree(str);
  
  	return False;
--- 695,708 ----
  	int	    n;
  	XmString    str;
  	Arg	    args[4];
! 	char	    *nomatch_msg = _("no specific match");
  
  	n = 0;
! 	str = XmStringCreateLocalized(nomatch_msg);
  	XtSetArg(args[n], XmNlabelString, str); ++n;
  	XtSetValues(data->sample, args, n);
  	apply_fontlist(data->sample);
! 	XmTextSetString(data->name, nomatch_msg);
  	XmStringFree(str);
  
  	return False;
***************
*** 886,906 ****
      {
  	int	i;
  	int	max;
! 	int	index = 0;
  	int	size;
! 	char	str[128];
  
  	for (i = 0, max = 0; i < data->num; i++)
  	{
! 	    get_part(fn(data, i), 7, str);
! 	    size = atoi(str);
  	    if ((size > max) && (size < MAX_DISPLAY_SIZE))
  	    {
! 		index = i;
  		max = size;
  	    }
  	}
! 	strcpy(big_font, fn(data, index));
      }
      data->old = XLoadQueryFont(XtDisplay(parent), big_font);
      data->old_list = gui_motif_create_fontlist(data->old);
--- 886,906 ----
      {
  	int	i;
  	int	max;
! 	int	idx = 0;
  	int	size;
! 	char	buf[128];
  
  	for (i = 0, max = 0; i < data->num; i++)
  	{
! 	    get_part(fn(data, i), 7, buf);
! 	    size = atoi(buf);
  	    if ((size > max) && (size < MAX_DISPLAY_SIZE))
  	    {
! 		idx = i;
  		max = size;
  	    }
  	}
! 	strcpy(big_font, fn(data, idx));
      }
      data->old = XLoadQueryFont(XtDisplay(parent), big_font);
      data->old_list = gui_motif_create_fontlist(data->old);
***************
*** 1217,1244 ****
  
  	if (i != 0)
  	{
! 	    char name[TEMP_BUF_SIZE];
! 	    char style[TEMP_BUF_SIZE];
! 	    char size[TEMP_BUF_SIZE];
! 	    char encoding[TEMP_BUF_SIZE];
  	    char *found;
  
  	    found = names[0];
  
! 	    name_part(found, name);
! 	    style_part(found, style);
! 	    size_part(found, size, data->in_pixels);
! 	    encoding_part(found, encoding);
! 
! 	    if (strlen(name) > 0
! 		    && strlen(style) > 0
! 		    && strlen(size) > 0
! 		    && strlen(encoding) > 0)
  	    {
! 		data->sel[NAME] = XtNewString(name);
! 		data->sel[STYLE] = XtNewString(style);
! 		data->sel[SIZE] = XtNewString(size);
! 		data->sel[ENCODING] = XtNewString(encoding);
  		data->font_name = XtNewString(names[0]);
  		display_sample(data);
  		XmTextSetString(data->name, data->font_name);
--- 1217,1244 ----
  
  	if (i != 0)
  	{
! 	    char namebuf[TEMP_BUF_SIZE];
! 	    char stylebuf[TEMP_BUF_SIZE];
! 	    char sizebuf[TEMP_BUF_SIZE];
! 	    char encodingbuf[TEMP_BUF_SIZE];
  	    char *found;
  
  	    found = names[0];
  
! 	    name_part(found, namebuf);
! 	    style_part(found, stylebuf);
! 	    size_part(found, sizebuf, data->in_pixels);
! 	    encoding_part(found, encodingbuf);
! 
! 	    if (strlen(namebuf) > 0
! 		    && strlen(stylebuf) > 0
! 		    && strlen(sizebuf) > 0
! 		    && strlen(encodingbuf) > 0)
  	    {
! 		data->sel[NAME] = XtNewString(namebuf);
! 		data->sel[STYLE] = XtNewString(stylebuf);
! 		data->sel[SIZE] = XtNewString(sizebuf);
! 		data->sel[ENCODING] = XtNewString(encodingbuf);
  		data->font_name = XtNewString(names[0]);
  		display_sample(data);
  		XmTextSetString(data->name, data->font_name);
*** ../vim-7.2.054/src/gui_xmebw.c	Thu Nov  8 20:48:14 2007
--- src/gui_xmebw.c	Fri Nov 28 18:58:53 2008
***************
*** 1256,1262 ****
      }
      else
      {
! 	int adjust = 0;
  
  #if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
  	/*
--- 1256,1262 ----
      }
      else
      {
! 	adjust = 0;
  
  #if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
  	/*
***************
*** 1268,1279 ****
  	{
  	    case XmEXTERNAL_HIGHLIGHT:
  		adjust = (eb->primitive.highlight_thickness -
! 			(eb->pushbutton.default_button_shadow_thickness ?
! 			 Xm3D_ENHANCE_PIXEL : 0));
  		break;
  
  	    case XmINTERNAL_HIGHLIGHT:
- 		adjust = 0;
  		break;
  
  	    default:
--- 1268,1278 ----
  	{
  	    case XmEXTERNAL_HIGHLIGHT:
  		adjust = (eb->primitive.highlight_thickness -
! 			 (eb->pushbutton.default_button_shadow_thickness
! 			  ?  Xm3D_ENHANCE_PIXEL : 0));
  		break;
  
  	    case XmINTERNAL_HIGHLIGHT:
  		break;
  
  	    default:
*** ../vim-7.2.054/src/main.c	Thu Nov 20 14:11:47 2008
--- src/main.c	Fri Nov 28 18:32:48 2008
***************
*** 2372,2378 ****
       * Is there any other system that cannot do this?
       */
      close(0);
!     dup(2);
  #endif
  }
  
--- 2372,2378 ----
       * Is there any other system that cannot do this?
       */
      close(0);
!     ignored = dup(2);
  #endif
  }
  
*** ../vim-7.2.054/src/mbyte.c	Thu Nov 20 17:09:09 2008
--- src/mbyte.c	Fri Nov 28 18:44:05 2008
***************
*** 717,723 ****
  		     * where mblen() returns 0 for invalid character.
  		     * Therefore, following condition includes 0.
  		     */
! 		    (void)mblen(NULL, 0);	/* First reset the state. */
  		    if (mblen(buf, (size_t)1) <= 0)
  			n = 2;
  		    else
--- 717,723 ----
  		     * where mblen() returns 0 for invalid character.
  		     * Therefore, following condition includes 0.
  		     */
! 		    ignored = mblen(NULL, 0);	/* First reset the state. */
  		    if (mblen(buf, (size_t)1) <= 0)
  			n = 2;
  		    else
***************
*** 5278,5284 ****
  
  /*ARGSUSED*/
      static void
! preedit_start_cbproc(XIC xic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("xim_decide_input_style()\n");
--- 5278,5284 ----
  
  /*ARGSUSED*/
      static void
! preedit_start_cbproc(XIC thexic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("xim_decide_input_style()\n");
***************
*** 5312,5318 ****
  
  /*ARGSUSED*/
      static void
! preedit_draw_cbproc(XIC xic, XPointer client_data, XPointer call_data)
  {
      XIMPreeditDrawCallbackStruct *draw_data;
      XIMText	*text;
--- 5312,5318 ----
  
  /*ARGSUSED*/
      static void
! preedit_draw_cbproc(XIC thexic, XPointer client_data, XPointer call_data)
  {
      XIMPreeditDrawCallbackStruct *draw_data;
      XIMText	*text;
***************
*** 5453,5459 ****
  
  /*ARGSUSED*/
      static void
! preedit_caret_cbproc(XIC xic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("preedit_caret_cbproc()\n");
--- 5453,5459 ----
  
  /*ARGSUSED*/
      static void
! preedit_caret_cbproc(XIC thexic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("preedit_caret_cbproc()\n");
***************
*** 5462,5468 ****
  
  /*ARGSUSED*/
      static void
! preedit_done_cbproc(XIC xic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("preedit_done_cbproc()\n");
--- 5462,5468 ----
  
  /*ARGSUSED*/
      static void
! preedit_done_cbproc(XIC thexic, XPointer client_data, XPointer call_data)
  {
  #ifdef XIM_DEBUG
      xim_log("preedit_done_cbproc()\n");
*** ../vim-7.2.054/src/message.c	Sun Jul 13 19:18:44 2008
--- src/message.c	Fri Nov 28 12:26:56 2008
***************
*** 4585,4645 ****
  			if (remove_trailing_zeroes)
  			{
  			    int i;
! 			    char *p;
  
  			    /* Using %g or %G: remove superfluous zeroes. */
  			    if (fmt_spec == 'f')
! 				p = tmp + str_arg_l - 1;
  			    else
  			    {
! 				p = (char *)vim_strchr((char_u *)tmp,
  						 fmt_spec == 'e' ? 'e' : 'E');
! 				if (p != NULL)
  				{
  				    /* Remove superfluous '+' and leading
  				     * zeroes from the exponent. */
! 				    if (p[1] == '+')
  				    {
  					/* Change "1.0e+07" to "1.0e07" */
! 					STRMOVE(p + 1, p + 2);
  					--str_arg_l;
  				    }
! 				    i = (p[1] == '-') ? 2 : 1;
! 				    while (p[i] == '0')
  				    {
  					/* Change "1.0e07" to "1.0e7" */
! 					STRMOVE(p + i, p + i + 1);
  					--str_arg_l;
  				    }
! 				    --p;
  				}
  			    }
  
! 			    if (p != NULL && !precision_specified)
  				/* Remove trailing zeroes, but keep the one
  				 * just after a dot. */
! 				while (p > tmp + 2 && *p == '0' && p[-1] != '.')
  				{
! 				    STRMOVE(p, p + 1);
! 				    --p;
  				    --str_arg_l;
  				}
  			}
  			else
  			{
! 			    char *p;
  
  			    /* Be consistent: some printf("%e") use 1.0e+12
  			     * and some 1.0e+012.  Remove one zero in the last
  			     * case. */
! 			    p = (char *)vim_strchr((char_u *)tmp,
  						 fmt_spec == 'e' ? 'e' : 'E');
! 			    if (p != NULL && (p[1] == '+' || p[1] == '-')
! 					  && p[2] == '0'
! 					  && vim_isdigit(p[3])
! 					  && vim_isdigit(p[4]))
  			    {
! 				STRMOVE(p + 2, p + 3);
  				--str_arg_l;
  			    }
  			}
--- 4585,4646 ----
  			if (remove_trailing_zeroes)
  			{
  			    int i;
! 			    char *tp;
  
  			    /* Using %g or %G: remove superfluous zeroes. */
  			    if (fmt_spec == 'f')
! 				tp = tmp + str_arg_l - 1;
  			    else
  			    {
! 				tp = (char *)vim_strchr((char_u *)tmp,
  						 fmt_spec == 'e' ? 'e' : 'E');
! 				if (tp != NULL)
  				{
  				    /* Remove superfluous '+' and leading
  				     * zeroes from the exponent. */
! 				    if (tp[1] == '+')
  				    {
  					/* Change "1.0e+07" to "1.0e07" */
! 					STRMOVE(tp + 1, tp + 2);
  					--str_arg_l;
  				    }
! 				    i = (tp[1] == '-') ? 2 : 1;
! 				    while (tp[i] == '0')
  				    {
  					/* Change "1.0e07" to "1.0e7" */
! 					STRMOVE(tp + i, tp + i + 1);
  					--str_arg_l;
  				    }
! 				    --tp;
  				}
  			    }
  
! 			    if (tp != NULL && !precision_specified)
  				/* Remove trailing zeroes, but keep the one
  				 * just after a dot. */
! 				while (tp > tmp + 2 && *tp == '0'
! 							     && tp[-1] != '.')
  				{
! 				    STRMOVE(tp, tp + 1);
! 				    --tp;
  				    --str_arg_l;
  				}
  			}
  			else
  			{
! 			    char *tp;
  
  			    /* Be consistent: some printf("%e") use 1.0e+12
  			     * and some 1.0e+012.  Remove one zero in the last
  			     * case. */
! 			    tp = (char *)vim_strchr((char_u *)tmp,
  						 fmt_spec == 'e' ? 'e' : 'E');
! 			    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')
! 					  && tp[2] == '0'
! 					  && vim_isdigit(tp[3])
! 					  && vim_isdigit(tp[4]))
  			    {
! 				STRMOVE(tp + 2, tp + 3);
  				--str_arg_l;
  			    }
  			}
*** ../vim-7.2.054/src/netbeans.c	Sat Nov 15 14:10:23 2008
--- src/netbeans.c	Fri Nov 28 18:51:43 2008
***************
*** 1043,1049 ****
  	nbdebug(("EVT: %s", buf));
  /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
  	if (sd >= 0)
! 	    sock_write(sd, buf, (int)STRLEN(buf));  /* ignore errors */
      }
  }
  
--- 1043,1049 ----
  	nbdebug(("EVT: %s", buf));
  /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
  	if (sd >= 0)
! 	    ignored = sock_write(sd, buf, (int)STRLEN(buf));
      }
  }
  
***************
*** 2277,2285 ****
  	    int serNum;
  	    int localTypeNum;
  	    int typeNum;
- # ifdef NBDEBUG
- 	    int len;
- # endif
  	    pos_T *pos;
  
  	    if (buf == NULL || buf->bufp == NULL)
--- 2277,2282 ----
***************
*** 2303,2315 ****
  	    pos = get_off_or_lnum(buf->bufp, &args);
  
  	    cp = (char *)args;
! # ifdef NBDEBUG
! 	    len =
! # endif
! 		strtol(cp, &cp, 10);
  	    args = (char_u *)cp;
  # ifdef NBDEBUG
! 	    if (len != -1)
  	    {
  		nbdebug(("    partial line annotation -- Not Yet Implemented!\n"));
  	    }
--- 2300,2309 ----
  	    pos = get_off_or_lnum(buf->bufp, &args);
  
  	    cp = (char *)args;
! 	    ignored = (int)strtol(cp, &cp, 10);
  	    args = (char_u *)cp;
  # ifdef NBDEBUG
! 	    if (ignored != -1)
  	    {
  		nbdebug(("    partial line annotation -- Not Yet Implemented!\n"));
  	    }
*** ../vim-7.2.054/src/option.c	Sun Nov  9 13:43:25 2008
--- src/option.c	Fri Nov 28 12:27:34 2008
***************
*** 8232,8244 ****
  	    {
  		if (number == 0 && string != NULL)
  		{
! 		    int index;
  
  		    /* Either we are given a string or we are setting option
  		     * to zero. */
! 		    for (index = 0; string[index] == '0'; ++index)
  			;
! 		    if (string[index] != NUL || index == 0)
  		    {
  			/* There's another character after zeros or the string
  			 * is empty.  In both cases, we are trying to set a
--- 8232,8244 ----
  	    {
  		if (number == 0 && string != NULL)
  		{
! 		    int idx;
  
  		    /* Either we are given a string or we are setting option
  		     * to zero. */
! 		    for (idx = 0; string[idx] == '0'; ++idx)
  			;
! 		    if (string[idx] != NUL || idx == 0)
  		    {
  			/* There's another character after zeros or the string
  			 * is empty.  In both cases, we are trying to set a
*** ../vim-7.2.054/src/os_unix.c	Wed Nov 12 14:09:38 2008
--- src/os_unix.c	Fri Nov 28 18:39:55 2008
***************
*** 315,326 ****
      {-1,	    "Unknown!", FALSE}
  };
  
      void
  mch_write(s, len)
      char_u	*s;
      int		len;
  {
!     write(1, (char *)s, len);
      if (p_wd)		/* Unix is too fast, slow down a bit more */
  	RealWaitForChar(read_cmd_fd, p_wd, NULL);
  }
--- 315,329 ----
      {-1,	    "Unknown!", FALSE}
  };
  
+ /*
+  * Write s[len] to the screen.
+  */
      void
  mch_write(s, len)
      char_u	*s;
      int		len;
  {
!     ignored = (int)write(1, (char *)s, len);
      if (p_wd)		/* Unix is too fast, slow down a bit more */
  	RealWaitForChar(read_cmd_fd, p_wd, NULL);
  }
***************
*** 3927,3935 ****
  		 */
  		if (fd >= 0)
  		{
! 		    dup(fd); /* To replace stdin  (file descriptor 0) */
! 		    dup(fd); /* To replace stdout (file descriptor 1) */
! 		    dup(fd); /* To replace stderr (file descriptor 2) */
  
  		    /* Don't need this now that we've duplicated it */
  		    close(fd);
--- 3930,3938 ----
  		 */
  		if (fd >= 0)
  		{
! 		    ignored = dup(fd); /* To replace stdin  (fd 0) */
! 		    ignored = dup(fd); /* To replace stdout (fd 1) */
! 		    ignored = dup(fd); /* To replace stderr (fd 2) */
  
  		    /* Don't need this now that we've duplicated it */
  		    close(fd);
***************
*** 3997,4009 ****
  
  		    /* set up stdin/stdout/stderr for the child */
  		    close(0);
! 		    dup(pty_slave_fd);
  		    close(1);
! 		    dup(pty_slave_fd);
  		    if (gui.in_use)
  		    {
  			close(2);
! 			dup(pty_slave_fd);
  		    }
  
  		    close(pty_slave_fd);    /* has been dupped, close it now */
--- 4000,4012 ----
  
  		    /* set up stdin/stdout/stderr for the child */
  		    close(0);
! 		    ignored = dup(pty_slave_fd);
  		    close(1);
! 		    ignored = dup(pty_slave_fd);
  		    if (gui.in_use)
  		    {
  			close(2);
! 			ignored = dup(pty_slave_fd);
  		    }
  
  		    close(pty_slave_fd);    /* has been dupped, close it now */
***************
*** 4014,4026 ****
  		    /* set up stdin for the child */
  		    close(fd_toshell[1]);
  		    close(0);
! 		    dup(fd_toshell[0]);
  		    close(fd_toshell[0]);
  
  		    /* set up stdout for the child */
  		    close(fd_fromshell[0]);
  		    close(1);
! 		    dup(fd_fromshell[1]);
  		    close(fd_fromshell[1]);
  
  # ifdef FEAT_GUI
--- 4017,4029 ----
  		    /* set up stdin for the child */
  		    close(fd_toshell[1]);
  		    close(0);
! 		    ignored = dup(fd_toshell[0]);
  		    close(fd_toshell[0]);
  
  		    /* set up stdout for the child */
  		    close(fd_fromshell[0]);
  		    close(1);
! 		    ignored = dup(fd_fromshell[1]);
  		    close(fd_fromshell[1]);
  
  # ifdef FEAT_GUI
***************
*** 4028,4034 ****
  		    {
  			/* set up stderr for the child */
  			close(2);
! 			dup(1);
  		    }
  # endif
  		}
--- 4031,4037 ----
  		    {
  			/* set up stderr for the child */
  			close(2);
! 			ignored = dup(1);
  		    }
  # endif
  		}
***************
*** 4159,4165 ****
  					    && (lnum !=
  						    curbuf->b_ml.ml_line_count
  						    || curbuf->b_p_eol)))
! 				    write(toshell_fd, "\n", (size_t)1);
  				++lnum;
  				if (lnum > curbuf->b_op_end.lnum)
  				{
--- 4162,4169 ----
  					    && (lnum !=
  						    curbuf->b_ml.ml_line_count
  						    || curbuf->b_p_eol)))
! 				    ignored = write(toshell_fd, "\n",
! 								   (size_t)1);
  				++lnum;
  				if (lnum > curbuf->b_op_end.lnum)
  				{
*** ../vim-7.2.054/src/spell.c	Fri Nov 28 10:08:05 2008
--- src/spell.c	Fri Nov 28 12:28:24 2008
***************
*** 4950,4956 ****
  static void put_sugtime __ARGS((spellinfo_T *spin, FILE *fd));
  static int write_vim_spell __ARGS((spellinfo_T *spin, char_u *fname));
  static void clear_node __ARGS((wordnode_T *node));
! static int put_node __ARGS((FILE *fd, wordnode_T *node, int index, int regionmask, int prefixtree));
  static void spell_make_sugfile __ARGS((spellinfo_T *spin, char_u *wfname));
  static int sug_filltree __ARGS((spellinfo_T *spin, slang_T *slang));
  static int sug_maketable __ARGS((spellinfo_T *spin));
--- 4950,4956 ----
  static void put_sugtime __ARGS((spellinfo_T *spin, FILE *fd));
  static int write_vim_spell __ARGS((spellinfo_T *spin, char_u *fname));
  static void clear_node __ARGS((wordnode_T *node));
! static int put_node __ARGS((FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree));
  static void spell_make_sugfile __ARGS((spellinfo_T *spin, char_u *wfname));
  static int sug_filltree __ARGS((spellinfo_T *spin, slang_T *slang));
  static int sug_maketable __ARGS((spellinfo_T *spin));
*** ../vim-7.2.054/src/ui.c	Sun Sep 14 15:57:54 2008
--- src/ui.c	Fri Nov 28 19:04:36 2008
***************
*** 1820,1826 ****
  #ifdef HAVE_DUP
  	    /* Use stderr for stdin, also works for shell commands. */
  	    close(0);
! 	    dup(2);
  #else
  	    read_cmd_fd = 2;	/* read from stderr instead of stdin */
  #endif
--- 1820,1826 ----
  #ifdef HAVE_DUP
  	    /* Use stderr for stdin, also works for shell commands. */
  	    close(0);
! 	    ignored = dup(2);
  #else
  	    read_cmd_fd = 2;	/* read from stderr instead of stdin */
  #endif
*** ../vim-7.2.054/src/window.c	Sat Nov 15 14:10:23 2008
--- src/window.c	Fri Nov 28 18:46:45 2008
***************
*** 4029,4042 ****
  	    if (mch_dirname(cwd, MAXPATHL) == OK)
  		globaldir = vim_strsave(cwd);
  	}
! 	mch_chdir((char *)curwin->w_localdir);
! 	shorten_fnames(TRUE);
      }
      else if (globaldir != NULL)
      {
  	/* Window doesn't have a local directory and we are not in the global
  	 * directory: Change to the global directory. */
! 	mch_chdir((char *)globaldir);
  	vim_free(globaldir);
  	globaldir = NULL;
  	shorten_fnames(TRUE);
--- 4029,4042 ----
  	    if (mch_dirname(cwd, MAXPATHL) == OK)
  		globaldir = vim_strsave(cwd);
  	}
! 	if (mch_chdir((char *)curwin->w_localdir) == 0)
! 	    shorten_fnames(TRUE);
      }
      else if (globaldir != NULL)
      {
  	/* Window doesn't have a local directory and we are not in the global
  	 * directory: Change to the global directory. */
! 	ignored = mch_chdir((char *)globaldir);
  	vim_free(globaldir);
  	globaldir = NULL;
  	shorten_fnames(TRUE);
*** ../vim-7.2.054/src/version.c	Fri Nov 28 12:05:07 2008
--- src/version.c	Fri Nov 28 21:12:42 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     55,
  /**/

-- 
PRINCE:    He's come to rescue me, father.
LAUNCELOT: (embarrassed) Well, let's not jump to conclusions ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.056
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.056 (after 7.2.050)
Problem:    Tests 58 and 59 fail.
Solution:   Don't invoke fwrite() with a zero length. (Dominique Pelle)
Files:	    src/spell.c


*** ../vim-7.2.055/src/spell.c	Fri Nov 28 21:26:50 2008
--- src/spell.c	Sat Nov 29 19:58:21 2008
***************
*** 8112,8118 ****
  		p = rr == 1 ? ftp->ft_from : ftp->ft_to;
  		l = (int)STRLEN(p);
  		putc(l, fd);
! 		fwv &= fwrite(p, l, (size_t)1, fd);
  	    }
  	}
  
--- 8218,8225 ----
  		p = rr == 1 ? ftp->ft_from : ftp->ft_to;
  		l = (int)STRLEN(p);
  		putc(l, fd);
! 		if (l > 0)
! 		    fwv &= fwrite(p, l, (size_t)1, fd);
  	    }
  	}
  
*** ../vim-7.2.055/src/version.c	Fri Nov 28 21:26:50 2008
--- src/version.c	Sat Nov 29 20:10:05 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     56,
  /**/

-- 
GUARD #1:  Where'd you get the coconut?
ARTHUR:    We found them.
GUARD #1:  Found them?  In Mercea?  The coconut's tropical!
ARTHUR:    What do you mean?
GUARD #1:  Well, this is a temperate zone.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.057
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.057 (after 7.2.056)
Problem:    Combination of int and size_t may not work.
Solution:   Use size_t for variable.
Files:	    src/spell.c


*** ../vim-7.2.056/src/spell.c	Sat Nov 29 20:10:59 2008
--- src/spell.c	Sat Nov 29 20:15:43 2008
***************
*** 7926,7932 ****
      char_u	*p;
      int		rr;
      int		retval = OK;
!     int		fwv = 1;  /* collect return value of fwrite() to avoid
  			     warnings from picky compiler */
  
      fd = mch_fopen((char *)fname, "w");
--- 8028,8034 ----
      char_u	*p;
      int		rr;
      int		retval = OK;
!     size_t	fwv = 1;  /* collect return value of fwrite() to avoid
  			     warnings from picky compiler */
  
      fd = mch_fopen((char *)fname, "w");
***************
*** 7939,7944 ****
--- 8041,8050 ----
      /* <HEADER>: <fileID> <versionnr> */
  							    /* <fileID> */
      fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);
+     if (fwv != (size_t)1)
+ 	/* Catch first write error, don't try writing more. */
+ 	goto theend;
+ 
      putc(VIMSPELLVERSION, fd);				    /* <versionnr> */
  
      /*
***************
*** 8300,8310 ****
      /* Write another byte to check for errors (file system full). */
      if (putc(0, fd) == EOF)
  	retval = FAIL;
! 
      if (fclose(fd) == EOF)
  	retval = FAIL;
  
!     if (fwv != 1)
  	retval = FAIL;
      if (retval == FAIL)
  	EMSG(_(e_write));
--- 8406,8416 ----
      /* Write another byte to check for errors (file system full). */
      if (putc(0, fd) == EOF)
  	retval = FAIL;
! theend:
      if (fclose(fd) == EOF)
  	retval = FAIL;
  
!     if (fwv != (size_t)1)
  	retval = FAIL;
      if (retval == FAIL)
  	EMSG(_(e_write));
***************
*** 9897,9903 ****
      char_u	*p;
      int		len;
      int		totlen;
!     int		x = 1;  /* collect return value of fwrite() */
  
      if (fd != NULL)
  	put_bytes(fd, (long_u)gap->ga_len, 2);	    /* <prefcondcnt> */
--- 10003,10009 ----
      char_u	*p;
      int		len;
      int		totlen;
!     size_t	x = 1;  /* collect return value of fwrite() */
  
      if (fd != NULL)
  	put_bytes(fd, (long_u)gap->ga_len, 2);	    /* <prefcondcnt> */
*** ../vim-7.2.056/src/version.c	Sat Nov 29 20:10:59 2008
--- src/version.c	Sat Nov 29 20:13:46 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     57,
  /**/

-- 
GUARD #1:  What -- a swallow carrying a coconut?
ARTHUR:    It could grip it by the husk!
GUARD #1:  It's not a question of where he grips it!  It's a simple question
           of weight ratios!  A five ounce bird could not carry a 1 pound
           coconut.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.058
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.058
Problem:    Can't add a patch name to the ":version" output.
Solution:   Add the extra_patches array.
Files:	    src/version.c


*** ../vim-7.2.057/src/version.c	Sat Nov 29 20:18:44 2008
--- src/version.c	Sun Nov 30 12:12:31 2008
***************
*** 794,799 ****
--- 796,814 ----
      0
  };
  
+ /*
+  * Place to put a short description when adding a feature with a patch.
+  * Keep it short, e.g.,: "relative numbers", "persistent undo".
+  * Also add a comment marker to separate the lines.
+  * See the official Vim patches for the diff format: It must use a context of
+  * one line only.  Use "diff -C2".
+  */
+ static char *(extra_patches[]) =
+ {   /* Add your patch description below this line */
+ /**/
+     NULL
+ };
+ 
      int
  highest_patch()
  {
***************
*** 939,944 ****
--- 954,972 ----
  	}
      }
  
+     /* Print the list of extra patch descriptions if there is at least one. */
+     if (extra_patches[0] != NULL)
+     {
+ 	MSG_PUTS(_("\nExtra patches: "));
+ 	s = "";
+ 	for (i = 0; extra_patches[i] != NULL; ++i)
+ 	{
+ 	    MSG_PUTS(s);
+ 	    s = ", ";
+ 	    MSG_PUTS(extra_patches[i]);
+ 	}
+     }
+ 
  #ifdef MODIFIED_BY
      MSG_PUTS("\n");
      MSG_PUTS(_("Modified by "));
*** ../vim-7.2.057/src/version.c	Sat Nov 29 20:18:44 2008
--- src/version.c	Sun Nov 30 12:12:31 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     58,
  /**/

-- 
ARTHUR:    Well, it doesn't matter.  Will you go and tell your master that
           Arthur from the Court of Camelot is here.
GUARD #1:  Listen, in order to maintain air-speed velocity, a swallow
           needs to beat its wings 43 times every second, right?
ARTHUR:    Please!
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.059
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.059
Problem:    Diff display is not always updated.
Solution:   Update the display more often.
Files:	    src/diff.c


*** ../vim-7.2.058/src/diff.c	Fri Nov 28 21:26:50 2008
--- src/diff.c	Fri Nov 28 17:23:35 2008
***************
*** 73,78 ****
--- 73,80 ----
  	{
  	    tp->tp_diffbuf[i] = NULL;
  	    tp->tp_diff_invalid = TRUE;
+ 	    if (tp == curtab)
+ 		diff_redraw(TRUE);
  	}
      }
  }
***************
*** 102,107 ****
--- 104,110 ----
  	    {
  		curtab->tp_diffbuf[i] = NULL;
  		curtab->tp_diff_invalid = TRUE;
+ 		diff_redraw(TRUE);
  	    }
  	}
      }
***************
*** 131,136 ****
--- 134,140 ----
  	{
  	    curtab->tp_diffbuf[i] = buf;
  	    curtab->tp_diff_invalid = TRUE;
+ 	    diff_redraw(TRUE);
  	    return;
  	}
  
*** ../vim-7.2.058/src/version.c	Sun Nov 30 12:14:35 2008
--- src/version.c	Sun Nov 30 15:13:18 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     59,
  /**/

-- 
GUARD #2:  Wait a minute -- supposing two swallows carried it together?
GUARD #1:  No, they'd have to have it on a line.
GUARD #2:  Well, simple!  They'd just use a standard creeper!
GUARD #1:  What, held under the dorsal guiding feathers?
GUARD #2:  Well, why not?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.060
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.060
Problem:    When a spell files has many compound rules it may take a very long
	    time making the list of suggestions.  Displaying also can be slow
	    when there are misspelled words.
	    Can't parse some Hunspell .aff files.
Solution:   Check if a compounding can possibly work before trying a
	    combination, if the compound rules don't contain wildcards.
	    Implement using CHECKCOMPOUNDPATTERN.
	    Ignore COMPOUNDRULES.  Ignore a comment after most items.
	    Accept ONLYINCOMPOUND as an alias for NEEDCOMPOUND.
	    Accept FORBIDDENWORD as an alias for BAD.
Files:	    runtime/doc/spell.txt, src/spell.c


*** ../vim-7.2.059/runtime/doc/spell.txt	Sat Aug  9 19:36:52 2008
--- runtime/doc/spell.txt	Sun Nov 30 16:30:02 2008
***************
*** 1,4 ****
! *spell.txt*	For Vim version 7.2.  Last change: 2008 Jun 21
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *spell.txt*	For Vim version 7.2.  Last change: 2008 Nov 30
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 831,838 ****
  
  	# comment line ~
  
! With some items it's also possible to put a comment after it, but this isn't
! supported in general.
  
  
  ENCODING							*spell-SET*
--- 831,841 ----
  
  	# comment line ~
  
! Items with a fixed number of arguments can be followed by a comment.  But only
! if none of the arguments can contain white space.  The comment must start with
! a "#" character.  Example:
! 
! 	KEEPCASE =  # fix case for words with this flag ~
  
  
  ENCODING							*spell-SET*
***************
*** 965,970 ****
--- 968,976 ----
  
  Note: When using utf-8 only characters up to 65000 may be used for flags.
  
+ Note: even when using "num" or "long" the number of flags available to
+ compounding and prefixes is limited to about 250.
+ 
  
  AFFIXES
  					    *spell-PFX* *spell-SFX*
***************
*** 1178,1183 ****
--- 1185,1193 ----
  The flag also applies to the word with affixes, thus this can be used to mark
  a whole bunch of related words as bad.
  
+ 							*spell-FORBIDDENWORD*
+ FORBIDDENWORD can be used just like BAD.  For compatibility with Hunspell.
+ 
  							*spell-NEEDAFFIX*
  The NEEDAFFIX flag is used to require that a word is used with an affix.  The
  word itself is not a good word (unless there is an empty affix).  Example:
***************
*** 1268,1273 ****
--- 1278,1287 ----
  
  	NEEDCOMPOUND & ~
  
+ 							*spell-ONLYINCOMPOUND*
+ The ONLYINCOMPOUND does exactly the same as NEEDCOMPOUND.  Supported for
+ compatiblity with Hunspell.
+ 
  							*spell-COMPOUNDMIN*
  The minimal character length of a word used for compounding is specified with
  COMPOUNDMIN.  Example:
***************
*** 1328,1333 ****
--- 1342,1361 ----
  rules.  Can also be used for an affix to count the affix as a compounding
  word.
  
+ 						*spell-CHECKCOMPOUNDPATTERN*
+ CHECKCOMPOUNDPATTERN is used to define patterns that, when matching at the
+ position where two words are compounded together forbids the compound.
+ For example:
+ 	CHECKCOMPOUNDPATTERN o e ~
+ 
+ This forbids compounding if the first word ends in "o" and the second word
+ starts with "e".
+ 
+ The arguments must be plain text, no patterns are actually supported, despite
+ the item name.  Case is always ignored.
+ 
+ The Hunspell feature to use three arguments and flags is not supported.
+ 
  							*spell-SYLLABLE*
  The SYLLABLE item defines characters or character sequences that are used to
  count the number of syllables in a word.  Example:
***************
*** 1496,1501 ****
--- 1524,1533 ----
  ACCENT		(Hunspell)				*spell-ACCENT*
  		Use MAP instead. |spell-MAP|
  
+ BREAK		(Hunspell)				*spell-BREAK*
+ 		Define break points.  Unclear how it works exactly.
+ 		Not supported.
+ 
  CHECKCOMPOUNDCASE  (Hunspell)			*spell-CHECKCOMPOUNDCASE*
  		Disallow uppercase letters at compound word boundaries.
  		Not supported.
***************
*** 1512,1520 ****
  		Forbid three identical characters when compounding.  Not
  		supported.
  
- CHECKCOMPOUNDPATTERN  (Hunspell)		*spell-CHECKCOMPOUNDPATTERN*
- 		Forbid compounding when patterns match.  Not supported.
- 
  COMPLEXPREFIXES  (Hunspell)				*spell-COMPLEXPREFIXES*
  		Enables using two prefixes.  Not supported.
  
--- 1544,1549 ----
***************
*** 1536,1548 ****
  COMPOUNDMIDDLE	(Hunspell)				*spell-COMPOUNDMIDDLE*
  		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|
  
  COMPOUNDSYLLABLE  (Hunspell)			*spell-COMPOUNDSYLLABLE*
  		Use SYLLABLE and COMPOUNDSYLMAX instead. |spell-SYLLABLE|
  		|spell-COMPOUNDSYLMAX|
  
! FORBIDDENWORD	(Hunspell)				*spell-FORBIDDENWORD*
! 		Use BAD instead. |spell-BAD|
! 
  LANG		(Hunspell)				*spell-LANG*
  		This specifies language-specific behavior.  This actually
  		moves part of the language knowledge into the program,
--- 1565,1582 ----
  COMPOUNDMIDDLE	(Hunspell)				*spell-COMPOUNDMIDDLE*
  		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|
  
+ COMPOUNDRULES	(Hunspell)				*spell-COMPOUNDRULES*
+ 		Number of COMPOUNDRULE lines following.  Ignored, but the
+ 		argument must be a number.
+ 
  COMPOUNDSYLLABLE  (Hunspell)			*spell-COMPOUNDSYLLABLE*
  		Use SYLLABLE and COMPOUNDSYLMAX instead. |spell-SYLLABLE|
  		|spell-COMPOUNDSYLMAX|
  
! KEY		(Hunspell)				*spell-KEY*
! 		Define characters that are close together on the keyboard.
! 		Used to give better suggestions.  Not supported.
! 		
  LANG		(Hunspell)				*spell-LANG*
  		This specifies language-specific behavior.  This actually
  		moves part of the language knowledge into the program,
***************
*** 1553,1562 ****
  		Only needed for morphological analysis.
  
  MAXNGRAMSUGS	(Hunspell)				*spell-MAXNGRAMSUGS*
! 		Not supported.
! 
! ONLYINCOMPOUND	(Hunspell)				*spell-ONLYINCOMPOUND*
! 		Use NEEDCOMPOUND instead. |spell-NEEDCOMPOUND|
  
  PSEUDOROOT	(Hunspell)				*spell-PSEUDOROOT*
  		Use NEEDAFFIX instead. |spell-NEEDAFFIX|
--- 1587,1593 ----
  		Only needed for morphological analysis.
  
  MAXNGRAMSUGS	(Hunspell)				*spell-MAXNGRAMSUGS*
! 		Set number of n-gram suggestions.  Not supported.
  
  PSEUDOROOT	(Hunspell)				*spell-PSEUDOROOT*
  		Use NEEDAFFIX instead. |spell-NEEDAFFIX|
*** ../vim-7.2.059/src/spell.c	Sat Nov 29 20:18:44 2008
--- src/spell.c	Sun Nov 30 20:59:13 2008
***************
*** 469,474 ****
--- 469,475 ----
      garray_T	sl_comppat;	/* CHECKCOMPOUNDPATTERN items */
      regprog_T	*sl_compprog;	/* COMPOUNDRULE turned into a regexp progrm
  				 * (NULL when no compounding) */
+     char_u	*sl_comprules;	/* all COMPOUNDRULE concatenated (or NULL) */
      char_u	*sl_compstartflags; /* flags for first compound word */
      char_u	*sl_compallflags; /* all flags for compound words */
      char_u	sl_nobreak;	/* When TRUE: no spaces between words */
***************
*** 839,845 ****
--- 840,849 ----
  static void slang_clear __ARGS((slang_T *lp));
  static void slang_clear_sug __ARGS((slang_T *lp));
  static void find_word __ARGS((matchinf_T *mip, int mode));
+ static int match_checkcompoundpattern __ARGS((char_u *ptr, int wlen, garray_T *gap));
  static int can_compound __ARGS((slang_T *slang, char_u *word, char_u *flags));
+ static int can_be_compound __ARGS((trystate_T *sp, slang_T *slang, char_u *compflags, int flag));
+ static int match_compoundrule __ARGS((slang_T *slang, char_u *compflags));
  static int valid_word_prefix __ARGS((int totprefcnt, int arridx, int flags, char_u *word, slang_T *slang, int cond_req));
  static void find_prefix __ARGS((matchinf_T *mip, int mode));
  static int fold_more __ARGS((matchinf_T *mip));
***************
*** 1519,1524 ****
--- 1523,1533 ----
  					    ((unsigned)flags >> 24)))
  		    continue;
  
+ 		/* If there is a match with a CHECKCOMPOUNDPATTERN rule
+ 		 * discard the compound word. */
+ 		if (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))
+ 		    continue;
+ 
  		if (mode == FIND_COMPOUND)
  		{
  		    int	    capflags;
***************
*** 1577,1582 ****
--- 1586,1596 ----
  		    if (!can_compound(slang, fword, mip->mi_compflags))
  			continue;
  		}
+ 		else if (slang->sl_comprules != NULL
+ 			     && !match_compoundrule(slang, mip->mi_compflags))
+ 		    /* The compound flags collected so far do not match any
+ 		     * COMPOUNDRULE, discard the compounded word. */
+ 		    continue;
  	    }
  
  	    /* Check NEEDCOMPOUND: can't use word without compounding. */
***************
*** 1727,1732 ****
--- 1741,1779 ----
  }
  
  /*
+  * Return TRUE if there is a match between the word ptr[wlen] and
+  * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another
+  * word.
+  * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the
+  * end of ptr[wlen] and the second part matches after it.
+  */
+     static int
+ match_checkcompoundpattern(ptr, wlen, gap)
+     char_u	*ptr;
+     int		wlen;
+     garray_T	*gap;  /* &sl_comppat */
+ {
+     int		i;
+     char_u	*p;
+     int		len;
+ 
+     for (i = 0; i + 1 < gap->ga_len; i += 2)
+     {
+ 	p = ((char_u **)gap->ga_data)[i + 1];
+ 	if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)
+ 	{
+ 	    /* Second part matches at start of following compound word, now
+ 	     * check if first part matches at end of previous word. */
+ 	    p = ((char_u **)gap->ga_data)[i];
+ 	    len = STRLEN(p);
+ 	    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)
+ 		return TRUE;
+ 	}
+     }
+     return FALSE;
+ }
+ 
+ /*
   * Return TRUE if "flags" is a valid sequence of compound flags and "word"
   * does not have too many syllables.
   */
***************
*** 1773,1778 ****
--- 1820,1917 ----
  }
  
  /*
+  * Return TRUE when the sequence of flags in "compflags" plus "flag" can
+  * possibly form a valid compounded word.  This also checks the COMPOUNDRULE
+  * lines if they don't contain wildcards.
+  */
+     static int
+ can_be_compound(sp, slang, compflags, flag)
+     trystate_T	*sp;
+     slang_T	*slang;
+     char_u	*compflags;
+     int		flag;
+ {
+     /* If the flag doesn't appear in sl_compstartflags or sl_compallflags
+      * then it can't possibly compound. */
+     if (!byte_in_str(sp->ts_complen == sp->ts_compsplit
+ 		? slang->sl_compstartflags : slang->sl_compallflags, flag))
+ 	return FALSE;
+ 
+     /* If there are no wildcards, we can check if the flags collected so far
+      * possibly can form a match with COMPOUNDRULE patterns.  This only
+      * makes sense when we have two or more words. */
+     if (slang->sl_comprules != NULL && sp->ts_complen > sp->ts_compsplit)
+     {
+ 	int v;
+ 
+ 	compflags[sp->ts_complen] = flag;
+ 	compflags[sp->ts_complen + 1] = NUL;
+ 	v = match_compoundrule(slang, compflags + sp->ts_compsplit);
+ 	compflags[sp->ts_complen] = NUL;
+ 	return v;
+     }
+ 
+     return TRUE;
+ }
+ 
+ 
+ /*
+  * Return TRUE if the compound flags in compflags[] match the start of any
+  * compound rule.  This is used to stop trying a compound if the flags
+  * collected so far can't possibly match any compound rule.
+  * Caller must check that slang->sl_comprules is not NULL.
+  */
+     static int
+ match_compoundrule(slang, compflags)
+     slang_T	*slang;
+     char_u	*compflags;
+ {
+     char_u	*p;
+     int		i;
+     int		c;
+ 
+     /* loop over all the COMPOUNDRULE entries */
+     for (p = slang->sl_comprules; *p != NUL; ++p)
+     {
+ 	/* loop over the flags in the compound word we have made, match
+ 	 * them against the current rule entry */
+ 	for (i = 0; ; ++i)
+ 	{
+ 	    c = compflags[i];
+ 	    if (c == NUL)
+ 		/* found a rule that matches for the flags we have so far */
+ 		return TRUE;
+ 	    if (*p == '/' || *p == NUL)
+ 		break;  /* end of rule, it's too short */
+ 	    if (*p == '[')
+ 	    {
+ 		int match = FALSE;
+ 
+ 		/* compare against all the flags in [] */
+ 		++p;
+ 		while (*p != ']' && *p != NUL)
+ 		    if (*p++ == c)
+ 			match = TRUE;
+ 		if (!match)
+ 		    break;  /* none matches */
+ 	    }
+ 	    else if (*p != c)
+ 		break;  /* flag of word doesn't match flag in pattern */
+ 	    ++p;
+ 	}
+ 
+ 	/* Skip to the next "/", where the next pattern starts. */
+ 	p = vim_strchr(p, '/');
+ 	if (p == NULL)
+ 	    break;
+     }
+ 
+     /* Checked all the rules and none of them match the flags, so there
+      * can't possibly be a compound starting with these flags. */
+     return FALSE;
+ }
+ 
+ /*
   * Return non-zero if the prefix indicated by "arridx" matches with the prefix
   * ID in "flags" for the word "word".
   * The WF_RAREPFX flag is included in the return value for a rare prefix.
***************
*** 2513,2521 ****
--- 2652,2662 ----
      lp->sl_midword = NULL;
  
      vim_free(lp->sl_compprog);
+     vim_free(lp->sl_comprules);
      vim_free(lp->sl_compstartflags);
      vim_free(lp->sl_compallflags);
      lp->sl_compprog = NULL;
+     lp->sl_comprules = NULL;
      lp->sl_compstartflags = NULL;
      lp->sl_compallflags = NULL;
  
***************
*** 3460,3465 ****
--- 3601,3607 ----
      char_u	*pp;
      char_u	*cp;
      char_u	*ap;
+     char_u	*crp;
      int		cnt;
      garray_T	*gap;
  
***************
*** 3545,3550 ****
--- 3687,3698 ----
      slang->sl_compallflags = ap;
      *ap = NUL;
  
+     /* And a list of all patterns in their original form, for checking whether
+      * compounding may work in match_compoundrule().  This is freed when we
+      * encounter a wildcard, the check doesn't work then. */
+     crp = alloc(todo + 1);
+     slang->sl_comprules = crp;
+ 
      pp = pat;
      *pp++ = '^';
      *pp++ = '\\';
***************
*** 3587,3592 ****
--- 3735,3754 ----
  		    atstart = 0;
  	    }
  	}
+ 
+ 	/* Copy flag to "sl_comprules", unless we run into a wildcard. */
+ 	if (crp != NULL)
+ 	{
+ 	    if (c == '+' || c == '*')
+ 	    {
+ 		vim_free(slang->sl_comprules);
+ 		slang->sl_comprules = NULL;
+ 		crp = NULL;
+ 	    }
+ 	    else
+ 		*crp++ = c;
+ 	}
+ 
  	if (c == '/')	    /* slash separates two items */
  	{
  	    *pp++ = '\\';
***************
*** 3611,3616 ****
--- 3773,3781 ----
      *pp++ = '$';
      *pp = NUL;
  
+     if (crp != NULL)
+ 	*crp = NUL;
+ 
      slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);
      vim_free(pat);
      if (slang->sl_compprog == NULL)
***************
*** 4915,4920 ****
--- 5080,5086 ----
  } spellinfo_T;
  
  static afffile_T *spell_read_aff __ARGS((spellinfo_T *spin, char_u *fname));
+ static int is_aff_rule __ARGS((char_u **items, int itemcnt, char *rulename, int	 mincount));
  static void aff_process_flags __ARGS((afffile_T *affile, affentry_T *entry));
  static int spell_info_item __ARGS((char_u *s));
  static unsigned affitem2flag __ARGS((int flagtype, char_u *item, char_u	*fname, int lnum));
***************
*** 5223,5230 ****
  	/* Handle non-empty lines. */
  	if (itemcnt > 0)
  	{
! 	    if (STRCMP(items[0], "SET") == 0 && itemcnt == 2
! 						       && aff->af_enc == NULL)
  	    {
  #ifdef FEAT_MBYTE
  		/* Setup for conversion from "ENC" to 'encoding'. */
--- 5389,5395 ----
  	/* Handle non-empty lines. */
  	if (itemcnt > 0)
  	{
! 	    if (is_aff_rule(items, itemcnt, "SET", 2) && aff->af_enc == NULL)
  	    {
  #ifdef FEAT_MBYTE
  		/* Setup for conversion from "ENC" to 'encoding'. */
***************
*** 5239,5245 ****
  		    smsg((char_u *)_("Conversion in %s not supported"), fname);
  #endif
  	    }
! 	    else if (STRCMP(items[0], "FLAG") == 0 && itemcnt == 2
  					      && aff->af_flagtype == AFT_CHAR)
  	    {
  		if (STRCMP(items[1], "long") == 0)
--- 5404,5410 ----
  		    smsg((char_u *)_("Conversion in %s not supported"), fname);
  #endif
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "FLAG", 2)
  					      && aff->af_flagtype == AFT_CHAR)
  	    {
  		if (STRCMP(items[1], "long") == 0)
***************
*** 5284,5352 ****
  			spin->si_info = p;
  		    }
  	    }
! 	    else if (STRCMP(items[0], "MIDWORD") == 0 && itemcnt == 2
  							   && midword == NULL)
  	    {
  		midword = getroom_save(spin, items[1]);
  	    }
! 	    else if (STRCMP(items[0], "TRY") == 0 && itemcnt == 2)
  	    {
  		/* ignored, we look in the tree for what chars may appear */
  	    }
  	    /* TODO: remove "RAR" later */
! 	    else if ((STRCMP(items[0], "RAR") == 0
! 			|| STRCMP(items[0], "RARE") == 0) && itemcnt == 2
! 						       && aff->af_rare == 0)
  	    {
  		aff->af_rare = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
  	    /* TODO: remove "KEP" later */
! 	    else if ((STRCMP(items[0], "KEP") == 0
! 		    || STRCMP(items[0], "KEEPCASE") == 0) && itemcnt == 2
  						     && aff->af_keepcase == 0)
  	    {
  		aff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "BAD") == 0 && itemcnt == 2
! 						       && aff->af_bad == 0)
  	    {
  		aff->af_bad = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "NEEDAFFIX") == 0 && itemcnt == 2
  						    && aff->af_needaffix == 0)
  	    {
  		aff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "CIRCUMFIX") == 0 && itemcnt == 2
  						    && aff->af_circumfix == 0)
  	    {
  		aff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "NOSUGGEST") == 0 && itemcnt == 2
  						    && aff->af_nosuggest == 0)
  	    {
  		aff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "NEEDCOMPOUND") == 0 && itemcnt == 2
  						     && aff->af_needcomp == 0)
  	    {
  		aff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "COMPOUNDROOT") == 0 && itemcnt == 2
  						     && aff->af_comproot == 0)
  	    {
  		aff->af_comproot = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "COMPOUNDFORBIDFLAG") == 0
! 				   && itemcnt == 2 && aff->af_compforbid == 0)
  	    {
  		aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
--- 5449,5519 ----
  			spin->si_info = p;
  		    }
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "MIDWORD", 2)
  							   && midword == NULL)
  	    {
  		midword = getroom_save(spin, items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "TRY", 2))
  	    {
  		/* ignored, we look in the tree for what chars may appear */
  	    }
  	    /* TODO: remove "RAR" later */
! 	    else if ((is_aff_rule(items, itemcnt, "RAR", 2)
! 			|| is_aff_rule(items, itemcnt, "RARE", 2))
! 							 && aff->af_rare == 0)
  	    {
  		aff->af_rare = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
  	    /* TODO: remove "KEP" later */
! 	    else if ((is_aff_rule(items, itemcnt, "KEP", 2)
! 			|| is_aff_rule(items, itemcnt, "KEEPCASE", 2))
  						     && aff->af_keepcase == 0)
  	    {
  		aff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if ((is_aff_rule(items, itemcnt, "BAD", 2)
! 			|| is_aff_rule(items, itemcnt, "FORBIDDENWORD", 2))
! 							  && aff->af_bad == 0)
  	    {
  		aff->af_bad = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "NEEDAFFIX", 2)
  						    && aff->af_needaffix == 0)
  	    {
  		aff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "CIRCUMFIX", 2)
  						    && aff->af_circumfix == 0)
  	    {
  		aff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "NOSUGGEST", 2)
  						    && aff->af_nosuggest == 0)
  	    {
  		aff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if ((is_aff_rule(items, itemcnt, "NEEDCOMPOUND", 2)
! 			|| is_aff_rule(items, itemcnt, "ONLYINCOMPOUND", 2))
  						     && aff->af_needcomp == 0)
  	    {
  		aff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDROOT", 2)
  						     && aff->af_comproot == 0)
  	    {
  		aff->af_comproot = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFORBIDFLAG", 2)
! 						   && aff->af_compforbid == 0)
  	    {
  		aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
***************
*** 5354,5361 ****
  		    smsg((char_u *)_("Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d"),
  			    fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "COMPOUNDPERMITFLAG") == 0
! 				   && itemcnt == 2 && aff->af_comppermit == 0)
  	    {
  		aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
--- 5521,5528 ----
  		    smsg((char_u *)_("Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d"),
  			    fname, lnum);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDPERMITFLAG", 2)
! 						   && aff->af_comppermit == 0)
  	    {
  		aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
***************
*** 5363,5369 ****
  		    smsg((char_u *)_("Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d"),
  			    fname, lnum);
  	    }
! 	    else if (STRCMP(items[0], "COMPOUNDFLAG") == 0 && itemcnt == 2
  							 && compflags == NULL)
  	    {
  		/* Turn flag "c" into COMPOUNDRULE compatible string "c+",
--- 5530,5536 ----
  		    smsg((char_u *)_("Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d"),
  			    fname, lnum);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFLAG", 2)
  							 && compflags == NULL)
  	    {
  		/* Turn flag "c" into COMPOUNDRULE compatible string "c+",
***************
*** 5376,5382 ****
  		    compflags = p;
  		}
  	    }
! 	    else if (STRCMP(items[0], "COMPOUNDRULE") == 0 && itemcnt == 2)
  	    {
  		/* Concatenate this string to previously defined ones, using a
  		 * slash to separate them. */
--- 5543,5557 ----
  		    compflags = p;
  		}
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULES", 2))
! 	    {
! 		/* We don't use the count, but do check that it's a number and
! 		 * not COMPOUNDRULE mistyped. */
! 		if (atoi((char *)items[1]) == 0)
! 		    smsg((char_u *)_("Wrong COMPOUNDRULES value in %s line %d: %s"),
! 						       fname, lnum, items[1]);
! 	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULE", 2))
  	    {
  		/* Concatenate this string to previously defined ones, using a
  		 * slash to separate them. */
***************
*** 5395,5401 ****
  		    compflags = p;
  		}
  	    }
! 	    else if (STRCMP(items[0], "COMPOUNDWORDMAX") == 0 && itemcnt == 2
  							      && compmax == 0)
  	    {
  		compmax = atoi((char *)items[1]);
--- 5570,5576 ----
  		    compflags = p;
  		}
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDWORDMAX", 2)
  							      && compmax == 0)
  	    {
  		compmax = atoi((char *)items[1]);
***************
*** 5403,5409 ****
  		    smsg((char_u *)_("Wrong COMPOUNDWORDMAX value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
! 	    else if (STRCMP(items[0], "COMPOUNDMIN") == 0 && itemcnt == 2
  							   && compminlen == 0)
  	    {
  		compminlen = atoi((char *)items[1]);
--- 5578,5584 ----
  		    smsg((char_u *)_("Wrong COMPOUNDWORDMAX value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDMIN", 2)
  							   && compminlen == 0)
  	    {
  		compminlen = atoi((char *)items[1]);
***************
*** 5411,5417 ****
  		    smsg((char_u *)_("Wrong COMPOUNDMIN value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
! 	    else if (STRCMP(items[0], "COMPOUNDSYLMAX") == 0 && itemcnt == 2
  							   && compsylmax == 0)
  	    {
  		compsylmax = atoi((char *)items[1]);
--- 5586,5592 ----
  		    smsg((char_u *)_("Wrong COMPOUNDMIN value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDSYLMAX", 2)
  							   && compsylmax == 0)
  	    {
  		compsylmax = atoi((char *)items[1]);
***************
*** 5419,5450 ****
  		    smsg((char_u *)_("Wrong COMPOUNDSYLMAX value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
! 	    else if (STRCMP(items[0], "CHECKCOMPOUNDDUP") == 0 && itemcnt == 1)
  	    {
  		compoptions |= COMP_CHECKDUP;
  	    }
! 	    else if (STRCMP(items[0], "CHECKCOMPOUNDREP") == 0 && itemcnt == 1)
  	    {
  		compoptions |= COMP_CHECKREP;
  	    }
! 	    else if (STRCMP(items[0], "CHECKCOMPOUNDCASE") == 0 && itemcnt == 1)
  	    {
  		compoptions |= COMP_CHECKCASE;
  	    }
! 	    else if (STRCMP(items[0], "CHECKCOMPOUNDTRIPLE") == 0
! 							      && itemcnt == 1)
  	    {
  		compoptions |= COMP_CHECKTRIPLE;
  	    }
! 	    else if (STRCMP(items[0], "CHECKCOMPOUNDPATTERN") == 0
! 							      && itemcnt == 2)
  	    {
  		if (atoi((char *)items[1]) == 0)
  		    smsg((char_u *)_("Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
! 	    else if (STRCMP(items[0], "CHECKCOMPOUNDPATTERN") == 0
! 							      && itemcnt == 3)
  	    {
  		garray_T    *gap = &spin->si_comppat;
  		int	    i;
--- 5594,5622 ----
  		    smsg((char_u *)_("Wrong COMPOUNDSYLMAX value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDDUP", 1))
  	    {
  		compoptions |= COMP_CHECKDUP;
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDREP", 1))
  	    {
  		compoptions |= COMP_CHECKREP;
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDCASE", 1))
  	    {
  		compoptions |= COMP_CHECKCASE;
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDTRIPLE", 1))
  	    {
  		compoptions |= COMP_CHECKTRIPLE;
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 2))
  	    {
  		if (atoi((char *)items[1]) == 0)
  		    smsg((char_u *)_("Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 3))
  	    {
  		garray_T    *gap = &spin->si_comppat;
  		int	    i;
***************
*** 5463,5486 ****
  					       = getroom_save(spin, items[2]);
  		}
  	    }
! 	    else if (STRCMP(items[0], "SYLLABLE") == 0 && itemcnt == 2
  							  && syllable == NULL)
  	    {
  		syllable = getroom_save(spin, items[1]);
  	    }
! 	    else if (STRCMP(items[0], "NOBREAK") == 0 && itemcnt == 1)
  	    {
  		spin->si_nobreak = TRUE;
  	    }
! 	    else if (STRCMP(items[0], "NOSPLITSUGS") == 0 && itemcnt == 1)
  	    {
  		spin->si_nosplitsugs = TRUE;
  	    }
! 	    else if (STRCMP(items[0], "NOSUGFILE") == 0 && itemcnt == 1)
  	    {
  		spin->si_nosugfile = TRUE;
  	    }
! 	    else if (STRCMP(items[0], "PFXPOSTPONE") == 0 && itemcnt == 1)
  	    {
  		aff->af_pfxpostpone = TRUE;
  	    }
--- 5635,5658 ----
  					       = getroom_save(spin, items[2]);
  		}
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "SYLLABLE", 2)
  							  && syllable == NULL)
  	    {
  		syllable = getroom_save(spin, items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "NOBREAK", 1))
  	    {
  		spin->si_nobreak = TRUE;
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "NOSPLITSUGS", 1))
  	    {
  		spin->si_nosplitsugs = TRUE;
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "NOSUGFILE", 1))
  	    {
  		spin->si_nosugfile = TRUE;
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "PFXPOSTPONE", 1))
  	    {
  		aff->af_pfxpostpone = TRUE;
  	    }
***************
*** 5771,5794 ****
  		    }
  		}
  	    }
! 	    else if (STRCMP(items[0], "FOL") == 0 && itemcnt == 2
! 							       && fol == NULL)
  	    {
  		fol = vim_strsave(items[1]);
  	    }
! 	    else if (STRCMP(items[0], "LOW") == 0 && itemcnt == 2
! 							       && low == NULL)
  	    {
  		low = vim_strsave(items[1]);
  	    }
! 	    else if (STRCMP(items[0], "UPP") == 0 && itemcnt == 2
! 							       && upp == NULL)
  	    {
  		upp = vim_strsave(items[1]);
  	    }
! 	    else if ((STRCMP(items[0], "REP") == 0
! 			|| STRCMP(items[0], "REPSAL") == 0)
! 		    && itemcnt == 2)
  	    {
  		/* Ignore REP/REPSAL count */;
  		if (!isdigit(*items[1]))
--- 5943,5962 ----
  		    }
  		}
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "FOL", 2) && fol == NULL)
  	    {
  		fol = vim_strsave(items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "LOW", 2) && low == NULL)
  	    {
  		low = vim_strsave(items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "UPP", 2) && upp == NULL)
  	    {
  		upp = vim_strsave(items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "REP", 2)
! 		     || is_aff_rule(items, itemcnt, "REPSAL", 2))
  	    {
  		/* Ignore REP/REPSAL count */;
  		if (!isdigit(*items[1]))
***************
*** 5819,5825 ****
  					 : &spin->si_rep, items[1], items[2]);
  		}
  	    }
! 	    else if (STRCMP(items[0], "MAP") == 0 && itemcnt == 2)
  	    {
  		/* MAP item or count */
  		if (!found_map)
--- 5987,5993 ----
  					 : &spin->si_rep, items[1], items[2]);
  		}
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "MAP", 2))
  	    {
  		/* MAP item or count */
  		if (!found_map)
***************
*** 5856,5864 ****
  		    ga_append(&spin->si_map, '/');
  		}
  	    }
! 	    /* Accept "SAL from to" and "SAL from to # comment". */
! 	    else if (STRCMP(items[0], "SAL") == 0
! 		    && (itemcnt == 3 || (itemcnt > 3 && items[3][0] == '#')))
  	    {
  		if (do_sal)
  		{
--- 6024,6031 ----
  		    ga_append(&spin->si_map, '/');
  		}
  	    }
! 	    /* Accept "SAL from to" and "SAL from to  #comment". */
! 	    else if (is_aff_rule(items, itemcnt, "SAL", 3))
  	    {
  		if (do_sal)
  		{
***************
*** 5877,5888 ****
  								: items[2]);
  		}
  	    }
! 	    else if (STRCMP(items[0], "SOFOFROM") == 0 && itemcnt == 2
  							  && sofofrom == NULL)
  	    {
  		sofofrom = getroom_save(spin, items[1]);
  	    }
! 	    else if (STRCMP(items[0], "SOFOTO") == 0 && itemcnt == 2
  							    && sofoto == NULL)
  	    {
  		sofoto = getroom_save(spin, items[1]);
--- 6044,6055 ----
  								: items[2]);
  		}
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "SOFOFROM", 2)
  							  && sofofrom == NULL)
  	    {
  		sofofrom = getroom_save(spin, items[1]);
  	    }
! 	    else if (is_aff_rule(items, itemcnt, "SOFOTO", 2)
  							    && sofoto == NULL)
  	    {
  		sofoto = getroom_save(spin, items[1]);
***************
*** 6017,6022 ****
--- 6184,6205 ----
  }
  
  /*
+  * Return TRUE when items[0] equals "rulename", there are "mincount" items or
+  * a comment is following after item "mincount".
+  */
+     static int
+ is_aff_rule(items, itemcnt, rulename, mincount)
+     char_u	**items;
+     int		itemcnt;
+     char	*rulename;
+     int		mincount;
+ {
+     return (STRCMP(items[0], rulename) == 0
+ 	    && (itemcnt == mincount
+ 		|| (itemcnt > mincount && items[mincount][0] == '#')));
+ }
+ 
+ /*
   * For affix "entry" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from
   * ae_flags to ae_comppermit and ae_compforbid.
   */
***************
*** 11492,11506 ****
  		    vim_strncpy(preword + sp->ts_prewordlen,
  			    tword + sp->ts_splitoff,
  			    sp->ts_twordlen - sp->ts_splitoff);
! 		    p = preword;
! 		    while (*skiptowhite(p) != NUL)
! 			p = skipwhite(skiptowhite(p));
! 		    if (fword_ends && !can_compound(slang, p,
! 						compflags + sp->ts_compsplit))
! 			/* Compound is not allowed.  But it may still be
! 			 * possible if we add another (short) word. */
  			compound_ok = FALSE;
  
  		    /* Get pointer to last char of previous word. */
  		    p = preword + sp->ts_prewordlen;
  		    mb_ptr_back(preword, p);
--- 11675,11698 ----
  		    vim_strncpy(preword + sp->ts_prewordlen,
  			    tword + sp->ts_splitoff,
  			    sp->ts_twordlen - sp->ts_splitoff);
! 
! 		    /* Verify CHECKCOMPOUNDPATTERN  rules. */
! 		    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,
! 							  &slang->sl_comppat))
  			compound_ok = FALSE;
  
+ 		    if (compound_ok)
+ 		    {
+ 			p = preword;
+ 			while (*skiptowhite(p) != NUL)
+ 			    p = skipwhite(skiptowhite(p));
+ 			if (fword_ends && !can_compound(slang, p,
+ 						compflags + sp->ts_compsplit))
+ 			    /* Compound is not allowed.  But it may still be
+ 			     * possible if we add another (short) word. */
+ 			    compound_ok = FALSE;
+ 		    }
+ 
  		    /* Get pointer to last char of previous word. */
  		    p = preword + sp->ts_prewordlen;
  		    mb_ptr_back(preword, p);
***************
*** 11697,11706 ****
  			&& (slang->sl_compsylmax < MAXWLEN
  			    || sp->ts_complen + 1 - sp->ts_compsplit
  							  < slang->sl_compmax)
! 			&& (byte_in_str(sp->ts_complen == sp->ts_compsplit
! 					    ? slang->sl_compstartflags
! 					    : slang->sl_compallflags,
! 						    ((unsigned)flags >> 24))))
  		{
  		    try_compound = TRUE;
  		    compflags[sp->ts_complen] = ((unsigned)flags >> 24);
--- 11889,11897 ----
  			&& (slang->sl_compsylmax < MAXWLEN
  			    || sp->ts_complen + 1 - sp->ts_compsplit
  							  < slang->sl_compmax)
! 			&& (can_be_compound(sp, slang,
! 					 compflags, ((unsigned)flags >> 24))))
! 
  		{
  		    try_compound = TRUE;
  		    compflags[sp->ts_complen] = ((unsigned)flags >> 24);
*** ../vim-7.2.059/src/version.c	Sun Nov 30 15:15:56 2008
--- src/version.c	Sun Nov 30 21:09:23 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     60,
  /**/

-- 
DEAD PERSON:  I'm getting better!
CUSTOMER:     No, you're not -- you'll be stone dead in a moment.
MORTICIAN:    Oh, I can't take him like that -- it's against regulations.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.061
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.061
Problem:    Can't create a funcref for an autoload function without loading
	    the script first. (Marc Weber)
Solution:   Accept autoload functions that don't exist yet in function().
Files:	    src/eval.c


*** ../vim-7.2.060/src/eval.c	Fri Nov 28 21:26:50 2008
--- src/eval.c	Sat Nov 29 12:28:51 2008
***************
*** 10339,10345 ****
      s = get_tv_string(&argvars[0]);
      if (s == NULL || *s == NUL || VIM_ISDIGIT(*s))
  	EMSG2(_(e_invarg2), s);
!     else if (!function_exists(s))
  	EMSG2(_("E700: Unknown function: %s"), s);
      else
      {
--- 10339,10346 ----
      s = get_tv_string(&argvars[0]);
      if (s == NULL || *s == NUL || VIM_ISDIGIT(*s))
  	EMSG2(_(e_invarg2), s);
!     /* Don't check an autoload name for existence here. */
!     else if (vim_strchr(s, AUTOLOAD_CHAR) == NULL && !function_exists(s))
  	EMSG2(_("E700: Unknown function: %s"), s);
      else
      {
*** ../vim-7.2.060/src/version.c	Sun Nov 30 21:11:54 2008
--- src/version.c	Wed Dec  3 09:49:07 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     61,
  /**/

-- 
There are 2 kinds of people in my world: those who know Unix, Perl, Vim, GNU,
Linux, etc, and those who know COBOL.  It gets very difficult for me at
parties, not knowing which group to socialise with :-)
						Sitaram Chamarty

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.062
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.062
Problem:    "[Scratch]" is not translated.
Solution:   Mark the string for translation. (Dominique Pelle)
Files:	    src/buffer.c


*** ../vim-7.2.061/src/buffer.c	Sat Nov 15 16:05:30 2008
--- src/buffer.c	Tue Dec  2 21:51:02 2008
***************
*** 5118,5124 ****
      {
  	if (buf->b_sfname != NULL)
  	    return (char *)buf->b_sfname;
! 	return "[Scratch]";
      }
  #endif
      if (buf->b_fname == NULL)
--- 5118,5124 ----
      {
  	if (buf->b_sfname != NULL)
  	    return (char *)buf->b_sfname;
! 	return _("[Scratch]");
      }
  #endif
      if (buf->b_fname == NULL)
*** ../vim-7.2.061/src/version.c	Wed Dec  3 09:51:19 2008
--- src/version.c	Wed Dec  3 11:20:30 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     62,
  /**/

-- 
DENNIS:  Listen -- strange women lying in ponds distributing swords is no
         basis for a system of government.  Supreme executive power derives
         from a mandate from the masses, not from some farcical aquatic
         ceremony.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.063
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.063
Problem:    Warning for NULL argument of Perl_sys_init3().
Solution:   Use Perl_sys_init() instead. (partly by Dominique Pelle)
Files:	    src/if_perl.xs


*** ../vim-7.2.062/src/if_perl.xs	Mon Sep  1 17:56:05 2008
--- src/if_perl.xs	Wed Dec  3 12:44:38 2008
***************
*** 166,172 ****
  # define Perl_Isv_yes_ptr dll_Perl_Isv_yes_ptr
  # define boot_DynaLoader dll_boot_DynaLoader
  
! # define Perl_sys_init3 dll_Perl_sys_init3
  # define Perl_sys_term dll_Perl_sys_term
  # define Perl_ISv_ptr dll_Perl_ISv_ptr
  # define Perl_Istack_max_ptr dll_Perl_Istack_max_ptr
--- 166,172 ----
  # define Perl_Isv_yes_ptr dll_Perl_Isv_yes_ptr
  # define boot_DynaLoader dll_boot_DynaLoader
  
! # define Perl_sys_init dll_Perl_sys_init
  # define Perl_sys_term dll_Perl_sys_term
  # define Perl_ISv_ptr dll_Perl_ISv_ptr
  # define Perl_Istack_max_ptr dll_Perl_Istack_max_ptr
***************
*** 272,278 ****
  
  #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
  static void (*Perl_sv_free2)(pTHX_ SV*);
! static void (*Perl_sys_init3)(int* argc, char*** argv, char*** env);
  static void (*Perl_sys_term)(void);
  static SV** (*Perl_ISv_ptr)(register PerlInterpreter*);
  static SV*** (*Perl_Istack_max_ptr)(register PerlInterpreter*);
--- 272,278 ----
  
  #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
  static void (*Perl_sv_free2)(pTHX_ SV*);
! static void (*Perl_sys_init)(int* argc, char*** argv);
  static void (*Perl_sys_term)(void);
  static SV** (*Perl_ISv_ptr)(register PerlInterpreter*);
  static SV*** (*Perl_Istack_max_ptr)(register PerlInterpreter*);
***************
*** 372,378 ****
      {"Perl_Tna_ptr", (PERL_PROC*)&Perl_Tna_ptr},
  #else
      {"Perl_sv_free2", (PERL_PROC*)&Perl_sv_free2},
!     {"Perl_sys_init3", (PERL_PROC*)&Perl_sys_init3},
      {"Perl_sys_term", (PERL_PROC*)&Perl_sys_term},
      {"Perl_ISv_ptr", (PERL_PROC*)&Perl_ISv_ptr},
      {"Perl_Istack_sp_ptr", (PERL_PROC*)&Perl_Istack_sp_ptr},
--- 372,378 ----
      {"Perl_Tna_ptr", (PERL_PROC*)&Perl_Tna_ptr},
  #else
      {"Perl_sv_free2", (PERL_PROC*)&Perl_sv_free2},
!     {"Perl_sys_init", (PERL_PROC*)&Perl_sys_init},
      {"Perl_sys_term", (PERL_PROC*)&Perl_sys_term},
      {"Perl_ISv_ptr", (PERL_PROC*)&Perl_ISv_ptr},
      {"Perl_Istack_sp_ptr", (PERL_PROC*)&Perl_Istack_sp_ptr},
***************
*** 460,466 ****
      static char *argv[] = { "", "-e", "" };
  
  #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
!     Perl_sys_init3(&argc, (char***)&argv, NULL);
  #endif
      perl_interp = perl_alloc();
      perl_construct(perl_interp);
--- 460,466 ----
      static char *argv[] = { "", "-e", "" };
  
  #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
!     Perl_sys_init(&argc, (char***)&argv);
  #endif
      perl_interp = perl_alloc();
      perl_construct(perl_interp);
*** ../vim-7.2.062/src/version.c	Wed Dec  3 11:21:20 2008
--- src/version.c	Wed Dec  3 12:42:50 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     63,
  /**/

-- 
Windows
M!uqoms

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.064
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.064
Problem:    Screen update bug when repeating "~" on a Visual block and the
	    last line doesn't change.
Solution:   Keep track of changes for all lines.  (Moritz Orbach)
Files:	    src/ops.c


*** ../vim-7.2.063/src/ops.c	Tue Jun 24 23:59:55 2008
--- src/ops.c	Wed Dec  3 13:12:06 2008
***************
*** 2209,2220 ****
      {
  	for (; pos.lnum <= oap->end.lnum; ++pos.lnum)
  	{
  	    block_prep(oap, &bd, pos.lnum, FALSE);
  	    pos.col = bd.textcol;
! 	    did_change = swapchars(oap->op_type, &pos, bd.textlen);
  
  # ifdef FEAT_NETBEANS_INTG
! 	    if (usingNetbeans && did_change)
  	    {
  		char_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);
  
--- 2209,2223 ----
      {
  	for (; pos.lnum <= oap->end.lnum; ++pos.lnum)
  	{
+ 	    int one_change;
+ 
  	    block_prep(oap, &bd, pos.lnum, FALSE);
  	    pos.col = bd.textcol;
! 	    one_change = swapchars(oap->op_type, &pos, bd.textlen);
! 	    did_change |= one_change;
  
  # ifdef FEAT_NETBEANS_INTG
! 	    if (usingNetbeans && one_change)
  	    {
  		char_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);
  
*** ../vim-7.2.063/src/version.c	Wed Dec  3 13:18:16 2008
--- src/version.c	Wed Dec  3 13:14:46 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     64,
  /**/

-- 
Q:   How many hardware engineers does it take to change a lightbulb?
A:   None.  We'll fix it in software.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.065
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.065
Problem:    GTK GUI: the cursor disappears when doing ":vsp" and the Vim
	    window is maximized.  (Dominique Pelle, Denis Smolyar)
Solution:   Don't change "Columns" back to an old value at a wrong moment.
	    Do change "Rows" when it should not be a problem.
Files:	    src/gui.c


*** ../vim-7.2.064/src/gui.c	Fri Nov 28 21:26:50 2008
--- src/gui.c	Wed Dec  3 18:01:21 2008
***************
*** 3241,3247 ****
  	    i = Rows;
  	    gui_update_tabline();
  	    Rows = i;
! 	    need_set_size = RESIZE_VERT;
  	    if (using_tabline)
  		fix_size = TRUE;
  	    if (!gui_use_tabline())
--- 3241,3247 ----
  	    i = Rows;
  	    gui_update_tabline();
  	    Rows = i;
! 	    need_set_size |= RESIZE_VERT;
  	    if (using_tabline)
  		fix_size = TRUE;
  	    if (!gui_use_tabline())
***************
*** 3275,3283 ****
  		if (gui.which_scrollbars[i] != prev_which_scrollbars[i])
  		{
  		    if (i == SBAR_BOTTOM)
! 			need_set_size = RESIZE_VERT;
  		    else
! 			need_set_size = RESIZE_HOR;
  		    if (gui.which_scrollbars[i])
  			fix_size = TRUE;
  		}
--- 3275,3283 ----
  		if (gui.which_scrollbars[i] != prev_which_scrollbars[i])
  		{
  		    if (i == SBAR_BOTTOM)
! 			need_set_size |= RESIZE_VERT;
  		    else
! 			need_set_size |= RESIZE_HOR;
  		    if (gui.which_scrollbars[i])
  			fix_size = TRUE;
  		}
***************
*** 3297,3303 ****
  	    gui_mch_enable_menu(gui.menu_is_active);
  	    Rows = i;
  	    prev_menu_is_active = gui.menu_is_active;
! 	    need_set_size = RESIZE_VERT;
  	    if (gui.menu_is_active)
  		fix_size = TRUE;
  	}
--- 3297,3303 ----
  	    gui_mch_enable_menu(gui.menu_is_active);
  	    Rows = i;
  	    prev_menu_is_active = gui.menu_is_active;
! 	    need_set_size |= RESIZE_VERT;
  	    if (gui.menu_is_active)
  		fix_size = TRUE;
  	}
***************
*** 3308,3314 ****
  	{
  	    gui_mch_show_toolbar(using_toolbar);
  	    prev_toolbar = using_toolbar;
! 	    need_set_size = RESIZE_VERT;
  	    if (using_toolbar)
  		fix_size = TRUE;
  	}
--- 3308,3314 ----
  	{
  	    gui_mch_show_toolbar(using_toolbar);
  	    prev_toolbar = using_toolbar;
! 	    need_set_size |= RESIZE_VERT;
  	    if (using_toolbar)
  		fix_size = TRUE;
  	}
***************
*** 3318,3324 ****
  	{
  	    gui_mch_enable_footer(using_footer);
  	    prev_footer = using_footer;
! 	    need_set_size = RESIZE_VERT;
  	    if (using_footer)
  		fix_size = TRUE;
  	}
--- 3318,3324 ----
  	{
  	    gui_mch_enable_footer(using_footer);
  	    prev_footer = using_footer;
! 	    need_set_size |= RESIZE_VERT;
  	    if (using_footer)
  		fix_size = TRUE;
  	}
***************
*** 3330,3339 ****
  	    prev_tearoff = using_tearoff;
  	}
  #endif
! 	if (need_set_size)
  	{
  #ifdef FEAT_GUI_GTK
! 	    long    c = Columns;
  #endif
  	    /* Adjust the size of the window to make the text area keep the
  	     * same size and to avoid that part of our window is off-screen
--- 3330,3340 ----
  	    prev_tearoff = using_tearoff;
  	}
  #endif
! 	if (need_set_size != 0)
  	{
  #ifdef FEAT_GUI_GTK
! 	    long    prev_Columns = Columns;
! 	    long    prev_Rows = Rows;
  #endif
  	    /* Adjust the size of the window to make the text area keep the
  	     * same size and to avoid that part of our window is off-screen
***************
*** 3349,3359 ****
  	     * If you remove this, please test this command for resizing
  	     * effects (with optional left scrollbar): ":vsp|q|vsp|q|vsp|q".
  	     * Don't do this while starting up though.
! 	     * And don't change Rows, it may have be reduced intentionally
! 	     * when adding menu/toolbar/tabline. */
! 	    if (!gui.starting)
  		(void)char_avail();
! 	    Columns = c;
  #endif
  	}
  #ifdef FEAT_WINDOWS
--- 3350,3363 ----
  	     * If you remove this, please test this command for resizing
  	     * effects (with optional left scrollbar): ":vsp|q|vsp|q|vsp|q".
  	     * Don't do this while starting up though.
! 	     * Don't change Rows when adding menu/toolbar/tabline.
! 	     * Don't change Columns when adding vertical toolbar. */
! 	    if (!gui.starting && need_set_size != (RESIZE_VERT | RESIZE_HOR))
  		(void)char_avail();
! 	    if ((need_set_size & RESIZE_VERT) == 0)
! 		Rows = prev_Rows;
! 	    if ((need_set_size & RESIZE_HOR) == 0)
! 		Columns = prev_Columns;
  #endif
  	}
  #ifdef FEAT_WINDOWS
*** ../vim-7.2.064/src/version.c	Wed Dec  3 13:38:00 2008
--- src/version.c	Wed Dec  3 18:47:11 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     65,
  /**/

-- 
Seen on the back of a biker's vest: If you can read this, my wife fell off.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.066
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.066
Problem:    It's not easy to see whether 'encoding' is a multi-byte encoding.
Solution:   Add has('multi_byte_encoding').
Files:	    runtime/doc/eval.txt, src/eval.c


*** ../vim-7.2.065/runtime/doc/eval.txt	Fri Nov 28 11:15:10 2008
--- runtime/doc/eval.txt	Tue Dec  9 10:55:59 2008
***************
*** 5841,5847 ****
  mouse_pterm		Compiled with support for qnx pterm mouse.
  mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
  mouse_xterm		Compiled with support for xterm mouse.
! multi_byte		Compiled with support for editing Korean et al.
  multi_byte_ime		Compiled with support for IME input method.
  multi_lang		Compiled with support for multiple languages.
  mzscheme		Compiled with MzScheme interface |mzscheme|.
--- 5852,5859 ----
  mouse_pterm		Compiled with support for qnx pterm mouse.
  mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
  mouse_xterm		Compiled with support for xterm mouse.
! multi_byte		Compiled with support for 'encoding'
! multi_byte_encoding	'encoding' is set to a multi-byte encoding.
  multi_byte_ime		Compiled with support for IME input method.
  multi_lang		Compiled with support for multiple languages.
  mzscheme		Compiled with MzScheme interface |mzscheme|.
*** ../vim-7.2.065/src/eval.c	Wed Dec  3 09:51:19 2008
--- src/eval.c	Wed Dec  3 14:29:09 2008
***************
*** 11842,11847 ****
--- 11842,11851 ----
  	    n = has_patch(atoi((char *)name + 5));
  	else if (STRICMP(name, "vim_starting") == 0)
  	    n = (starting != 0);
+ #ifdef FEAT_MBYTE
+ 	else if (STRICMP(name, "multi_byte_encoding") == 0)
+ 	    n = has_mbyte;
+ #endif
  #if defined(FEAT_BEVAL) && defined(FEAT_GUI_W32)
  	else if (STRICMP(name, "balloon_multiline") == 0)
  	    n = multiline_balloon_available();
*** ../vim-7.2.065/src/version.c	Wed Dec  3 18:50:09 2008
--- src/version.c	Tue Dec  9 10:48:49 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     66,
  /**/

-- 
ARTHUR: Listen, old crone!  Unless you tell us where we can buy a shrubbery,
        my friend and I will ... we will say "Ni!"
CRONE:  Do your worst!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.067
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.067
Problem:    Session file can't load extra file when the path contains special
	    characters.
Solution:   Escape the file name. (Lech Lorens)
Files:	    src/ex_docmd.c


*** ../vim-7.2.066/src/ex_docmd.c	Fri Nov 28 21:26:50 2008
--- src/ex_docmd.c	Fri Dec  5 21:34:11 2008
***************
*** 10106,10112 ****
       */
      if (put_line(fd, "let s:sx = expand(\"<sfile>:p:r\").\"x.vim\"") == FAIL
  	    || put_line(fd, "if file_readable(s:sx)") == FAIL
! 	    || put_line(fd, "  exe \"source \" . s:sx") == FAIL
  	    || put_line(fd, "endif") == FAIL)
  	return FAIL;
  
--- 10106,10112 ----
       */
      if (put_line(fd, "let s:sx = expand(\"<sfile>:p:r\").\"x.vim\"") == FAIL
  	    || put_line(fd, "if file_readable(s:sx)") == FAIL
! 	    || put_line(fd, "  exe \"source \" . fnameescape(s:sx)") == FAIL
  	    || put_line(fd, "endif") == FAIL)
  	return FAIL;
  
*** ../vim-7.2.066/src/version.c	Tue Dec  9 10:56:50 2008
--- src/version.c	Tue Dec  9 11:16:27 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     67,
  /**/

-- 
Life is a gift, living is an art.		(Bram Moolenaar)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.068
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.068
Problem:    Emacs tags file lines can be too long, resulting in an error
	    message. (James Vega)
Solution:   Ignore lines with errors if they are too long.
Files:	    src/tag.c


*** ../vim-7.2.067/src/tag.c	Fri Jul 18 11:26:12 2008
--- src/tag.c	Sat Dec  6 13:54:33 2008
***************
*** 2725,2731 ****
--- 2725,2748 ----
  	 */
  	p_7f = vim_strchr(lbuf, 0x7f);
  	if (p_7f == NULL)
+ 	{
+ etag_fail:
+ 	    if (vim_strchr(lbuf, '\n') == NULL)
+ 	    {
+ 		/* Truncated line.  Ignore it. */
+ 		if (p_verbose >= 5)
+ 		{
+ 		    verbose_enter();
+ 		    MSG(_("Ignoring long line in tags file"));
+ 		    verbose_leave();
+ 		}
+ 		tagp->command = lbuf;
+ 		tagp->tagname = lbuf;
+ 		tagp->tagname_end = lbuf;
+ 		return OK;
+ 	    }
  	    return FAIL;
+ 	}
  
  	/* Find ^A.  If not found the line number is after the 0x7f */
  	p = vim_strchr(p_7f, Ctrl_A);
***************
*** 2735,2741 ****
  	    ++p;
  
  	if (!VIM_ISDIGIT(*p))	    /* check for start of line number */
! 	    return FAIL;
  	tagp->command = p;
  
  
--- 2752,2758 ----
  	    ++p;
  
  	if (!VIM_ISDIGIT(*p))	    /* check for start of line number */
! 	    goto etag_fail;
  	tagp->command = p;
  
  
***************
*** 2749,2755 ****
  	    /* find end of tagname */
  	    for (p = p_7f - 1; !vim_iswordc(*p); --p)
  		if (p == lbuf)
! 		    return FAIL;
  	    tagp->tagname_end = p + 1;
  	    while (p >= lbuf && vim_iswordc(*p))
  		--p;
--- 2766,2772 ----
  	    /* find end of tagname */
  	    for (p = p_7f - 1; !vim_iswordc(*p); --p)
  		if (p == lbuf)
! 		    goto etag_fail;
  	    tagp->tagname_end = p + 1;
  	    while (p >= lbuf && vim_iswordc(*p))
  		--p;
*** ../vim-7.2.067/src/version.c	Tue Dec  9 11:17:23 2008
--- src/version.c	Tue Dec  9 12:05:41 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     68,
  /**/

-- 
Q: What do you call a fish without an eye?
A: fsh!
Q: What do you call a deer with no eyes?
A: no eye deer.
Q: What do you call a deer with no eyes and no legs?
A: still no eye deer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.069
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.069 (after 7.2.060)
Problem:    Compiler warning for storing size_t in int.
Solution:   Add type cast.
Files:      src/spell.c


*** ../vim-7.2.068/src/spell.c	Sun Nov 30 21:11:54 2008
--- src/spell.c	Tue Dec  9 22:19:04 2008
***************
*** 1765,1771 ****
  	    /* Second part matches at start of following compound word, now
  	     * check if first part matches at end of previous word. */
  	    p = ((char_u **)gap->ga_data)[i];
! 	    len = STRLEN(p);
  	    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)
  		return TRUE;
  	}
--- 1765,1771 ----
  	    /* Second part matches at start of following compound word, now
  	     * check if first part matches at end of previous word. */
  	    p = ((char_u **)gap->ga_data)[i];
! 	    len = (int)STRLEN(p);
  	    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)
  		return TRUE;
  	}
*** ../vim-7.2.068/src/version.c	Tue Dec  9 12:12:31 2008
--- src/version.c	Tue Dec  9 22:21:15 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     69,
  /**/

-- 
The war between Emacs and Vi is over.  Vi has won with 3 to 1.
			http://www.ssc.com/lg/issue30/raymond.html

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.070
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.070
Problem:    Crash when a function returns a:000. (Matt Wozkiski)
Solution:   Don't put the function struct on the stack, allocate it.  Free it
	    only when nothing in it is used.
Files:	    src/eval.c


*** ../vim-7.2.069/src/eval.c	Tue Dec  9 10:56:50 2008
--- src/eval.c	Wed Dec 17 21:32:26 2008
***************
*** 32,37 ****
--- 32,40 ----
  
  #define DICT_MAXNEST 100	/* maximum nesting of lists and dicts */
  
+ #define DO_NOT_FREE_CNT 99999	/* refcount for dict or list that should not
+ 				   be freed. */
+ 
  /*
   * In a hashtab item "hi_key" points to "di_key" in a dictitem.
   * This avoids adding a pointer to the hashtab item.
***************
*** 789,794 ****
--- 792,799 ----
  static void func_unref __ARGS((char_u *name));
  static void func_ref __ARGS((char_u *name));
  static void call_user_func __ARGS((ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, linenr_T firstline, linenr_T lastline, dict_T *selfdict));
+ static int can_free_funccal __ARGS((funccall_T *fc, int copyID)) ;
+ static void free_funccal __ARGS((funccall_T *fc, int free_val));
  static void add_nr_var __ARGS((dict_T *dp, dictitem_T *v, char *name, varnumber_T nr));
  static win_T *find_win_by_nr __ARGS((typval_T *vp, tabpage_T *tp));
  static void getwinvar __ARGS((typval_T *argvars, typval_T *rettv, int off));
***************
*** 923,928 ****
--- 928,937 ----
  /* pointer to funccal for currently active function */
  funccall_T *current_funccal = NULL;
  
+ /* pointer to list of previously used funccal, still around because some
+  * item in it is still being used. */
+ funccall_T *previous_funccal = NULL;
+ 
  /*
   * Return TRUE when a function was ended by a ":return" command.
   */
***************
*** 6490,6496 ****
      buf_T	*buf;
      win_T	*wp;
      int		i;
!     funccall_T	*fc;
      int		did_free = FALSE;
  #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
--- 6499,6505 ----
      buf_T	*buf;
      win_T	*wp;
      int		i;
!     funccall_T	*fc, **pfc;
      int		did_free = FALSE;
  #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
***************
*** 6574,6579 ****
--- 6583,6602 ----
  	else
  	    ll = ll->lv_used_next;
  
+     /* check if any funccal can be freed now */
+     for (pfc = &previous_funccal; *pfc != NULL; )
+     {
+ 	if (can_free_funccal(*pfc, copyID))
+ 	{
+ 	    fc = *pfc;
+ 	    *pfc = fc->caller;
+ 	    free_funccal(fc, TRUE);
+ 	    did_free = TRUE;
+ 	}
+ 	else
+ 	    pfc = &(*pfc)->caller;
+     }
+ 
      return did_free;
  }
  
***************
*** 18962,18968 ****
      dictitem_T	*dict_var;
  {
      hash_init(&dict->dv_hashtab);
!     dict->dv_refcount = 99999;
      dict_var->di_tv.vval.v_dict = dict;
      dict_var->di_tv.v_type = VAR_DICT;
      dict_var->di_tv.v_lock = VAR_FIXED;
--- 18985,18991 ----
      dictitem_T	*dict_var;
  {
      hash_init(&dict->dv_hashtab);
!     dict->dv_refcount = DO_NOT_FREE_CNT;
      dict_var->di_tv.vval.v_dict = dict;
      dict_var->di_tv.v_type = VAR_DICT;
      dict_var->di_tv.v_lock = VAR_FIXED;
***************
*** 19299,19304 ****
--- 19322,19329 ----
   * Copy the values from typval_T "from" to typval_T "to".
   * When needed allocates string or increases reference count.
   * Does not make a copy of a list or dict but copies the reference!
+  * It is OK for "from" and "to" to point to the same item.  This is used to
+  * make a copy later.
   */
      static void
  copy_tv(from, to)
***************
*** 21111,21117 ****
      char_u	*save_sourcing_name;
      linenr_T	save_sourcing_lnum;
      scid_T	save_current_SID;
!     funccall_T	fc;
      int		save_did_emsg;
      static int	depth = 0;
      dictitem_T	*v;
--- 21136,21142 ----
      char_u	*save_sourcing_name;
      linenr_T	save_sourcing_lnum;
      scid_T	save_current_SID;
!     funccall_T	*fc;
      int		save_did_emsg;
      static int	depth = 0;
      dictitem_T	*v;
***************
*** 21137,21172 ****
  
      line_breakcheck();		/* check for CTRL-C hit */
  
!     fc.caller = current_funccal;
!     current_funccal = &fc;
!     fc.func = fp;
!     fc.rettv = rettv;
      rettv->vval.v_number = 0;
!     fc.linenr = 0;
!     fc.returned = FALSE;
!     fc.level = ex_nesting_level;
      /* Check if this function has a breakpoint. */
!     fc.breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);
!     fc.dbg_tick = debug_tick;
  
      /*
!      * Note about using fc.fixvar[]: This is an array of FIXVAR_CNT variables
       * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free
       * each argument variable and saves a lot of time.
       */
      /*
       * Init l: variables.
       */
!     init_var_dict(&fc.l_vars, &fc.l_vars_var);
      if (selfdict != NULL)
      {
  	/* Set l:self to "selfdict".  Use "name" to avoid a warning from
  	 * some compiler that checks the destination size. */
! 	v = &fc.fixvar[fixvar_idx++].var;
  	name = v->di_key;
  	STRCPY(name, "self");
  	v->di_flags = DI_FLAGS_RO + DI_FLAGS_FIX;
! 	hash_add(&fc.l_vars.dv_hashtab, DI2HIKEY(v));
  	v->di_tv.v_type = VAR_DICT;
  	v->di_tv.v_lock = 0;
  	v->di_tv.vval.v_dict = selfdict;
--- 21162,21198 ----
  
      line_breakcheck();		/* check for CTRL-C hit */
  
!     fc = (funccall_T *)alloc(sizeof(funccall_T));
!     fc->caller = current_funccal;
!     current_funccal = fc;
!     fc->func = fp;
!     fc->rettv = rettv;
      rettv->vval.v_number = 0;
!     fc->linenr = 0;
!     fc->returned = FALSE;
!     fc->level = ex_nesting_level;
      /* Check if this function has a breakpoint. */
!     fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);
!     fc->dbg_tick = debug_tick;
  
      /*
!      * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables
       * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free
       * each argument variable and saves a lot of time.
       */
      /*
       * Init l: variables.
       */
!     init_var_dict(&fc->l_vars, &fc->l_vars_var);
      if (selfdict != NULL)
      {
  	/* Set l:self to "selfdict".  Use "name" to avoid a warning from
  	 * some compiler that checks the destination size. */
! 	v = &fc->fixvar[fixvar_idx++].var;
  	name = v->di_key;
  	STRCPY(name, "self");
  	v->di_flags = DI_FLAGS_RO + DI_FLAGS_FIX;
! 	hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));
  	v->di_tv.v_type = VAR_DICT;
  	v->di_tv.v_lock = 0;
  	v->di_tv.vval.v_dict = selfdict;
***************
*** 21178,21208 ****
       * Set a:0 to "argcount".
       * Set a:000 to a list with room for the "..." arguments.
       */
!     init_var_dict(&fc.l_avars, &fc.l_avars_var);
!     add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "0",
  				(varnumber_T)(argcount - fp->uf_args.ga_len));
      /* Use "name" to avoid a warning from some compiler that checks the
       * destination size. */
!     v = &fc.fixvar[fixvar_idx++].var;
      name = v->di_key;
      STRCPY(name, "000");
      v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
!     hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
      v->di_tv.v_type = VAR_LIST;
      v->di_tv.v_lock = VAR_FIXED;
!     v->di_tv.vval.v_list = &fc.l_varlist;
!     vim_memset(&fc.l_varlist, 0, sizeof(list_T));
!     fc.l_varlist.lv_refcount = 99999;
!     fc.l_varlist.lv_lock = VAR_FIXED;
  
      /*
       * Set a:firstline to "firstline" and a:lastline to "lastline".
       * Set a:name to named arguments.
       * Set a:N to the "..." arguments.
       */
!     add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "firstline",
  						      (varnumber_T)firstline);
!     add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "lastline",
  						       (varnumber_T)lastline);
      for (i = 0; i < argcount; ++i)
      {
--- 21204,21234 ----
       * Set a:0 to "argcount".
       * Set a:000 to a list with room for the "..." arguments.
       */
!     init_var_dict(&fc->l_avars, &fc->l_avars_var);
!     add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "0",
  				(varnumber_T)(argcount - fp->uf_args.ga_len));
      /* Use "name" to avoid a warning from some compiler that checks the
       * destination size. */
!     v = &fc->fixvar[fixvar_idx++].var;
      name = v->di_key;
      STRCPY(name, "000");
      v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
!     hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));
      v->di_tv.v_type = VAR_LIST;
      v->di_tv.v_lock = VAR_FIXED;
!     v->di_tv.vval.v_list = &fc->l_varlist;
!     vim_memset(&fc->l_varlist, 0, sizeof(list_T));
!     fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;
!     fc->l_varlist.lv_lock = VAR_FIXED;
  
      /*
       * Set a:firstline to "firstline" and a:lastline to "lastline".
       * Set a:name to named arguments.
       * Set a:N to the "..." arguments.
       */
!     add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "firstline",
  						      (varnumber_T)firstline);
!     add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "lastline",
  						       (varnumber_T)lastline);
      for (i = 0; i < argcount; ++i)
      {
***************
*** 21218,21224 ****
  	}
  	if (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)
  	{
! 	    v = &fc.fixvar[fixvar_idx++].var;
  	    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
  	}
  	else
--- 21244,21250 ----
  	}
  	if (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)
  	{
! 	    v = &fc->fixvar[fixvar_idx++].var;
  	    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
  	}
  	else
***************
*** 21230,21236 ****
  	    v->di_flags = DI_FLAGS_RO;
  	}
  	STRCPY(v->di_key, name);
! 	hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
  
  	/* Note: the values are copied directly to avoid alloc/free.
  	 * "argvars" must have VAR_FIXED for v_lock. */
--- 21256,21262 ----
  	    v->di_flags = DI_FLAGS_RO;
  	}
  	STRCPY(v->di_key, name);
! 	hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));
  
  	/* Note: the values are copied directly to avoid alloc/free.
  	 * "argvars" must have VAR_FIXED for v_lock. */
***************
*** 21239,21247 ****
  
  	if (ai >= 0 && ai < MAX_FUNC_ARGS)
  	{
! 	    list_append(&fc.l_varlist, &fc.l_listitems[ai]);
! 	    fc.l_listitems[ai].li_tv = argvars[i];
! 	    fc.l_listitems[ai].li_tv.v_lock = VAR_FIXED;
  	}
      }
  
--- 21265,21273 ----
  
  	if (ai >= 0 && ai < MAX_FUNC_ARGS)
  	{
! 	    list_append(&fc->l_varlist, &fc->l_listitems[ai]);
! 	    fc->l_listitems[ai].li_tv = argvars[i];
! 	    fc->l_listitems[ai].li_tv.v_lock = VAR_FIXED;
  	}
      }
  
***************
*** 21306,21312 ****
  	if (!fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL))
  	    func_do_profile(fp);
  	if (fp->uf_profiling
! 		       || (fc.caller != NULL && fc.caller->func->uf_profiling))
  	{
  	    ++fp->uf_tm_count;
  	    profile_start(&call_start);
--- 21332,21338 ----
  	if (!fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL))
  	    func_do_profile(fp);
  	if (fp->uf_profiling
! 		    || (fc->caller != NULL && fc->caller->func->uf_profiling))
  	{
  	    ++fp->uf_tm_count;
  	    profile_start(&call_start);
***************
*** 21322,21328 ****
      did_emsg = FALSE;
  
      /* call do_cmdline() to execute the lines */
!     do_cmdline(NULL, get_func_line, (void *)&fc,
  				     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);
  
      --RedrawingDisabled;
--- 21348,21354 ----
      did_emsg = FALSE;
  
      /* call do_cmdline() to execute the lines */
!     do_cmdline(NULL, get_func_line, (void *)fc,
  				     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);
  
      --RedrawingDisabled;
***************
*** 21337,21352 ****
  
  #ifdef FEAT_PROFILE
      if (do_profiling == PROF_YES && (fp->uf_profiling
! 		    || (fc.caller != NULL && fc.caller->func->uf_profiling)))
      {
  	profile_end(&call_start);
  	profile_sub_wait(&wait_start, &call_start);
  	profile_add(&fp->uf_tm_total, &call_start);
  	profile_self(&fp->uf_tm_self, &call_start, &fp->uf_tm_children);
! 	if (fc.caller != NULL && fc.caller->func->uf_profiling)
  	{
! 	    profile_add(&fc.caller->func->uf_tm_children, &call_start);
! 	    profile_add(&fc.caller->func->uf_tml_children, &call_start);
  	}
      }
  #endif
--- 21363,21378 ----
  
  #ifdef FEAT_PROFILE
      if (do_profiling == PROF_YES && (fp->uf_profiling
! 		    || (fc->caller != NULL && fc->caller->func->uf_profiling)))
      {
  	profile_end(&call_start);
  	profile_sub_wait(&wait_start, &call_start);
  	profile_add(&fp->uf_tm_total, &call_start);
  	profile_self(&fp->uf_tm_self, &call_start, &fp->uf_tm_children);
! 	if (fc->caller != NULL && fc->caller->func->uf_profiling)
  	{
! 	    profile_add(&fc->caller->func->uf_tm_children, &call_start);
! 	    profile_add(&fc->caller->func->uf_tml_children, &call_start);
  	}
      }
  #endif
***************
*** 21359,21367 ****
  
  	if (aborting())
  	    smsg((char_u *)_("%s aborted"), sourcing_name);
! 	else if (fc.rettv->v_type == VAR_NUMBER)
  	    smsg((char_u *)_("%s returning #%ld"), sourcing_name,
! 					       (long)fc.rettv->vval.v_number);
  	else
  	{
  	    char_u	buf[MSG_BUF_LEN];
--- 21385,21393 ----
  
  	if (aborting())
  	    smsg((char_u *)_("%s aborted"), sourcing_name);
! 	else if (fc->rettv->v_type == VAR_NUMBER)
  	    smsg((char_u *)_("%s returning #%ld"), sourcing_name,
! 					       (long)fc->rettv->vval.v_number);
  	else
  	{
  	    char_u	buf[MSG_BUF_LEN];
***************
*** 21372,21378 ****
  	    /* The value may be very long.  Skip the middle part, so that we
  	     * have some idea how it starts and ends. smsg() would always
  	     * truncate it at the end. */
! 	    s = tv2string(fc.rettv, &tofree, numbuf2, 0);
  	    if (s != NULL)
  	    {
  		trunc_string(s, buf, MSG_BUF_CLEN);
--- 21398,21404 ----
  	    /* The value may be very long.  Skip the middle part, so that we
  	     * have some idea how it starts and ends. smsg() would always
  	     * truncate it at the end. */
! 	    s = tv2string(fc->rettv, &tofree, numbuf2, 0);
  	    if (s != NULL)
  	    {
  		trunc_string(s, buf, MSG_BUF_CLEN);
***************
*** 21408,21421 ****
      }
  
      did_emsg |= save_did_emsg;
!     current_funccal = fc.caller;
  
!     /* The a: variables typevals were not allocated, only free the allocated
!      * variables. */
!     vars_clear_ext(&fc.l_avars.dv_hashtab, FALSE);
  
!     vars_clear(&fc.l_vars.dv_hashtab);		/* free all l: variables */
!     --depth;
  }
  
  /*
--- 21434,21517 ----
      }
  
      did_emsg |= save_did_emsg;
!     current_funccal = fc->caller;
!     --depth;
  
!     /* if the a:000 list and the a: dict are not referenced we can free the
!      * funccall_T and what's in it. */
!     if (fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT
! 	    && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT
! 	    && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)
!     {
! 	free_funccal(fc, FALSE);
!     }
!     else
!     {
! 	hashitem_T	*hi;
! 	listitem_T	*li;
! 	int		todo;
  
! 	/* "fc" is still in use.  This can happen when returning "a:000" or
! 	 * assigning "l:" to a global variable.
! 	 * Link "fc" in the list for garbage collection later. */
! 	fc->caller = previous_funccal;
! 	previous_funccal = fc;
! 
! 	/* Make a copy of the a: variables, since we didn't do that above. */
! 	todo = (int)fc->l_avars.dv_hashtab.ht_used;
! 	for (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)
! 	{
! 	    if (!HASHITEM_EMPTY(hi))
! 	    {
! 		--todo;
! 		v = HI2DI(hi);
! 		copy_tv(&v->di_tv, &v->di_tv);
! 	    }
! 	}
! 
! 	/* Make a copy of the a:000 items, since we didn't do that above. */
! 	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
! 	    copy_tv(&li->li_tv, &li->li_tv);
!     }
! }
! 
! /*
!  * Return TRUE if items in "fc" do not have "copyID".  That means they are not
!  * referenced from anywyere.
!  */
!     static int
! can_free_funccal(fc, copyID)
!     funccall_T	*fc;
!     int		copyID;
! {
!     return (fc->l_varlist.lv_copyID != copyID
! 	    && fc->l_vars.dv_copyID != copyID
! 	    && fc->l_avars.dv_copyID != copyID);
! }
! 
! /*
!  * Free "fc" and what it contains.
!  */
!    static void
! free_funccal(fc, free_val)
!     funccall_T	*fc;
!     int		free_val;  /* a: vars were allocated */
! {
!     listitem_T	*li;
! 
!     /* The a: variables typevals may not have been allocated, only free the
!      * allocated variables. */
!     vars_clear_ext(&fc->l_avars.dv_hashtab, free_val);
! 
!     /* free all l: variables */
!     vars_clear(&fc->l_vars.dv_hashtab);
! 
!     /* Free the a:000 variables if they were allocated. */
!     if (free_val)
! 	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
! 	    clear_tv(&li->li_tv);
! 
!     vim_free(fc);
  }
  
  /*
*** ../vim-7.2.069/src/version.c	Tue Dec  9 22:34:02 2008
--- src/version.c	Sun Dec 21 12:47:07 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     70,
  /**/

-- 
Close your shells, or I'll kill -9 you
Tomorrow I'll quota you
Remember the disks'll always be full
And then while I'm away
I'll write ~ everyday
And I'll send-pr all my buggings to you.
    [ CVS log "Beatles style" for FreeBSD ports/INDEX, Satoshi Asami ]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.071
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.071 (extra)
Problem:    Win32: Handling netbeans events while Vim is busy updating the
	    screen may cause a crash.
Solution:   Like with GTK, only handle netbeans messages in the main loop.
	    (Xavier de Gaye)
Files:	    src/gui_w48.c, src/netbeans.c


*** ../vim-7.2.070/src/gui_w48.c	Thu Nov 20 17:09:09 2008
--- src/gui_w48.c	Thu Dec 11 23:47:18 2008
***************
*** 1937,1942 ****
--- 1937,1947 ----
  	    s_need_activate = FALSE;
  	}
  
+ #ifdef FEAT_NETBEANS_INTG
+ 	/* Process the queued netbeans messages. */
+ 	netbeans_parse_messages();
+ #endif
+ 
  	/*
  	 * Don't use gui_mch_update() because then we will spin-lock until a
  	 * char arrives, instead we use GetMessage() to hang until an
*** ../vim-7.2.070/src/netbeans.c	Fri Nov 28 21:26:50 2008
--- src/netbeans.c	Sun Nov 30 12:07:00 2008
***************
*** 769,779 ****
  	return; /* don't try to parse it */
      }
  
! #ifdef FEAT_GUI_GTK
      if (gtk_main_level() > 0)
  	gtk_main_quit();
  #else
!     /* Parse the messages, but avoid recursion. */
      if (level == 1)
  	netbeans_parse_messages();
  
--- 769,782 ----
  	return; /* don't try to parse it */
      }
  
! #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)
!     /* Let the main loop handle messages. */
! # ifdef FEAT_GUI_GTK
      if (gtk_main_level() > 0)
  	gtk_main_quit();
+ # endif
  #else
!     /* Parse the messages now, but avoid recursion. */
      if (level == 1)
  	netbeans_parse_messages();
  
*** ../vim-7.2.070/src/version.c	Sun Dec 21 13:02:47 2008
--- src/version.c	Wed Dec 24 12:18:59 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     71,
  /**/

-- 
No children may attend school with their breath smelling of "wild onions."
		[real standing law in West Virginia, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.072 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.072 (extra)
Problem:    Compiler warning in Sniff code.
Solution:   Use return value of pipe(). (Dominique Pelle)
Files:	    src/if_sniff.c

NOTE: Patch was adjusted to avoid problems with CVS interference.

*** ../vim-7.2.071/src/if_sniff.c	Sat Nov 15 14:11:10 2008
--- src/if_sniff.c	Sat Dec  6 14:01:57 2008
***************
*** 716,723 ****
  #else		/* UNIX Version of the Code */
      int ToSniffEmacs[2], FromSniffEmacs[2];
  
!     pipe(ToSniffEmacs);
!     pipe(FromSniffEmacs);
  
      /* fork */
      if ((sniffemacs_pid=fork()) == 0)
--- 714,723 ----
  #else		/* UNIX Version of the Code */
      int ToSniffEmacs[2], FromSniffEmacs[2];
  
!     if (pipe(ToSniffEmacs) != 0)
! 	return 1;
!     if (pipe(FromSniffEmacs) != 0)
! 	return 1;
  
      /* fork */
      if ((sniffemacs_pid=fork()) == 0)
*** ../vim-7.2.071/src/version.c	Wed Dec 24 12:20:10 2008
--- src/version.c	Wed Dec 24 12:42:13 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     72,
  /**/

-- 
SIGIRO -- irony detected (iron core dumped)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.073
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.073
Problem:    ":set <xHome>" has the same output as ":set <Home>". (Matt
	    Wozniski)
Solution:   Don't translate "x" keys to its alternative for ":set".
Files:	    src/misc2.c, src/option.c, src/proto/misc2.pro


*** ../vim-7.2.072/src/misc2.c	Wed Nov 12 13:07:48 2008
--- src/misc2.c	Sun Dec 14 12:28:47 2008
***************
*** 2561,2567 ****
      int		key;
      int		dlen = 0;
  
!     key = find_special_key(srcp, &modifiers, keycode);
      if (key == 0)
  	return 0;
  
--- 2561,2567 ----
      int		key;
      int		dlen = 0;
  
!     key = find_special_key(srcp, &modifiers, keycode, FALSE);
      if (key == 0)
  	return 0;
  
***************
*** 2597,2606 ****
   * returns 0 if there is no match.
   */
      int
! find_special_key(srcp, modp, keycode)
      char_u	**srcp;
      int		*modp;
!     int		keycode; /* prefer key code, e.g. K_DEL instead of DEL */
  {
      char_u	*last_dash;
      char_u	*end_of_name;
--- 2597,2607 ----
   * returns 0 if there is no match.
   */
      int
! find_special_key(srcp, modp, keycode, keep_x_key)
      char_u	**srcp;
      int		*modp;
!     int		keycode;     /* prefer key code, e.g. K_DEL instead of DEL */
!     int		keep_x_key;  /* don't translate xHome to Home key */
  {
      char_u	*last_dash;
      char_u	*end_of_name;
***************
*** 2668,2674 ****
  	    else
  	    {
  		key = get_special_key_code(last_dash + 1);
! 		key = handle_x_keys(key);
  	    }
  
  	    /*
--- 2669,2676 ----
  	    else
  	    {
  		key = get_special_key_code(last_dash + 1);
! 		if (!keep_x_key)
! 		    key = handle_x_keys(key);
  	    }
  
  	    /*
*** ../vim-7.2.072/src/option.c	Fri Nov 28 21:26:50 2008
--- src/option.c	Sun Dec 14 12:28:56 2008
***************
*** 8328,8334 ****
      {
  	--arg;			    /* put arg at the '<' */
  	modifiers = 0;
! 	key = find_special_key(&arg, &modifiers, TRUE);
  	if (modifiers)		    /* can't handle modifiers here */
  	    key = 0;
      }
--- 8328,8334 ----
      {
  	--arg;			    /* put arg at the '<' */
  	modifiers = 0;
! 	key = find_special_key(&arg, &modifiers, TRUE, TRUE);
  	if (modifiers)		    /* can't handle modifiers here */
  	    key = 0;
      }
*** ../vim-7.2.072/src/proto/misc2.pro	Thu Jul 24 20:29:37 2008
--- src/proto/misc2.pro	Sun Dec 14 12:29:05 2008
***************
*** 59,65 ****
  int handle_x_keys __ARGS((int key));
  char_u *get_special_key_name __ARGS((int c, int modifiers));
  int trans_special __ARGS((char_u **srcp, char_u *dst, int keycode));
! int find_special_key __ARGS((char_u **srcp, int *modp, int keycode));
  int extract_modifiers __ARGS((int key, int *modp));
  int find_special_key_in_table __ARGS((int c));
  int get_special_key_code __ARGS((char_u *name));
--- 59,65 ----
  int handle_x_keys __ARGS((int key));
  char_u *get_special_key_name __ARGS((int c, int modifiers));
  int trans_special __ARGS((char_u **srcp, char_u *dst, int keycode));
! int find_special_key __ARGS((char_u **srcp, int *modp, int keycode, int keep_x_key));
  int extract_modifiers __ARGS((int key, int *modp));
  int find_special_key_in_table __ARGS((int c));
  int get_special_key_code __ARGS((char_u *name));
*** ../vim-7.2.072/src/version.c	Wed Dec 24 12:43:15 2008
--- src/version.c	Wed Dec 24 12:51:26 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     73,
  /**/


-- 
ARTHUR: If you do not open these doors, we will take this castle by force ...
   [A bucket of slops land on ARTHUR.  He tries to retain his dignity.]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.074 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.074 (extra, after 7.2.073)
Problem:    ":set <xHome>" has the same output as ":set <Home>". (Matt
	    Wozniski)
Solution:   Don't translate "x" keys to its alternative for ":set".
Files:	    src/gui_mac.c


*** ../vim-7.2.073/src/gui_mac.c	Sat Aug  9 19:37:28 2008
--- src/gui_mac.c	Sun Dec 14 12:28:26 2008
***************
*** 4966,4972 ****
  	char_u	    *p_actext;
  
  	p_actext = menu->actext;
! 	key = find_special_key(&p_actext, &modifiers, /*keycode=*/0);
  	if (*p_actext != 0)
  	    key = 0; /* error: trailing text */
  	/* find_special_key() returns a keycode with as many of the
--- 4966,4972 ----
  	char_u	    *p_actext;
  
  	p_actext = menu->actext;
! 	key = find_special_key(&p_actext, &modifiers, FALSE, FALSE);
  	if (*p_actext != 0)
  	    key = 0; /* error: trailing text */
  	/* find_special_key() returns a keycode with as many of the
*** ../vim-7.2.073/src/version.c	Wed Dec 24 12:53:33 2008
--- src/version.c	Wed Dec 24 12:55:42 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     74,
  /**/

-- 
   Another bucket of what can only be described as human ordure hits ARTHUR.
ARTHUR: ... Right!  (to the KNIGHTS) That settles it!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.075
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.075 (after 7.2.058)
Problem:    Explanation about making a diff for extra_patches is unclear.
Solution:   Adjust comment.
Files:	    src/version.c


*** ../vim-7.2.074/src/version.c	Wed Dec 24 13:04:41 2008
--- src/version.c	Wed Dec 24 13:07:47 2008
***************
*** 833,839 ****
   * Keep it short, e.g.,: "relative numbers", "persistent undo".
   * Also add a comment marker to separate the lines.
   * See the official Vim patches for the diff format: It must use a context of
!  * one line only.  Use "diff -C2".
   */
  static char *(extra_patches[]) =
  {   /* Add your patch description below this line */
--- 835,841 ----
   * Keep it short, e.g.,: "relative numbers", "persistent undo".
   * Also add a comment marker to separate the lines.
   * See the official Vim patches for the diff format: It must use a context of
!  * one line only.  Create it by hand or use "diff -C2" and edit the patch.
   */
  static char *(extra_patches[]) =
  {   /* Add your patch description below this line */
*** ../vim-7.2.074/src/version.c	Wed Dec 24 13:04:41 2008
--- src/version.c	Wed Dec 24 13:07:47 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     75,
  /**/

-- 
BEDEVERE: Stand by for attack!!
   [CUT TO enormous army forming up.  Trebuchets, rows of PIKEMEN, siege
   towers, pennants flying, shouts of "Stand by for attack!"  Traditional
   army build-up shots.  The shouts echo across the ranks of the army.
   We see various groups reacting, and stirring themselves in readiness.]
ARTHUR:   Who are they?
BEDEVERE: Oh, just some friends!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.076
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.076
Problem:    rename(from, to) deletes the file if "from" and "to" are not equal
	    but still refer to the same file.  E.g., on a FAT32 filesystem
	    under Unix.
Solution:   Go through another file name.
Files:	    src/fileio.c


*** ../vim-7.2.075/src/fileio.c	Fri Nov 28 21:26:50 2008
--- src/fileio.c	Tue Dec 30 16:04:44 2008
***************
*** 6119,6124 ****
--- 6119,6165 ----
      if (mch_stat((char *)from, &st) < 0)
  	return -1;
  
+ #ifdef UNIX
+     {
+ 	struct stat	st_to;
+ 	char		tempname[MAXPATHL + 1];
+ 
+ 	/* It's possible for the source and destination to be the same file.
+ 	 * This happens when "from" and "to" differ in case and are on a FAT32
+ 	 * filesystem.  In that case go through a temp file name. */
+ 	if (mch_stat((char *)to, &st_to) >= 0
+ 		&& st.st_dev == st_to.st_dev
+ 		&& st.st_ino == st_to.st_ino)
+ 	{
+ 	    /* Find a name that doesn't exist and is in the same directory.
+ 	     * Move "from" to "tempname" and then to "to". */
+ 	    if (STRLEN(from) >= MAXPATHL - 5)
+ 		return -1;
+ 	    STRCPY(tempname, from);
+ 	    for (n = 123; n < 99999; ++n)
+ 	    {
+ 		sprintf(gettail(tempname), "%d", n);
+ 		if (mch_stat(tempname, &st_to) < 0)
+ 		{
+ 		    if (mch_rename((char *)from, tempname) == 0)
+ 		    {
+ 			if (mch_rename(tempname, (char *)to) == 0)
+ 			    return 0;
+ 			/* Strange, the second step failed.  Try moving the
+ 			 * file back and return failure. */
+ 			mch_rename(tempname, (char *)from);
+ 			return -1;
+ 		    }
+ 		    /* If it fails for one temp name it will most likely fail
+ 		     * for any temp name, give up. */
+ 		    return -1;
+ 		}
+ 	    }
+ 	    return -1;
+ 	}
+     }
+ #endif
+ 
      /*
       * Delete the "to" file, this is required on some systems to make the
       * mch_rename() work, on other systems it makes sure that we don't have
*** ../vim-7.2.075/src/version.c	Wed Dec 24 14:24:41 2008
--- src/version.c	Tue Dec 30 16:09:51 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     76,
  /**/

-- 
FATAL ERROR! SYSTEM HALTED! - Press any key to continue doing nothing.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.077
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.077 (after 7.2.076)
Problem:    rename(from, to) doesn't work if "from" and "to" differ only in
	    case on a system that ignores case in file names.
Solution:   Go through another file name.
Files:	    src/fileio.c


*** ../vim-7.2.076/src/fileio.c	Tue Dec 30 16:15:16 2008
--- src/fileio.c	Wed Dec 31 14:59:59 2008
***************
*** 6106,6117 ****
  #ifdef HAVE_ACL
      vim_acl_T	acl;		/* ACL from original file */
  #endif
  
      /*
!      * When the names are identical, there is nothing to do.
       */
      if (fnamecmp(from, to) == 0)
! 	return 0;
  
      /*
       * Fail if the "from" file doesn't exist.  Avoids that "to" is deleted.
--- 6106,6129 ----
  #ifdef HAVE_ACL
      vim_acl_T	acl;		/* ACL from original file */
  #endif
+ #if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
+     int		use_tmp_file = FALSE;
+ #endif
  
      /*
!      * When the names are identical, there is nothing to do.  When they refer
!      * to the same file (ignoring case and slash/backslash differences) but
!      * the file name differs we need to go through a temp file.
       */
      if (fnamecmp(from, to) == 0)
!     {
! #ifdef CASE_INSENSITIVE_FILENAME
! 	if (STRCMP(gettail(from), gettail(to)) != 0)
! 	    use_tmp_file = TRUE;
! 	else
! #endif
! 	    return 0;
!     }
  
      /*
       * Fail if the "from" file doesn't exist.  Avoids that "to" is deleted.
***************
*** 6122,6128 ****
  #ifdef UNIX
      {
  	struct stat	st_to;
- 	char		tempname[MAXPATHL + 1];
  
  	/* It's possible for the source and destination to be the same file.
  	 * This happens when "from" and "to" differ in case and are on a FAT32
--- 6134,6139 ----
***************
*** 6130,6162 ****
  	if (mch_stat((char *)to, &st_to) >= 0
  		&& st.st_dev == st_to.st_dev
  		&& st.st_ino == st_to.st_ino)
  	{
! 	    /* Find a name that doesn't exist and is in the same directory.
! 	     * Move "from" to "tempname" and then to "to". */
! 	    if (STRLEN(from) >= MAXPATHL - 5)
! 		return -1;
! 	    STRCPY(tempname, from);
! 	    for (n = 123; n < 99999; ++n)
  	    {
! 		sprintf(gettail(tempname), "%d", n);
! 		if (mch_stat(tempname, &st_to) < 0)
  		{
! 		    if (mch_rename((char *)from, tempname) == 0)
! 		    {
! 			if (mch_rename(tempname, (char *)to) == 0)
! 			    return 0;
! 			/* Strange, the second step failed.  Try moving the
! 			 * file back and return failure. */
! 			mch_rename(tempname, (char *)from);
! 			return -1;
! 		    }
! 		    /* If it fails for one temp name it will most likely fail
! 		     * for any temp name, give up. */
  		    return -1;
  		}
  	    }
- 	    return -1;
  	}
      }
  #endif
  
--- 6141,6182 ----
  	if (mch_stat((char *)to, &st_to) >= 0
  		&& st.st_dev == st_to.st_dev
  		&& st.st_ino == st_to.st_ino)
+ 	    use_tmp_file = TRUE;
+     }
+ #endif
+ 
+ #if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
+     if (use_tmp_file)
+     {
+ 	char	tempname[MAXPATHL + 1];
+ 
+ 	/*
+ 	 * Find a name that doesn't exist and is in the same directory.
+ 	 * Rename "from" to "tempname" and then rename "tempname" to "to".
+ 	 */
+ 	if (STRLEN(from) >= MAXPATHL - 5)
+ 	    return -1;
+ 	STRCPY(tempname, from);
+ 	for (n = 123; n < 99999; ++n)
  	{
! 	    sprintf((char *)gettail((char_u *)tempname), "%d", n);
! 	    if (mch_stat(tempname, &st) < 0)
  	    {
! 		if (mch_rename((char *)from, tempname) == 0)
  		{
! 		    if (mch_rename(tempname, (char *)to) == 0)
! 			return 0;
! 		    /* Strange, the second step failed.  Try moving the
! 		     * file back and return failure. */
! 		    mch_rename(tempname, (char *)from);
  		    return -1;
  		}
+ 		/* If it fails for one temp name it will most likely fail
+ 		 * for any temp name, give up. */
+ 		return -1;
  	    }
  	}
+ 	return -1;
      }
  #endif
  
*** ../vim-7.2.076/src/version.c	Tue Dec 30 16:15:16 2008
--- src/version.c	Wed Dec 31 16:19:29 2008
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     77,
  /**/

-- 
We apologise again for the fault in the subtitles.  Those responsible for
sacking the people who have just been sacked have been sacked.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.078
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.078
Problem:    When deleting a fold that is specified with markers the cursor
	    position may be wrong.  Folds may not be displayed properly after
	    a delete.  Wrong fold may be deleted.
Solution:   Fix the problems. (mostly by Lech Lorens)
Files:	    src/fold.c


*** ../vim-7.2.077/src/fold.c	Fri Nov 28 21:26:50 2008
--- src/fold.c	Tue Jan  6 14:53:26 2009
***************
*** 740,746 ****
      garray_T	*found_ga;
      fold_T	*found_fp = NULL;
      linenr_T	found_off = 0;
!     int		use_level = FALSE;
      int		maybe_small = FALSE;
      int		level = 0;
      linenr_T	lnum = start;
--- 740,746 ----
      garray_T	*found_ga;
      fold_T	*found_fp = NULL;
      linenr_T	found_off = 0;
!     int		use_level;
      int		maybe_small = FALSE;
      int		level = 0;
      linenr_T	lnum = start;
***************
*** 757,762 ****
--- 757,763 ----
  	gap = &curwin->w_folds;
  	found_ga = NULL;
  	lnum_off = 0;
+ 	use_level = FALSE;
  	for (;;)
  	{
  	    if (!foldFind(gap, lnum - lnum_off, &fp))
***************
*** 783,802 ****
  	else
  	{
  	    lnum = found_fp->fd_top + found_fp->fd_len + found_off;
- 	    did_one = TRUE;
  
  	    if (foldmethodIsManual(curwin))
  		deleteFoldEntry(found_ga,
  		    (int)(found_fp - (fold_T *)found_ga->ga_data), recursive);
  	    else
  	    {
! 		if (found_fp->fd_top + found_off < first_lnum)
! 		    first_lnum = found_fp->fd_top;
! 		if (lnum > last_lnum)
  		    last_lnum = lnum;
! 		parseMarker(curwin);
  		deleteFoldMarkers(found_fp, recursive, found_off);
  	    }
  
  	    /* redraw window */
  	    changed_window_setting();
--- 784,804 ----
  	else
  	{
  	    lnum = found_fp->fd_top + found_fp->fd_len + found_off;
  
  	    if (foldmethodIsManual(curwin))
  		deleteFoldEntry(found_ga,
  		    (int)(found_fp - (fold_T *)found_ga->ga_data), recursive);
  	    else
  	    {
! 		if (first_lnum > found_fp->fd_top + found_off)
! 		    first_lnum = found_fp->fd_top + found_off;
! 		if (last_lnum < lnum)
  		    last_lnum = lnum;
! 		if (!did_one)
! 		    parseMarker(curwin);
  		deleteFoldMarkers(found_fp, recursive, found_off);
  	    }
+ 	    did_one = TRUE;
  
  	    /* redraw window */
  	    changed_window_setting();
***************
*** 811,816 ****
--- 813,822 ----
  	    redraw_curbuf_later(INVERTED);
  #endif
      }
+     else
+ 	/* Deleting markers may make cursor column invalid. */
+ 	check_cursor_col();
+ 
      if (last_lnum > 0)
  	changed_lines(first_lnum, (colnr_T)0, last_lnum, 0L);
  }
*** ../vim-7.2.077/src/version.c	Wed Dec 31 16:20:54 2008
--- src/version.c	Tue Jan  6 15:00:36 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     78,
  /**/

-- 
Looking at Perl through Lisp glasses, Perl looks atrocious.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.079
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.079
Problem:    "killed" netbeans events are not handled correctly.
Solution:   A "killed" netbeans event is sent when the buffer is deleted or
	    wiped out (in this case, the netbeans annotations in this buffer
	    have been removed).  A user can still remove a sign with the
	    command ":sign unplace" and this does not trigger a "killed"
	    event.  (Xavier de Gaye)
Files:	    runtime/doc/netbeans.txt, src/buffer.c, src/globals.h,
	    src/netbeans.c, src/proto/netbeans.pro


*** ../vim-7.2.078/runtime/doc/netbeans.txt	Sat Aug  9 19:36:49 2008
--- runtime/doc/netbeans.txt	Tue Jan  6 15:23:39 2009
***************
*** 1,4 ****
! *netbeans.txt*  For Vim version 7.2.  Last change: 2008 Jun 28
  
  
  		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
--- 1,4 ----
! *netbeans.txt*  For Vim version 7.2.  Last change: 2009 Jan 06
  
  
  		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
***************
*** 722,729 ****
  		of the cursor.
  		New in version 2.1.
  
! killed		A file was closed by the user.  Only for files that have been
! 		assigned a number by the IDE.
  
  newDotAndMark off off
  		Reports the position of the cursor being at "off" bytes into
--- 722,731 ----
  		of the cursor.
  		New in version 2.1.
  
! killed		A file was deleted or wiped out by the user and the buffer
! 		annotations have been removed.  The bufID number for this
! 		buffer has become invalid.  Only for files that have been
! 		assigned a bufID number by the IDE.
  
  newDotAndMark off off
  		Reports the position of the cursor being at "off" bytes into
*** ../vim-7.2.078/src/buffer.c	Wed Dec  3 11:21:20 2008
--- src/buffer.c	Tue Jan  6 15:23:02 2009
***************
*** 437,446 ****
  	return;
  #endif
  
- #ifdef FEAT_NETBEANS_INTG
-     if (usingNetbeans)
- 	netbeans_file_closed(buf);
- #endif
      /* Change directories when the 'acd' option is set. */
      DO_AUTOCHDIR
  
--- 437,442 ----
***************
*** 639,644 ****
--- 635,644 ----
  #ifdef FEAT_SIGNS
      buf_delete_signs(buf);		/* delete any signs */
  #endif
+ #ifdef FEAT_NETBEANS_INTG
+     if (usingNetbeans)
+         netbeans_file_killed(buf);
+ #endif
  #ifdef FEAT_LOCALMAP
      map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);  /* clear local mappings */
      map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);   /* clear local abbrevs */
***************
*** 815,823 ****
      int		bnr;		/* buffer number */
      char_u	*p;
  
- #ifdef FEAT_NETBEANS_INTG
-     netbeansCloseFile = 1;
- #endif
      if (addr_count == 0)
      {
  	(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);
--- 815,820 ----
***************
*** 912,920 ****
  	}
      }
  
- #ifdef FEAT_NETBEANS_INTG
-     netbeansCloseFile = 0;
- #endif
  
      return errormsg;
  }
--- 909,914 ----
*** ../vim-7.2.078/src/globals.h	Fri Nov 28 21:26:50 2008
--- src/globals.h	Tue Jan  6 15:23:02 2009
***************
*** 1340,1346 ****
  
  #ifdef FEAT_NETBEANS_INTG
  EXTERN char *netbeansArg INIT(= NULL);	/* the -nb[:host:port:passwd] arg */
- EXTERN int netbeansCloseFile INIT(= 0);	/* send killed if != 0 */
  EXTERN int netbeansFireChanges INIT(= 1); /* send buffer changes if != 0 */
  EXTERN int netbeansForcedQuit INIT(= 0);/* don't write modified files */
  EXTERN int netbeansReadFile INIT(= 1);	/* OK to read from disk if != 0 */
--- 1340,1345 ----
*** ../vim-7.2.078/src/netbeans.c	Wed Dec 24 12:20:10 2008
--- src/netbeans.c	Tue Jan  6 15:23:02 2009
***************
*** 2921,2964 ****
  }
  
  /*
!  * Tell netbeans a file was closed.
   */
      void
! netbeans_file_closed(buf_T *bufp)
  {
      int		bufno = nb_getbufno(bufp);
      nbbuf_T	*nbbuf = nb_get_buf(bufno);
      char	buffer[2*MAXPATHL];
  
!     if (!haveConnection || bufno < 0)
  	return;
  
!     if (!netbeansCloseFile)
!     {
! 	nbdebug(("Ignoring file_closed for %s. File was closed from IDE\n",
! 		    bufp->b_ffname));
! 	return;
!     }
! 
!     nbdebug(("netbeans_file_closed:\n"));
!     nbdebug(("    Closing bufno: %d", bufno));
!     if (curbuf != NULL && curbuf != bufp)
!     {
! 	nbdebug(("    Curbuf bufno:  %d\n", nb_getbufno(curbuf)));
!     }
!     else if (curbuf == bufp)
!     {
! 	nbdebug(("    curbuf == bufp\n"));
!     }
! 
!     if (bufno <= 0)
! 	return;
  
      sprintf(buffer, "%d:killed=%d\n", bufno, r_cmdno);
  
      nbdebug(("EVT: %s", buffer));
  
!     nb_send(buffer, "netbeans_file_closed");
  
      if (nbbuf != NULL)
  	nbbuf->bufp = NULL;
--- 2921,2946 ----
  }
  
  /*
!  * Tell netbeans that a file was deleted or wiped out.
   */
      void
! netbeans_file_killed(buf_T *bufp)
  {
      int		bufno = nb_getbufno(bufp);
      nbbuf_T	*nbbuf = nb_get_buf(bufno);
      char	buffer[2*MAXPATHL];
  
!     if (!haveConnection || bufno == -1)
  	return;
  
!     nbdebug(("netbeans_file_killed:\n"));
!     nbdebug(("    Killing bufno: %d", bufno));
  
      sprintf(buffer, "%d:killed=%d\n", bufno, r_cmdno);
  
      nbdebug(("EVT: %s", buffer));
  
!     nb_send(buffer, "netbeans_file_killed");
  
      if (nbbuf != NULL)
  	nbbuf->bufp = NULL;
*** ../vim-7.2.078/src/proto/netbeans.pro	Tue Jun 24 23:25:53 2008
--- src/proto/netbeans.pro	Tue Jan  6 15:23:02 2009
***************
*** 11,17 ****
  void netbeans_frame_moved __ARGS((int new_x, int new_y));
  void netbeans_file_activated __ARGS((buf_T *bufp));
  void netbeans_file_opened __ARGS((buf_T *bufp));
! void netbeans_file_closed __ARGS((buf_T *bufp));
  void netbeans_inserted __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, char_u *txt, int newlen));
  void netbeans_removed __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, long len));
  void netbeans_unmodified __ARGS((buf_T *bufp));
--- 11,17 ----
  void netbeans_frame_moved __ARGS((int new_x, int new_y));
  void netbeans_file_activated __ARGS((buf_T *bufp));
  void netbeans_file_opened __ARGS((buf_T *bufp));
! void netbeans_file_killed __ARGS((buf_T *bufp));
  void netbeans_inserted __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, char_u *txt, int newlen));
  void netbeans_removed __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, long len));
  void netbeans_unmodified __ARGS((buf_T *bufp));
*** ../vim-7.2.078/src/version.c	Tue Jan  6 15:01:58 2009
--- src/version.c	Tue Jan  6 16:11:11 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     79,
  /**/

-- 
Friends?  I have lots of friends!  In fact, I have every episode ever made.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.080
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.080
Problem:    When typing a composing character just after starting completion
	    may access memory before its allocation point. (Dominique Pelle)
Solution:   Don't delete before the completion start column.  Add extra checks
	    for the offset not being negative.
Files:	    src/edit.c


*** ../vim-7.2.079/src/edit.c	Wed Aug  6 18:56:55 2008
--- src/edit.c	Tue Jan 13 12:05:57 2009
***************
*** 147,152 ****
--- 147,153 ----
  static int  ins_compl_bs __ARGS((void));
  static void ins_compl_new_leader __ARGS((void));
  static void ins_compl_addleader __ARGS((int c));
+ static int ins_compl_len __ARGS((void));
  static void ins_compl_restart __ARGS((void));
  static void ins_compl_set_original_text __ARGS((char_u *str));
  static void ins_compl_addfrommatch __ARGS((void));
***************
*** 197,203 ****
  static void mb_replace_pop_ins __ARGS((int cc));
  #endif
  static void replace_flush __ARGS((void));
! static void replace_do_bs __ARGS((void));
  #ifdef FEAT_CINDENT
  static int cindent_on __ARGS((void));
  #endif
--- 198,205 ----
  static void mb_replace_pop_ins __ARGS((int cc));
  #endif
  static void replace_flush __ARGS((void));
! static void replace_do_bs __ARGS((int limit_col));
! static int del_char_after_col __ARGS((int limit_col));
  #ifdef FEAT_CINDENT
  static int cindent_on __ARGS((void));
  #endif
***************
*** 1933,1938 ****
--- 1935,1942 ----
  /*
   * Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
   * modes correctly.  May also be used when not in insert mode at all.
+  * Will attempt not to go before "col" even when there is a composing
+  * character.
   */
      void
  backspace_until_column(col)
***************
*** 1942,1954 ****
      {
  	curwin->w_cursor.col--;
  	if (State & REPLACE_FLAG)
! 	    replace_do_bs();
! 	else
! 	    (void)del_char(FALSE);
      }
  }
  #endif
  
  #if defined(FEAT_INS_EXPAND) || defined(PROTO)
  /*
   * CTRL-X pressed in Insert mode.
--- 1946,1994 ----
      {
  	curwin->w_cursor.col--;
  	if (State & REPLACE_FLAG)
! 	    replace_do_bs(col);
! 	else if (!del_char_after_col(col))
! 	    break;
      }
  }
  #endif
  
+ /*
+  * Like del_char(), but make sure not to go before column "limit_col".
+  * Only matters when there are composing characters.
+  * Return TRUE when something was deleted.
+  */
+    static int
+ del_char_after_col(limit_col)
+     int limit_col;
+ {
+ #ifdef FEAT_MBYTE
+     if (enc_utf8 && limit_col >= 0)
+     {
+ 	int ecol = curwin->w_cursor.col + 1;
+ 
+ 	/* Make sure the cursor is at the start of a character, but
+ 	 * skip forward again when going too far back because of a
+ 	 * composing character. */
+ 	mb_adjust_cursor();
+ 	while (curwin->w_cursor.col < limit_col)
+ 	{
+ 	    int l = utf_ptr2len(ml_get_cursor());
+ 
+ 	    if (l == 0)  /* end of line */
+ 		break;
+ 	    curwin->w_cursor.col += l;
+ 	}
+ 	if (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)
+ 	    return FALSE;
+ 	del_bytes((long)(ecol - curwin->w_cursor.col), FALSE, TRUE);
+     }
+     else
+ #endif
+ 	(void)del_char(FALSE);
+     return TRUE;
+ }
+ 
  #if defined(FEAT_INS_EXPAND) || defined(PROTO)
  /*
   * CTRL-X pressed in Insert mode.
***************
*** 2418,2424 ****
  	{
  	    had_match = (curwin->w_cursor.col > compl_col);
  	    ins_compl_delete();
! 	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
  	    ins_redraw(FALSE);
  
  	    /* When the match isn't there (to avoid matching itself) remove it
--- 2458,2464 ----
  	{
  	    had_match = (curwin->w_cursor.col > compl_col);
  	    ins_compl_delete();
! 	    ins_bytes(compl_leader + ins_compl_len());
  	    ins_redraw(FALSE);
  
  	    /* When the match isn't there (to avoid matching itself) remove it
***************
*** 2470,2476 ****
  	    *p = NUL;
  	    had_match = (curwin->w_cursor.col > compl_col);
  	    ins_compl_delete();
! 	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
  	    ins_redraw(FALSE);
  
  	    /* When the match isn't there (to avoid matching itself) remove it
--- 2510,2516 ----
  	    *p = NUL;
  	    had_match = (curwin->w_cursor.col > compl_col);
  	    ins_compl_delete();
! 	    ins_bytes(compl_leader + ins_compl_len());
  	    ins_redraw(FALSE);
  
  	    /* When the match isn't there (to avoid matching itself) remove it
***************
*** 3209,3215 ****
  {
      ins_compl_del_pum();
      ins_compl_delete();
!     ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
      compl_used_match = FALSE;
  
      if (compl_started)
--- 3249,3255 ----
  {
      ins_compl_del_pum();
      ins_compl_delete();
!     ins_bytes(compl_leader + ins_compl_len());
      compl_used_match = FALSE;
  
      if (compl_started)
***************
*** 3264,3269 ****
--- 3304,3323 ----
  }
  
  /*
+  * Return the length of the completion, from the completion start column to
+  * the cursor column.  Making sure it never goes below zero.
+  */
+     static int
+ ins_compl_len()
+ {
+     int off = curwin->w_cursor.col - compl_col;
+ 
+     if (off < 0)
+ 	return 0;
+     return off;
+ }
+ 
+ /*
   * Append one character to the match leader.  May reduce the number of
   * matches.
   */
***************
*** 3621,3630 ****
  	    {
  		ins_compl_delete();
  		if (compl_leader != NULL)
! 		    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
  		else if (compl_first_match != NULL)
! 		    ins_bytes(compl_orig_text
! 					  + curwin->w_cursor.col - compl_col);
  		retval = TRUE;
  	    }
  
--- 3675,3683 ----
  	    {
  		ins_compl_delete();
  		if (compl_leader != NULL)
! 		    ins_bytes(compl_leader + ins_compl_len());
  		else if (compl_first_match != NULL)
! 		    ins_bytes(compl_orig_text + ins_compl_len());
  		retval = TRUE;
  	    }
  
***************
*** 4256,4262 ****
      static void
  ins_compl_insert()
  {
!     ins_bytes(compl_shown_match->cp_str + curwin->w_cursor.col - compl_col);
      if (compl_shown_match->cp_flags & ORIGINAL_TEXT)
  	compl_used_match = FALSE;
      else
--- 4309,4315 ----
      static void
  ins_compl_insert()
  {
!     ins_bytes(compl_shown_match->cp_str + ins_compl_len());
      if (compl_shown_match->cp_flags & ORIGINAL_TEXT)
  	compl_used_match = FALSE;
      else
***************
*** 4425,4431 ****
  	if (!compl_get_longest || compl_used_match)
  	    ins_compl_insert();
  	else
! 	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
      }
      else
  	compl_used_match = FALSE;
--- 4478,4484 ----
  	if (!compl_get_longest || compl_used_match)
  	    ins_compl_insert();
  	else
! 	    ins_bytes(compl_leader + ins_compl_len());
      }
      else
  	compl_used_match = FALSE;
***************
*** 7123,7131 ****
   * cc == 0: character was inserted, delete it
   * cc > 0: character was replaced, put cc (first byte of original char) back
   * and check for more characters to be put back
   */
      static void
! replace_do_bs()
  {
      int		cc;
  #ifdef FEAT_VREPLACE
--- 7176,7187 ----
   * cc == 0: character was inserted, delete it
   * cc > 0: character was replaced, put cc (first byte of original char) back
   * and check for more characters to be put back
+  * When "limit_col" is >= 0, don't delete before this column.  Matters when
+  * using composing characters, use del_char_after_col() instead of del_char().
   */
      static void
! replace_do_bs(limit_col)
!     int		limit_col;
  {
      int		cc;
  #ifdef FEAT_VREPLACE
***************
*** 7153,7159 ****
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
! 	    del_char(FALSE);
  # ifdef FEAT_VREPLACE
  	    if (State & VREPLACE_FLAG)
  		orig_len = (int)STRLEN(ml_get_cursor());
--- 7209,7215 ----
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
! 	    (void)del_char_after_col(limit_col);
  # ifdef FEAT_VREPLACE
  	    if (State & VREPLACE_FLAG)
  		orig_len = (int)STRLEN(ml_get_cursor());
***************
*** 7203,7209 ****
  	changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);
      }
      else if (cc == 0)
! 	(void)del_char(FALSE);
  }
  
  #ifdef FEAT_CINDENT
--- 7259,7265 ----
  	changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);
      }
      else if (cc == 0)
! 	(void)del_char_after_col(limit_col);
  }
  
  #ifdef FEAT_CINDENT
***************
*** 8239,8245 ****
  	 * Replace mode */
  	if (curwin->w_cursor.lnum != Insstart.lnum
  		|| curwin->w_cursor.col >= Insstart.col)
! 	    replace_do_bs();
      }
      else
  	(void)del_char(FALSE);
--- 8295,8301 ----
  	 * Replace mode */
  	if (curwin->w_cursor.lnum != Insstart.lnum
  		|| curwin->w_cursor.col >= Insstart.col)
! 	    replace_do_bs(-1);
      }
      else
  	(void)del_char(FALSE);
***************
*** 8556,8562 ****
  		break;
  	    }
  	    if (State & REPLACE_FLAG)
! 		replace_do_bs();
  	    else
  	    {
  #ifdef FEAT_MBYTE
--- 8612,8618 ----
  		break;
  	    }
  	    if (State & REPLACE_FLAG)
! 		replace_do_bs(-1);
  	    else
  	    {
  #ifdef FEAT_MBYTE
*** ../vim-7.2.079/src/version.c	Tue Jan  6 16:13:42 2009
--- src/version.c	Tue Jan 13 12:25:29 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     80,
  /**/

-- 
At some point in the project somebody will start whining about the need to
determine the project "requirements".  This involves interviewing people who
don't know what they want but, curiously, know exactly when they need it.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.081
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.081
Problem:    Compiler warning for floating point overflow on VAX.
Solution:   For VAX use a smaller number. (Zoltan Arpadffy)
Files:	    src/message.c


*** ../vim-7.2.080/src/message.c	Fri Nov 28 21:26:50 2008
--- src/message.c	Tue Jan 13 16:19:07 2009
***************
*** 4556,4562 ****
  			remove_trailing_zeroes = TRUE;
  		    }
  
! 		    if (fmt_spec == 'f' && abs_f > 1.0e307)
  		    {
  			/* Avoid a buffer overflow */
  			strcpy(tmp, "inf");
--- 4556,4568 ----
  			remove_trailing_zeroes = TRUE;
  		    }
  
! 		    if (fmt_spec == 'f' &&
! #ifdef VAX
! 			    abs_f > 1.0e38
! #else
! 			    abs_f > 1.0e307
! #endif
! 			    )
  		    {
  			/* Avoid a buffer overflow */
  			strcpy(tmp, "inf");
*** ../vim-7.2.080/src/version.c	Tue Jan 13 12:29:03 2009
--- src/version.c	Tue Jan 13 16:19:52 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     81,
  /**/

-- 
Sometimes you can protect millions of dollars in your budget simply by buying
a bag of cookies, dropping it on the budget anylyst's desk, and saying
something deeply personal such as "How was your weekend, big guy?"
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.082
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.082
Problem:    When 'ff' is "mac" then "ga" on a ^J shows 0x0d instead of 0x0a.
	    (Andy Wokula)
Solution:   Use NL for this situation. (Lech Lorens)
Files:	    src/ex_cmds.c


*** ../vim-7.2.081/src/ex_cmds.c	Fri Nov 28 21:26:50 2008
--- src/ex_cmds.c	Tue Jan 13 16:51:32 2009
***************
*** 49,54 ****
--- 49,55 ----
      exarg_T	*eap;
  {
      int		c;
+     int		cval;
      char	buf1[20];
      char	buf2[20];
      char_u	buf3[7];
***************
*** 75,80 ****
--- 76,85 ----
      {
  	if (c == NL)	    /* NUL is stored as NL */
  	    c = NUL;
+ 	if (c == CAR && get_fileformat(curbuf) == EOL_MAC)
+ 	    cval = NL;	    /* NL is stored as CR */
+ 	else
+ 	    cval = c;
  	if (vim_isprintc_strict(c) && (c < ' '
  #ifndef EBCDIC
  		    || c > '~'
***************
*** 94,100 ****
  	    buf2[0] = NUL;
  	vim_snprintf((char *)IObuff, IOSIZE,
  		_("<%s>%s%s  %d,  Hex %02x,  Octal %03o"),
! 					   transchar(c), buf1, buf2, c, c, c);
  #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    c = cc[ci++];
--- 99,105 ----
  	    buf2[0] = NUL;
  	vim_snprintf((char *)IObuff, IOSIZE,
  		_("<%s>%s%s  %d,  Hex %02x,  Octal %03o"),
! 				  transchar(c), buf1, buf2, cval, cval, cval);
  #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    c = cc[ci++];
*** ../vim-7.2.081/src/version.c	Tue Jan 13 16:37:31 2009
--- src/version.c	Tue Jan 13 16:53:39 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     82,
  /**/

-- 
The budget process was invented by an alien race of sadistic beings who
resemble large cats.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.083
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.083
Problem:    ":tag" does not return to the right tag entry from the tag stack.
Solution:   Don't change the current match when there is no argument.
	    (Erik Falor)
Files:	    src/tag.c


*** ../vim-7.2.082/src/tag.c	Tue Dec  9 12:12:31 2008
--- src/tag.c	Tue Jan 13 17:14:59 2009
***************
*** 515,521 ****
  	     * If a count is supplied to the ":tag <name>" command, then
  	     * jump to count'th matching tag.
  	     */
! 	    if (type == DT_TAG && count > 0)
  		cur_match = count - 1;
  
  	    if (type == DT_SELECT || type == DT_JUMP
--- 515,521 ----
  	     * If a count is supplied to the ":tag <name>" command, then
  	     * jump to count'th matching tag.
  	     */
! 	    if (type == DT_TAG && *tag != NUL && count > 0)
  		cur_match = count - 1;
  
  	    if (type == DT_SELECT || type == DT_JUMP
*** ../vim-7.2.082/src/version.c	Tue Jan 13 16:57:09 2009
--- src/version.c	Tue Jan 13 17:16:42 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     83,
  /**/

-- 
Engineers will go without food and hygiene for days to solve a problem.
(Other times just because they forgot.)
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.084
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.084
Problem:    Recursive structures are not handled properly in Python
	    vim.eval().
Solution:   Keep track of references in a better way. (Yukihiro Nakadaira)
Files:	    src/if_python.c


*** ../vim-7.2.083/src/if_python.c	Thu Nov 20 11:04:01 2008
--- src/if_python.c	Tue Jan 13 18:08:06 2009
***************
*** 1151,1164 ****
  
      /* Check if we run into a recursive loop.  The item must be in lookupDict
       * then and we can use it again. */
!     sprintf(ptrBuf, PRINTF_DECIMAL_LONG_U, (long_u)our_tv);
!     result = PyDict_GetItemString(lookupDict, ptrBuf);
!     if (result != NULL)
! 	Py_INCREF(result);
!     else if (our_tv->v_type == VAR_STRING)
      {
  	result = Py_BuildValue("s", our_tv->vval.v_string);
- 	PyDict_SetItemString(lookupDict, ptrBuf, result);
      }
      else if (our_tv->v_type == VAR_NUMBER)
      {
--- 1151,1173 ----
  
      /* Check if we run into a recursive loop.  The item must be in lookupDict
       * then and we can use it again. */
!     if ((our_tv->v_type == VAR_LIST && our_tv->vval.v_list != NULL)
! 	    || (our_tv->v_type == VAR_DICT && our_tv->vval.v_dict != NULL))
!     {
! 	sprintf(ptrBuf, PRINTF_DECIMAL_LONG_U,
! 	        our_tv->v_type == VAR_LIST ? (long_u)our_tv->vval.v_list
! 		                           : (long_u)our_tv->vval.v_dict);
! 	result = PyDict_GetItemString(lookupDict, ptrBuf);
! 	if (result != NULL)
! 	{
! 	    Py_INCREF(result);
! 	    return result;
! 	}
!     }
! 
!     if (our_tv->v_type == VAR_STRING)
      {
  	result = Py_BuildValue("s", our_tv->vval.v_string);
      }
      else if (our_tv->v_type == VAR_NUMBER)
      {
***************
*** 1167,1173 ****
  	/* For backwards compatibility numbers are stored as strings. */
  	sprintf(buf, "%ld", (long)our_tv->vval.v_number);
  	result = Py_BuildValue("s", buf);
- 	PyDict_SetItemString(lookupDict, ptrBuf, result);
      }
  # ifdef FEAT_FLOAT
      else if (our_tv->v_type == VAR_FLOAT)
--- 1176,1181 ----
***************
*** 1176,1182 ****
  
  	sprintf(buf, "%f", our_tv->vval.v_float);
  	result = Py_BuildValue("s", buf);
- 	PyDict_SetItemString(lookupDict, ptrBuf, result);
      }
  # endif
      else if (our_tv->v_type == VAR_LIST)
--- 1184,1189 ----
***************
*** 1185,1194 ****
  	listitem_T	*curr;
  
  	result = PyList_New(0);
- 	PyDict_SetItemString(lookupDict, ptrBuf, result);
  
  	if (list != NULL)
  	{
  	    for (curr = list->lv_first; curr != NULL; curr = curr->li_next)
  	    {
  		newObj = VimToPython(&curr->li_tv, depth + 1, lookupDict);
--- 1192,1202 ----
  	listitem_T	*curr;
  
  	result = PyList_New(0);
  
  	if (list != NULL)
  	{
+ 	    PyDict_SetItemString(lookupDict, ptrBuf, result);
+ 
  	    for (curr = list->lv_first; curr != NULL; curr = curr->li_next)
  	    {
  		newObj = VimToPython(&curr->li_tv, depth + 1, lookupDict);
***************
*** 1200,1206 ****
      else if (our_tv->v_type == VAR_DICT)
      {
  	result = PyDict_New();
- 	PyDict_SetItemString(lookupDict, ptrBuf, result);
  
  	if (our_tv->vval.v_dict != NULL)
  	{
--- 1208,1213 ----
***************
*** 1209,1214 ****
--- 1216,1223 ----
  	    hashitem_T	*hi;
  	    dictitem_T	*di;
  
+ 	    PyDict_SetItemString(lookupDict, ptrBuf, result);
+ 
  	    for (hi = ht->ht_array; todo > 0; ++hi)
  	    {
  		if (!HASHITEM_EMPTY(hi))
*** ../vim-7.2.083/src/version.c	Tue Jan 13 17:27:18 2009
--- src/version.c	Tue Jan 13 17:54:14 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     84,
  /**/

-- 
Article in the first Free Software Magazine: "Bram Moolenaar studied electrical
engineering at the Technical University of Delft and graduated in 1985 on a
multi-processor Unix architecture."
Response by "dimator": Could the school not afford a proper stage for the
ceremony?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.085
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.085
Problem:    ":set <M-b>=<Esc>b" does not work when 'encoding' is utf-8.
Solution:   Put the <M-b> character in the input buffer as valid utf-8.
	    (partly by Matt Wosniski)
Files:	    src/term.c


*** ../vim-7.2.084/src/term.c	Tue Jul 29 12:22:12 2008
--- src/term.c	Thu Jan 22 18:18:29 2009
***************
*** 4920,4926 ****
  	key_name[0] = KEY2TERMCAP0(key);
  	key_name[1] = KEY2TERMCAP1(key);
  	if (key_name[0] == KS_KEY)
! 	    string[new_slen++] = key_name[1];	/* from ":set <M-b>=xx" */
  	else
  	{
  	    string[new_slen++] = K_SPECIAL;
--- 4920,4934 ----
  	key_name[0] = KEY2TERMCAP0(key);
  	key_name[1] = KEY2TERMCAP1(key);
  	if (key_name[0] == KS_KEY)
! 	{
! 	    /* from ":set <M-b>=xx" */
! #ifdef FEAT_MBYTE
! 	    if (has_mbyte)
! 		new_slen += (*mb_char2bytes)(key_name[1], string + new_slen);
! 	    else
! #endif
! 		string[new_slen++] = key_name[1];
! 	}
  	else
  	{
  	    string[new_slen++] = K_SPECIAL;
*** ../vim-7.2.084/src/version.c	Tue Jan 13 18:10:21 2009
--- src/version.c	Thu Jan 22 18:31:50 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     85,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
20. When looking at a pageful of someone else's links, you notice all of them
    are already highlighted in purple.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.086
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.086
Problem:    Using ":diffget 1" in buffer 1 corrupts the text.
Solution:   Don't do anything when source and destination of ":diffget" or
	    ":diffput" is the same buffer. (Dominique Pelle)
Files:	    src/diff.c


*** ../vim-7.2.085/src/diff.c	Sun Nov 30 15:15:56 2008
--- src/diff.c	Wed Jan 14 20:40:25 2009
***************
*** 8,14 ****
   */
  
  /*
!  * diff.c: code for diff'ing two or three buffers.
   */
  
  #include "vim.h"
--- 8,14 ----
   */
  
  /*
!  * diff.c: code for diff'ing two, three or four buffers.
   */
  
  #include "vim.h"
***************
*** 116,122 ****
   * Add a buffer to make diffs for.
   * Call this when a new buffer is being edited in the current window where
   * 'diff' is set.
!  * Marks the current buffer as being part of the diff and requireing updating.
   * This must be done before any autocmd, because a command may use info
   * about the screen contents.
   */
--- 116,122 ----
   * Add a buffer to make diffs for.
   * Call this when a new buffer is being edited in the current window where
   * 'diff' is set.
!  * Marks the current buffer as being part of the diff and requiring updating.
   * This must be done before any autocmd, because a command may use info
   * about the screen contents.
   */
***************
*** 929,935 ****
  	goto theend;
  
  #ifdef UNIX
!     /* Temporaraly chdir to /tmp, to avoid patching files in the current
       * directory when the patch file contains more than one patch.  When we
       * have our own temp dir use that instead, it will be cleaned up when we
       * exit (any .rej files created).  Don't change directory if we can't
--- 929,935 ----
  	goto theend;
  
  #ifdef UNIX
!     /* Temporarily chdir to /tmp, to avoid patching files in the current
       * directory when the patch file contains more than one patch.  When we
       * have our own temp dir use that instead, it will be cleaned up when we
       * exit (any .rej files created).  Don't change directory if we can't
***************
*** 2129,2134 ****
--- 2129,2136 ----
  	    EMSG2(_("E102: Can't find buffer \"%s\""), eap->arg);
  	    return;
  	}
+ 	if (buf == curbuf)
+ 	    return;		/* nothing to do */
  	idx_other = diff_buf_idx(buf);
  	if (idx_other == DB_COUNT)
  	{
*** ../vim-7.2.085/src/version.c	Thu Jan 22 18:32:55 2009
--- src/version.c	Thu Jan 22 20:46:54 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     86,
  /**/

-- 
Shift happens.
                -- Doppler

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.087
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.087
Problem:    Adding URL to 'path' doesn't work to edit a file.
Solution:   Skip simplify_filename() for URLs. (Matt Wosniski)
Files:	    src/misc2.c


*** ../vim-7.2.086/src/misc2.c	Wed Dec 24 12:53:33 2008
--- src/misc2.c	Sun Jan 18 12:26:20 2009
***************
*** 4696,4702 ****
  				stackp->ffs_filearray_cur = i + 1;
  				ff_push(search_ctx, stackp);
  
! 				simplify_filename(file_path);
  				if (mch_dirname(ff_expand_buffer, MAXPATHL)
  									== OK)
  				{
--- 4696,4703 ----
  				stackp->ffs_filearray_cur = i + 1;
  				ff_push(search_ctx, stackp);
  
! 				if (!path_with_url(file_path))
! 				    simplify_filename(file_path);
  				if (mch_dirname(ff_expand_buffer, MAXPATHL)
  									== OK)
  				{
*** ../vim-7.2.086/src/version.c	Thu Jan 22 20:48:07 2009
--- src/version.c	Thu Jan 22 21:30:36 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     87,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
21. Your dog has its own home page.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.088 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.088 (extra)
Problem:    OpenClipboard() may fail when another application is using the
	    clipboard.
Solution:   Retry OpenClipboard() a few times. (Jianrong Yu)
Files:	    src/os_mswin.c


*** ../vim-7.2.087/src/os_mswin.c	Thu Nov 20 17:09:09 2008
--- src/os_mswin.c	Thu Jan 22 18:38:12 2009
***************
*** 1224,1229 ****
--- 1224,1248 ----
  #endif /* FEAT_MBYTE */
  
  /*
+  * Wait for another process to Close the Clipboard.
+  * Returns TRUE for success.
+  */
+     int
+ vim_open_clipboard()
+ {
+     int delay = 10;
+ 
+     while (!OpenClipboard(NULL))
+     {
+         if (delay > 500)
+             return FALSE;  /* waited too long, give up */
+         Sleep(delay);
+         delay *= 2;	/* wait for 10, 20, 40, 80, etc. msec */
+     }
+     return TRUE;
+ }
+ 
+ /*
   * Get the current selection and put it in the clipboard register.
   *
   * NOTE: Must use GlobalLock/Unlock here to ensure Win32s compatibility.
***************
*** 1254,1260 ****
       * Don't pass GetActiveWindow() as an argument to OpenClipboard() because
       * then we can't paste back into the same window for some reason - webb.
       */
!     if (!OpenClipboard(NULL))
  	return;
  
      /* Check for vim's own clipboard format first.  This only gets the type of
--- 1273,1279 ----
       * Don't pass GetActiveWindow() as an argument to OpenClipboard() because
       * then we can't paste back into the same window for some reason - webb.
       */
!     if (!vim_open_clipboard())
  	return;
  
      /* Check for vim's own clipboard format first.  This only gets the type of
***************
*** 1562,1568 ****
       * because then we can't paste back into the same window for some
       * reason - webb.
       */
!     if (OpenClipboard(NULL))
      {
  	if (EmptyClipboard())
  	{
--- 1581,1587 ----
       * because then we can't paste back into the same window for some
       * reason - webb.
       */
!     if (vim_open_clipboard())
      {
  	if (EmptyClipboard())
  	{
*** ../vim-7.2.087/src/version.c	Thu Jan 22 21:31:24 2009
--- src/version.c	Thu Jan 22 21:47:52 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     88,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
22. You've already visited all the links at Yahoo and you're halfway through
    Lycos.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.089 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.089 (extra)
Problem:    Win32: crash when using Ultramon buttons.
Solution:   Don't use a WM_OLE message of zero size. (Ray Megal)
Files:	    src/if_ole.cpp, src/gui_w48.c


*** ../vim-7.2.088/src/if_ole.cpp	Sun Mar 16 14:53:11 2008
--- src/if_ole.cpp	Mon Jan 19 21:16:33 2009
***************
*** 353,361 ****
      }
  
      /* Pass the string to the main input loop. The memory will be freed when
!      * the message is processed.
       */
!     PostMessage(NULL, WM_OLE, 0, (LPARAM)str);
  
      return S_OK;
  }
--- 353,365 ----
      }
  
      /* Pass the string to the main input loop. The memory will be freed when
!      * the message is processed.  Except for an empty message, we don't need
!      * to post it then.
       */
!     if (*str == NUL)
! 	vim_free(str);
!     else
! 	PostMessage(NULL, WM_OLE, 0, (LPARAM)str);
  
      return S_OK;
  }
*** ../vim-7.2.088/src/gui_w48.c	Wed Dec 24 12:20:10 2008
--- src/gui_w48.c	Mon Jan 19 21:19:30 2009
***************
*** 1663,1670 ****
      if (msg.message == WM_OLE)
      {
  	char_u *str = (char_u *)msg.lParam;
! 	add_to_input_buf(str, (int)STRLEN(str));
! 	vim_free(str);
  	return;
      }
  #endif
--- 1663,1679 ----
      if (msg.message == WM_OLE)
      {
  	char_u *str = (char_u *)msg.lParam;
! 	if (str == NULL || *str == NUL)
! 	{
! 	    /* Message can't be ours, forward it.  Fixes problem with Ultramon
! 	     * 3.0.4 */
! 	    DispatchMessage(&msg);
! 	}
! 	else
! 	{
! 	    add_to_input_buf(str, (int)STRLEN(str));
! 	    vim_free(str);  /* was allocated in CVim::SendKeys() */
! 	}
  	return;
      }
  #endif
*** ../vim-7.2.088/src/version.c	Thu Jan 22 21:49:21 2009
--- src/version.c	Wed Jan 28 14:16:01 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     89,
  /**/


-- 
How To Keep A Healthy Level Of Insanity:
16. Have your coworkers address you by your wrestling name, Rock Hard Kim.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.090
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.090
Problem:    User command containing 0x80 in multi-byte character does not work
	    properly. (Yasuhiro Matsumoto)
Solution:   Undo replacement of K_SPECIAL and CSI characters when executing
	    the command.
Files:	    src/ex_docmd.c


*** ../vim-7.2.089/src/ex_docmd.c	Tue Dec  9 11:17:23 2008
--- src/ex_docmd.c	Wed Jan 28 15:34:19 2009
***************
*** 5482,5487 ****
--- 5482,5490 ----
      return OK;
  }
  
+ /*
+  * ":command ..."
+  */
      static void
  ex_command(eap)
      exarg_T   *eap;
***************
*** 5914,5919 ****
--- 5917,5923 ----
  
      char_u	*start;
      char_u	*end;
+     char_u	*ksp;
      size_t	len, totlen;
  
      size_t	split_len = 0;
***************
*** 5930,5945 ****
  
      /*
       * Replace <> in the command by the arguments.
       */
      buf = NULL;
      for (;;)
      {
! 	p = cmd->uc_rep;
! 	q = buf;
  	totlen = 0;
! 	while ((start = vim_strchr(p, '<')) != NULL
! 	       && (end = vim_strchr(start + 1, '>')) != NULL)
  	{
  	    /* Include the '>' */
  	    ++end;
  
--- 5934,5984 ----
  
      /*
       * Replace <> in the command by the arguments.
+      * First round: "buf" is NULL, compute length, allocate "buf".
+      * Second round: copy result into "buf".
       */
      buf = NULL;
      for (;;)
      {
! 	p = cmd->uc_rep;    /* source */
! 	q = buf;	    /* destinateion */
  	totlen = 0;
! 
! 	for (;;)
  	{
+ 	    start = vim_strchr(p, '<');
+ 	    if (start != NULL)
+ 		end = vim_strchr(start + 1, '>');
+ 	    if (buf != NULL)
+ 	    {
+ 		ksp = vim_strchr(p, K_SPECIAL);
+ 		if (ksp != NULL && (start == NULL || ksp < start || end == NULL)
+ 			&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)
+ # ifdef FEAT_GUI
+ 			    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)
+ # endif
+ 			    ))
+ 		{
+ 		    /* K_SPECIAL han been put in the buffer as K_SPECIAL
+ 		     * KS_SPECIAL KE_FILLER, like for mappings, but
+ 		     * do_cmdline() doesn't handle that, so convert it back.
+ 		     * Also change K_SPECIAL KS_EXTRA KE_CSI into CSI. */
+ 		    len = ksp - p;
+ 		    if (len > 0)
+ 		    {
+ 			mch_memmove(q, p, len);
+ 			q += len;
+ 		    }
+ 		    *q++ = ksp[1] == KS_SPECIAL ? K_SPECIAL : CSI;
+ 		    p = ksp + 3;
+ 		    continue;
+ 		}
+ 	    }
+ 
+ 	    /* break if there no <item> is found */
+ 	    if (start == NULL || end == NULL)
+ 		break;
+ 
  	    /* Include the '>' */
  	    ++end;
  
*** ../vim-7.2.089/src/version.c	Wed Jan 28 14:17:21 2009
--- src/version.c	Wed Jan 28 15:37:40 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     90,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
17. When the money comes out the ATM, scream "I won!, I won! 3rd
    time this week!!!!!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.091
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.091
Problem:    ":cs help" output is not aligned for some languages.
Solution:   Compute character size instead of byte size. (Dominique Pelle)
Files:	    src/if_cscope.c


*** ../vim-7.2.090/src/if_cscope.c	Mon Aug 25 04:35:13 2008
--- src/if_cscope.c	Thu Jan 22 18:44:46 2009
***************
*** 1177,1184 ****
      (void)MSG_PUTS(_("cscope commands:\n"));
      while (cmdp->name != NULL)
      {
! 	(void)smsg((char_u *)_("%-5s: %-30s (Usage: %s)"),
! 				      cmdp->name, _(cmdp->help), cmdp->usage);
  	if (strcmp(cmdp->name, "find") == 0)
  	    MSG_PUTS(_("\n"
  		       "       c: Find functions calling this function\n"
--- 1177,1192 ----
      (void)MSG_PUTS(_("cscope commands:\n"));
      while (cmdp->name != NULL)
      {
! 	char *help = _(cmdp->help);
! 	int  space_cnt = 30 - vim_strsize((char_u *)help);
! 
! 	/* Use %*s rather than %30s to ensure proper alignment in utf-8 */
! 	if (space_cnt < 0)
! 	    space_cnt = 0;
! 	(void)smsg((char_u *)_("%-5s: %s%*s (Usage: %s)"),
! 				      cmdp->name,
! 				      help, space_cnt, " ",
! 				      cmdp->usage);
  	if (strcmp(cmdp->name, "find") == 0)
  	    MSG_PUTS(_("\n"
  		       "       c: Find functions calling this function\n"
*** ../vim-7.2.090/src/version.c	Wed Jan 28 15:42:07 2009
--- src/version.c	Wed Jan 28 16:02:25 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     91,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
18. When leaving the zoo, start running towards the parking lot,
    yelling "run for your lives, they're loose!!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.092
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.092
Problem:    Some error messages are not translated.
Solution:   Add _() around the messages. (Dominique Pelle)
Files:	    src/eval.c


*** ../vim-7.2.091/src/eval.c	Sun Dec 21 13:02:47 2008
--- src/eval.c	Sat Jan 24 12:22:47 2009
***************
*** 7918,7926 ****
      else if (!aborting())
      {
  	if (argcount == MAX_FUNC_ARGS)
! 	    emsg_funcname("E740: Too many arguments for function %s", name);
  	else
! 	    emsg_funcname("E116: Invalid arguments for function %s", name);
      }
  
      while (--argcount >= 0)
--- 7918,7926 ----
      else if (!aborting())
      {
  	if (argcount == MAX_FUNC_ARGS)
! 	    emsg_funcname(N_("E740: Too many arguments for function %s"), name);
  	else
! 	    emsg_funcname(N_("E116: Invalid arguments for function %s"), name);
      }
  
      while (--argcount >= 0)
***************
*** 8153,8158 ****
--- 8153,8159 ----
  
  /*
   * Give an error message with a function name.  Handle <SNR> things.
+  * "ermsg" is to be passed without translation, use N_() instead of _().
   */
      static void
  emsg_funcname(ermsg, name)
***************
*** 19867,19873 ****
  		}
  	    }
  	    else
! 		emsg_funcname("E123: Undefined function: %s", name);
  	}
  	goto ret_free;
      }
--- 19868,19874 ----
  		}
  	    }
  	    else
! 		emsg_funcname(N_("E123: Undefined function: %s"), name);
  	}
  	goto ret_free;
      }
***************
*** 19911,19917 ****
  						      : eval_isnamec(arg[j])))
  		++j;
  	    if (arg[j] != NUL)
! 		emsg_funcname(_(e_invarg2), arg);
  	}
      }
  
--- 19912,19918 ----
  						      : eval_isnamec(arg[j])))
  		++j;
  	    if (arg[j] != NUL)
! 		emsg_funcname(e_invarg2, arg);
  	}
      }
  
***************
*** 20183,20189 ****
  	v = find_var(name, &ht);
  	if (v != NULL && v->di_tv.v_type == VAR_FUNC)
  	{
! 	    emsg_funcname("E707: Function name conflicts with variable: %s",
  									name);
  	    goto erret;
  	}
--- 20184,20190 ----
  	v = find_var(name, &ht);
  	if (v != NULL && v->di_tv.v_type == VAR_FUNC)
  	{
! 	    emsg_funcname(N_("E707: Function name conflicts with variable: %s"),
  									name);
  	    goto erret;
  	}
***************
*** 20198,20204 ****
  	    }
  	    if (fp->uf_calls > 0)
  	    {
! 		emsg_funcname("E127: Cannot redefine function %s: It is in use",
  									name);
  		goto erret;
  	    }
--- 20199,20205 ----
  	    }
  	    if (fp->uf_calls > 0)
  	    {
! 		emsg_funcname(N_("E127: Cannot redefine function %s: It is in use"),
  									name);
  		goto erret;
  	    }
***************
*** 21477,21483 ****
  
  /*
   * Return TRUE if items in "fc" do not have "copyID".  That means they are not
!  * referenced from anywyere.
   */
      static int
  can_free_funccal(fc, copyID)
--- 21478,21484 ----
  
  /*
   * Return TRUE if items in "fc" do not have "copyID".  That means they are not
!  * referenced from anywhere.
   */
      static int
  can_free_funccal(fc, copyID)
*** ../vim-7.2.091/src/version.c	Wed Jan 28 16:03:51 2009
--- src/version.c	Wed Jan 28 19:05:47 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     92,
  /**/


-- 
Now it is such a bizarrely improbable coincidence that anything as
mind-bogglingly useful as the Babel fish could have evolved purely by chance
that some thinkers have chosen to see it as a final and clinching proof of the
NON-existence of God.
The argument goes something like this: 'I refuse to prove that I exist,' says
God, 'for proof denies faith, and without faith I am nothing.'
'But,' says Man, 'the Babel fish is a dead giveaway, isn't it?  It could not
have evolved by chance.  It proves you exist, and so therefore, by your own
arguments, you don't.  QED.'
'Oh dear,' says God, 'I hadn't thought of that,' and promptly vanishes in a
puff of logic.
'Oh, that was easy,' says Man, and for an encore goes on to prove that black
is white and gets himself killed on the next pedestrian crossing.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.093 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.093 (extra)
Problem:    Win32: inputdialog() and find/replace dialogs can't handle
	    multi-byte text.
Solution:   Use the wide version of dialog functions when available. (Yanwei
	    Jia)
Files:	    src/gui_w32.c, src/gui_w48.c


*** ../vim-7.2.092/src/gui_w32.c	Thu Nov 20 17:09:09 2008
--- src/gui_w32.c	Wed Jan 28 21:15:29 2009
***************
*** 1582,1587 ****
--- 1582,1598 ----
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
+ # if defined(FEAT_MBYTE) && defined(WIN3264)
+     s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
+     s_findrep_struct_w.lpstrFindWhat =
+ 			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
+     s_findrep_struct_w.lpstrFindWhat[0] = NUL;
+     s_findrep_struct_w.lpstrReplaceWith =
+ 			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
+     s_findrep_struct_w.lpstrReplaceWith[0] = NUL;
+     s_findrep_struct_w.wFindWhatLen = MSWIN_FR_BUFSIZE;
+     s_findrep_struct_w.wReplaceWithLen = MSWIN_FR_BUFSIZE;
+ # endif
  #endif
  
  theend:
***************
*** 2938,2945 ****
  
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
! 	    GetDlgItemText(hwnd, DLG_NONBUTTON_CONTROL + 2,
  							 s_textfield, IOSIZE);
  
  	/*
  	 * Need to check for IDOK because if the user just hits Return to
--- 2949,2975 ----
  
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
! 	{
! # if defined(FEAT_MBYTE) && defined(WIN3264)
! 	    /* If the OS is Windows NT, and 'encoding' differs from active
! 	     * codepage: use wide function and convert text. */
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
!             {
! 	       WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
! 	       char_u *p;
! 
! 	       GetDlgItemTextW(hwnd, DLG_NONBUTTON_CONTROL + 2, wp, IOSIZE);
! 	       p = utf16_to_enc(wp, NULL);
! 	       vim_strncpy(s_textfield, p, IOSIZE);
! 	       vim_free(p);
! 	       vim_free(wp);
! 	    }
! 	    else
! # endif
! 		GetDlgItemText(hwnd, DLG_NONBUTTON_CONTROL + 2,
  							 s_textfield, IOSIZE);
+ 	}
  
  	/*
  	 * Need to check for IDOK because if the user just hits Return to
*** ../vim-7.2.092/src/gui_w48.c	Wed Jan 28 14:17:21 2009
--- src/gui_w48.c	Wed Jan 28 21:10:26 2009
***************
*** 153,158 ****
--- 153,161 ----
  #ifdef MSWIN_FIND_REPLACE
  static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
  static FINDREPLACE	s_findrep_struct;
+ # if defined(FEAT_MBYTE) && defined(WIN3264)
+ static FINDREPLACEW	s_findrep_struct_w;
+ # endif
  static HWND		s_findrep_hwnd = NULL;
  static int		s_findrep_is_find;	/* TRUE for find dialog, FALSE
  						   for find/replace dialog */
***************
*** 884,889 ****
--- 887,931 ----
  #endif
  
  #ifdef MSWIN_FIND_REPLACE
+ # if defined(FEAT_MBYTE) && defined(WIN3264)
+ /*
+  * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
+  */
+     static void
+ findrep_atow(LPFINDREPLACEW lpfrw, LPFINDREPLACE lpfr)
+ {
+     WCHAR *wp;
+ 
+     lpfrw->hwndOwner = lpfr->hwndOwner;
+     lpfrw->Flags = lpfr->Flags;
+ 
+     wp = enc_to_utf16(lpfr->lpstrFindWhat, NULL);
+     wcsncpy(lpfrw->lpstrFindWhat, wp, lpfrw->wFindWhatLen - 1);
+     vim_free(wp);
+ 
+     /* the field "lpstrReplaceWith" doesn't need to be copied */
+ }
+ 
+ /*
+  * copy useful data from structure LPFINDREPLACEW to structure LPFINDREPLACE
+  */
+     static void
+ findrep_wtoa(LPFINDREPLACE lpfr, LPFINDREPLACEW lpfrw)
+ {
+     char_u *p;
+ 
+     lpfr->Flags = lpfrw->Flags;
+ 
+     p = utf16_to_enc(lpfrw->lpstrFindWhat, NULL);
+     vim_strncpy(lpfr->lpstrFindWhat, p, lpfr->wFindWhatLen - 1);
+     vim_free(p);
+ 
+     p = utf16_to_enc(lpfrw->lpstrReplaceWith, NULL);
+     vim_strncpy(lpfr->lpstrReplaceWith, p, lpfr->wReplaceWithLen - 1);
+     vim_free(p);
+ }
+ # endif
+ 
  /*
   * Handle a Find/Replace window message.
   */
***************
*** 893,898 ****
--- 935,950 ----
      int	    flags = 0;
      int	    down;
  
+ # if defined(FEAT_MBYTE) && defined(WIN3264)
+     /* If the OS is Windows NT, and 'encoding' differs from active codepage:
+      * convert text from wide string. */
+     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
+ 			&& enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+     {
+         findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
+     }
+ # endif
+ 
      if (s_findrep_struct.Flags & FR_DIALOGTERM)
  	/* Give main window the focus back. */
  	(void)SetFocus(s_hwnd);
***************
*** 2562,2568 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! 	    s_findrep_hwnd = FindText((LPFINDREPLACE) &s_findrep_struct);
  	}
  
  	set_window_title(s_findrep_hwnd,
--- 2614,2632 ----
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # if defined(FEAT_MBYTE) && defined(WIN3264)
! 	    /* If the OS is Windows NT, and 'encoding' differs from active
! 	     * codepage: convert text and use wide function. */
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	    {
! 	        findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
! 		s_findrep_hwnd = FindTextW(
! 					(LPFINDREPLACEW) &s_findrep_struct_w);
! 	    }
! 	    else
! # endif
! 		s_findrep_hwnd = FindText((LPFINDREPLACE) &s_findrep_struct);
  	}
  
  	set_window_title(s_findrep_hwnd,
***************
*** 2587,2593 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! 	    s_findrep_hwnd = ReplaceText((LPFINDREPLACE) &s_findrep_struct);
  	}
  
  	set_window_title(s_findrep_hwnd,
--- 2651,2668 ----
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # if defined(FEAT_MBYTE) && defined(WIN3264)
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	    {
! 		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
! 		s_findrep_hwnd = ReplaceTextW(
! 					(LPFINDREPLACEW) &s_findrep_struct_w);
! 	    }
! 	    else
! # endif
! 		s_findrep_hwnd = ReplaceText(
! 					   (LPFINDREPLACE) &s_findrep_struct);
  	}
  
  	set_window_title(s_findrep_hwnd,
*** ../vim-7.2.092/src/version.c	Wed Jan 28 19:08:31 2009
--- src/version.c	Wed Jan 28 21:19:56 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     93,
  /**/

-- 
I'm not familiar with this proof, but I'm aware of a significant
following of toddlers who believe that peanut butter is the solution
to all of life's problems... 		-- Tim Hammerquist

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.094
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.094
Problem:    Compiler warning for signed/unsigned compare.
Solution:   Add type cast.  Also fix a few typos.
Files:	    src/edit.c


*** ../vim-7.2.093/src/edit.c	Tue Jan 13 12:29:03 2009
--- src/edit.c	Wed Jan 28 21:13:51 2009
***************
*** 1958,1963 ****
--- 1958,1964 ----
   * Only matters when there are composing characters.
   * Return TRUE when something was deleted.
   */
+ /*ARGSUSED*/
     static int
  del_char_after_col(limit_col)
      int limit_col;
***************
*** 1971,1977 ****
  	 * skip forward again when going too far back because of a
  	 * composing character. */
  	mb_adjust_cursor();
! 	while (curwin->w_cursor.col < limit_col)
  	{
  	    int l = utf_ptr2len(ml_get_cursor());
  
--- 1972,1978 ----
  	 * skip forward again when going too far back because of a
  	 * composing character. */
  	mb_adjust_cursor();
! 	while (curwin->w_cursor.col < (colnr_T)limit_col)
  	{
  	    int l = utf_ptr2len(ml_get_cursor());
  
***************
*** 4240,4246 ****
  	}
  
  	/* check if compl_curr_match has changed, (e.g. other type of
! 	 * expansion added somenthing) */
  	if (type != 0 && compl_curr_match != old_match)
  	    found_new_match = OK;
  
--- 4241,4247 ----
  	}
  
  	/* check if compl_curr_match has changed, (e.g. other type of
! 	 * expansion added something) */
  	if (type != 0 && compl_curr_match != old_match)
  	    found_new_match = OK;
  
***************
*** 4741,4747 ****
  		}
  		compl_length = curwin->w_cursor.col - (int)compl_col;
  		/* IObuff is used to add a "word from the next line" would we
! 		 * have enough space?  just being paranoic */
  #define	MIN_SPACE 75
  		if (compl_length > (IOSIZE - MIN_SPACE))
  		{
--- 4742,4748 ----
  		}
  		compl_length = curwin->w_cursor.col - (int)compl_col;
  		/* IObuff is used to add a "word from the next line" would we
! 		 * have enough space?  just being paranoid */
  #define	MIN_SPACE 75
  		if (compl_length > (IOSIZE - MIN_SPACE))
  		{
***************
*** 8206,8212 ****
  /*
   * If the cursor is on an indent, ^T/^D insert/delete one
   * shiftwidth.	Otherwise ^T/^D behave like a "<<" or ">>".
!  * Always round the indent to 'shiftwith', this is compatible
   * with vi.  But vi only supports ^T and ^D after an
   * autoindent, we support it everywhere.
   */
--- 8207,8213 ----
  /*
   * If the cursor is on an indent, ^T/^D insert/delete one
   * shiftwidth.	Otherwise ^T/^D behave like a "<<" or ">>".
!  * Always round the indent to 'shiftwidth', this is compatible
   * with vi.  But vi only supports ^T and ^D after an
   * autoindent, we support it everywhere.
   */
*** ../vim-7.2.093/src/version.c	Wed Jan 28 21:22:20 2009
--- src/version.c	Wed Feb  4 11:17:02 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     94,
  /**/

-- 
Despite the cost of living, have you noticed how it remains so popular?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.095
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.095
Problem:    With Visual selection, "r" and then CTRL-C Visual mode is stopped
	    but the highlighting is not removed.
Solution:   Call reset_VIsual().
Files:	    src/normal.c


*** ../vim-7.2.094/src/normal.c	Thu Nov 20 16:11:03 2008
--- src/normal.c	Fri Jan 30 20:37:01 2009
***************
*** 6783,6788 ****
--- 6783,6790 ----
      /* Visual mode "r" */
      if (VIsual_active)
      {
+ 	if (got_int)
+ 	    reset_VIsual();
  	nv_operator(cap);
  	return;
      }
***************
*** 7839,7845 ****
  	else
  	    i = curwin->w_leftcol;
  	/* Go to the middle of the screen line.  When 'number' is on and lines
! 	 * are wrapping the middle can be more to the left.*/
  	if (cap->nchar == 'm')
  	    i += (W_WIDTH(curwin) - curwin_col_off()
  		    + ((curwin->w_p_wrap && i > 0)
--- 7841,7847 ----
  	else
  	    i = curwin->w_leftcol;
  	/* Go to the middle of the screen line.  When 'number' is on and lines
! 	 * are wrapping the middle can be more to the left. */
  	if (cap->nchar == 'm')
  	    i += (W_WIDTH(curwin) - curwin_col_off()
  		    + ((curwin->w_p_wrap && i > 0)
*** ../vim-7.2.094/src/version.c	Wed Feb  4 11:19:40 2009
--- src/version.c	Wed Feb  4 11:43:28 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     95,
  /**/

-- 
Nothing is fool-proof to a sufficiently talented fool.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.096
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.096
Problem:    After ":number" the "Press Enter" message may be on the wrong
	    screen, if switching screens for shell commands.
Solution:   Reset info_message. (James Vega)
Files:	    src/ex_cmds.c


*** ../vim-7.2.095/src/ex_cmds.c	Tue Jan 13 16:57:09 2009
--- src/ex_cmds.c	Fri Jan 30 21:01:54 2009
***************
*** 2417,2424 ****
  	cursor_on();		/* msg_start() switches it off */
  	out_flush();
  	silent_mode = save_silent;
- 	info_message = FALSE;
      }
  }
  
  /*
--- 2417,2424 ----
  	cursor_on();		/* msg_start() switches it off */
  	out_flush();
  	silent_mode = save_silent;
      }
+     info_message = FALSE;
  }
  
  /*
*** ../vim-7.2.095/src/version.c	Wed Feb  4 11:45:28 2009
--- src/version.c	Wed Feb  4 13:12:55 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     96,
  /**/

-- 
A fine is a tax for doing wrong.  A tax is a fine for doing well.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.097
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.097
Problem:    "!xterm&" doesn't work when 'shell' is "bash".
Solution:   Ignore SIGHUP after calling setsid(). (Simon Schubert) 
Files:	    src/os_unix.c


*** ../vim-7.2.096/src/os_unix.c	Fri Nov 28 21:26:50 2008
--- src/os_unix.c	Wed Feb  4 12:09:55 2009
***************
*** 3950,3956 ****
--- 3950,3966 ----
  		 * children can be kill()ed.  Don't do this when using pipes,
  		 * because stdin is not a tty, we would lose /dev/tty. */
  		if (p_stmp)
+ 		{
  		    (void)setsid();
+ #  if defined(SIGHUP)
+ 		    /* When doing "!xterm&" and 'shell' is bash: the shell
+ 		     * will exit and send SIGHUP to all processes in its
+ 		     * group, killing the just started process.  Ignore SIGHUP
+ 		     * to avoid that. (suggested by Simon Schubert)
+ 		     */
+ 		    signal(SIGHUP, SIG_IGN);
+ #  endif
+ 		}
  # endif
  # ifdef FEAT_GUI
  		if (pty_slave_fd >= 0)
*** ../vim-7.2.096/src/version.c	Wed Feb  4 13:13:42 2009
--- src/version.c	Wed Feb  4 14:16:37 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     97,
  /**/

-- 
It was recently discovered that research causes cancer in rats.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.098
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.098
Problem:    Warning for signed/unsigned pointer.
Solution:   Add type cast.
Files:	    src/eval.c


*** ../vim-7.2.097/src/eval.c	Wed Jan 28 19:08:31 2009
--- src/eval.c	Wed Feb  4 13:09:01 2009
***************
*** 3928,3934 ****
  
  /*
   * Handle top level expression:
!  *	expr1 ? expr0 : expr0
   *
   * "arg" must point to the first non-white of the expression.
   * "arg" is advanced to the next non-white after the recognized expression.
--- 3928,3934 ----
  
  /*
   * Handle top level expression:
!  *	expr2 ? expr1 : expr1
   *
   * "arg" must point to the first non-white of the expression.
   * "arg" is advanced to the next non-white after the recognized expression.
***************
*** 19912,19918 ****
  						      : eval_isnamec(arg[j])))
  		++j;
  	    if (arg[j] != NUL)
! 		emsg_funcname(e_invarg2, arg);
  	}
      }
  
--- 19912,19918 ----
  						      : eval_isnamec(arg[j])))
  		++j;
  	    if (arg[j] != NUL)
! 		emsg_funcname((char *)e_invarg2, arg);
  	}
      }
  
*** ../vim-7.2.097/src/version.c	Wed Feb  4 14:18:44 2009
--- src/version.c	Wed Feb  4 16:24:06 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     98,
  /**/

-- 
Everybody lies, but it doesn't matter since nobody listens.
                                -- Lieberman's Law

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.099
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.099
Problem:    Changing GUI options causes an unnecessary redraw when the GUI
	    isn't active.
Solution:   Avoid the redraw. (Lech Lorens)
Files:	    src/option.c


*** ../vim-7.2.098/src/option.c	Wed Dec 24 12:53:33 2008
--- src/option.c	Wed Feb  4 16:59:56 2009
***************
*** 5407,5412 ****
--- 5407,5416 ----
      int		did_chartab = FALSE;
      char_u	**gvarp;
      long_u	free_oldval = (options[opt_idx].flags & P_ALLOCED);
+ #ifdef FEAT_GUI
+     /* set when changing an option that only requires a redraw in the GUI */
+     int		redraw_gui_only = FALSE;
+ #endif
  
      /* Get the global option to compare with, otherwise we would have to check
       * two values for all local options. */
***************
*** 6055,6060 ****
--- 6059,6065 ----
  		    errmsg = (char_u *)N_("E596: Invalid font(s)");
  	    }
  	}
+ 	redraw_gui_only = TRUE;
      }
  # ifdef FEAT_XFONTSET
      else if (varp == &p_guifontset)
***************
*** 6063,6068 ****
--- 6068,6074 ----
  	    errmsg = (char_u *)N_("E597: can't select fontset");
  	else if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)
  	    errmsg = (char_u *)N_("E598: Invalid fontset");
+ 	redraw_gui_only = TRUE;
      }
  # endif
  # ifdef FEAT_MBYTE
***************
*** 6072,6077 ****
--- 6078,6084 ----
  	    errmsg = (char_u *)N_("E533: can't select wide font");
  	else if (gui_get_wide_font() == FAIL)
  	    errmsg = (char_u *)N_("E534: Invalid wide font");
+ 	redraw_gui_only = TRUE;
      }
  # endif
  #endif
***************
*** 6133,6145 ****
--- 6140,6163 ----
  #ifdef FEAT_GUI
      /* 'guioptions' */
      else if (varp == &p_go)
+     {
  	gui_init_which_components(oldval);
+ 	redraw_gui_only = TRUE;
+     }
  #endif
  
  #if defined(FEAT_GUI_TABLINE)
      /* 'guitablabel' */
      else if (varp == &p_gtl)
+     {
  	redraw_tabline = TRUE;
+ 	redraw_gui_only = TRUE;
+     }
+     /* 'guitabtooltip' */
+     else if (varp == &p_gtt)
+     {
+ 	redraw_gui_only = TRUE;
+     }
  #endif
  
  #if defined(FEAT_MOUSE_TTY) && (defined(UNIX) || defined(VMS))
***************
*** 6717,6723 ****
  
      if (curwin->w_curswant != MAXCOL)
  	curwin->w_set_curswant = TRUE;  /* in case 'showbreak' changed */
!     check_redraw(options[opt_idx].flags);
  
      return errmsg;
  }
--- 6735,6745 ----
  
      if (curwin->w_curswant != MAXCOL)
  	curwin->w_set_curswant = TRUE;  /* in case 'showbreak' changed */
! #ifdef FEAT_GUI
!     /* check redraw when it's not a GUI option or the GUI is active. */
!     if (!redraw_gui_only || gui.in_use)
! #endif
! 	check_redraw(options[opt_idx].flags);
  
      return errmsg;
  }
*** ../vim-7.2.098/src/version.c	Wed Feb  4 16:25:53 2009
--- src/version.c	Wed Feb  4 17:24:11 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     99,
  /**/

-- 
I started out with nothing, and I still have most of it.
                                -- Michael Davis -- "Tonight Show"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.2.100
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.100
Problem:    When using ":source" on a FIFO or something else that can't rewind
	    the first three bytes are skipped.
Solution:   Instead of rewinding read the first line and detect a BOM in that.
	    (mostly by James Vega)
Files:	    src/ex_cmds2.c


*** ../vim-7.2.099/src/ex_cmds2.c	Sat Nov 15 14:10:23 2008
--- src/ex_cmds2.c	Wed Feb  4 16:05:51 2009
***************
*** 2842,2847 ****
--- 2842,2848 ----
      linenr_T		    save_sourcing_lnum;
      char_u		    *p;
      char_u		    *fname_exp;
+     char_u		    *firstline = NULL;
      int			    retval = FAIL;
  #ifdef FEAT_EVAL
      scid_T		    save_current_SID;
***************
*** 2992,3014 ****
  
      cookie.level = ex_nesting_level;
  #endif
- #ifdef FEAT_MBYTE
-     cookie.conv.vc_type = CONV_NONE;		/* no conversion */
- 
-     /* Try reading the first few bytes to check for a UTF-8 BOM. */
-     {
- 	char_u	    buf[3];
- 
- 	if (fread((char *)buf, sizeof(char_u), (size_t)3, cookie.fp)
- 								  == (size_t)3
- 		&& buf[0] == 0xef && buf[1] == 0xbb && buf[2] == 0xbf)
- 	    /* Found BOM, setup conversion and skip over it. */
- 	    convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
- 	else
- 	    /* No BOM found, rewind. */
- 	    fseek(cookie.fp, 0L, SEEK_SET);
-     }
- #endif
  
      /*
       * Keep the sourcing name/lnum, for recursive calls.
--- 2993,2998 ----
***************
*** 3018,3023 ****
--- 3002,3026 ----
      save_sourcing_lnum = sourcing_lnum;
      sourcing_lnum = 0;
  
+ #ifdef FEAT_MBYTE
+     cookie.conv.vc_type = CONV_NONE;		/* no conversion */
+ 
+     /* Read the first line so we can check for a UTF-8 BOM. */
+     firstline = getsourceline(0, (void *)&cookie, 0);
+     if (firstline != NULL && STRLEN(firstline) >= 3 && firstline[0] == 0xef
+ 			      && firstline[1] == 0xbb && firstline[2] == 0xbf)
+     {
+ 	/* Found BOM; setup conversion, skip over BOM and recode the line. */
+ 	convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
+ 	p = string_convert(&cookie.conv, firstline + 3, NULL);
+ 	if (p != NULL)
+ 	{
+ 	    vim_free(firstline);
+ 	    firstline = p;
+ 	}
+     }
+ #endif
+ 
  #ifdef STARTUPTIME
      time_push(&tv_rel, &tv_start);
  #endif
***************
*** 3111,3119 ****
      /*
       * Call do_cmdline, which will call getsourceline() to get the lines.
       */
!     do_cmdline(NULL, getsourceline, (void *)&cookie,
  				     DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);
- 
      retval = OK;
  
  #ifdef FEAT_PROFILE
--- 3114,3121 ----
      /*
       * Call do_cmdline, which will call getsourceline() to get the lines.
       */
!     do_cmdline(firstline, getsourceline, (void *)&cookie,
  				     DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);
      retval = OK;
  
  #ifdef FEAT_PROFILE
***************
*** 3171,3176 ****
--- 3173,3179 ----
  #endif
      fclose(cookie.fp);
      vim_free(cookie.nextline);
+     vim_free(firstline);
  #ifdef FEAT_MBYTE
      convert_setup(&cookie.conv, NULL, NULL);
  #endif
*** ../vim-7.2.099/src/version.c	Wed Feb  4 17:27:50 2009
--- src/version.c	Wed Feb  4 17:48:47 2009
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     100,
  /**/

-- 
Well, you come from nothing, you go back to nothing...  What have you
lost?  Nothing!
				-- Monty Python: The life of Brian

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
