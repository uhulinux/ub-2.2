diff -Naur orig/aclocal.m4 patched/aclocal.m4
--- orig/aclocal.m4	2012-02-26 15:53:39.000000000 +0100
+++ patched/aclocal.m4	2014-01-19 19:05:51.000000000 +0100
@@ -1,8 +1,7 @@
-# generated automatically by aclocal 1.11.3 -*- Autoconf -*-
+# generated automatically by aclocal 1.14.1 -*- Autoconf -*-
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,
-# Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -12,33 +11,31 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
+m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.68],,
-[m4_warning([this file was generated for autoconf 2.68.
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,
+[m4_warning([this file was generated for autoconf 2.69.
 You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
-To do so, use the procedure documented by the package, typically `autoreconf'.])])
+To do so, use the procedure documented by the package, typically 'autoreconf'.])])
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 2002-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
 # Automake X.Y traces this macro to ensure aclocal.m4 has been
 # generated from the m4 files accompanying Automake X.Y.
 # (This private macro should not be called outside this file.)
 AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.11'
+[am__api_version='1.14'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.3], [],
+m4_if([$1], [1.14.1], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -54,24 +51,22 @@
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.3])dnl
+[AM_AUTOMAKE_VERSION([1.14.1])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
+# '$srcdir', '$srcdir/..', or '$srcdir/../..'.
 #
 # Of course, Automake must honor this variable whenever it calls a
 # tool from the auxiliary directory.  The problem is that $srcdir (and
@@ -90,7 +85,7 @@
 #
 # The reason of the latter failure is that $top_srcdir and $ac_aux_dir
 # are both prefixed by $srcdir.  In an in-source build this is usually
-# harmless because $srcdir is `.', but things will broke when you
+# harmless because $srcdir is '.', but things will broke when you
 # start a VPATH build or use an absolute $srcdir.
 #
 # So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
@@ -116,22 +111,19 @@
 
 # AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1997-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 9
-
 # AM_CONDITIONAL(NAME, SHELL-CONDITION)
 # -------------------------------------
 # Define a conditional.
 AC_DEFUN([AM_CONDITIONAL],
-[AC_PREREQ(2.52)dnl
- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
-	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+[AC_PREREQ([2.52])dnl
+ m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
 AC_SUBST([$1_TRUE])dnl
 AC_SUBST([$1_FALSE])dnl
 _AM_SUBST_NOTMAKE([$1_TRUE])dnl
@@ -150,16 +142,14 @@
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,
-# 2010, 2011 Free Software Foundation, Inc.
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 12
 
-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
 # will think it sees a *use*, and therefore will trigger all it's
 # C support machinery.  Also note that it means that autoscan, seeing
@@ -169,7 +159,7 @@
 # _AM_DEPENDENCIES(NAME)
 # ----------------------
 # See how the compiler implements dependency checking.
-# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# NAME is "CC", "CXX", "OBJC", "OBJCXX", "UPC", or "GJC".
 # We try a few techniques and use that to set a single cache variable.
 #
 # We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
@@ -182,12 +172,13 @@
 AC_REQUIRE([AM_MAKE_INCLUDE])dnl
 AC_REQUIRE([AM_DEP_TRACK])dnl
 
-ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
-       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
-       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
-       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
-       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
-                   [depcc="$$1"   am_compiler_list=])
+m4_if([$1], [CC],   [depcc="$CC"   am_compiler_list=],
+      [$1], [CXX],  [depcc="$CXX"  am_compiler_list=],
+      [$1], [OBJC], [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+      [$1], [OBJCXX], [depcc="$OBJCXX" am_compiler_list='gcc3 gcc'],
+      [$1], [UPC],  [depcc="$UPC"  am_compiler_list=],
+      [$1], [GCJ],  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                    [depcc="$$1"   am_compiler_list=])
 
 AC_CACHE_CHECK([dependency style of $depcc],
                [am_cv_$1_dependencies_compiler_type],
@@ -195,8 +186,8 @@
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -236,16 +227,16 @@
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -254,8 +245,8 @@
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -263,7 +254,7 @@
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -311,7 +302,7 @@
 # AM_SET_DEPDIR
 # -------------
 # Choose a directory name for dependency files.
-# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES.
 AC_DEFUN([AM_SET_DEPDIR],
 [AC_REQUIRE([AM_SET_LEADING_DOT])dnl
 AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
@@ -321,9 +312,13 @@
 # AM_DEP_TRACK
 # ------------
 AC_DEFUN([AM_DEP_TRACK],
-[AC_ARG_ENABLE(dependency-tracking,
-[  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors])
+[AC_ARG_ENABLE([dependency-tracking], [dnl
+AS_HELP_STRING(
+  [--enable-dependency-tracking],
+  [do not reject slow dependency extractors])
+AS_HELP_STRING(
+  [--disable-dependency-tracking],
+  [speeds up one-time build])])
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
@@ -338,20 +333,18 @@
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-#serial 5
 
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
 AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
 [{
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # Older Autoconf quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
   # if we detect the quoting.
   case $CONFIG_FILES in
@@ -364,7 +357,7 @@
     # Strip MF so we end up with the name of the file.
     mf=`echo "$mf" | sed -e 's/:.*$//'`
     # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
+    # We used to match only the files named 'Makefile.in', but
     # some people rename them; so instead we look at the file content.
     # Grep'ing the first line is not enough: some people post-process
     # each Makefile.in and add a new line on top of each file to say so.
@@ -376,21 +369,19 @@
       continue
     fi
     # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
+    # from the Makefile without running 'make'.
     DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
     test -z "$DEPDIR" && continue
     am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
+    test -z "$am__include" && continue
     am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
     # Find all dependency output files, they are included files with
     # $(DEPDIR) in their names.  We invoke sed twice because it is the
     # simplest approach to changing $(DEPDIR) to its actual value in the
     # expansion.
     for file in `sed -n "
       s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
       # Make sure the directory exists.
       test -f "$dirpart/$file" && continue
       fdir=`AS_DIRNAME(["$file"])`
@@ -408,7 +399,7 @@
 # This macro should only be invoked once -- use via AC_REQUIRE.
 #
 # This code is only required when automatic dependency tracking
-# is enabled.  FIXME.  This creates each `.P' file that we will
+# is enabled.  FIXME.  This creates each '.P' file that we will
 # need in order to bootstrap the dependency handling code.
 AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 [AC_CONFIG_COMMANDS([depfiles],
@@ -418,18 +409,21 @@
 
 # Do all the work for Automake.                             -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 16
-
 # This macro actually does too much.  Some checks are only needed if
 # your package does certain things.  But this isn't really a big deal.
 
+dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.
+m4_define([AC_PROG_CC],
+m4_defn([AC_PROG_CC])
+[_AM_PROG_CC_C_O
+])
+
 # AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
 # AM_INIT_AUTOMAKE([OPTIONS])
 # -----------------------------------------------
@@ -442,7 +436,7 @@
 # arguments mandatory, and then we can depend on a new Autoconf
 # release and drop the old call support.
 AC_DEFUN([AM_INIT_AUTOMAKE],
-[AC_PREREQ([2.62])dnl
+[AC_PREREQ([2.65])dnl
 dnl Autoconf wants to disallow AM_ names.  We explicitly allow
 dnl the ones we care about.
 m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
@@ -471,31 +465,40 @@
 # Define the identity of the package.
 dnl Distinguish between old-style and new-style calls.
 m4_ifval([$2],
-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+[AC_DIAGNOSE([obsolete],
+             [$0: two- and three-arguments forms are deprecated.])
+m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
  AC_SUBST([PACKAGE], [$1])dnl
  AC_SUBST([VERSION], [$2])],
 [_AM_SET_OPTIONS([$1])dnl
 dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
+m4_if(
+  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
+  [ok:ok],,
   [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
  AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
  AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
 
 _AM_IF_OPTION([no-define],,
-[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
- AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+[AC_DEFINE_UNQUOTED([PACKAGE], ["$PACKAGE"], [Name of package])
+ AC_DEFINE_UNQUOTED([VERSION], ["$VERSION"], [Version number of package])])dnl
 
 # Some tools Automake needs.
 AC_REQUIRE([AM_SANITY_CHECK])dnl
 AC_REQUIRE([AC_ARG_PROGRAM])dnl
-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
-AM_MISSING_PROG(AUTOCONF, autoconf)
-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
-AM_MISSING_PROG(AUTOHEADER, autoheader)
-AM_MISSING_PROG(MAKEINFO, makeinfo)
+AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])
+AM_MISSING_PROG([AUTOCONF], [autoconf])
+AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])
+AM_MISSING_PROG([AUTOHEADER], [autoheader])
+AM_MISSING_PROG([MAKEINFO], [makeinfo])
 AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
 AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
-AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+AC_REQUIRE([AC_PROG_MKDIR_P])dnl
+# For better backward compatibility.  To be removed once Automake 1.9.x
+# dies out for good.  For more background, see:
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
+AC_SUBST([mkdir_p], ['$(MKDIR_P)'])
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
 AC_REQUIRE([AC_PROG_AWK])dnl
@@ -506,34 +509,78 @@
 			     [_AM_PROG_TAR([v7])])])
 _AM_IF_OPTION([no-dependencies],,
 [AC_PROVIDE_IFELSE([AC_PROG_CC],
-		  [_AM_DEPENDENCIES(CC)],
-		  [define([AC_PROG_CC],
-			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+		  [_AM_DEPENDENCIES([CC])],
+		  [m4_define([AC_PROG_CC],
+			     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl
 AC_PROVIDE_IFELSE([AC_PROG_CXX],
-		  [_AM_DEPENDENCIES(CXX)],
-		  [define([AC_PROG_CXX],
-			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+		  [_AM_DEPENDENCIES([CXX])],
+		  [m4_define([AC_PROG_CXX],
+			     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl
 AC_PROVIDE_IFELSE([AC_PROG_OBJC],
-		  [_AM_DEPENDENCIES(OBJC)],
-		  [define([AC_PROG_OBJC],
-			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
-])
-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
+		  [_AM_DEPENDENCIES([OBJC])],
+		  [m4_define([AC_PROG_OBJC],
+			     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],
+		  [_AM_DEPENDENCIES([OBJCXX])],
+		  [m4_define([AC_PROG_OBJCXX],
+			     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl
+])
+AC_REQUIRE([AM_SILENT_RULES])dnl
+dnl The testsuite driver may need to know about EXEEXT, so add the
+dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This
+dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.
 AC_CONFIG_COMMANDS_PRE(dnl
 [m4_provide_if([_AM_COMPILER_EXEEXT],
   [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
-])
 
-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
+# POSIX will say in a future version that running "rm -f" with no argument
+# is OK; and we want to be able to make that assumption in our Makefile
+# recipes.  So use an aggressive probe to check that the usage we want is
+# actually supported "in the wild" to an acceptable degree.
+# See automake bug#10828.
+# To make any issue more visible, cause the running configure to be aborted
+# by default if the 'rm' program in use doesn't match our expectations; the
+# user can still override this though.
+if rm -f && rm -fr && rm -rf; then : OK; else
+  cat >&2 <<'END'
+Oops!
+
+Your 'rm' program seems unable to run without file operands specified
+on the command line, even when the '-f' option is present.  This is contrary
+to the behaviour of most rm programs out there, and not conforming with
+the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>
+
+Please tell bug-automake@gnu.org about your system, including the value
+of your $PATH and any error possibly output before this message.  This
+can help us improve future automake versions.
+
+END
+  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
+    echo 'Configuration will proceed anyway, since you have set the' >&2
+    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to "yes"' >&2
+    echo >&2
+  else
+    cat >&2 <<'END'
+Aborting the configuration process, to ensure you take notice of the issue.
+
+You can download and install GNU coreutils to get an 'rm' implementation
+that behaves properly: <http://www.gnu.org/software/coreutils/>.
+
+If you want to complete the configuration process using your problematic
+'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
+to "yes", and re-run configure.
+
+END
+    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])
+  fi
+fi])
+
+dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
 dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
 dnl mangled by Autoconf and run in a shell conditional statement.
 m4_define([_AC_COMPILER_EXEEXT],
 m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])
 
-
 # When config.status generates a header, we must update the stamp-h file.
 # This file resides in the same directory as the config header
 # that is generated.  The stamp files are numbered to have different names.
@@ -555,15 +602,12 @@
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,
-# Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # AM_PROG_INSTALL_SH
 # ------------------
 # Define $install_sh.
@@ -577,16 +621,14 @@
     install_sh="\${SHELL} $am_aux_dir/install-sh"
   esac
 fi
-AC_SUBST(install_sh)])
+AC_SUBST([install_sh])])
 
-# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2003-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 2
-
 # Check whether the underlying file-system supports filenames
 # with a leading dot.  For instance MS-DOS doesn't.
 AC_DEFUN([AM_SET_LEADING_DOT],
@@ -602,14 +644,12 @@
 
 # Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 4
-
 # AM_MAKE_INCLUDE()
 # -----------------
 # Check to see how make treats includes.
@@ -627,7 +667,7 @@
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
+# Ignore all kinds of additional output from 'make'.
 case `$am_make -s -f confmf 2> /dev/null` in #(
 *the\ am__doit\ target*)
   am__include=include
@@ -652,52 +692,14 @@
 rm -f confinc confmf
 ])
 
-# Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 6
-
-# AM_PROG_CC_C_O
-# --------------
-# Like AC_PROG_CC_C_O, but changed for automake.
-AC_DEFUN([AM_PROG_CC_C_O],
-[AC_REQUIRE([AC_PROG_CC_C_O])dnl
-AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-AC_REQUIRE_AUX_FILE([compile])dnl
-# FIXME: we rely on the cache variable name because
-# there is no other way.
-set dummy $CC
-am_cc=`echo $[2] | sed ['s/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/']`
-eval am_t=\$ac_cv_prog_cc_${am_cc}_c_o
-if test "$am_t" != yes; then
-   # Losing compiler, so override with the script.
-   # FIXME: It is wrong to rewrite CC.
-   # But if we don't then we get into trouble of one sort or another.
-   # A longer-term fix would be to have automake use am__CC in this case,
-   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
-   CC="$am_aux_dir/compile $CC"
-fi
-dnl Make sure AC_PROG_CC is never called again, or it will override our
-dnl setting of CC.
-m4_define([AC_PROG_CC],
-          [m4_fatal([AC_PROG_CC cannot be called after AM_PROG_CC_C_O])])
-])
-
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1997-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 6
-
 # AM_MISSING_PROG(NAME, PROGRAM)
 # ------------------------------
 AC_DEFUN([AM_MISSING_PROG],
@@ -705,11 +707,10 @@
 $1=${$1-"${am_missing_run}$2"}
 AC_SUBST($1)])
 
-
 # AM_MISSING_HAS_RUN
 # ------------------
-# Define MISSING if not defined so far and test if it supports --run.
-# If it does, set am_missing_run to use it, otherwise, to nothing.
+# Define MISSING if not defined so far and test if it is modern enough.
+# If it is, set am_missing_run to use it, otherwise, to nothing.
 AC_DEFUN([AM_MISSING_HAS_RUN],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
 AC_REQUIRE_AUX_FILE([missing])dnl
@@ -722,54 +723,22 @@
   esac
 fi
 # Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
+if eval "$MISSING --is-lightweight"; then
+  am_missing_run="$MISSING "
 else
   am_missing_run=
-  AC_MSG_WARN([`missing' script is too old or missing])
+  AC_MSG_WARN(['missing' script is too old or missing])
 fi
 ])
 
-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,
-# Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 1
-
-# AM_PROG_MKDIR_P
-# ---------------
-# Check for `mkdir -p'.
-AC_DEFUN([AM_PROG_MKDIR_P],
-[AC_PREREQ([2.60])dnl
-AC_REQUIRE([AC_PROG_MKDIR_P])dnl
-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
-dnl while keeping a definition of mkdir_p for backward compatibility.
-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
-dnl Makefile.ins that do not define MKDIR_P, so we do our own
-dnl adjustment using top_builddir (which is defined more often than
-dnl MKDIR_P).
-AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
-case $mkdir_p in
-  [[\\/$]]* | ?:[[\\/]]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-])
-
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
-
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
 AC_DEFUN([_AM_MANGLE_OPTION],
@@ -779,7 +748,7 @@
 # --------------------
 # Set option NAME.  Presently that only means defining a flag for this option.
 AC_DEFUN([_AM_SET_OPTION],
-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+[m4_define(_AM_MANGLE_OPTION([$1]), [1])])
 
 # _AM_SET_OPTIONS(OPTIONS)
 # ------------------------
@@ -793,24 +762,82 @@
 AC_DEFUN([_AM_IF_OPTION],
 [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
 
-# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
-# Free Software Foundation, Inc.
+# _AM_PROG_CC_C_O
+# ---------------
+# Like AC_PROG_CC_C_O, but changed for automake.  We rewrite AC_PROG_CC
+# to automatically call this.
+AC_DEFUN([_AM_PROG_CC_C_O],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([compile])dnl
+AC_LANG_PUSH([C])dnl
+AC_CACHE_CHECK(
+  [whether $CC understands -c and -o together],
+  [am_cv_prog_cc_c_o],
+  [AC_LANG_CONFTEST([AC_LANG_PROGRAM([])])
+  # Make sure it works both with $CC and with simple cc.
+  # Following AC_PROG_CC_C_O, we do the test twice because some
+  # compilers refuse to overwrite an existing .o file with -o,
+  # though they will create one.
+  am_cv_prog_cc_c_o=yes
+  for am_i in 1 2; do
+    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \
+         && test -f conftest2.$ac_objext; then
+      : OK
+    else
+      am_cv_prog_cc_c_o=no
+      break
+    fi
+  done
+  rm -f core conftest*
+  unset am_i])
+if test "$am_cv_prog_cc_c_o" != yes; then
+   # Losing compiler, so override with the script.
+   # FIXME: It is wrong to rewrite CC.
+   # But if we don't then we get into trouble of one sort or another.
+   # A longer-term fix would be to have automake use am__CC in this case,
+   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
+   CC="$am_aux_dir/compile $CC"
+fi
+AC_LANG_POP([C])])
+
+# For backward compatibility.
+AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# AM_RUN_LOG(COMMAND)
+# -------------------
+# Run COMMAND, save the exit status in ac_status, and log it.
+# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)
+AC_DEFUN([AM_RUN_LOG],
+[{ echo "$as_me:$LINENO: $1" >&AS_MESSAGE_LOG_FD
+   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   (exit $ac_status); }])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # AM_SANITY_CHECK
 # ---------------
 AC_DEFUN([AM_SANITY_CHECK],
 [AC_MSG_CHECKING([whether build environment is sane])
-# Just in case
-sleep 1
-echo timestamp > conftest.file
 # Reject unsafe characters in $srcdir or the absolute working directory
 # name.  Accept space and tab only in the latter.
 am_lf='
@@ -821,32 +848,40 @@
 esac
 case $srcdir in
   *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
+    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;
 esac
 
-# Do `set' in a subshell so we don't clobber the current shell's
+# Do 'set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$[*]" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$[*]" != "X $srcdir/configure conftest.file" \
-      && test "$[*]" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
-alias in your environment])
-   fi
-
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$[*]" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$[*]" != "X $srcdir/configure conftest.file" \
+	&& test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment])
+     fi
+     if test "$[2]" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
    test "$[2]" = conftest.file
    )
 then
@@ -856,46 +891,118 @@
    AC_MSG_ERROR([newly created file is older than distributed files!
 Check your system clock])
 fi
-AC_MSG_RESULT(yes)])
+AC_MSG_RESULT([yes])
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+AC_CONFIG_COMMANDS_PRE(
+  [AC_MSG_CHECKING([that generated files are newer than configure])
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   AC_MSG_RESULT([done])])
+rm -f conftest.file
+])
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2009-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# AM_SILENT_RULES([DEFAULT])
+# --------------------------
+# Enable less verbose build rules; with the default set to DEFAULT
+# ("yes" being less verbose, "no" or empty being verbose).
+AC_DEFUN([AM_SILENT_RULES],
+[AC_ARG_ENABLE([silent-rules], [dnl
+AS_HELP_STRING(
+  [--enable-silent-rules],
+  [less verbose build output (undo: "make V=1")])
+AS_HELP_STRING(
+  [--disable-silent-rules],
+  [verbose build output (undo: "make V=0")])dnl
+])
+case $enable_silent_rules in @%:@ (((
+  yes) AM_DEFAULT_VERBOSITY=0;;
+   no) AM_DEFAULT_VERBOSITY=1;;
+    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;
+esac
+dnl
+dnl A few 'make' implementations (e.g., NonStop OS and NextStep)
+dnl do not support nested variable expansions.
+dnl See automake bug#9928 and bug#10237.
+am_make=${MAKE-make}
+AC_CACHE_CHECK([whether $am_make supports nested variables],
+   [am_cv_make_support_nested_variables],
+   [if AS_ECHO([['TRUE=$(BAR$(V))
+BAR0=false
+BAR1=true
+V=1
+am__doit:
+	@$(TRUE)
+.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then
+  am_cv_make_support_nested_variables=yes
+else
+  am_cv_make_support_nested_variables=no
+fi])
+if test $am_cv_make_support_nested_variables = yes; then
+  dnl Using '$V' instead of '$(V)' breaks IRIX make.
+  AM_V='$(V)'
+  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
+else
+  AM_V=$AM_DEFAULT_VERBOSITY
+  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY
+fi
+AC_SUBST([AM_V])dnl
+AM_SUBST_NOTMAKE([AM_V])dnl
+AC_SUBST([AM_DEFAULT_V])dnl
+AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl
+AC_SUBST([AM_DEFAULT_VERBOSITY])dnl
+AM_BACKSLASH='\'
+AC_SUBST([AM_BACKSLASH])dnl
+_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl
+])
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # AM_PROG_INSTALL_STRIP
 # ---------------------
-# One issue with vendor `install' (even GNU) is that you can't
+# One issue with vendor 'install' (even GNU) is that you can't
 # specify the program used to strip binaries.  This is especially
 # annoying in cross-compiling environments, where the build's strip
 # is unlikely to handle the host's binaries.
 # Fortunately install-sh will honor a STRIPPROG variable, so we
-# always use install-sh in `make install-strip', and initialize
+# always use install-sh in "make install-strip", and initialize
 # STRIPPROG with the value of the STRIP variable (set by the user).
 AC_DEFUN([AM_PROG_INSTALL_STRIP],
 [AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
 # tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+# will honor the 'STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.
 if test "$cross_compiling" != no; then
   AC_CHECK_TOOL([STRIP], [strip], :)
 fi
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.
+# Copyright (C) 2006-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 3
-
 # _AM_SUBST_NOTMAKE(VARIABLE)
 # ---------------------------
 # Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
@@ -909,18 +1016,16 @@
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.
+# Copyright (C) 2004-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 2
-
 # _AM_PROG_TAR(FORMAT)
 # --------------------
 # Check how to create a tarball in format FORMAT.
-# FORMAT should be one of `v7', `ustar', or `pax'.
+# FORMAT should be one of 'v7', 'ustar', or 'pax'.
 #
 # Substitute a variable $(am__tar) that is a command
 # writing to stdout a FORMAT-tarball containing the directory
@@ -930,76 +1035,114 @@
 # Substitute a variable $(am__untar) that extract such
 # a tarball read from stdin.
 #     $(am__untar) < result.tar
+#
 AC_DEFUN([_AM_PROG_TAR],
 [# Always define AMTAR for backward compatibility.  Yes, it's still used
 # in the wild :-(  We should find a proper way to deprecate it ...
 AC_SUBST([AMTAR], ['$${TAR-tar}'])
-m4_if([$1], [v7],
-     [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
-     [m4_case([$1], [ustar],, [pax],,
-              [m4_fatal([Unknown tar format])])
-AC_MSG_CHECKING([how to create a $1 tar archive])
-# Loop over all known methods to create a tar archive until one works.
+
+# We'll loop over all known methods to create a tar archive until one works.
 _am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
-_am_tools=${am_cv_prog_tar_$1-$_am_tools}
-# Do not fold the above two line into one, because Tru64 sh and
-# Solaris sh will not grok spaces in the rhs of `-'.
-for _am_tool in $_am_tools
-do
-  case $_am_tool in
-  gnutar)
-    for _am_tar in tar gnutar gtar;
-    do
-      AM_RUN_LOG([$_am_tar --version]) && break
-    done
-    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
-    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
-    am__untar="$_am_tar -xf -"
-    ;;
-  plaintar)
-    # Must skip GNU tar: if it does not support --format= it doesn't create
-    # ustar tarball either.
-    (tar --version) >/dev/null 2>&1 && continue
-    am__tar='tar chf - "$$tardir"'
-    am__tar_='tar chf - "$tardir"'
-    am__untar='tar xf -'
-    ;;
-  pax)
-    am__tar='pax -L -x $1 -w "$$tardir"'
-    am__tar_='pax -L -x $1 -w "$tardir"'
-    am__untar='pax -r'
-    ;;
-  cpio)
-    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
-    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
-    am__untar='cpio -i -H $1 -d'
-    ;;
-  none)
-    am__tar=false
-    am__tar_=false
-    am__untar=false
-    ;;
-  esac
 
-  # If the value was cached, stop now.  We just wanted to have am__tar
-  # and am__untar set.
-  test -n "${am_cv_prog_tar_$1}" && break
+m4_if([$1], [v7],
+  [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
 
-  # tar/untar a dummy directory, and stop if the command works
-  rm -rf conftest.dir
-  mkdir conftest.dir
-  echo GrepMe > conftest.dir/file
-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  [m4_case([$1],
+    [ustar],
+     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.
+      # There is notably a 21 bits limit for the UID and the GID.  In fact,
+      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343
+      # and bug#13588).
+      am_max_uid=2097151 # 2^21 - 1
+      am_max_gid=$am_max_uid
+      # The $UID and $GID variables are not portable, so we need to resort
+      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls
+      # below are definitely unexpected, so allow the users to see them
+      # (that is, avoid stderr redirection).
+      am_uid=`id -u || echo unknown`
+      am_gid=`id -g || echo unknown`
+      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])
+      if test $am_uid -le $am_max_uid; then
+         AC_MSG_RESULT([yes])
+      else
+         AC_MSG_RESULT([no])
+         _am_tools=none
+      fi
+      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])
+      if test $am_gid -le $am_max_gid; then
+         AC_MSG_RESULT([yes])
+      else
+        AC_MSG_RESULT([no])
+        _am_tools=none
+      fi],
+
+  [pax],
+    [],
+
+  [m4_fatal([Unknown tar format])])
+
+  AC_MSG_CHECKING([how to create a $1 tar archive])
+
+  # Go ahead even if we have the value already cached.  We do so because we
+  # need to set the values for the 'am__tar' and 'am__untar' variables.
+  _am_tools=${am_cv_prog_tar_$1-$_am_tools}
+
+  for _am_tool in $_am_tools; do
+    case $_am_tool in
+    gnutar)
+      for _am_tar in tar gnutar gtar; do
+        AM_RUN_LOG([$_am_tar --version]) && break
+      done
+      am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+      am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+      am__untar="$_am_tar -xf -"
+      ;;
+    plaintar)
+      # Must skip GNU tar: if it does not support --format= it doesn't create
+      # ustar tarball either.
+      (tar --version) >/dev/null 2>&1 && continue
+      am__tar='tar chf - "$$tardir"'
+      am__tar_='tar chf - "$tardir"'
+      am__untar='tar xf -'
+      ;;
+    pax)
+      am__tar='pax -L -x $1 -w "$$tardir"'
+      am__tar_='pax -L -x $1 -w "$tardir"'
+      am__untar='pax -r'
+      ;;
+    cpio)
+      am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+      am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+      am__untar='cpio -i -H $1 -d'
+      ;;
+    none)
+      am__tar=false
+      am__tar_=false
+      am__untar=false
+      ;;
+    esac
+
+    # If the value was cached, stop now.  We just wanted to have am__tar
+    # and am__untar set.
+    test -n "${am_cv_prog_tar_$1}" && break
+
+    # tar/untar a dummy directory, and stop if the command works.
+    rm -rf conftest.dir
+    mkdir conftest.dir
+    echo GrepMe > conftest.dir/file
+    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+    rm -rf conftest.dir
+    if test -s conftest.tar; then
+      AM_RUN_LOG([$am__untar <conftest.tar])
+      AM_RUN_LOG([cat conftest.dir/file])
+      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+    fi
+  done
   rm -rf conftest.dir
-  if test -s conftest.tar; then
-    AM_RUN_LOG([$am__untar <conftest.tar])
-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
-  fi
-done
-rm -rf conftest.dir
 
-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
-AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+  AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+
 AC_SUBST([am__tar])
 AC_SUBST([am__untar])
 ]) # _AM_PROG_TAR
diff -Naur orig/ChangeLog patched/ChangeLog
--- orig/ChangeLog	2012-03-28 21:23:56.000000000 +0200
+++ patched/ChangeLog	2014-04-12 21:16:28.000000000 +0200
@@ -1,6 +1,304 @@
 This is top-level ChangeLog. It describes changes in application, without
-delving into details at source code level. See src/ChangeLog for details on
-changes in source files.
+delving into details at source code level. src/ChangeLog file is no longer
+updated. See commit messages for details on changes in source files.
+
+2014-04-12 Kamil Ignacak
+	* file system: until now if in a given directory there was a
+	directory whose name is composed only of underscores ('_'), it
+	will be put by scandir() at the beginning of 'eps' list, before
+	'..' - this was an incorrect behaviour and it has been fixed today
+	in cdw_fs module.
+	* review of changes: today I have completed review of changes in
+	source code between cdw 0.7.1 and HEAD. Next step in tests will be
+	testing cdw with valgrind (again) and then functional tests.
+
+2014-04-06 Kamil Ignacak
+	* proceeding with review of changes in source code as part of
+	pre-release checks.
+	* xorriso and mkisofs code: unconditionally including ISO9660 meta
+	information - it is now included when creating stand-alone ISO9660
+	image, and when burning disc from files.
+	* xorriso regex code: adding code for catching one more error
+	message.
+	* xorriso: fixing "speed" parameter for "burn from image" and
+	"erase" task.
+
+2014-03-22 Kamil Ignacak
+	* fixing some problems with memory deallocation discovered by
+	using valgrind.
+
+	The fact that I'm using valgrind means that I'm done with features
+	and I'm slowly getting closer to a release.
+
+2014-03-15 Kamil Ignacak
+	* cdw_erase_t: new data structure declared in cdw_erase_disc.h
+	that collects options related in erasing of discs. Used in both
+	cdw_task_t and cdw_config_t. Also adding a set of basic functions
+	that operate on variables of this type.
+
+2014-03-12 Kamil Ignacak
+	* widget drivers: one step closer to removing old code that
+	controlled keys presses in widgets. The code handling old-style
+	widget drivers has been disabled/removed in cdw_form module, and
+	most, if not all, of the old code in widgets themselves has been
+	removed as well.
+
+2014-03-10 Kamil Ignacak
+	* cdw_write_t: Declaration of 'burn' structure (now cdw_write_t)
+	and some constants moved from cdw_task.h to cdw_burn_disc.h. The
+	structure has been reorganized a bit, so this will cause some
+	changes in other files.
+
+	The change is similar to previous change in 'create image' data
+	structure: some bits of data moved to other, more appropriate
+	places (cdw_iso9660.h, cdw_udf.h), code handling the data moved to
+	appropriate modules. Data structures and code handling them shared
+	between 'cdw task' module and 'config variable' module. More of
+	reuse of code.
+
+2014-03-02 Kamil Ignacak
+	* UDF: Added missing piece of UDF creation procedure: if volume
+	size should be equal to size of disc in drive, there should be a
+	step that checks the size of disc. This has been added today in
+	cdw_create_image_udf().
+
+	Also modified additional delay after completion of "sync"
+	command. There is (and was) a constant delay of X seconds, and now
+	it's increased by factor proportional to length of number
+	describing size of selected (and copied into UDF file system)
+	files.
+
+2014-02-28 Kamil Ignacak
+	* UI: Displaying additional information about (not) following
+	symlinks in volume information area in main window. This
+	information indicates whether calculated size of selected files
+	includes size of symlinked files or not.
+
+	* config file: Names of some options in configuration file have
+	been made more verbose. Changes in functions reading and writing
+	the config file reflect this. A certain degree of backwards
+	compatibility is maintained. New cdw will be able (for some time
+	into future) to read old config files, and will be able (for some
+	time into future) to write backwards-compatible config file.
+
+	* config file: general.display_hidden_files option is now saved in
+	config file.
+
+	* configuration: Two options: general.selected_follow_symlinks and
+	iso9660.follow_symlinks are now completely separate. First one
+	only affects calculating size of selected files by cdw, the other
+	only affects working of mkisofs or xorriso. User will have to be
+	sure that the options are in sync.
+
+	Until now it was easy to use the same variable for "when
+	calculating size of selected files follow symlinks" feature and
+	mkisofs'/xorriso's "follow symlinks in ISO9660 file system"
+	function. But after adding support for UDF file system things got
+	more complicated. Files are copied to UDF fs with rsync, and
+	rsync's options for handling symbolic links are much more
+	complicated than "follow" vs. "don't follow". I can't keep an eye
+	on all of rsync's options, so user has to provide an options
+	string on his own. And since I can't control how symlinks are
+	handled by rsync, I can't make the link between "when calculating
+	size of selected files follow symlinks" feature and rsync's
+	symlinks handling options. Therefore I decided to break the link
+	for ISO9660.
+
+2014-02-24 Kamil Ignacak
+	* drives: Made change in cdw_cdio_drives to handle one problematic
+	situation, when an ISO image has been mounted by root user.
+	libcdio sees the mounted image as a drive, but cannot get its
+	capabilities. Until now it caused error, now it is handled
+	properly (the "drive" is not shown on list of drives available to
+	cdw).
+
+	* native file system: one important change in
+	cdw_fs_shorten_fullpath(): a full path to a directory shall not
+	end with a slash (a name of directory shall not end with
+	slash). This change is made to ensure that lstat() in code
+	calculating size of selected files receives
+	"/path/to/symlink/to/directory" rather than
+	"/path/to/symlink/to/directory/". That way the path is correctly
+	recognized as symlink.
+
+2014-02-23 Kamil Ignacak
+	* creating UDF image: using cdw_selecte_files_search() to perform
+	additional test in validation function: checking if UDF mount
+	point is on list of selected files. If it is, an error is
+	reported.  The cdw_selecte_files_search() function is very, very
+	basic, but this basic test works.
+	Checking if rsync options string is empty, and printing warning
+	when it is.
+
+2014-02-18 Kamil Ignacak
+	* UDF, config: adding writing of UDF options to configuration
+	file, and reading the options from the file. It still needs some
+	work and fixing, but it should be usable soon.
+
+2014-02-17 Kamil Ignacak
+	* ISO9660: Since I've created a separate cdw_iso9660_t type, I can
+	now use it in more places. This time in cdw_config_t, where the
+	data type replaces a set of separate variables. The code in
+	cdw_config.c operating on these separate variables has been
+	replaced with calls to functions from cdw_iso9660 module. More of
+	code reuse = profit!
+
+2014-02-16 Kamil Ignacak
+	* unifying paths to image file that are used in two different
+	places: path leading to newly created image file, and path to
+	image file intended to be written to optical disc. Now the two
+	paths are represented by the same variable, so now it's certain
+	that when user in first step creates ISO9660 image file, and then
+	intends in second step to burn an image to disc, the default path
+	to the file in step two will be exactly the same as in step one.
+
+2014-02-14 Kamil Ignacak
+	* UDF: cdw_create_image_udf(): added checking of exit status of a
+	child process.  Any error reported by external tool, and not
+	caught by regex code, will be handled by cdw by catching exit code
+	of child process.
+
+2014-02-12 Kamil Ignacak
+	* User interface: added "About" item to main menu. When selecting
+	this item, cdw displays dialog window with program's version,
+	copyright notice and short license information.
+
+2014-02-09 Kamil Ignacak
+	* UDF: one of steps in creating UDF image is copying files to UDF
+	file system. cdw performs this step using rsync. Thus cdw
+	"recommends" rsync - otherwise creating UDF images won't be
+	possible.
+	I may decide to also implement copying files with cp, but this is
+	still to be decided.
+
+	cdw now contains initial implementation of functions that perform
+	all steps of recipe for creating UDF image. Two of the steps are
+	"sudo mount" and "sudo umount". Both commands need to be defined
+	in sudoers, and both need to be executed without prompting for
+	password (since cdw won't ask user for password). This is
+	mentioned in help text in Configuration window.
+
+	* symlinks: in the course of adding support for rsync I realized
+	that I can't reasonably cover all possible combinations of flags
+	for handling symbolic links in rsync. This is why I have added
+	"rsync options" field in image wizard options. This will be the
+	place where user will decide how and what rsync copies into UDF
+	file system.
+
+	This also means that the role of "follow symbolic links" option in
+	Configuration window should be limited only to deciding how to
+	calculate size of selected files - either naively follow all
+	symbolic links, or naively don't follow links. More sophisticated
+	control of (not) following symbolic links should be left to
+	user. In case of ISO9660/mkisofs this is just a matter of marking
+	one checkbox (mkisofs' option -l), but in case of rsync this is
+	much, much more complicated.
+
+	If I ever decide to add support for "cp", I will also have to
+	create "cp options" field where user will be able to control
+	handling of symlinks by cp. I checked this only briefly, but cp
+	gives less options than rsync, but certainly more than mkisofs.
+
+	I can't reasonably provide checkboxes and dropdowns for all
+	possible scenarios of handling symlinks - this will have to be
+	done in "cp/rsync options" text input field.
+
+2014-02-07 Kamil Ignacak
+	* UDF: added a new page to Configuration window, with some
+	information about what is needed to create UDF image (which tools
+	are used).
+
+2014-02-05 Kamil Ignacak
+	* task IDs: a generic task ID CDW_TASK_CREATE_IMAGE has been
+	replaced with CDW_TASK_CREATE_IMAGE_ISO9660 and
+	CDW_TASK_CREATE_IMAGE_UDF. It become necessary to make a
+	distinction between those two tasks. In some places there should
+	be two separate paths for the two tasks.
+	* UDF: I'm continuing with implementation of support for UDF. New
+	module: cdw_mkudffs_helpers has been created for tools that are
+	used as helpers in process of creating image (truncate,
+	mount/umount, etc.).
+
+2014-01-30 Kamil Ignacak
+	* UDF: UDF options in image wizard are now read from task variable
+	when creating the options pages, and saved to a task variable when
+	performing creation of an image.
+
+	For now UDF options are stored only to a master_task variable in
+	cdw_task module, they aren't stored to a global configuration
+	variable, nor to a disk file.
+
+	The cdw_task module now requires initialization (the master_task
+	variable is initialized with default values of mkudffs options).
+
+	* widgets: CDW_CHECKBOX now supports the new style driver function.
+
+	* cdw_form: updated the form code and widget driver functions so
+	that they can be used in configuration window as well (may be, but
+	aren't used fully yet). Now the special keys in configuration
+	window (i.e. F_X keys used for switching between panels) are
+	handled correctly.
+
+2014-01-27 Kamil Ignacak
+	* widgets: I have shortened list of widgets IDs in cdw_widgets.h,
+	updated the names so that they are clearly IDs of widgets, and
+	used the changed names in whole source code tree. I just have to
+	remove cdw_input_line module from Makefile.am.
+
+2014-01-26 Kamil Ignacak
+	* Image wizard: finished changes in main page of image wizard -
+	the page is now able to support both ISO9660 and UDF image
+	formats. Now I can focus on pages for options, visible after
+	pressing "More options".
+
+	Source file for the wizard has been changed from
+	cdw_iso9660_wizard to cdw_image_wizard, since the wizard is no
+	longer ISO9660-only. The old file (cdw_iso9660_wizard) will be
+	kept in repository to preserve changes history.
+
+2014-01-25 Kamil Ignacak
+	* widgets: two new modules in src/user_interface/widgets:
+	cdw_safe_input_line (derived from cdw_input_line) and
+	cdw_dynamic_label. The modules implement new widgets that support
+	->driver() function. The widgets and the function are used in
+	image wizard window, but introducing them also affected cdw_form
+	module. In theory the new widgets should make implementation of
+	drivers in other parts of cdw easier.
+
+	The dynamic label module makes it possible to easily implement
+	area where error message about insecure characters is displayed.
+	Imagine an input field, where user entered some insecure
+	character. cdw_input_line widget displayed the error message in
+	one-line form field/subwindow below the input line, and the form
+	field was an integral part of the cdw_input_line. With the dynamic
+	label module, I can display the error message in place of a
+	regular label that usually accompanies input field - the label is
+	located before or above the input field.
+
+2014-01-22 Kamil Ignacak
+	* UDF: updating ISO9660 image wizard with selector of image file
+	format. There will be "UDF" item that can be selected from
+	dropdown if "external tools" module will detect necessary tools
+	installed on user's system.
+
+2014-01-20 Kamil Ignacak
+	* Child exit status: initial modifications for improved handling
+	of exit status of child processes (this was totally neglected
+	until now). The change is a result of talks with user rogerx about
+	supporting UFD file format. This would require calling some new
+	external tools. In order to limit amount of new code for parsing
+	their stdout and stderr (at least initially), I would rather try
+	to handle their exit statuses to determine success/failure of
+	their actions.
+
+2014-01-19 Kamil Ignacak
+	* Updating FSF address in copyright header of *.c files (problem
+	reported by Sergio Belkin).
+	* Integrating cdw_ld_as_needed.diff patch from Debian.
+	* Updating invocation of AM_INIT_AUTOMAKE in configure.ac.
+	* Compiler reported clashes between PACKAGE, VERSION and some
+	other names from cdw's config.h and libcdio's header files. This
+	has been fixed in one of today's commits.
 
 2012-03-28 Kamil Ignacak
 	* gettext: updating gettext information and cdw.pot template file;
diff -Naur orig/config_cdw.h.in patched/config_cdw.h.in
--- orig/config_cdw.h.in	1970-01-01 01:00:00.000000000 +0100
+++ patched/config_cdw.h.in	2014-01-23 22:33:16.000000000 +0100
@@ -0,0 +1,355 @@
+/* config_cdw.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Checking binary dir... */
+#undef CDWDIR
+
+/* Checking common licenses dir... */
+#undef COMMON
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#undef CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#undef C_ALLOCA
+
+/* Checking docdir... */
+#undef DOCDIR
+
+/* gnulib provides canonicalize_filename_mode() */
+#undef GNULIB_CANONICALIZE
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#undef HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#undef HAVE_ALLOCA_H
+
+/* Define to 1 if you have the `asprintf' function. */
+#undef HAVE_ASPRINTF
+
+/* Define to 1 if you have the `canonicalize_file_name' function. */
+#undef HAVE_CANONICALIZE_FILE_NAME
+
+/* Define to 1 if you have the <cdio/cdio.h> header file. */
+#undef HAVE_CDIO_CDIO_H
+
+/* Define to 1 if you have the <cdio/iso9660.h> header file. */
+#undef HAVE_CDIO_ISO9660_H
+
+/* Define to 1 if you have the <cdio/mmc.h> header file. */
+#undef HAVE_CDIO_MMC_H
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_DIRENT_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the `floor' function. */
+#undef HAVE_FLOOR
+
+/* Define to 1 if you have the `fork' function. */
+#undef HAVE_FORK
+
+/* Define to 1 if you have the <form.h> header file. */
+#undef HAVE_FORM_H
+
+/* Define to 1 if you have the `getmntent' function. */
+#undef HAVE_GETMNTENT
+
+/* Define to 1 if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define to 1 if you have the `getpass' function. */
+#undef HAVE_GETPASS
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#undef HAVE_LIBINTL_H
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
+/* Define to 1 if `lstat' has the bug that it succeeds when given the
+   zero-length file name argument. */
+#undef HAVE_LSTAT_EMPTY_STRING_BUG
+
+/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
+   to 0 otherwise. */
+#undef HAVE_MALLOC
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#undef HAVE_MALLOC_H
+
+/* Define to 1 if you have the `memmove' function. */
+#undef HAVE_MEMMOVE
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `mempcpy' function. */
+#undef HAVE_MEMPCPY
+
+/* Define to 1 if you have the `memset' function. */
+#undef HAVE_MEMSET
+
+/* Define to 1 if you have the <menu.h> header file. */
+#undef HAVE_MENU_H
+
+/* Define to 1 if you have the `mkdir' function. */
+#undef HAVE_MKDIR
+
+/* Define to 1 if you have a working `mmap' system call. */
+#undef HAVE_MMAP
+
+/* Define to 1 if you have the <mntent.h> header file. */
+#undef HAVE_MNTENT_H
+
+/* Define to 1 if you have the <ncursesw/form.h> header file. */
+#undef HAVE_NCURSESW_FORM_H
+
+/* Define to 1 if you have the <ncursesw/menu.h> header file. */
+#undef HAVE_NCURSESW_MENU_H
+
+/* Define to 1 if you have the <ncursesw/ncurses.h> header file. */
+#undef HAVE_NCURSESW_NCURSES_H
+
+/* Define to 1 if you have the <ncursesw/panel.h> header file. */
+#undef HAVE_NCURSESW_PANEL_H
+
+/* Define to 1 if you have the <ncurses.h> header file. */
+#undef HAVE_NCURSES_H
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+#undef HAVE_NDIR_H
+
+/* Define to 1 if you have the <nl_types.h> header file. */
+#undef HAVE_NL_TYPES_H
+
+/* Define to 1 if you have the <panel.h> header file. */
+#undef HAVE_PANEL_H
+
+/* Define to 1 if you have the `pathconf' function. */
+#undef HAVE_PATHCONF
+
+/* Define to 1 if the system has the type `ptrdiff_t'. */
+#undef HAVE_PTRDIFF_T
+
+/* Define to 1 if your system has a GNU libc compatible `realloc' function,
+   and to 0 otherwise. */
+#undef HAVE_REALLOC
+
+/* Define to 1 if you have the `realpath' function. */
+#undef HAVE_REALPATH
+
+/* Define to 1 if you have the `regcomp' function. */
+#undef HAVE_REGCOMP
+
+/* Define to 1 if you have the `resolvepath' function. */
+#undef HAVE_RESOLVEPATH
+
+/* Define to 1 if you have the `setenv' function. */
+#undef HAVE_SETENV
+
+/* Define to 1 if you have the `setlocale' function. */
+#undef HAVE_SETLOCALE
+
+/* Define to 1 if `stat' has the bug that it succeeds when given the
+   zero-length file name argument. */
+#undef HAVE_STAT_EMPTY_STRING_BUG
+
+/* Define to 1 if stdbool.h conforms to C99. */
+#undef HAVE_STDBOOL_H
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#undef HAVE_STDDEF_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `strdup' function. */
+#undef HAVE_STRDUP
+
+/* Define to 1 if you have the `strerror' function. */
+#undef HAVE_STRERROR
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#undef HAVE_STRNCASECMP
+
+/* Define to 1 if you have the `strndup' function. */
+#undef HAVE_STRNDUP
+
+/* Define to 1 if you have the `strpbrk' function. */
+#undef HAVE_STRPBRK
+
+/* Define to 1 if you have the `strrchr' function. */
+#undef HAVE_STRRCHR
+
+/* Define to 1 if you have the `strspn' function. */
+#undef HAVE_STRSPN
+
+/* Define to 1 if you have the `strtol' function. */
+#undef HAVE_STRTOL
+
+/* Define to 1 if `st_blksize' is a member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_BLKSIZE
+
+/* Define to 1 if `st_blocks' is a member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_BLOCKS
+
+/* Define to 1 if your `struct stat' has `st_blocks'. Deprecated, use
+   `HAVE_STRUCT_STAT_ST_BLOCKS' instead. */
+#undef HAVE_ST_BLOCKS
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_SYS_DIR_H
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_SYS_NDIR_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#undef HAVE_SYS_SOCKET_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#undef HAVE_SYS_WAIT_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the `vfork' function. */
+#undef HAVE_VFORK
+
+/* Define to 1 if you have the <vfork.h> header file. */
+#undef HAVE_VFORK_H
+
+/* Define to 1 if `fork' works. */
+#undef HAVE_WORKING_FORK
+
+/* Define to 1 if `vfork' works. */
+#undef HAVE_WORKING_VFORK
+
+/* Define to 1 if the system has the type `_Bool'. */
+#undef HAVE__BOOL
+
+/* Checking localdir... */
+#undef LOCALEDIR
+
+/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
+   slash. */
+#undef LSTAT_FOLLOWS_SLASHED_SYMLINK
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+#undef STACK_DIRECTION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT32_T
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT8_T
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to rpl_malloc if the replacement function should be used. */
+#undef malloc
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#undef off_t
+
+/* Define to `int' if <sys/types.h> does not define. */
+#undef pid_t
+
+/* Define to rpl_realloc if the replacement function should be used. */
+#undef realloc
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define to `int' if <sys/types.h> does not define. */
+#undef ssize_t
+
+/* Define to the type of an unsigned integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint16_t
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint32_t
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint8_t
+
+/* Define as `fork' if `vfork' does not work. */
+#undef vfork
diff -Naur orig/config.h.in patched/config.h.in
--- orig/config.h.in	2012-02-26 15:59:44.000000000 +0100
+++ patched/config.h.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,358 +0,0 @@
-/* config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Checking binary dir... */
-#undef CDWDIR
-
-/* Checking common licenses dir... */
-#undef COMMON
-
-/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
-   systems. This function is required for `alloca.c' support on those systems.
-   */
-#undef CRAY_STACKSEG_END
-
-/* Define to 1 if using `alloca.c'. */
-#undef C_ALLOCA
-
-/* Checking docdir... */
-#undef DOCDIR
-
-/* gnulib provides canonicalize_filename_mode() */
-#undef GNULIB_CANONICALIZE
-
-/* Define to 1 if you have `alloca', as a function or macro. */
-#undef HAVE_ALLOCA
-
-/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
-   */
-#undef HAVE_ALLOCA_H
-
-/* Define to 1 if you have the `asprintf' function. */
-#undef HAVE_ASPRINTF
-
-/* Define to 1 if you have the `canonicalize_file_name' function. */
-#undef HAVE_CANONICALIZE_FILE_NAME
-
-/* Define to 1 if you have the <cdio/cdio.h> header file. */
-#undef HAVE_CDIO_CDIO_H
-
-/* Define to 1 if you have the <cdio/iso9660.h> header file. */
-#undef HAVE_CDIO_ISO9660_H
-
-/* Define to 1 if you have the <cdio/mmc.h> header file. */
-#undef HAVE_CDIO_MMC_H
-
-/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_DIRENT_H
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#undef HAVE_FCNTL_H
-
-/* Define to 1 if you have the `floor' function. */
-#undef HAVE_FLOOR
-
-/* Define to 1 if you have the `fork' function. */
-#undef HAVE_FORK
-
-/* Define to 1 if you have the <form.h> header file. */
-#undef HAVE_FORM_H
-
-/* Define to 1 if you have the `getmntent' function. */
-#undef HAVE_GETMNTENT
-
-/* Define to 1 if you have the `getpagesize' function. */
-#undef HAVE_GETPAGESIZE
-
-/* Define to 1 if you have the `getpass' function. */
-#undef HAVE_GETPASS
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
-/* Define to 1 if you have the <libintl.h> header file. */
-#undef HAVE_LIBINTL_H
-
-/* Define to 1 if you have the <limits.h> header file. */
-#undef HAVE_LIMITS_H
-
-/* Define to 1 if you have the <locale.h> header file. */
-#undef HAVE_LOCALE_H
-
-/* Define to 1 if `lstat' has the bug that it succeeds when given the
-   zero-length file name argument. */
-#undef HAVE_LSTAT_EMPTY_STRING_BUG
-
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#undef HAVE_MALLOC
-
-/* Define to 1 if you have the <malloc.h> header file. */
-#undef HAVE_MALLOC_H
-
-/* Define to 1 if you have the `memmove' function. */
-#undef HAVE_MEMMOVE
-
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
-/* Define to 1 if you have the `mempcpy' function. */
-#undef HAVE_MEMPCPY
-
-/* Define to 1 if you have the `memset' function. */
-#undef HAVE_MEMSET
-
-/* Define to 1 if you have the <menu.h> header file. */
-#undef HAVE_MENU_H
-
-/* Define to 1 if you have the `mkdir' function. */
-#undef HAVE_MKDIR
-
-/* Define to 1 if you have a working `mmap' system call. */
-#undef HAVE_MMAP
-
-/* Define to 1 if you have the <mntent.h> header file. */
-#undef HAVE_MNTENT_H
-
-/* Define to 1 if you have the <ncursesw/form.h> header file. */
-#undef HAVE_NCURSESW_FORM_H
-
-/* Define to 1 if you have the <ncursesw/menu.h> header file. */
-#undef HAVE_NCURSESW_MENU_H
-
-/* Define to 1 if you have the <ncursesw/ncurses.h> header file. */
-#undef HAVE_NCURSESW_NCURSES_H
-
-/* Define to 1 if you have the <ncursesw/panel.h> header file. */
-#undef HAVE_NCURSESW_PANEL_H
-
-/* Define to 1 if you have the <ncurses.h> header file. */
-#undef HAVE_NCURSES_H
-
-/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
-#undef HAVE_NDIR_H
-
-/* Define to 1 if you have the <nl_types.h> header file. */
-#undef HAVE_NL_TYPES_H
-
-/* Define to 1 if you have the <panel.h> header file. */
-#undef HAVE_PANEL_H
-
-/* Define to 1 if you have the `pathconf' function. */
-#undef HAVE_PATHCONF
-
-/* Define to 1 if the system has the type `ptrdiff_t'. */
-#undef HAVE_PTRDIFF_T
-
-/* Define to 1 if your system has a GNU libc compatible `realloc' function,
-   and to 0 otherwise. */
-#undef HAVE_REALLOC
-
-/* Define to 1 if you have the `realpath' function. */
-#undef HAVE_REALPATH
-
-/* Define to 1 if you have the `regcomp' function. */
-#undef HAVE_REGCOMP
-
-/* Define to 1 if you have the `resolvepath' function. */
-#undef HAVE_RESOLVEPATH
-
-/* Define to 1 if you have the `setenv' function. */
-#undef HAVE_SETENV
-
-/* Define to 1 if you have the `setlocale' function. */
-#undef HAVE_SETLOCALE
-
-/* Define to 1 if `stat' has the bug that it succeeds when given the
-   zero-length file name argument. */
-#undef HAVE_STAT_EMPTY_STRING_BUG
-
-/* Define to 1 if stdbool.h conforms to C99. */
-#undef HAVE_STDBOOL_H
-
-/* Define to 1 if you have the <stddef.h> header file. */
-#undef HAVE_STDDEF_H
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the `strdup' function. */
-#undef HAVE_STRDUP
-
-/* Define to 1 if you have the `strerror' function. */
-#undef HAVE_STRERROR
-
-/* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the `strncasecmp' function. */
-#undef HAVE_STRNCASECMP
-
-/* Define to 1 if you have the `strndup' function. */
-#undef HAVE_STRNDUP
-
-/* Define to 1 if you have the `strpbrk' function. */
-#undef HAVE_STRPBRK
-
-/* Define to 1 if you have the `strrchr' function. */
-#undef HAVE_STRRCHR
-
-/* Define to 1 if you have the `strspn' function. */
-#undef HAVE_STRSPN
-
-/* Define to 1 if you have the `strtol' function. */
-#undef HAVE_STRTOL
-
-/* Define to 1 if `st_blksize' is a member of `struct stat'. */
-#undef HAVE_STRUCT_STAT_ST_BLKSIZE
-
-/* Define to 1 if `st_blocks' is a member of `struct stat'. */
-#undef HAVE_STRUCT_STAT_ST_BLOCKS
-
-/* Define to 1 if your `struct stat' has `st_blocks'. Deprecated, use
-   `HAVE_STRUCT_STAT_ST_BLOCKS' instead. */
-#undef HAVE_ST_BLOCKS
-
-/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_SYS_DIR_H
-
-/* Define to 1 if you have the <sys/ioctl.h> header file. */
-#undef HAVE_SYS_IOCTL_H
-
-/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_SYS_NDIR_H
-
-/* Define to 1 if you have the <sys/param.h> header file. */
-#undef HAVE_SYS_PARAM_H
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#undef HAVE_SYS_SOCKET_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
-#undef HAVE_SYS_WAIT_H
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
-/* Define to 1 if you have the `vfork' function. */
-#undef HAVE_VFORK
-
-/* Define to 1 if you have the <vfork.h> header file. */
-#undef HAVE_VFORK_H
-
-/* Define to 1 if `fork' works. */
-#undef HAVE_WORKING_FORK
-
-/* Define to 1 if `vfork' works. */
-#undef HAVE_WORKING_VFORK
-
-/* Define to 1 if the system has the type `_Bool'. */
-#undef HAVE__BOOL
-
-/* Checking localdir... */
-#undef LOCALEDIR
-
-/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
-   slash. */
-#undef LSTAT_FOLLOWS_SLASHED_SYMLINK
-
-/* Define to 1 if your C compiler doesn't accept -c and -o together. */
-#undef NO_MINUS_C_MINUS_O
-
-/* Name of package */
-#undef PACKAGE
-
-/* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
-
-/* Define to the full name of this package. */
-#undef PACKAGE_NAME
-
-/* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
-
-/* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
-
-/* Define to the home page for this package. */
-#undef PACKAGE_URL
-
-/* Define to the version of this package. */
-#undef PACKAGE_VERSION
-
-/* If using the C implementation of alloca, define if you know the
-   direction of stack growth for your system; otherwise it will be
-   automatically deduced at runtime.
-	STACK_DIRECTION > 0 => grows toward higher addresses
-	STACK_DIRECTION < 0 => grows toward lower addresses
-	STACK_DIRECTION = 0 => direction of growth unknown */
-#undef STACK_DIRECTION
-
-/* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
-
-/* Version number of package */
-#undef VERSION
-
-/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
-   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
-   #define below would cause a syntax error. */
-#undef _UINT32_T
-
-/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
-   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
-   #define below would cause a syntax error. */
-#undef _UINT8_T
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-#undef inline
-#endif
-
-/* Define to rpl_malloc if the replacement function should be used. */
-#undef malloc
-
-/* Define to `long int' if <sys/types.h> does not define. */
-#undef off_t
-
-/* Define to `int' if <sys/types.h> does not define. */
-#undef pid_t
-
-/* Define to rpl_realloc if the replacement function should be used. */
-#undef realloc
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-#undef size_t
-
-/* Define to `int' if <sys/types.h> does not define. */
-#undef ssize_t
-
-/* Define to the type of an unsigned integer type of width exactly 16 bits if
-   such a type exists and the standard includes do not define it. */
-#undef uint16_t
-
-/* Define to the type of an unsigned integer type of width exactly 32 bits if
-   such a type exists and the standard includes do not define it. */
-#undef uint32_t
-
-/* Define to the type of an unsigned integer type of width exactly 8 bits if
-   such a type exists and the standard includes do not define it. */
-#undef uint8_t
-
-/* Define as `fork' if `vfork' does not work. */
-#undef vfork
diff -Naur orig/configure patched/configure
--- orig/configure	2012-02-26 15:53:42.000000000 +0100
+++ patched/configure	2014-01-19 20:51:28.000000000 +0100
@@ -1,13 +1,11 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68 for cdw 0.7.1.
+# Generated by GNU Autoconf 2.69 for cdw 0.7.1.
 #
 # Report bugs to <acerion@wp.pl>.
 #
 #
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -136,6 +134,31 @@
 # CDPATH.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
 if test "x$CONFIG_SHELL" = x; then
   as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
@@ -169,7 +192,8 @@
 else
   exitcode=1; echo positional parameters were not saved.
 fi
-test x\$exitcode = x0 || exit 1"
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
   as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
@@ -214,21 +238,25 @@
 
 
       if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	# Preserve -v and -x to the replacement shell.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	case $- in # ((((
-	  *v*x* | *x*v* ) as_opts=-vx ;;
-	  *v* ) as_opts=-v ;;
-	  *x* ) as_opts=-x ;;
-	  * ) as_opts= ;;
-	esac
-	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
 fi
 
     if test x$as_have_required = xno; then :
@@ -331,6 +359,14 @@
 
 
 } # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
@@ -452,6 +488,10 @@
   chmod +x "$as_me.lineno" ||
     { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
   # original and so on.  Autoconf is especially sensitive to this).
@@ -486,16 +526,16 @@
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -507,28 +547,8 @@
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -635,6 +655,10 @@
 LDFLAGS
 CFLAGS
 CC
+AM_BACKSLASH
+AM_DEFAULT_VERBOSITY
+AM_DEFAULT_V
+AM_V
 am__untar
 am__tar
 AMTAR
@@ -699,6 +723,7 @@
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
+enable_silent_rules
 enable_dependency_tracking
 enable_debug
 '
@@ -1168,8 +1193,6 @@
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used" >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1329,8 +1352,12 @@
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors
+  --enable-silent-rules   less verbose build output (undo: "make V=1")
+  --disable-silent-rules  verbose build output (undo: "make V=0")
+  --enable-dependency-tracking
+                          do not reject slow dependency extractors
+  --disable-dependency-tracking
+                          speeds up one-time build
   --enable-debug          enable debug messages printed to stderr, include
                           debug info for gdb
 
@@ -1417,9 +1444,9 @@
 if $ac_init_version; then
   cat <<\_ACEOF
 cdw configure 0.7.1
-generated by GNU Autoconf 2.68
+generated by GNU Autoconf 2.69
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1495,7 +1522,7 @@
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
+	 test -x conftest$ac_exeext
        }; then :
   ac_retval=0
 else
@@ -1917,7 +1944,8 @@
 main ()
 {
 static int test_array [1 - 2 * !((($ac_type) -1 >> ($2 / 2 - 1)) >> ($2 / 2 - 1) == 3)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -1950,7 +1978,7 @@
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by cdw $as_me 0.7.1, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
@@ -2300,7 +2328,8 @@
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-am__api_version='1.11'
+
+am__api_version='1.14'
 
 ac_aux_dir=
 for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
@@ -2368,7 +2397,7 @@
     # by default.
     for ac_prog in ginstall scoinst install; do
       for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
 	  if test $ac_prog = install &&
 	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
 	    # AIX install.  It has an incompatible calling convention.
@@ -2426,9 +2455,6 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
 $as_echo_n "checking whether build environment is sane... " >&6; }
-# Just in case
-sleep 1
-echo timestamp > conftest.file
 # Reject unsafe characters in $srcdir or the absolute working directory
 # name.  Accept space and tab only in the latter.
 am_lf='
@@ -2439,32 +2465,40 @@
 esac
 case $srcdir in
   *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+    as_fn_error $? "unsafe srcdir value: '$srcdir'" "$LINENO" 5;;
 esac
 
-# Do `set' in a subshell so we don't clobber the current shell's
+# Do 'set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$*" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$*" != "X $srcdir/configure conftest.file" \
-      && test "$*" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" "$LINENO" 5
-   fi
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$*" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$*" != "X $srcdir/configure conftest.file" \
+	&& test "$*" != "X conftest.file $srcdir/configure"; then
 
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment" "$LINENO" 5
+     fi
+     if test "$2" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
    test "$2" = conftest.file
    )
 then
@@ -2476,6 +2510,16 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+
+rm -f conftest.file
+
 test "$program_prefix" != NONE &&
   program_transform_name="s&^&$program_prefix&;$program_transform_name"
 # Use a double $ so make ignores it.
@@ -2498,12 +2542,12 @@
   esac
 fi
 # Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
+if eval "$MISSING --is-lightweight"; then
+  am_missing_run="$MISSING "
 else
   am_missing_run=
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
-$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: 'missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: 'missing' script is too old or missing" >&2;}
 fi
 
 if test x"${install_sh}" != xset; then
@@ -2515,10 +2559,10 @@
   esac
 fi
 
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
 # tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
+# will honor the 'STRIP' environment variable to overrule this program.
 if test "$cross_compiling" != no; then
   if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
@@ -2537,7 +2581,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_STRIP="${ac_tool_prefix}strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2577,7 +2621,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_STRIP="strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2628,7 +2672,7 @@
   test -z "$as_dir" && as_dir=.
     for ac_prog in mkdir gmkdir; do
 	 for ac_exec_ext in '' $ac_executable_extensions; do
-	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext" || continue
 	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
 	     'mkdir (GNU coreutils) '* | \
 	     'mkdir (coreutils) '* | \
@@ -2657,12 +2701,6 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
 $as_echo "$MKDIR_P" >&6; }
 
-mkdir_p="$MKDIR_P"
-case $mkdir_p in
-  [\\/$]* | ?:[\\/]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-
 for ac_prog in gawk mawk nawk awk
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
@@ -2681,7 +2719,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_AWK="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2745,6 +2783,45 @@
 fi
 rmdir .tst 2>/dev/null
 
+# Check whether --enable-silent-rules was given.
+if test "${enable_silent_rules+set}" = set; then :
+  enableval=$enable_silent_rules;
+fi
+
+case $enable_silent_rules in # (((
+  yes) AM_DEFAULT_VERBOSITY=0;;
+   no) AM_DEFAULT_VERBOSITY=1;;
+    *) AM_DEFAULT_VERBOSITY=1;;
+esac
+am_make=${MAKE-make}
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $am_make supports nested variables" >&5
+$as_echo_n "checking whether $am_make supports nested variables... " >&6; }
+if ${am_cv_make_support_nested_variables+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if $as_echo 'TRUE=$(BAR$(V))
+BAR0=false
+BAR1=true
+V=1
+am__doit:
+	@$(TRUE)
+.PHONY: am__doit' | $am_make -f - >/dev/null 2>&1; then
+  am_cv_make_support_nested_variables=yes
+else
+  am_cv_make_support_nested_variables=no
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_make_support_nested_variables" >&5
+$as_echo "$am_cv_make_support_nested_variables" >&6; }
+if test $am_cv_make_support_nested_variables = yes; then
+    AM_V='$(V)'
+  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
+else
+  AM_V=$AM_DEFAULT_VERBOSITY
+  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY
+fi
+AM_BACKSLASH='\'
+
 if test "`cd $srcdir && pwd`" != "`pwd`"; then
   # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
   # is not polluted with repeated "-I."
@@ -2766,8 +2843,8 @@
 
 
 # Define the identity of the package.
- PACKAGE=cdw
- VERSION=0.7.1
+ PACKAGE='cdw'
+ VERSION='0.7.1'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -2795,20 +2872,71 @@
 
 MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
 
+# For better backward compatibility.  To be removed once Automake 1.9.x
+# dies out for good.  For more background, see:
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
+mkdir_p='$(MKDIR_P)'
+
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
 # Always define AMTAR for backward compatibility.  Yes, it's still used
 # in the wild :-(  We should find a proper way to deprecate it ...
 AMTAR='$${TAR-tar}'
 
+
+# We'll loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar  pax cpio none'
+
 am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
 
 
 
 
- # part of checking (autoconf) and building (automake) systems
 
-ac_config_headers="$ac_config_headers config.h"
+
+# POSIX will say in a future version that running "rm -f" with no argument
+# is OK; and we want to be able to make that assumption in our Makefile
+# recipes.  So use an aggressive probe to check that the usage we want is
+# actually supported "in the wild" to an acceptable degree.
+# See automake bug#10828.
+# To make any issue more visible, cause the running configure to be aborted
+# by default if the 'rm' program in use doesn't match our expectations; the
+# user can still override this though.
+if rm -f && rm -fr && rm -rf; then : OK; else
+  cat >&2 <<'END'
+Oops!
+
+Your 'rm' program seems unable to run without file operands specified
+on the command line, even when the '-f' option is present.  This is contrary
+to the behaviour of most rm programs out there, and not conforming with
+the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>
+
+Please tell bug-automake@gnu.org about your system, including the value
+of your $PATH and any error possibly output before this message.  This
+can help us improve future automake versions.
+
+END
+  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
+    echo 'Configuration will proceed anyway, since you have set the' >&2
+    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to "yes"' >&2
+    echo >&2
+  else
+    cat >&2 <<'END'
+Aborting the configuration process, to ensure you take notice of the issue.
+
+You can download and install GNU coreutils to get an 'rm' implementation
+that behaves properly: <http://www.gnu.org/software/coreutils/>.
+
+If you want to complete the configuration process using your problematic
+'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
+to "yes", and re-run configure.
+
+END
+    as_fn_error $? "Your 'rm' program is bad, sorry." "$LINENO" 5
+  fi
+fi
+ac_config_headers="$ac_config_headers config_cdw.h"
 
 
 
@@ -2835,7 +2963,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2875,7 +3003,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2928,7 +3056,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2969,7 +3097,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
@@ -3027,7 +3155,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3071,7 +3199,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3517,8 +3645,7 @@
 /* end confdefs.h.  */
 #include <stdarg.h>
 #include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
+struct stat;
 /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
 struct buf { int x; };
 FILE * (*rcsopen) (struct buf *, struct stat *, int);
@@ -3602,6 +3729,65 @@
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC understands -c and -o together" >&5
+$as_echo_n "checking whether $CC understands -c and -o together... " >&6; }
+if ${am_cv_prog_cc_c_o+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+  # Make sure it works both with $CC and with simple cc.
+  # Following AC_PROG_CC_C_O, we do the test twice because some
+  # compilers refuse to overwrite an existing .o file with -o,
+  # though they will create one.
+  am_cv_prog_cc_c_o=yes
+  for am_i in 1 2; do
+    if { echo "$as_me:$LINENO: $CC -c conftest.$ac_ext -o conftest2.$ac_objext" >&5
+   ($CC -c conftest.$ac_ext -o conftest2.$ac_objext) >&5 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } \
+         && test -f conftest2.$ac_objext; then
+      : OK
+    else
+      am_cv_prog_cc_c_o=no
+      break
+    fi
+  done
+  rm -f core conftest*
+  unset am_i
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_prog_cc_c_o" >&5
+$as_echo "$am_cv_prog_cc_c_o" >&6; }
+if test "$am_cv_prog_cc_c_o" != yes; then
+   # Losing compiler, so override with the script.
+   # FIXME: It is wrong to rewrite CC.
+   # But if we don't then we get into trouble of one sort or another.
+   # A longer-term fix would be to have automake use am__CC in this case,
+   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
+   CC="$am_aux_dir/compile $CC"
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
 DEPDIR="${am__leading_dot}deps"
 
 ac_config_commands="$ac_config_commands depfiles"
@@ -3621,7 +3807,7 @@
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
+# Ignore all kinds of additional output from 'make'.
 case `$am_make -s -f confmf 2> /dev/null` in #(
 *the\ am__doit\ target*)
   am__include=include
@@ -3677,8 +3863,8 @@
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -3713,16 +3899,16 @@
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -3731,8 +3917,8 @@
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -3740,7 +3926,7 @@
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -3823,7 +4009,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3863,7 +4049,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_RANLIB="ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3916,7 +4102,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_YACC="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3943,131 +4129,6 @@
 
 
 # enabe usage of per-target preprocessor flags
-if test "x$CC" != xcc; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC and cc understand -c and -o together" >&5
-$as_echo_n "checking whether $CC and cc understand -c and -o together... " >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether cc understands -c and -o together" >&5
-$as_echo_n "checking whether cc understands -c and -o together... " >&6; }
-fi
-set dummy $CC; ac_cc=`$as_echo "$2" |
-		      sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
-if eval \${ac_cv_prog_cc_${ac_cc}_c_o+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-# Make sure it works both with $CC and with simple cc.
-# We do the test twice because some compilers refuse to overwrite an
-# existing .o file with -o, though they will create one.
-ac_try='$CC -c conftest.$ac_ext -o conftest2.$ac_objext >&5'
-rm -f conftest2.*
-if { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } &&
-   test -f conftest2.$ac_objext && { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; };
-then
-  eval ac_cv_prog_cc_${ac_cc}_c_o=yes
-  if test "x$CC" != xcc; then
-    # Test first that cc exists at all.
-    if { ac_try='cc -c conftest.$ac_ext >&5'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then
-      ac_try='cc -c conftest.$ac_ext -o conftest2.$ac_objext >&5'
-      rm -f conftest2.*
-      if { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } &&
-	 test -f conftest2.$ac_objext && { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; };
-      then
-	# cc works too.
-	:
-      else
-	# cc exists but doesn't like -o.
-	eval ac_cv_prog_cc_${ac_cc}_c_o=no
-      fi
-    fi
-  fi
-else
-  eval ac_cv_prog_cc_${ac_cc}_c_o=no
-fi
-rm -f core conftest*
-
-fi
-if eval test \$ac_cv_prog_cc_${ac_cc}_c_o = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-$as_echo "#define NO_MINUS_C_MINUS_O 1" >>confdefs.h
-
-fi
-
-# FIXME: we rely on the cache variable name because
-# there is no other way.
-set dummy $CC
-am_cc=`echo $2 | sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
-eval am_t=\$ac_cv_prog_cc_${am_cc}_c_o
-if test "$am_t" != yes; then
-   # Losing compiler, so override with the script.
-   # FIXME: It is wrong to rewrite CC.
-   # But if we don't then we get into trouble of one sort or another.
-   # A longer-term fix would be to have automake use am__CC in this case,
-   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
-   CC="$am_aux_dir/compile $CC"
-fi
-
 
 
 
@@ -4470,7 +4531,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_TXT2TAGS="txt2tags"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4691,7 +4752,7 @@
     for ac_prog in grep ggrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+      as_fn_executable_p "$ac_path_GREP" || continue
 # Check for GNU ac_path_GREP and select it if it is found.
   # Check for GNU $ac_path_GREP
 case `"$ac_path_GREP" --version 2>&1` in
@@ -4757,7 +4818,7 @@
     for ac_prog in egrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+      as_fn_executable_p "$ac_path_EGREP" || continue
 # Check for GNU ac_path_EGREP and select it if it is found.
   # Check for GNU $ac_path_EGREP
 case `"$ac_path_EGREP" --version 2>&1` in
@@ -5096,23 +5157,20 @@
 /* end confdefs.h.  */
 $ac_includes_default
 int
-find_stack_direction ()
+find_stack_direction (int *addr, int depth)
 {
-  static char *addr = 0;
-  auto char dummy;
-  if (addr == 0)
-    {
-      addr = &dummy;
-      return find_stack_direction ();
-    }
-  else
-    return (&dummy > addr) ? 1 : -1;
+  int dir, dummy = 0;
+  if (! addr)
+    addr = &dummy;
+  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;
+  dir = depth ? find_stack_direction (addr, depth - 1) : 0;
+  return dir + dummy;
 }
 
 int
-main ()
+main (int argc, char **argv)
 {
-  return find_stack_direction () < 0;
+  return find_stack_direction (0, argc + !argv + 20) < 0;
 }
 _ACEOF
 if ac_fn_c_try_run "$LINENO"; then :
@@ -5494,60 +5552,60 @@
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-#include <stdbool.h>
-#ifndef bool
- "error: bool is not defined"
-#endif
-#ifndef false
- "error: false is not defined"
-#endif
-#if false
- "error: false is not 0"
-#endif
-#ifndef true
- "error: true is not defined"
-#endif
-#if true != 1
- "error: true is not 1"
-#endif
-#ifndef __bool_true_false_are_defined
- "error: __bool_true_false_are_defined is not defined"
-#endif
-
-	struct s { _Bool s: 1; _Bool t; } s;
-
-	char a[true == 1 ? 1 : -1];
-	char b[false == 0 ? 1 : -1];
-	char c[__bool_true_false_are_defined == 1 ? 1 : -1];
-	char d[(bool) 0.5 == true ? 1 : -1];
-	/* See body of main program for 'e'.  */
-	char f[(_Bool) 0.0 == false ? 1 : -1];
-	char g[true];
-	char h[sizeof (_Bool)];
-	char i[sizeof s.t];
-	enum { j = false, k = true, l = false * true, m = true * 256 };
-	/* The following fails for
-	   HP aC++/ANSI C B3910B A.05.55 [Dec 04 2003]. */
-	_Bool n[m];
-	char o[sizeof n == m * sizeof n[0] ? 1 : -1];
-	char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
-	/* Catch a bug in an HP-UX C compiler.  See
-	   http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
-	   http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
-	 */
-	_Bool q = true;
-	_Bool *pq = &q;
+             #include <stdbool.h>
+             #ifndef bool
+              "error: bool is not defined"
+             #endif
+             #ifndef false
+              "error: false is not defined"
+             #endif
+             #if false
+              "error: false is not 0"
+             #endif
+             #ifndef true
+              "error: true is not defined"
+             #endif
+             #if true != 1
+              "error: true is not 1"
+             #endif
+             #ifndef __bool_true_false_are_defined
+              "error: __bool_true_false_are_defined is not defined"
+             #endif
+
+             struct s { _Bool s: 1; _Bool t; } s;
+
+             char a[true == 1 ? 1 : -1];
+             char b[false == 0 ? 1 : -1];
+             char c[__bool_true_false_are_defined == 1 ? 1 : -1];
+             char d[(bool) 0.5 == true ? 1 : -1];
+             /* See body of main program for 'e'.  */
+             char f[(_Bool) 0.0 == false ? 1 : -1];
+             char g[true];
+             char h[sizeof (_Bool)];
+             char i[sizeof s.t];
+             enum { j = false, k = true, l = false * true, m = true * 256 };
+             /* The following fails for
+                HP aC++/ANSI C B3910B A.05.55 [Dec 04 2003]. */
+             _Bool n[m];
+             char o[sizeof n == m * sizeof n[0] ? 1 : -1];
+             char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
+             /* Catch a bug in an HP-UX C compiler.  See
+                http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+                http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+              */
+             _Bool q = true;
+             _Bool *pq = &q;
 
 int
 main ()
 {
 
-	bool e = &s;
-	*pq |= q;
-	*pq |= ! q;
-	/* Refer to every declared value, to avoid compiler optimizations.  */
-	return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
-		+ !m + !n + !o + !p + !q + !pq);
+             bool e = &s;
+             *pq |= q;
+             *pq |= ! q;
+             /* Refer to every declared value, to avoid compiler optimizations.  */
+             return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
+                     + !m + !n + !o + !p + !q + !pq);
 
   ;
   return 0;
@@ -5562,7 +5620,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdbool_h" >&5
 $as_echo "$ac_cv_header_stdbool_h" >&6; }
-ac_fn_c_check_type "$LINENO" "_Bool" "ac_cv_type__Bool" "$ac_includes_default"
+   ac_fn_c_check_type "$LINENO" "_Bool" "ac_cv_type__Bool" "$ac_includes_default"
 if test "x$ac_cv_type__Bool" = xyes; then :
 
 cat >>confdefs.h <<_ACEOF
@@ -5572,6 +5630,7 @@
 
 fi
 
+
 if test $ac_cv_header_stdbool_h = yes; then
 
 $as_echo "#define HAVE_STDBOOL_H 1" >>confdefs.h
@@ -6927,6 +6986,14 @@
 LTLIBOBJS=$ac_ltlibobjs
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
+$as_echo_n "checking that generated files are newer than configure... " >&6; }
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: done" >&5
+$as_echo "done" >&6; }
  if test -n "$EXEEXT"; then
   am__EXEEXT_TRUE=
   am__EXEEXT_FALSE='#'
@@ -7245,16 +7312,16 @@
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -7314,28 +7381,16 @@
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -7357,7 +7412,7 @@
 # values after options handling.
 ac_log="
 This file was extended by cdw $as_me 0.7.1, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -7423,10 +7478,10 @@
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 cdw config.status 0.7.1
-configured by $0, generated by GNU Autoconf 2.68,
+configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -7517,7 +7572,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
   \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
@@ -7551,7 +7606,7 @@
 for ac_config_target in $ac_config_targets
 do
   case $ac_config_target in
-    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+    "config_cdw.h") CONFIG_HEADERS="$CONFIG_HEADERS config_cdw.h" ;;
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
@@ -8163,7 +8218,7 @@
 
   case $ac_file$ac_mode in
     "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # Older Autoconf quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
   # if we detect the quoting.
   case $CONFIG_FILES in
@@ -8176,7 +8231,7 @@
     # Strip MF so we end up with the name of the file.
     mf=`echo "$mf" | sed -e 's/:.*$//'`
     # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
+    # We used to match only the files named 'Makefile.in', but
     # some people rename them; so instead we look at the file content.
     # Grep'ing the first line is not enough: some people post-process
     # each Makefile.in and add a new line on top of each file to say so.
@@ -8210,21 +8265,19 @@
       continue
     fi
     # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
+    # from the Makefile without running 'make'.
     DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
     test -z "$DEPDIR" && continue
     am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
+    test -z "$am__include" && continue
     am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
     # Find all dependency output files, they are included files with
     # $(DEPDIR) in their names.  We invoke sed twice because it is the
     # simplest approach to changing $(DEPDIR) to its actual value in the
     # expansion.
     for file in `sed -n "
       s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
       # Make sure the directory exists.
       test -f "$dirpart/$file" && continue
       fdir=`$as_dirname -- "$file" ||
@@ -8295,5 +8348,3 @@
 $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
-
-
diff -Naur orig/configure.ac patched/configure.ac
--- orig/configure.ac	2012-02-26 15:40:47.000000000 +0100
+++ patched/configure.ac	2014-01-19 20:44:35.000000000 +0100
@@ -3,9 +3,9 @@
 
 # AC_PREREQ(2.61)
 AC_INIT(cdw, 0.7.1, acerion@wp.pl)
-AM_INIT_AUTOMAKE(cdw, 0.7.1) # part of checking (autoconf) and building (automake) systems
 AC_CONFIG_SRCDIR([src/main.c])
-AC_CONFIG_HEADER([config.h])
+AM_INIT_AUTOMAKE
+AC_CONFIG_HEADER([config_cdw.h])
 
 
 # Checks for programs.
@@ -160,5 +160,3 @@
 		 src/configuration/Makefile
 		 src/utilities/Makefile])
 AC_OUTPUT
-
-
diff -Naur orig/doc/tools/dvd_rw_format_and_dvd_rw.txt patched/doc/tools/dvd_rw_format_and_dvd_rw.txt
--- orig/doc/tools/dvd_rw_format_and_dvd_rw.txt	1970-01-01 01:00:00.000000000 +0100
+++ patched/doc/tools/dvd_rw_format_and_dvd_rw.txt	2008-12-29 22:41:19.000000000 +0100
@@ -0,0 +1,279 @@
+short description:
+This file documents my tests of dvd+rw-format (version 7.1)
+performed on DVD-RW disc.
+
+
+I used two commands:
+ - dvd+rw-format -force /dev/scd0
+ - dvd+rw-format -blank /dev/scd0
+on DVD-RW disc in 'Sequential' and in 'Restricted Overwrite' modes.
+Commands were used without '=full' suboption.
+
+Summary of results is following:
+1. 'DVD-RW Seq' -> dvd+rw-format -force /dev/scd0 -> 'DVD-RW Res'
+2. 'DVD-RW Res' -> dvd+rw-format -force /dev/scd0 -> 'DVD-RW Res'
+3. 'DVD-RW Res' -> dvd+rw-format -blank /dev/scd0 -> 'DVD-RW Seq'
+4. 'DVD-RW Seq' -> dvd+rw-format -blank /dev/scd0 -> 'DVD-RW Seq'
+
+All commands completed in less than 60 seconds. I guess that
+(in combination with missing '=full' option) it means that this
+was blanking in 'fast' mode.
+
+After every run of 'dvd+rw-format' I also called 'dvd+rw-mediainfo /dev/scd0'.
+All results are below.
+
+
+
+
+
+1.
+disc mode before: DVD-RW Sequential
+
+performed test:
+"
+time dvd+rw-format -force /dev/scd0
+* BD/DVDRW/-RAM format utility by <appro@fy.chalmers.se>, version 7.1.
+* 4.7GB DVD-RW media in Sequential mode detected.
+* formatting 100.0-
+
+real    0m54.774s
+user    0m0.000s
+sys     0m0.000s
+"
+
+
+notes: 
+at the beginning percentage value (after "formatting") was 0.0 for 
+few seconds, but it started to grow rapidly to stop at 100.0. After that 
+it stayed at 100.0, and the program didn't return. After few seconds the
+program returned.
+
+disc mode after: DVD-RW Restricted Overwrite
+
+
+---------------------
+dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         13h, DVD-RW Restricted Overwrite
+ Media ID:              CMCW04
+ Current Write Speed:   6.0x1385=8310KB/s
+ Write Speed #0:        6.0x1385=8310KB/s
+ Write Speed #1:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2297887 R@8.0x1385=11080KB/s W@6.0x1385=8310KB/s
+ Speed Descriptor#1:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       33h, DVD-RW book [revision 3]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    1
+ State of Last Session: incomplete
+ "Next" Track:          1
+ Number of Tracks:      1
+READ FORMAT CAPACITIES:
+ no media:              4101552*2048=8399978496
+ 00h(800):              2297888*2048=4706074624
+ 10h(10):               2297888*2048=4706074624
+ 15h(10):               2297888*2048=4706074624
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible incremental
+ Track Start Address:   0*2KB
+ Next Writable Address: 0*2KB
+ Free Blocks:           2297888*2KB
+ Fixed Packet Size:     16*2KB
+ Track Size:            2297888*2KB
+READ CAPACITY:          0*2048=0
+---------------------
+
+
+
+
+2.
+disc mode before: DVD-RW Restricted Overwrite
+
+performed test:
+"
+time dvd+rw-format -force /dev/scd0
+* BD/DVDRW/-RAM format utility by <appro@fy.chalmers.se>, version 7.1.
+* 4.7GB DVD-RW media in Restricted Overwrite mode detected.
+* formatting 100.0/
+
+real    0m53.591s
+user    0m0.000s
+sys     0m0.000s
+"
+
+
+notes: 
+program behaved exactly the same as in point 1.
+
+disc mode after: DVD-RW restricted Overwrite
+
+
+---------------------
+dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         13h, DVD-RW Restricted Overwrite
+ Media ID:              CMCW04
+ Current Write Speed:   6.0x1385=8310KB/s
+ Write Speed #0:        6.0x1385=8310KB/s
+ Write Speed #1:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2297887 R@8.0x1385=11080KB/s W@6.0x1385=8310KB/s
+ Speed Descriptor#1:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       33h, DVD-RW book [revision 3]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    1
+ State of Last Session: incomplete
+ "Next" Track:          1
+ Number of Tracks:      1
+READ FORMAT CAPACITIES:
+ no media:              4101552*2048=8399978496
+ 00h(800):              2297888*2048=4706074624
+ 10h(10):               2297888*2048=4706074624
+ 15h(10):               2297888*2048=4706074624
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible incremental
+ Track Start Address:   0*2KB
+ Next Writable Address: 0*2KB
+ Free Blocks:           2297888*2KB
+ Fixed Packet Size:     16*2KB
+ Track Size:            2297888*2KB
+READ CAPACITY:          0*2048=0
+---------------------
+
+
+
+
+3.
+disc mode before: DVD-RW Restricted Overwrite
+
+performed test:
+"
+time dvd+rw-format -blank /dev/scd0
+* BD/DVDRW/-RAM format utility by <appro@fy.chalmers.se>, version 7.1.
+* 4.7GB DVD-RW media in Restricted Overwrite mode detected.
+* blanking 100.0|
+
+real    0m48.775s
+user    0m0.000s
+sys     0m0.000s
+"
+
+
+notes:
+program behaved exactly the same as in 1. and 2.
+
+disc mode after: DVD-RW Sequential
+
+
+---------------------
+dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         14h, DVD-RW Sequential
+ Media ID:              CMCW04
+ Current Write Speed:   6.0x1385=8310KB/s
+ Write Speed #0:        6.0x1385=8310KB/s
+ Write Speed #1:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2297887 R@8.0x1385=11080KB/s W@6.0x1385=8310KB/s
+ Speed Descriptor#1:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       33h, DVD-RW book [revision 3]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           blank
+ Number of Sessions:    1
+ State of Last Session: empty
+ "Next" Track:          1
+ Number of Tracks:      1
+READ FORMAT CAPACITIES:
+ unformatted:           2297888*2048=4706074624
+ 00h(800):              2297888*2048=4706074624
+ 10h(10):               2297888*2048=4706074624
+ 15h(10):               2297888*2048=4706074624
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible incremental
+ Track Start Address:   0*2KB
+ Next Writable Address: 0*2KB
+ Free Blocks:           2297888*2KB
+ Track Size:            2297888*2KB
+READ CAPACITY:          0*2048=0
+---------------------
+
+
+
+
+4.
+disc mode before: DVD-RW Sequential
+
+performed test:
+"
+time dvd+rw-format -blank /dev/scd0
+* BD/DVDRW/-RAM format utility by <appro@fy.chalmers.se>, version 7.1.
+* 4.7GB DVD-RW media in Sequential mode detected.
+* blanking 100.0/
+
+real    0m50.178s
+user    0m0.000s
+sys     0m0.004s
+"
+
+
+notes:
+program behaved exactly the same as in 1., 2. and 3.
+
+disc mode after: DVD-RW Sequential
+
+
+---------------------
+dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         14h, DVD-RW Sequential
+ Media ID:              CMCW04
+ Current Write Speed:   6.0x1385=8310KB/s
+ Write Speed #0:        6.0x1385=8310KB/s
+ Write Speed #1:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2297887 R@4.0x1385=5540KB/s W@6.0x1385=8310KB/s
+ Speed Descriptor#1:    00/2297887 R@4.0x1385=5540KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       33h, DVD-RW book [revision 3]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           blank
+ Number of Sessions:    1
+ State of Last Session: empty
+ "Next" Track:          1
+ Number of Tracks:      1
+READ FORMAT CAPACITIES:
+ unformatted:           2297888*2048=4706074624
+ 00h(800):              2297888*2048=4706074624
+ 10h(10):               2297888*2048=4706074624
+ 15h(10):               2297888*2048=4706074624
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible incremental
+ Track Start Address:   0*2KB
+ Next Writable Address: 0*2KB
+ Free Blocks:           2297888*2KB
+ Track Size:            2297888*2KB
+READ CAPACITY:          0*2048=0
+---------------------
+
+
diff -Naur orig/doc/tools/growisofs_and_dvd_rp.txt patched/doc/tools/growisofs_and_dvd_rp.txt
--- orig/doc/tools/growisofs_and_dvd_rp.txt	1970-01-01 01:00:00.000000000 +0100
+++ patched/doc/tools/growisofs_and_dvd_rp.txt	2008-12-29 22:40:52.000000000 +0100
@@ -0,0 +1,557 @@
+short description:
+This file documents my tests of growisofs (version 7.1)
+performed on DVD+R disc, conducted to learn about usage of 
+"-Z" / "-M" and "-dvd-compat" options.
+
+After every write operation I checked (using file manager) that
+the files were written.
+
+
+
+calling "growisofs -Z" on empty DVD+R disc with intention to create appendable disc (writing files):
+
+acerion@macondo3 16 $ growisofs -Z /dev/scd0 -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_3
+Executing 'genisoimage -J -R -iso-level=3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_3 | builtin_dd of=/dev/scd0 obs=32k seek=0'
+[...]
+ 98.80% done, estimate finish Mon Dec 29 16:34:44 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 2700
+Total directory bytes: 4096
+Path table size(bytes): 38
+Max brk space used 0
+156878 extents written (306 MB)
+builtin_dd: 156880*2KB out @ average 3.8x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing session
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 17 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         1Bh, DVD+R
+ Media ID:              TDK/003
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2295103 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    00/2295103 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    00/2295103 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    00/2295103 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2295103 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2295104*2KB=4700372992
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    2
+ State of Last Session: empty
+ "Next" Track:          2
+ Number of Tracks:      2
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            156880*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           blank
+ Track Start Address:   158928*2KB
+ Next Writable Address: 158928*2KB
+ Free Blocks:           2136176*2KB
+ Track Size:            2136176*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#AA :             14@156880
+ Multi-session Info:    #1@0
+READ CAPACITY:          156880*2048=321290240
+
+disc is non-empty and seems to be appendable
+
+---------------------------------------
+calling "growisofs -M" on non-empty, appendable DVD+R disc with intention to append data and don't close disc (writing files):
+
+acerion@macondo3 17 $ growisofs -M /dev/scd0 -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_2
+Executing 'genisoimage -C 16,158928 -M /dev/fd/3 -J -R -iso-level=3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_2 | builtin_dd of=/dev/scd0 obs=32k seek=9933'
+Setting input-charset to 'UTF-8' from locale.
+ISO-9660 image includes checksum signature for correct inode numbers.
+Rock Ridge signatures found
+[...]
+ 98.94% done, estimate finish Mon Dec 29 16:38:59 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 5873
+Total directory bytes: 10240
+Path table size(bytes): 60
+Max brk space used 0
+83664 extents written (163 MB)
+builtin_dd: 83664*2KB out @ average 3.3x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing session
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+acerion@macondo3 18 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         1Bh, DVD+R
+ Media ID:              TDK/003
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2295103 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    00/2295103 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    00/2295103 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    00/2295103 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2295103 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2295104*2KB=4700372992
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    3
+ State of Last Session: empty
+ "Next" Track:          3
+ Number of Tracks:      3
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            156880*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           invisible
+ Track Start Address:   158928*2KB
+ Free Blocks:           0*2KB
+ Track Size:            83664*2KB
+READ TRACK INFORMATION[#3]:
+ Track State:           blank
+ Track Start Address:   244640*2KB
+ Next Writable Address: 244640*2KB
+ Free Blocks:           2050464*2KB
+ Track Size:            2050464*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#2  :             14@158928
+ Track#AA :             14@242592
+ Multi-session Info:    #2@158928
+READ CAPACITY:          242592*2048=496828416
+
+disc is non-empty and seems to be appendable
+
+---------------------------------------
+calling "growisofs -M" on non-empty, appendable DVD+R disc with intention to append even more data and don't close disc (writing files):
+
+growisofs -M /dev/scd0 -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_1
+Executing 'genisoimage -C 158944,244640 -M /dev/fd/3 -J -R -iso-level=3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_1 | builtin_dd of=/dev/scd0 obs=32k seek=15290'
+[...]
+ 98.40% done, estimate finish Mon Dec 29 16:43:05 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 9453
+Total directory bytes: 18432
+Path table size(bytes): 120
+Max brk space used 0
+60233 extents written (117 MB)
+builtin_dd: 60240*2KB out @ average 2.9x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing session
+
+so disc is still appendable
+
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 19 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         1Bh, DVD+R
+ Media ID:              TDK/003
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2295103 R@4.0x1385=5540KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    00/2295103 R@4.0x1385=5540KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    00/2295103 R@4.0x1385=5540KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    00/2295103 R@4.0x1385=5540KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2295103 R@4.0x1385=5540KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2295104*2KB=4700372992
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    4
+ State of Last Session: empty
+ "Next" Track:          4
+ Number of Tracks:      4
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            156880*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           invisible
+ Track Start Address:   158928*2KB
+ Free Blocks:           0*2KB
+ Track Size:            83664*2KB
+READ TRACK INFORMATION[#3]:
+ Track State:           invisible
+ Track Start Address:   244640*2KB
+ Free Blocks:           0*2KB
+ Track Size:            60240*2KB
+READ TRACK INFORMATION[#4]:
+ Track State:           blank
+ Track Start Address:   306928*2KB
+ Next Writable Address: 306928*2KB
+ Free Blocks:           1988176*2KB
+ Track Size:            1988176*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#2  :             14@158928
+ Track#3  :             14@244640
+ Track#AA :             14@304880
+ Multi-session Info:    #3@244640
+READ CAPACITY:          304880*2048=624394240
+
+disc is non-empty and appendable
+
+---------------------------------------
+calling "growisofs -dvd-compat -M" on non-empty, appendable DVD+R disc with intention to write final session and close disc (writing files):
+
+acerion@macondo3 19 $ growisofs -dvd-compat -M /dev/scd0 -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_5
+Executing 'genisoimage -C 244656,306928 -M /dev/fd/3 -J -R -iso-level=3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_5 | builtin_dd of=/dev/scd0 obs=32k seek=19183'
+[...]
+ 99.44% done, estimate finish Mon Dec 29 16:46:04 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 11280
+Total directory bytes: 22528
+Path table size(bytes): 148
+Max brk space used 0
+115426 extents written (225 MB)
+builtin_dd: 115440*2KB out @ average 4.0x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing session
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 20 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         1Bh, DVD+R
+ Media ID:              TDK/003
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2295103 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    00/2295103 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    00/2295103 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    00/2295103 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2295103 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2295104*2KB=4700372992
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    5
+ State of Last Session: empty
+ "Next" Track:          5
+ Number of Tracks:      5
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            156880*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           invisible
+ Track Start Address:   158928*2KB
+ Free Blocks:           0*2KB
+ Track Size:            83664*2KB
+READ TRACK INFORMATION[#3]:
+ Track State:           invisible
+ Track Start Address:   244640*2KB
+ Free Blocks:           0*2KB
+ Track Size:            60240*2KB
+READ TRACK INFORMATION[#4]:
+ Track State:           invisible
+ Track Start Address:   306928*2KB
+ Free Blocks:           0*2KB
+ Track Size:            115440*2KB
+READ TRACK INFORMATION[#5]:
+ Track State:           blank
+ Track Start Address:   424416*2KB
+ Next Writable Address: 424416*2KB
+ Free Blocks:           1870688*2KB
+ Track Size:            1870688*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#2  :             14@158928
+ Track#3  :             14@244640
+ Track#4  :             14@306928
+ Track#AA :             14@422368
+ Multi-session Info:    #4@306928
+READ CAPACITY:          422368*2048=865009664
+
+disc is non-empty and seems to be appendable
+
+---------------------------------------
+calling "growisofs -M" on DVD-R disc that I tried to close in previous step:
+
+acerion@macondo3 20 $ growisofs -M /dev/scd0 -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_4
+Executing 'genisoimage -C 306944,424416 -M /dev/fd/3 -J -R -iso-level=3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_4 | builtin_dd of=/dev/scd0 obs=32k seek=26526'
+[...]
+ 99.44% done, estimate finish Mon Dec 29 16:50:43 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 13797
+Total directory bytes: 26624
+Path table size(bytes): 176
+Max brk space used 0
+158881 extents written (310 MB)
+builtin_dd: 158896*2KB out @ average 4.6x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing session
+
+conclusion: option "-dvd-compat" does not close appednable DVD-R disc that already has some data;
+
+
+=======================================
+using new, blank DVD+R
+=======================================
+
+calling "growisofs -dvd-compat -Z" on empty DVD+R disc with intention to create non-appendable disc (writing image):
+
+acerion@macondo3 21 $ growisofs -dvd-compat -Z /dev/scd0 ~/current/cdw/cdw_tests/_DVD_batches/_5/
+Executing 'genisoimage /home/acerion/current/cdw/cdw_tests/_DVD_batches/_5/ | builtin_dd of=/dev/scd0 obs=32k seek=0'
+Setting input-charset to 'UTF-8' from locale.
+[...]
+ 99.66% done, estimate finish Mon Dec 29 16:58:11 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 0
+Total directory bytes: 2048
+Path table size(bytes): 26
+Max brk space used 0
+115401 extents written (225 MB)
+builtin_dd: 115408*2KB out @ average 2.8x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing disc
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 21 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         1Bh, DVD+R
+ Media ID:              TDK/003
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2295103 R@4.0x1385=5540KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    00/2295103 R@4.0x1385=5540KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    00/2295103 R@4.0x1385=5540KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    00/2295103 R@4.0x1385=5540KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2295103 R@4.0x1385=5540KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    115408*2KB=236355584
+READ DISC INFORMATION:
+ Disc status:           complete
+ Number of Sessions:    1
+ State of Last Session: complete
+ Number of Tracks:      1
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            115408*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#AA :             14@115408
+ Multi-session Info:    #1@0
+READ CAPACITY:          115408*2048=236355584
+
+disc is non-empty and seems to be non-appendable
+
+---------------------------------------
+calling "growisofs -M" on non-empty DVD+R disc that should be non-appendable:
+
+acerion@macondo3 22 $ growisofs -M /dev/scd0 ~/current/cdw/cdw_tests/_DVD_batches/_2
+:-( media is not appendable
+
+
+conclusion: using "-dvd-compat -Z" for writing files to empty DVD+R disc creates non-appendable disc
+
+
+
+=======================================
+using new, blank DVD+R
+=======================================
+
+calling "growisofs -Z" on empty DVD+R disc to create appendable disc (writing image):
+
+acerion@macondo3 2 $ growisofs -Z /dev/scd0=/tmp/testowy.iso
+Executing 'builtin_dd if=/tmp/testowy.iso of=/dev/scd0 obs=32k seek=0'
+/dev/scd0: "Current Write Speed" is 16.4x1352KBps.
+[...]
+  167378944/171335680 (97.7%) @6.9x, remaining 0:01 RBU  11.8% UBU  99.8%
+builtin_dd: 83664*2KB out @ average 2.9x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing session
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 4 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         1Bh, DVD+R
+ Media ID:              TDK/003
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2295103 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    00/2295103 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    00/2295103 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    00/2295103 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2295103 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2295104*2KB=4700372992
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    2
+ State of Last Session: empty
+ "Next" Track:          2
+ Number of Tracks:      2
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            83664*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           blank
+ Track Start Address:   85712*2KB
+ Next Writable Address: 85712*2KB
+ Free Blocks:           2209392*2KB
+ Track Size:            2209392*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#AA :             14@83664
+ Multi-session Info:    #1@0
+READ CAPACITY:          83664*2048=171343872
+
+disc is non-empty and seems to be appendable
+
+---------------------------------------
+calling (growisofs -M) to check if disc is appendable (writing files):
+
+growisofs -M /dev/scd0 -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_5
+Executing 'genisoimage -C 16,85712 -M /dev/fd/3 -J -R -iso-level=3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_5 | builtin_dd of=/dev/scd0 obs=32k seek=5357'
+[...]
+ 99.44% done, estimate finish Mon Dec 29 20:53:11 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 5166
+Total directory bytes: 10240
+Path table size(bytes): 60
+Max brk space used 0
+115415 extents written (225 MB)
+builtin_dd: 115424*2KB out @ average 4.0x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing session
+
+disc was appendable;
+
+conclusion: writing image to empty disc with "-Z" option only creates appendable disc;
+
+=======================================
+using new, blank DVD+R
+=======================================
+
+calling "growisofs -dvd-compat -Z" with intention to create non-appendable disc (writing iso image):
+
+acerion@macondo3 4 $ growisofs -dvd-compat -Z /dev/scd0=/tmp/testowy.iso
+Executing 'builtin_dd if=/tmp/testowy.iso of=/dev/scd0 obs=32k seek=0'
+/dev/scd0: "Current Write Speed" is 16.4x1352KBps.
+[...]
+  165511168/171335680 (96.6%) @6.5x, remaining 0:01 RBU  17.4% UBU  99.8%
+builtin_dd: 83664*2KB out @ average 2.9x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: closing track
+/dev/scd0: closing disc
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 6 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         1Bh, DVD+R
+ Media ID:              TDK/003
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    00/2295103 R@4.0x1385=5540KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    00/2295103 R@4.0x1385=5540KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    00/2295103 R@4.0x1385=5540KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    00/2295103 R@4.0x1385=5540KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2295103 R@4.0x1385=5540KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    83664*2KB=171343872
+READ DISC INFORMATION:
+ Disc status:           complete
+ Number of Sessions:    1
+ State of Last Session: complete
+ Number of Tracks:      1
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            83664*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#AA :             14@83664
+ Multi-session Info:    #1@0
+READ CAPACITY:          83664*2048=171343872
+
+disc is non-empty and seems to be closed;
+
+---------------------------------------
+calling "growisofs -M" to check if disc is appendable:
+
+acerion@macondo3 5 $ growisofs -M /dev/scd0 -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_5
+:-( media is not appendable
+
+conclusion: calling growisofs with "-dvd-compat -Z" when writing image to empty DVD+R disc creates non-appendable disc
+
+
+
+
+end
diff -Naur orig/doc/tools/growisofs_and_dvd_r.txt patched/doc/tools/growisofs_and_dvd_r.txt
--- orig/doc/tools/growisofs_and_dvd_r.txt	1970-01-01 01:00:00.000000000 +0100
+++ patched/doc/tools/growisofs_and_dvd_r.txt	2008-12-29 22:40:52.000000000 +0100
@@ -0,0 +1,609 @@
+short description:
+This file documents my tests of growisofs (version 7.1)
+performed on DVD-R disc, conducted to learn about usage of 
+"-Z" / "-M" and "-dvd-compat" options.
+
+After every write operation I checked (using file manager) that
+the files were written.
+
+
+acerion@macondo3 7 $ growisofs --version
+* growisofs by <appro@fy.chalmers.se>, version 7.1,
+  front-ending to genisoimage: mkisofs 2.01.01a37 (x86_64-unknown-linux-gnu) Copyright (C) 1993-1997 Eric Youngdale (C) 1997-2007 Jrg Schilling
+
+
+
+---------------------------------------
+calling dvd+rw-mediainfo on empty (new) DVD-R:
+
+acerion@macondo3 8 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         11h, DVD-R Sequential
+ Media ID:              MCC 03RG20
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    08/2297887 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    08/2297887 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    08/2297887 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    08/2297887 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       25h, DVD-R book [revision 5]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           blank
+ Number of Sessions:    1
+ State of Last Session: empty
+ "Next" Track:          1
+ Number of Tracks:      1
+READ TRACK INFORMATION[#1]:
+ Track State:           invisible incremental
+ Track Start Address:   0*2KB
+ Next Writable Address: 0*2KB
+ Free Blocks:           2297888*2KB
+ Track Size:            2297888*2KB
+READ CAPACITY:          0*2048=0
+
+
+
+---------------------------------------
+calling "growisofs -Z" on new, blank DVD with intention to create appendable disc (writing files):
+
+acerion@macondo3 4 $ growisofs -Z /dev/scd0 ~/current/cdw/cdw_tests/_DVD_batches/_5/
+Executing 'genisoimage /home/acerion/current/cdw/cdw_tests/_DVD_batches/_5/ | builtin_dd of=/dev/scd0 obs=32k seek=0'
+[...]
+ 95.33% done, estimate finish Mon Dec 29 15:12:29 2008
+ 99.66% done, estimate finish Mon Dec 29 15:12:28 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 0
+Total directory bytes: 2048
+Path table size(bytes): 26
+Max brk space used 0
+115401 extents written (225 MB)
+builtin_dd: 115408*2KB out @ average 5.5x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: updating RMA
+/dev/scd0: closing session
+
+---------------------------------------
+now calling dvd+rw-mediainfo again:
+
+acerion@macondo3 9 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         11h, DVD-R Sequential
+ Media ID:              MCC 03RG20
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    08/2297887 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    08/2297887 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    08/2297887 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    08/2297887 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       25h, DVD-R book [revision 5]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    2
+ State of Last Session: empty
+ "Next" Track:          2
+ Number of Tracks:      2
+READ TRACK INFORMATION[#1]:
+ Track State:           complete incremental
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            115408*2KB
+ Last Recorded Address: 115407*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           invisible incremental
+ Track Start Address:   144096*2KB
+ Next Writable Address: 144096*2KB
+ Free Blocks:           2153792*2KB
+ Track Size:            2153792*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#AA :             14@115408
+ Multi-session Info:    #1@0
+READ CAPACITY:          115408*2048=236355584
+
+
+disc is non-empty and appendable;
+
+
+---------------------------------------
+calling "growisofs -M" for non-empty, appendable disc with intention to append files and don't close disc (write files):
+
+acerion@macondo3 5 $ growisofs -M /dev/scd0 ~/current/cdw/cdw_tests/_DVD_batches/_4/
+Executing 'genisoimage -C 16,144096 -M /dev/fd/3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_4/ | builtin_dd of=/dev/scd0 obs=32k seek=9006'
+Setting input-charset to 'UTF-8' from locale.
+ISO-9660 image includes checksum signature for correct inode numbers.
+NO Rock Ridge present
+Disabling Rock Ridge / XA / AA
+Warning: Neither Rock Ridge (-R) nor TRANS.TBL (-T)
+name translations were found on previous session.
+ISO-9660 file names have been used instead.
+[...]
+ 99.03% done, estimate finish Mon Dec 29 15:17:56 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 0
+Total directory bytes: 4096
+Path table size(bytes): 42
+Max brk space used 0
+158853 extents written (310 MB)
+builtin_dd: 158864*2KB out @ average 6.4x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: updating RMA
+/dev/scd0: closing session
+
+
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 10 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         11h, DVD-R Sequential
+ Media ID:              MCC 03RG20
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    08/2297887 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    08/2297887 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    08/2297887 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    08/2297887 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       25h, DVD-R book [revision 5]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    3
+ State of Last Session: empty
+ "Next" Track:          3
+ Number of Tracks:      3
+READ TRACK INFORMATION[#1]:
+ Track State:           complete incremental
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            115408*2KB
+ Last Recorded Address: 115407*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           complete incremental
+ Track Start Address:   144096*2KB
+ Free Blocks:           0*2KB
+ Track Size:            158864*2KB
+ Last Recorded Address: 302959*2KB
+READ TRACK INFORMATION[#3]:
+ Track State:           invisible incremental
+ Track Start Address:   309120*2KB
+ Next Writable Address: 309120*2KB
+ Free Blocks:           1988768*2KB
+ Track Size:            1988768*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#2  :             14@144096
+ Track#AA :             14@302960
+ Multi-session Info:    #2@144096
+READ CAPACITY:          302960*2048=620462080
+
+disc is non-empty and appendable
+
+
+---------------------------------------
+calling "growisofs -dvd-compat -M" on non-empty, appendable disc with intention to close it (writing files):
+
+growisofs -dvd-compat -M /dev/scd0 ~/current/cdw/cdw_tests/_DVD_batches/_1/
+Executing 'genisoimage -C 144112,309120 -M /dev/fd/3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_1/ | builtin_dd of=/dev/scd0 obs=32k seek=19320'
+Setting input-charset to 'UTF-8' from locale.
+ISO-9660 image includes checksum signature for correct inode numbers.
+NO Rock Ridge present
+Disabling Rock Ridge / XA / AA
+Warning: Neither Rock Ridge (-R) nor TRANS.TBL (-T)
+name translations were found on previous session.
+ISO-9660 file names have been used instead.
+[...]
+ 98.74% done, estimate finish Mon Dec 29 15:23:46 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 0
+Total directory bytes: 10240
+Path table size(bytes): 90
+Max brk space used 0
+60564 extents written (118 MB)
+builtin_dd: 60576*2KB out @ average 5.3x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: updating RMA
+/dev/scd0: closing session
+
+it doesn't seem to close the disc
+
+---------------------------------------
+calling dvd+rw-mediainfo on disc that I wanted to close:
+
+acerion@macondo3 11 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         11h, DVD-R Sequential
+ Media ID:              MCC 03RG20
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    08/2297887 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    08/2297887 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    08/2297887 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    08/2297887 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       25h, DVD-R book [revision 5]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    4
+ State of Last Session: empty
+ "Next" Track:          4
+ Number of Tracks:      4
+READ TRACK INFORMATION[#1]:
+ Track State:           complete incremental
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            115408*2KB
+ Last Recorded Address: 115407*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           complete incremental
+ Track Start Address:   144096*2KB
+ Free Blocks:           0*2KB
+ Track Size:            158864*2KB
+ Last Recorded Address: 302959*2KB
+READ TRACK INFORMATION[#3]:
+ Track State:           complete incremental
+ Track Start Address:   309120*2KB
+ Free Blocks:           0*2KB
+ Track Size:            60576*2KB
+ Last Recorded Address: 369695*2KB
+READ TRACK INFORMATION[#4]:
+ Track State:           invisible incremental
+ Track Start Address:   375856*2KB
+ Next Writable Address: 375856*2KB
+ Free Blocks:           1922032*2KB
+ Track Size:            1922032*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#2  :             14@309120
+ Track#AA :             14@369696
+ Multi-session Info:    #2@309120
+READ CAPACITY:          369696*2048=757137408
+
+disc is non-empty and still appendable
+
+
+
+=======================================
+using new, blank DVD-R
+=======================================
+
+caling "growisofs -dvd-compat -Z" on empty DVD-R disc with intention to create single-session non-appendable disc (writing files)
+
+acerion@macondo3 7 $ growisofs -dvd-compat -Z /dev/scd0 ~/current/cdw/cdw_tests/_DVD_batches/_1/
+Executing 'genisoimage /home/acerion/current/cdw/cdw_tests/_DVD_batches/_1/ | builtin_dd of=/dev/scd0 obs=32k seek=0'
+[...]
+ 99.66% done, estimate finish Mon Dec 29 15:40:53 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 0
+Total directory bytes: 6144
+Path table size(bytes): 58
+Max brk space used 0
+60213 extents written (117 MB)
+builtin_dd: 60224*2KB out @ average 5.2x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: updating RMA
+/dev/scd0: closing disc
+
+---------------------------------------
+
+calling dvd+rw-mediainfo:
+
+dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         11h, DVD-R Sequential
+ Media ID:              MCC 03RG20
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    08/2297887 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    08/2297887 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    08/2297887 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    08/2297887 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       25h, DVD-R book [revision 5]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           complete
+ Number of Sessions:    1
+ State of Last Session: complete
+ Number of Tracks:      1
+READ TRACK INFORMATION[#1]:
+ Track State:           complete incremental
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            60224*2KB
+ Last Recorded Address: 60223*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#AA :             14@60224
+ Multi-session Info:    #1@0
+READ CAPACITY:          60224*2048=123338752
+
+disc seems to be non-empty and non-appendable
+
+---------------------------------------
+calling "growisofs -M" on (supposedly) closed DVD-R disc - just to check:
+
+acerion@macondo3 8 $ growisofs -M /dev/scd0 ~/current/cdw/cdw_tests/_DVD_batches/_2
+:-( media is not appendable
+
+disc is non-appendable;
+
+
+=======================================
+using new, blank DVD-R
+=======================================
+
+calling "growisofs -Z" on empty DVD-R disc with intention to create appendable disc (writing image):
+
+growisofs -Z /dev/scd0=/tmp/testowy.iso
+Executing 'builtin_dd if=/tmp/testowy.iso of=/dev/scd0 obs=32k seek=0'
+/dev/scd0: "Current Write Speed" is 16.4x1352KBps.
+     917504/171335680 ( 0.5%) @0.0x, remaining 12:22 RBU 100.0% UBU   6.9%
+   31883264/171335680 (18.6%) @6.6x, remaining 0:34 RBU 100.0% UBU  99.8%
+   63569920/171335680 (37.1%) @6.8x, remaining 0:18 RBU 100.0% UBU  99.8%
+   95748096/171335680 (55.9%) @6.9x, remaining 0:11 RBU 100.0% UBU  99.8%
+  128417792/171335680 (75.0%) @7.0x, remaining 0:06 RBU 100.0% UBU  99.8%
+  154238976/171335680 (90.0%) @5.5x, remaining 0:02 RBU  51.0% UBU  99.8%
+builtin_dd: 83664*2KB out @ average 5.2x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: updating RMA
+/dev/scd0: closing session
+
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 13 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         11h, DVD-R Sequential
+ Media ID:              MCC 03RG20
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    08/2297887 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    08/2297887 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    08/2297887 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    08/2297887 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       25h, DVD-R book [revision 5]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    2
+ State of Last Session: empty
+ "Next" Track:          2
+ Number of Tracks:      2
+READ TRACK INFORMATION[#1]:
+ Track State:           complete incremental
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            83664*2KB
+ Last Recorded Address: 83663*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           invisible incremental
+ Track Start Address:   112352*2KB
+ Next Writable Address: 112352*2KB
+ Free Blocks:           2185536*2KB
+ Track Size:            2185536*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#AA :             14@83664
+ Multi-session Info:    #1@0
+READ CAPACITY:          83664*2048=171343872
+
+disc is non-empty and seems to be appendable
+
+---------------------------------------
+calling "growisofs -M" on non-empty, appendable DVD-R disc with intention to append files, and don't close disc (writing files):
+
+growisofs -M /dev/scd0 -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_4
+Executing 'genisoimage -C 16,112352 -M /dev/fd/3 -J -R -iso-level=3 /home/acerion/current/cdw/cdw_tests/_DVD_batches/_4 | builtin_dd of=/dev/scd0 obs=32k seek=7022'
+Setting input-charset to 'UTF-8' from locale.
+ISO-9660 image includes checksum signature for correct inode numbers.
+Rock Ridge signatures found
+[...]
+ 99.55% done, estimate finish Mon Dec 29 16:02:18 2008
+Total translation table size: 0
+Total rockridge attributes bytes: 5865
+Total directory bytes: 10240
+Path table size(bytes): 60
+Max brk space used 0
+158867 extents written (310 MB)
+builtin_dd: 158880*2KB out @ average 6.0x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: updating RMA
+/dev/scd0: closing session
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 14 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         11h, DVD-R Sequential
+ Media ID:              MCC 03RG20
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    08/2297887 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    08/2297887 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    08/2297887 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    08/2297887 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       25h, DVD-R book [revision 5]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           appendable
+ Number of Sessions:    3
+ State of Last Session: empty
+ "Next" Track:          3
+ Number of Tracks:      3
+READ TRACK INFORMATION[#1]:
+ Track State:           complete incremental
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            83664*2KB
+ Last Recorded Address: 83663*2KB
+READ TRACK INFORMATION[#2]:
+ Track State:           complete incremental
+ Track Start Address:   112352*2KB
+ Free Blocks:           0*2KB
+ Track Size:            158880*2KB
+ Last Recorded Address: 271231*2KB
+READ TRACK INFORMATION[#3]:
+ Track State:           invisible incremental
+ Track Start Address:   277392*2KB
+ Next Writable Address: 277392*2KB
+ Free Blocks:           2020496*2KB
+ Track Size:            2020496*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#2  :             14@112352
+ Track#AA :             14@271232
+ Multi-session Info:    #2@112352
+READ CAPACITY:          271232*2048=555483136
+
+disc is non-empty and appendable
+
+
+
+=======================================
+using new, blank DVD-R
+=======================================
+
+calling "growisofs -dvd-compat -Z" on empty DVD-R with intention to create non-appendable disc (writing image):
+
+acerion@macondo3 14 $ growisofs -dvd-compat -Z /dev/scd0=/tmp/testowy.iso
+Executing 'builtin_dd if=/tmp/testowy.iso of=/dev/scd0 obs=32k seek=0'
+/dev/scd0: "Current Write Speed" is 16.4x1352KBps.
+     917504/171335680 ( 0.5%) @0.0x, remaining 15:28 RBU 100.0% UBU   6.9%
+   27131904/171335680 (15.8%) @5.6x, remaining 0:42 RBU 100.0% UBU  99.8%
+   58720256/171335680 (34.3%) @6.8x, remaining 0:23 RBU 100.0% UBU  99.8%
+   90832896/171335680 (53.0%) @6.9x, remaining 0:13 RBU 100.0% UBU  99.8%
+  123437056/171335680 (72.0%) @7.0x, remaining 0:06 RBU 100.0% UBU  99.8%
+  149651456/171335680 (87.3%) @5.6x, remaining 0:03 RBU  64.6% UBU  99.8%
+builtin_dd: 83664*2KB out @ average 5.0x1352KBps
+/dev/scd0: flushing cache
+/dev/scd0: updating RMA
+/dev/scd0: closing disc
+
+
+---------------------------------------
+calling dvd+rw-mediainfo:
+
+acerion@macondo3 16 $ dvd+rw-mediainfo /dev/scd0
+INQUIRY:                [ASUS    ][DRW-2014L1T     ][1.00]
+GET [CURRENT] CONFIGURATION:
+ Mounted Media:         11h, DVD-R Sequential
+ Media ID:              MCC 03RG20
+ Current Write Speed:   16.0x1385=22160KB/s
+ Write Speed #0:        16.0x1385=22160KB/s
+ Write Speed #1:        12.0x1385=16620KB/s
+ Write Speed #2:        10.0x1385=13850KB/s
+ Write Speed #3:        8.0x1385=11080KB/s
+ Write Speed #4:        4.0x1385=5540KB/s
+ Speed Descriptor#0:    08/2297887 R@8.0x1385=11080KB/s W@16.0x1385=22160KB/s
+ Speed Descriptor#1:    08/2297887 R@8.0x1385=11080KB/s W@12.0x1385=16620KB/s
+ Speed Descriptor#2:    08/2297887 R@8.0x1385=11080KB/s W@10.0x1385=13850KB/s
+ Speed Descriptor#3:    08/2297887 R@8.0x1385=11080KB/s W@8.0x1385=11080KB/s
+ Speed Descriptor#4:    00/2297887 R@8.0x1385=11080KB/s W@4.0x1385=5540KB/s
+READ DVD STRUCTURE[#10h]:
+ Media Book Type:       00h, DVD-ROM book [revision 0]
+ Legacy lead-out at:    2298496*2KB=4707319808
+READ DVD STRUCTURE[#0h]:
+ Media Book Type:       25h, DVD-R book [revision 5]
+ Last border-out at:    2045*2KB=4188160
+READ DISC INFORMATION:
+ Disc status:           complete
+ Number of Sessions:    1
+ State of Last Session: complete
+ Number of Tracks:      1
+READ TRACK INFORMATION[#1]:
+ Track State:           complete incremental
+ Track Start Address:   0*2KB
+ Free Blocks:           0*2KB
+ Track Size:            83664*2KB
+ Last Recorded Address: 83663*2KB
+FABRICATED TOC:
+ Track#1  :             14@0
+ Track#AA :             14@83664
+ Multi-session Info:    #1@0
+READ CAPACITY:          83664*2048=171343872
+
+disc is non-empty and seems to be closed
+
+---------------------------------------
+calling "growisofs -M" to make sure that disc is not appendable:
+
+growisofs -M /dev/scd0 -dvd-compat -J -R -iso-level=3 ~/current/cdw/cdw_tests/_DVD_batches/_3
+:-( media is not appendable
+
+
+
+end
diff -Naur orig/doc/tools/growisofs_and_dvd_rw.txt patched/doc/tools/growisofs_and_dvd_rw.txt
--- orig/doc/tools/growisofs_and_dvd_rw.txt	1970-01-01 01:00:00.000000000 +0100
+++ patched/doc/tools/growisofs_and_dvd_rw.txt	2008-12-28 23:05:55.000000000 +0100
@@ -0,0 +1,26 @@
+Results of my experiments with growisofs v7.1.
+First column shows intended action: first four for direct writing of
+files, last two for writing image. First row shows current format of
+disc. Body of table shows growisofs options required to get intended
+result.
+
+                         DVD-RW Seq.        DVD-RW Res.
+
+start appendable         -Z                 -Z
+
+create single            -dvd-compat -Z      n/a (1)
+
+continue appendable      -M                 -M
+
+write final              -dvd-compat -M      n/a (2)
+
+write image (first       -Z                 -Z
+session, appendable)
+
+write image (first       -dvd-compat -Z      n/a (1)
+session, non-appen.)
+
+
+1. not available: using "-dvd-compat -Z" doesn't create non-appendable disc
+2. not available: using "-dvd-compat -M" doesn't close disc
+
diff -Naur orig/Doxyfile patched/Doxyfile
--- orig/Doxyfile	1970-01-01 01:00:00.000000000 +0100
+++ patched/Doxyfile	2010-09-17 11:43:47.000000000 +0200
@@ -0,0 +1,1630 @@
+# Doxyfile 1.7.1
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = cdw
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number.
+# This could be handy for archiving the generated documentation or
+# if some version control system is used.
+
+PROJECT_NUMBER         = 0.5.0
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
+# base path where the generated documentation will be put.
+# If a relative path is entered, it will be relative to the location
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = doc/doxydoc
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
+# 4096 sub-directories (in 2 levels) under the output directory of each output
+# format and will distribute the generated files over these directories.
+# Enabling this option can be useful when feeding doxygen a huge amount of
+# source files, where putting all generated files in the same directory would
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# The default language is English, other supported languages are:
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
+# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,
+# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
+# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
+# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak,
+# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
+# include brief member descriptions after the members that are listed in
+# the file and class documentation (similar to JavaDoc).
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
+# the brief description of a member or function before the detailed description.
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator
+# that is used to form the text in various listings. Each string
+# in this list, if found as the leading text of the brief description, will be
+# stripped from the text and the result after processing the whole list, is
+# used as the annotated text. Otherwise, the brief description is used as-is.
+# If left blank, the following values are used ("$name" is automatically
+# replaced with the name of the entity): "The $name class" "The $name widget"
+# "The $name file" "is" "provides" "specifies" "contains"
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       =
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# Doxygen will generate a detailed section even if there is only a brief
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
+# path before files name in the file list and in the header files. If set
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
+# can be used to strip a user-defined part of the path. Stripping is
+# only done if one of the specified strings matches the left-hand part of
+# the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the
+# path to strip.
+
+STRIP_FROM_PATH        = /home/acerion/current/cdw/working_copy/cdw/src
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
+# the path mentioned in the documentation of a class, which tells
+# the reader which header file to include in order to use a class.
+# If left blank only the name of the header file containing the class
+# definition is used. Otherwise one should specify the include paths that
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
+# (but less readable) file names. This can be useful is your file systems
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
+# will interpret the first line (until the first dot) of a JavaDoc-style
+# comment as the brief description. If set to NO, the JavaDoc
+# comments will behave just like regular Qt-style comments
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
+# interpret the first line (until the first dot) of a Qt-style
+# comment as the brief description. If set to NO, the comments
+# will behave just like regular Qt-style comments (thus requiring
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
+# treat a multi-line C++ special comment block (i.e. a block of //! or ///
+# comments) as a brief description. This used to be the default behaviour.
+# The new default is to treat a multi-line C++ comment block as a detailed
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
+# member inherits the documentation from any documented member that it
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
+# a new page for each member. If set to NO, the documentation of a member will
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab.
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts
+# as commands in the documentation. An alias has the form "name=value".
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to
+# put the command \sideeffect (or @sideeffect) in the documentation, which
+# will result in a user-defined paragraph with heading "Side Effects:".
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
+# sources only. Doxygen will then generate output that is more tailored for C.
+# For instance, some of the names that are used will be different. The list
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
+# sources only. Doxygen will then generate output that is more tailored for
+# Java. For instance, namespaces will be presented as packages, qualified
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources only. Doxygen will then generate output that is more tailored for
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given extension.
+# Doxygen has a built-in mapping, but you can override or extend it using this
+# tag. The format is ext=language, where ext is a file extension, and language
+# is one of the parsers supported by doxygen: IDL, Java, Javascript, CSharp, C,
+# C++, D, PHP, Objective-C, Python, Fortran, VHDL, C, C++. For instance to make
+# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C
+# (default is Fortran), use: inc=Fortran f=C. Note that for custom extensions
+# you also need to set FILE_PATTERNS otherwise the files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should
+# set this tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
+# func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
+# Doxygen will parse them like normal C++ but will assume all classes use public
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate getter
+# and setter methods for a property. Setting this option to YES (the default)
+# will make doxygen to replace the get and set methods by a property in the
+# documentation. This will only work if the methods are indeed getting or
+# setting a simple type. If this is not the case, or you want to show the
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES, then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
+# the same type (for instance a group of public functions) to be put as a
+# subgroup of that type (e.g. under the Public Functions section). Set it to
+# NO to prevent subgrouping. Alternatively, this can be done per class using
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
+# is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically
+# be useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = YES
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to
+# determine which symbols to keep in memory and which to flush to disk.
+# When the cache is full, less often used symbols will be written to disk.
+# For small to medium size projects (<1000 input files) the default value is
+# probably good enough. For larger projects a too small cache size can cause
+# doxygen to be busy swapping symbols to and from disk most of the time
+# causing a significant performance penality.
+# If the system has enough physical memory increasing the cache will improve the
+# performance by keeping more symbols in memory. Note that the value works on
+# a logarithmic scale so increasing the size by one will rougly double the
+# memory usage. The cache size is given by this formula:
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
+# corresponding to a cache size of 2^16 = 65536 symbols
+
+SYMBOL_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
+# documentation are documented, even if no documentation was available.
+# Private class members and static file members will be hidden unless
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = YES
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file
+# will be included in the documentation.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
+# defined locally in source files will be included in the documentation.
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local
+# methods, which are defined in the implementation section but not in
+# the interface are included in the documentation.
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base
+# name of the file that contains the anonymous namespace. By default
+# anonymous namespace are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
+# undocumented members of documented classes, files or namespaces.
+# If set to NO (the default) these members will be included in the
+# various overviews, but no documentation section is generated.
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy.
+# If set to NO (the default) these classes will be included in the various
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
+# friend (class|struct|union) declarations.
+# If set to NO (the default) these declarations will be included in the
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
+# documentation blocks found inside the body of a function.
+# If set to NO (the default) these blocks will be appended to the
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation
+# that is typed after a \internal command is included. If the tag is set
+# to NO (the default) then the documentation will be excluded.
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
+# file names in lower-case letters. If set to YES upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
+# will show members with their full class and namespace scopes in the
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
+# will put a list of the files that are included by a file in the documentation
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen
+# will list include files with double quotes in the documentation
+# rather than with sharp brackets.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
+# will sort the (detailed) documentation of file and class members
+# alphabetically by member name. If set to NO the members will appear in
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
+# brief documentation of file, namespace and class members alphabetically
+# by member name. If set to NO (the default) the members will appear in
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen
+# will sort the (brief and detailed) documentation of class members so that
+# constructors and destructors are listed first. If set to NO (the default)
+# the constructors will appear in the respective orders defined by
+# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS.
+# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO
+# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
+# hierarchy of group names into alphabetical order. If set to NO (the default)
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
+# sorted by fully-qualified names, including namespaces. If set to
+# NO (the default), the class list will be sorted only by class name,
+# not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or
+# disable (NO) the todo list. This list is created by putting \todo
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or
+# disable (NO) the test list. This list is created by putting \test
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or
+# disable (NO) the bug list. This list is created by putting \bug
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
+# disable (NO) the deprecated list. This list is created by putting
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
+# the initial value of a variable or define consists of for it to appear in
+# the documentation. If the initializer consists of more lines than specified
+# here it will be hidden. Use a value of 0 to hide initializers completely.
+# The appearance of the initializer of individual variables and defines in the
+# documentation can be controlled using \showinitializer or \hideinitializer
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
+# at the bottom of the documentation of classes and structs. If set to YES the
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
+# This will remove the Files entry from the Quick Index and from the
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the
+# Namespaces page.
+# This will remove the Namespaces entry from the Quick Index
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command <command> <input-file>, where <command> is the value of
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
+# provided by doxygen. Whatever the program writes to standard output
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. The create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option.
+# You can optionally specify a file name after the option, if omitted
+# DoxygenLayout.xml will be used as the name of the layout file.
+
+LAYOUT_FILE            =
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = YES
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated by doxygen. Possible values are YES and NO. If left blank
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some
+# parameters in a documented function, or documenting parameters that
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for
+# functions that are documented, but have no documentation for their parameters
+# or return value. If set to NO (the default) doxygen will only warn about
+# wrong or incomplete parameter documentation, but not about the absence of
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that
+# doxygen can produce. The string should contain the $file, $line, and $text
+# tags, which will be replaced by the file and line number from which the
+# warning originated and the warning text. Optionally the format may contain
+# $version, which will be replaced by the version of the file (if it could
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning
+# and error messages should be written. If left blank the output is written
+# to stderr.
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain
+# documented source files. You may enter file names like "myfile.cpp" or
+# directories like "/usr/src/myproject". Separate the files or directories
+# with spaces.
+
+INPUT                  = /home/acerion/current/cdw/working_copy/cdw/src
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
+# also the default input encoding. Doxygen uses libiconv (or the iconv built
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank the following patterns are tested:
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
+
+FILE_PATTERNS          =
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories
+# should be searched for input files as well. Possible values are YES and NO.
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                =
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or
+# directories that are symbolic links (a Unix filesystem feature) are excluded
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories. Note that the wildcards are matched
+# against the file with absolute path, so to exclude all test directories
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or
+# directories that contain example code fragments that are included (see
+# the \include command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank all files are included.
+
+EXAMPLE_PATTERNS       =
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude
+# commands irrespective of the value of the RECURSIVE tag.
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or
+# directories that contain image that are included in the documentation (see
+# the \image command).
+
+IMAGE_PATH             =
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command <filter> <input-file>, where <filter>
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
+# input file. Doxygen will then use the output that the filter program writes
+# to standard output.
+# If FILTER_PATTERNS is specified, this tag will be
+# ignored.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis.
+# Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match.
+# The filters are a list of the form:
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER
+# is applied to all files.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will be used to filter the input files when producing source
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will
+# be generated. Documented entities will be cross-referenced with these sources.
+# Note: To get rid of all source code in the generated output, make sure also
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
+# doxygen to hide any special comment blocks from generated source code
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = NO
+
+# If the REFERENCED_BY_RELATION tag is set to YES
+# then for each documented function all documented
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES
+# then for each documented function all documented entities
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
+# link to the source code.
+# Otherwise they will link to the documentation.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code
+# will point to the HTML generated by the htags(1) tool instead of doxygen
+# built-in source browser. The htags tool is part of GNU's global source
+# tagging system (see http://www.gnu.org/software/global/global.html). You
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
+# will generate a verbatim copy of the header file for each class for
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
+# of all compounds will be generated. Enable this if the project
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all
+# classes will be put under the same header in the alphabetical index.
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for
+# each generated HTML page. If it is left blank doxygen will generate a
+# standard header.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for
+# each generated HTML page. If it is left blank doxygen will generate a
+# standard footer.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
+# style sheet that is used by each HTML page. It can be used to
+# fine-tune the look of the HTML output. If the tag is left blank doxygen
+# will generate a default style sheet. Note that doxygen will try to copy
+# the style sheet file to the HTML output directory, so don't put your own
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output.
+# Doxygen will adjust the colors in the stylesheet and background images
+# according to this color. Hue is specified as an angle on a colorwheel,
+# see http://en.wikipedia.org/wiki/Hue for more information.
+# For instance the value 0 represents red, 60 is yellow, 120 is green,
+# 180 is cyan, 240 is blue, 300 purple, and 360 is red again.
+# The allowed range is 0 to 359.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of
+# the colors in the HTML output. For a value of 0 the output will use
+# grayscales only. A value of 255 will produce the most vivid colors.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to
+# the luminance component of the colors in the HTML output. Values below
+# 100 gradually make the output lighter, whereas values above 100 make
+# the output darker. The value divided by 100 is the actual gamma applied,
+# so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2,
+# and 100 does not change the gamma.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting
+# this to NO can help when comparing the output of multiple runs.
+
+HTML_TIMESTAMP         = YES
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,
+# files or namespaces will be aligned in HTML using tables. If set to
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded. For this to work a browser that supports
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox
+# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files
+# will be generated that can be used as input for Apple's Xcode 3
+# integrated development environment, introduced with OSX 10.5 (Leopard).
+# To create a documentation set, doxygen will generate a Makefile in the
+# HTML output directory. Running make will produce the docset in that
+# directory and running "make install" will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
+# it at startup.
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+# for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
+# feed. A documentation feed provides an umbrella under which multiple
+# documentation sets from a single provider (such as a company or product suite)
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
+# should uniquely identify the documentation set bundle. This should be a
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files
+# will be generated that can be used as input for tools like the
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
+# be used to specify the file name of the resulting .chm file. You
+# can add a path in front of the file if the result should not be
+# written to the html output directory.
+
+CHM_FILE               =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
+# be used to specify the location (absolute path including file name) of
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
+# controls if a separate .chi index file is generated (YES) or that
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file
+# content.
+
+CHM_INDEX_ENCODING     =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
+# controls whether a binary table of contents is generated (YES) or a
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated
+# that can be used as input for Qt's qhelpgenerator to generate a
+# Qt Compressed Help (.qch) of the generated HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can
+# be used to specify the file name of the resulting .qch file.
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating
+# Qt Help Project output. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#namespace
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
+# Qt Help Project output. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#virtual-folders
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to
+# add. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#custom-filters
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see
+# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">
+# Qt Help Project / Custom Filters</a>.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's
+# filter section matches.
+# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">
+# Qt Help Project / Filter Attributes</a>.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
+# be used to specify the location of Qt's qhelpgenerator.
+# If non-empty doxygen will try to run qhelpgenerator on the generated
+# .qhp file.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files
+#  will be generated, which together with the HTML files, form an Eclipse help
+# plugin. To install this plugin and make it available under the help contents
+# menu in Eclipse, the contents of the directory containing the HTML and XML
+# files needs to be copied into the plugins directory of eclipse. The name of
+# the directory within the plugins directory should be the same as
+# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before
+# the help appears.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have
+# this name.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at
+# top of each HTML page. The value NO (the default) enables the index and
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20])
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information.
+# If the tag value is set to YES, a side panel will be generated
+# containing a tree-like index structure (just like the one that
+# is generated for HTML Help). For this to work a browser that supports
+# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).
+# Windows users are probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NONE
+
+# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories,
+# and Class Hierarchy pages using a tree view instead of an ordered list.
+
+USE_INLINE_TREES       = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
+# used to set the initial width (in pixels) of the frame in which the tree
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open
+# links to external symbols imported via tag files in a separate window.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of Latex formulas included
+# as images in the HTML documentation. The default is 10. Note that
+# when you change the font size after a successful doxygen run you need
+# to manually remove any form_*.png images from the HTML output directory
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are
+# not supported properly for IE 6.0, but are supported on all modern browsers.
+# Note that when changing this option you need to delete any form_*.png files
+# in the HTML output before the changes have effect.
+
+FORMULA_TRANSPARENT    = YES
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box
+# for the HTML output. The underlying search engine uses javascript
+# and DHTML and should work on any modern browser. Note that when using
+# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets
+# (GENERATE_DOCSET) there is already a search function so this one should
+# typically be disabled. For large projects the javascript based search engine
+# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
+
+SEARCHENGINE           = NO
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a PHP enabled web server instead of at the web client
+# using Javascript. Doxygen will generate the search PHP script and index
+# file to put on the web server. The advantage of the server
+# based approach is that it scales better to large projects and allows
+# full text search. The disadvances is that it is more difficult to setup
+# and does not have live searching capabilities.
+
+SERVER_BASED_SEARCH    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
+# generate Latex output.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked. If left blank `latex' will be used as the default command name.
+# Note that when enabling USE_PDFLATEX this option is only used for
+# generating bitmaps for formulas in the HTML output, but not in the
+# Makefile that is written to the output directory.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
+# generate index for LaTeX. If left blank `makeindex' will be used as the
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
+# LaTeX documents. This may be useful for small projects and may help to
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used
+# by the printer. Possible values are: a4, a4wide, letter, legal and
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
+# the generated latex document. The header should contain everything until
+# the first chapter. If it is left blank doxygen will generate a
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will
+# contain links (just like the HTML output) instead of page references
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
+# plain latex in the generated Makefile. Set this option to YES to get a
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
+# command to the generated LaTeX files. This will instruct LaTeX to keep
+# running if errors occur, instead of asking the user for help.
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not
+# include the index chapters (such as File Index, Compound Index, etc.)
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+# If LATEX_SOURCE_CODE is set to YES then doxygen will include
+# source code with syntax highlighting in the LaTeX output.
+# Note that which sources are shown also depends on other settings
+# such as SOURCE_BROWSER.
+
+LATEX_SOURCE_CODE      = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
+# The RTF output is optimized for Word 97 and may not look very pretty with
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
+# RTF documents. This may be useful for small projects and may help to
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
+# will contain hyperlink fields. The RTF file will
+# contain links (just like the HTML output) instead of page references.
+# This makes the output suitable for online browsing using WORD or other
+# programs which support those fields.
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's
+# config file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an rtf document.
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    =
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
+# then it will generate one additional man file for each entity
+# documented in the real man page(s). These additional files
+# only source the real man page, but without them the man command
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will
+# generate an XML file that captures the structure of
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema,
+# which can be used by a validating XML parser to check the
+# syntax of the XML files.
+
+XML_SCHEMA             =
+
+# The XML_DTD tag can be used to specify an XML DTD,
+# which can be used by a validating XML parser to check the
+# syntax of the XML files.
+
+XML_DTD                =
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
+# dump the program listings (including syntax highlighting
+# and cross-referencing information) to the XML output. Note that
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
+# generate an AutoGen Definitions (see autogen.sf.net) file
+# that captures the structure of the code including all
+# documentation. Note that this feature is still experimental
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will
+# generate a Perl module file that captures the structure of
+# the code including all documentation. Note that this
+# feature is still experimental and incomplete at the
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
+# nicely formatted so it can be parsed by a human reader.
+# This is useful
+# if you want to understand what is going on.
+# On the other hand, if this
+# tag is set to NO the size of the Perl module output will be much smaller
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
+# This is useful so different doxyrules.make files included by the same
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
+# evaluate all C-preprocessor directives found in the sources and include
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
+# names in the source code. If set to NO (the default) only conditional
+# compilation will be performed. Macro expansion can be done in a controlled
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
+# then the macro expansion is limited to the macros specified with the
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by
+# the preprocessor.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will
+# be used.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that
+# are defined before the preprocessor is started (similar to the -D option of
+# gcc). The argument of the tag is a list of macros of the form: name
+# or name=definition (no spaces). If the definition and the = are
+# omitted =1 is assumed. To prevent a macro definition from being
+# undefined via #undef or recursively expanded use the := operator
+# instead of the = operator.
+
+PREDEFINED             =
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
+# this tag can be used to specify a list of macro names that should be expanded.
+# The macro definition that is found in the sources will be used.
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
+# doxygen's preprocessor will remove all function-like macros that are alone
+# on a line, have an all uppercase name, and do not end with a semicolon. Such
+# function macros are typically used for boiler-plate code, and will confuse
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles.
+# Optionally an initial location of the external documentation
+# can be added for each tagfile. The format of a tag file without
+# this location is as follows:
+#
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+#
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where "loc1" and "loc2" can be relative or absolute paths or
+# URLs. If a location is present for each tag, the installdox tool
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed
+# in the class index. If set to NO only the inherited external classes
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
+# or super classes. Setting the tag to NO turns the diagrams off. Note that
+# this option is superseded by the HAVE_DOT option below. This is only a
+# fallback. It is recommended to install and use dot, since it yields more
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            =
+
+# If set to YES, the inheritance and collaboration graphs will hide
+# inheritance and usage relations if the target is undocumented
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz, a graph visualization
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = YES
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is
+# allowed to run in parallel. When set to 0 (the default) doxygen will
+# base this on the number of processors available in the system. You can set it
+# explicitly to a value larger than 0 to get control over the balance
+# between CPU load and processing speed.
+
+DOT_NUM_THREADS        = 0
+
+# By default doxygen will write a font called FreeSans.ttf to the output
+# directory and reference it in all dot files that doxygen generates. This
+# font does not include all possible unicode characters however, so when you need
+# these (or just want a differently looking font) you can specify the font name
+# using DOT_FONTNAME. You need need to make sure dot is able to find the font,
+# which can be done by putting it in a standard location or by setting the
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory
+# containing the font.
+
+DOT_FONTNAME           = FreeSans
+
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
+# The default size is 10pt.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the output directory to look for the
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a
+# different font using DOT_FONTNAME you can set the path where dot
+# can find it using this tag.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for each documented class showing the direct and
+# indirect inheritance relations. Setting this tag to YES will force the
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for each documented class showing the direct and
+# indirect implementation dependencies (inheritance, containment, and
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
+# tags are set to YES then doxygen will generate a graph for each documented
+# file showing the direct and indirect include dependencies of the file with
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
+# documented header file showing the documented files that directly or
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then
+# doxygen will generate a call dependency graph for every global function
+# or class method. Note that enabling this option will significantly increase
+# the time of a run. So in most cases it will be better to enable call graphs
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = YES
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
+# doxygen will generate a caller dependency graph for every global function
+# or class method. Note that enabling this option will significantly increase
+# the time of a run. So in most cases it will be better to enable caller
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = YES
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES
+# then doxygen will show the dependencies a directory has on other directories
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the
+# \dotfile command).
+
+DOTFILE_DIRS           =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
+# nodes that will be shown in the graph. If the number of nodes in a graph
+# becomes larger than this value, doxygen will truncate the graph, which is
+# visualized by representing a node as a red box. Note that doxygen if the
+# number of direct children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
+# graphs generated by dot. A depth value of 3 means that only nodes reachable
+# from the root by following a path via at most 3 edges will be shown. Nodes
+# that lay further from the root node will be omitted. Note that setting this
+# option to 1 or 2 may greatly reduce the computation time needed for large
+# code bases. Also note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not
+# seem to support this out of the box. Warning: Depending on the platform used,
+# enabling this option may lead to badly anti-aliased labels on the edges of
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = YES
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10)
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
+# generate a legend page explaining the meaning of the various boxes and
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
+# remove the intermediate dot files that are used to generate
+# the various graphs.
+
+DOT_CLEANUP            = YES
diff -Naur orig/gnulib/lib/canonicalize.c patched/gnulib/lib/canonicalize.c
--- orig/gnulib/lib/canonicalize.c	2010-05-05 20:28:45.000000000 +0200
+++ patched/gnulib/lib/canonicalize.c	2014-01-19 20:49:58.000000000 +0100
@@ -16,7 +16,7 @@
    If not, write to the Free Software Foundation,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
 #define _GNU_SOURCE
-#include <config.h>
+#include "config_cdw.h"
 
 #include "canonicalize.h"
 
diff -Naur orig/gnulib/lib/canonicalize.h patched/gnulib/lib/canonicalize.h
--- orig/gnulib/lib/canonicalize.h	2010-05-05 20:28:45.000000000 +0200
+++ patched/gnulib/lib/canonicalize.h	2014-01-19 20:49:58.000000000 +0100
@@ -19,7 +19,7 @@
 #ifndef CANONICALIZE_H_
 # define CANONICALIZE_H_
 
-#include "config.h"
+#include "config_cdw.h"
 
 # if GNULIB_CANONICALIZE
 enum canonicalize_mode_t
diff -Naur orig/gnulib/lib/cycle-check.c patched/gnulib/lib/cycle-check.c
--- orig/gnulib/lib/cycle-check.c	2010-05-05 20:28:45.000000000 +0200
+++ patched/gnulib/lib/cycle-check.c	2014-01-19 20:49:58.000000000 +0100
@@ -19,7 +19,7 @@
 
 /* Written by Jim Meyering */
 
-#include <config.h>
+#include "config_cdw.h"
 
 #include <sys/types.h>
 #include <sys/stat.h>
diff -Naur orig/gnulib/lib/filenamecat.c patched/gnulib/lib/filenamecat.c
--- orig/gnulib/lib/filenamecat.c	2010-05-05 20:28:45.000000000 +0200
+++ patched/gnulib/lib/filenamecat.c	2014-01-19 20:49:58.000000000 +0100
@@ -22,7 +22,8 @@
 #define _GNU_SOURCE /* mempcpy() */
 #include <stdio.h>
 #include <stdlib.h>
-#include <config.h>
+
+#include "config_cdw.h"
 
 /* Specification.  */
 #include "filenamecat.h"
diff -Naur orig/gnulib/lib/Makefile.in patched/gnulib/lib/Makefile.in
--- orig/gnulib/lib/Makefile.in	2012-02-26 15:53:40.000000000 +0100
+++ patched/gnulib/lib/Makefile.in	2014-01-19 20:51:28.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,41 +76,88 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = gnulib/lib
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libgnulib_a_AR = $(AR) $(ARFLAGS)
 libgnulib_a_LIBADD =
 am_libgnulib_a_OBJECTS = canonicalize.$(OBJEXT) cycle-check.$(OBJEXT) \
 	filenamecat.$(OBJEXT) xreadlink.$(OBJEXT)
 libgnulib_a_OBJECTS = $(am_libgnulib_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libgnulib_a_SOURCES)
 DIST_SOURCES = $(libgnulib_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -267,10 +358,11 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libgnulib.a: $(libgnulib_a_OBJECTS) $(libgnulib_a_DEPENDENCIES) $(EXTRA_libgnulib_a_DEPENDENCIES) 
-	-rm -f libgnulib.a
-	$(libgnulib_a_AR) libgnulib.a $(libgnulib_a_OBJECTS) $(libgnulib_a_LIBADD)
-	$(RANLIB) libgnulib.a
+	$(AM_V_at)-rm -f libgnulib.a
+	$(AM_V_AR)$(libgnulib_a_AR) libgnulib.a $(libgnulib_a_OBJECTS) $(libgnulib_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libgnulib.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -284,39 +376,28 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xreadlink.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -328,15 +409,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -345,6 +422,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -484,17 +576,17 @@
 
 .MAKE: install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES ctags distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-tags distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
 	uninstall-am
 
 
diff -Naur orig/gnulib/lib/xreadlink.c patched/gnulib/lib/xreadlink.c
--- orig/gnulib/lib/xreadlink.c	2010-05-05 20:28:45.000000000 +0200
+++ patched/gnulib/lib/xreadlink.c	2014-01-19 20:49:58.000000000 +0100
@@ -20,7 +20,7 @@
 
 /* Written by Jim Meyering <jim@meyering.net>  */
 
-#include <config.h>
+#include "config_cdw.h"
 
 #include "xreadlink.h"
 
diff -Naur orig/gnulib/Makefile.in patched/gnulib/Makefile.in
--- orig/gnulib/Makefile.in	2012-02-26 15:53:40.000000000 +0100
+++ patched/gnulib/Makefile.in	2014-01-19 20:51:28.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +14,51 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,29 +76,67 @@
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 subdir = gnulib
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 SOURCES =
 DIST_SOURCES =
-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
-	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
-AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
-	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
 	distdir
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -87,6 +169,7 @@
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -212,22 +295,25 @@
 $(am__aclocal_m4_deps):
 
 # This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
 	  echo "Making $$target in $$subdir"; \
 	  if test "$$subdir" = "."; then \
 	    dot_seen=yes; \
@@ -242,57 +328,12 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test "$$subdir" = "."; then :; else \
-	    rev="$$subdir $$rev"; \
-	  fi; \
-	done; \
-	rev="$$rev ."; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done && test -z "$$fail"
-tags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
-	done
-ctags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
-	done
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
 
-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
 	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
@@ -308,12 +349,7 @@
 	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -325,15 +361,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -342,6 +374,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -378,13 +425,10 @@
 	done
 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
 	    $(am__relativize); \
 	    new_distdir=$$reldir; \
@@ -505,21 +549,19 @@
 
 uninstall-am:
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
-	install-am install-strip tags-recursive
+.MAKE: $(am__recursive_targets) install-am install-strip
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-am clean clean-generic ctags \
-	ctags-recursive distclean distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	installdirs-am maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic pdf pdf-am ps ps-am tags \
-	tags-recursive uninstall uninstall-am
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
+	check-am clean clean-generic cscopelist-am ctags ctags-am \
+	distclean distclean-generic distclean-tags distdir dvi dvi-am \
+	html html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
+	pdf-am ps ps-am tags tags-am uninstall uninstall-am
 
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
diff -Naur orig/intl/bindtextdom.c patched/intl/bindtextdom.c
--- orig/intl/bindtextdom.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/bindtextdom.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,368 @@
+/* Implementation of the bindtextdomain(3) function
+   Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+#include "gettextP.h"
+
+#ifdef _LIBC
+/* We have to handle multi-threaded applications.  */
+# include <bits/libc-lock.h>
+#else
+/* Provide dummy implementation if this is outside glibc.  */
+# define __libc_rwlock_define(CLASS, NAME)
+# define __libc_rwlock_wrlock(NAME)
+# define __libc_rwlock_unlock(NAME)
+#endif
+
+/* The internal variables in the standalone libintl.a must have different
+   names than the internal variables in GNU libc, otherwise programs
+   using libintl.a cannot be linked statically.  */
+#if !defined _LIBC
+# define _nl_default_dirname _nl_default_dirname__
+# define _nl_domain_bindings _nl_domain_bindings__
+#endif
+
+/* Some compilers, like SunOS4 cc, don't have offsetof in <stddef.h>.  */
+#ifndef offsetof
+# define offsetof(type,ident) ((size_t)&(((type*)0)->ident))
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Contains the default location of the message catalogs.  */
+extern const char _nl_default_dirname[];
+
+/* List with bindings of specific domains.  */
+extern struct binding *_nl_domain_bindings;
+
+/* Lock variable to protect the global data in the gettext implementation.  */
+__libc_rwlock_define (extern, _nl_state_lock)
+
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define BINDTEXTDOMAIN __bindtextdomain
+# define BIND_TEXTDOMAIN_CODESET __bind_textdomain_codeset
+# ifndef strdup
+#  define strdup(str) __strdup (str)
+# endif
+#else
+# define BINDTEXTDOMAIN bindtextdomain__
+# define BIND_TEXTDOMAIN_CODESET bind_textdomain_codeset__
+#endif
+
+/* Prototypes for local functions.  */
+static void set_binding_values PARAMS ((const char *domainname,
+					const char **dirnamep,
+					const char **codesetp));
+
+/* Specifies the directory name *DIRNAMEP and the output codeset *CODESETP
+   to be used for the DOMAINNAME message catalog.
+   If *DIRNAMEP or *CODESETP is NULL, the corresponding attribute is not
+   modified, only the current value is returned.
+   If DIRNAMEP or CODESETP is NULL, the corresponding attribute is neither
+   modified nor returned.  */
+static void
+set_binding_values (domainname, dirnamep, codesetp)
+     const char *domainname;
+     const char **dirnamep;
+     const char **codesetp;
+{
+  struct binding *binding;
+  int modified;
+
+  /* Some sanity checks.  */
+  if (domainname == NULL || domainname[0] == '\0')
+    {
+      if (dirnamep)
+	*dirnamep = NULL;
+      if (codesetp)
+	*codesetp = NULL;
+      return;
+    }
+
+  __libc_rwlock_wrlock (_nl_state_lock);
+
+  modified = 0;
+
+  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
+    {
+      int compare = strcmp (domainname, binding->domainname);
+      if (compare == 0)
+	/* We found it!  */
+	break;
+      if (compare < 0)
+	{
+	  /* It is not in the list.  */
+	  binding = NULL;
+	  break;
+	}
+    }
+
+  if (binding != NULL)
+    {
+      if (dirnamep)
+	{
+	  const char *dirname = *dirnamep;
+
+	  if (dirname == NULL)
+	    /* The current binding has be to returned.  */
+	    *dirnamep = binding->dirname;
+	  else
+	    {
+	      /* The domain is already bound.  If the new value and the old
+		 one are equal we simply do nothing.  Otherwise replace the
+		 old binding.  */
+	      char *result = binding->dirname;
+	      if (strcmp (dirname, result) != 0)
+		{
+		  if (strcmp (dirname, _nl_default_dirname) == 0)
+		    result = (char *) _nl_default_dirname;
+		  else
+		    {
+#if defined _LIBC || defined HAVE_STRDUP
+		      result = strdup (dirname);
+#else
+		      size_t len = strlen (dirname) + 1;
+		      result = (char *) malloc (len);
+		      if (__builtin_expect (result != NULL, 1))
+			memcpy (result, dirname, len);
+#endif
+		    }
+
+		  if (__builtin_expect (result != NULL, 1))
+		    {
+		      if (binding->dirname != _nl_default_dirname)
+			free (binding->dirname);
+
+		      binding->dirname = result;
+		      modified = 1;
+		    }
+		}
+	      *dirnamep = result;
+	    }
+	}
+
+      if (codesetp)
+	{
+	  const char *codeset = *codesetp;
+
+	  if (codeset == NULL)
+	    /* The current binding has be to returned.  */
+	    *codesetp = binding->codeset;
+	  else
+	    {
+	      /* The domain is already bound.  If the new value and the old
+		 one are equal we simply do nothing.  Otherwise replace the
+		 old binding.  */
+	      char *result = binding->codeset;
+	      if (result == NULL || strcmp (codeset, result) != 0)
+		{
+#if defined _LIBC || defined HAVE_STRDUP
+		  result = strdup (codeset);
+#else
+		  size_t len = strlen (codeset) + 1;
+		  result = (char *) malloc (len);
+		  if (__builtin_expect (result != NULL, 1))
+		    memcpy (result, codeset, len);
+#endif
+
+		  if (__builtin_expect (result != NULL, 1))
+		    {
+		      if (binding->codeset != NULL)
+			free (binding->codeset);
+
+		      binding->codeset = result;
+		      binding->codeset_cntr++;
+		      modified = 1;
+		    }
+		}
+	      *codesetp = result;
+	    }
+	}
+    }
+  else if ((dirnamep == NULL || *dirnamep == NULL)
+	   && (codesetp == NULL || *codesetp == NULL))
+    {
+      /* Simply return the default values.  */
+      if (dirnamep)
+	*dirnamep = _nl_default_dirname;
+      if (codesetp)
+	*codesetp = NULL;
+    }
+  else
+    {
+      /* We have to create a new binding.  */
+      size_t len = strlen (domainname) + 1;
+      struct binding *new_binding =
+	(struct binding *) malloc (offsetof (struct binding, domainname) + len);
+
+      if (__builtin_expect (new_binding == NULL, 0))
+	goto failed;
+
+      memcpy (new_binding->domainname, domainname, len);
+
+      if (dirnamep)
+	{
+	  const char *dirname = *dirnamep;
+
+	  if (dirname == NULL)
+	    /* The default value.  */
+	    dirname = _nl_default_dirname;
+	  else
+	    {
+	      if (strcmp (dirname, _nl_default_dirname) == 0)
+		dirname = _nl_default_dirname;
+	      else
+		{
+		  char *result;
+#if defined _LIBC || defined HAVE_STRDUP
+		  result = strdup (dirname);
+		  if (__builtin_expect (result == NULL, 0))
+		    goto failed_dirname;
+#else
+		  size_t len = strlen (dirname) + 1;
+		  result = (char *) malloc (len);
+		  if (__builtin_expect (result == NULL, 0))
+		    goto failed_dirname;
+		  memcpy (result, dirname, len);
+#endif
+		  dirname = result;
+		}
+	    }
+	  *dirnamep = dirname;
+	  new_binding->dirname = (char *) dirname;
+	}
+      else
+	/* The default value.  */
+	new_binding->dirname = (char *) _nl_default_dirname;
+
+      new_binding->codeset_cntr = 0;
+
+      if (codesetp)
+	{
+	  const char *codeset = *codesetp;
+
+	  if (codeset != NULL)
+	    {
+	      char *result;
+
+#if defined _LIBC || defined HAVE_STRDUP
+	      result = strdup (codeset);
+	      if (__builtin_expect (result == NULL, 0))
+		goto failed_codeset;
+#else
+	      size_t len = strlen (codeset) + 1;
+	      result = (char *) malloc (len);
+	      if (__builtin_expect (result == NULL, 0))
+		goto failed_codeset;
+	      memcpy (result, codeset, len);
+#endif
+	      codeset = result;
+	      new_binding->codeset_cntr++;
+	    }
+	  *codesetp = codeset;
+	  new_binding->codeset = (char *) codeset;
+	}
+      else
+	new_binding->codeset = NULL;
+
+      /* Now enqueue it.  */
+      if (_nl_domain_bindings == NULL
+	  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)
+	{
+	  new_binding->next = _nl_domain_bindings;
+	  _nl_domain_bindings = new_binding;
+	}
+      else
+	{
+	  binding = _nl_domain_bindings;
+	  while (binding->next != NULL
+		 && strcmp (domainname, binding->next->domainname) > 0)
+	    binding = binding->next;
+
+	  new_binding->next = binding->next;
+	  binding->next = new_binding;
+	}
+
+      modified = 1;
+
+      /* Here we deal with memory allocation failures.  */
+      if (0)
+	{
+	failed_codeset:
+	  if (new_binding->dirname != _nl_default_dirname)
+	    free (new_binding->dirname);
+	failed_dirname:
+	  free (new_binding);
+	failed:
+	  if (dirnamep)
+	    *dirnamep = NULL;
+	  if (codesetp)
+	    *codesetp = NULL;
+	}
+    }
+
+  /* If we modified any binding, we flush the caches.  */
+  if (modified)
+    ++_nl_msg_cat_cntr;
+
+  __libc_rwlock_unlock (_nl_state_lock);
+}
+
+/* Specify that the DOMAINNAME message catalog will be found
+   in DIRNAME rather than in the system locale data base.  */
+char *
+BINDTEXTDOMAIN (domainname, dirname)
+     const char *domainname;
+     const char *dirname;
+{
+  set_binding_values (domainname, &dirname, NULL);
+  return (char *) dirname;
+}
+
+/* Specify the character encoding in which the messages from the
+   DOMAINNAME message catalog will be returned.  */
+char *
+BIND_TEXTDOMAIN_CODESET (domainname, codeset)
+     const char *domainname;
+     const char *codeset;
+{
+  set_binding_values (domainname, NULL, &codeset);
+  return (char *) codeset;
+}
+
+#ifdef _LIBC
+/* Aliases for function names in GNU C Library.  */
+weak_alias (__bindtextdomain, bindtextdomain);
+weak_alias (__bind_textdomain_codeset, bind_textdomain_codeset);
+#endif
diff -Naur orig/intl/ChangeLog patched/intl/ChangeLog
--- orig/intl/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/ChangeLog	2002-05-30 12:52:20.000000000 +0200
@@ -0,0 +1,4 @@
+2001-07-24  GNU  <bug-gnu-utils@gnu.org>
+
+	* Version 0.10.39 released.
+
diff -Naur orig/intl/config.charset patched/intl/config.charset
--- orig/intl/config.charset	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/config.charset	2002-05-30 12:52:01.000000000 +0200
@@ -0,0 +1,438 @@
+#! /bin/sh
+# Output a system dependent table of character encoding aliases.
+#
+#   Copyright (C) 2000-2001 Free Software Foundation, Inc.
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU Library General Public License as published
+#   by the Free Software Foundation; either version 2, or (at your option)
+#   any later version.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Library General Public License for more details.
+#
+#   You should have received a copy of the GNU Library General Public
+#   License along with this program; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+#   USA.
+#
+# The table consists of lines of the form
+#    ALIAS  CANONICAL
+#
+# ALIAS is the (system dependent) result of "nl_langinfo (CODESET)".
+# ALIAS is compared in a case sensitive way.
+#
+# CANONICAL is the GNU canonical name for this character encoding.
+# It must be an encoding supported by libiconv. Support by GNU libc is
+# also desirable. CANONICAL is case insensitive. Usually an upper case
+# MIME charset name is preferred.
+# The current list of GNU canonical charset names is as follows.
+#
+#       name                         used by which systems         a MIME name?
+#   ASCII, ANSI_X3.4-1968     glibc solaris freebsd
+#   ISO-8859-1                glibc aix hpux irix osf solaris freebsd   yes
+#   ISO-8859-2                glibc aix hpux irix osf solaris freebsd   yes
+#   ISO-8859-3                glibc                                     yes
+#   ISO-8859-4                osf solaris freebsd                       yes
+#   ISO-8859-5                glibc aix hpux irix osf solaris freebsd   yes
+#   ISO-8859-6                glibc aix hpux solaris                    yes
+#   ISO-8859-7                glibc aix hpux irix osf solaris           yes
+#   ISO-8859-8                glibc aix hpux osf solaris                yes
+#   ISO-8859-9                glibc aix hpux irix osf solaris           yes
+#   ISO-8859-13               glibc
+#   ISO-8859-15               glibc aix osf solaris freebsd
+#   KOI8-R                    glibc solaris freebsd                     yes
+#   KOI8-U                    glibc freebsd                             yes
+#   CP437                     dos
+#   CP775                     dos
+#   CP850                     aix osf dos
+#   CP852                     dos
+#   CP855                     dos
+#   CP856                     aix
+#   CP857                     dos
+#   CP861                     dos
+#   CP862                     dos
+#   CP864                     dos
+#   CP865                     dos
+#   CP866                     freebsd dos
+#   CP869                     dos
+#   CP874                     win32 dos
+#   CP922                     aix
+#   CP932                     aix win32 dos
+#   CP943                     aix
+#   CP949                     osf win32 dos
+#   CP950                     win32 dos
+#   CP1046                    aix
+#   CP1124                    aix
+#   CP1129                    aix
+#   CP1250                    win32
+#   CP1251                    glibc win32
+#   CP1252                    aix win32
+#   CP1253                    win32
+#   CP1254                    win32
+#   CP1255                    win32
+#   CP1256                    win32
+#   CP1257                    win32
+#   GB2312                    glibc aix hpux irix solaris freebsd       yes
+#   EUC-JP                    glibc aix hpux irix osf solaris freebsd   yes
+#   EUC-KR                    glibc aix hpux irix osf solaris freebsd   yes
+#   EUC-TW                    glibc aix hpux irix osf solaris
+#   BIG5                      glibc aix hpux osf solaris freebsd        yes
+#   BIG5-HKSCS                glibc
+#   GBK                       aix osf win32 dos
+#   GB18030                   glibc
+#   SHIFT_JIS                 hpux osf solaris freebsd                  yes
+#   JOHAB                     glibc win32
+#   TIS-620                   glibc aix hpux osf solaris
+#   VISCII                    glibc                                     yes
+#   HP-ROMAN8                 hpux
+#   HP-ARABIC8                hpux
+#   HP-GREEK8                 hpux
+#   HP-HEBREW8                hpux
+#   HP-TURKISH8               hpux
+#   HP-KANA8                  hpux
+#   DEC-KANJI                 osf
+#   DEC-HANYU                 osf
+#   UTF-8                     glibc aix hpux osf solaris                yes
+#
+# Note: Names which are not marked as being a MIME name should not be used in
+# Internet protocols for information interchange (mail, news, etc.).
+#
+# Note: ASCII and ANSI_X3.4-1968 are synonymous canonical names. Applications
+# must understand both names and treat them as equivalent.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+
+host="$1"
+os=`echo "$host" | sed -e 's/^[^-]*-[^-]*-\(.*\)$/\1/'`
+echo "# This file contains a table of character encoding aliases,"
+echo "# suitable for operating system '${os}'."
+echo "# It was automatically generated from config.charset."
+# List of references, updated during installation:
+echo "# Packages using this file: "
+case "$os" in
+    linux* | *-gnu*)
+	# With glibc-2.1 or newer, we don't need any canonicalization,
+	# because glibc has iconv and both glibc and libiconv support all
+	# GNU canonical names directly. Therefore, the Makefile does not
+	# need to install the alias file at all.
+	# The following applies only to glibc-2.0.x and older libcs.
+	echo "ISO_646.IRV:1983 ASCII"
+	;;
+    aix*)
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-6 ISO-8859-6"
+	echo "ISO8859-7 ISO-8859-7"
+	echo "ISO8859-8 ISO-8859-8"
+	echo "ISO8859-9 ISO-8859-9"
+	echo "ISO8859-15 ISO-8859-15"
+	echo "IBM-850 CP850"
+	echo "IBM-856 CP856"
+	echo "IBM-921 ISO-8859-13"
+	echo "IBM-922 CP922"
+	echo "IBM-932 CP932"
+	echo "IBM-943 CP943"
+	echo "IBM-1046 CP1046"
+	echo "IBM-1124 CP1124"
+	echo "IBM-1129 CP1129"
+	echo "IBM-1252 CP1252"
+	echo "IBM-eucCN GB2312"
+	echo "IBM-eucJP EUC-JP"
+	echo "IBM-eucKR EUC-KR"
+	echo "IBM-eucTW EUC-TW"
+	echo "big5 BIG5"
+	echo "GBK GBK"
+	echo "TIS-620 TIS-620"
+	echo "UTF-8 UTF-8"
+	;;
+    hpux*)
+	echo "iso88591 ISO-8859-1"
+	echo "iso88592 ISO-8859-2"
+	echo "iso88595 ISO-8859-5"
+	echo "iso88596 ISO-8859-6"
+	echo "iso88597 ISO-8859-7"
+	echo "iso88598 ISO-8859-8"
+	echo "iso88599 ISO-8859-9"
+	echo "iso885915 ISO-8859-15"
+	echo "roman8 HP-ROMAN8"
+	echo "arabic8 HP-ARABIC8"
+	echo "greek8 HP-GREEK8"
+	echo "hebrew8 HP-HEBREW8"
+	echo "turkish8 HP-TURKISH8"
+	echo "kana8 HP-KANA8"
+	echo "tis620 TIS-620"
+	echo "big5 BIG5"
+	echo "eucJP EUC-JP"
+	echo "eucKR EUC-KR"
+	echo "eucTW EUC-TW"
+	echo "hp15CN GB2312"
+	#echo "ccdc ?" # what is this?
+	echo "SJIS SHIFT_JIS"
+	echo "utf8 UTF-8"
+	;;
+    irix*)
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-7 ISO-8859-7"
+	echo "ISO8859-9 ISO-8859-9"
+	echo "eucCN GB2312"
+	echo "eucJP EUC-JP"
+	echo "eucKR EUC-KR"
+	echo "eucTW EUC-TW"
+	;;
+    osf*)
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-4 ISO-8859-4"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-7 ISO-8859-7"
+	echo "ISO8859-8 ISO-8859-8"
+	echo "ISO8859-9 ISO-8859-9"
+	echo "ISO8859-15 ISO-8859-15"
+	echo "cp850 CP850"
+	echo "big5 BIG5"
+	echo "dechanyu DEC-HANYU"
+	echo "dechanzi GB2312"
+	echo "deckanji DEC-KANJI"
+	echo "deckorean EUC-KR"
+	echo "eucJP EUC-JP"
+	echo "eucKR EUC-KR"
+	echo "eucTW EUC-TW"
+	echo "GBK GBK"
+	echo "KSC5601 CP949"
+	echo "sdeckanji EUC-JP"
+	echo "SJIS SHIFT_JIS"
+	echo "TACTIS TIS-620"
+	echo "UTF-8 UTF-8"
+	;;
+    solaris*)
+	echo "646 ASCII"
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-4 ISO-8859-4"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-6 ISO-8859-6"
+	echo "ISO8859-7 ISO-8859-7"
+	echo "ISO8859-8 ISO-8859-8"
+	echo "ISO8859-9 ISO-8859-9"
+	echo "ISO8859-15 ISO-8859-15"
+	echo "koi8-r KOI8-R"
+	echo "BIG5 BIG5"
+	echo "gb2312 GB2312"
+	echo "cns11643 EUC-TW"
+	echo "5601 EUC-KR"
+	echo "eucJP EUC-JP"
+	echo "PCK SHIFT_JIS"
+	echo "TIS620.2533 TIS-620"
+	#echo "sun_eu_greek ?" # what is this?
+	echo "UTF-8 UTF-8"
+	;;
+    freebsd*)
+	# FreeBSD 4.2 doesn't have nl_langinfo(CODESET); therefore
+	# localcharset.c falls back to using the full locale name
+	# from the environment variables.
+	echo "C ASCII"
+	echo "US-ASCII ASCII"
+	for l in la_LN lt_LN; do
+	  echo "$l.ASCII ASCII"
+	done
+	for l in da_DK de_AT de_CH de_DE en_AU en_CA en_GB en_US es_ES \
+	         fi_FI fr_BE fr_CA fr_CH fr_FR is_IS it_CH it_IT la_LN \
+	         lt_LN nl_BE nl_NL no_NO pt_PT sv_SE; do
+	  echo "$l.ISO_8859-1 ISO-8859-1"
+	  echo "$l.DIS_8859-15 ISO-8859-15"
+	done
+	for l in cs_CZ hr_HR hu_HU la_LN lt_LN pl_PL sl_SI; do
+	  echo "$l.ISO_8859-2 ISO-8859-2"
+	done
+	for l in la_LN lt_LT; do
+	  echo "$l.ISO_8859-4 ISO-8859-4"
+	done
+	for l in ru_RU ru_SU; do
+	  echo "$l.KOI8-R KOI8-R"
+	  echo "$l.ISO_8859-5 ISO-8859-5"
+	  echo "$l.CP866 CP866"
+	done
+	echo "uk_UA.KOI8-U KOI8-U"
+	echo "zh_TW.BIG5 BIG5"
+	echo "zh_TW.Big5 BIG5"
+	echo "zh_CN.EUC GB2312"
+	echo "ja_JP.EUC EUC-JP"
+	echo "ja_JP.SJIS SHIFT_JIS"
+	echo "ja_JP.Shift_JIS SHIFT_JIS"
+	echo "ko_KR.EUC EUC-KR"
+	;;
+    beos*)
+	# BeOS has a single locale, and it has UTF-8 encoding.
+	echo "* UTF-8"
+	;;
+    msdosdjgpp*)
+	# DJGPP 2.03 doesn't have nl_langinfo(CODESET); therefore
+	# localcharset.c falls back to using the full locale name
+	# from the environment variables.
+	echo "#"
+	echo "# The encodings given here may not all be correct."
+	echo "# If you find that the encoding given for your language and"
+	echo "# country is not the one your DOS machine actually uses, just"
+	echo "# correct it in this file, and send a mail to"
+	echo "# Juan Manuel Guerrero <st001906@hrz1.hrz.tu-darmstadt.de>"
+	echo "# and Bruno Haible <haible@clisp.cons.org>."
+	echo "#"
+	echo "C ASCII"
+	# ISO-8859-1 languages
+	echo "ca CP850"
+	echo "ca_ES CP850"
+	echo "da CP865"    # not CP850 ??
+	echo "da_DK CP865" # not CP850 ??
+	echo "de CP850"
+	echo "de_AT CP850"
+	echo "de_CH CP850"
+	echo "de_DE CP850"
+	echo "en CP850"
+	echo "en_AU CP850" # not CP437 ??
+	echo "en_CA CP850"
+	echo "en_GB CP850"
+	echo "en_NZ CP437"
+	echo "en_US CP437"
+	echo "en_ZA CP850" # not CP437 ??
+	echo "es CP850"
+	echo "es_AR CP850"
+	echo "es_BO CP850"
+	echo "es_CL CP850"
+	echo "es_CO CP850"
+	echo "es_CR CP850"
+	echo "es_CU CP850"
+	echo "es_DO CP850"
+	echo "es_EC CP850"
+	echo "es_ES CP850"
+	echo "es_GT CP850"
+	echo "es_HN CP850"
+	echo "es_MX CP850"
+	echo "es_NI CP850"
+	echo "es_PA CP850"
+	echo "es_PY CP850"
+	echo "es_PE CP850"
+	echo "es_SV CP850"
+	echo "es_UY CP850"
+	echo "es_VE CP850"
+	echo "et CP850"
+	echo "et_EE CP850"
+	echo "eu CP850"
+	echo "eu_ES CP850"
+	echo "fi CP850"
+	echo "fi_FI CP850"
+	echo "fr CP850"
+	echo "fr_BE CP850"
+	echo "fr_CA CP850"
+	echo "fr_CH CP850"
+	echo "fr_FR CP850"
+	echo "ga CP850"
+	echo "ga_IE CP850"
+	echo "gd CP850"
+	echo "gd_GB CP850"
+	echo "gl CP850"
+	echo "gl_ES CP850"
+	echo "id CP850"    # not CP437 ??
+	echo "id_ID CP850" # not CP437 ??
+	echo "is CP861"    # not CP850 ??
+	echo "is_IS CP861" # not CP850 ??
+	echo "it CP850"
+	echo "it_CH CP850"
+	echo "it_IT CP850"
+	echo "lt CP775"
+	echo "lt_LT CP775"
+	echo "lv CP775"
+	echo "lv_LV CP775"
+	echo "nb CP865"    # not CP850 ??
+	echo "nb_NO CP865" # not CP850 ??
+	echo "nl CP850"
+	echo "nl_BE CP850"
+	echo "nl_NL CP850"
+	echo "nn CP865"    # not CP850 ??
+	echo "nn_NO CP865" # not CP850 ??
+	echo "no CP865"    # not CP850 ??
+	echo "no_NO CP865" # not CP850 ??
+	echo "pt CP850"
+	echo "pt_BR CP850"
+	echo "pt_PT CP850"
+	echo "sv CP850"
+	echo "sv_SE CP850"
+	# ISO-8859-2 languages
+	echo "cs CP852"
+	echo "cs_CZ CP852"
+	echo "hr CP852"
+	echo "hr_HR CP852"
+	echo "hu CP852"
+	echo "hu_HU CP852"
+	echo "pl CP852"
+	echo "pl_PL CP852"
+	echo "ro CP852"
+	echo "ro_RO CP852"
+	echo "sk CP852"
+	echo "sk_SK CP852"
+	echo "sl CP852"
+	echo "sl_SI CP852"
+	echo "sq CP852"
+	echo "sq_AL CP852"
+	echo "sr CP852"    # CP852 or CP866 or CP855 ??
+	echo "sr_YU CP852" # CP852 or CP866 or CP855 ??
+	# ISO-8859-3 languages
+	echo "mt CP850"
+	echo "mt_MT CP850"
+	# ISO-8859-5 languages
+	echo "be CP866"
+	echo "be_BE CP866"
+	echo "bg CP866"    # not CP855 ??
+	echo "bg_BG CP866" # not CP855 ??
+	echo "mk CP866"    # not CP855 ??
+	echo "mk_MK CP866" # not CP855 ??
+	echo "ru KOI8-R"    # not CP866 ??
+	echo "ru_RU KOI8-R" # not CP866 ??
+	# ISO-8859-6 languages
+	echo "ar CP864"
+	echo "ar_AE CP864"
+	echo "ar_DZ CP864"
+	echo "ar_EG CP864"
+	echo "ar_IQ CP864"
+	echo "ar_IR CP864"
+	echo "ar_JO CP864"
+	echo "ar_KW CP864"
+	echo "ar_MA CP864"
+	echo "ar_OM CP864"
+	echo "ar_QA CP864"
+	echo "ar_SA CP864"
+	echo "ar_SY CP864"
+	# ISO-8859-7 languages
+	echo "el CP869"
+	echo "el_GR CP869"
+	# ISO-8859-8 languages
+	echo "he CP862"
+	echo "he_IL CP862"
+	# ISO-8859-9 languages
+	echo "tr CP857"
+	echo "tr_TR CP857"
+	# Japanese
+	echo "ja CP932"
+	echo "ja_JP CP932"
+	# Chinese
+	echo "zh_CN GBK"
+	echo "zh_TW CP950" # not CP938 ??
+	# Korean
+	echo "kr CP949"    # not CP934 ??
+	echo "kr_KR CP949" # not CP934 ??
+	# Thai
+	echo "th CP874"
+	echo "th_TH CP874"
+	# Other
+	echo "eo CP850"
+	echo "eo_EO CP850"
+	;;
+esac
diff -Naur orig/intl/dcgettext.c patched/intl/dcgettext.c
--- orig/intl/dcgettext.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/dcgettext.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,57 @@
+/* Implementation of the dcgettext(3) function.
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DCGETTEXT __dcgettext
+# define DCIGETTEXT __dcigettext
+#else
+# define DCGETTEXT dcgettext__
+# define DCIGETTEXT dcigettext__
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+char *
+DCGETTEXT (domainname, msgid, category)
+     const char *domainname;
+     const char *msgid;
+     int category;
+{
+  return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__dcgettext, dcgettext);
+#endif
diff -Naur orig/intl/dcigettext.c patched/intl/dcigettext.c
--- orig/intl/dcigettext.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/dcigettext.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,1258 @@
+/* Implementation of the internal dcigettext function.
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+/* Tell glibc's <string.h> to provide a prototype for mempcpy().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE	1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+# define HAVE_ALLOCA 1
+#else
+# if defined HAVE_ALLOCA_H || defined _LIBC
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+ #pragma alloca
+#  else
+#   ifndef alloca
+char *alloca ();
+#   endif
+#  endif
+# endif
+#endif
+
+#include <errno.h>
+#ifndef errno
+extern int errno;
+#endif
+#ifndef __set_errno
+# define __set_errno(val) errno = (val)
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+
+#include <string.h>
+#if !HAVE_STRCHR && !defined _LIBC
+# ifndef strchr
+#  define strchr index
+# endif
+#endif
+
+#if defined HAVE_UNISTD_H || defined _LIBC
+# include <unistd.h>
+#endif
+
+#include <locale.h>
+
+#if defined HAVE_SYS_PARAM_H || defined _LIBC
+# include <sys/param.h>
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+#include "hash-string.h"
+
+/* Thread safetyness.  */
+#ifdef _LIBC
+# include <bits/libc-lock.h>
+#else
+/* Provide dummy implementation if this is outside glibc.  */
+# define __libc_lock_define_initialized(CLASS, NAME)
+# define __libc_lock_lock(NAME)
+# define __libc_lock_unlock(NAME)
+# define __libc_rwlock_define_initialized(CLASS, NAME)
+# define __libc_rwlock_rdlock(NAME)
+# define __libc_rwlock_unlock(NAME)
+#endif
+
+/* Alignment of types.  */
+#if defined __GNUC__ && __GNUC__ >= 2
+# define alignof(TYPE) __alignof__ (TYPE)
+#else
+# define alignof(TYPE) \
+    ((int) &((struct { char dummy1; TYPE dummy2; } *) 0)->dummy2)
+#endif
+
+/* The internal variables in the standalone libintl.a must have different
+   names than the internal variables in GNU libc, otherwise programs
+   using libintl.a cannot be linked statically.  */
+#if !defined _LIBC
+# define _nl_default_default_domain _nl_default_default_domain__
+# define _nl_current_default_domain _nl_current_default_domain__
+# define _nl_default_dirname _nl_default_dirname__
+# define _nl_domain_bindings _nl_domain_bindings__
+#endif
+
+/* Some compilers, like SunOS4 cc, don't have offsetof in <stddef.h>.  */
+#ifndef offsetof
+# define offsetof(type,ident) ((size_t)&(((type*)0)->ident))
+#endif
+
+/* @@ end of prolog @@ */
+
+#ifdef _LIBC
+/* Rename the non ANSI C functions.  This is required by the standard
+   because some ANSI C functions will require linking with this object
+   file and the name space must not be polluted.  */
+# define getcwd __getcwd
+# ifndef stpcpy
+#  define stpcpy __stpcpy
+# endif
+# define tfind __tfind
+#else
+# if !defined HAVE_GETCWD
+char *getwd ();
+#  define getcwd(buf, max) getwd (buf)
+# else
+char *getcwd ();
+# endif
+# ifndef HAVE_STPCPY
+static char *stpcpy PARAMS ((char *dest, const char *src));
+# endif
+# ifndef HAVE_MEMPCPY
+static void *mempcpy PARAMS ((void *dest, const void *src, size_t n));
+# endif
+#endif
+
+/* Amount to increase buffer size by in each try.  */
+#define PATH_INCR 32
+
+/* The following is from pathmax.h.  */
+/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define
+   PATH_MAX but might cause redefinition warnings when sys/param.h is
+   later included (as on MORE/BSD 4.3).  */
+#if defined _POSIX_VERSION || (defined HAVE_LIMITS_H && !defined __GNUC__)
+# include <limits.h>
+#endif
+
+#ifndef _POSIX_PATH_MAX
+# define _POSIX_PATH_MAX 255
+#endif
+
+#if !defined PATH_MAX && defined _PC_PATH_MAX
+# define PATH_MAX (pathconf ("/", _PC_PATH_MAX) < 1 ? 1024 : pathconf ("/", _PC_PATH_MAX))
+#endif
+
+/* Don't include sys/param.h if it already has been.  */
+#if defined HAVE_SYS_PARAM_H && !defined PATH_MAX && !defined MAXPATHLEN
+# include <sys/param.h>
+#endif
+
+#if !defined PATH_MAX && defined MAXPATHLEN
+# define PATH_MAX MAXPATHLEN
+#endif
+
+#ifndef PATH_MAX
+# define PATH_MAX _POSIX_PATH_MAX
+#endif
+
+/* Pathname support.
+   ISSLASH(C)           tests whether C is a directory separator character.
+   IS_ABSOLUTE_PATH(P)  tests whether P is an absolute path.  If it is not,
+                        it may be concatenated to a directory pathname.
+   IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
+ */
+#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
+# define ISSLASH(C) ((C) == '/' || (C) == '\\')
+# define HAS_DEVICE(P) \
+    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
+     && (P)[1] == ':')
+# define IS_ABSOLUTE_PATH(P) (ISSLASH ((P)[0]) || HAS_DEVICE (P))
+# define IS_PATH_WITH_DIR(P) \
+    (strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
+#else
+  /* Unix */
+# define ISSLASH(C) ((C) == '/')
+# define IS_ABSOLUTE_PATH(P) ISSLASH ((P)[0])
+# define IS_PATH_WITH_DIR(P) (strchr (P, '/') != NULL)
+#endif
+
+/* XPG3 defines the result of `setlocale (category, NULL)' as:
+   ``Directs `setlocale()' to query `category' and return the current
+     setting of `local'.''
+   However it does not specify the exact format.  Neither do SUSV2 and
+   ISO C 99.  So we can use this feature only on selected systems (e.g.
+   those using GNU C Library).  */
+#if defined _LIBC || (defined __GNU_LIBRARY__ && __GNU_LIBRARY__ >= 2)
+# define HAVE_LOCALE_NULL
+#endif
+
+/* This is the type used for the search tree where known translations
+   are stored.  */
+struct known_translation_t
+{
+  /* Domain in which to search.  */
+  char *domainname;
+
+  /* The category.  */
+  int category;
+
+  /* State of the catalog counter at the point the string was found.  */
+  int counter;
+
+  /* Catalog where the string was found.  */
+  struct loaded_l10nfile *domain;
+
+  /* And finally the translation.  */
+  const char *translation;
+  size_t translation_length;
+
+  /* Pointer to the string in question.  */
+  char msgid[ZERO];
+};
+
+/* Root of the search tree with known translations.  We can use this
+   only if the system provides the `tsearch' function family.  */
+#if defined HAVE_TSEARCH || defined _LIBC
+# include <search.h>
+
+static void *root;
+
+# ifdef _LIBC
+#  define tsearch __tsearch
+# endif
+
+/* Function to compare two entries in the table of known translations.  */
+static int transcmp PARAMS ((const void *p1, const void *p2));
+static int
+transcmp (p1, p2)
+     const void *p1;
+     const void *p2;
+{
+  const struct known_translation_t *s1;
+  const struct known_translation_t *s2;
+  int result;
+
+  s1 = (const struct known_translation_t *) p1;
+  s2 = (const struct known_translation_t *) p2;
+
+  result = strcmp (s1->msgid, s2->msgid);
+  if (result == 0)
+    {
+      result = strcmp (s1->domainname, s2->domainname);
+      if (result == 0)
+	/* We compare the category last (though this is the cheapest
+	   operation) since it is hopefully always the same (namely
+	   LC_MESSAGES).  */
+	result = s1->category - s2->category;
+    }
+
+  return result;
+}
+#endif
+
+/* Name of the default domain used for gettext(3) prior any call to
+   textdomain(3).  The default value for this is "messages".  */
+const char _nl_default_default_domain[] = "messages";
+
+/* Value used as the default domain for gettext(3).  */
+const char *_nl_current_default_domain = _nl_default_default_domain;
+
+/* Contains the default location of the message catalogs.  */
+const char _nl_default_dirname[] = LOCALEDIR;
+
+/* List with bindings of specific domains created by bindtextdomain()
+   calls.  */
+struct binding *_nl_domain_bindings;
+
+/* Prototypes for local functions.  */
+static char *plural_lookup PARAMS ((struct loaded_l10nfile *domain,
+				    unsigned long int n,
+				    const char *translation,
+				    size_t translation_len))
+     internal_function;
+static unsigned long int plural_eval PARAMS ((struct expression *pexp,
+					      unsigned long int n))
+     internal_function;
+static const char *category_to_name PARAMS ((int category)) internal_function;
+static const char *guess_category_value PARAMS ((int category,
+						 const char *categoryname))
+     internal_function;
+
+
+/* For those loosing systems which don't have `alloca' we have to add
+   some additional code emulating it.  */
+#ifdef HAVE_ALLOCA
+/* Nothing has to be done.  */
+# define ADD_BLOCK(list, address) /* nothing */
+# define FREE_BLOCKS(list) /* nothing */
+#else
+struct block_list
+{
+  void *address;
+  struct block_list *next;
+};
+# define ADD_BLOCK(list, addr)						      \
+  do {									      \
+    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \
+    /* If we cannot get a free block we cannot add the new element to	      \
+       the list.  */							      \
+    if (newp != NULL) {							      \
+      newp->address = (addr);						      \
+      newp->next = (list);						      \
+      (list) = newp;							      \
+    }									      \
+  } while (0)
+# define FREE_BLOCKS(list)						      \
+  do {									      \
+    while (list != NULL) {						      \
+      struct block_list *old = list;					      \
+      list = list->next;						      \
+      free (old);							      \
+    }									      \
+  } while (0)
+# undef alloca
+# define alloca(size) (malloc (size))
+#endif	/* have alloca */
+
+
+#ifdef _LIBC
+/* List of blocks allocated for translations.  */
+typedef struct transmem_list
+{
+  struct transmem_list *next;
+  char data[ZERO];
+} transmem_block_t;
+static struct transmem_list *transmem_list;
+#else
+typedef unsigned char transmem_block_t;
+#endif
+
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DCIGETTEXT __dcigettext
+#else
+# define DCIGETTEXT dcigettext__
+#endif
+
+/* Lock variable to protect the global data in the gettext implementation.  */
+#ifdef _LIBC
+__libc_rwlock_define_initialized (, _nl_state_lock)
+#endif
+
+/* Checking whether the binaries runs SUID must be done and glibc provides
+   easier methods therefore we make a difference here.  */
+#ifdef _LIBC
+# define ENABLE_SECURE __libc_enable_secure
+# define DETERMINE_SECURE
+#else
+# ifndef HAVE_GETUID
+#  define getuid() 0
+# endif
+# ifndef HAVE_GETGID
+#  define getgid() 0
+# endif
+# ifndef HAVE_GETEUID
+#  define geteuid() getuid()
+# endif
+# ifndef HAVE_GETEGID
+#  define getegid() getgid()
+# endif
+static int enable_secure;
+# define ENABLE_SECURE (enable_secure == 1)
+# define DETERMINE_SECURE \
+  if (enable_secure == 0)						      \
+    {									      \
+      if (getuid () != geteuid () || getgid () != getegid ())		      \
+	enable_secure = 1;						      \
+      else								      \
+	enable_secure = -1;						      \
+    }
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current
+   CATEGORY locale and, if PLURAL is nonzero, search over string
+   depending on the plural form determined by N.  */
+char *
+DCIGETTEXT (domainname, msgid1, msgid2, plural, n, category)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     int plural;
+     unsigned long int n;
+     int category;
+{
+#ifndef HAVE_ALLOCA
+  struct block_list *block_list = NULL;
+#endif
+  struct loaded_l10nfile *domain;
+  struct binding *binding;
+  const char *categoryname;
+  const char *categoryvalue;
+  char *dirname, *xdomainname;
+  char *single_locale;
+  char *retval;
+  size_t retlen;
+  int saved_errno;
+#if defined HAVE_TSEARCH || defined _LIBC
+  struct known_translation_t *search;
+  struct known_translation_t **foundp = NULL;
+  size_t msgid_len;
+#endif
+  size_t domainname_len;
+
+  /* If no real MSGID is given return NULL.  */
+  if (msgid1 == NULL)
+    return NULL;
+
+  __libc_rwlock_rdlock (_nl_state_lock);
+
+  /* If DOMAINNAME is NULL, we are interested in the default domain.  If
+     CATEGORY is not LC_MESSAGES this might not make much sense but the
+     definition left this undefined.  */
+  if (domainname == NULL)
+    domainname = _nl_current_default_domain;
+
+#if defined HAVE_TSEARCH || defined _LIBC
+  msgid_len = strlen (msgid1) + 1;
+
+  /* Try to find the translation among those which we found at
+     some time.  */
+  search = (struct known_translation_t *)
+	   alloca (offsetof (struct known_translation_t, msgid) + msgid_len);
+  memcpy (search->msgid, msgid1, msgid_len);
+  search->domainname = (char *) domainname;
+  search->category = category;
+
+  foundp = (struct known_translation_t **) tfind (search, &root, transcmp);
+  if (foundp != NULL && (*foundp)->counter == _nl_msg_cat_cntr)
+    {
+      /* Now deal with plural.  */
+      if (plural)
+	retval = plural_lookup ((*foundp)->domain, n, (*foundp)->translation,
+				(*foundp)->translation_length);
+      else
+	retval = (char *) (*foundp)->translation;
+
+      __libc_rwlock_unlock (_nl_state_lock);
+      return retval;
+    }
+#endif
+
+  /* Preserve the `errno' value.  */
+  saved_errno = errno;
+
+  /* See whether this is a SUID binary or not.  */
+  DETERMINE_SECURE;
+
+  /* First find matching binding.  */
+  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
+    {
+      int compare = strcmp (domainname, binding->domainname);
+      if (compare == 0)
+	/* We found it!  */
+	break;
+      if (compare < 0)
+	{
+	  /* It is not in the list.  */
+	  binding = NULL;
+	  break;
+	}
+    }
+
+  if (binding == NULL)
+    dirname = (char *) _nl_default_dirname;
+  else if (IS_ABSOLUTE_PATH (binding->dirname))
+    dirname = binding->dirname;
+  else
+    {
+      /* We have a relative path.  Make it absolute now.  */
+      size_t dirname_len = strlen (binding->dirname) + 1;
+      size_t path_max;
+      char *ret;
+
+      path_max = (unsigned int) PATH_MAX;
+      path_max += 2;		/* The getcwd docs say to do this.  */
+
+      for (;;)
+	{
+	  dirname = (char *) alloca (path_max + dirname_len);
+	  ADD_BLOCK (block_list, dirname);
+
+	  __set_errno (0);
+	  ret = getcwd (dirname, path_max);
+	  if (ret != NULL || errno != ERANGE)
+	    break;
+
+	  path_max += path_max / 2;
+	  path_max += PATH_INCR;
+	}
+
+      if (ret == NULL)
+	{
+	  /* We cannot get the current working directory.  Don't signal an
+	     error but simply return the default string.  */
+	  FREE_BLOCKS (block_list);
+	  __libc_rwlock_unlock (_nl_state_lock);
+	  __set_errno (saved_errno);
+	  return (plural == 0
+		  ? (char *) msgid1
+		  /* Use the Germanic plural rule.  */
+		  : n == 1 ? (char *) msgid1 : (char *) msgid2);
+	}
+
+      stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
+    }
+
+  /* Now determine the symbolic name of CATEGORY and its value.  */
+  categoryname = category_to_name (category);
+  categoryvalue = guess_category_value (category, categoryname);
+
+  domainname_len = strlen (domainname);
+  xdomainname = (char *) alloca (strlen (categoryname)
+				 + domainname_len + 5);
+  ADD_BLOCK (block_list, xdomainname);
+
+  stpcpy (mempcpy (stpcpy (stpcpy (xdomainname, categoryname), "/"),
+		  domainname, domainname_len),
+	  ".mo");
+
+  /* Creating working area.  */
+  single_locale = (char *) alloca (strlen (categoryvalue) + 1);
+  ADD_BLOCK (block_list, single_locale);
+
+
+  /* Search for the given string.  This is a loop because we perhaps
+     got an ordered list of languages to consider for the translation.  */
+  while (1)
+    {
+      /* Make CATEGORYVALUE point to the next element of the list.  */
+      while (categoryvalue[0] != '\0' && categoryvalue[0] == ':')
+	++categoryvalue;
+      if (categoryvalue[0] == '\0')
+	{
+	  /* The whole contents of CATEGORYVALUE has been searched but
+	     no valid entry has been found.  We solve this situation
+	     by implicitly appending a "C" entry, i.e. no translation
+	     will take place.  */
+	  single_locale[0] = 'C';
+	  single_locale[1] = '\0';
+	}
+      else
+	{
+	  char *cp = single_locale;
+	  while (categoryvalue[0] != '\0' && categoryvalue[0] != ':')
+	    *cp++ = *categoryvalue++;
+	  *cp = '\0';
+
+	  /* When this is a SUID binary we must not allow accessing files
+	     outside the dedicated directories.  */
+	  if (ENABLE_SECURE && IS_PATH_WITH_DIR (single_locale))
+	    /* Ingore this entry.  */
+	    continue;
+	}
+
+      /* If the current locale value is C (or POSIX) we don't load a
+	 domain.  Return the MSGID.  */
+      if (strcmp (single_locale, "C") == 0
+	  || strcmp (single_locale, "POSIX") == 0)
+	{
+	  FREE_BLOCKS (block_list);
+	  __libc_rwlock_unlock (_nl_state_lock);
+	  __set_errno (saved_errno);
+	  return (plural == 0
+		  ? (char *) msgid1
+		  /* Use the Germanic plural rule.  */
+		  : n == 1 ? (char *) msgid1 : (char *) msgid2);
+	}
+
+
+      /* Find structure describing the message catalog matching the
+	 DOMAINNAME and CATEGORY.  */
+      domain = _nl_find_domain (dirname, single_locale, xdomainname, binding);
+
+      if (domain != NULL)
+	{
+	  retval = _nl_find_msg (domain, binding, msgid1, &retlen);
+
+	  if (retval == NULL)
+	    {
+	      int cnt;
+
+	      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)
+		{
+		  retval = _nl_find_msg (domain->successor[cnt], binding,
+					 msgid1, &retlen);
+
+		  if (retval != NULL)
+		    {
+		      domain = domain->successor[cnt];
+		      break;
+		    }
+		}
+	    }
+
+	  if (retval != NULL)
+	    {
+	      /* Found the translation of MSGID1 in domain DOMAIN:
+		 starting at RETVAL, RETLEN bytes.  */
+	      FREE_BLOCKS (block_list);
+	      __set_errno (saved_errno);
+#if defined HAVE_TSEARCH || defined _LIBC
+	      if (foundp == NULL)
+		{
+		  /* Create a new entry and add it to the search tree.  */
+		  struct known_translation_t *newp;
+
+		  newp = (struct known_translation_t *)
+		    malloc (offsetof (struct known_translation_t, msgid)
+			    + msgid_len + domainname_len + 1);
+		  if (newp != NULL)
+		    {
+		      newp->domainname =
+			mempcpy (newp->msgid, msgid1, msgid_len);
+		      memcpy (newp->domainname, domainname, domainname_len + 1);
+		      newp->category = category;
+		      newp->counter = _nl_msg_cat_cntr;
+		      newp->domain = domain;
+		      newp->translation = retval;
+		      newp->translation_length = retlen;
+
+		      /* Insert the entry in the search tree.  */
+		      foundp = (struct known_translation_t **)
+			tsearch (newp, &root, transcmp);
+		      if (foundp == NULL
+			  || __builtin_expect (*foundp != newp, 0))
+			/* The insert failed.  */
+			free (newp);
+		    }
+		}
+	      else
+		{
+		  /* We can update the existing entry.  */
+		  (*foundp)->counter = _nl_msg_cat_cntr;
+		  (*foundp)->domain = domain;
+		  (*foundp)->translation = retval;
+		  (*foundp)->translation_length = retlen;
+		}
+#endif
+	      /* Now deal with plural.  */
+	      if (plural)
+		retval = plural_lookup (domain, n, retval, retlen);
+
+	      __libc_rwlock_unlock (_nl_state_lock);
+	      return retval;
+	    }
+	}
+    }
+  /* NOTREACHED */
+}
+
+
+char *
+internal_function
+_nl_find_msg (domain_file, domainbinding, msgid, lengthp)
+     struct loaded_l10nfile *domain_file;
+     struct binding *domainbinding;
+     const char *msgid;
+     size_t *lengthp;
+{
+  struct loaded_domain *domain;
+  size_t act;
+  char *result;
+  size_t resultlen;
+
+  if (domain_file->decided == 0)
+    _nl_load_domain (domain_file, domainbinding);
+
+  if (domain_file->data == NULL)
+    return NULL;
+
+  domain = (struct loaded_domain *) domain_file->data;
+
+  /* Locate the MSGID and its translation.  */
+  if (domain->hash_size > 2 && domain->hash_tab != NULL)
+    {
+      /* Use the hashing table.  */
+      nls_uint32 len = strlen (msgid);
+      nls_uint32 hash_val = hash_string (msgid);
+      nls_uint32 idx = hash_val % domain->hash_size;
+      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));
+
+      while (1)
+	{
+	  nls_uint32 nstr = W (domain->must_swap, domain->hash_tab[idx]);
+
+	  if (nstr == 0)
+	    /* Hash table entry is empty.  */
+	    return NULL;
+
+	  /* Compare msgid with the original string at index nstr-1.
+	     We compare the lengths with >=, not ==, because plural entries
+	     are represented by strings with an embedded NUL.  */
+	  if (W (domain->must_swap, domain->orig_tab[nstr - 1].length) >= len
+	      && (strcmp (msgid,
+			  domain->data + W (domain->must_swap,
+					    domain->orig_tab[nstr - 1].offset))
+		  == 0))
+	    {
+	      act = nstr - 1;
+	      goto found;
+	    }
+
+	  if (idx >= domain->hash_size - incr)
+	    idx -= domain->hash_size - incr;
+	  else
+	    idx += incr;
+	}
+      /* NOTREACHED */
+    }
+  else
+    {
+      /* Try the default method:  binary search in the sorted array of
+	 messages.  */
+      size_t top, bottom;
+
+      bottom = 0;
+      top = domain->nstrings;
+      while (bottom < top)
+	{
+	  int cmp_val;
+
+	  act = (bottom + top) / 2;
+	  cmp_val = strcmp (msgid, (domain->data
+				    + W (domain->must_swap,
+					 domain->orig_tab[act].offset)));
+	  if (cmp_val < 0)
+	    top = act;
+	  else if (cmp_val > 0)
+	    bottom = act + 1;
+	  else
+	    goto found;
+	}
+      /* No translation was found.  */
+      return NULL;
+    }
+
+ found:
+  /* The translation was found at index ACT.  If we have to convert the
+     string to use a different character set, this is the time.  */
+  result = ((char *) domain->data
+	    + W (domain->must_swap, domain->trans_tab[act].offset));
+  resultlen = W (domain->must_swap, domain->trans_tab[act].length) + 1;
+
+#if defined _LIBC || HAVE_ICONV
+  if (domain->codeset_cntr
+      != (domainbinding != NULL ? domainbinding->codeset_cntr : 0))
+    {
+      /* The domain's codeset has changed through bind_textdomain_codeset()
+	 since the message catalog was initialized or last accessed.  We
+	 have to reinitialize the converter.  */
+      _nl_free_domain_conv (domain);
+      _nl_init_domain_conv (domain_file, domain, domainbinding);
+    }
+
+  if (
+# ifdef _LIBC
+      domain->conv != (__gconv_t) -1
+# else
+#  if HAVE_ICONV
+      domain->conv != (iconv_t) -1
+#  endif
+# endif
+      )
+    {
+      /* We are supposed to do a conversion.  First allocate an
+	 appropriate table with the same structure as the table
+	 of translations in the file, where we can put the pointers
+	 to the converted strings in.
+	 There is a slight complication with plural entries.  They
+	 are represented by consecutive NUL terminated strings.  We
+	 handle this case by converting RESULTLEN bytes, including
+	 NULs.  */
+
+      if (domain->conv_tab == NULL
+	  && ((domain->conv_tab = (char **) calloc (domain->nstrings,
+						    sizeof (char *)))
+	      == NULL))
+	/* Mark that we didn't succeed allocating a table.  */
+	domain->conv_tab = (char **) -1;
+
+      if (__builtin_expect (domain->conv_tab == (char **) -1, 0))
+	/* Nothing we can do, no more memory.  */
+	goto converted;
+
+      if (domain->conv_tab[act] == NULL)
+	{
+	  /* We haven't used this string so far, so it is not
+	     translated yet.  Do this now.  */
+	  /* We use a bit more efficient memory handling.
+	     We allocate always larger blocks which get used over
+	     time.  This is faster than many small allocations.   */
+	  __libc_lock_define_initialized (static, lock)
+# define INITIAL_BLOCK_SIZE	4080
+	  static unsigned char *freemem;
+	  static size_t freemem_size;
+
+	  const unsigned char *inbuf;
+	  unsigned char *outbuf;
+	  int malloc_count;
+# ifndef _LIBC
+	  transmem_block_t *transmem_list = NULL;
+# endif
+
+	  __libc_lock_lock (lock);
+
+	  inbuf = (const unsigned char *) result;
+	  outbuf = freemem + sizeof (size_t);
+
+	  malloc_count = 0;
+	  while (1)
+	    {
+	      transmem_block_t *newmem;
+# ifdef _LIBC
+	      size_t non_reversible;
+	      int res;
+
+	      if (freemem_size < sizeof (size_t))
+		goto resize_freemem;
+
+	      res = __gconv (domain->conv,
+			     &inbuf, inbuf + resultlen,
+			     &outbuf,
+			     outbuf + freemem_size - sizeof (size_t),
+			     &non_reversible);
+
+	      if (res == __GCONV_OK || res == __GCONV_EMPTY_INPUT)
+		break;
+
+	      if (res != __GCONV_FULL_OUTPUT)
+		{
+		  __libc_lock_unlock (lock);
+		  goto converted;
+		}
+
+	      inbuf = result;
+# else
+#  if HAVE_ICONV
+	      const char *inptr = (const char *) inbuf;
+	      size_t inleft = resultlen;
+	      char *outptr = (char *) outbuf;
+	      size_t outleft;
+
+	      if (freemem_size < sizeof (size_t))
+		goto resize_freemem;
+
+	      outleft = freemem_size - sizeof (size_t);
+	      if (iconv (domain->conv,
+			 (ICONV_CONST char **) &inptr, &inleft,
+			 &outptr, &outleft)
+		  != (size_t) (-1))
+		{
+		  outbuf = (unsigned char *) outptr;
+		  break;
+		}
+	      if (errno != E2BIG)
+		{
+		  __libc_lock_unlock (lock);
+		  goto converted;
+		}
+#  endif
+# endif
+
+	    resize_freemem:
+	      /* We must allocate a new buffer or resize the old one.  */
+	      if (malloc_count > 0)
+		{
+		  ++malloc_count;
+		  freemem_size = malloc_count * INITIAL_BLOCK_SIZE;
+		  newmem = (transmem_block_t *) realloc (transmem_list,
+							 freemem_size);
+# ifdef _LIBC
+		  if (newmem != NULL)
+		    transmem_list = transmem_list->next;
+		  else
+		    {
+		      struct transmem_list *old = transmem_list;
+
+		      transmem_list = transmem_list->next;
+		      free (old);
+		    }
+# endif
+		}
+	      else
+		{
+		  malloc_count = 1;
+		  freemem_size = INITIAL_BLOCK_SIZE;
+		  newmem = (transmem_block_t *) malloc (freemem_size);
+		}
+	      if (__builtin_expect (newmem == NULL, 0))
+		{
+		  freemem = NULL;
+		  freemem_size = 0;
+		  __libc_lock_unlock (lock);
+		  goto converted;
+		}
+
+# ifdef _LIBC
+	      /* Add the block to the list of blocks we have to free
+                 at some point.  */
+	      newmem->next = transmem_list;
+	      transmem_list = newmem;
+
+	      freemem = newmem->data;
+	      freemem_size -= offsetof (struct transmem_list, data);
+# else
+	      transmem_list = newmem;
+	      freemem = newmem;
+# endif
+
+	      outbuf = freemem + sizeof (size_t);
+	    }
+
+	  /* We have now in our buffer a converted string.  Put this
+	     into the table of conversions.  */
+	  *(size_t *) freemem = outbuf - freemem - sizeof (size_t);
+	  domain->conv_tab[act] = (char *) freemem;
+	  /* Shrink freemem, but keep it aligned.  */
+	  freemem_size -= outbuf - freemem;
+	  freemem = outbuf;
+	  freemem += freemem_size & (alignof (size_t) - 1);
+	  freemem_size = freemem_size & ~ (alignof (size_t) - 1);
+
+	  __libc_lock_unlock (lock);
+	}
+
+      /* Now domain->conv_tab[act] contains the translation of all
+	 the plural variants.  */
+      result = domain->conv_tab[act] + sizeof (size_t);
+      resultlen = *(size_t *) domain->conv_tab[act];
+    }
+
+ converted:
+  /* The result string is converted.  */
+
+#endif /* _LIBC || HAVE_ICONV */
+
+  *lengthp = resultlen;
+  return result;
+}
+
+
+/* Look up a plural variant.  */
+static char *
+internal_function
+plural_lookup (domain, n, translation, translation_len)
+     struct loaded_l10nfile *domain;
+     unsigned long int n;
+     const char *translation;
+     size_t translation_len;
+{
+  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;
+  unsigned long int index;
+  const char *p;
+
+  index = plural_eval (domaindata->plural, n);
+  if (index >= domaindata->nplurals)
+    /* This should never happen.  It means the plural expression and the
+       given maximum value do not match.  */
+    index = 0;
+
+  /* Skip INDEX strings at TRANSLATION.  */
+  p = translation;
+  while (index-- > 0)
+    {
+#ifdef _LIBC
+      p = __rawmemchr (p, '\0');
+#else
+      p = strchr (p, '\0');
+#endif
+      /* And skip over the NUL byte.  */
+      p++;
+
+      if (p >= translation + translation_len)
+	/* This should never happen.  It means the plural expression
+	   evaluated to a value larger than the number of variants
+	   available for MSGID1.  */
+	return (char *) translation;
+    }
+  return (char *) p;
+}
+
+
+/* Function to evaluate the plural expression and return an index value.  */
+static unsigned long int
+internal_function
+plural_eval (pexp, n)
+     struct expression *pexp;
+     unsigned long int n;
+{
+  switch (pexp->nargs)
+    {
+    case 0:
+      switch (pexp->operation)
+	{
+	case var:
+	  return n;
+	case num:
+	  return pexp->val.num;
+	default:
+	  break;
+	}
+      /* NOTREACHED */
+      break;
+    case 1:
+      {
+	/* pexp->operation must be lnot.  */
+	unsigned long int arg = plural_eval (pexp->val.args[0], n);
+	return ! arg;
+      }
+    case 2:
+      {
+	unsigned long int leftarg = plural_eval (pexp->val.args[0], n);
+	if (pexp->operation == lor)
+	  return leftarg || plural_eval (pexp->val.args[1], n);
+	else if (pexp->operation == land)
+	  return leftarg && plural_eval (pexp->val.args[1], n);
+	else
+	  {
+	    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);
+
+	    switch (pexp->operation)
+	      {
+	      case mult:
+		return leftarg * rightarg;
+	      case divide:
+		return leftarg / rightarg;
+	      case module:
+		return leftarg % rightarg;
+	      case plus:
+		return leftarg + rightarg;
+	      case minus:
+		return leftarg - rightarg;
+	      case less_than:
+		return leftarg < rightarg;
+	      case greater_than:
+		return leftarg > rightarg;
+	      case less_or_equal:
+		return leftarg <= rightarg;
+	      case greater_or_equal:
+		return leftarg >= rightarg;
+	      case equal:
+		return leftarg == rightarg;
+	      case not_equal:
+		return leftarg != rightarg;
+	      default:
+		break;
+	      }
+	  }
+	/* NOTREACHED */
+	break;
+      }
+    case 3:
+      {
+	/* pexp->operation must be qmop.  */
+	unsigned long int boolarg = plural_eval (pexp->val.args[0], n);
+	return plural_eval (pexp->val.args[boolarg ? 1 : 2], n);
+      }
+    }
+  /* NOTREACHED */
+  return 0;
+}
+
+
+/* Return string representation of locale CATEGORY.  */
+static const char *
+internal_function
+category_to_name (category)
+     int category;
+{
+  const char *retval;
+
+  switch (category)
+  {
+#ifdef LC_COLLATE
+  case LC_COLLATE:
+    retval = "LC_COLLATE";
+    break;
+#endif
+#ifdef LC_CTYPE
+  case LC_CTYPE:
+    retval = "LC_CTYPE";
+    break;
+#endif
+#ifdef LC_MONETARY
+  case LC_MONETARY:
+    retval = "LC_MONETARY";
+    break;
+#endif
+#ifdef LC_NUMERIC
+  case LC_NUMERIC:
+    retval = "LC_NUMERIC";
+    break;
+#endif
+#ifdef LC_TIME
+  case LC_TIME:
+    retval = "LC_TIME";
+    break;
+#endif
+#ifdef LC_MESSAGES
+  case LC_MESSAGES:
+    retval = "LC_MESSAGES";
+    break;
+#endif
+#ifdef LC_RESPONSE
+  case LC_RESPONSE:
+    retval = "LC_RESPONSE";
+    break;
+#endif
+#ifdef LC_ALL
+  case LC_ALL:
+    /* This might not make sense but is perhaps better than any other
+       value.  */
+    retval = "LC_ALL";
+    break;
+#endif
+  default:
+    /* If you have a better idea for a default value let me know.  */
+    retval = "LC_XXX";
+  }
+
+  return retval;
+}
+
+/* Guess value of current locale from value of the environment variables.  */
+static const char *
+internal_function
+guess_category_value (category, categoryname)
+     int category;
+     const char *categoryname;
+{
+  const char *language;
+  const char *retval;
+
+  /* The highest priority value is the `LANGUAGE' environment
+     variable.  But we don't use the value if the currently selected
+     locale is the C locale.  This is a GNU extension.  */
+  language = getenv ("LANGUAGE");
+  if (language != NULL && language[0] == '\0')
+    language = NULL;
+
+  /* We have to proceed with the POSIX methods of looking to `LC_ALL',
+     `LC_xxx', and `LANG'.  On some systems this can be done by the
+     `setlocale' function itself.  */
+#if defined _LIBC || (defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL)
+  retval = setlocale (category, NULL);
+#else
+  /* Setting of LC_ALL overwrites all other.  */
+  retval = getenv ("LC_ALL");
+  if (retval == NULL || retval[0] == '\0')
+    {
+      /* Next comes the name of the desired category.  */
+      retval = getenv (categoryname);
+      if (retval == NULL || retval[0] == '\0')
+	{
+	  /* Last possibility is the LANG environment variable.  */
+	  retval = getenv ("LANG");
+	  if (retval == NULL || retval[0] == '\0')
+	    /* We use C as the default domain.  POSIX says this is
+	       implementation defined.  */
+	    return "C";
+	}
+    }
+#endif
+
+  return language != NULL && strcmp (retval, "C") != 0 ? language : retval;
+}
+
+/* @@ begin of epilog @@ */
+
+/* We don't want libintl.a to depend on any other library.  So we
+   avoid the non-standard function stpcpy.  In GNU C Library this
+   function is available, though.  Also allow the symbol HAVE_STPCPY
+   to be defined.  */
+#if !_LIBC && !HAVE_STPCPY
+static char *
+stpcpy (dest, src)
+     char *dest;
+     const char *src;
+{
+  while ((*dest++ = *src++) != '\0')
+    /* Do nothing. */ ;
+  return dest - 1;
+}
+#endif
+
+#if !_LIBC && !HAVE_MEMPCPY
+static void *
+mempcpy (dest, src, n)
+     void *dest;
+     const void *src;
+     size_t n;
+{
+  return (void *) ((char *) memcpy (dest, src, n) + n);
+}
+#endif
+
+
+#ifdef _LIBC
+/* If we want to free all resources we have to do some work at
+   program's end.  */
+static void __attribute__ ((unused))
+free_mem (void)
+{
+  void *old;
+
+  while (_nl_domain_bindings != NULL)
+    {
+      struct binding *oldp = _nl_domain_bindings;
+      _nl_domain_bindings = _nl_domain_bindings->next;
+      if (oldp->dirname != _nl_default_dirname)
+	/* Yes, this is a pointer comparison.  */
+	free (oldp->dirname);
+      free (oldp->codeset);
+      free (oldp);
+    }
+
+  if (_nl_current_default_domain != _nl_default_default_domain)
+    /* Yes, again a pointer comparison.  */
+    free ((char *) _nl_current_default_domain);
+
+  /* Remove the search tree with the known translations.  */
+  __tdestroy (root, free);
+  root = NULL;
+
+  while (transmem_list != NULL)
+    {
+      old = transmem_list;
+      transmem_list = transmem_list->next;
+      free (old);
+    }
+}
+
+text_set_element (__libc_subfreeres, free_mem);
+#endif
diff -Naur orig/intl/dcngettext.c patched/intl/dcngettext.c
--- orig/intl/dcngettext.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/dcngettext.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,59 @@
+/* Implementation of the dcngettext(3) function.
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DCNGETTEXT __dcngettext
+# define DCIGETTEXT __dcigettext
+#else
+# define DCNGETTEXT dcngettext__
+# define DCIGETTEXT dcigettext__
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+char *
+DCNGETTEXT (domainname, msgid1, msgid2, n, category)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+     int category;
+{
+  return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__dcngettext, dcngettext);
+#endif
diff -Naur orig/intl/dgettext.c patched/intl/dgettext.c
--- orig/intl/dgettext.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/dgettext.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,58 @@
+/* Implementation of the dgettext(3) function.
+   Copyright (C) 1995-1997, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <locale.h>
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DGETTEXT __dgettext
+# define DCGETTEXT __dcgettext
+#else
+# define DGETTEXT dgettext__
+# define DCGETTEXT dcgettext__
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog of the current
+   LC_MESSAGES locale.  */
+char *
+DGETTEXT (domainname, msgid)
+     const char *domainname;
+     const char *msgid;
+{
+  return DCGETTEXT (domainname, msgid, LC_MESSAGES);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__dgettext, dgettext);
+#endif
diff -Naur orig/intl/dngettext.c patched/intl/dngettext.c
--- orig/intl/dngettext.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/dngettext.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,60 @@
+/* Implementation of the dngettext(3) function.
+   Copyright (C) 1995-1997, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <locale.h>
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DNGETTEXT __dngettext
+# define DCNGETTEXT __dcngettext
+#else
+# define DNGETTEXT dngettext__
+# define DCNGETTEXT dcngettext__
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog of the current
+   LC_MESSAGES locale and skip message according to the plural form.  */
+char *
+DNGETTEXT (domainname, msgid1, msgid2, n)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+{
+  return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__dngettext, dngettext);
+#endif
diff -Naur orig/intl/explodename.c patched/intl/explodename.c
--- orig/intl/explodename.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/explodename.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,191 @@
+/* Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+
+#include "loadinfo.h"
+
+/* On some strange systems still no definition of NULL is found.  Sigh!  */
+#ifndef NULL
+# if defined __STDC__ && __STDC__
+#  define NULL ((void *) 0)
+# else
+#  define NULL 0
+# endif
+#endif
+
+/* @@ end of prolog @@ */
+
+char *
+_nl_find_language (name)
+     const char *name;
+{
+  while (name[0] != '\0' && name[0] != '_' && name[0] != '@'
+	 && name[0] != '+' && name[0] != ',')
+    ++name;
+
+  return (char *) name;
+}
+
+
+int
+_nl_explode_name (name, language, modifier, territory, codeset,
+		  normalized_codeset, special, sponsor, revision)
+     char *name;
+     const char **language;
+     const char **modifier;
+     const char **territory;
+     const char **codeset;
+     const char **normalized_codeset;
+     const char **special;
+     const char **sponsor;
+     const char **revision;
+{
+  enum { undecided, xpg, cen } syntax;
+  char *cp;
+  int mask;
+
+  *modifier = NULL;
+  *territory = NULL;
+  *codeset = NULL;
+  *normalized_codeset = NULL;
+  *special = NULL;
+  *sponsor = NULL;
+  *revision = NULL;
+
+  /* Now we determine the single parts of the locale name.  First
+     look for the language.  Termination symbols are `_' and `@' if
+     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
+  mask = 0;
+  syntax = undecided;
+  *language = cp = name;
+  cp = _nl_find_language (*language);
+
+  if (*language == cp)
+    /* This does not make sense: language has to be specified.  Use
+       this entry as it is without exploding.  Perhaps it is an alias.  */
+    cp = strchr (*language, '\0');
+  else if (cp[0] == '_')
+    {
+      /* Next is the territory.  */
+      cp[0] = '\0';
+      *territory = ++cp;
+
+      while (cp[0] != '\0' && cp[0] != '.' && cp[0] != '@'
+	     && cp[0] != '+' && cp[0] != ',' && cp[0] != '_')
+	++cp;
+
+      mask |= TERRITORY;
+
+      if (cp[0] == '.')
+	{
+	  /* Next is the codeset.  */
+	  syntax = xpg;
+	  cp[0] = '\0';
+	  *codeset = ++cp;
+
+	  while (cp[0] != '\0' && cp[0] != '@')
+	    ++cp;
+
+	  mask |= XPG_CODESET;
+
+	  if (*codeset != cp && (*codeset)[0] != '\0')
+	    {
+	      *normalized_codeset = _nl_normalize_codeset (*codeset,
+							   cp - *codeset);
+	      if (strcmp (*codeset, *normalized_codeset) == 0)
+		free ((char *) *normalized_codeset);
+	      else
+		mask |= XPG_NORM_CODESET;
+	    }
+	}
+    }
+
+  if (cp[0] == '@' || (syntax != xpg && cp[0] == '+'))
+    {
+      /* Next is the modifier.  */
+      syntax = cp[0] == '@' ? xpg : cen;
+      cp[0] = '\0';
+      *modifier = ++cp;
+
+      while (syntax == cen && cp[0] != '\0' && cp[0] != '+'
+	     && cp[0] != ',' && cp[0] != '_')
+	++cp;
+
+      mask |= XPG_MODIFIER | CEN_AUDIENCE;
+    }
+
+  if (syntax != xpg && (cp[0] == '+' || cp[0] == ',' || cp[0] == '_'))
+    {
+      syntax = cen;
+
+      if (cp[0] == '+')
+	{
+ 	  /* Next is special application (CEN syntax).  */
+	  cp[0] = '\0';
+	  *special = ++cp;
+
+	  while (cp[0] != '\0' && cp[0] != ',' && cp[0] != '_')
+	    ++cp;
+
+	  mask |= CEN_SPECIAL;
+	}
+
+      if (cp[0] == ',')
+	{
+ 	  /* Next is sponsor (CEN syntax).  */
+	  cp[0] = '\0';
+	  *sponsor = ++cp;
+
+	  while (cp[0] != '\0' && cp[0] != '_')
+	    ++cp;
+
+	  mask |= CEN_SPONSOR;
+	}
+
+      if (cp[0] == '_')
+	{
+ 	  /* Next is revision (CEN syntax).  */
+	  cp[0] = '\0';
+	  *revision = ++cp;
+
+	  mask |= CEN_REVISION;
+	}
+    }
+
+  /* For CEN syntax values it might be important to have the
+     separator character in the file name, not for XPG syntax.  */
+  if (syntax == xpg)
+    {
+      if (*territory != NULL && (*territory)[0] == '\0')
+	mask &= ~TERRITORY;
+
+      if (*codeset != NULL && (*codeset)[0] == '\0')
+	mask &= ~XPG_CODESET;
+
+      if (*modifier != NULL && (*modifier)[0] == '\0')
+	mask &= ~XPG_MODIFIER;
+    }
+
+  return mask;
+}
diff -Naur orig/intl/finddomain.c patched/intl/finddomain.c
--- orig/intl/finddomain.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/finddomain.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,197 @@
+/* Handle list of needed message catalogs
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@gnu.org>, 1995.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if defined HAVE_UNISTD_H || defined _LIBC
+# include <unistd.h>
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+/* List of already loaded domains.  */
+static struct loaded_l10nfile *_nl_loaded_domains;
+
+
+/* Return a data structure describing the message catalog described by
+   the DOMAINNAME and CATEGORY parameters with respect to the currently
+   established bindings.  */
+struct loaded_l10nfile *
+internal_function
+_nl_find_domain (dirname, locale, domainname, domainbinding)
+     const char *dirname;
+     char *locale;
+     const char *domainname;
+     struct binding *domainbinding;
+{
+  struct loaded_l10nfile *retval;
+  const char *language;
+  const char *modifier;
+  const char *territory;
+  const char *codeset;
+  const char *normalized_codeset;
+  const char *special;
+  const char *sponsor;
+  const char *revision;
+  const char *alias_value;
+  int mask;
+
+  /* LOCALE can consist of up to four recognized parts for the XPG syntax:
+
+		language[_territory[.codeset]][@modifier]
+
+     and six parts for the CEN syntax:
+
+	language[_territory][+audience][+special][,[sponsor][_revision]]
+
+     Beside the first part all of them are allowed to be missing.  If
+     the full specified locale is not found, the less specific one are
+     looked for.  The various parts will be stripped off according to
+     the following order:
+		(1) revision
+		(2) sponsor
+		(3) special
+		(4) codeset
+		(5) normalized codeset
+		(6) territory
+		(7) audience/modifier
+   */
+
+  /* If we have already tested for this locale entry there has to
+     be one data set in the list of loaded domains.  */
+  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
+			       strlen (dirname) + 1, 0, locale, NULL, NULL,
+			       NULL, NULL, NULL, NULL, NULL, domainname, 0);
+  if (retval != NULL)
+    {
+      /* We know something about this locale.  */
+      int cnt;
+
+      if (retval->decided == 0)
+	_nl_load_domain (retval, domainbinding);
+
+      if (retval->data != NULL)
+	return retval;
+
+      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
+	{
+	  if (retval->successor[cnt]->decided == 0)
+	    _nl_load_domain (retval->successor[cnt], domainbinding);
+
+	  if (retval->successor[cnt]->data != NULL)
+	    break;
+	}
+      return cnt >= 0 ? retval : NULL;
+      /* NOTREACHED */
+    }
+
+  /* See whether the locale value is an alias.  If yes its value
+     *overwrites* the alias name.  No test for the original value is
+     done.  */
+  alias_value = _nl_expand_alias (locale);
+  if (alias_value != NULL)
+    {
+#if defined _LIBC || defined HAVE_STRDUP
+      locale = strdup (alias_value);
+      if (locale == NULL)
+	return NULL;
+#else
+      size_t len = strlen (alias_value) + 1;
+      locale = (char *) malloc (len);
+      if (locale == NULL)
+	return NULL;
+
+      memcpy (locale, alias_value, len);
+#endif
+    }
+
+  /* Now we determine the single parts of the locale name.  First
+     look for the language.  Termination symbols are `_' and `@' if
+     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
+  mask = _nl_explode_name (locale, &language, &modifier, &territory,
+			   &codeset, &normalized_codeset, &special,
+			   &sponsor, &revision);
+
+  /* Create all possible locale entries which might be interested in
+     generalization.  */
+  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
+			       strlen (dirname) + 1, mask, language, territory,
+			       codeset, normalized_codeset, modifier, special,
+			       sponsor, revision, domainname, 1);
+  if (retval == NULL)
+    /* This means we are out of core.  */
+    return NULL;
+
+  if (retval->decided == 0)
+    _nl_load_domain (retval, domainbinding);
+  if (retval->data == NULL)
+    {
+      int cnt;
+      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
+	{
+	  if (retval->successor[cnt]->decided == 0)
+	    _nl_load_domain (retval->successor[cnt], domainbinding);
+	  if (retval->successor[cnt]->data != NULL)
+	    break;
+	}
+    }
+
+  /* The room for an alias was dynamically allocated.  Free it now.  */
+  if (alias_value != NULL)
+    free (locale);
+
+  /* The space for normalized_codeset is dynamically allocated.  Free it.  */
+  if (mask & XPG_NORM_CODESET)
+    free ((void *) normalized_codeset);
+
+  return retval;
+}
+
+
+#ifdef _LIBC
+static void __attribute__ ((unused))
+free_mem (void)
+{
+  struct loaded_l10nfile *runp = _nl_loaded_domains;
+
+  while (runp != NULL)
+    {
+      struct loaded_l10nfile *here = runp;
+      if (runp->data != NULL)
+	_nl_unload_domain ((struct loaded_domain *) runp->data);
+      runp = runp->next;
+      free ((char *) here->filename);
+      free (here);
+    }
+}
+
+text_set_element (__libc_subfreeres, free_mem);
+#endif
diff -Naur orig/intl/gettext.c patched/intl/gettext.c
--- orig/intl/gettext.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/gettext.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,63 @@
+/* Implementation of gettext(3) function.
+   Copyright (C) 1995, 1997, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef _LIBC
+# define __need_NULL
+# include <stddef.h>
+#else
+# include <stdlib.h>		/* Just for NULL.  */
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define GETTEXT __gettext
+# define DCGETTEXT __dcgettext
+#else
+# define GETTEXT gettext__
+# define DCGETTEXT dcgettext__
+#endif
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+char *
+GETTEXT (msgid)
+     const char *msgid;
+{
+  return DCGETTEXT (NULL, msgid, LC_MESSAGES);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__gettext, gettext);
+#endif
diff -Naur orig/intl/gettext.h patched/intl/gettext.h
--- orig/intl/gettext.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/gettext.h	2002-05-30 12:52:15.000000000 +0200
@@ -0,0 +1,101 @@
+/* Description of GNU message catalog format: general file layout.
+   Copyright (C) 1995, 1997, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _GETTEXT_H
+#define _GETTEXT_H 1
+
+#if HAVE_LIMITS_H || _LIBC
+# include <limits.h>
+#endif
+
+/* @@ end of prolog @@ */
+
+/* The magic number of the GNU message catalog format.  */
+#define _MAGIC 0x950412de
+#define _MAGIC_SWAPPED 0xde120495
+
+/* Revision number of the currently used .mo (binary) file format.  */
+#define MO_REVISION_NUMBER 0
+
+/* The following contortions are an attempt to use the C preprocessor
+   to determine an unsigned integral type that is 32 bits wide.  An
+   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but
+   as of version autoconf-2.13, the AC_CHECK_SIZEOF macro doesn't work
+   when cross-compiling.  */
+
+#if __STDC__
+# define UINT_MAX_32_BITS 4294967295U
+#else
+# define UINT_MAX_32_BITS 0xFFFFFFFF
+#endif
+
+/* If UINT_MAX isn't defined, assume it's a 32-bit type.
+   This should be valid for all systems GNU cares about because
+   that doesn't include 16-bit systems, and only modern systems
+   (that certainly have <limits.h>) have 64+-bit integral types.  */
+
+#ifndef UINT_MAX
+# define UINT_MAX UINT_MAX_32_BITS
+#endif
+
+#if UINT_MAX == UINT_MAX_32_BITS
+typedef unsigned nls_uint32;
+#else
+# if USHRT_MAX == UINT_MAX_32_BITS
+typedef unsigned short nls_uint32;
+# else
+#  if ULONG_MAX == UINT_MAX_32_BITS
+typedef unsigned long nls_uint32;
+#  else
+  /* The following line is intended to throw an error.  Using #error is
+     not portable enough.  */
+  "Cannot determine unsigned 32-bit data type."
+#  endif
+# endif
+#endif
+
+
+/* Header for binary .mo file format.  */
+struct mo_file_header
+{
+  /* The magic number.  */
+  nls_uint32 magic;
+  /* The revision number of the file format.  */
+  nls_uint32 revision;
+  /* The number of strings pairs.  */
+  nls_uint32 nstrings;
+  /* Offset of table with start offsets of original strings.  */
+  nls_uint32 orig_tab_offset;
+  /* Offset of table with start offsets of translation strings.  */
+  nls_uint32 trans_tab_offset;
+  /* Size of hashing table.  */
+  nls_uint32 hash_tab_size;
+  /* Offset of first hashing entry.  */
+  nls_uint32 hash_tab_offset;
+};
+
+struct string_desc
+{
+  /* Length of addressed string.  */
+  nls_uint32 length;
+  /* Offset of string in file.  */
+  nls_uint32 offset;
+};
+
+/* @@ begin of epilog @@ */
+
+#endif	/* gettext.h  */
diff -Naur orig/intl/gettextP.h patched/intl/gettextP.h
--- orig/intl/gettextP.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/gettextP.h	2002-05-30 12:52:11.000000000 +0200
@@ -0,0 +1,251 @@
+/* Header describing internals of libintl library.
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 1995.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _GETTEXTP_H
+#define _GETTEXTP_H
+
+#include <stddef.h>		/* Get size_t.  */
+
+#ifdef _LIBC
+# include "../iconv/gconv_int.h"
+#else
+# if HAVE_ICONV
+#  include <iconv.h>
+# endif
+#endif
+
+#include "loadinfo.h"
+
+#include "gettext.h"		/* Get nls_uint32.  */
+
+/* @@ end of prolog @@ */
+
+#ifndef PARAMS
+# if __STDC__
+#  define PARAMS(args) args
+# else
+#  define PARAMS(args) ()
+# endif
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+/* Tell the compiler when a conditional or integer expression is
+   almost always true or almost always false.  */
+#ifndef HAVE_BUILTIN_EXPECT
+# define __builtin_expect(expr, val) (expr)
+#endif
+
+#ifndef W
+# define W(flag, data) ((flag) ? SWAP (data) : (data))
+#endif
+
+
+#ifdef _LIBC
+# include <byteswap.h>
+# define SWAP(i) bswap_32 (i)
+#else
+static inline nls_uint32
+SWAP (i)
+     nls_uint32 i;
+{
+  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
+}
+#endif
+
+
+/* This is the representation of the expressions to determine the
+   plural form.  */
+struct expression
+{
+  int nargs;			/* Number of arguments.  */
+  enum operator
+  {
+    /* Without arguments:  */
+    var,			/* The variable "n".  */
+    num,			/* Decimal number.  */
+    /* Unary operators:  */
+    lnot,			/* Logical NOT.  */
+    /* Binary operators:  */
+    mult,			/* Multiplication.  */
+    divide,			/* Division.  */
+    module,			/* Module operation.  */
+    plus,			/* Addition.  */
+    minus,			/* Subtraction.  */
+    less_than,			/* Comparison.  */
+    greater_than,		/* Comparison.  */
+    less_or_equal,		/* Comparison.  */
+    greater_or_equal,		/* Comparison.  */
+    equal,			/* Comparision for equality.  */
+    not_equal,			/* Comparision for inequality.  */
+    land,			/* Logical AND.  */
+    lor,			/* Logical OR.  */
+    /* Ternary operators:  */
+    qmop			/* Question mark operator.  */
+  } operation;
+  union
+  {
+    unsigned long int num;	/* Number value for `num'.  */
+    struct expression *args[3];	/* Up to three arguments.  */
+  } val;
+};
+
+/* This is the data structure to pass information to the parser and get
+   the result in a thread-safe way.  */
+struct parse_args
+{
+  const char *cp;
+  struct expression *res;
+};
+
+
+/* The representation of an opened message catalog.  */
+struct loaded_domain
+{
+  const char *data;
+  int use_mmap;
+  size_t mmap_size;
+  int must_swap;
+  nls_uint32 nstrings;
+  struct string_desc *orig_tab;
+  struct string_desc *trans_tab;
+  nls_uint32 hash_size;
+  nls_uint32 *hash_tab;
+  int codeset_cntr;
+#ifdef _LIBC
+  __gconv_t conv;
+#else
+# if HAVE_ICONV
+  iconv_t conv;
+# endif
+#endif
+  char **conv_tab;
+
+  struct expression *plural;
+  unsigned long int nplurals;
+};
+
+/* We want to allocate a string at the end of the struct.  But ISO C
+   doesn't allow zero sized arrays.  */
+#ifdef __GNUC__
+# define ZERO 0
+#else
+# define ZERO 1
+#endif
+
+/* A set of settings bound to a message domain.  Used to store settings
+   from bindtextdomain() and bind_textdomain_codeset().  */
+struct binding
+{
+  struct binding *next;
+  char *dirname;
+  int codeset_cntr;	/* Incremented each time codeset changes.  */
+  char *codeset;
+  char domainname[ZERO];
+};
+
+/* A counter which is incremented each time some previous translations
+   become invalid.
+   This variable is part of the external ABI of the GNU libintl.  */
+extern int _nl_msg_cat_cntr;
+
+struct loaded_l10nfile *_nl_find_domain PARAMS ((const char *__dirname,
+						 char *__locale,
+						 const char *__domainname,
+					      struct binding *__domainbinding))
+     internal_function;
+void _nl_load_domain PARAMS ((struct loaded_l10nfile *__domain,
+			      struct binding *__domainbinding))
+     internal_function;
+void _nl_unload_domain PARAMS ((struct loaded_domain *__domain))
+     internal_function;
+const char *_nl_init_domain_conv PARAMS ((struct loaded_l10nfile *__domain_file,
+					  struct loaded_domain *__domain,
+					  struct binding *__domainbinding))
+     internal_function;
+void _nl_free_domain_conv PARAMS ((struct loaded_domain *__domain))
+     internal_function;
+
+char *_nl_find_msg PARAMS ((struct loaded_l10nfile *domain_file,
+			    struct binding *domainbinding,
+			    const char *msgid, size_t *lengthp))
+     internal_function;
+
+#ifdef _LIBC
+extern char *__gettext PARAMS ((const char *__msgid));
+extern char *__dgettext PARAMS ((const char *__domainname,
+				 const char *__msgid));
+extern char *__dcgettext PARAMS ((const char *__domainname,
+				  const char *__msgid, int __category));
+extern char *__ngettext PARAMS ((const char *__msgid1, const char *__msgid2,
+				 unsigned long int __n));
+extern char *__dngettext PARAMS ((const char *__domainname,
+				  const char *__msgid1, const char *__msgid2,
+				  unsigned long int n));
+extern char *__dcngettext PARAMS ((const char *__domainname,
+				   const char *__msgid1, const char *__msgid2,
+				   unsigned long int __n, int __category));
+extern char *__dcigettext PARAMS ((const char *__domainname,
+				   const char *__msgid1, const char *__msgid2,
+				   int __plural, unsigned long int __n,
+				   int __category));
+extern char *__textdomain PARAMS ((const char *__domainname));
+extern char *__bindtextdomain PARAMS ((const char *__domainname,
+				       const char *__dirname));
+extern char *__bind_textdomain_codeset PARAMS ((const char *__domainname,
+						const char *__codeset));
+#else
+extern char *gettext__ PARAMS ((const char *__msgid));
+extern char *dgettext__ PARAMS ((const char *__domainname,
+				 const char *__msgid));
+extern char *dcgettext__ PARAMS ((const char *__domainname,
+				  const char *__msgid, int __category));
+extern char *ngettext__ PARAMS ((const char *__msgid1, const char *__msgid2,
+				 unsigned long int __n));
+extern char *dngettext__ PARAMS ((const char *__domainname,
+				  const char *__msgid1, const char *__msgid2,
+				  unsigned long int __n));
+extern char *dcngettext__ PARAMS ((const char *__domainname,
+				   const char *__msgid1, const char *__msgid2,
+				   unsigned long int __n, int __category));
+extern char *dcigettext__ PARAMS ((const char *__domainname,
+				   const char *__msgid1, const char *__msgid2,
+				   int __plural, unsigned long int __n,
+				   int __category));
+extern char *textdomain__ PARAMS ((const char *__domainname));
+extern char *bindtextdomain__ PARAMS ((const char *__domainname,
+				       const char *__dirname));
+extern char *bind_textdomain_codeset__ PARAMS ((const char *__domainname,
+						const char *__codeset));
+#endif
+
+#ifdef _LIBC
+extern void __gettext_free_exp PARAMS ((struct expression *exp))
+     internal_function;
+extern int __gettextparse PARAMS ((void *arg));
+#else
+extern void gettext_free_exp__ PARAMS ((struct expression *exp))
+     internal_function;
+extern int gettextparse__ PARAMS ((void *arg));
+#endif
+
+/* @@ begin of epilog @@ */
+
+#endif /* gettextP.h  */
diff -Naur orig/intl/hash-string.h patched/intl/hash-string.h
--- orig/intl/hash-string.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/hash-string.h	2002-05-30 12:52:18.000000000 +0200
@@ -0,0 +1,58 @@
+/* Description of GNU message catalog format: string hashing function.
+   Copyright (C) 1995, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* @@ end of prolog @@ */
+
+#ifndef PARAMS
+# if __STDC__
+#  define PARAMS(Args) Args
+# else
+#  define PARAMS(Args) ()
+# endif
+#endif
+
+/* We assume to have `unsigned long int' value with at least 32 bits.  */
+#define HASHWORDBITS 32
+
+
+/* Defines the so called `hashpjw' function by P.J. Weinberger
+   [see Aho/Sethi/Ullman, COMPILERS: Principles, Techniques and Tools,
+   1986, 1987 Bell Telephone Laboratories, Inc.]  */
+static unsigned long int hash_string PARAMS ((const char *__str_param));
+
+static inline unsigned long int
+hash_string (str_param)
+     const char *str_param;
+{
+  unsigned long int hval, g;
+  const char *str = str_param;
+
+  /* Compute the hash value for the given string.  */
+  hval = 0;
+  while (*str != '\0')
+    {
+      hval <<= 4;
+      hval += (unsigned long int) *str++;
+      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));
+      if (g != 0)
+	{
+	  hval ^= g >> (HASHWORDBITS - 8);
+	  hval ^= g;
+	}
+    }
+  return hval;
+}
diff -Naur orig/intl/intl-compat.c patched/intl/intl-compat.c
--- orig/intl/intl-compat.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/intl-compat.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,166 @@
+/* intl-compat.c - Stub functions to call gettext functions from GNU gettext
+   Library.
+   Copyright (C) 1995, 2000, 2001 Software Foundation, Inc.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "libgnuintl.h"
+#include "gettextP.h"
+
+/* @@ end of prolog @@ */
+
+/* This file redirects the gettext functions (without prefix or suffix) to
+   those defined in the included GNU gettext library (with "__" suffix).
+   It is compiled into libintl when the included GNU gettext library is
+   configured --with-included-gettext.
+
+   This redirection works also in the case that the system C library or
+   the system libintl library contain gettext/textdomain/... functions.
+   If it didn't, we would need to add preprocessor level redirections to
+   libgnuintl.h of the following form:
+
+#    define gettext gettext__
+#    define dgettext dgettext__
+#    define dcgettext dcgettext__
+#    define ngettext ngettext__
+#    define dngettext dngettext__
+#    define dcngettext dcngettext__
+#    define textdomain textdomain__
+#    define bindtextdomain bindtextdomain__
+#    define bind_textdomain_codeset bind_textdomain_codeset__
+
+   How does this redirection work? There are two cases.
+   A. When libintl.a is linked into an executable, it works because
+      functions defined in the executable always override functions in
+      the shared libraries.
+   B. When libintl.so is used, it works because
+      1. those systems defining gettext/textdomain/... in the C library
+         (namely, Solaris 2.4 and newer, and GNU libc 2.0 and newer) are
+         ELF systems and define these symbols as weak, thus explicitly
+         letting other shared libraries override it.
+      2. those systems defining gettext/textdomain/... in a standalone
+         libintl.so library (namely, Solaris 2.3 and newer) have this
+         shared library in /usr/lib, and the linker will search /usr/lib
+         *after* the directory where the GNU gettext library is installed.
+
+   A third case, namely when libintl.a is linked into a shared library
+   whose name is not libintl.so, is not supported. In this case, on
+   Solaris, when -lintl precedes the linker option for the shared library
+   containing GNU gettext, the system's gettext would indeed override
+   the GNU gettext. Anyone doing this kind of stuff must be clever enough
+   to 1. compile libintl.a with -fPIC, 2. remove -lintl from his linker
+   command line.  */
+
+
+#undef gettext
+#undef dgettext
+#undef dcgettext
+#undef ngettext
+#undef dngettext
+#undef dcngettext
+#undef textdomain
+#undef bindtextdomain
+#undef bind_textdomain_codeset
+
+
+char *
+gettext (msgid)
+     const char *msgid;
+{
+  return gettext__ (msgid);
+}
+
+
+char *
+dgettext (domainname, msgid)
+     const char *domainname;
+     const char *msgid;
+{
+  return dgettext__ (domainname, msgid);
+}
+
+
+char *
+dcgettext (domainname, msgid, category)
+     const char *domainname;
+     const char *msgid;
+     int category;
+{
+  return dcgettext__ (domainname, msgid, category);
+}
+
+
+char *
+ngettext (msgid1, msgid2, n)
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+{
+  return ngettext__ (msgid1, msgid2, n);
+}
+
+
+char *
+dngettext (domainname, msgid1, msgid2, n)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+{
+  return dngettext__ (domainname, msgid1, msgid2, n);
+}
+
+
+char *
+dcngettext (domainname, msgid1, msgid2, n, category)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+     int category;
+{
+  return dcngettext__ (domainname, msgid1, msgid2, n, category);
+}
+
+
+char *
+textdomain (domainname)
+     const char *domainname;
+{
+  return textdomain__ (domainname);
+}
+
+
+char *
+bindtextdomain (domainname, dirname)
+     const char *domainname;
+     const char *dirname;
+{
+  return bindtextdomain__ (domainname, dirname);
+}
+
+
+char *
+bind_textdomain_codeset (domainname, codeset)
+     const char *domainname;
+     const char *codeset;
+{
+  return bind_textdomain_codeset__ (domainname, codeset);
+}
diff -Naur orig/intl/l10nflist.c patched/intl/l10nflist.c
--- orig/intl/l10nflist.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/l10nflist.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,404 @@
+/* Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+/* Tell glibc's <string.h> to provide a prototype for stpcpy().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE	1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <string.h>
+#if !HAVE_STRCHR && !defined _LIBC
+# ifndef strchr
+#  define strchr index
+# endif
+#endif
+
+#if defined _LIBC || defined HAVE_ARGZ_H
+# include <argz.h>
+#endif
+#include <ctype.h>
+#include <sys/types.h>
+#include <stdlib.h>
+
+#include "loadinfo.h"
+
+/* On some strange systems still no definition of NULL is found.  Sigh!  */
+#ifndef NULL
+# if defined __STDC__ && __STDC__
+#  define NULL ((void *) 0)
+# else
+#  define NULL 0
+# endif
+#endif
+
+/* @@ end of prolog @@ */
+
+#ifdef _LIBC
+/* Rename the non ANSI C functions.  This is required by the standard
+   because some ANSI C functions will require linking with this object
+   file and the name space must not be polluted.  */
+# ifndef stpcpy
+#  define stpcpy(dest, src) __stpcpy(dest, src)
+# endif
+#else
+# ifndef HAVE_STPCPY
+static char *stpcpy PARAMS ((char *dest, const char *src));
+# endif
+#endif
+
+/* Define function which are usually not available.  */
+
+#if !defined _LIBC && !defined HAVE___ARGZ_COUNT
+/* Returns the number of strings in ARGZ.  */
+static size_t argz_count__ PARAMS ((const char *argz, size_t len));
+
+static size_t
+argz_count__ (argz, len)
+     const char *argz;
+     size_t len;
+{
+  size_t count = 0;
+  while (len > 0)
+    {
+      size_t part_len = strlen (argz);
+      argz += part_len + 1;
+      len -= part_len + 1;
+      count++;
+    }
+  return count;
+}
+# undef __argz_count
+# define __argz_count(argz, len) argz_count__ (argz, len)
+#endif	/* !_LIBC && !HAVE___ARGZ_COUNT */
+
+#if !defined _LIBC && !defined HAVE___ARGZ_STRINGIFY
+/* Make '\0' separated arg vector ARGZ printable by converting all the '\0's
+   except the last into the character SEP.  */
+static void argz_stringify__ PARAMS ((char *argz, size_t len, int sep));
+
+static void
+argz_stringify__ (argz, len, sep)
+     char *argz;
+     size_t len;
+     int sep;
+{
+  while (len > 0)
+    {
+      size_t part_len = strlen (argz);
+      argz += part_len;
+      len -= part_len + 1;
+      if (len > 0)
+	*argz++ = sep;
+    }
+}
+# undef __argz_stringify
+# define __argz_stringify(argz, len, sep) argz_stringify__ (argz, len, sep)
+#endif	/* !_LIBC && !HAVE___ARGZ_STRINGIFY */
+
+#if !defined _LIBC && !defined HAVE___ARGZ_NEXT
+static char *argz_next__ PARAMS ((char *argz, size_t argz_len,
+				  const char *entry));
+
+static char *
+argz_next__ (argz, argz_len, entry)
+     char *argz;
+     size_t argz_len;
+     const char *entry;
+{
+  if (entry)
+    {
+      if (entry < argz + argz_len)
+        entry = strchr (entry, '\0') + 1;
+
+      return entry >= argz + argz_len ? NULL : (char *) entry;
+    }
+  else
+    if (argz_len > 0)
+      return argz;
+    else
+      return 0;
+}
+# undef __argz_next
+# define __argz_next(argz, len, entry) argz_next__ (argz, len, entry)
+#endif	/* !_LIBC && !HAVE___ARGZ_NEXT */
+
+
+/* Return number of bits set in X.  */
+static int pop PARAMS ((int x));
+
+static inline int
+pop (x)
+     int x;
+{
+  /* We assume that no more than 16 bits are used.  */
+  x = ((x & ~0x5555) >> 1) + (x & 0x5555);
+  x = ((x & ~0x3333) >> 2) + (x & 0x3333);
+  x = ((x >> 4) + x) & 0x0f0f;
+  x = ((x >> 8) + x) & 0xff;
+
+  return x;
+}
+
+
+struct loaded_l10nfile *
+_nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
+		    territory, codeset, normalized_codeset, modifier, special,
+		    sponsor, revision, filename, do_allocate)
+     struct loaded_l10nfile **l10nfile_list;
+     const char *dirlist;
+     size_t dirlist_len;
+     int mask;
+     const char *language;
+     const char *territory;
+     const char *codeset;
+     const char *normalized_codeset;
+     const char *modifier;
+     const char *special;
+     const char *sponsor;
+     const char *revision;
+     const char *filename;
+     int do_allocate;
+{
+  char *abs_filename;
+  struct loaded_l10nfile *last = NULL;
+  struct loaded_l10nfile *retval;
+  char *cp;
+  size_t entries;
+  int cnt;
+
+  /* Allocate room for the full file name.  */
+  abs_filename = (char *) malloc (dirlist_len
+				  + strlen (language)
+				  + ((mask & TERRITORY) != 0
+				     ? strlen (territory) + 1 : 0)
+				  + ((mask & XPG_CODESET) != 0
+				     ? strlen (codeset) + 1 : 0)
+				  + ((mask & XPG_NORM_CODESET) != 0
+				     ? strlen (normalized_codeset) + 1 : 0)
+				  + (((mask & XPG_MODIFIER) != 0
+				      || (mask & CEN_AUDIENCE) != 0)
+				     ? strlen (modifier) + 1 : 0)
+				  + ((mask & CEN_SPECIAL) != 0
+				     ? strlen (special) + 1 : 0)
+				  + (((mask & CEN_SPONSOR) != 0
+				      || (mask & CEN_REVISION) != 0)
+				     ? (1 + ((mask & CEN_SPONSOR) != 0
+					     ? strlen (sponsor) + 1 : 0)
+					+ ((mask & CEN_REVISION) != 0
+					   ? strlen (revision) + 1 : 0)) : 0)
+				  + 1 + strlen (filename) + 1);
+
+  if (abs_filename == NULL)
+    return NULL;
+
+  retval = NULL;
+  last = NULL;
+
+  /* Construct file name.  */
+  memcpy (abs_filename, dirlist, dirlist_len);
+  __argz_stringify (abs_filename, dirlist_len, PATH_SEPARATOR);
+  cp = abs_filename + (dirlist_len - 1);
+  *cp++ = '/';
+  cp = stpcpy (cp, language);
+
+  if ((mask & TERRITORY) != 0)
+    {
+      *cp++ = '_';
+      cp = stpcpy (cp, territory);
+    }
+  if ((mask & XPG_CODESET) != 0)
+    {
+      *cp++ = '.';
+      cp = stpcpy (cp, codeset);
+    }
+  if ((mask & XPG_NORM_CODESET) != 0)
+    {
+      *cp++ = '.';
+      cp = stpcpy (cp, normalized_codeset);
+    }
+  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)
+    {
+      /* This component can be part of both syntaces but has different
+	 leading characters.  For CEN we use `+', else `@'.  */
+      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';
+      cp = stpcpy (cp, modifier);
+    }
+  if ((mask & CEN_SPECIAL) != 0)
+    {
+      *cp++ = '+';
+      cp = stpcpy (cp, special);
+    }
+  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)
+    {
+      *cp++ = ',';
+      if ((mask & CEN_SPONSOR) != 0)
+	cp = stpcpy (cp, sponsor);
+      if ((mask & CEN_REVISION) != 0)
+	{
+	  *cp++ = '_';
+	  cp = stpcpy (cp, revision);
+	}
+    }
+
+  *cp++ = '/';
+  stpcpy (cp, filename);
+
+  /* Look in list of already loaded domains whether it is already
+     available.  */
+  last = NULL;
+  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)
+    if (retval->filename != NULL)
+      {
+	int compare = strcmp (retval->filename, abs_filename);
+	if (compare == 0)
+	  /* We found it!  */
+	  break;
+	if (compare < 0)
+	  {
+	    /* It's not in the list.  */
+	    retval = NULL;
+	    break;
+	  }
+
+	last = retval;
+      }
+
+  if (retval != NULL || do_allocate == 0)
+    {
+      free (abs_filename);
+      return retval;
+    }
+
+  retval = (struct loaded_l10nfile *)
+    malloc (sizeof (*retval) + (__argz_count (dirlist, dirlist_len)
+				* (1 << pop (mask))
+				* sizeof (struct loaded_l10nfile *)));
+  if (retval == NULL)
+    return NULL;
+
+  retval->filename = abs_filename;
+  retval->decided = (__argz_count (dirlist, dirlist_len) != 1
+		     || ((mask & XPG_CODESET) != 0
+			 && (mask & XPG_NORM_CODESET) != 0));
+  retval->data = NULL;
+
+  if (last == NULL)
+    {
+      retval->next = *l10nfile_list;
+      *l10nfile_list = retval;
+    }
+  else
+    {
+      retval->next = last->next;
+      last->next = retval;
+    }
+
+  entries = 0;
+  /* If the DIRLIST is a real list the RETVAL entry corresponds not to
+     a real file.  So we have to use the DIRLIST separation mechanism
+     of the inner loop.  */
+  cnt = __argz_count (dirlist, dirlist_len) == 1 ? mask - 1 : mask;
+  for (; cnt >= 0; --cnt)
+    if ((cnt & ~mask) == 0
+	&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)
+	&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))
+      {
+	/* Iterate over all elements of the DIRLIST.  */
+	char *dir = NULL;
+
+	while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
+	       != NULL)
+	  retval->successor[entries++]
+	    = _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1, cnt,
+				  language, territory, codeset,
+				  normalized_codeset, modifier, special,
+				  sponsor, revision, filename, 1);
+      }
+  retval->successor[entries] = NULL;
+
+  return retval;
+}
+
+/* Normalize codeset name.  There is no standard for the codeset
+   names.  Normalization allows the user to use any of the common
+   names.  The return value is dynamically allocated and has to be
+   freed by the caller.  */
+const char *
+_nl_normalize_codeset (codeset, name_len)
+     const char *codeset;
+     size_t name_len;
+{
+  int len = 0;
+  int only_digit = 1;
+  char *retval;
+  char *wp;
+  size_t cnt;
+
+  for (cnt = 0; cnt < name_len; ++cnt)
+    if (isalnum (codeset[cnt]))
+      {
+	++len;
+
+	if (isalpha (codeset[cnt]))
+	  only_digit = 0;
+      }
+
+  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);
+
+  if (retval != NULL)
+    {
+      if (only_digit)
+	wp = stpcpy (retval, "iso");
+      else
+	wp = retval;
+
+      for (cnt = 0; cnt < name_len; ++cnt)
+	if (isalpha (codeset[cnt]))
+	  *wp++ = tolower (codeset[cnt]);
+	else if (isdigit (codeset[cnt]))
+	  *wp++ = codeset[cnt];
+
+      *wp = '\0';
+    }
+
+  return (const char *) retval;
+}
+
+
+/* @@ begin of epilog @@ */
+
+/* We don't want libintl.a to depend on any other library.  So we
+   avoid the non-standard function stpcpy.  In GNU C Library this
+   function is available, though.  Also allow the symbol HAVE_STPCPY
+   to be defined.  */
+#if !_LIBC && !HAVE_STPCPY
+static char *
+stpcpy (dest, src)
+     char *dest;
+     const char *src;
+{
+  while ((*dest++ = *src++) != '\0')
+    /* Do nothing. */ ;
+  return dest - 1;
+}
+#endif
diff -Naur orig/intl/libgettext.h patched/intl/libgettext.h
--- orig/intl/libgettext.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/libgettext.h	2002-05-30 12:52:23.000000000 +0200
@@ -0,0 +1,48 @@
+/* Convenience header for conditional use of GNU <libintl.h>.
+   Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _LIBGETTEXT_H
+#define _LIBGETTEXT_H 1
+
+/* NLS can be disabled through the configure --disable-nls option.  */
+#if ENABLE_NLS
+
+/* Get declarations of GNU message catalog functions.  */
+# include <libintl.h>
+
+#else
+
+# define gettext(Msgid) (Msgid)
+# define dgettext(Domainname, Msgid) (Msgid)
+# define dcgettext(Domainname, Msgid, Category) (Msgid)
+# define ngettext(Msgid1, Msgid2, N) \
+    ((N) == 1 ? (char *) (Msgid1) : (char *) (Msgid2))
+# define dngettext(Domainname, Msgid1, Msgid2, N) \
+    ((N) == 1 ? (char *) (Msgid1) : (char *) (Msgid2))
+# define dcngettext(Domainname, Msgid1, Msgid2, N, Category) \
+    ((N) == 1 ? (char *) (Msgid1) : (char *) (Msgid2))
+# define textdomain(Domainname) ((char *) (Domainname))
+# define bindtextdomain(Domainname, Dirname) ((char *) (Dirname))
+# define bind_textdomain_codeset(Domainname, Codeset) ((char *) (Codeset))
+
+#endif
+
+/* For automatical extraction of messages sometimes no real
+   translation is needed.  Instead the string itself is the result.  */
+#define gettext_noop(Str) (Str)
+
+#endif /* _LIBGETTEXT_H */
diff -Naur orig/intl/libgnuintl.h patched/intl/libgnuintl.h
--- orig/intl/libgnuintl.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/libgnuintl.h	2002-05-30 12:52:05.000000000 +0200
@@ -0,0 +1,127 @@
+/* Message catalogs for internationalization.
+   Copyright (C) 1995-1997, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _LIBINTL_H
+#define _LIBINTL_H	1
+
+#include <locale.h>
+
+/* The LC_MESSAGES locale category is the category used by the functions
+   gettext() and dgettext().  It is specified in POSIX, but not in ANSI C.
+   On systems that don't define it, use an arbitrary value instead.
+   On Solaris, <locale.h> defines __LOCALE_H then includes <libintl.h> (i.e.
+   this file!) and then only defines LC_MESSAGES.  To avoid a redefinition
+   warning, don't define LC_MESSAGES in this case.  */
+#if !defined LC_MESSAGES && !defined __LOCALE_H
+# define LC_MESSAGES 1729
+#endif
+
+/* We define an additional symbol to signal that we use the GNU
+   implementation of gettext.  */
+#define __USE_GNU_GETTEXT 1
+
+/* Resolve a platform specific conflict on DJGPP.  GNU gettext takes
+   precedence over _conio_gettext.  */
+#ifdef __DJGPP__
+# undef gettext
+# define gettext gettext
+#endif
+
+#ifndef PARAMS
+# if __STDC__ || defined __cplusplus
+#  define PARAMS(args) args
+# else
+#  define PARAMS(args) ()
+# endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+extern char *gettext PARAMS ((const char *__msgid));
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current
+   LC_MESSAGES locale.  */
+extern char *dgettext PARAMS ((const char *__domainname, const char *__msgid));
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+extern char *dcgettext PARAMS ((const char *__domainname, const char *__msgid,
+				int __category));
+
+
+/* Similar to `gettext' but select the plural form corresponding to the
+   number N.  */
+extern char *ngettext PARAMS ((const char *__msgid1, const char *__msgid2,
+			       unsigned long int __n));
+
+/* Similar to `dgettext' but select the plural form corresponding to the
+   number N.  */
+extern char *dngettext PARAMS ((const char *__domainname, const char *__msgid1,
+				const char *__msgid2, unsigned long int __n));
+
+/* Similar to `dcgettext' but select the plural form corresponding to the
+   number N.  */
+extern char *dcngettext PARAMS ((const char *__domainname, const char *__msgid1,
+				 const char *__msgid2, unsigned long int __n,
+				 int __category));
+
+
+/* Set the current default message catalog to DOMAINNAME.
+   If DOMAINNAME is null, return the current default.
+   If DOMAINNAME is "", reset to the default of "messages".  */
+extern char *textdomain PARAMS ((const char *__domainname));
+
+/* Specify that the DOMAINNAME message catalog will be found
+   in DIRNAME rather than in the system locale data base.  */
+extern char *bindtextdomain PARAMS ((const char *__domainname,
+				     const char *__dirname));
+
+/* Specify the character encoding in which the messages from the
+   DOMAINNAME message catalog will be returned.  */
+extern char *bind_textdomain_codeset PARAMS ((const char *__domainname,
+					      const char *__codeset));
+
+
+/* Optimized version of the functions above.  */
+#if defined __OPTIMIZED
+/* These are macros, but could also be inline functions.  */
+
+# define gettext(msgid)							      \
+  dgettext (NULL, msgid)
+
+# define dgettext(domainname, msgid)					      \
+  dcgettext (domainname, msgid, LC_MESSAGES)
+
+# define ngettext(msgid1, msgid2, n)					      \
+  dngettext (NULL, msgid1, msgid2, n)
+
+# define dngettext(domainname, msgid1, msgid2, n)			      \
+  dcngettext (domainname, msgid1, msgid2, n, LC_MESSAGES)
+
+#endif /* Optimizing. */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* libintl.h */
diff -Naur orig/intl/loadinfo.h patched/intl/loadinfo.h
--- orig/intl/loadinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/loadinfo.h	2002-05-30 12:52:16.000000000 +0200
@@ -0,0 +1,108 @@
+/* Copyright (C) 1996-1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _LOADINFO_H
+#define _LOADINFO_H	1
+
+#ifndef PARAMS
+# if __STDC__
+#  define PARAMS(args) args
+# else
+#  define PARAMS(args) ()
+# endif
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+/* Tell the compiler when a conditional or integer expression is
+   almost always true or almost always false.  */
+#ifndef HAVE_BUILTIN_EXPECT
+# define __builtin_expect(expr, val) (expr)
+#endif
+
+/* Separator in PATH like lists of pathnames.  */
+#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
+# define PATH_SEPARATOR ';'
+#else
+  /* Unix */
+# define PATH_SEPARATOR ':'
+#endif
+
+/* Encoding of locale name parts.  */
+#define CEN_REVISION		1
+#define CEN_SPONSOR		2
+#define CEN_SPECIAL		4
+#define XPG_NORM_CODESET	8
+#define XPG_CODESET		16
+#define TERRITORY		32
+#define CEN_AUDIENCE		64
+#define XPG_MODIFIER		128
+
+#define CEN_SPECIFIC	(CEN_REVISION|CEN_SPONSOR|CEN_SPECIAL|CEN_AUDIENCE)
+#define XPG_SPECIFIC	(XPG_CODESET|XPG_NORM_CODESET|XPG_MODIFIER)
+
+
+struct loaded_l10nfile
+{
+  const char *filename;
+  int decided;
+
+  const void *data;
+
+  struct loaded_l10nfile *next;
+  struct loaded_l10nfile *successor[1];
+};
+
+
+/* Normalize codeset name.  There is no standard for the codeset
+   names.  Normalization allows the user to use any of the common
+   names.  The return value is dynamically allocated and has to be
+   freed by the caller.  */
+extern const char *_nl_normalize_codeset PARAMS ((const char *codeset,
+						  size_t name_len));
+
+extern struct loaded_l10nfile *
+_nl_make_l10nflist PARAMS ((struct loaded_l10nfile **l10nfile_list,
+			    const char *dirlist, size_t dirlist_len, int mask,
+			    const char *language, const char *territory,
+			    const char *codeset,
+			    const char *normalized_codeset,
+			    const char *modifier, const char *special,
+			    const char *sponsor, const char *revision,
+			    const char *filename, int do_allocate));
+
+
+extern const char *_nl_expand_alias PARAMS ((const char *name));
+
+/* normalized_codeset is dynamically allocated and has to be freed by
+   the caller.  */
+extern int _nl_explode_name PARAMS ((char *name, const char **language,
+				     const char **modifier,
+				     const char **territory,
+				     const char **codeset,
+				     const char **normalized_codeset,
+				     const char **special,
+				     const char **sponsor,
+				     const char **revision));
+
+extern char *_nl_find_language PARAMS ((const char *name));
+
+#endif	/* loadinfo.h */
diff -Naur orig/intl/loadmsgcat.c patched/intl/loadmsgcat.c
--- orig/intl/loadmsgcat.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/loadmsgcat.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,566 @@
+/* Load needed message catalogs.
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+/* Tell glibc's <string.h> to provide a prototype for mempcpy().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE    1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+# define HAVE_ALLOCA 1
+#else
+# if defined HAVE_ALLOCA_H || defined _LIBC
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+ #pragma alloca
+#  else
+#   ifndef alloca
+char *alloca ();
+#   endif
+#  endif
+# endif
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#if defined HAVE_UNISTD_H || defined _LIBC
+# include <unistd.h>
+#endif
+
+#ifdef _LIBC
+# include <langinfo.h>
+# include <locale.h>
+#endif
+
+#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
+    || (defined _LIBC && defined _POSIX_MAPPED_FILES)
+# include <sys/mman.h>
+# undef HAVE_MMAP
+# define HAVE_MMAP	1
+#else
+# undef HAVE_MMAP
+#endif
+
+#include "gettext.h"
+#include "gettextP.h"
+
+#ifdef _LIBC
+# include "../locale/localeinfo.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+#ifdef _LIBC
+/* Rename the non ISO C functions.  This is required by the standard
+   because some ISO C functions will require linking with this object
+   file and the name space must not be polluted.  */
+# define open   __open
+# define close  __close
+# define read   __read
+# define mmap   __mmap
+# define munmap __munmap
+#endif
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define PLURAL_PARSE __gettextparse
+#else
+# define PLURAL_PARSE gettextparse__
+#endif
+
+/* For those losing systems which don't have `alloca' we have to add
+   some additional code emulating it.  */
+#ifdef HAVE_ALLOCA
+# define freea(p) /* nothing */
+#else
+# define alloca(n) malloc (n)
+# define freea(p) free (p)
+#endif
+
+/* For systems that distinguish between text and binary I/O.
+   O_BINARY is usually declared in <fcntl.h>. */
+#if !defined O_BINARY && defined _O_BINARY
+  /* For MSC-compatible compilers.  */
+# define O_BINARY _O_BINARY
+# define O_TEXT _O_TEXT
+#endif
+#ifdef __BEOS__
+  /* BeOS 5 has O_BINARY and O_TEXT, but they have no effect.  */
+# undef O_BINARY
+# undef O_TEXT
+#endif
+/* On reasonable systems, binary I/O is the default.  */
+#ifndef O_BINARY
+# define O_BINARY 0
+#endif
+
+/* We need a sign, whether a new catalog was loaded, which can be associated
+   with all translations.  This is important if the translations are
+   cached by one of GCC's features.  */
+int _nl_msg_cat_cntr;
+
+#if (defined __GNUC__ && !defined __APPLE_CC__) \
+    || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)
+
+/* These structs are the constant expression for the germanic plural
+   form determination.  It represents the expression  "n != 1".  */
+static const struct expression plvar =
+{
+  .nargs = 0,
+  .operation = var,
+};
+static const struct expression plone =
+{
+  .nargs = 0,
+  .operation = num,
+  .val =
+  {
+    .num = 1
+  }
+};
+static struct expression germanic_plural =
+{
+  .nargs = 2,
+  .operation = not_equal,
+  .val =
+  {
+    .args =
+    {
+      [0] = (struct expression *) &plvar,
+      [1] = (struct expression *) &plone
+    }
+  }
+};
+
+# define INIT_GERMANIC_PLURAL()
+
+#else
+
+/* For compilers without support for ISO C 99 struct/union initializers:
+   Initialization at run-time.  */
+
+static struct expression plvar;
+static struct expression plone;
+static struct expression germanic_plural;
+
+static void
+init_germanic_plural ()
+{
+  if (plone.val.num == 0)
+    {
+      plvar.nargs = 0;
+      plvar.operation = var;
+
+      plone.nargs = 0;
+      plone.operation = num;
+      plone.val.num = 1;
+
+      germanic_plural.nargs = 2;
+      germanic_plural.operation = not_equal;
+      germanic_plural.val.args[0] = &plvar;
+      germanic_plural.val.args[1] = &plone;
+    }
+}
+
+# define INIT_GERMANIC_PLURAL() init_germanic_plural ()
+
+#endif
+
+
+/* Initialize the codeset dependent parts of an opened message catalog.
+   Return the header entry.  */
+const char *
+internal_function
+_nl_init_domain_conv (domain_file, domain, domainbinding)
+     struct loaded_l10nfile *domain_file;
+     struct loaded_domain *domain;
+     struct binding *domainbinding;
+{
+  /* Find out about the character set the file is encoded with.
+     This can be found (in textual form) in the entry "".  If this
+     entry does not exist or if this does not contain the `charset='
+     information, we will assume the charset matches the one the
+     current locale and we don't have to perform any conversion.  */
+  char *nullentry;
+  size_t nullentrylen;
+
+  /* Preinitialize fields, to avoid recursion during _nl_find_msg.  */
+  domain->codeset_cntr =
+    (domainbinding != NULL ? domainbinding->codeset_cntr : 0);
+#ifdef _LIBC
+  domain->conv = (__gconv_t) -1;
+#else
+# if HAVE_ICONV
+  domain->conv = (iconv_t) -1;
+# endif
+#endif
+  domain->conv_tab = NULL;
+
+  /* Get the header entry.  */
+  nullentry = _nl_find_msg (domain_file, domainbinding, "", &nullentrylen);
+
+  if (nullentry != NULL)
+    {
+#if defined _LIBC || HAVE_ICONV
+      const char *charsetstr;
+
+      charsetstr = strstr (nullentry, "charset=");
+      if (charsetstr != NULL)
+	{
+	  size_t len;
+	  char *charset;
+	  const char *outcharset;
+
+	  charsetstr += strlen ("charset=");
+	  len = strcspn (charsetstr, " \t\n");
+
+	  charset = (char *) alloca (len + 1);
+# if defined _LIBC || HAVE_MEMPCPY
+	  *((char *) mempcpy (charset, charsetstr, len)) = '\0';
+# else
+	  memcpy (charset, charsetstr, len);
+	  charset[len] = '\0';
+# endif
+
+	  /* The output charset should normally be determined by the
+	     locale.  But sometimes the locale is not used or not correctly
+	     set up, so we provide a possibility for the user to override
+	     this.  Moreover, the value specified through
+	     bind_textdomain_codeset overrides both.  */
+	  if (domainbinding != NULL && domainbinding->codeset != NULL)
+	    outcharset = domainbinding->codeset;
+	  else
+	    {
+	      outcharset = getenv ("OUTPUT_CHARSET");
+	      if (outcharset == NULL || outcharset[0] == '\0')
+		{
+# ifdef _LIBC
+		  outcharset = (*_nl_current[LC_CTYPE])->values[_NL_ITEM_INDEX (CODESET)].string;
+# else
+#  if HAVE_ICONV
+		  extern const char *locale_charset (void);
+		  outcharset = locale_charset ();
+#  endif
+# endif
+		}
+	    }
+
+# ifdef _LIBC
+	  /* We always want to use transliteration.  */
+	  outcharset = norm_add_slashes (outcharset, "TRANSLIT");
+	  charset = norm_add_slashes (charset, NULL);
+	  if (__gconv_open (outcharset, charset, &domain->conv,
+			    GCONV_AVOID_NOCONV)
+	      != __GCONV_OK)
+	    domain->conv = (__gconv_t) -1;
+# else
+#  if HAVE_ICONV
+	  /* When using GNU libiconv, we want to use transliteration.  */
+#   if _LIBICONV_VERSION >= 0x0105
+	  len = strlen (outcharset);
+	  {
+	    char *tmp = (char *) alloca (len + 10 + 1);
+	    memcpy (tmp, outcharset, len);
+	    memcpy (tmp + len, "//TRANSLIT", 10 + 1);
+	    outcharset = tmp;
+	  }
+#   endif
+	  domain->conv = iconv_open (outcharset, charset);
+#   if _LIBICONV_VERSION >= 0x0105
+	  freea (outcharset);
+#   endif
+#  endif
+# endif
+
+	  freea (charset);
+	}
+#endif /* _LIBC || HAVE_ICONV */
+    }
+
+  return nullentry;
+}
+
+/* Frees the codeset dependent parts of an opened message catalog.  */
+void
+internal_function
+_nl_free_domain_conv (domain)
+     struct loaded_domain *domain;
+{
+  if (domain->conv_tab != NULL && domain->conv_tab != (char **) -1)
+    free (domain->conv_tab);
+
+#ifdef _LIBC
+  if (domain->conv != (__gconv_t) -1)
+    __gconv_close (domain->conv);
+#else
+# if HAVE_ICONV
+  if (domain->conv != (iconv_t) -1)
+    iconv_close (domain->conv);
+# endif
+#endif
+}
+
+/* Load the message catalogs specified by FILENAME.  If it is no valid
+   message catalog do nothing.  */
+void
+internal_function
+_nl_load_domain (domain_file, domainbinding)
+     struct loaded_l10nfile *domain_file;
+     struct binding *domainbinding;
+{
+  int fd;
+  size_t size;
+#ifdef _LIBC
+  struct stat64 st;
+#else
+  struct stat st;
+#endif
+  struct mo_file_header *data = (struct mo_file_header *) -1;
+  int use_mmap = 0;
+  struct loaded_domain *domain;
+  const char *nullentry;
+
+  domain_file->decided = 1;
+  domain_file->data = NULL;
+
+  /* Note that it would be useless to store domainbinding in domain_file
+     because domainbinding might be == NULL now but != NULL later (after
+     a call to bind_textdomain_codeset).  */
+
+  /* If the record does not represent a valid locale the FILENAME
+     might be NULL.  This can happen when according to the given
+     specification the locale file name is different for XPG and CEN
+     syntax.  */
+  if (domain_file->filename == NULL)
+    return;
+
+  /* Try to open the addressed file.  */
+  fd = open (domain_file->filename, O_RDONLY | O_BINARY);
+  if (fd == -1)
+    return;
+
+  /* We must know about the size of the file.  */
+  if (
+#ifdef _LIBC
+      __builtin_expect (fstat64 (fd, &st) != 0, 0)
+#else
+      __builtin_expect (fstat (fd, &st) != 0, 0)
+#endif
+      || __builtin_expect ((size = (size_t) st.st_size) != st.st_size, 0)
+      || __builtin_expect (size < sizeof (struct mo_file_header), 0))
+    {
+      /* Something went wrong.  */
+      close (fd);
+      return;
+    }
+
+#ifdef HAVE_MMAP
+  /* Now we are ready to load the file.  If mmap() is available we try
+     this first.  If not available or it failed we try to load it.  */
+  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,
+					 MAP_PRIVATE, fd, 0);
+
+  if (__builtin_expect (data != (struct mo_file_header *) -1, 1))
+    {
+      /* mmap() call was successful.  */
+      close (fd);
+      use_mmap = 1;
+    }
+#endif
+
+  /* If the data is not yet available (i.e. mmap'ed) we try to load
+     it manually.  */
+  if (data == (struct mo_file_header *) -1)
+    {
+      size_t to_read;
+      char *read_ptr;
+
+      data = (struct mo_file_header *) malloc (size);
+      if (data == NULL)
+	return;
+
+      to_read = size;
+      read_ptr = (char *) data;
+      do
+	{
+	  long int nb = (long int) read (fd, read_ptr, to_read);
+	  if (nb <= 0)
+	    {
+#ifdef EINTR
+	      if (nb == -1 && errno == EINTR)
+		continue;
+#endif
+	      close (fd);
+	      return;
+	    }
+	  read_ptr += nb;
+	  to_read -= nb;
+	}
+      while (to_read > 0);
+
+      close (fd);
+    }
+
+  /* Using the magic number we can test whether it really is a message
+     catalog file.  */
+  if (__builtin_expect (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED,
+			0))
+    {
+      /* The magic number is wrong: not a message catalog file.  */
+#ifdef HAVE_MMAP
+      if (use_mmap)
+	munmap ((caddr_t) data, size);
+      else
+#endif
+	free (data);
+      return;
+    }
+
+  domain = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
+  if (domain == NULL)
+    return;
+  domain_file->data = domain;
+
+  domain->data = (char *) data;
+  domain->use_mmap = use_mmap;
+  domain->mmap_size = size;
+  domain->must_swap = data->magic != _MAGIC;
+
+  /* Fill in the information about the available tables.  */
+  switch (W (domain->must_swap, data->revision))
+    {
+    case 0:
+      domain->nstrings = W (domain->must_swap, data->nstrings);
+      domain->orig_tab = (struct string_desc *)
+	((char *) data + W (domain->must_swap, data->orig_tab_offset));
+      domain->trans_tab = (struct string_desc *)
+	((char *) data + W (domain->must_swap, data->trans_tab_offset));
+      domain->hash_size = W (domain->must_swap, data->hash_tab_size);
+      domain->hash_tab = (nls_uint32 *)
+	((char *) data + W (domain->must_swap, data->hash_tab_offset));
+      break;
+    default:
+      /* This is an invalid revision.  */
+#ifdef HAVE_MMAP
+      if (use_mmap)
+	munmap ((caddr_t) data, size);
+      else
+#endif
+	free (data);
+      free (domain);
+      domain_file->data = NULL;
+      return;
+    }
+
+  /* Now initialize the character set converter from the character set
+     the file is encoded with (found in the header entry) to the domain's
+     specified character set or the locale's character set.  */
+  nullentry = _nl_init_domain_conv (domain_file, domain, domainbinding);
+
+  /* Also look for a plural specification.  */
+  if (nullentry != NULL)
+    {
+      const char *plural;
+      const char *nplurals;
+
+      plural = strstr (nullentry, "plural=");
+      nplurals = strstr (nullentry, "nplurals=");
+      if (plural == NULL || nplurals == NULL)
+	goto no_plural;
+      else
+	{
+	  /* First get the number.  */
+	  char *endp;
+	  unsigned long int n;
+	  struct parse_args args;
+
+	  nplurals += 9;
+	  while (*nplurals != '\0' && isspace (*nplurals))
+	    ++nplurals;
+#if defined HAVE_STRTOUL || defined _LIBC
+	  n = strtoul (nplurals, &endp, 10);
+#else
+	  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)
+	    n = n * 10 + (*endp - '0');
+#endif
+	  domain->nplurals = n;
+	  if (nplurals == endp)
+	    goto no_plural;
+
+	  /* Due to the restrictions bison imposes onto the interface of the
+	     scanner function we have to put the input string and the result
+	     passed up from the parser into the same structure which address
+	     is passed down to the parser.  */
+	  plural += 7;
+	  args.cp = plural;
+	  if (PLURAL_PARSE (&args) != 0)
+	    goto no_plural;
+	  domain->plural = args.res;
+	}
+    }
+  else
+    {
+      /* By default we are using the Germanic form: singular form only
+         for `one', the plural form otherwise.  Yes, this is also what
+         English is using since English is a Germanic language.  */
+    no_plural:
+      INIT_GERMANIC_PLURAL ();
+      domain->plural = &germanic_plural;
+      domain->nplurals = 2;
+    }
+}
+
+
+#ifdef _LIBC
+void
+internal_function
+_nl_unload_domain (domain)
+     struct loaded_domain *domain;
+{
+  if (domain->plural != &germanic_plural)
+    __gettext_free_exp (domain->plural);
+
+  _nl_free_domain_conv (domain);
+
+# ifdef _POSIX_MAPPED_FILES
+  if (domain->use_mmap)
+    munmap ((caddr_t) domain->data, domain->mmap_size);
+  else
+# endif	/* _POSIX_MAPPED_FILES */
+    free ((void *) domain->data);
+
+  free (domain);
+}
+#endif
diff -Naur orig/intl/localcharset.c patched/intl/localcharset.c
--- orig/intl/localcharset.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/localcharset.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,270 @@
+/* Determine a canonical name for the current locale's character encoding.
+
+   Copyright (C) 2000-2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+/* Written by Bruno Haible <haible@clisp.cons.org>.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#if HAVE_STDDEF_H
+# include <stddef.h>
+#endif
+
+#include <stdio.h>
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+#if HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+
+#if defined _WIN32 || defined __WIN32__
+# undef WIN32   /* avoid warning on mingw32 */
+# define WIN32
+#endif
+
+#ifndef WIN32
+# if HAVE_LANGINFO_CODESET
+#  include <langinfo.h>
+# else
+#  if HAVE_SETLOCALE
+#   include <locale.h>
+#  endif
+# endif
+#else /* WIN32 */
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+#endif
+
+#ifndef DIRECTORY_SEPARATOR
+# define DIRECTORY_SEPARATOR '/'
+#endif
+
+#ifndef ISSLASH
+# define ISSLASH(C) ((C) == DIRECTORY_SEPARATOR)
+#endif
+
+/* The following static variable is declared 'volatile' to avoid a
+   possible multithread problem in the function get_charset_aliases. If we
+   are running in a threaded environment, and if two threads initialize
+   'charset_aliases' simultaneously, both will produce the same value,
+   and everything will be ok if the two assignments to 'charset_aliases'
+   are atomic. But I don't know what will happen if the two assignments mix.  */
+#if __STDC__ != 1
+# define volatile /* empty */
+#endif
+/* Pointer to the contents of the charset.alias file, if it has already been
+   read, else NULL.  Its format is:
+   ALIAS_1 '\0' CANONICAL_1 '\0' ... ALIAS_n '\0' CANONICAL_n '\0' '\0'  */
+static const char * volatile charset_aliases;
+
+/* Return a pointer to the contents of the charset.alias file.  */
+static const char *
+get_charset_aliases ()
+{
+  const char *cp;
+
+  cp = charset_aliases;
+  if (cp == NULL)
+    {
+#ifndef WIN32
+      FILE *fp;
+      const char *dir = LIBDIR;
+      const char *base = "charset.alias";
+      char *file_name;
+
+      /* Concatenate dir and base into freshly allocated file_name.  */
+      {
+	size_t dir_len = strlen (dir);
+	size_t base_len = strlen (base);
+	int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));
+	file_name = (char *) malloc (dir_len + add_slash + base_len + 1);
+	if (file_name != NULL)
+	  {
+	    memcpy (file_name, dir, dir_len);
+	    if (add_slash)
+	      file_name[dir_len] = DIRECTORY_SEPARATOR;
+	    memcpy (file_name + dir_len + add_slash, base, base_len + 1);
+	  }
+      }
+
+      if (file_name == NULL || (fp = fopen (file_name, "r")) == NULL)
+	/* Out of memory or file not found, treat it as empty.  */
+	cp = "";
+      else
+	{
+	  /* Parse the file's contents.  */
+	  int c;
+	  char buf1[50+1];
+	  char buf2[50+1];
+	  char *res_ptr = NULL;
+	  size_t res_size = 0;
+	  size_t l1, l2;
+
+	  for (;;)
+	    {
+	      c = getc (fp);
+	      if (c == EOF)
+		break;
+	      if (c == '\n' || c == ' ' || c == '\t')
+		continue;
+	      if (c == '#')
+		{
+		  /* Skip comment, to end of line.  */
+		  do
+		    c = getc (fp);
+		  while (!(c == EOF || c == '\n'));
+		  if (c == EOF)
+		    break;
+		  continue;
+		}
+	      ungetc (c, fp);
+	      if (fscanf(fp, "%50s %50s", buf1, buf2) < 2)
+		break;
+	      l1 = strlen (buf1);
+	      l2 = strlen (buf2);
+	      if (res_size == 0)
+		{
+		  res_size = l1 + 1 + l2 + 1;
+		  res_ptr = malloc (res_size + 1);
+		}
+	      else
+		{
+		  res_size += l1 + 1 + l2 + 1;
+		  res_ptr = realloc (res_ptr, res_size + 1);
+		}
+	      if (res_ptr == NULL)
+		{
+		  /* Out of memory. */
+		  res_size = 0;
+		  break;
+		}
+	      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
+	      strcpy (res_ptr + res_size - (l2 + 1), buf2);
+	    }
+	  fclose (fp);
+	  if (res_size == 0)
+	    cp = "";
+	  else
+	    {
+	      *(res_ptr + res_size) = '\0';
+	      cp = res_ptr;
+	    }
+	}
+
+      if (file_name != NULL)
+	free (file_name);
+
+#else /* WIN32 */
+
+      /* To avoid the troubles of installing a separate file in the same
+	 directory as the DLL and of retrieving the DLL's directory at
+	 runtime, simply inline the aliases here.  */
+
+      cp = "CP936" "\0" "GBK" "\0"
+	   "CP1361" "\0" "JOHAB" "\0";
+#endif
+
+      charset_aliases = cp;
+    }
+
+  return cp;
+}
+
+/* Determine the current locale's character encoding, and canonicalize it
+   into one of the canonical names listed in config.charset.
+   The result must not be freed; it is statically allocated.
+   If the canonical name cannot be determined, the result is a non-canonical
+   name.  */
+
+#ifdef STATIC
+STATIC
+#endif
+const char *
+locale_charset ()
+{
+  const char *codeset;
+  const char *aliases;
+
+#ifndef WIN32
+
+# if HAVE_LANGINFO_CODESET
+
+  /* Most systems support nl_langinfo (CODESET) nowadays.  */
+  codeset = nl_langinfo (CODESET);
+
+# else
+
+  /* On old systems which lack it, use setlocale or getenv.  */
+  const char *locale = NULL;
+
+  /* But most old systems don't have a complete set of locales.  Some
+     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't
+     use setlocale here; it would return "C" when it doesn't support the
+     locale name the user has set.  */
+#  if HAVE_SETLOCALE && 0
+  locale = setlocale (LC_CTYPE, NULL);
+#  endif
+  if (locale == NULL || locale[0] == '\0')
+    {
+      locale = getenv ("LC_ALL");
+      if (locale == NULL || locale[0] == '\0')
+	{
+	  locale = getenv ("LC_CTYPE");
+	  if (locale == NULL || locale[0] == '\0')
+	    locale = getenv ("LANG");
+	}
+    }
+
+  /* On some old systems, one used to set locale = "iso8859_1". On others,
+     you set it to "language_COUNTRY.charset". In any case, we resolve it
+     through the charset.alias file.  */
+  codeset = locale;
+
+# endif
+
+#else /* WIN32 */
+
+  static char buf[2 + 10 + 1];
+
+  /* Win32 has a function returning the locale's codepage as a number.  */
+  sprintf (buf, "CP%u", GetACP ());
+  codeset = buf;
+
+#endif
+
+  if (codeset == NULL)
+    /* The canonical name cannot be determined.  */
+    codeset = "";
+
+  /* Resolve alias. */
+  for (aliases = get_charset_aliases ();
+       *aliases != '\0';
+       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)
+    if (strcmp (codeset, aliases) == 0
+	|| (aliases[0] == '*' && aliases[1] == '\0'))
+      {
+	codeset = aliases + strlen (aliases) + 1;
+	break;
+      }
+
+  return codeset;
+}
diff -Naur orig/intl/locale.alias patched/intl/locale.alias
--- orig/intl/locale.alias	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/locale.alias	2002-05-30 12:52:04.000000000 +0200
@@ -0,0 +1,77 @@
+# Locale name alias data base.
+# Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# The format of this file is the same as for the corresponding file of
+# the X Window System, which normally can be found in
+#	/usr/lib/X11/locale/locale.alias
+# A single line contains two fields: an alias and a substitution value.
+# All entries are case independent.
+
+# Note: This file is far from being complete.  If you have a value for
+# your own site which you think might be useful for others too, share
+# it with the rest of us.  Send it using the `glibcbug' script to
+# bugs@gnu.org.
+
+# Packages using this file: 
+
+bokmal		no_NO.ISO-8859-1
+bokml		no_NO.ISO-8859-1
+catalan		ca_ES.ISO-8859-1
+croatian	hr_HR.ISO-8859-2
+czech		cs_CZ.ISO-8859-2
+danish          da_DK.ISO-8859-1
+dansk		da_DK.ISO-8859-1
+deutsch		de_DE.ISO-8859-1
+dutch		nl_NL.ISO-8859-1
+eesti		et_EE.ISO-8859-1
+estonian	et_EE.ISO-8859-1
+finnish         fi_FI.ISO-8859-1
+franais	fr_FR.ISO-8859-1
+french		fr_FR.ISO-8859-1
+galego		gl_ES.ISO-8859-1
+galician	gl_ES.ISO-8859-1
+german		de_DE.ISO-8859-1
+greek           el_GR.ISO-8859-7
+hebrew          iw_IL.ISO-8859-8
+hrvatski	hr_HR.ISO-8859-2
+hungarian       hu_HU.ISO-8859-2
+icelandic       is_IS.ISO-8859-1
+italian         it_IT.ISO-8859-1
+japanese	ja_JP.eucJP
+japanese.euc	ja_JP.eucJP
+ja_JP		ja_JP.eucJP
+ja_JP.ujis	ja_JP.eucJP
+japanese.sjis	ja_JP.SJIS
+korean		ko_KR.eucKR
+korean.euc 	ko_KR.eucKR
+ko_KR		ko_KR.eucKR
+lithuanian      lt_LT.ISO-8859-13
+nb_NO		no_NO.ISO-8859-1
+nb_NO.ISO-8859-1 no_NO.ISO-8859-1
+norwegian       no_NO.ISO-8859-1
+nynorsk		nn_NO.ISO-8859-1
+polish          pl_PL.ISO-8859-2
+portuguese      pt_PT.ISO-8859-1
+romanian        ro_RO.ISO-8859-2
+russian         ru_RU.ISO-8859-5
+slovak          sk_SK.ISO-8859-2
+slovene         sl_SI.ISO-8859-2
+slovenian       sl_SI.ISO-8859-2
+spanish         es_ES.ISO-8859-1
+swedish         sv_SE.ISO-8859-1
+thai		th_TH.TIS-620
+turkish         tr_TR.ISO-8859-9
diff -Naur orig/intl/localealias.c patched/intl/localealias.c
--- orig/intl/localealias.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/localealias.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,403 @@
+/* Handle aliases for locale names.
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+/* Tell glibc's <string.h> to provide a prototype for mempcpy().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE    1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#include <sys/types.h>
+
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+# define HAVE_ALLOCA 1
+#else
+# if defined HAVE_ALLOCA_H || defined _LIBC
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+ #pragma alloca
+#  else
+#   ifndef alloca
+char *alloca ();
+#   endif
+#  endif
+# endif
+#endif
+
+#include <stdlib.h>
+
+#include <string.h>
+#if !HAVE_STRCHR && !defined _LIBC
+# ifndef strchr
+#  define strchr index
+# endif
+#endif
+
+#include "gettextP.h"
+
+/* @@ end of prolog @@ */
+
+#ifdef _LIBC
+/* Rename the non ANSI C functions.  This is required by the standard
+   because some ANSI C functions will require linking with this object
+   file and the name space must not be polluted.  */
+# define strcasecmp __strcasecmp
+
+# ifndef mempcpy
+#  define mempcpy __mempcpy
+# endif
+# define HAVE_MEMPCPY	1
+
+/* We need locking here since we can be called from different places.  */
+# include <bits/libc-lock.h>
+
+__libc_lock_define_initialized (static, lock);
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+/* For those losing systems which don't have `alloca' we have to add
+   some additional code emulating it.  */
+#ifdef HAVE_ALLOCA
+# define freea(p) /* nothing */
+#else
+# define alloca(n) malloc (n)
+# define freea(p) free (p)
+#endif
+
+#if defined _LIBC_REENTRANT || defined HAVE_FGETS_UNLOCKED
+# undef fgets
+# define fgets(buf, len, s) fgets_unlocked (buf, len, s)
+#endif
+#if defined _LIBC_REENTRANT || defined HAVE_FEOF_UNLOCKED
+# undef feof
+# define feof(s) feof_unlocked (s)
+#endif
+
+
+struct alias_map
+{
+  const char *alias;
+  const char *value;
+};
+
+
+static char *string_space;
+static size_t string_space_act;
+static size_t string_space_max;
+static struct alias_map *map;
+static size_t nmap;
+static size_t maxmap;
+
+
+/* Prototypes for local functions.  */
+static size_t read_alias_file PARAMS ((const char *fname, int fname_len))
+     internal_function;
+static int extend_alias_table PARAMS ((void));
+static int alias_compare PARAMS ((const struct alias_map *map1,
+				  const struct alias_map *map2));
+
+
+const char *
+_nl_expand_alias (name)
+    const char *name;
+{
+  static const char *locale_alias_path = LOCALE_ALIAS_PATH;
+  struct alias_map *retval;
+  const char *result = NULL;
+  size_t added;
+
+#ifdef _LIBC
+  __libc_lock_lock (lock);
+#endif
+
+  do
+    {
+      struct alias_map item;
+
+      item.alias = name;
+
+      if (nmap > 0)
+	retval = (struct alias_map *) bsearch (&item, map, nmap,
+					       sizeof (struct alias_map),
+					       (int (*) PARAMS ((const void *,
+								 const void *))
+						) alias_compare);
+      else
+	retval = NULL;
+
+      /* We really found an alias.  Return the value.  */
+      if (retval != NULL)
+	{
+	  result = retval->value;
+	  break;
+	}
+
+      /* Perhaps we can find another alias file.  */
+      added = 0;
+      while (added == 0 && locale_alias_path[0] != '\0')
+	{
+	  const char *start;
+
+	  while (locale_alias_path[0] == PATH_SEPARATOR)
+	    ++locale_alias_path;
+	  start = locale_alias_path;
+
+	  while (locale_alias_path[0] != '\0'
+		 && locale_alias_path[0] != PATH_SEPARATOR)
+	    ++locale_alias_path;
+
+	  if (start < locale_alias_path)
+	    added = read_alias_file (start, locale_alias_path - start);
+	}
+    }
+  while (added != 0);
+
+#ifdef _LIBC
+  __libc_lock_unlock (lock);
+#endif
+
+  return result;
+}
+
+
+static size_t
+internal_function
+read_alias_file (fname, fname_len)
+     const char *fname;
+     int fname_len;
+{
+  FILE *fp;
+  char *full_fname;
+  size_t added;
+  static const char aliasfile[] = "/locale.alias";
+
+  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
+#ifdef HAVE_MEMPCPY
+  mempcpy (mempcpy (full_fname, fname, fname_len),
+	   aliasfile, sizeof aliasfile);
+#else
+  memcpy (full_fname, fname, fname_len);
+  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
+#endif
+
+  fp = fopen (full_fname, "r");
+  freea (full_fname);
+  if (fp == NULL)
+    return 0;
+
+  added = 0;
+  while (!feof (fp))
+    {
+      /* It is a reasonable approach to use a fix buffer here because
+	 a) we are only interested in the first two fields
+	 b) these fields must be usable as file names and so must not
+	    be that long
+       */
+      char buf[BUFSIZ];
+      char *alias;
+      char *value;
+      char *cp;
+
+      if (fgets (buf, sizeof buf, fp) == NULL)
+	/* EOF reached.  */
+	break;
+
+      /* Possibly not the whole line fits into the buffer.  Ignore
+	 the rest of the line.  */
+      if (strchr (buf, '\n') == NULL)
+	{
+	  char altbuf[BUFSIZ];
+	  do
+	    if (fgets (altbuf, sizeof altbuf, fp) == NULL)
+	      /* Make sure the inner loop will be left.  The outer loop
+		 will exit at the `feof' test.  */
+	      break;
+	  while (strchr (altbuf, '\n') == NULL);
+	}
+
+      cp = buf;
+      /* Ignore leading white space.  */
+      while (isspace (cp[0]))
+	++cp;
+
+      /* A leading '#' signals a comment line.  */
+      if (cp[0] != '\0' && cp[0] != '#')
+	{
+	  alias = cp++;
+	  while (cp[0] != '\0' && !isspace (cp[0]))
+	    ++cp;
+	  /* Terminate alias name.  */
+	  if (cp[0] != '\0')
+	    *cp++ = '\0';
+
+	  /* Now look for the beginning of the value.  */
+	  while (isspace (cp[0]))
+	    ++cp;
+
+	  if (cp[0] != '\0')
+	    {
+	      size_t alias_len;
+	      size_t value_len;
+
+	      value = cp++;
+	      while (cp[0] != '\0' && !isspace (cp[0]))
+		++cp;
+	      /* Terminate value.  */
+	      if (cp[0] == '\n')
+		{
+		  /* This has to be done to make the following test
+		     for the end of line possible.  We are looking for
+		     the terminating '\n' which do not overwrite here.  */
+		  *cp++ = '\0';
+		  *cp = '\n';
+		}
+	      else if (cp[0] != '\0')
+		*cp++ = '\0';
+
+	      if (nmap >= maxmap)
+		if (__builtin_expect (extend_alias_table (), 0))
+		  return added;
+
+	      alias_len = strlen (alias) + 1;
+	      value_len = strlen (value) + 1;
+
+	      if (string_space_act + alias_len + value_len > string_space_max)
+		{
+		  /* Increase size of memory pool.  */
+		  size_t new_size = (string_space_max
+				     + (alias_len + value_len > 1024
+					? alias_len + value_len : 1024));
+		  char *new_pool = (char *) realloc (string_space, new_size);
+		  if (new_pool == NULL)
+		    return added;
+
+		  if (__builtin_expect (string_space != new_pool, 0))
+		    {
+		      size_t i;
+
+		      for (i = 0; i < nmap; i++)
+			{
+			  map[i].alias += new_pool - string_space;
+			  map[i].value += new_pool - string_space;
+			}
+		    }
+
+		  string_space = new_pool;
+		  string_space_max = new_size;
+		}
+
+	      map[nmap].alias = memcpy (&string_space[string_space_act],
+					alias, alias_len);
+	      string_space_act += alias_len;
+
+	      map[nmap].value = memcpy (&string_space[string_space_act],
+					value, value_len);
+	      string_space_act += value_len;
+
+	      ++nmap;
+	      ++added;
+	    }
+	}
+    }
+
+  /* Should we test for ferror()?  I think we have to silently ignore
+     errors.  --drepper  */
+  fclose (fp);
+
+  if (added > 0)
+    qsort (map, nmap, sizeof (struct alias_map),
+	   (int (*) PARAMS ((const void *, const void *))) alias_compare);
+
+  return added;
+}
+
+
+static int
+extend_alias_table ()
+{
+  size_t new_size;
+  struct alias_map *new_map;
+
+  new_size = maxmap == 0 ? 100 : 2 * maxmap;
+  new_map = (struct alias_map *) realloc (map, (new_size
+						* sizeof (struct alias_map)));
+  if (new_map == NULL)
+    /* Simply don't extend: we don't have any more core.  */
+    return -1;
+
+  map = new_map;
+  maxmap = new_size;
+  return 0;
+}
+
+
+#ifdef _LIBC
+static void __attribute__ ((unused))
+free_mem (void)
+{
+  if (string_space != NULL)
+    free (string_space);
+  if (map != NULL)
+    free (map);
+}
+text_set_element (__libc_subfreeres, free_mem);
+#endif
+
+
+static int
+alias_compare (map1, map2)
+     const struct alias_map *map1;
+     const struct alias_map *map2;
+{
+#if defined _LIBC || defined HAVE_STRCASECMP
+  return strcasecmp (map1->alias, map2->alias);
+#else
+  const unsigned char *p1 = (const unsigned char *) map1->alias;
+  const unsigned char *p2 = (const unsigned char *) map2->alias;
+  unsigned char c1, c2;
+
+  if (p1 == p2)
+    return 0;
+
+  do
+    {
+      /* I know this seems to be odd but the tolower() function in
+	 some systems libc cannot handle nonalpha characters.  */
+      c1 = isupper (*p1) ? tolower (*p1) : *p1;
+      c2 = isupper (*p2) ? tolower (*p2) : *p2;
+      if (c1 == '\0')
+	break;
+      ++p1;
+      ++p2;
+    }
+  while (c1 == c2);
+
+  return c1 - c2;
+#endif
+}
diff -Naur orig/intl/Makefile.in patched/intl/Makefile.in
--- orig/intl/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/Makefile.in	2002-05-30 12:52:13.000000000 +0200
@@ -0,0 +1,312 @@
+# Makefile for directory with message catalog handling in GNU NLS Utilities.
+# Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+PACKAGE = @PACKAGE@
+VERSION = @VERSION@
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+top_builddir = ..
+VPATH = @srcdir@
+
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+transform = @program_transform_name@
+libdir = @libdir@
+includedir = @includedir@
+datadir = @datadir@
+localedir = $(datadir)/locale
+gettextsrcdir = $(datadir)/gettext/intl
+aliaspath = $(localedir)
+subdir = intl
+
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+mkinstalldirs = $(SHELL) `case "$(MKINSTALLDIRS)" in /*) echo "$(MKINSTALLDIRS)" ;; *) echo "$(top_builddir)/$(MKINSTALLDIRS)" ;; esac`
+
+l = @INTL_LIBTOOL_SUFFIX_PREFIX@
+
+AR = ar
+CC = @CC@
+LIBTOOL = @LIBTOOL@
+RANLIB = @RANLIB@
+YACC = @INTLBISON@ -y -d
+YFLAGS = --name-prefix=__gettext
+
+DEFS = -DLOCALEDIR=\"$(localedir)\" -DLOCALE_ALIAS_PATH=\"$(aliaspath)\" \
+-DLIBDIR=\"$(libdir)\" @DEFS@
+CPPFLAGS = @CPPFLAGS@
+CFLAGS = @CFLAGS@
+LDFLAGS = @LDFLAGS@
+
+COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS)
+
+HEADERS = $(COMHDRS) libgnuintl.h libgettext.h loadinfo.h
+COMHDRS = gettext.h gettextP.h hash-string.h
+SOURCES = $(COMSRCS) intl-compat.c
+COMSRCS = bindtextdom.c dcgettext.c dgettext.c gettext.c \
+finddomain.c loadmsgcat.c localealias.c textdomain.c l10nflist.c \
+explodename.c dcigettext.c dcngettext.c dngettext.c ngettext.c plural.y \
+localcharset.c
+OBJECTS = @INTLOBJS@ bindtextdom.$lo dcgettext.$lo dgettext.$lo gettext.$lo \
+finddomain.$lo loadmsgcat.$lo localealias.$lo textdomain.$lo l10nflist.$lo \
+explodename.$lo dcigettext.$lo dcngettext.$lo dngettext.$lo ngettext.$lo \
+plural.$lo localcharset.$lo
+GETTOBJS = intl-compat.$lo
+DISTFILES.common = Makefile.in \
+config.charset locale.alias ref-add.sin ref-del.sin $(HEADERS) $(SOURCES)
+DISTFILES.generated = plural.c
+DISTFILES.normal = VERSION
+DISTFILES.gettext = libintl.glibc
+DISTFILES.obsolete = xopen-msg.sed linux-msg.sed po2tbl.sed.in cat-compat.c
+
+# Libtool's library version information for libintl.
+# Before making a gettext release, the gettext maintainer must change this
+# according to the libtool documentation, section "Library interface versions".
+# Maintainers of other packages that include the intl directory must *not*
+# change these values.
+LTV_CURRENT=1
+LTV_REVISION=1
+LTV_AGE=0
+
+.SUFFIXES:
+.SUFFIXES: .c .y .o .lo .sin .sed
+.c.o:
+	$(COMPILE) $<
+.c.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) $<
+
+.y.c:
+	$(YACC) $(YFLAGS) --output $@ $<
+	rm -f $*.h
+
+.sin.sed:
+	sed -e '/^#/d' -e 's/@''PACKAGE''@/@PACKAGE@/g' $< > t-$@
+	mv t-$@ $@
+
+INCLUDES = -I.. -I. -I$(top_srcdir)/intl
+
+all: all-@USE_INCLUDED_LIBINTL@
+all-yes: libintl.$la libintl.h charset.alias ref-add.sed ref-del.sed
+all-no: all-no-@BUILD_INCLUDED_LIBINTL@
+all-no-yes: libgnuintl.$la
+all-no-no:
+
+libintl.a libgnuintl.a: $(OBJECTS)
+	rm -f $@
+	$(AR) cru $@ $(OBJECTS)
+	$(RANLIB) $@
+
+libintl.la libgnuintl.la: $(OBJECTS)
+	$(LIBTOOL) --mode=link \
+	  $(CC) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS) $(LDFLAGS) -o $@ \
+	  $(OBJECTS) @LIBICONV@ \
+	  -version-info $(LTV_CURRENT):$(LTV_REVISION):$(LTV_AGE) \
+	  -rpath $(libdir) \
+	  -no-undefined
+
+libintl.h: libgnuintl.h
+	cp $(srcdir)/libgnuintl.h libintl.h
+
+charset.alias: config.charset
+	$(SHELL) $(srcdir)/config.charset '@host@' > t-$@
+	mv t-$@ $@
+
+check: all
+
+# This installation goal is only used in GNU gettext.  Packages which
+# only use the library should use install instead.
+
+# We must not install the libintl.h/libintl.a files if we are on a
+# system which has the GNU gettext() function in its C library or in a
+# separate library.
+# If you want to use the one which comes with this version of the
+# package, you have to use `configure --with-included-gettext'.
+install: install-exec install-data
+install-exec: all
+	if test "$(PACKAGE)" = "gettext" \
+	   && test '@INTLOBJS@' = '$(GETTOBJS)'; then \
+	  $(mkinstalldirs) $(DESTDIR)$(libdir) $(DESTDIR)$(includedir); \
+	  $(INSTALL_DATA) libintl.h $(DESTDIR)$(includedir)/libintl.h; \
+	  $(LIBTOOL) --mode=install \
+	    $(INSTALL_DATA) libintl.$la $(DESTDIR)$(libdir)/libintl.$la; \
+	else \
+	  : ; \
+	fi
+	if test '@USE_INCLUDED_LIBINTL@' = yes; then \
+	  $(mkinstalldirs) $(DESTDIR)$(libdir); \
+	  temp=$(DESTDIR)$(libdir)/t-charset.alias; \
+	  dest=$(DESTDIR)$(libdir)/charset.alias; \
+	  if test -f $(DESTDIR)$(libdir)/charset.alias; then \
+	    orig=$(DESTDIR)$(libdir)/charset.alias; \
+	    sed -f ref-add.sed $$orig > $$temp; \
+	    $(INSTALL_DATA) $$temp $$dest; \
+	    rm -f $$temp; \
+	  else \
+	    if test @GLIBC21@ = no; then \
+	      orig=charset.alias; \
+	      sed -f ref-add.sed $$orig > $$temp; \
+	      $(INSTALL_DATA) $$temp $$dest; \
+	      rm -f $$temp; \
+	    fi; \
+	  fi; \
+	  $(mkinstalldirs) $(DESTDIR)$(localedir); \
+	  test -f $(DESTDIR)$(localedir)/locale.alias \
+	    && orig=$(DESTDIR)$(localedir)/locale.alias \
+	    || orig=$(srcdir)/locale.alias; \
+	  temp=$(DESTDIR)$(localedir)/t-locale.alias; \
+	  dest=$(DESTDIR)$(localedir)/locale.alias; \
+	  sed -f ref-add.sed $$orig > $$temp; \
+	  $(INSTALL_DATA) $$temp $$dest; \
+	  rm -f $$temp; \
+	else \
+	  : ; \
+	fi
+install-data: all
+	if test "$(PACKAGE)" = "gettext"; then \
+	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
+	  $(INSTALL_DATA) VERSION $(DESTDIR)$(gettextsrcdir)/VERSION; \
+	  $(INSTALL_DATA) ChangeLog.inst $(DESTDIR)$(gettextsrcdir)/ChangeLog; \
+	  dists="$(DISTFILES.common)"; \
+	  for file in $$dists; do \
+	    $(INSTALL_DATA) $(srcdir)/$$file \
+			    $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	  chmod a+x $(DESTDIR)$(gettextsrcdir)/config.charset; \
+	  dists="$(DISTFILES.generated)"; \
+	  for file in $$dists; do \
+	    if test -f $$file; then dir=.; else dir=$(srcdir); fi; \
+	    $(INSTALL_DATA) $$dir/$$file \
+			    $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	  dists="$(DISTFILES.obsolete)"; \
+	  for file in $$dists; do \
+	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	else \
+	  : ; \
+	fi
+
+# Define this as empty until I found a useful application.
+installcheck:
+
+uninstall:
+	if test "$(PACKAGE)" = "gettext" \
+	   && test '@INTLOBJS@' = '$(GETTOBJS)'; then \
+	  rm -f $(DESTDIR)$(includedir)/libintl.h; \
+	  $(LIBTOOL) --mode=uninstall \
+	    rm -f $(DESTDIR)$(libdir)/libintl.$la; \
+	else \
+	  : ; \
+	fi
+	if test '@USE_INCLUDED_LIBINTL@' = yes; then \
+	  if test -f $(DESTDIR)$(libdir)/charset.alias; then \
+	    temp=$(DESTDIR)$(libdir)/t-charset.alias; \
+	    dest=$(DESTDIR)$(libdir)/charset.alias; \
+	    sed -f ref-del.sed $$dest > $$temp; \
+	    if grep '^# Packages using this file: $$' $$temp > /dev/null; then \
+	      rm -f $$dest; \
+	    else \
+	      $(INSTALL_DATA) $$temp $$dest; \
+	    fi; \
+	    rm -f $$temp; \
+	  fi; \
+	  if test -f $(DESTDIR)$(localedir)/locale.alias; then \
+	    temp=$(DESTDIR)$(localedir)/t-locale.alias; \
+	    dest=$(DESTDIR)$(localedir)/locale.alias; \
+	    sed -f ref-del.sed $$dest > $$temp; \
+	    if grep '^# Packages using this file: $$' $$temp > /dev/null; then \
+	      rm -f $$dest; \
+	    else \
+	      $(INSTALL_DATA) $$temp $$dest; \
+	    fi; \
+	    rm -f $$temp; \
+	  fi; \
+	else \
+	  : ; \
+	fi
+	if test "$(PACKAGE)" = "gettext"; then \
+	  for file in VERSION ChangeLog $(DISTFILES.common) $(DISTFILES.generated); do \
+	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	else \
+	  : ; \
+	fi
+
+info dvi:
+
+$(OBJECTS): ../config.h libgnuintl.h
+bindtextdom.$lo finddomain.$lo loadmsgcat.$lo: gettextP.h gettext.h loadinfo.h
+dcgettext.$lo: gettextP.h gettext.h hash-string.h loadinfo.h
+
+tags: TAGS
+
+TAGS: $(HEADERS) $(SOURCES)
+	here=`pwd`; cd $(srcdir) && etags -o $$here/TAGS $(HEADERS) $(SOURCES)
+
+id: ID
+
+ID: $(HEADERS) $(SOURCES)
+	here=`pwd`; cd $(srcdir) && mkid -f$$here/ID $(HEADERS) $(SOURCES)
+
+
+mostlyclean:
+	rm -f *.a *.la *.o *.lo core core.*
+	rm -f libintl.h charset.alias ref-add.sed ref-del.sed
+	rm -f -r .libs _libs
+
+clean: mostlyclean
+
+distclean: clean
+	rm -f Makefile ID TAGS
+	if test "$(PACKAGE)" = gettext; then \
+	  rm -f ChangeLog.inst $(DISTFILES.normal); \
+	else \
+	  : ; \
+	fi
+
+maintainer-clean: distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+
+# GNU gettext needs not contain the file `VERSION' but contains some
+# other files which should not be distributed in other packages.
+distdir = ../$(PACKAGE)-$(VERSION)/$(subdir)
+dist distdir: Makefile
+	if test "$(PACKAGE)" = gettext; then \
+	  additional="$(DISTFILES.gettext)"; \
+	else \
+	  additional="$(DISTFILES.normal)"; \
+	fi; \
+	$(MAKE) $(DISTFILES.common) $(DISTFILES.generated) $$additional; \
+	for file in ChangeLog $(DISTFILES.common) $(DISTFILES.generated) $$additional; do \
+	  if test -f $$file; then dir=.; else dir=$(srcdir); fi; \
+	  ln $$dir/$$file $(distdir) 2> /dev/null \
+	    || cp -p $$dir/$$file $(distdir); \
+	done
+
+Makefile: Makefile.in ../config.status
+	cd .. \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+# Tell versions [3.59,3.63) of GNU make not to export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur orig/intl/ngettext.c patched/intl/ngettext.c
--- orig/intl/ngettext.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/ngettext.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,67 @@
+/* Implementation of ngettext(3) function.
+   Copyright (C) 1995, 1997, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef _LIBC
+# define __need_NULL
+# include <stddef.h>
+#else
+# include <stdlib.h>		/* Just for NULL.  */
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+#include <locale.h>
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define NGETTEXT __ngettext
+# define DCNGETTEXT __dcngettext
+#else
+# define NGETTEXT ngettext__
+# define DCNGETTEXT dcngettext__
+#endif
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+char *
+NGETTEXT (msgid1, msgid2, n)
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+{
+  return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__ngettext, ngettext);
+#endif
diff -Naur orig/intl/plural.c patched/intl/plural.c
--- orig/intl/plural.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/plural.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,1325 @@
+
+/*  A Bison parser, made from plural.y
+    by GNU Bison version 1.28  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define yyparse __gettextparse
+#define yylex __gettextlex
+#define yyerror __gettexterror
+#define yylval __gettextlval
+#define yychar __gettextchar
+#define yydebug __gettextdebug
+#define yynerrs __gettextnerrs
+#define	EQUOP2	257
+#define	CMPOP2	258
+#define	ADDOP2	259
+#define	MULOP2	260
+#define	NUMBER	261
+
+#line 1 "plural.y"
+
+/* Expression parsing for plural form selection.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+/* The bison generated parser uses alloca.  AIX 3 forces us to put this
+   declaration at the beginning of the file.  The declaration in bison's
+   skeleton file comes too late.  This must come before <config.h>
+   because <config.h> may include arbitrary system headers.  */
+#if defined _AIX && !defined __GNUC__
+ #pragma alloca
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+#include "gettextP.h"
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define FREE_EXPRESSION __gettext_free_exp
+#else
+# define FREE_EXPRESSION gettext_free_exp__
+# define __gettextparse gettextparse__
+#endif
+
+#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
+#define YYPARSE_PARAM	arg
+
+#line 52 "plural.y"
+typedef union {
+  unsigned long int num;
+  enum operator op;
+  struct expression *exp;
+} YYSTYPE;
+#line 58 "plural.y"
+
+/* Prototypes for local functions.  */
+static struct expression *new_exp PARAMS ((int nargs, enum operator op,
+					   struct expression * const *args));
+static inline struct expression *new_exp_0 PARAMS ((enum operator op));
+static inline struct expression *new_exp_1 PARAMS ((enum operator op,
+						   struct expression *right));
+static struct expression *new_exp_2 PARAMS ((enum operator op,
+					     struct expression *left,
+					     struct expression *right));
+static inline struct expression *new_exp_3 PARAMS ((enum operator op,
+						   struct expression *bexp,
+						   struct expression *tbranch,
+						   struct expression *fbranch));
+static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
+static void yyerror PARAMS ((const char *str));
+
+/* Allocation of expressions.  */
+
+static struct expression *
+new_exp (nargs, op, args)
+     int nargs;
+     enum operator op;
+     struct expression * const *args;
+{
+  int i;
+  struct expression *newp;
+
+  /* If any of the argument could not be malloc'ed, just return NULL.  */
+  for (i = nargs - 1; i >= 0; i--)
+    if (args[i] == NULL)
+      goto fail;
+
+  /* Allocate a new expression.  */
+  newp = (struct expression *) malloc (sizeof (*newp));
+  if (newp != NULL)
+    {
+      newp->nargs = nargs;
+      newp->operation = op;
+      for (i = nargs - 1; i >= 0; i--)
+	newp->val.args[i] = args[i];
+      return newp;
+    }
+
+ fail:
+  for (i = nargs - 1; i >= 0; i--)
+    FREE_EXPRESSION (args[i]);
+
+  return NULL;
+}
+
+static inline struct expression *
+new_exp_0 (op)
+     enum operator op;
+{
+  return new_exp (0, op, NULL);
+}
+
+static inline struct expression *
+new_exp_1 (op, right)
+     enum operator op;
+     struct expression *right;
+{
+  struct expression *args[1];
+
+  args[0] = right;
+  return new_exp (1, op, args);
+}
+
+static struct expression *
+new_exp_2 (op, left, right)
+     enum operator op;
+     struct expression *left;
+     struct expression *right;
+{
+  struct expression *args[2];
+
+  args[0] = left;
+  args[1] = right;
+  return new_exp (2, op, args);
+}
+
+static inline struct expression *
+new_exp_3 (op, bexp, tbranch, fbranch)
+     enum operator op;
+     struct expression *bexp;
+     struct expression *tbranch;
+     struct expression *fbranch;
+{
+  struct expression *args[3];
+
+  args[0] = bexp;
+  args[1] = tbranch;
+  args[2] = fbranch;
+  return new_exp (3, op, args);
+}
+
+#include <stdio.h>
+
+#ifndef __cplusplus
+#ifndef __STDC__
+#define const
+#endif
+#endif
+
+
+
+#define	YYFINAL		27
+#define	YYFLAG		-32768
+#define	YYNTBASE	16
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 261 ? yytranslate[x] : 18)
+
+static const char yytranslate[] = {     0,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,    10,     2,     2,     2,     2,     5,     2,    14,
+    15,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,    12,     2,     2,
+     2,     2,     3,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,    13,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     4,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     1,     6,     7,     8,     9,
+    11
+};
+
+#if YYDEBUG != 0
+static const short yyprhs[] = {     0,
+     0,     2,     8,    12,    16,    20,    24,    28,    32,    35,
+    37,    39
+};
+
+static const short yyrhs[] = {    17,
+     0,    17,     3,    17,    12,    17,     0,    17,     4,    17,
+     0,    17,     5,    17,     0,    17,     6,    17,     0,    17,
+     7,    17,     0,    17,     8,    17,     0,    17,     9,    17,
+     0,    10,    17,     0,    13,     0,    11,     0,    14,    17,
+    15,     0
+};
+
+#endif
+
+#if YYDEBUG != 0
+static const short yyrline[] = { 0,
+   177,   185,   189,   193,   197,   201,   205,   209,   213,   217,
+   221,   226
+};
+#endif
+
+
+#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+
+static const char * const yytname[] = {   "$","error","$undefined.","'?'","'|'",
+"'&'","EQUOP2","CMPOP2","ADDOP2","MULOP2","'!'","NUMBER","':'","'n'","'('","')'",
+"start","exp", NULL
+};
+#endif
+
+static const short yyr1[] = {     0,
+    16,    17,    17,    17,    17,    17,    17,    17,    17,    17,
+    17,    17
+};
+
+static const short yyr2[] = {     0,
+     1,     5,     3,     3,     3,     3,     3,     3,     2,     1,
+     1,     3
+};
+
+static const short yydefact[] = {     0,
+     0,    11,    10,     0,     1,     9,     0,     0,     0,     0,
+     0,     0,     0,     0,    12,     0,     3,     4,     5,     6,
+     7,     8,     0,     2,     0,     0,     0
+};
+
+static const short yydefgoto[] = {    25,
+     5
+};
+
+static const short yypact[] = {    -9,
+    -9,-32768,-32768,    -9,    34,-32768,    11,    -9,    -9,    -9,
+    -9,    -9,    -9,    -9,-32768,    24,    39,    43,    16,    26,
+    -3,-32768,    -9,    34,    21,    53,-32768
+};
+
+static const short yypgoto[] = {-32768,
+    -1
+};
+
+
+#define	YYLAST		53
+
+
+static const short yytable[] = {     6,
+     1,     2,     7,     3,     4,    14,    16,    17,    18,    19,
+    20,    21,    22,     8,     9,    10,    11,    12,    13,    14,
+    26,    24,    12,    13,    14,    15,     8,     9,    10,    11,
+    12,    13,    14,    13,    14,    23,     8,     9,    10,    11,
+    12,    13,    14,    10,    11,    12,    13,    14,    11,    12,
+    13,    14,    27
+};
+
+static const short yycheck[] = {     1,
+    10,    11,     4,    13,    14,     9,     8,     9,    10,    11,
+    12,    13,    14,     3,     4,     5,     6,     7,     8,     9,
+     0,    23,     7,     8,     9,    15,     3,     4,     5,     6,
+     7,     8,     9,     8,     9,    12,     3,     4,     5,     6,
+     7,     8,     9,     5,     6,     7,     8,     9,     6,     7,
+     8,     9,     0
+};
+#define YYPURE 1
+
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/home/haible/gnu/arch/linuxlibc6/share/bison.simple"
+/* This file comes from bison-1.28.  */
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
+#ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
+#include <alloca.h>
+#else /* not sparc */
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
+#include <malloc.h>
+#endif
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
+ #pragma alloca
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#endif /* __hpux */
+#endif
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
+
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
+#endif
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    { yychar = (token), yylval = (value);			\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval, &yylloc)
+#endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval)
+#endif
+#endif /* not YYLSP_NEEDED */
+#endif
+
+/* If nonreentrant, generate the variables here */
+
+#ifndef YYPURE
+
+int	yychar;			/*  the lookahead symbol		*/
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+#ifdef YYLSP_NEEDED
+YYLTYPE yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
+
+int yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
+
+#if YYDEBUG != 0
+int yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     unsigned int count;
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#else /* __cplusplus */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (char *to, char *from, unsigned int count)
+{
+  register char *t = to;
+  register char *f = from;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#endif
+#endif
+
+#line 217 "/home/haible/gnu/arch/linuxlibc6/share/bison.simple"
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif /* not YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int yyparse (void *);
+#else
+int yyparse (void);
+#endif
+#endif
+
+int
+yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register YYSTYPE *yyvsp;
+  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  int yystacksize = YYINITDEPTH;
+  int yyfree_stacks = 0;
+
+#ifdef YYPURE
+  int yychar;
+  YYSTYPE yylval;
+  int yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylloc;
+#endif
+#endif
+
+  YYSTYPE yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+  int yylen;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+
+/* Push a new state, which is found in  yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+yynewstate:
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Give user a chance to reallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *yyvs1 = yyvs;
+      short *yyss1 = yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *yyls1 = yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if yyoverflow is a macro.  */
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yyls1, size * sizeof (*yylsp),
+		 &yystacksize);
+#else
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yystacksize);
+#endif
+
+      yyss = yyss1; yyvs = yyvs1;
+#ifdef YYLSP_NEEDED
+      yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	{
+	  yyerror("parser stack overflow");
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
+	  return 2;
+	}
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
+#ifdef YYLSP_NEEDED
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
+#endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + size - 1;
+      yyvsp = yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      yylsp = yyls + size - 1;
+#endif
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Entering state %d\n", yystate);
+#endif
+
+  goto yybackup;
+ yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Reading a token: ");
+#endif
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE(yychar);
+
+#if YYDEBUG != 0
+      if (yydebug)
+	{
+	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+#endif
+	  fprintf (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus) yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+/* Do the default action for the current state.  */
+yydefault:
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+
+/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+yyreduce:
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1-yylen]; /* implement default value of the action */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      int i;
+
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+
+  switch (yyn) {
+
+case 1:
+#line 178 "plural.y"
+{
+	    if (yyvsp[0].exp == NULL)
+	      YYABORT;
+	    ((struct parse_args *) arg)->res = yyvsp[0].exp;
+	  ;
+    break;}
+case 2:
+#line 186 "plural.y"
+{
+	    yyval.exp = new_exp_3 (qmop, yyvsp[-4].exp, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 3:
+#line 190 "plural.y"
+{
+	    yyval.exp = new_exp_2 (lor, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 4:
+#line 194 "plural.y"
+{
+	    yyval.exp = new_exp_2 (land, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 5:
+#line 198 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 6:
+#line 202 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 7:
+#line 206 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 8:
+#line 210 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 9:
+#line 214 "plural.y"
+{
+	    yyval.exp = new_exp_1 (lnot, yyvsp[0].exp);
+	  ;
+    break;}
+case 10:
+#line 218 "plural.y"
+{
+	    yyval.exp = new_exp_0 (var);
+	  ;
+    break;}
+case 11:
+#line 222 "plural.y"
+{
+	    if ((yyval.exp = new_exp_0 (num)) != NULL)
+	      yyval.exp->val.num = yyvsp[0].num;
+	  ;
+    break;}
+case 12:
+#line 227 "plural.y"
+{
+	    yyval.exp = yyvsp[-1].exp;
+	  ;
+    break;}
+}
+   /* the action file gets copied in in place of this dollarsign */
+#line 543 "/home/haible/gnu/arch/linuxlibc6/share/bison.simple"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YYLSP_NEEDED
+  yylsp++;
+  if (yylen == 0)
+    {
+      yylsp->first_line = yylloc.first_line;
+      yylsp->first_column = yylloc.first_column;
+      yylsp->last_line = (yylsp-1)->last_line;
+      yylsp->last_column = (yylsp-1)->last_column;
+      yylsp->text = 0;
+    }
+  else
+    {
+      yylsp->last_line = (yylsp+yylen-1)->last_line;
+      yylsp->last_column = (yylsp+yylen-1)->last_column;
+    }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yyerrlab:   /* here on detecting error */
+
+  if (! yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+	  for (x = (yyn < 0 ? -yyn : 0);
+	       x < (sizeof(yytname) / sizeof(char *)); x++)
+	    if (yycheck[x + yyn] == x)
+	      size += strlen(yytname[x]) + 15, count++;
+	  msg = (char *) malloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (yyn < 0 ? -yyn : 0);
+		       x < (sizeof(yytname) / sizeof(char *)); x++)
+		    if (yycheck[x + yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror("parse error");
+    }
+
+  goto yyerrlab1;
+yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3)
+    {
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
+#endif
+
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) goto yydefault;
+#endif
+
+yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss) YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+yyerrhandle:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 1;
+}
+#line 232 "plural.y"
+
+
+void
+internal_function
+FREE_EXPRESSION (exp)
+     struct expression *exp;
+{
+  if (exp == NULL)
+    return;
+
+  /* Handle the recursive case.  */
+  switch (exp->nargs)
+    {
+    case 3:
+      FREE_EXPRESSION (exp->val.args[2]);
+      /* FALLTHROUGH */
+    case 2:
+      FREE_EXPRESSION (exp->val.args[1]);
+      /* FALLTHROUGH */
+    case 1:
+      FREE_EXPRESSION (exp->val.args[0]);
+      /* FALLTHROUGH */
+    default:
+      break;
+    }
+
+  free (exp);
+}
+
+
+static int
+yylex (lval, pexp)
+     YYSTYPE *lval;
+     const char **pexp;
+{
+  const char *exp = *pexp;
+  int result;
+
+  while (1)
+    {
+      if (exp[0] == '\0')
+	{
+	  *pexp = exp;
+	  return YYEOF;
+	}
+
+      if (exp[0] != ' ' && exp[0] != '\t')
+	break;
+
+      ++exp;
+    }
+
+  result = *exp++;
+  switch (result)
+    {
+    case '0': case '1': case '2': case '3': case '4':
+    case '5': case '6': case '7': case '8': case '9':
+      {
+	unsigned long int n = result - '0';
+	while (exp[0] >= '0' && exp[0] <= '9')
+	  {
+	    n *= 10;
+	    n += exp[0] - '0';
+	    ++exp;
+	  }
+	lval->num = n;
+	result = NUMBER;
+      }
+      break;
+
+    case '=':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = equal;
+	  result = EQUOP2;
+	}
+      else
+	result = YYERRCODE;
+      break;
+
+    case '!':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = not_equal;
+	  result = EQUOP2;
+	}
+      break;
+
+    case '&':
+    case '|':
+      if (exp[0] == result)
+	++exp;
+      else
+	result = YYERRCODE;
+      break;
+
+    case '<':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = less_or_equal;
+	}
+      else
+	lval->op = less_than;
+      result = CMPOP2;
+      break;
+
+    case '>':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = greater_or_equal;
+	}
+      else
+	lval->op = greater_than;
+      result = CMPOP2;
+      break;
+
+    case '*':
+      lval->op = mult;
+      result = MULOP2;
+      break;
+
+    case '/':
+      lval->op = divide;
+      result = MULOP2;
+      break;
+
+    case '%':
+      lval->op = module;
+      result = MULOP2;
+      break;
+
+    case '+':
+      lval->op = plus;
+      result = ADDOP2;
+      break;
+
+    case '-':
+      lval->op = minus;
+      result = ADDOP2;
+      break;
+
+    case 'n':
+    case '?':
+    case ':':
+    case '(':
+    case ')':
+      /* Nothing, just return the character.  */
+      break;
+
+    case ';':
+    case '\n':
+    case '\0':
+      /* Be safe and let the user call this function again.  */
+      --exp;
+      result = YYEOF;
+      break;
+
+    default:
+      result = YYERRCODE;
+#if YYDEBUG != 0
+      --exp;
+#endif
+      break;
+    }
+
+  *pexp = exp;
+
+  return result;
+}
+
+
+static void
+yyerror (str)
+     const char *str;
+{
+  /* Do nothing.  We don't print error messages here.  */
+}
diff -Naur orig/intl/plural.y patched/intl/plural.y
--- orig/intl/plural.y	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/plural.y	2002-05-30 12:52:00.000000000 +0200
@@ -0,0 +1,412 @@
+%{
+/* Expression parsing for plural form selection.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* The bison generated parser uses alloca.  AIX 3 forces us to put this
+   declaration at the beginning of the file.  The declaration in bison's
+   skeleton file comes too late.  This must come before <config.h>
+   because <config.h> may include arbitrary system headers.  */
+#if defined _AIX && !defined __GNUC__
+ #pragma alloca
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+#include "gettextP.h"
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define FREE_EXPRESSION __gettext_free_exp
+#else
+# define FREE_EXPRESSION gettext_free_exp__
+# define __gettextparse gettextparse__
+#endif
+
+#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
+#define YYPARSE_PARAM	arg
+%}
+%pure_parser
+%expect 10
+
+%union {
+  unsigned long int num;
+  enum operator op;
+  struct expression *exp;
+}
+
+%{
+/* Prototypes for local functions.  */
+static struct expression *new_exp PARAMS ((int nargs, enum operator op,
+					   struct expression * const *args));
+static inline struct expression *new_exp_0 PARAMS ((enum operator op));
+static inline struct expression *new_exp_1 PARAMS ((enum operator op,
+						   struct expression *right));
+static struct expression *new_exp_2 PARAMS ((enum operator op,
+					     struct expression *left,
+					     struct expression *right));
+static inline struct expression *new_exp_3 PARAMS ((enum operator op,
+						   struct expression *bexp,
+						   struct expression *tbranch,
+						   struct expression *fbranch));
+static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
+static void yyerror PARAMS ((const char *str));
+
+/* Allocation of expressions.  */
+
+static struct expression *
+new_exp (nargs, op, args)
+     int nargs;
+     enum operator op;
+     struct expression * const *args;
+{
+  int i;
+  struct expression *newp;
+
+  /* If any of the argument could not be malloc'ed, just return NULL.  */
+  for (i = nargs - 1; i >= 0; i--)
+    if (args[i] == NULL)
+      goto fail;
+
+  /* Allocate a new expression.  */
+  newp = (struct expression *) malloc (sizeof (*newp));
+  if (newp != NULL)
+    {
+      newp->nargs = nargs;
+      newp->operation = op;
+      for (i = nargs - 1; i >= 0; i--)
+	newp->val.args[i] = args[i];
+      return newp;
+    }
+
+ fail:
+  for (i = nargs - 1; i >= 0; i--)
+    FREE_EXPRESSION (args[i]);
+
+  return NULL;
+}
+
+static inline struct expression *
+new_exp_0 (op)
+     enum operator op;
+{
+  return new_exp (0, op, NULL);
+}
+
+static inline struct expression *
+new_exp_1 (op, right)
+     enum operator op;
+     struct expression *right;
+{
+  struct expression *args[1];
+
+  args[0] = right;
+  return new_exp (1, op, args);
+}
+
+static struct expression *
+new_exp_2 (op, left, right)
+     enum operator op;
+     struct expression *left;
+     struct expression *right;
+{
+  struct expression *args[2];
+
+  args[0] = left;
+  args[1] = right;
+  return new_exp (2, op, args);
+}
+
+static inline struct expression *
+new_exp_3 (op, bexp, tbranch, fbranch)
+     enum operator op;
+     struct expression *bexp;
+     struct expression *tbranch;
+     struct expression *fbranch;
+{
+  struct expression *args[3];
+
+  args[0] = bexp;
+  args[1] = tbranch;
+  args[2] = fbranch;
+  return new_exp (3, op, args);
+}
+
+%}
+
+/* This declares that all operators have the same associativity and the
+   precedence order as in C.  See [Harbison, Steele: C, A Reference Manual].
+   There is no unary minus and no bitwise operators.
+   Operators with the same syntactic behaviour have been merged into a single
+   token, to save space in the array generated by bison.  */
+%right '?'		/*   ?		*/
+%left '|'		/*   ||		*/
+%left '&'		/*   &&		*/
+%left EQUOP2		/*   == !=	*/
+%left CMPOP2		/*   < > <= >=	*/
+%left ADDOP2		/*   + -	*/
+%left MULOP2		/*   * / %	*/
+%right '!'		/*   !		*/
+
+%token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2
+%token <num> NUMBER
+%type <exp> exp
+
+%%
+
+start:	  exp
+	  {
+	    if ($1 == NULL)
+	      YYABORT;
+	    ((struct parse_args *) arg)->res = $1;
+	  }
+	;
+
+exp:	  exp '?' exp ':' exp
+	  {
+	    $$ = new_exp_3 (qmop, $1, $3, $5);
+	  }
+	| exp '|' exp
+	  {
+	    $$ = new_exp_2 (lor, $1, $3);
+	  }
+	| exp '&' exp
+	  {
+	    $$ = new_exp_2 (land, $1, $3);
+	  }
+	| exp EQUOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp CMPOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp ADDOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp MULOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| '!' exp
+	  {
+	    $$ = new_exp_1 (lnot, $2);
+	  }
+	| 'n'
+	  {
+	    $$ = new_exp_0 (var);
+	  }
+	| NUMBER
+	  {
+	    if (($$ = new_exp_0 (num)) != NULL)
+	      $$->val.num = $1;
+	  }
+	| '(' exp ')'
+	  {
+	    $$ = $2;
+	  }
+	;
+
+%%
+
+void
+internal_function
+FREE_EXPRESSION (exp)
+     struct expression *exp;
+{
+  if (exp == NULL)
+    return;
+
+  /* Handle the recursive case.  */
+  switch (exp->nargs)
+    {
+    case 3:
+      FREE_EXPRESSION (exp->val.args[2]);
+      /* FALLTHROUGH */
+    case 2:
+      FREE_EXPRESSION (exp->val.args[1]);
+      /* FALLTHROUGH */
+    case 1:
+      FREE_EXPRESSION (exp->val.args[0]);
+      /* FALLTHROUGH */
+    default:
+      break;
+    }
+
+  free (exp);
+}
+
+
+static int
+yylex (lval, pexp)
+     YYSTYPE *lval;
+     const char **pexp;
+{
+  const char *exp = *pexp;
+  int result;
+
+  while (1)
+    {
+      if (exp[0] == '\0')
+	{
+	  *pexp = exp;
+	  return YYEOF;
+	}
+
+      if (exp[0] != ' ' && exp[0] != '\t')
+	break;
+
+      ++exp;
+    }
+
+  result = *exp++;
+  switch (result)
+    {
+    case '0': case '1': case '2': case '3': case '4':
+    case '5': case '6': case '7': case '8': case '9':
+      {
+	unsigned long int n = result - '0';
+	while (exp[0] >= '0' && exp[0] <= '9')
+	  {
+	    n *= 10;
+	    n += exp[0] - '0';
+	    ++exp;
+	  }
+	lval->num = n;
+	result = NUMBER;
+      }
+      break;
+
+    case '=':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = equal;
+	  result = EQUOP2;
+	}
+      else
+	result = YYERRCODE;
+      break;
+
+    case '!':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = not_equal;
+	  result = EQUOP2;
+	}
+      break;
+
+    case '&':
+    case '|':
+      if (exp[0] == result)
+	++exp;
+      else
+	result = YYERRCODE;
+      break;
+
+    case '<':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = less_or_equal;
+	}
+      else
+	lval->op = less_than;
+      result = CMPOP2;
+      break;
+
+    case '>':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = greater_or_equal;
+	}
+      else
+	lval->op = greater_than;
+      result = CMPOP2;
+      break;
+
+    case '*':
+      lval->op = mult;
+      result = MULOP2;
+      break;
+
+    case '/':
+      lval->op = divide;
+      result = MULOP2;
+      break;
+
+    case '%':
+      lval->op = module;
+      result = MULOP2;
+      break;
+
+    case '+':
+      lval->op = plus;
+      result = ADDOP2;
+      break;
+
+    case '-':
+      lval->op = minus;
+      result = ADDOP2;
+      break;
+
+    case 'n':
+    case '?':
+    case ':':
+    case '(':
+    case ')':
+      /* Nothing, just return the character.  */
+      break;
+
+    case ';':
+    case '\n':
+    case '\0':
+      /* Be safe and let the user call this function again.  */
+      --exp;
+      result = YYEOF;
+      break;
+
+    default:
+      result = YYERRCODE;
+#if YYDEBUG != 0
+      --exp;
+#endif
+      break;
+    }
+
+  *pexp = exp;
+
+  return result;
+}
+
+
+static void
+yyerror (str)
+     const char *str;
+{
+  /* Do nothing.  We don't print error messages here.  */
+}
diff -Naur orig/intl/ref-add.sin patched/intl/ref-add.sin
--- orig/intl/ref-add.sin	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/ref-add.sin	2002-05-30 12:52:20.000000000 +0200
@@ -0,0 +1,31 @@
+# Add this package to a list of references stored in a text file.
+#
+#   Copyright (C) 2000 Free Software Foundation, Inc.
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU Library General Public License as published
+#   by the Free Software Foundation; either version 2, or (at your option)
+#   any later version.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Library General Public License for more details.
+#
+#   You should have received a copy of the GNU Library General Public
+#   License along with this program; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+#   USA.
+#
+# Written by Bruno Haible <haible@clisp.cons.org>.
+#
+/^# Packages using this file: / {
+  s/# Packages using this file://
+  ta
+  :a
+  s/ @PACKAGE@ / @PACKAGE@ /
+  tb
+  s/ $/ @PACKAGE@ /
+  :b
+  s/^/# Packages using this file:/
+}
diff -Naur orig/intl/ref-del.sin patched/intl/ref-del.sin
--- orig/intl/ref-del.sin	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/ref-del.sin	2002-05-30 12:52:04.000000000 +0200
@@ -0,0 +1,26 @@
+# Remove this package from a list of references stored in a text file.
+#
+#   Copyright (C) 2000 Free Software Foundation, Inc.
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU Library General Public License as published
+#   by the Free Software Foundation; either version 2, or (at your option)
+#   any later version.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Library General Public License for more details.
+#
+#   You should have received a copy of the GNU Library General Public
+#   License along with this program; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+#   USA.
+#
+# Written by Bruno Haible <haible@clisp.cons.org>.
+#
+/^# Packages using this file: / {
+  s/# Packages using this file://
+  s/ @PACKAGE@ / /
+  s/^/# Packages using this file:/
+}
diff -Naur orig/intl/textdomain.c patched/intl/textdomain.c
--- orig/intl/textdomain.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/textdomain.c	2014-01-19 16:07:14.000000000 +0100
@@ -0,0 +1,141 @@
+/* Implementation of the textdomain(3) function.
+   Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+#include "gettextP.h"
+
+#ifdef _LIBC
+/* We have to handle multi-threaded applications.  */
+# include <bits/libc-lock.h>
+#else
+/* Provide dummy implementation if this is outside glibc.  */
+# define __libc_rwlock_define(CLASS, NAME)
+# define __libc_rwlock_wrlock(NAME)
+# define __libc_rwlock_unlock(NAME)
+#endif
+
+/* The internal variables in the standalone libintl.a must have different
+   names than the internal variables in GNU libc, otherwise programs
+   using libintl.a cannot be linked statically.  */
+#if !defined _LIBC
+# define _nl_default_default_domain _nl_default_default_domain__
+# define _nl_current_default_domain _nl_current_default_domain__
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Name of the default text domain.  */
+extern const char _nl_default_default_domain[];
+
+/* Default text domain in which entries for gettext(3) are to be found.  */
+extern const char *_nl_current_default_domain;
+
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define TEXTDOMAIN __textdomain
+# ifndef strdup
+#  define strdup(str) __strdup (str)
+# endif
+#else
+# define TEXTDOMAIN textdomain__
+#endif
+
+/* Lock variable to protect the global data in the gettext implementation.  */
+__libc_rwlock_define (extern, _nl_state_lock)
+
+/* Set the current default message catalog to DOMAINNAME.
+   If DOMAINNAME is null, return the current default.
+   If DOMAINNAME is "", reset to the default of "messages".  */
+char *
+TEXTDOMAIN (domainname)
+     const char *domainname;
+{
+  char *new_domain;
+  char *old_domain;
+
+  /* A NULL pointer requests the current setting.  */
+  if (domainname == NULL)
+    return (char *) _nl_current_default_domain;
+
+  __libc_rwlock_wrlock (_nl_state_lock);
+
+  old_domain = (char *) _nl_current_default_domain;
+
+  /* If domain name is the null string set to default domain "messages".  */
+  if (domainname[0] == '\0'
+      || strcmp (domainname, _nl_default_default_domain) == 0)
+    {
+      _nl_current_default_domain = _nl_default_default_domain;
+      new_domain = (char *) _nl_current_default_domain;
+    }
+  else if (strcmp (domainname, old_domain) == 0)
+    /* This can happen and people will use it to signal that some
+       environment variable changed.  */
+    new_domain = old_domain;
+  else
+    {
+      /* If the following malloc fails `_nl_current_default_domain'
+	 will be NULL.  This value will be returned and so signals we
+	 are out of core.  */
+#if defined _LIBC || defined HAVE_STRDUP
+      new_domain = strdup (domainname);
+#else
+      size_t len = strlen (domainname) + 1;
+      new_domain = (char *) malloc (len);
+      if (new_domain != NULL)
+	memcpy (new_domain, domainname, len);
+#endif
+
+      if (new_domain != NULL)
+	_nl_current_default_domain = new_domain;
+    }
+
+  /* We use this possibility to signal a change of the loaded catalogs
+     since this is most likely the case and there is no other easy we
+     to do it.  Do it only when the call was successful.  */
+  if (new_domain != NULL)
+    {
+      ++_nl_msg_cat_cntr;
+
+      if (old_domain != new_domain && old_domain != _nl_default_default_domain)
+	free (old_domain);
+    }
+
+  __libc_rwlock_unlock (_nl_state_lock);
+
+  return new_domain;
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__textdomain, textdomain);
+#endif
diff -Naur orig/intl/VERSION patched/intl/VERSION
--- orig/intl/VERSION	1970-01-01 01:00:00.000000000 +0100
+++ patched/intl/VERSION	2002-05-30 12:52:14.000000000 +0200
@@ -0,0 +1 @@
+GNU gettext library from gettext-0.10.39
diff -Naur orig/invoke_xgettext patched/invoke_xgettext
--- orig/invoke_xgettext	1970-01-01 01:00:00.000000000 +0100
+++ patched/invoke_xgettext	2012-03-28 21:14:13.000000000 +0200
@@ -0,0 +1,13 @@
+#!/bin/bash
+xgettext \
+    src/main.c \
+    src/configuration/*.c \
+    src/disc_and_drive/*c \
+    src/external_tools/*.c \
+    src/native_file_system/*.c \
+    src/optical_file_systems/*.c \
+    src/tasks/*.c \
+    src/user_interface/*.c \
+    src/user_interface/widgets/*.c \
+    src/utilities/*.c \
+    --no-wrap --keyword=_ --keyword=gettext_noop --add-comments=2TRANS: -o po/cdw.pot
diff -Naur orig/Makefile.am patched/Makefile.am
--- orig/Makefile.am	2011-02-04 21:40:46.000000000 +0100
+++ patched/Makefile.am	2014-01-19 21:00:10.000000000 +0100
@@ -16,5 +16,6 @@
 EXTRA_DIST = $(top_srcdir)/Makefile.cdw.am \
 	$(top_srcdir)/cdw.conf \
 	$(top_srcdir)/cdw.colors \
-	$(top_srcdir)/TODO
+	$(top_srcdir)/TODO \
+	$(top_srcdir)/src/config_cdw_undefine.h
 
diff -Naur orig/Makefile.in patched/Makefile.in
--- orig/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/Makefile.in	2014-01-19 21:00:49.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -22,6 +21,51 @@
 # http://mij.oltrelinux.com/devel/autoconf-automake/
 #
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -39,11 +83,11 @@
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 subdir = .
-DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in $(srcdir)/config.h.in \
-	$(top_srcdir)/configure ABOUT-NLS AUTHORS COPYING ChangeLog \
-	INSTALL NEWS THANKS TODO compile config.rpath depcomp \
-	install-sh missing
+DIST_COMMON = INSTALL NEWS README AUTHORS ChangeLog \
+	$(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/configure $(am__configure_deps) \
+	$(srcdir)/config_cdw.h.in ABOUT-NLS COPYING THANKS TODO \
+	compile config.rpath depcomp install-sh missing
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
@@ -51,25 +95,65 @@
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
  configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = config.h
+CONFIG_HEADER = config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 SOURCES =
 DIST_SOURCES =
-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
-	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
-AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
-	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
-	distdir dist dist-all distcheck
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
+	cscope distdir dist dist-all distcheck
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) \
+	$(LISP)config_cdw.h.in
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+CSCOPE = cscope
 DIST_SUBDIRS = $(SUBDIRS)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
@@ -80,6 +164,7 @@
       && rm -rf "$(distdir)" \
       || { sleep 5 && rm -rf "$(distdir)"; }; \
   else :; fi
+am__post_remove_distdir = $(am__remove_distdir)
 am__relativize = \
   dir0=`pwd`; \
   sed_first='s,^\([^/]*\)/.*$$,\1,'; \
@@ -107,6 +192,7 @@
   reldir="$$dir2"
 DIST_ARCHIVES = $(distdir).tar.gz
 GZIP_ENV = --best
+DIST_TARGETS = dist-gzip
 distuninstallcheck_listfiles = find . -type f -print
 am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \
   | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
@@ -114,6 +200,7 @@
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -214,9 +301,10 @@
 EXTRA_DIST = $(top_srcdir)/Makefile.cdw.am \
 	$(top_srcdir)/cdw.conf \
 	$(top_srcdir)/cdw.colors \
-	$(top_srcdir)/TODO
+	$(top_srcdir)/TODO \
+	$(top_srcdir)/src/config_cdw_undefine.h
 
-all: config.h
+all: config_cdw.h
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
 .SUFFIXES:
@@ -255,38 +343,41 @@
 	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
 $(am__aclocal_m4_deps):
 
-config.h: stamp-h1
-	@if test ! -f $@; then rm -f stamp-h1; else :; fi
-	@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi
+config_cdw.h: stamp-h1
+	@test -f $@ || rm -f stamp-h1
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) stamp-h1
 
-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+stamp-h1: $(srcdir)/config_cdw.h.in $(top_builddir)/config.status
 	@rm -f stamp-h1
-	cd $(top_builddir) && $(SHELL) ./config.status config.h
-$(srcdir)/config.h.in:  $(am__configure_deps) 
+	cd $(top_builddir) && $(SHELL) ./config.status config_cdw.h
+$(srcdir)/config_cdw.h.in:  $(am__configure_deps) 
 	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
 	rm -f stamp-h1
 	touch $@
 
 distclean-hdr:
-	-rm -f config.h stamp-h1
+	-rm -f config_cdw.h stamp-h1
 
 # This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
 	  echo "Making $$target in $$subdir"; \
 	  if test "$$subdir" = "."; then \
 	    dot_seen=yes; \
@@ -301,57 +392,12 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test "$$subdir" = "."; then :; else \
-	    rev="$$subdir $$rev"; \
-	  fi; \
-	done; \
-	rev="$$rev ."; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done && test -z "$$fail"
-tags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
-	done
-ctags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
-	done
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
 
-TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
 	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
@@ -367,12 +413,7 @@
 	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
-	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -384,15 +425,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -401,9 +438,31 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscope: cscope.files
+	test ! -s cscope.files \
+	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
+clean-cscope:
+	-rm -f cscope.files
+cscope.files: clean-cscope cscopelist
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
 
 distdir: $(DISTFILES)
 	$(am__remove_distdir)
@@ -439,13 +498,10 @@
 	done
 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
 	    $(am__relativize); \
 	    new_distdir=$$reldir; \
@@ -474,40 +530,42 @@
 	|| chmod -R a+r "$(distdir)"
 dist-gzip: distdir
 	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-bzip2: distdir
 	tardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-lzip: distdir
 	tardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz
-	$(am__remove_distdir)
-
-dist-lzma: distdir
-	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-xz: distdir
 	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-tarZ: distdir
+	@echo WARNING: "Support for shar distribution archives is" \
+	               "deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
 	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-shar: distdir
+	@echo WARNING: "Support for distribution archives compressed with" \
+		       "legacy program 'compress' is deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
 	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-zip: distdir
 	-rm -f $(distdir).zip
 	zip -rq $(distdir).zip $(distdir)
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
-dist dist-all: distdir
-	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
-	$(am__remove_distdir)
+dist dist-all:
+	$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'
+	$(am__post_remove_distdir)
 
 # This target untars the dist file and tries a VPATH configuration.  Then
 # it guarantees that the distribution is self-contained by making another
@@ -518,8 +576,6 @@
 	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
 	*.tar.bz2*) \
 	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
-	*.tar.lzma*) \
-	  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\
 	*.tar.lz*) \
 	  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\
 	*.tar.xz*) \
@@ -531,18 +587,19 @@
 	*.zip*) \
 	  unzip $(distdir).zip ;;\
 	esac
-	chmod -R a-w $(distdir); chmod a+w $(distdir)
-	mkdir $(distdir)/_build
-	mkdir $(distdir)/_inst
+	chmod -R a-w $(distdir)
+	chmod u+w $(distdir)
+	mkdir $(distdir)/_build $(distdir)/_inst
 	chmod a-w $(distdir)
 	test -d $(distdir)/_build || exit 0; \
 	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
 	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
 	  && am__cwd=`pwd` \
 	  && $(am__cd) $(distdir)/_build \
-	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	  && ../configure \
 	    $(AM_DISTCHECK_CONFIGURE_FLAGS) \
 	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	    --srcdir=.. --prefix="$$dc_install_base" \
 	  && $(MAKE) $(AM_MAKEFLAGS) \
 	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
 	  && $(MAKE) $(AM_MAKEFLAGS) check \
@@ -565,7 +622,7 @@
 	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
 	  && cd "$$am__cwd" \
 	  || exit 1
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 	@(echo "$(distdir) archives ready for distribution: "; \
 	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
 	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
@@ -597,7 +654,7 @@
 	       exit 1; } >&2
 check-am: all-am
 check: check-recursive
-all-am: Makefile config.h
+all-am: Makefile config_cdw.h
 installdirs: installdirs-recursive
 installdirs-am:
 install: install-recursive
@@ -699,13 +756,12 @@
 
 uninstall-am:
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all \
-	ctags-recursive install-am install-strip tags-recursive
+.MAKE: $(am__recursive_targets) all install-am install-strip
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am am--refresh check check-am clean clean-generic \
-	ctags ctags-recursive dist dist-all dist-bzip2 dist-gzip \
-	dist-lzip dist-lzma dist-shar dist-tarZ dist-xz dist-zip \
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am \
+	am--refresh check check-am clean clean-cscope clean-generic \
+	cscope cscopelist-am ctags ctags-am dist dist-all dist-bzip2 \
+	dist-gzip dist-lzip dist-shar dist-tarZ dist-xz dist-zip \
 	distcheck distclean distclean-generic distclean-hdr \
 	distclean-tags distcleancheck distdir distuninstallcheck dvi \
 	dvi-am html html-am info info-am install install-am \
@@ -715,8 +771,8 @@
 	install-pdf-am install-ps install-ps-am install-strip \
 	installcheck installcheck-am installdirs installdirs-am \
 	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-generic pdf pdf-am ps ps-am tags tags-recursive \
-	uninstall uninstall-am
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
diff -Naur orig/man/cdw.t2t patched/man/cdw.t2t
--- orig/man/cdw.t2t	2012-03-30 22:16:51.000000000 +0200
+++ patched/man/cdw.t2t	2014-02-14 23:06:45.000000000 +0100
@@ -303,14 +303,14 @@
       dvd+rw-mediainfo, xorriso). Specifying this path is obligatory.
     - Show log after actions - show the content of log file after some of
       actions performed by cdw.
-    - ISO volume size - size of ISO filesystem that you want to
-      create. Most often it is equal to capacity of optical disc that you
-      want burn data to. This is a dropdown, from which you can select one
-      of preselected values, or select "Custom value". This custom value can
-      be entered below the dropdown.
-    - Custom ISO volume size - size of ISO filesystem that you want to create.
-      This is the place where you can enter nonstandard value of target ISO
-      filesystem size.
+    - Volume size - size of ISO/UDF filesystem that you want to
+      create. Most often it is equal to capacity of optical disc that
+      you want burn data to. This is a dropdown, from which you can
+      select one of preselected values, or select "Custom value". This
+      custom value can be entered below the dropdown.
+    - Custom volume size - size of ISO/UDF filesystem that you want to
+      create.  This is the place where you can enter nonstandard value
+      of target ISO/UDF filesystem size.
 
  - Tools (second tab):
       First thing that you will see in this tab "Configure tools manually"
diff -Naur orig/man/Makefile.in patched/man/Makefile.in
--- orig/man/Makefile.in	2012-02-26 15:53:40.000000000 +0100
+++ patched/man/Makefile.in	2014-01-19 20:51:28.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +14,51 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,17 +76,34 @@
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 subdir = man
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 SOURCES =
 DIST_SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -74,10 +135,12 @@
 am__installdirs = "$(DESTDIR)$(man1dir)"
 NROFF = nroff
 MANS = $(man_MANS)
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -208,11 +271,18 @@
 $(am__aclocal_m4_deps):
 install-man1: $(man_MANS)
 	@$(NORMAL_INSTALL)
-	test -z "$(man1dir)" || $(MKDIR_P) "$(DESTDIR)$(man1dir)"
-	@list=''; test -n "$(man1dir)" || exit 0; \
-	{ for i in $$list; do echo "$$i"; done; \
-	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
-	  sed -n '/\.1[a-z]*$$/p'; \
+	@list1=''; \
+	list2='$(man_MANS)'; \
+	test -n "$(man1dir)" \
+	  && test -n "`echo $$list1$$list2`" \
+	  || exit 0; \
+	echo " $(MKDIR_P) '$(DESTDIR)$(man1dir)'"; \
+	$(MKDIR_P) "$(DESTDIR)$(man1dir)" || exit 1; \
+	{ for i in $$list1; do echo "$$i"; done;  \
+	if test -n "$$list2"; then \
+	  for i in $$list2; do echo "$$i"; done \
+	    | sed -n '/\.1[a-z]*$$/p'; \
+	fi; \
 	} | while read p; do \
 	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; echo "$$p"; \
@@ -242,27 +312,14 @@
 	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^1][0-9a-z]*$$,1,;x' \
 	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
 	dir='$(DESTDIR)$(man1dir)'; $(am__uninstall_files_from_dir)
-tags: TAGS
-TAGS:
+tags TAGS:
+
+ctags CTAGS:
 
-ctags: CTAGS
-CTAGS:
+cscope cscopelist:
 
 
 distdir: $(DISTFILES)
-	@list='$(MANS)'; if test -n "$$list"; then \
-	  list=`for p in $$list; do \
-	    if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
-	    if test -f "$$d$$p"; then echo "$$d$$p"; else :; fi; done`; \
-	  if test -n "$$list" && \
-	    grep 'ab help2man is required to generate this page' $$list >/dev/null; then \
-	    echo "error: found man pages containing the \`missing help2man' replacement text:" >&2; \
-	    grep -l 'ab help2man is required to generate this page' $$list | sed 's/^/         /' >&2; \
-	    echo "       to fix them, install help2man, remove and regenerate the man pages;" >&2; \
-	    echo "       typically \`make maintainer-clean' will remove them" >&2; \
-	    exit 1; \
-	  else :; fi; \
-	else :; fi
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -399,16 +456,17 @@
 
 .MAKE: install-am install-strip
 
-.PHONY: all all-am check check-am clean clean-generic distclean \
-	distclean-generic distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-man1 install-pdf install-pdf-am install-ps \
-	install-ps-am install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic pdf pdf-am ps ps-am uninstall \
-	uninstall-am uninstall-man uninstall-man1
+.PHONY: all all-am check check-am clean clean-generic cscopelist-am \
+	ctags-am distclean distclean-generic distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-man1 install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
+	pdf-am ps ps-am tags-am uninstall uninstall-am uninstall-man \
+	uninstall-man1
 
 
 # each line of shell script in Makefile will be treated as separate
diff -Naur orig/po/cdw.pot patched/po/cdw.pot
--- orig/po/cdw.pot	1970-01-01 01:00:00.000000000 +0100
+++ patched/po/cdw.pot	2012-03-30 22:43:40.000000000 +0200
@@ -0,0 +1,3960 @@
+# pot file for cdw 0.7.1
+# Copyright (C) 2007-2012 Kamil Ignacak
+# This file is distributed under the same license as the cdw package.
+# Kamil Ignacak acerion@wp.pl, 2012.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: cdw 0.7.1\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2012-03-30 22:18+0200\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=CHARSET\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. 2TRANS: this is title of dialog window
+#. 2TRANS: this is the title of dialog window
+#. 2TRANS: this is the title of the dialog window
+#. 2TRANS: this is title of dialog window
+#: src/main.c:127 src/main.c:177 src/main.c:189 src/main.c:197 src/main.c:212
+#: src/main.c:226 src/configuration/cdw_config_window.c:113
+#: src/configuration/cdw_config_window.c:458 src/disc_and_drive/cdw_disc.c:328
+#: src/disc_and_drive/cdw_disc.c:619 src/disc_and_drive/cdw_disc.c:702
+#: src/disc_and_drive/cdw_drive.c:585 src/disc_and_drive/cdw_drive.c:607
+#: src/external_tools/cdw_cdrecord.c:243 src/external_tools/cdw_cdrecord.c:432
+#: src/external_tools/cdw_cdrecord.c:531
+#: src/external_tools/cdw_dvd_rw_mediainfo.c:54
+#: src/external_tools/cdw_ext_tools.c:713
+#: src/external_tools/cdw_ext_tools.c:722
+#: src/external_tools/cdw_ext_tools.c:1008
+#: src/native_file_system/cdw_file_manager.c:960
+#: src/native_file_system/cdw_fs_browser.c:584
+#: src/native_file_system/cdw_fs.c:408 src/native_file_system/cdw_fs.c:639
+#: src/native_file_system/cdw_fs.c:666 src/native_file_system/cdw_fs.c:1401
+#: src/native_file_system/cdw_fs.c:1411 src/native_file_system/cdw_fs.c:1417
+#: src/native_file_system/cdw_fs.c:1425 src/native_file_system/cdw_fs.c:1431
+#: src/native_file_system/cdw_fs.c:1439 src/native_file_system/cdw_fs.c:1447
+#: src/native_file_system/cdw_fs.c:1456 src/native_file_system/cdw_fs.c:1464
+#: src/native_file_system/cdw_fs.c:1471 src/native_file_system/cdw_fs.c:1478
+#: src/native_file_system/cdw_fs.c:1484 src/native_file_system/cdw_fs.c:1490
+#: src/native_file_system/cdw_fs.c:1496 src/native_file_system/cdw_fs.c:1504
+#: src/native_file_system/cdw_fs.c:1511
+#: src/optical_file_systems/cdw_iso9660.c:101 src/tasks/cdw_burn_disc.c:137
+#: src/tasks/cdw_burn_disc.c:456 src/tasks/cdw_burn_disc.c:469
+#: src/tasks/cdw_burn_disc.c:482 src/tasks/cdw_burn_disc.c:493
+#: src/tasks/cdw_calculate_digest.c:81 src/tasks/cdw_calculate_digest.c:148
+#: src/tasks/cdw_calculate_digest.c:156 src/tasks/cdw_calculate_digest.c:295
+#: src/tasks/cdw_calculate_digest.c:350 src/tasks/cdw_calculate_digest.c:363
+#: src/tasks/cdw_calculate_digest.c:384 src/tasks/cdw_calculate_digest.c:463
+#: src/tasks/cdw_calculate_digest.c:635 src/tasks/cdw_create_image.c:119
+#: src/tasks/cdw_erase_disc.c:99 src/tasks/cdw_erase_disc.c:255
+#: src/tasks/cdw_erase_disc.c:271 src/tasks/cdw_read_disc.c:150
+#: src/tasks/cdw_read_disc.c:201 src/tasks/cdw_read_disc_info.c:58
+#: src/tasks/cdw_read_disc_info.c:86 src/tasks/cdw_read_disc_info.c:102
+#: src/tasks/cdw_read_disc_info.c:118 src/tasks/cdw_read_disc_info.c:176
+#: src/tasks/cdw_read_disc_info.c:195 src/tasks/cdw_read_disc_info.c:205
+#: src/tasks/cdw_task.c:618 src/tasks/cdw_task.c:1056
+#: src/user_interface/cdw_iso9660_wizard.c:212
+#: src/user_interface/cdw_iso9660_wizard.c:696
+#: src/user_interface/cdw_main_window.c:769
+#: src/user_interface/cdw_write_wizard.c:1093 src/utilities/cdw_logging.c:446
+#: src/utilities/cdw_logging.c:452 src/utilities/cdw_logging.c:458
+#: src/utilities/cdw_logging.c:464 src/utilities/cdw_logging.c:552
+msgid "Error"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. initial configuration of tmp files failed
+#: src/main.c:130
+msgid "Error occurred when configuring home or tmp directory. Closing."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. initial configuration of tmp files failed
+#: src/main.c:180
+msgid "Error occurred when configuring log file. Closing."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. cdw can't find "which" utility on computer
+#: src/main.c:192
+msgid "Error occurred when configuring external tools: \"which\" tool is not available on your system. Closing."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. initial configuration of external tools
+#. (e.g. cdrecord, mkisofs) failed
+#: src/main.c:201
+msgid "Unknown error occurred when configuring external tools. Closing."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. initial configuration of cdw file manager
+#. failed
+#: src/main.c:216
+msgid "Error occurred when configuring file manager. Closing."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. initial configuration of cdw UI failed
+#: src/main.c:229
+msgid "Error occurred when configuring user interface files. Closing."
+msgstr ""
+
+#. 2TRANS: this is a title of window displaying
+#. content of log file
+#: src/main.c:342
+msgid "cdw log file"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/main.c:510
+msgid "Please confirm"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window,
+#. user can press OK or Cancel
+#: src/main.c:513
+msgid "Do you really want to quit cdw?"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal,
+#. first %s is name of a testing program, second %s is
+#. a name of this software package
+#: src/main.c:555
+#, c-format
+msgid ""
+"\n"
+"%s: testing tool for %s\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal,
+#. %s is program name; keep square brackets
+#. 2TRANS: this is help text displayed in console;
+#. %s will be replaced by program name, don't change its
+#. position
+#: src/main.c:558 src/utilities/cdw_utils.c:216
+#, c-format
+msgid ""
+"Usage: %s [options]\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal,
+#. a header for options supported by this program
+#: src/main.c:561
+#, c-format
+msgid "Options:\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal
+#: src/main.c:564
+#, c-format
+msgid "  --help    | -h            : show this screen\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal
+#: src/main.c:566
+#, c-format
+msgid ""
+"\n"
+"Invoke this program without options to run unit tests\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal;
+#. first %s is name of a testing program, second %s is
+#. a name of this software package
+#: src/main.c:572
+#, c-format
+msgid ""
+"%s: %s unit tests facility\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this is dropdown item label: 650MB CD
+#: src/configuration/cdw_config.c:68 src/configuration/cdw_config_window.c:961
+msgid "74 min CD (650 MB)"
+msgstr ""
+
+#. 2TRANS: this is dropdown item label: 700MB CD
+#: src/configuration/cdw_config.c:70 src/configuration/cdw_config_window.c:963
+msgid "80 min CD (700 MB)"
+msgstr ""
+
+#. 2TRANS: this is dropdown item label: DVD
+#: src/configuration/cdw_config.c:72 src/configuration/cdw_config_window.c:965
+msgid "Generic DVD (4.7 GB)"
+msgstr ""
+
+#. 2TRANS: this is dropdown item label: DVD+R DL
+#: src/configuration/cdw_config.c:74 src/configuration/cdw_config_window.c:967
+msgid "DVD+R DL (8.5 GB)"
+msgstr ""
+
+#. 2TRANS: this is dropdown item label: custom value of
+#. ISO volume; user can enter arbitrary natural number
+#: src/configuration/cdw_config.c:77 src/configuration/cdw_config_window.c:970
+msgid "Custom value"
+msgstr ""
+
+#. 2TRANS: this is dropdown item label:
+#. "automatic" = automatic detection/resolution of size of ISO volume
+#: src/configuration/cdw_config.c:80 src/configuration/cdw_config_window.c:973
+msgid "Get sizes from disc"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/configuration/cdw_config.c:200 src/configuration/cdw_config.c:226
+#: src/configuration/cdw_config.c:303 src/configuration/cdw_config.c:309
+#: src/configuration/cdw_config.c:367 src/configuration/cdw_config.c:374
+#: src/configuration/cdw_config_window.c:129
+msgid "Config file error"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config.c:202
+msgid "Cannot find home directory and settings file. Will use configuration file in temporary location."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config.c:228
+msgid "Cannot read or write settings file. Will use temporary configuration."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#. 2TRANS: this is the title of the dialog window
+#. 2TRANS: this is title of dialog window
+#: src/configuration/cdw_config.c:244 src/external_tools/cdw_ext_tools.c:1282
+#: src/tasks/cdw_burn_disc.c:504 src/tasks/cdw_read_disc.c:489
+#: src/tasks/cdw_read_disc.c:498 src/tasks/cdw_read_disc.c:513
+msgid "Information"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config.c:246
+msgid "Migrating cdw configuration files to new location (into .cdw/ subdirectory in home dir)"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config.c:305
+msgid "An error occurred when saving configuration. Please check config file permissions. Any changes will be lost after closing cdw."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config.c:311
+msgid "Unknown error occurred when saving configuration. Any changes will be lost after closing cdw."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/configuration/cdw_config.c:360
+msgid "Config file problems"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config.c:362
+msgid "Cannot open config file. Will use default configuration."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config.c:369
+msgid "Cannot open config file. Please check file permissions."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config.c:376
+msgid "Unknown error occurred when reading configuration. Default values will be used."
+msgstr ""
+
+#. 2TRANS: this is a default label for ISO9660 volume
+#: src/configuration/cdw_config.c:1072
+msgid "my volume"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config_window.c:115
+msgid "Failed to create configuration window"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config_window.c:131
+msgid "Cannot write to config file. Configuration will not be saved to file."
+msgstr ""
+
+#. 2TRANS: this is name of tab of notepad-style widget:
+#. "Audio" means 'audio cd ripping configuration'
+#: src/configuration/cdw_config_window.c:258
+msgid "Audio"
+msgstr ""
+
+#. 2TRANS: this is name of tab of notepad-style widget:
+#. "Hardware" refers to CD/DVD drives
+#: src/configuration/cdw_config_window.c:261
+msgid "Hardware"
+msgstr ""
+
+#. 2TRANS: this is name of tab of notepad-style widget: "tools" are
+#. external programs (like cdrecord or dvd+rw-mediainfo) used by cdw
+#: src/configuration/cdw_config_window.c:264
+msgid "Tools"
+msgstr ""
+
+#. 2TRANS: this is name of tab of notepad-style widget: "log" is a
+#. file where the program writes various stuff that can be later
+#. examined by user; "misc" means "miscellaneous settings"
+#: src/configuration/cdw_config_window.c:268
+msgid "Log and misc"
+msgstr ""
+
+#: src/configuration/cdw_config_window.c:298
+#: src/user_interface/cdw_iso9660_wizard.c:539
+#: src/user_interface/cdw_write_wizard.c:923
+#, c-format
+msgid "Press F%d / F%d key to save changes or ESC to cancel"
+msgstr ""
+
+#. 2TRANS: this is title of cdw configuration main window
+#: src/configuration/cdw_config_window.c:305
+msgid "Configuration"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/configuration/cdw_config_window.c:460
+#: src/user_interface/cdw_iso9660_wizard.c:214
+#: src/user_interface/cdw_iso9660_wizard.c:698
+#: src/user_interface/cdw_write_wizard.c:1095
+msgid "One of option fields is incorrect or contains character that is not allowed. Please fix it."
+msgstr ""
+
+#. 2TRANS: this is label in configuration window, "drive" is an optical drive
+#: src/configuration/cdw_config_window.c:516
+msgid "cdw should use this drive:"
+msgstr ""
+
+#. 2TRANS: this is input field label: keep no longer than original;
+#. input field holds path to cd reader/writer device
+#: src/configuration/cdw_config_window.c:520
+msgid "Custom path to drive:"
+msgstr ""
+
+#. 2TRANS: this is input field label: keep no longer than original;
+#. input field holds address of scsi writing device
+#: src/configuration/cdw_config_window.c:524
+msgid "SCSI device (for cdrecord):"
+msgstr ""
+
+#. 2TRANS: this is input field label: keep no longer than original;  input field
+#. holds path to directory, into which audio tracks will be ripped
+#. 2TRANS: this is title of window with file picker
+#: src/configuration/cdw_config_window.c:567
+#: src/configuration/cdw_config_window.c:917
+msgid "Audio output dir"
+msgstr ""
+
+#. 2TRANS: do not translate
+#: src/configuration/cdw_config_window.c:572
+#: src/configuration/cdw_config_window.c:696
+#: src/user_interface/cdw_iso9660_wizard.c:344
+msgid ">"
+msgstr ""
+
+#. 2TRANS: this is checkbox label, it means that user will perform manual
+#. selection of values in dropdowns representing available tools
+#: src/configuration/cdw_config_window.c:614
+msgid "Configure tools manually"
+msgstr ""
+
+#. 2TRANS: this is label of input field
+#: src/configuration/cdw_config_window.c:617
+msgid "Tool for creating stand alone ISO9660 file:"
+msgstr ""
+
+#. 2TRANS: this is label of input field; "path" is path in filesystem
+#: src/configuration/cdw_config_window.c:621
+msgid "Tools for handling CDs:"
+msgstr ""
+
+#. 2TRANS: this is label of input field;
+#: src/configuration/cdw_config_window.c:625
+msgid "Tools for handling DVDs:"
+msgstr ""
+
+#. 2TRANS: this is label of input field; "path" is path in filesystem
+#: src/configuration/cdw_config_window.c:629
+msgid "Path to mkisofs:"
+msgstr ""
+
+#. 2TRANS: this is label of input field; "path" is path in filesystem
+#: src/configuration/cdw_config_window.c:632
+msgid "Path to cdrecord:"
+msgstr ""
+
+#. 2TRANS: this is label of input field
+#: src/configuration/cdw_config_window.c:636
+msgid "Digest tool:"
+msgstr ""
+
+#. 2TRANS: this is input field label: keep no longer than original;
+#. input field holds full path to log file
+#: src/configuration/cdw_config_window.c:691
+msgid "Log file path (obligatory):"
+msgstr ""
+
+#. 2TRANS: this is checkbox label: keep no longer than original
+#: src/configuration/cdw_config_window.c:699
+msgid "Show log after actions"
+msgstr ""
+
+#. 2TRANS: this is label above a dropdown, a maximal size of created/update ISO9660 volume
+#: src/configuration/cdw_config_window.c:702
+msgid "ISO volume size:"
+msgstr ""
+
+#. 2TRANS: this is input field label, user can enter into the field a custom value of max. size of ISO volume; "MB" is megabytes
+#: src/configuration/cdw_config_window.c:705
+msgid "Custom ISO volume size (MB):"
+msgstr ""
+
+#. 2TRANS: this is checkbox label: keep no longer than original
+#. 2TRANS: this is checkbox label; when traversing file system, follow UNIX symbolic links
+#: src/configuration/cdw_config_window.c:710
+#: src/external_tools/cdw_mkisofs_options.c:87
+#: src/external_tools/cdw_xorriso_options.c:82
+msgid "Follow added symbolic links"
+msgstr ""
+
+#. 2TRANS: this is title of window with file picker
+#: src/configuration/cdw_config_window.c:886
+msgid "Log file"
+msgstr ""
+
+#. 2TRANS: this is message in file picker
+#. window, explaining what file should be
+#. selected
+#: src/configuration/cdw_config_window.c:890
+msgid "Select new or existing log file"
+msgstr ""
+
+#. 2TRANS: this is message in file picker
+#. window, explaining what file should be
+#. selected
+#: src/configuration/cdw_config_window.c:921
+msgid "Select existing output dir"
+msgstr ""
+
+#. 2TRANS: this is a description in one of
+#. configuration window panels; a series of
+#. dropdown widgets is displayed below the label
+#: src/configuration/cdw_config_window.c:1018
+msgid "Changes made here won't be saved after closing cdw."
+msgstr ""
+
+#. 2TRANS: this is string written to log file when
+#. reading one track from CD disc is finished;
+#. it is written after "Track %d: " string
+#: src/disc_and_drive/cdw_cdio.c:1530
+msgid "There is probably not enough space on hard disc for copied data\n"
+msgstr ""
+
+#. 2TRANS: this is string written to log file when
+#. reading one track from CD disc is finished with
+#. problems; "%s" is system error message;
+#. it is written after "Track %d: " string
+#: src/disc_and_drive/cdw_cdio.c:1540
+#, c-format
+msgid "Maybe this error message will be helpful: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this string will be displayed as message in progress window;
+#. first %ld is amount of data already read from cd,
+#. second %ld is total amount of data to be read
+#: src/disc_and_drive/cdw_cdio.c:1670
+#, c-format
+msgid "%ld/%ld MB"
+msgstr ""
+
+#. 2TRANS: "unknown" as in "Disc type: unknown"; keep short
+#. 2TRANS: this is message in dialog window,
+#. displayed after "Can write to the disc: "
+#. label; it means "I don't know if you can
+#. write to this disc"
+#: src/disc_and_drive/cdw_disc.c:189 src/tasks/cdw_read_disc_info.c:332
+msgid "unknown"
+msgstr ""
+
+#. 2TRANS: this string means "there is no disc in drive"; keep short
+#. 2TRANS: "No disc" means "currently there is no disc in
+#. drive or no information about disc has been collected
+#. yet"; keep short
+#: src/disc_and_drive/cdw_disc.c:191 src/user_interface/cdw_main_window.c:587
+msgid "No disc"
+msgstr ""
+
+#. 2TRANS: this string means "regular CD disc with music"; keep short
+#: src/disc_and_drive/cdw_disc.c:193
+msgid "Audio CD"
+msgstr ""
+
+#. 2TRANS: this is message printed in dialog window
+#: src/disc_and_drive/cdw_disc.c:196
+msgid "cdw can't read the disc because the disc is empty."
+msgstr ""
+
+#. 2TRANS: this is message printed in dialog window
+#: src/disc_and_drive/cdw_disc.c:198
+msgid "cdw can't read the disc because your operating system does not support ISO9660 file system."
+msgstr ""
+
+#. 2TRANS: this is message printed in dialog window
+#: src/disc_and_drive/cdw_disc.c:200
+msgid "cdw can't read the disc because your operating system does not support UDF file system."
+msgstr ""
+
+#. 2TRANS: this is message printed in dialog window;
+#. "not supported" means "cdw can't handle it"
+#: src/disc_and_drive/cdw_disc.c:203
+msgid "cdw can't read the disc because file system on the disc is not supported by cdw."
+msgstr ""
+
+#. 2TRANS: this is message printed in dialog window;
+#. there is some generic/unknown issue/problem with
+#. checking the disc
+#: src/disc_and_drive/cdw_disc.c:207
+msgid "cdw can't read the disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/disc_and_drive/cdw_disc.c:330
+msgid "Cannot check media: disc is mounted. Please unmount your optical disc."
+msgstr ""
+
+#. 2TRANS: this is title of process window; reading
+#. disc meta information
+#: src/disc_and_drive/cdw_disc.c:388 src/tasks/cdw_read_disc_info.c:71
+msgid "Read disc information"
+msgstr ""
+
+#. 2TRANS: this is message in
+#. process window
+#: src/disc_and_drive/cdw_disc.c:391 src/tasks/cdw_read_disc_info.c:74
+msgid "Reading disc information"
+msgstr ""
+
+#. 2TRANS: this is message dialog window,
+#. program cannot get metadata from disc
+#: src/disc_and_drive/cdw_disc.c:622
+msgid "Cannot get information about disc."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#. 2TRANS: this is the title of dialog window
+#. 2TRANS: this is title of dialog window
+#. 2TRANS: this is a dialog window title
+#: src/disc_and_drive/cdw_disc.c:641 src/disc_and_drive/cdw_drive.c:327
+#: src/native_file_system/cdw_fs.c:483 src/native_file_system/cdw_fs.c:1391
+#: src/tasks/cdw_burn_disc.c:260 src/tasks/cdw_burn_disc.c:292
+#: src/tasks/cdw_burn_disc.c:414 src/tasks/cdw_erase_disc.c:279
+#: src/tasks/cdw_read_disc.c:247 src/tasks/cdw_task.c:230
+#: src/tasks/cdw_task.c:1107
+msgid "Warning"
+msgstr ""
+
+#. 2TRANS: this is message dialog window
+#: src/disc_and_drive/cdw_disc.c:643
+msgid "This is DVD-RW disc, it is not fully supported by cdw. You may have some problems."
+msgstr ""
+
+#. 2TRANS: this is message dialog window,
+#. program cannot get metadata from disc
+#: src/disc_and_drive/cdw_disc.c:705
+msgid "Cannot get basic information about disc."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/disc_and_drive/cdw_disc.c:754
+msgid "Getting disc info with cdrecord"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/disc_and_drive/cdw_disc.c:759
+msgid "Getting disc info with dvd+rw-mediainfo"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/disc_and_drive/cdw_disc.c:764
+msgid "Getting disc info with xorriso"
+msgstr ""
+
+#: src/disc_and_drive/cdw_drive.c:327
+msgid "No drive.\n"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window:
+#. some problem occurred while trying to access disc
+#. 2TRANS: this is title of dialog window: some error occurred
+#. while trying to access disc
+#: src/disc_and_drive/cdw_drive.c:333 src/disc_and_drive/cdw_drive.c:565
+msgid "CD drive error"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/disc_and_drive/cdw_drive.c:338
+msgid "Getting drive status"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: no optical disc
+#. found in drive; user can select OK or CANCEL button
+#: src/disc_and_drive/cdw_drive.c:347
+msgid "No disc in CD/DVD drive. Please insert disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window; user
+#. can select OK or CANCEL button
+#: src/disc_and_drive/cdw_drive.c:353
+msgid "Please close CD/DVD drive tray."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. user can select OK or CANCEL button
+#: src/disc_and_drive/cdw_drive.c:360
+msgid "CD/DVD drive doesn't respond (timeout). Try again?"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. cannot read some meta-data from cd; user
+#. can select OK or CANCEL button
+#: src/disc_and_drive/cdw_drive.c:367
+msgid "Can't get CD/DVD drive info. Continue?"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. for some reason program cannot open CD device.
+#. User should check his settings
+#: src/disc_and_drive/cdw_drive.c:374
+msgid "Can't open CD/DVD drive device. Please check your configuration."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. unknown error occurred
+#: src/disc_and_drive/cdw_drive.c:380
+msgid "Can't open CD/DVD drive device. Unknown error."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: some errors
+#. occurred while accessing drive
+#: src/disc_and_drive/cdw_drive.c:404
+msgid ""
+"Something went wrong.\n"
+"Please check settings in Configuration -> Hardware and try once more."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/disc_and_drive/cdw_drive.c:457 src/disc_and_drive/cdw_drive.c:520
+msgid "Ejecting tray"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window;
+#. "tray" is an optical drive tray
+#: src/disc_and_drive/cdw_drive.c:476
+msgid "Closing tray, waiting for drive"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/disc_and_drive/cdw_drive.c:504 src/tasks/cdw_calculate_digest.c:256
+#: src/tasks/cdw_calculate_digest.c:291 src/utilities/cdw_logging.c:358
+msgid "Message"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/disc_and_drive/cdw_drive.c:506
+msgid "Cannot eject tray. Please unmount your drive."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/disc_and_drive/cdw_drive.c:529
+msgid "Closing tray and waiting for drive"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window: some error occurred
+#. while trying to access disc
+#: src/disc_and_drive/cdw_drive.c:556
+msgid "Drive error"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. some error occurred while accessing cdrom
+#: src/disc_and_drive/cdw_drive.c:559
+msgid "Can't open device. Please check your configuration."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/disc_and_drive/cdw_drive.c:567
+msgid "CDROM doesn't respond (timeout)."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/disc_and_drive/cdw_drive.c:587
+msgid "Can't find any drive. Please check your hardware configuration."
+msgstr ""
+
+#. 2TRANS: this is title of process window;
+#. "drive" is "optical drive" - a burner
+#: src/disc_and_drive/cdw_drive.c:594
+msgid "Drive tray"
+msgstr ""
+
+#. 2TRANS: this is message in process window,
+#. "drive" is "optical drive" - a burner
+#: src/disc_and_drive/cdw_drive.c:597
+msgid "Opening/closing drive tray"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/disc_and_drive/cdw_drive.c:609
+msgid "Cannot get media info."
+msgstr ""
+
+#. 2TRANS: this is message in process window,
+#. "drive" is "optical drive" - a burner
+#: src/disc_and_drive/cdw_drive.c:626
+msgid "Drive state changed"
+msgstr ""
+
+#. 2TRANS: this is a label in a dropdown; "custom path" is
+#. "path to a device file, specified by user"
+#: src/disc_and_drive/cdw_drive.c:649
+msgid "Use custom path to drive"
+msgstr ""
+
+#. 2TRANS: this is a help message
+#: src/disc_and_drive/cdw_drive.c:725
+msgid "cdw can't detect any drives, you may want to enter and use custom path to a device.\n"
+msgstr ""
+
+#. 2TRANS: this is a help message, describing content
+#. of a dropdown
+#: src/disc_and_drive/cdw_drive.c:730
+msgid "'*' in dropdown denotes default drive.\n"
+msgstr ""
+
+#. 2TRANS: this is a help message, keep \"/dev/xxx\" unchanged
+#: src/disc_and_drive/cdw_drive.c:732
+msgid ""
+"Custom path to device should have form \"/dev/xxx\", without ending slash.\n"
+"\"SCSI device\" field is for experts only, and if filled, cdw may not work correctly.\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. 'image file' refers to 'ISO image file'
+#: src/external_tools/cdw_cdrecord.c:246
+msgid "Failed to prepare burning image file to disc"
+msgstr ""
+
+#. 2TRANS: this is message printed in log file
+#: src/external_tools/cdw_cdrecord.c:363
+msgid ""
+"\n"
+"\n"
+"Preparing to write to optical disc directly from files.\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in log file; "%s" is command
+#. (program name + options) passed to shell
+#: src/external_tools/cdw_cdrecord.c:366
+#, c-format
+msgid "Command for calculating tsize: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in log file; "%s" is command
+#. (program name + options) passed to shell
+#: src/external_tools/cdw_cdrecord.c:369
+#, c-format
+msgid "Command for mkisofs: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in log file; "%s" is command
+#. (program name + options) passed to shell
+#: src/external_tools/cdw_cdrecord.c:372
+#, c-format
+msgid "Command for cdrecord: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/external_tools/cdw_cdrecord.c:434
+msgid "An error occurred when attempting to erase disc."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window:
+#. erasing refers to erasing of CD-RW
+#. 2TRANS: this is title of dialog window
+#: src/external_tools/cdw_cdrecord.c:464 src/external_tools/cdw_cdrecord.c:475
+#: src/external_tools/cdw_cdrecord.c:483
+msgid "Erasing error"
+msgstr ""
+
+#. 2TRANS: this is message
+#. in dialog window
+#: src/external_tools/cdw_cdrecord.c:467
+msgid "Can't erase the disc. Try selecting different implementation of cdrecord in Configuration -> Tools or switch to dvd+rw-tools (if available)."
+msgstr ""
+
+#. 2TRANS: this is message
+#. in dialog window
+#: src/external_tools/cdw_cdrecord.c:478
+msgid "This disc cannot be erased. Please try erasing with option 'Erase all content'."
+msgstr ""
+
+#. 2TRANS: this is message
+#. in dialog window
+#: src/external_tools/cdw_cdrecord.c:486
+msgid "This disc cannot be erased."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/external_tools/cdw_cdrecord.c:533
+msgid "An error occurred when attempting to read some meta information from disc."
+msgstr ""
+
+#. 2TRANS: this is message printed into log file
+#: src/external_tools/cdw_cdrecord.c:558
+#, c-format
+msgid "cdrecord command for extracting ATIP information: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message in process window,
+#. it is about getting some meta information from
+#. optical disc
+#: src/external_tools/cdw_cdrecord.c:562
+msgid "Getting ATIP information"
+msgstr ""
+
+#. 2TRANS: this is message printed into log file
+#: src/external_tools/cdw_cdrecord.c:584
+#, c-format
+msgid "cdrecord command for extracting PRCAP information: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message in process window,
+#. it is about getting some meta information from
+#. optical disc
+#: src/external_tools/cdw_cdrecord.c:588
+msgid "Getting PRCAP information"
+msgstr ""
+
+#. 2TRANS: this is message printed into log file
+#: src/external_tools/cdw_cdrecord.c:611
+#, c-format
+msgid "cdrecord command for extracting TOC information: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message in process window,
+#. it is about getting some meta information from
+#. optical disc
+#: src/external_tools/cdw_cdrecord.c:615
+msgid "Getting TOC information"
+msgstr ""
+
+#. 2TRANS: this is message printed into log file
+#: src/external_tools/cdw_cdrecord.c:637
+#, c-format
+msgid "cdrecord command for extracting MSINFO information: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message in process window,
+#. it is about getting some meta information from
+#. optical disc
+#: src/external_tools/cdw_cdrecord.c:641
+msgid "Getting MSINFO information"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/external_tools/cdw_cdrecord.c:899
+msgid "Error message"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/external_tools/cdw_cdrecord.c:901
+msgid "An error occurred. Try to write disc again."
+msgstr ""
+
+#. 2TRANS: this is dialog window title
+#. (writing audio files to CD)
+#: src/external_tools/cdw_cdrecord.c:1091
+msgid "Write audio"
+msgstr ""
+
+#. 2TRANS: this is message in dialog
+#. window: writing audio CD is in
+#. progress
+#: src/external_tools/cdw_cdrecord.c:1095
+msgid "Writing audio..."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window; result of
+#. operation is unknown
+#: src/external_tools/cdw_cdrecord.c:1101
+msgid "Writing audio finished"
+msgstr ""
+
+#. 2TRANS: this string will be used as title of window
+#. displaying log of operation (of writing audio CD)
+#: src/external_tools/cdw_cdrecord.c:1105
+msgid "Write audio log"
+msgstr ""
+
+#. 2TRANS: this is dialog window title
+#. 2TRANS: this is title of dialog window, it is related to ripping data CD
+#: src/external_tools/cdw_cdrecord.c:1142 src/tasks/cdw_read_disc.c:74
+msgid "Copy data CD"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. result of operation (success/failure) unknown
+#: src/external_tools/cdw_cdrecord.c:1148
+msgid "Copying data CD finished"
+msgstr ""
+
+#. 2TRANS: this string will be used as title of
+#. window displaying log of operation (of copying CD)
+#: src/external_tools/cdw_cdrecord.c:1152
+msgid "Copy data CD log"
+msgstr ""
+
+#. 2TRANS: this is checkbox label in config window; a noun (?); "pad" -> "padding" -> "some bytes added at the end of proper data"
+#: src/external_tools/cdw_cdrecord_options.c:78
+msgid "Pad"
+msgstr ""
+
+#. 2TRANS: this is checkbox label: keep no longer than original; "Pad" refers to adding empty data at the end of track
+#: src/external_tools/cdw_cdrecord_options.c:81
+msgid "Pad size (number >= 0, '150' is recommended)"
+msgstr ""
+
+#. 2TRANS: do not translate
+#: src/external_tools/cdw_cdrecord_options.c:85
+msgid "s"
+msgstr ""
+
+#. 2TRANS: this is checkbox label in configuration window; see documentation of cdrecord for definition of "burnproof"
+#: src/external_tools/cdw_cdrecord_options.c:89
+msgid "Burnproof"
+msgstr ""
+
+#. 2TRANS: this is label of input field in configuration window; the field contains other options passed to cdrecord
+#: src/external_tools/cdw_cdrecord_options.c:92
+msgid "Other cdrecord options:"
+msgstr ""
+
+#. 2TRANS: this is label displayed in progress window,
+#. Track is cd data track, %d is its number
+#: src/external_tools/cdw_cdrecord_regex.c:630
+#: src/external_tools/cdw_cdrecord_regex.c:735
+#, c-format
+msgid "Track: %d"
+msgstr ""
+
+#. 2TRANS: this is label displayed in progress window,
+#. %d is amount of data already written to CD
+#: src/external_tools/cdw_cdrecord_regex.c:636
+#, c-format
+msgid "%d MB"
+msgstr ""
+
+#. 2TRANS: this is label displayed in progress window,
+#. first %d is amount of data already written to CD,
+#. second %d is total amount of data to write
+#: src/external_tools/cdw_cdrecord_regex.c:717
+#: src/external_tools/cdw_xorriso_regex.c:675
+#, c-format
+msgid "%d/%d MB"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window,
+#. meaning that closing session is in progress
+#: src/external_tools/cdw_cdrecord_regex.c:753
+msgid "Fixating, please wait..."
+msgstr ""
+
+#. 2TRANS: this is message in progress window, meaning that
+#. subprocess cannot access CD drive, because the drive is busy
+#: src/external_tools/cdw_cdrecord_regex.c:795
+msgid "Device or resource busy."
+msgstr ""
+
+#. 2TRANS: this is message in progress window,
+#. possible explanation for previous message
+#: src/external_tools/cdw_cdrecord_regex.c:798
+msgid "Make sure that device is unmounted."
+msgstr ""
+
+#. 2TRANS: this is message in progress window
+#: src/external_tools/cdw_cdrecord_regex.c:1368
+msgid "You need to close drive tray and press ENTER"
+msgstr ""
+
+#. 2TRANS: this is message in process window - there is some
+#. preparation to erasing, but the erasing hasn't started yet
+#: src/external_tools/cdw_dvd_rw_format.c:99
+#: src/external_tools/cdw_growisofs.c:708
+msgid "Preparing to erase. Please wait."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/external_tools/cdw_dvd_rw_mediainfo.c:56
+msgid "An error occurred when attempting to read DVD info."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/external_tools/cdw_dvd_rw_mediainfo.c:62
+msgid "Getting disc information"
+msgstr ""
+
+#. 2TRANS: this is message printed into cdw log. %s is a tool name,
+#. like cdrecord or growisofs; "Tools" is a label of one of tabs
+#. in Configuration window; keep escaped quotes
+#: src/external_tools/cdw_ext_tools.c:701
+#, c-format
+msgid "ERROR: cdw can't find following tool: \"%s\".\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window; %s is a tool name,
+#. like cdrecord or growisofs; "Tools" is a label of one of tabs
+#. in Configuration window; keep escaped quotes
+#: src/external_tools/cdw_ext_tools.c:707
+#, c-format
+msgid "cdw can't proceed because it can't find this tool: %s. Please check your options (\"Tools\" tab)."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "tool" refers to external programs like cdrecord
+#. or growisofs; keep escaped quotes
+#: src/external_tools/cdw_ext_tools.c:717
+msgid "Can't find some external tool. Please check your options (\"Tools\" tab)."
+msgstr ""
+
+#. 2TRANS: given tool is not available in user's environment;
+#. no more than 19 chars
+#: src/external_tools/cdw_ext_tools.c:738
+msgid "(not available)"
+msgstr ""
+
+#. 2TRANS: "system default" means "tool selected by default
+#. in user's system";  no more than 19 chars
+#: src/external_tools/cdw_ext_tools.c:743
+msgid "(system default)"
+msgstr ""
+
+#. 2TRANS: "no tool available" means "no tool that would meet some
+#. specification is available"; no more than 19 chars
+#: src/external_tools/cdw_ext_tools.c:748
+msgid "(no tool available)"
+msgstr ""
+
+#. 2TRANS: this is label in dropdown list; it allows selecting xorriso,
+#. with information that you can handle "only" DVD+R and DVD-R discs with it
+#: src/external_tools/cdw_ext_tools.c:878
+msgid "xorriso (only DVD+/-R)"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "tool" means "cdrecord", "growisofs", etc.
+#: src/external_tools/cdw_ext_tools.c:1011
+msgid "Can't find any tool for current task, please check your configuration and system.\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/external_tools/cdw_ext_tools.c:1284
+msgid "cdw can't handle this type of disc using xorriso, please select different tool in Configuration -> Tools."
+msgstr ""
+
+#. 2TRANS: this is message in process window - there is some
+#. preparation to writing, but the writing hasn't started yet
+#: src/external_tools/cdw_growisofs.c:278
+#: src/external_tools/cdw_growisofs.c:320
+msgid "Preparing to write. Please wait."
+msgstr ""
+
+#. 2TRANS: this is message printed to log file; string with
+#. program name and its all command-line parameters will be
+#. printed in next line
+#: src/external_tools/cdw_growisofs.c:423
+msgid "Command for growisofs for writing from ISO image:\n"
+msgstr ""
+
+#. 2TRANS: this is message printed to log file; string with all
+#. command-line parameters passed to mkisofs will be printed in next line
+#: src/external_tools/cdw_growisofs.c:566
+msgid "mkisofs options used by growisofs for writing files to DVD:\n"
+msgstr ""
+
+#. 2TRANS: this is message printed to log file; string with
+#. program name and its all command-line parameters will be
+#. printed in next line
+#: src/external_tools/cdw_growisofs.c:602
+msgid "Command for growisofs for writing from files:\n"
+msgstr ""
+
+#. 2TRANS: this is title of process window - program is blanking disc
+#: src/external_tools/cdw_growisofs.c:705
+msgid "Erase DVD"
+msgstr ""
+
+#. 2TRANS: this is message in process window - program finished
+#. blanking disc, status unknown
+#: src/external_tools/cdw_growisofs.c:718
+msgid "Erasing of DVD finished"
+msgstr ""
+
+#. 2TRANS: this is message in process window - program didn't
+#. erase blanking because of errors
+#: src/external_tools/cdw_growisofs.c:723
+msgid "Erasing of DVD failed, please see log file"
+msgstr ""
+
+#. 2TRANS: this is a label for input field: "Other options passed to growisofs
+#: src/external_tools/cdw_growisofs_options.c:58
+msgid "Other growisofs options:"
+msgstr ""
+
+#. 2TRANS: this is string displayed in process progress window;
+#. first %.1f is amount of data already written, second %.1f is
+#. total amount of data to be written
+#: src/external_tools/cdw_growisofs_regex.c:719
+#, c-format
+msgid "%.1f/%.1f MB"
+msgstr ""
+
+#. 2TRANS: this is string displayed in process progress window;
+#. writing iso image to DVD disc is in progress
+#: src/external_tools/cdw_growisofs_regex.c:730
+msgid "Writing image in progress..."
+msgstr ""
+
+#. 2TRANS: this is string displayed in process progress window;
+#. writing selected files to DVD disc is in progress
+#: src/external_tools/cdw_growisofs_regex.c:734
+msgid "Writing files in progress..."
+msgstr ""
+
+#. 2TRANS: this is string displayed in process progress window;
+#. blanking DVD disc is in progress
+#: src/external_tools/cdw_growisofs_regex.c:738
+msgid "Erasing of DVD in progress..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process progress window:
+#. ETA stands for time left to end of process, %2d is amount of
+#. minutes left, %02d is amount of seconds left
+#: src/external_tools/cdw_growisofs_regex.c:750
+#, c-format
+msgid "ETA: %2d:%02d"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process progress window;
+#. "Speed" is writing speed, %d and %d are decimal and fractional
+#. parts of writing speed, e.g. "Speed: 2.5x"
+#: src/external_tools/cdw_growisofs_regex.c:758
+#, c-format
+msgid "Speed: %d.%dx"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process progress window:
+#. dvd+rw disc in drive has never been written to and has to be
+#. formatted for a first time
+#: src/external_tools/cdw_growisofs_regex.c:815
+msgid "Pre-formatting blank disc..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process progress window:
+#. writing is almost finished, growisofs is writing ending part
+#. of session
+#: src/external_tools/cdw_growisofs_regex.c:830
+msgid "Writing leadout..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process progress window
+#: src/external_tools/cdw_growisofs_regex.c:843
+msgid "Reformatting media..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process progress window
+#: src/external_tools/cdw_growisofs_regex.c:856
+msgid "Wrong media type, cannot write"
+msgstr ""
+
+#. 2TRANS: this is message displayed in processwin:
+#. writing is almost finished, growisofs is cleaning cache buffer
+#: src/external_tools/cdw_growisofs_regex.c:877
+msgid "Flushing cache..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in process progress window:
+#. ETA stands for amount of time left to end of current process;
+#. 0:00 is minutes:seconds, please leave value as zero
+#: src/external_tools/cdw_growisofs_regex.c:888
+#, c-format
+msgid "ETA: 0:00"
+msgstr ""
+
+#. 2TRANS: this is message displayed in processwin:
+#. writing is finished, growisofs is closing track
+#: src/external_tools/cdw_growisofs_regex.c:913
+msgid "Closing track..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in processwin:
+#. writing is finished, growisofs is closing session
+#: src/external_tools/cdw_growisofs_regex.c:934
+msgid "Closing session..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in processwin:
+#. writing single session is finished, growisofs flushed cache and
+#. now is doing something called "Updating RMA", whatever it is ;)
+#: src/external_tools/cdw_growisofs_regex.c:951
+msgid "Updating RMA..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in processwin:
+#. writing single session is finished, growisofs flushed cache and
+#. now is closing disc, so that no other data can be written
+#: src/external_tools/cdw_growisofs_regex.c:968
+msgid "Closing disc..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in processwin;
+#. I have no idea what it means
+#: src/external_tools/cdw_growisofs_regex.c:984
+msgid "Stopping de-icing..."
+msgstr ""
+
+#. 2TRANS: this is message displayed in processwin;
+#. An error occurred during process of writing
+#. 2TRANS: this is message displayed in processwin
+#: src/external_tools/cdw_growisofs_regex.c:1002
+#: src/external_tools/cdw_growisofs_regex.c:1029
+#: src/external_tools/cdw_growisofs_regex.c:1057
+#: src/external_tools/cdw_growisofs_regex.c:1079
+msgid "An error occurred"
+msgstr ""
+
+#. 2TRANS: this is message in displayed in processwin;
+#. growisofs detected that there is not enough space on disc
+#. to write selected data
+#: src/external_tools/cdw_growisofs_regex.c:1006
+msgid "Too little space on optical disc"
+msgstr ""
+
+#. 2TRANS: this is message in displayed in processwin;
+#. growisofs detected that there is not enough space on disc
+#. to write selected data
+#: src/external_tools/cdw_growisofs_regex.c:1033
+msgid "Media is not appendable"
+msgstr ""
+
+#. 2TRANS: this is message in displayed in processwin;
+#. growisofs detected that there is not enough space on disc
+#. to write selected data
+#: src/external_tools/cdw_growisofs_regex.c:1061
+msgid "Use different session writing mode"
+msgstr ""
+
+#. 2TRANS: this is message in displayed in processwin;
+#. growisofs detected that there is not enough space on disc
+#. to write selected data
+#: src/external_tools/cdw_growisofs_regex.c:1083
+msgid "Some error occurred, please try again with different settings"
+msgstr ""
+
+#. 2TRANS: this is checkbox label; use Joliet extensions to ISO9660 (add Joliet information to ISO file system)
+#: src/external_tools/cdw_mkisofs_options.c:79
+#: src/external_tools/cdw_xorriso_options.c:74
+msgid "Joliet information"
+msgstr ""
+
+#. 2TRANS: this is checkbox label; specify Rock Ridge extensions to ISO9660 (add Rock Ridge information to ISO file system)
+#: src/external_tools/cdw_mkisofs_options.c:83
+#: src/external_tools/cdw_xorriso_options.c:77
+msgid "Rock Ridge information"
+msgstr ""
+
+#. 2TRANS: this is a label next to dropdown list; select ISO9660 level from the dropdown
+#: src/external_tools/cdw_mkisofs_options.c:91
+msgid "ISO level"
+msgstr ""
+
+#. 2TRANS: this is a checkbox label; allow long file names in ISO9660 file system; "Joliet" is an extension to ISO9660 standard
+#: src/external_tools/cdw_mkisofs_options.c:95
+msgid "Long Joliet file names"
+msgstr ""
+
+#. 2TRANS: this is a checkbox label; add additional bytes after proper data payload
+#: src/external_tools/cdw_mkisofs_options.c:99
+#: src/external_tools/cdw_xorriso_options.c:86
+msgid "Pad at the end"
+msgstr ""
+
+#. 2TRANS: this is an input field label: define additional top level (root) directory for created file system
+#: src/external_tools/cdw_mkisofs_options.c:103
+msgid "Root directory:"
+msgstr ""
+
+#. 2TRANS: this is an input field label; define other options passed to mkisofs
+#: src/external_tools/cdw_mkisofs_options.c:107
+msgid "Other mkisofs options:"
+msgstr ""
+
+#. 2TRANS: do not translate
+#: src/external_tools/cdw_mkisofs_options.c:129
+msgid "1"
+msgstr ""
+
+#. 2TRANS: do not translate
+#: src/external_tools/cdw_mkisofs_options.c:131
+msgid "2"
+msgstr ""
+
+#. 2TRANS: do not translate
+#: src/external_tools/cdw_mkisofs_options.c:133
+msgid "3"
+msgstr ""
+
+#. 2TRANS: do not translate
+#: src/external_tools/cdw_mkisofs_options.c:135
+msgid "4"
+msgstr ""
+
+#. 2TRANS: none = no Rock Ridge extensions
+#: src/external_tools/cdw_mkisofs_options.c:157
+msgid "None"
+msgstr ""
+
+#. 2TRANS: useful = some values of attributes of file system are set to some more useful values
+#: src/external_tools/cdw_mkisofs_options.c:159
+#: src/external_tools/cdw_xorriso_options.c:111
+msgid "Useful"
+msgstr ""
+
+#. 2TRANS: full = full Rock Ridge extensions
+#: src/external_tools/cdw_mkisofs_options.c:161
+#: src/external_tools/cdw_xorriso_options.c:113
+msgid "Full"
+msgstr ""
+
+#. 2TRANS: this is button label; a verb: read data from config file
+#: src/external_tools/cdw_mkisofsrc.c:92 src/external_tools/cdw_xorrisorc.c:88
+msgid "Read"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter abstract of ISO9660 volume; don't localize "ABST"
+#: src/external_tools/cdw_mkisofsrc.c:95
+msgid "Abstract (ABST)"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter ID of ISO9660 volume set; don't localize "VOLS"
+#: src/external_tools/cdw_mkisofsrc.c:99
+msgid "Volume set ID (VOLS)"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter copyright of ISO9660 volume; don't localize "COPY"
+#: src/external_tools/cdw_mkisofsrc.c:103
+msgid "Copyright (COPY)"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter information about publisher of ISO9660 volume; don't localize "PUBL"
+#: src/external_tools/cdw_mkisofsrc.c:107
+msgid "Publisher (PUBL)"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter information about preparer of ISO9660 volume; don't localize "PREP"
+#: src/external_tools/cdw_mkisofsrc.c:111
+msgid "Preparer (PREP)"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter information about system on which ISO9660 volume has been created; don't localize "SYSI"
+#: src/external_tools/cdw_mkisofsrc.c:115
+msgid "System ID (SYSI)"
+msgstr ""
+
+#. 2TRANS: this is message printed in configuration window;
+#. don't localize "$HOME/.mkisofsrc"
+#: src/external_tools/cdw_mkisofsrc.c:224
+msgid "These values won't be saved after closing cdw. Leave the fields empty (values from mkisofs config file will be used) or enter custom values. You can populate the fields with values from $HOME/.mkisofsrc using the button below."
+msgstr ""
+
+#. 2TRANS: this is message printed to log file
+#: src/external_tools/cdw_mkisofs_regex.c:584
+msgid "ERROR: problem with creating file system on optical disc.\n"
+msgstr ""
+
+#. 2TRANS: this is message printed to log file
+#: src/external_tools/cdw_mkisofs_regex.c:586
+msgid "ERROR: Perhaps this information will help resolve the problem:\n"
+msgstr ""
+
+#. 2TRANS: this is message printed to log file;
+#. '%s' is an error message printed by mkisofs
+#: src/external_tools/cdw_mkisofs_regex.c:589
+#, c-format
+msgid "ERROR: %s\n"
+msgstr ""
+
+#. 2TRANS: this is time stamp (current time) printed to log file;
+#. %d is an integer representing UNIX time
+#: src/external_tools/cdw_thread.c:289
+#, c-format
+msgid "Time stamp: %d\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in log file; this is current
+#. time (in readable form, like "Wed Jun 30 21:49:08 1993");
+#. %s is a string with time in readable, probably localized, form
+#: src/external_tools/cdw_thread.c:293
+#, c-format
+msgid "Time: %s\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in log file; "current command"
+#. is a call to external command that will be performed
+#: src/external_tools/cdw_thread.c:296
+#, c-format
+msgid "Full command issued to shell: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in log file; 'external tools' are
+#. programs like cdrecord or mkisofs
+#: src/external_tools/cdw_thread.c:299
+msgid ""
+"Output from external tool(s) follow:\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this is string displayed in log file when
+#. something went very badly and cdw cannot create child
+#. process - this is serious error
+#: src/external_tools/cdw_thread.c:324
+msgid "Error: fork failure\n"
+msgstr ""
+
+#. 2TRANS: this is message printed to log file when
+#. something went very badly and  exec() function
+#. returned after a call; %d is value returned by
+#. exec()
+#: src/external_tools/cdw_thread.c:384
+#, c-format
+msgid "Error: exec() returned with value %d\n"
+msgstr ""
+
+#. 2TRANS: this is debug message displayed in
+#. console when thread cannot be created
+#: src/external_tools/cdw_thread.c:436
+#, c-format
+msgid "Thread 1 creation error"
+msgstr ""
+
+#. 2TRANS: this is debug message displayed in
+#. console when thread cannot be created
+#: src/external_tools/cdw_thread.c:446
+#, c-format
+msgid "Thread 2 creation error"
+msgstr ""
+
+#. 2TRANS: this is a message printed to log file; "socket" is an UNIX socket
+#: src/external_tools/cdw_thread.c:473
+msgid "Error: creating socket pairs failed\n"
+msgstr ""
+
+#. 2TRANS: this is an input field label; define other options passed to xorriso, related to creating ISO9660 file system
+#: src/external_tools/cdw_xorriso_options.c:89
+msgid "Other xorriso options for ISO9660:"
+msgstr ""
+
+#. 2TRANS: this is an input field label; define other options passed to xorriso, related to burning discs
+#: src/external_tools/cdw_xorriso_options.c:198
+msgid "Other xorriso options for writing:"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter information about publisher of ISO9660 volume
+#: src/external_tools/cdw_xorrisorc.c:91
+msgid "Publisher"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter information about ID of ISO9660 volume set
+#: src/external_tools/cdw_xorrisorc.c:95
+msgid "Volume set ID"
+msgstr ""
+
+#. 2TRANS: this is a label next to input field, in which user can enter information about system on which ISO9660 volume has been created
+#: src/external_tools/cdw_xorrisorc.c:99
+msgid "System ID"
+msgstr ""
+
+#. 2TRANS: this is a message printed in configuration window;
+#. don't localize "$HOME/.xorrisorc"
+#: src/external_tools/cdw_xorrisorc.c:174
+msgid "These values won't be saved after closing cdw. Leave the fields empty (values from xorriso config file will be used) or enter custom values. You can populate the fields with values from $HOME/.xorrisorc using the button below."
+msgstr ""
+
+#. 2TRANS: this is message printed to log file;
+#. '%s' is configuration file name
+#: src/external_tools/cdw_xorrisorc.c:199
+#, c-format
+msgid "WARNING: can't open %s file in home directory\n"
+msgstr ""
+
+#. 2TRANS: this is label displayed in progress window
+#: src/external_tools/cdw_xorriso_regex.c:351
+#, c-format
+msgid "segment: %d"
+msgstr ""
+
+#. 2TRANS: this is label displayed in progress window,
+#. %d.%d is a number with fractional part, describing amount
+#. of data (in percents) processed
+#: src/external_tools/cdw_xorriso_regex.c:358
+#, c-format
+msgid "%d.%d %%"
+msgstr ""
+
+#. 2TRANS: this is label displayed in progress window;
+#. the task is fully completed
+#: src/external_tools/cdw_xorriso_regex.c:376
+#, c-format
+msgid "Completed"
+msgstr ""
+
+#. 2TRANS: this is label displayed in progress window,
+#. writing is now completed in 100%
+#: src/external_tools/cdw_xorriso_regex.c:382
+#, c-format
+msgid "100.0%%"
+msgstr ""
+
+#. 2TRANS: this is a message printed to log file;
+#. '%s' is a string with unknown option passed to xorriso
+#: src/external_tools/cdw_xorriso_regex.c:922
+#, c-format
+msgid "ERROR: unknown xorriso option \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is a message printed to log file
+#: src/external_tools/cdw_xorriso_regex.c:927
+msgid "ERROR: unknown xorriso option\n"
+msgstr ""
+
+#. 2TRANS: "E" stands for "Error" - this label marks invalid
+#. item; please keep as short as possible
+#: src/native_file_system/cdw_file.c:594
+msgid "E"
+msgstr ""
+
+#. 2TRANS: this is label indicating that labeled item
+#. is a directory; please keep as short as possible
+#: src/native_file_system/cdw_file.c:600
+msgid "DIR"
+msgstr ""
+
+#. 2TRANS: suffix for megabytes,
+#. please keep as short as possible
+#: src/native_file_system/cdw_file.c:610
+msgid "M"
+msgstr ""
+
+#. 2TRANS: suffix for kilobytes,
+#. please keep as short as possible
+#: src/native_file_system/cdw_file.c:613
+msgid "K"
+msgstr ""
+
+#. 2TRANS: "n/a" means here that there is no label suitable
+#. for description of given item; keep as short as possible
+#: src/native_file_system/cdw_file.c:617
+msgid "n/a"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/native_file_system/cdw_file_manager.c:592
+msgid "File not added. Please try again."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/native_file_system/cdw_file_manager.c:595
+msgid "Unexpected error. Please close this window and open it again."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window. Some
+#. function returned error value. No further action
+#. will be performed, no other explanations provided
+#: src/native_file_system/cdw_file_manager.c:600
+msgid "Cannot show file selector window. Some error occurred."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window. Some
+#. function returned error value. No further action
+#. will be performed, no other explanations provided
+#: src/native_file_system/cdw_file_manager.c:605
+msgid "Cannot display view with selected files. You should restart application."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/native_file_system/cdw_file_manager.c:611
+msgid "File manager error"
+msgstr ""
+
+#. 2TRANS: this is title of file selector window
+#: src/native_file_system/cdw_file_manager.c:832
+msgid "Add files"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/native_file_system/cdw_file_manager.c:849
+msgid "No files selected"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user
+#. wants to write files or create image, but no
+#. files from hdd are selected yet
+#: src/native_file_system/cdw_file_manager.c:853
+msgid "No files selected. Please use 'Add files'"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/native_file_system/cdw_file_manager.c:962
+msgid "For some reason cdw can't visit all files in selected directory (consult log file for details)."
+msgstr ""
+
+#. 2TRANS: this is message printed into log file;
+#. %s is a full path to a file
+#: src/native_file_system/cdw_file_manager.c:966
+#, c-format
+msgid "ERROR: failed to fully scan this path: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is label of button
+#. 2TRANS: button label, please keep as short as possible
+#: src/native_file_system/cdw_file_picker.c:235
+#: src/user_interface/widgets/cdw_dialog.c:574
+msgid "OK"
+msgstr ""
+
+#. 2TRANS: this is label of button
+#. 2TRANS: button label
+#. 2TRANS: button label, please keep as short as possible
+#: src/native_file_system/cdw_file_picker.c:238
+#: src/user_interface/cdw_erase_wizard.c:480
+#: src/user_interface/cdw_iso9660_wizard.c:352
+#: src/user_interface/cdw_verify_wizard.c:332
+#: src/user_interface/cdw_write_wizard.c:805
+#: src/user_interface/widgets/cdw_dialog.c:580
+msgid "Cancel"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/native_file_system/cdw_fs_browser.c:560
+msgid "Unexpected error, perhaps some file has been deleted. Please close this window and open it again."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "change directory" means "enter into directory"
+#: src/native_file_system/cdw_fs_browser.c:564
+msgid "Cannot change directory: wrong permissions."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "read directory" means "read content of directory"
+#: src/native_file_system/cdw_fs_browser.c:568
+msgid "Cannot read directory: wrong permissions."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. user highlighted a file and pressed enter,
+#. but the file probably does not exit
+#: src/native_file_system/cdw_fs_browser.c:573
+msgid "File does not exists or cannot change directory."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window. Some
+#. function returned error value. No further action
+#. will be performed, no other explanations provided
+#: src/native_file_system/cdw_fs_browser.c:578
+msgid "Cannot display content of current directory. Please close this window and open it again."
+msgstr ""
+
+#. 2TRANS: this is title of help window
+#. 2TRANS: this is title of small
+#. help window displaying hotkeys
+#: src/native_file_system/cdw_fs_browser.c:856
+#: src/user_interface/cdw_help.c:51 src/user_interface/cdw_help.c:135
+msgid "Help"
+msgstr ""
+
+#. 2TRANS: this is helper text at the bottom of help window
+#: src/native_file_system/cdw_fs_browser.c:858
+msgid "Press any key to close"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/native_file_system/cdw_fs.c:390 src/native_file_system/cdw_fs.c:461
+msgid "Select directory"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window. Please keep '\n'.
+#: src/native_file_system/cdw_fs.c:392
+msgid ""
+"Please select Home directory.\n"
+"   Press ESC to cancel."
+msgstr ""
+
+#. 2TRANS: this is message in dialog
+#. window, "Home" is user's home dir,
+#. "closing" refers to closing
+#. application
+#: src/native_file_system/cdw_fs.c:413
+msgid "Path to Home directory not initialized properly, closing."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window. Please keep '\n'.
+#: src/native_file_system/cdw_fs.c:463
+msgid ""
+"Please select temporary directory.\n"
+"   Press ESC to cancel."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#: src/native_file_system/cdw_fs.c:485
+msgid "Path to tmp directory is the same as path to home directory. This is not a bad thing, but some things might work differently."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/native_file_system/cdw_fs.c:641
+msgid "Path to drive specified in configuration is incorrect. Please check your configuration."
+msgstr ""
+
+#. 2TRANS: this is message printed in log file,
+#. %s is full path to a device file
+#: src/native_file_system/cdw_fs.c:660
+#, c-format
+msgid "cdw can't check device specified in configuration as \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/native_file_system/cdw_fs.c:668
+msgid "cdw has problems with searching for your device. Please restart cdw."
+msgstr ""
+
+#. 2TRANS: this is message printed to log file; %s is
+#. a full path to file
+#. 2TRANS: this is message printed to log file;
+#. %s is a full path to file
+#: src/native_file_system/cdw_fs.c:1167 src/native_file_system/cdw_fs.c:1199
+#, c-format
+msgid "Error: cdw can't get any information about this file: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message printed to log file; %s is
+#. an additional error message string
+#: src/native_file_system/cdw_fs.c:1170 src/native_file_system/cdw_fs.c:1203
+#, c-format
+msgid "Error: perhaps this information can help resolve problem: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message dialog window, user can
+#. press Yes, No or Cancel button
+#: src/native_file_system/cdw_fs.c:1394
+msgid "File already exists. Overwrite?"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1403
+msgid "The path points to directory."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1413
+msgid "Wrong access rights to file or parent directory."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1419
+msgid "Path is too long."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1427
+msgid "File or part of directory path does not exist."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1433
+msgid "File is of incorrect type."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1441
+msgid "This is not path to directory or part of a path name is invalid."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1449
+msgid "Wrong permissions for the file."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1458
+msgid "Path is invalid or points to invalid file."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1466
+msgid "Path is invalid or points to invalid file"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1473
+msgid "Path to file in read-only file system."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1480
+msgid "The file pointed by path is invalid."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1486
+msgid "Path is invalid."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1492 src/native_file_system/cdw_fs.c:1498
+msgid "File is too big to open."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1506
+msgid "Path uses too many symbolic links."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1513
+msgid "There is no space on this device for the file."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/native_file_system/cdw_fs.c:1517 src/native_file_system/cdw_fs.c:1523
+#: src/native_file_system/cdw_fs.c:1529 src/native_file_system/cdw_fs.c:1536
+#: src/native_file_system/cdw_fs.c:1598
+msgid "System error"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1519
+msgid "No system memory. You should close application."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#: src/native_file_system/cdw_fs.c:1525 src/native_file_system/cdw_fs.c:1531
+msgid "Too many files opened. You should close application."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user can press OK button
+#. 2TRANS: this is message in
+#. dialog window, user can
+#. press OK button
+#: src/native_file_system/cdw_fs.c:1538 src/native_file_system/cdw_fs.c:1602
+msgid "Unknown error while accessing the file."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/optical_file_systems/cdw_iso9660.c:103
+msgid "There seems to be problem with iso file. Please check the file location."
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window
+#: src/tasks/cdw_burn_disc.c:139
+msgid "cdw can't create write wizard. Please restart cdw."
+msgstr ""
+
+#. 2TRANS: this is a title of process window;
+#. "disc" is "optical disc"
+#: src/tasks/cdw_burn_disc.c:162
+msgid "Writing to disc"
+msgstr ""
+
+#. 2TRANS: this is message in process window;
+#. "disc" is "optical disc"
+#: src/tasks/cdw_burn_disc.c:165
+msgid "Writing to optical disc"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. operation finished with unknown result, probably success
+#: src/tasks/cdw_burn_disc.c:220
+msgid "Writing finished"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. operation finished (most probably) with error
+#: src/tasks/cdw_burn_disc.c:226
+msgid "Writing probably failed"
+msgstr ""
+
+#. 2TRANS: this is the title of the dialog window, displaying messages
+#. from the program writing iso image or selected files to CD disc
+#: src/tasks/cdw_burn_disc.c:232
+msgid "\"Write\" log"
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window
+#: src/tasks/cdw_burn_disc.c:262
+msgid "You are attempting to use wodim to burn large image. This task will probably fail. You should try using another tool (cdrecord or growisofs) for this task. Do you want to continue?"
+msgstr ""
+
+#. 2TRANS: this is message printed in log file;
+#. %ld is size of ISO9660 image (in sectors)
+#: src/tasks/cdw_burn_disc.c:267
+#, c-format
+msgid "Attempting to burn ISO image of size %ld sectors with wodim, this may fail...\n"
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window
+#: src/tasks/cdw_burn_disc.c:294
+msgid "The disc is not blank, you will overwrite its current content. Continue?"
+msgstr ""
+
+#. 2TRANS: this is message in process window:
+#. writing selected files to CD is in progress
+#: src/tasks/cdw_burn_disc.c:339
+msgid "Writing files to CD..."
+msgstr ""
+
+#. 2TRANS: this is message in process window:
+#. writing selected files to DVD is in progress
+#: src/tasks/cdw_burn_disc.c:343
+msgid "Writing files to DVD..."
+msgstr ""
+
+#. 2TRANS: this is message in process window -
+#. writing iso image to CD is in progress
+#: src/tasks/cdw_burn_disc.c:349
+msgid "Writing image to CD..."
+msgstr ""
+
+#. 2TRANS: this is message in process window -
+#. writing iso image to DVD is in progress
+#: src/tasks/cdw_burn_disc.c:353
+msgid "Writing image to DVD..."
+msgstr ""
+
+#. 2TRANS: this is the title of dialog window
+#. 2TRANS: this is title of dialog window
+#: src/tasks/cdw_burn_disc.c:390 src/tasks/cdw_create_image.c:161
+#: src/user_interface/cdw_iso9660_wizard.c:438
+msgid "Path to iso image"
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window;
+#. "writing" means writing to optical disc
+#: src/tasks/cdw_burn_disc.c:393
+msgid "Please enter FULL path to an existing iso image file for writing:"
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window:
+#. disc is not recognized as supported by
+#. currently selected tools
+#: src/tasks/cdw_burn_disc.c:418
+msgid "One of selected files has a size over 4GB. Choose your tools wisely (Configuration -> Tools), otherwise writing to disc will give incorrect results."
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window:
+#. disc is not recognized as supported by
+#. currently selected tools
+#. 2TRANS: this is message in dialog window:
+#. disc is not recognized as supported by
+#. currently selected tools
+#: src/tasks/cdw_burn_disc.c:460 src/tasks/cdw_erase_disc.c:259
+msgid "Can't recognize disc in drive. Try changing tools family in Configuration -> Tools or use different disc type."
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window - disc is not writable
+#: src/tasks/cdw_burn_disc.c:471
+msgid "Disc in drive is read-only."
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window: for some
+#. reason cdw cannot read disc metainfo; this may be a
+#. problem with the hardware configuration or with the family
+#. of tools (cdrtools / dvd+rw-tools) used for the task
+#: src/tasks/cdw_burn_disc.c:487
+msgid "Cannot get full information about disc. Please check configuration of hardware or tools. (Are you using wodim?)."
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window - user tries to write to a closed disc
+#: src/tasks/cdw_burn_disc.c:495
+msgid "Cannot write to this disc anymore, disc is closed."
+msgstr ""
+
+#. 2TRANS: this is the message in the dialog window
+#: src/tasks/cdw_burn_disc.c:506
+msgid "You are attempting to burn to a DVD+R DL disc. You REALLY need to use high quality discs and have a bit of luck to correctly burn data to DVD+R DL. Additionally cdw offers very limited support for DVD+RD DL discs. Continue?"
+msgstr ""
+
+#: src/tasks/cdw_calculate_digest.c:82 src/tasks/cdw_calculate_digest.c:636
+msgid "Can't perform the task, it seems that there are no digest tools (like md5sum or sha1sum) installed in your system."
+msgstr ""
+
+#. 2TRANS: this is message in process window
+#: src/tasks/cdw_calculate_digest.c:179
+msgid "Calculating digest of input file"
+msgstr ""
+
+#. 2TRANS: this is message in progress window:
+#. description of task currently performed
+#: src/tasks/cdw_calculate_digest.c:214
+msgid "Calculating digest of disc track"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "digest" is a value returned by tools such
+#. as md5sum or sha512sum
+#: src/tasks/cdw_calculate_digest.c:260
+msgid "Finished. Digest value is in log file ('L' hotkey in main window)."
+msgstr ""
+
+#. 2TRANS: this is text written to log file: a header printed before
+#. a digest for data file is printed;
+#. "%s" is a name of tool/algorithm used to calculate digest, like
+#. "md5sum" or "sha256"
+#: src/tasks/cdw_calculate_digest.c:266
+#, c-format
+msgid ""
+"\n"
+"\n"
+"Digest (%s):\n"
+msgstr ""
+
+#. 2TRANS: this is text written to log file: %s is a digest of
+#. data burned to first track of optical disc;
+#. keep '\n' chars in place; keep " chars around %s
+#: src/tasks/cdw_calculate_digest.c:271
+#, c-format
+msgid ""
+"Digest of input file:\n"
+"\"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is text written to log file: %s is a digest of
+#. data burned to first track of optical disc;
+#. keep '\n' chars in place; keep " chars around %s
+#: src/tasks/cdw_calculate_digest.c:276
+#, c-format
+msgid ""
+"Digest of first track on optical disc:\n"
+"\"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: it describes result of verification
+#: src/tasks/cdw_calculate_digest.c:285
+msgid ""
+"Verification finished, data file and first track on disc are the same.\n"
+"\n"
+"Digest values have been printed to log file ('L' key in main window)."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: it describes result of verification
+#: src/tasks/cdw_calculate_digest.c:287
+msgid ""
+"Verification finished, data file and first track on disc are different.\n"
+"\n"
+"Digest values have been printed to log file ('L' key in main window)."
+msgstr ""
+
+#. 2TRANS: this is text written to log file: a header printed before
+#. two digests for track and for input file are printed;
+#. "%s" is a name of tool/algorithm used to calculate digest, like
+#. "md5sum" or "sha256"
+#: src/tasks/cdw_calculate_digest.c:309
+#, c-format
+msgid ""
+"\n"
+"\n"
+"Digests (%s):\n"
+msgstr ""
+
+#. 2TRANS: this is text written to log file: %s is a digest of
+#. data burned to first track of optical disc;
+#. keep '\n' chars in place; keep " chars around %s
+#: src/tasks/cdw_calculate_digest.c:313
+#, c-format
+msgid ""
+"Digest of burned data:\n"
+"\"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is text written to log file: %s is digest of
+#. input data file; keep '\n' chars in place;  keep " chars around %s
+#: src/tasks/cdw_calculate_digest.c:316
+#, c-format
+msgid ""
+"Digest of input data file:\n"
+"\"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: disc
+#. is in drive, but cdw cannot open it using a
+#. library API
+#: src/tasks/cdw_calculate_digest.c:354 src/tasks/cdw_read_disc.c:154
+msgid "Cannot open disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. some preconditions of reading a CD were not met
+#: src/tasks/cdw_calculate_digest.c:366
+msgid "Can't read from the disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. it describes result of verification
+#: src/tasks/cdw_calculate_digest.c:387
+msgid "Failed to set up reading from optical disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_calculate_digest.c:465
+msgid "Failed to open given file."
+msgstr ""
+
+#. 2TRANS: this string will be displayed as message in progress window;
+#. first %ld is amount of data already read from CD,
+#. second %ld is total amount of data to be read
+#: src/tasks/cdw_calculate_digest.c:565
+#, c-format
+msgid "%lld/%lld MB"
+msgstr ""
+
+#. 2TRANS: this is message printed in progress window
+#: src/tasks/cdw_calculate_digest.c:598
+msgid "Verifying data on optical disc"
+msgstr ""
+
+#. 2TRANS: this is message printed in progress window
+#: src/tasks/cdw_calculate_digest.c:601
+msgid "Verifying data in given file"
+msgstr ""
+
+#. 2TRANS: this is message printed in progress window
+#: src/tasks/cdw_calculate_digest.c:604
+msgid "Comparing data on disc and in given file"
+msgstr ""
+
+#. 2TRANS: this is title of process window
+#: src/tasks/cdw_calculate_digest.c:608
+msgid "Verify data"
+msgstr ""
+
+#. 2TRANS: this is a title of file selector dialog window
+#: src/tasks/cdw_calculate_digest.c:660
+msgid "Select data file"
+msgstr ""
+
+#. 2TRANS: this is additional message in file selector dialog window
+#: src/tasks/cdw_calculate_digest.c:662
+msgid "Select existing file to verify"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/tasks/cdw_create_image.c:83
+msgid "Create image"
+msgstr ""
+
+#. 2TRANS: this is message in dialog
+#. window - creating iso image is in
+#. progress
+#: src/tasks/cdw_create_image.c:87
+msgid "Creating iso image..."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. operation finished with unknown result
+#: src/tasks/cdw_create_image.c:101
+msgid "Finished"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window, window shows
+#. messages from program writing selected files to iso
+#. image (creating iso image from selected files)
+#: src/tasks/cdw_create_image.c:115
+msgid "\"Create image\" log"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. probably some malloc() call failed when
+#. program was preparing call of mkisofs;
+#. 'command' is command-line command. 'Image'
+#. means iso image file.
+#: src/tasks/cdw_create_image.c:125
+msgid "System error occurred when preparing command. Image not created."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/tasks/cdw_create_image.c:144
+msgid "Boot image error"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_create_image.c:146
+msgid "Boot image file doesn't exist or has wrong permissions! Check \"Boot image\" option in Configuration."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. below it there is an input field where user can
+#. enter path to ISO image file
+#: src/tasks/cdw_create_image.c:165
+#: src/user_interface/cdw_iso9660_wizard.c:442
+msgid "Please enter FULL path to new iso image file:"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window, user
+#. cancelled erasing media by pressing Escape key
+#: src/tasks/cdw_erase_disc.c:102
+msgid "Some error occurred when attempting to erase disc."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window, displaying
+#. messages from program blanking disc
+#: src/tasks/cdw_erase_disc.c:113
+msgid "\"Erase\" log"
+msgstr ""
+
+#. 2TRANS: this is title of process window;
+#. "disc" is "optical disc"
+#: src/tasks/cdw_erase_disc.c:138
+msgid "Erase disc"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "disc" is "optical disc"
+#: src/tasks/cdw_erase_disc.c:141
+msgid "Erasing disc"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. disc is now erased
+#: src/tasks/cdw_erase_disc.c:163
+msgid "Erasing of disc finished successfully"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. cdw called cdrecord to perform erasing, but
+#. most probably it failed and disc was not erased.
+#: src/tasks/cdw_erase_disc.c:169
+msgid "Erasing of disc probably failed. Please check your disc."
+msgstr ""
+
+#. 2TRANS: this is message in process window,
+#. it says about fast mode of blanking
+#: src/tasks/cdw_erase_disc.c:195
+msgid "Erasing in \"fast\" mode"
+msgstr ""
+
+#. 2TRANS: this is message in process window -
+#. erasing a disc will be a time-consuming task
+#: src/tasks/cdw_erase_disc.c:199
+msgid "Erasing in \"all\" mode (long time)"
+msgstr ""
+
+#. 2TRANS: this is message in process window;
+#. "disc" is optical disc
+#: src/tasks/cdw_erase_disc.c:204
+msgid "Erasing of disc in progress"
+msgstr ""
+
+#. 2TRANS: this is message in progress window, displayed when
+#. cdrecord blanks disc - no information about progress of
+#. erasing is provided
+#: src/tasks/cdw_erase_disc.c:216
+msgid "No progress info will be displayed"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/tasks/cdw_erase_disc.c:224
+msgid "Erasing with dvd+rw-format"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/tasks/cdw_erase_disc.c:231
+msgid "Erasing with xorriso"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process window
+#: src/tasks/cdw_erase_disc.c:238
+msgid "Erasing with growisofs"
+msgstr ""
+
+#. 2TRANS: this is message dialog window, user
+#. tries to erase disc that is not erasable
+#: src/tasks/cdw_erase_disc.c:274
+msgid "Disc in drive is not erasable. Cannot erase it."
+msgstr ""
+
+#. 2TRANS: this is message dialog window, user
+#. tries to erase disc that may be not erasable
+#: src/tasks/cdw_erase_disc.c:282
+msgid "Type of disc in drive is unknown. Cannot erase it."
+msgstr ""
+
+#. 2TRANS: this is message printed to log file: a header for any further messages related to ripping audio CD
+#: src/tasks/cdw_read_disc.c:65
+msgid "Copying audio tracks:\n"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window, it is related to ripping audio CD
+#: src/tasks/cdw_read_disc.c:67
+msgid "Copy audio CD"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: ripping audio cd is in progress
+#: src/tasks/cdw_read_disc.c:69
+msgid "Copying audio CD..."
+msgstr ""
+
+#. 2TRANS: this is message printed to log file: a header for any further messages related to ripping data CD
+#: src/tasks/cdw_read_disc.c:72
+msgid "Copying data CD tracks:\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: ripping data CD is in progress
+#: src/tasks/cdw_read_disc.c:76
+msgid "Copying data CD..."
+msgstr ""
+
+#. 2TRANS: this is message printed to log file: a header for any further messages related to ripping data DVD
+#: src/tasks/cdw_read_disc.c:79
+msgid "Copying data DVD track:\n"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window, it is related to ripping data DVD
+#: src/tasks/cdw_read_disc.c:81
+msgid "Copy data DVD"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: ripping data DVD is in progress
+#: src/tasks/cdw_read_disc.c:83
+msgid "Copying data DVD..."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: reading
+#. a disc is finished. I'm not adding "successfully",
+#. because this is not 100% sure.
+#: src/tasks/cdw_read_disc.c:192
+msgid "Finished."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: reading
+#. a disc is finished, but with errors
+#: src/tasks/cdw_read_disc.c:198
+msgid "Finished. Some errors occurred."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_read_disc.c:203
+msgid "Failed to read disc content. Consult log file ('L' key in main window) for further info."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window in which user has
+#. to enter path to valid dir
+#: src/tasks/cdw_read_disc.c:217
+msgid "Output directory"
+msgstr ""
+
+#. 2TRANS: this is label in dialog
+#. window below it is input field
+#: src/tasks/cdw_read_disc.c:220
+msgid "Enter path to existing output directory"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_read_disc.c:249
+msgid "You are attempting to read multi-track disc. cdw can't read second and following tracks, so only first track will be read. Continue?"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window in which user has
+#. to enter path to valid dir
+#: src/tasks/cdw_read_disc.c:260
+msgid "Output file"
+msgstr ""
+
+#. 2TRANS: this is label in dialog
+#. window below it is input field
+#: src/tasks/cdw_read_disc.c:263
+msgid "Select new or existing image file"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window:
+#. first %d number of track being currently ripped,
+#. second %d is total number of tracks
+#: src/tasks/cdw_read_disc.c:378
+#, c-format
+msgid "Copying track %d/%d"
+msgstr ""
+
+#. 2TRANS: this is string written to log file when
+#. program attempted to read track from CD, but failed
+#. to open file, to which the track was supposed to
+#. be written; 'skipping' means 'not performing read
+#. of the track and going to next track'
+#: src/tasks/cdw_read_disc.c:416
+#, c-format
+msgid "Failed to open output file for track %d, skipping...\n"
+msgstr ""
+
+#. 2TRANS: this is string written to log file when
+#. program starts to read one track from CD disc;
+#. "%d" is number of track
+#: src/tasks/cdw_read_disc.c:421
+#, c-format
+msgid "Track %d: "
+msgstr ""
+
+#. 2TRANS: this is string written to log file when
+#. reading one track from CD disc is finished;
+#. it is written after "Track %d: " string
+#: src/tasks/cdw_read_disc.c:443
+msgid "done\n"
+msgstr ""
+
+#. 2TRANS: this is string written to log file when
+#. reading one track from CD disc is finished;
+#. it is written after "Track %d: " string
+#: src/tasks/cdw_read_disc.c:453
+msgid "failed: there were some problems while reading track\n"
+msgstr ""
+
+#. 2TRANS: this message in dialog window
+#: src/tasks/cdw_read_disc.c:491
+msgid "Disc in drive is empty, can't read any data from the disc."
+msgstr ""
+
+#. 2TRANS: this message in dialog window
+#: src/tasks/cdw_read_disc.c:500
+msgid "Disc in drive may be empty and reading from disc may fail. Continue?"
+msgstr ""
+
+#. 2TRANS: this is main part of name of audio tracks ripped from
+#. cd, no more than TRACK_CORE_NAME_LEN = 30 chars
+#: src/tasks/cdw_read_disc.c:530
+msgid "track"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window where user have to
+#. enter core of track file names
+#: src/tasks/cdw_read_disc.c:540
+msgid "File name"
+msgstr ""
+
+#. 2TRANS: this is label in dialog window, below it is an input field
+#: src/tasks/cdw_read_disc.c:542
+msgid "Enter core of track file names (no more than 30 characters)."
+msgstr ""
+
+#. 2TRANS: this is error message displayed in dialog window
+#. when getting a file name from user failed
+#: src/tasks/cdw_read_disc.c:549
+msgid "Can't get valid file name, aborting."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_read_disc_info.c:60
+msgid "Can't find any drives, please check your hardware."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_read_disc_info.c:88
+msgid "Cannot show disc info. No disc in drive."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_read_disc_info.c:104
+msgid "Cannot check media. Please unmount your drive."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_read_disc_info.c:120
+msgid "Cannot get media info. Consult log file ('L' hotkey in main window)."
+msgstr ""
+
+#. 2TRANS: this is message in dialog
+#. window, user can select "OK" or
+#. "Cancel" button
+#: src/tasks/cdw_read_disc_info.c:180
+msgid "Cannot check if disc is unmounted. You should unmount your drive. Continue?"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: an
+#. operation cannot be executed, because optical
+#. disc is mounted in file system
+#: src/tasks/cdw_read_disc_info.c:199
+msgid "Cannot continue with mounted drive."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window: an
+#. operation cannot be executed, because optical
+#. disc is mounted in file system
+#: src/tasks/cdw_read_disc_info.c:209
+msgid "Cannot continue. Please unmount your drive and press OK."
+msgstr ""
+
+#. 2TRANS: this is a title of a window
+#. 2TRANS: this is title of area displaying basic
+#. information about disc currently in drive
+#: src/tasks/cdw_read_disc_info.c:250 src/user_interface/cdw_main_window.c:522
+msgid "Disc info"
+msgstr ""
+
+#. 2TRANS: this is message at the bottom of a window
+#: src/tasks/cdw_read_disc_info.c:252
+msgid "Press any key to close window"
+msgstr ""
+
+#. 2TRANS: this is a message in dialog window
+#: src/tasks/cdw_read_disc_info.c:273
+msgid "Can't get disc information"
+msgstr ""
+
+#. 2TRANS: this is a message in dialog window,
+#. "write to the disc" = "burn data to the disc";
+#. this message will be followed by a message stating
+#. if you can write to disc
+#: src/tasks/cdw_read_disc_info.c:296
+msgid "Can write to the disc: "
+msgstr ""
+
+#. 2TRANS: this is a label in dialog
+#. window, displayed after "Can write
+#. to the disc: " label; "yes" as in
+#. "yes, you can write to the disc"
+#. 2TRANS: this is a label in dialog window,
+#. "yes" as in "yes, you can erase the disc"
+#: src/tasks/cdw_read_disc_info.c:305 src/tasks/cdw_read_disc_info.c:346
+msgid "yes"
+msgstr ""
+
+#. 2TRANS: this is a label in dialog
+#. window, displayed after "Can write
+#. to the disc: "; "no" as in "no, you
+#. can't write to the disc"
+#: src/tasks/cdw_read_disc_info.c:311
+msgid "no, disc is closed"
+msgstr ""
+
+#. 2TRANS: this is a label in dialog
+#. window, displayed after "Can write
+#. to the disc: " label; "unknown" as
+#. in "I don't know if you can write
+#. to this disc"
+#. 2TRANS: this is a label in dialog
+#. window, displayed after "Can erase this
+#. disc: " label; "unknown" as in "I don't
+#. know if you can erase this disc"
+#: src/tasks/cdw_read_disc_info.c:318 src/tasks/cdw_read_disc_info.c:356
+msgid "unknown, probably no"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window,
+#. displayed after "Can write to the disc: "
+#. label; it means "no, you can't write to
+#. this disc because it is 'read only' type
+#. of disc"
+#: src/tasks/cdw_read_disc_info.c:326
+msgid "no, disc type is \"read only\""
+msgstr ""
+
+#. 2TRANS: this is a label in dialog window,
+#. it will be followed by a string describing
+#. if a disc can be erased or no
+#: src/tasks/cdw_read_disc_info.c:339
+msgid "Can erase this disc: "
+msgstr ""
+
+#. 2TRANS: this is a label in dialog window,
+#. "no" as in "no, you can't erase the disc"
+#: src/tasks/cdw_read_disc_info.c:350
+msgid "no"
+msgstr ""
+
+#. 2TRANS: this is a label in dialog window, it will
+#. be followed by string representing volume ID
+#. (a disc label)
+#: src/tasks/cdw_read_disc_info.c:363
+msgid "Volume id:"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:202
+msgid "cdrecord can't access CD/DVD drive. Please check your settings in Configuration -> Hardware."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:215
+msgid "cdrecord reports problems - it can't find some files. Please make sure that string in Configuration -> Writing -> \"Other cdrecord options\" field is correct."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:223
+msgid "cdrecord reports errors when attempting to write to optical disc, probably selected session mode is not acceptable. Please consult log file ('L' hotkey in main window)."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:232
+msgid "cdrecord reported some problems with erasing optical disc, the disc may be still non-empty, please check it."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:240
+msgid "cdrecord reported some problems with writing to optical disc, the disc was not appendable (probably it was closed)."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:248
+msgid "cdrecord reported some problems with writing to optical disc, most probably data was not written. Try using different tool."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:256
+msgid "Size of selected files or ISO image exceeds size of free space available on optical disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:264
+msgid "One of cdrecord options is incorrect. Please check \"Other cdrecord options\" field in Configuration -> Writing."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:272
+msgid "cdw can't find valid disc in drive. Perhaps drive tray is open."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:283
+msgid "Can't open CD/DVD drive device. Please check your settings in Configuration -> Hardware."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:291
+msgid "Can't read optical disc. Please check the disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:302
+msgid "Can't burn these files to optical disc. Too little space or no space left on optical disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:310
+msgid "Can't burn this ISO image file to optical disc. Too little space or no space left on optical disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:318
+msgid "Can't write to optical disc, it is not appendable. Please check the disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#. don't make an impression that the disc *really*
+#. is empty - only suggest it to user
+#: src/tasks/cdw_task.c:328
+msgid "Optical disc is probably empty. Check the disc and consider using \"Start new, appendable disc\" option in \"Session writing mode\" dropdown in write wizard."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:336
+msgid "Unknown error occurred. Please retry with different options."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:344
+msgid ""
+"Action failed because some files were larger than 4GB.\n"
+"\n"
+"You may want to retry the action with \"-allow-limited-size   -udf\" options in Configuration -> ISO filesystem -> Other mkisofs options field, but that may result in data being unreadable on some systems that don't support UDF filesystem.\n"
+"\n"
+"Consult log file ('L' hotkey in main window) to check which file caused problems."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:355
+msgid "Can't create image: some file names are too long. Try toggling \"Long Joliet names\" checkbox in Configuration -> ISO filesystem."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:366
+msgid "Can't create image. Check your settings in Configuration -> ISO filesystem."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:377
+msgid "Can't create image. Path to boot image file is incorrect. Please consult \"mkisofs\" or \"cdw\" manual page."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:389
+msgid ""
+"mkisofs reports problems: it can't find some files. Possible reasons:\n"
+"one of selected files has been deleted or is a broken symbolic link, or there is incorrect option in \"Other mkisofs options\" field in Configuration -> ISO filesystem tab. Check log for details ('L' key)."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:402
+msgid "mkisofs reports invalid option. Please check content of \"Other mkisofs options\" field in Configuration -> ISO filesystem tab."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:414
+msgid "mkisofs reports problems with selected files. Can't write these files. Try creating ISO image and then burn the image to optical disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:418
+msgid "mkisofs reports problems with selected files. Can't write these files."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/tasks/cdw_task.c:421
+msgid "Error - more info"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:423
+msgid "If you are appending data to non-empty optical disc, make sure to use the same mkisofs options as for data already written to the disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:431
+msgid "No space left on hard disc. Select other hard disc as target for ISO image file."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:439
+msgid "mkisofs reported some problems, probably current \"ISO level\" value set in Configuration -> \"ISO filesystem\" does not match the one used for writing previous session."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:449
+msgid "mkisofs reported some problems when trying to append data to optical disc. Probably you can't append more data to the disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:453
+msgid "mkisofs reported some problems when trying to create ISO image, probably some files have very similar names or paths."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:468
+msgid "mkisofs failed to create ISO image because one of selected files changed size. Check log file for details ('L' hotkey in main window).\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:472
+msgid "Process of writing files to optical disc failed because one of selected files changed size. Check log file for details ('L' hotkey in main window).\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:484
+msgid "mkisofs reported fatal error, current task was finished incorrectly. Check log file for details ('L' hotkey in main window).\n"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:492
+msgid ""
+"Action failed because some files were larger than 2GiB.\n"
+"\n"
+"You may want to retry the action with \"-allow-limited-size  -udf\" option in Configuration -> ISO filesystem -> \"Other mkisofs options\" field, but that may result in data being unreadable on some systems that don't support UDF filesystem.\n"
+"Alternatively ensure that \"ISO level\" in Configuration -> ISO filesystem is at least 3.\n"
+"\n"
+"Consult log file ('L' hotkey in main window) to check which file caused problems."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:501
+msgid ""
+"Action failed because some files were too large for current settings. Please ensure that \"ISO level\" in Configuration -> ISO filesystem is at least 3.\n"
+"\n"
+"Consult log file ('L' hotkey in main window) to check which file caused problems."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:509
+msgid "Action failed, but you may want to open and close drive tray and try again."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:517
+msgid "Action failed, you probably need to select \"xorriso\" in Configuration -> Tools to burn to this disc. Check log file for details ('L' hotkey in main window), search for \"Implementation botch\"."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:527
+msgid "Tried to check md5sum of non-data track or track from multi-track disc. cdw can't do that."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:538
+msgid "This disc/drive combo does not accept simulation of burning or erasing. Please adjust the options of the task."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:546
+msgid "There is too little space on optical disc to burn selected data."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:554
+msgid "cdw can't read any information from the disc using xorriso. Please adjust your settings in Configuration -> Tools."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:562
+msgid "Invalid option passed to xorriso. Check options in text fields in Configuration window, and under wizard's \"Other options\". See log file ('L' hotkey) for details."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "tool" means "cdrecord", "growisofs", etc.
+#. "manual" means "made by user in config window";
+#. "automatic" means "not made by user in config window"
+#: src/tasks/cdw_task.c:597
+msgid "There was some error with manual selection of a tool for current task. You may need to check your system or use automatic selection of tool (Configuration -> Tools). Please refer to previous error messages and cdw log file for details."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "tool" means "cdrecord", "growisofs", etc.
+#. "manual" means "made by user in config window";
+#. "automatic" means "not made by user in config window"
+#: src/tasks/cdw_task.c:605
+msgid "There was some problem with automatic selection of a tool for current task. You may need to check your system or use manual selection of tool (Configuration -> Tools). Please refer to previous error messages and cdw log file for details."
+msgstr ""
+
+#. 2TRANS: this is message dialog window;
+#. "mode" is a type of writing to disc: here
+#. it is a generic term that includes
+#. both "tao/dao" and "single session/multi session"
+#: src/tasks/cdw_task.c:661
+msgid "Cannot guess allowed modes for the disc, can't write to the disc. Try with different disc type."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:1061
+msgid "cdw can't write image file to non-empty disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:1064
+msgid "cdw can't write to non-empty DVD+R DL disc."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/tasks/cdw_task.c:1067
+msgid "cdw can't write to non-empty DVD-R or DVD+R disc with current tool. Please adjust your settings in Configuration -> Tools."
+msgstr ""
+
+#. 2TRANS: this is a message in dialog window
+#: src/tasks/cdw_task.c:1109
+msgid "cdw can't recognize tool previously used to burn to this disc. You may experience serious trouble (including data loss) if you decide to continue."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "tools" means "cdrecord", "growisofs" etc.
+#: src/tasks/cdw_task.c:1644
+msgid "cdw can't find in your system any tools for handling CD discs. Current action can't be performed."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "tools" means "cdrecord", "growisofs" etc.
+#: src/tasks/cdw_task.c:1654
+msgid "cdw can't find in your system any tools for handling DVD discs. Current action can't be performed."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window;
+#. "tools" means "mkisofs", "xorriso" etc.
+#: src/tasks/cdw_task.c:1667
+msgid "cdw can't find in your system any tools for creating ISO9660 files. Current action can't be performed."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/user_interface/cdw_erase_wizard.c:184
+#: src/user_interface/cdw_verify_wizard.c:136
+msgid "ERROR"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/user_interface/cdw_erase_wizard.c:186
+#: src/user_interface/cdw_verify_wizard.c:138
+msgid "Failed to create erasing wizard. Please restart cdw and try again."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/user_interface/cdw_erase_wizard.c:328
+msgid "Attempting to erase a DVD+/-RW disc"
+msgstr ""
+
+#. 2TRANS: this is warning message in dialog window.
+#. User can press OK or Cancel button.
+#: src/user_interface/cdw_erase_wizard.c:331
+msgid "This will (partially) erase information from disc making it unreadable. The process may take some time. You don't have to erase DVD+RW or DVD-RW Restricted Overwrite disc to create new compilation - just choose \"Start new, appendable disc\" in Write wizard. Do you want to continue with erasing?"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/user_interface/cdw_erase_wizard.c:340
+msgid "Attempting to erase a DVD-RW disc"
+msgstr ""
+
+#. 2TRANS: this is warning message in dialog window.
+#. User can press OK or Cancel button.
+#: src/user_interface/cdw_erase_wizard.c:343
+msgid "This will (partially) erase information from disc making it unreadable. The process may take some time. Excessive erasing of DVD may limit lifetime of media. Do you want to continue with erasing?"
+msgstr ""
+
+#. 2TRANS: this is title of wizard window; "erase" as in
+#. "Erasing an optical disc"
+#: src/user_interface/cdw_erase_wizard.c:393
+msgid "Erase wizard"
+msgstr ""
+
+#. 2TRANS: this is tip at the bottom of window - user can
+#. switch between window elements using tab key
+#. 2TRANS: this is tip at the bottom
+#. of window - user can switch between
+#. window elements using tab key
+#. 2TRANS: this is tip at the bottom of window - user can
+#. switch between window elements using tab key
+#: src/user_interface/cdw_erase_wizard.c:396
+#: src/user_interface/cdw_iso9660_wizard.c:312
+#: src/user_interface/cdw_verify_wizard.c:275
+#: src/user_interface/cdw_write_wizard.c:665
+msgid "Use 'Tab' key to move"
+msgstr ""
+
+#. 2TRANS: this is message to user: current action will
+#. be erasing "%s" disc, where "%s" is DVD or CD
+#: src/user_interface/cdw_erase_wizard.c:416
+#, c-format
+msgid "Select parameters for erasing %s disc"
+msgstr ""
+
+#. 2TRANS: this is label in erase wizard
+#: src/user_interface/cdw_erase_wizard.c:461
+msgid "Mode of erasing:"
+msgstr ""
+
+#. 2TRANS: this is label in erase wizard
+#: src/user_interface/cdw_erase_wizard.c:465
+msgid "Speed of erasing:"
+msgstr ""
+
+#. 2TRANS: this is label in erase wizard, it's about target
+#. format for a DVD-RW disc
+#: src/user_interface/cdw_erase_wizard.c:470
+msgid "Format of DVD-RW:"
+msgstr ""
+
+#. 2TRANS: this is label of checkbox; "tray" is a tray of CD burner; "erasing" refers to blanking of optical disc
+#: src/user_interface/cdw_erase_wizard.c:475
+msgid "Eject tray after erasing"
+msgstr ""
+
+#. 2TRANS: button label, it refers to erasing optical disc
+#: src/user_interface/cdw_erase_wizard.c:478
+msgid "Erase"
+msgstr ""
+
+#. 2TRANS: this string means "perform erasing in fast mode"
+#: src/user_interface/cdw_erase_wizard.c:515
+#: src/user_interface/cdw_erase_wizard.c:523
+msgid "Erase in fast mode"
+msgstr ""
+
+#. 2TRANS: this string means "erase all data from disc"
+#: src/user_interface/cdw_erase_wizard.c:525
+msgid "Erase all content (long time)"
+msgstr ""
+
+#. 2TRANS: this is label in dropdown: it means "don't change
+#. format of DVD-RW during process of erasing disc"
+#: src/user_interface/cdw_erase_wizard.c:593
+msgid "Don't change format of DVD-RW"
+msgstr ""
+
+#. 2TRANS: this is label in dropdown: 'Sequential' is one of two
+#. possible formats of DVD-RW
+#: src/user_interface/cdw_erase_wizard.c:596
+msgid "Change format to Sequential"
+msgstr ""
+
+#. 2TRANS: this is label in dropdown: 'Restricted' is one of two
+#. possible formats of DVD-RW
+#: src/user_interface/cdw_erase_wizard.c:599
+msgid "Change format to Restricted"
+msgstr ""
+
+#. 2TRANS: this is message at the
+#. bottom of help window
+#: src/user_interface/cdw_help.c:54
+msgid "Press ESCAPE to close window"
+msgstr ""
+
+#. 2TRANS: this is label explaining content of help window
+#: src/user_interface/cdw_help.c:63
+msgid "Hotkeys available in main window:"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "show this help window";
+#. keep position of '-'
+#: src/user_interface/cdw_help.c:67
+msgid "F1, H, ?  - Show this help"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "show window displaying cdw
+#. license"; keep position of '-'
+#: src/user_interface/cdw_help.c:70
+msgid "F9 / F10  - Show license of this program"
+msgstr ""
+
+#. 2TRANS: this is hotkey label; keep position of '-'
+#: src/user_interface/cdw_help.c:72
+msgid "C         - Show Configuration window"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "show window with some
+#. disc meta-data"; keep position of '-'
+#: src/user_interface/cdw_help.c:75
+msgid "D         - Show information about disc"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "eject tray of your
+#. CD/DVD drive"; keep position of '-'
+#: src/user_interface/cdw_help.c:78
+msgid "E         - Eject drive tray"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "burn files that you
+#. selected to optical disc"; keep position of '-'
+#: src/user_interface/cdw_help.c:81
+msgid "F         - Write selected files to disc"
+msgstr ""
+
+#. 2TRANS: this is hotkey label, it means "copy tracks from audio
+#. or data CD to your hard disc"; keep position of '-'
+#: src/user_interface/cdw_help.c:84
+msgid "G         - Read content of CD"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "burn ISO9660 file
+#. to optical disc"; keep position of '-'
+#: src/user_interface/cdw_help.c:87
+msgid "I         - Write ISO image to disc"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "show window displaying
+#. log file of cdw program"; keep position of '-'
+#: src/user_interface/cdw_help.c:90
+msgid "L         - Show log file"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "read some information about disc that
+#. is in drive and display it in app window"; keep position of '-'
+#: src/user_interface/cdw_help.c:93
+msgid "R         - Refresh information about disc"
+msgstr ""
+
+#. 2TRANS: this is hotkey label: "verify data in disc
+#. or on optical media
+#: src/user_interface/cdw_help.c:96
+msgid "V         - Verify data"
+msgstr ""
+
+#. 2TRANS: this is hotkey label, it means
+#. "close application"; keep position of '-'
+#: src/user_interface/cdw_help.c:99
+msgid "Q         - Quit cdw"
+msgstr ""
+
+#. 2TRANS: this is label explaining content of help window
+#: src/user_interface/cdw_help.c:104
+msgid "Hotkeys available in other places:"
+msgstr ""
+
+#. 2TRANS: this is label in a window, describing hotkeys
+#: src/user_interface/cdw_help.c:106
+msgid "'Q', 'q' and 'Escape' - 'close'/'quit' action"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:137
+msgid "Press ESC to close window"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:138
+msgid "->     - Step into catalogized files window"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:139
+msgid "<-     - Step into menu window"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:140
+msgid "ENTER  - Change category or disk or directory"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:141
+msgid "BSPACE"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:142
+msgid "/      - Move one level up"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:143
+msgid "DEL    - Delete category or disk"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:144
+msgid "A      - Add disk into catalog"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:145
+msgid "S      - Show all disks"
+msgstr ""
+
+#: src/user_interface/cdw_help.c:146
+msgid "Q      - Quit Disk catalog"
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:168
+msgid "Select files from hard drive for further processing."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:172
+msgid "Deselect files from list using Delete key."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:176
+msgid "Create ISO9660 image from selected files."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:180
+msgid "Copy content of optical disc to to your hard drive."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:184
+msgid "Write selected files to optical disc."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:188
+msgid "Write ISO9660 image file to optical disc."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:192
+msgid "Blank CD-RW or DVD+/-RW disc. Reformat DVD-RW disc."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:196
+msgid "Calculate a digest of a file or data on optical disc."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:200
+msgid "cdw configuration: hardware, external tools and other."
+msgstr ""
+
+#. 2TRANS: this is tooltip displayed at the bottom of main cdw window
+#: src/user_interface/cdw_help.c:204
+msgid "Close this program, return to command line session."
+msgstr ""
+
+#. 2TRANS: this is title of wizard
+#. window; "write" as in
+#. 'writing to optical disc"
+#: src/user_interface/cdw_iso9660_wizard.c:308
+msgid "ISO9660 wizard"
+msgstr ""
+
+#. 2TRANS: this is label next to input field, where user can enter a label describing created ISO9660 volume
+#: src/user_interface/cdw_iso9660_wizard.c:337
+#: src/user_interface/cdw_write_wizard.c:771
+msgid "Volume ID:"
+msgstr ""
+
+#. 2TRANS: this is label next to input field, where user can specify path to ISO9660 file
+#: src/user_interface/cdw_iso9660_wizard.c:341
+msgid "ISO9660 image file:"
+msgstr ""
+
+#. 2TRANS: this is label of a button that opens configuration window; "more options" related to creating ISO9660 file
+#: src/user_interface/cdw_iso9660_wizard.c:347
+msgid "More options"
+msgstr ""
+
+#. 2TRANS: button label, it refers to writing to optical disc
+#: src/user_interface/cdw_iso9660_wizard.c:350
+msgid "Create"
+msgstr ""
+
+#. 2TRANS: label of a tab in configuration window with options related to ISO9660; probably you don't want to translate this
+#: src/user_interface/cdw_iso9660_wizard.c:517
+#: src/user_interface/cdw_iso9660_wizard.c:519
+#: src/user_interface/cdw_write_wizard.c:905
+#: src/user_interface/cdw_write_wizard.c:907
+msgid "ISO9660"
+msgstr ""
+
+#. 2TRANS: label of a tab in configuration window with options related to meta information of ISO9660 file system
+#: src/user_interface/cdw_iso9660_wizard.c:521
+#: src/user_interface/cdw_iso9660_wizard.c:523
+msgid "Meta data"
+msgstr ""
+
+#. 2TRANS: this is title of cdw options main window
+#: src/user_interface/cdw_iso9660_wizard.c:547
+msgid "ISO9660 options"
+msgstr ""
+
+#. 2TRANS: label of item main menu: Add files from file system to
+#. list of files that will be written to CD or to image files
+#: src/user_interface/cdw_main_window.c:327
+msgid " Add files "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: Remove dir(s)/file(s) from
+#. list of files that will be written to CD or to image files
+#: src/user_interface/cdw_main_window.c:330
+msgid " Delete files "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: write
+#. selected dirs/files to optical disc
+#: src/user_interface/cdw_main_window.c:333
+msgid " Write files to disc "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: create ISO9660 image file
+#. using selected files/directories
+#: src/user_interface/cdw_main_window.c:336
+msgid " Create image "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: write (burn) ISO9660 image
+#. file to optical disc
+#: src/user_interface/cdw_main_window.c:339
+msgid " Write image to disc "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: read content of
+#. your audio CD / data CD / data DVD and write it to hard drive
+#: src/user_interface/cdw_main_window.c:342
+msgid " Read disc "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: erase content of optical disc
+#: src/user_interface/cdw_main_window.c:344
+msgid " Erase disc "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: perform verification of data
+#: src/user_interface/cdw_main_window.c:346
+msgid " Verify data "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: change configuration of cdw
+#: src/user_interface/cdw_main_window.c:348
+msgid " Configuration "
+msgstr ""
+
+#. 2TRANS: label of item in main menu: exit cdw
+#: src/user_interface/cdw_main_window.c:350
+msgid " Quit "
+msgstr ""
+
+#. 2TRANS: this is title of biggest area in
+#. cdw UI that shows files selected for
+#. writing to cd or image file
+#: src/user_interface/cdw_main_window.c:479
+msgid "Selected files"
+msgstr ""
+
+#. 2TRANS: "No drive" means "no optical drive
+#. detected by cdw", "?" means that cdw is not
+#. 100% sure about this; keep short
+#: src/user_interface/cdw_main_window.c:593
+msgid "No drive (?)"
+msgstr ""
+
+#. 2TRANS: this is a hint about a hot key; keep short;
+#. "refresh" means - (re)read disc information and display
+#. it in disc information area
+#: src/user_interface/cdw_main_window.c:598
+msgid "'R' key - refresh"
+msgstr ""
+
+#. 2TRANS: this is string displaying information
+#. about disc: 1st %s is disc type (e.g. CD-RW),
+#. 2nd %s is file system type on a disc; resulting
+#. string may look like "CD-RW / ISO9660"; keep short
+#: src/user_interface/cdw_main_window.c:609
+#, c-format
+msgid "%s / %s"
+msgstr ""
+
+#. 2TRANS: 'Empty' means that there is no data on disc;
+#. 'Y', 'N' or '?' will follow after colon; keep short
+#: src/user_interface/cdw_main_window.c:617
+msgid "Empty: "
+msgstr ""
+
+#: src/user_interface/cdw_main_window.c:618
+#: src/user_interface/cdw_main_window.c:626
+#: src/user_interface/cdw_main_window.c:629
+#: src/user_interface/cdw_main_window.c:637
+#: src/user_interface/cdw_main_window.c:648
+#: src/user_interface/cdw_main_window.c:649
+#: src/user_interface/cdw_main_window.c:650
+#, c-format
+msgid "%s"
+msgstr ""
+
+#. 2TRANS: 'Writable' means that it is possible to write to disc;
+#. 'Y', 'N' or '?' will follow after colon; keep short
+#: src/user_interface/cdw_main_window.c:624
+msgid "Writable: "
+msgstr ""
+
+#. 2TRANS: "Erasable" means: 'content can be blanked/erased/wiped out'
+#. 'Y' or 'N' will follow after colon; keep short
+#: src/user_interface/cdw_main_window.c:636
+msgid "Erasable: "
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/user_interface/cdw_main_window.c:771
+msgid "One or more of selected files may be missing. Check log file for more information - press 'L' key in main window."
+msgstr ""
+
+#. 2TRANS: '%d' is a number of new files selected for
+#. burning, '%.1f' is a size of the files; keep tilde
+#. ('~') char or equivalent, as exact size of selected
+#. files is not 100% precise
+#: src/user_interface/cdw_main_window.c:835
+#, c-format
+msgid "Selected files (%d): ~%.1f MB"
+msgstr ""
+
+#. 2TRANS: '%d' is a number of new files selected for
+#. burning, '%.1f' is a size of the files;
+#: src/user_interface/cdw_main_window.c:838
+#, c-format
+msgid "Selected files (%d): %.1f MB"
+msgstr ""
+
+#. 2TRANS: this is information about disc usage
+#. and capacity: '%.1f' is size of data on disc,
+#. '%d' is a capacity (total size) of disc; keep
+#. tilde ('~') char or equivalent, as exact sizes
+#. are not 100% precise
+#: src/user_interface/cdw_main_window.c:848
+#, c-format
+msgid "On disc: ~%.1f / ~%d MB"
+msgstr ""
+
+#. 2TRANS: this is information about available
+#. space left on disc; keep tilde ('~') char
+#. or equivalent
+#: src/user_interface/cdw_main_window.c:870
+#, c-format
+msgid "Free space: ~%.1f MB"
+msgstr ""
+
+#. 2TRANS: this is information about available
+#. space left on disc: 0 MB, i.e. no space left
+#: src/user_interface/cdw_main_window.c:877
+msgid "Free space: 0 MB"
+msgstr ""
+
+#. 2TRANS: this is information about usage of disc space:
+#. '%2.1f%%' is information about used space, displayed
+#. as percentage of total disc size; keep tilde ('~') char
+#. or equivalent
+#: src/user_interface/cdw_main_window.c:888
+#, c-format
+msgid "~%2.1f%%"
+msgstr ""
+
+#. 2TRANS: this is information about usage of CD space:
+#. '%2.1f%%' is information about used space, displayed
+#. as percentage of total disc size
+#: src/user_interface/cdw_main_window.c:888
+#: src/user_interface/cdw_main_window.c:1233
+#, c-format
+msgid "%2.1f%%"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/user_interface/cdw_main_window.c:934
+msgid "No files to delete"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window. User
+#. wants to deselect files from list, but there
+#. are no files at this time
+#: src/user_interface/cdw_main_window.c:938
+msgid "Nothing to delete - no files selected."
+msgstr ""
+
+#. 2TRANS: this is title of area showing basic info (total
+#. size, CD usage) about selected files
+#: src/user_interface/cdw_main_window.c:985
+msgid "ISO volume"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window showing cdw license
+#: src/user_interface/cdw_main_window.c:1013
+msgid "License"
+msgstr ""
+
+#. 2TRANS: this is standard information about licensing
+#. program under GPL; it may be non-translatable in your area
+#: src/user_interface/cdw_main_window.c:1028
+msgid ""
+"This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n"
+"\n"
+"This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n"
+"\n"
+"You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"
+msgstr ""
+
+#. 2TRANS: this is title of dialog window, in which
+#. basic information about licensing is displayed
+#: src/user_interface/cdw_main_window.c:1032
+#: src/user_interface/cdw_main_window.c:1039
+msgid "cdw license"
+msgstr ""
+
+#. 2TRANS: this is short information
+#. about licensing program under GPL;
+#. it may be non-translatable in your area
+#: src/user_interface/cdw_main_window.c:1043
+msgid "This program is distributed under terms of GNU General Public License either version 2, or (at your option) any later version. This program is distributed WITHOUT ANY WARRANTY."
+msgstr ""
+
+#. 2TRANS: this string displays total size of dirs/files
+#. selected ('%.1f'), total available space ('%d') and
+#. number of items selected (second '%d').
+#: src/user_interface/cdw_main_window.c:1212
+#, c-format
+msgid "%.1f/%ld MB in %d items"
+msgstr ""
+
+#. 2TRANS: this string displays total size of dirs/files
+#. selected ('%.1f'), total available space ('%d'), number of
+#. items selected (second '%d'), and free space left ('%.0f').
+#: src/user_interface/cdw_main_window.c:1220
+#, c-format
+msgid "%.1f/%ld MB in %d items, %.0f MB free"
+msgstr ""
+
+#. 2TRANS: this message displayed in console when program
+#. detects that requirement about console size is not met
+#. and exits; please keep '\n' chars
+#: src/user_interface/cdw_ncurses.c:155
+#, c-format
+msgid ""
+"\n"
+"Cannot start cdw: cdw needs at least 80x24 terminal!\n"
+msgstr ""
+
+#. 2TRANS: message displayed in progress window:
+#. user must press any key to close the window after
+#. task is completed
+#: src/user_interface/cdw_processwin.c:211
+msgid "Press any key"
+msgstr ""
+
+#. 2TRANS: status message displayed in progress
+#. window: %d%% is percent amount of task finished,
+#. %s is previously prepared string displaying
+#. some additional information about %d, e.g. units
+#: src/user_interface/cdw_processwin.c:490
+#, c-format
+msgid "%d%% done (%s)"
+msgstr ""
+
+#. 2TRANS: status message displayed in progress
+#. window: %d%% is percent amount of task finished
+#: src/user_interface/cdw_processwin.c:495
+#, c-format
+msgid "%d%% done"
+msgstr ""
+
+#. 2TRANS: this is message displayed in progress window, describing
+#. FIFO buffer usage (in percents) during some resources-consuming
+#. tasks
+#: src/user_interface/cdw_processwin.c:611
+#, c-format
+msgid "FIFO: %3.d%%"
+msgstr ""
+
+#. 2TRANS: this is message displayed in process progress window;
+#. "Speed" is writing speed, %d and %d are decimal and fractional
+#. parts of writing speed, e.g. "Speed: 2.5x"
+#: src/user_interface/cdw_processwin.c:646
+#, c-format
+msgid "Speed: %2d.%dx"
+msgstr ""
+
+#. 2TRANS: this is help text displayed at the bottom of text file
+#. viewer window: it explains which keys can be used
+#: src/user_interface/cdw_text_file_viewer.c:301
+msgid "Use ESC to close, use arrows, Home and End to move"
+msgstr ""
+
+#. 2TRANS: this is title of wizard window; "verify" as in
+#. "Erasing an optical disc"
+#: src/user_interface/cdw_verify_wizard.c:272
+msgid "Verify wizard"
+msgstr ""
+
+#. 2TRANS: button label, "verify" means "verify data"
+#: src/user_interface/cdw_verify_wizard.c:330
+msgid "Verify"
+msgstr ""
+
+#. 2TRANS: this is a label in dropdown list; digest is an output of tools such as md5sum or sha512 sum
+#: src/user_interface/cdw_verify_wizard.c:365
+msgid "Calculate digest of a file"
+msgstr ""
+
+#. 2TRANS: this is a label in dropdown list; "disc" is an optical disc
+#: src/user_interface/cdw_verify_wizard.c:375
+msgid "Verify first track of a disc"
+msgstr ""
+
+#. 2TRANS: this is a label in dropdown list; "disc" is an optical disc
+#: src/user_interface/cdw_verify_wizard.c:383
+msgid "Compare a disc against a file (experimental)"
+msgstr ""
+
+#. 2TRANS: this is message printed in a wizard;
+#: src/user_interface/cdw_verify_wizard.c:426
+msgid "Select what you want to verify. Verification algorithm (md5sum, sha1sum etc.) can be changed in main window -> Configuration -> Tools -> Digest tool."
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:321
+msgid "Start new, appendable disc"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:323
+msgid "Create non-appendable disc"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:325
+msgid "Append data, don't close disc"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:327
+msgid "Append data and close disc"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - some error occurred
+#: src/user_interface/cdw_write_wizard.c:329
+#: src/user_interface/cdw_write_wizard.c:399
+msgid "(ERROR)"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:381
+msgid "Unspecified"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:383
+msgid "TAO"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:385
+msgid "DAO"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:387
+msgid "SAO"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:390
+msgid "RAW"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:392
+msgid "RAW96R"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:394
+msgid "RAW96P"
+msgstr ""
+
+#. 2TRANS: label visible in dropdown menu - mode of writing data to optical disc
+#: src/user_interface/cdw_write_wizard.c:396
+msgid "RAW16"
+msgstr ""
+
+#. 2TRANS: this is title of wizard window; 'write' as in
+#. 'writing to optical disc
+#: src/user_interface/cdw_write_wizard.c:662
+msgid "Write wizard"
+msgstr ""
+
+#. 2TRANS: this is message to user: current action will
+#. be writing to %s, where %s is DVD or CD
+#: src/user_interface/cdw_write_wizard.c:683
+#, c-format
+msgid "You are writing to %s disc"
+msgstr ""
+
+#. 2TRANS: this is a button label of a button that opens configuration window
+#: src/user_interface/cdw_write_wizard.c:762
+msgid "Other options"
+msgstr ""
+
+#. 2TRANS: this is a label in write wizard, after which a writing speed selection list will be displayed
+#: src/user_interface/cdw_write_wizard.c:775
+msgid "Writing speed:"
+msgstr ""
+
+#. 2TRANS: this is a label in write wizard, after which a session writing mode selection list will be displayed
+#: src/user_interface/cdw_write_wizard.c:779
+msgid "Session writing mode:"
+msgstr ""
+
+#. 2TRANS: this is a label in write wizard, after which a disc writing mode selection list will be displayed
+#: src/user_interface/cdw_write_wizard.c:783
+msgid "Disc writing mode:"
+msgstr ""
+
+#. 2TRANS: this is label next to checkbox; marked checkbox enables verification of correctness of writing to CD; this feature is experimental
+#: src/user_interface/cdw_write_wizard.c:787
+msgid "Verify write (experimental)"
+msgstr ""
+
+#. 2TRANS: this is checkbox label: keep no longer than original; "Dummy write" means attempting to write
+#. to a disc and performing all normal operations (just for a try), but without actual burning
+#: src/user_interface/cdw_write_wizard.c:792
+msgid "Dummy write"
+msgstr ""
+
+#. 2TRANS: this is a checkbox label; "tray" is a tray of optical drive; "writing" is burning to optical disc
+#: src/user_interface/cdw_write_wizard.c:796
+msgid "Eject tray after writing"
+msgstr ""
+
+#. 2TRANS: button label, it refers to writing to optical disc
+#. 2TRANS: label of a tab in configuration window with options related burning
+#: src/user_interface/cdw_write_wizard.c:803
+#: src/user_interface/cdw_write_wizard.c:899
+#: src/user_interface/cdw_write_wizard.c:901
+#: src/user_interface/cdw_write_wizard.c:903
+msgid "Write"
+msgstr ""
+
+#. 2TRANS: this is title of cdw options main window
+#: src/user_interface/cdw_write_wizard.c:936
+msgid "Write options"
+msgstr ""
+
+#. 2TRANS: button label, please keep as short as possible
+#: src/user_interface/widgets/cdw_dialog.c:576
+msgid "Yes"
+msgstr ""
+
+#. 2TRANS: button label, please keep as short as possible
+#: src/user_interface/widgets/cdw_dialog.c:578
+msgid "No"
+msgstr ""
+
+#. 2TRANS: this is error message in dialog window, "%s" is
+#. string with single insecure character; keep short
+#: src/user_interface/widgets/cdw_input_line.c:332
+#, c-format
+msgid "ERROR: insecure char %s "
+msgstr ""
+
+#. 2TRANS: this is error message in dialog window, "%s" is
+#. string with single insecure character; keep short
+#: src/user_interface/widgets/cdw_input_line.c:335
+#, c-format
+msgid "Insecure char %s "
+msgstr ""
+
+#. 2TRANS: this is error message in dialog window, "%s" is
+#. string with single insecure character; keep short
+#: src/user_interface/widgets/cdw_input_line.c:338
+#, c-format
+msgid "Insec. char %s"
+msgstr ""
+
+#. 2TRANS: this is header printed in log file;
+#. first %s is program name, second %s is program version
+#: src/utilities/cdw_logging.c:270
+#, c-format
+msgid "   ::: Log file for %s %s :::   "
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:360
+msgid "Path to CDW log file has been reset. You may want to check current path in Configuration -> Log."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:390
+msgid "Enter path to directory on another device."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:393
+msgid "Enter non-empty path to initial (e.g. Home) directory."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:396
+msgid "Enter valid path to directory to store cdw log file."
+msgstr ""
+
+#. 2TRANS: this is title of dialog window
+#: src/utilities/cdw_logging.c:400
+msgid "Configuring cdw..."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:448
+msgid "Too little space left on disc, can't write to log file."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:454
+msgid "Path to log file is empty, can't open file."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:460
+msgid "Path to log file is invalid, can't open file"
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:466
+msgid "cdw can't configure its log file. Please restart the program."
+msgstr ""
+
+#. 2TRANS: this is message in dialog window
+#: src/utilities/cdw_logging.c:554
+msgid "Cannot show log file. Unknown error occurred."
+msgstr ""
+
+#. 2TRANS: this is debug message displayed in console, regcomp is a
+#. function compiling regular expressions, used in cdw code
+#: src/utilities/cdw_regex.c:177
+#, c-format
+msgid "ERROR: REGCOMP ERROR in %s(): regular expression = \"%s\", id = %lld\n"
+msgstr ""
+
+#. 2TRANS: this is a message printed to console when cdw needs to
+#. close unexpectedly. "signal" is a signal from operating system;
+#. "%s" is a signal's name; keep leading and ending "\n";
+#. use "\n" in the middle of message as needed to keep line
+#. lengths no more than 76 characters
+#: src/utilities/cdw_sys.c:239
+#, c-format
+msgid ""
+"\n"
+"\n"
+"cdw received %s signal and it needed to clean up after itself\n"
+"and leave. This may mean that there is a bug in cdw. Don't be mad...\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: error message displayed when terminal requirements are not met
+#: src/utilities/cdw_utils.c:106
+#, c-format
+msgid "Needed min 80x25 terminal!"
+msgstr ""
+
+#. 2TRANS: this is error message printed to terminal,
+#. first '%s' is name of option expecting a valid value,
+#. second '%s' is invalid value of the option
+#: src/utilities/cdw_utils.c:141
+#, c-format
+msgid "ERROR: incorrect value of option %s: \"%s\"\n"
+msgstr ""
+
+#. 2TRANS: this is error message printed to terminal,
+#. "ESC delay" is number describing time between
+#. pressing ESC key, and reaction to the key
+#: src/utilities/cdw_utils.c:149
+#, c-format
+msgid "ERROR: ESC delay can't be negative\n"
+msgstr ""
+
+#. 2TRANS: this is error message printed to terminal
+#: src/utilities/cdw_utils.c:165
+#, c-format
+msgid "ERROR: unknown option in command line\n"
+msgstr ""
+
+#. 2TRANS: this is error message printed to terminal
+#: src/utilities/cdw_utils.c:167
+#, c-format
+msgid "use '-h' option for help message\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal,
+#. first %s is program name, second %s is
+#. program version
+#: src/utilities/cdw_utils.c:185 src/utilities/cdw_utils.c:199
+#, c-format
+msgid "%s %s\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal,
+#. first %s is program name, second %s is
+#. program version
+#: src/utilities/cdw_utils.c:203
+#, c-format
+msgid "Copyright (C) 2002 - 2003 Balazs Varkonyi\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal,
+#. first %s is program name, second %s is
+#. program version
+#: src/utilities/cdw_utils.c:207
+#, c-format
+msgid ""
+"Copyright (C) 2007 - 2012 Kamil Ignacak\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this is message printed in terminal,
+#. '2+' means "version 2, or later";
+#. keep double newline character
+#: src/utilities/cdw_utils.c:211
+#, c-format
+msgid ""
+"License: GNU General Public License, version 2+\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this is help text displayed in console
+#: src/utilities/cdw_utils.c:218
+#, c-format
+msgid ""
+"Options:\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this is help text displayed in console;
+#. don't localize anything before colon
+#: src/utilities/cdw_utils.c:222
+#, c-format
+msgid "  -c | --catalog            : start in Disk Catalog mode\n"
+msgstr ""
+
+#. 2TRANS: this is help text displayed in console;
+#. don't localize anything before colon
+#: src/utilities/cdw_utils.c:226
+#, c-format
+msgid "  -h | --help               : show this message\n"
+msgstr ""
+
+#. 2TRANS: this is help text displayed in console;
+#. don't localize anything before colon
+#: src/utilities/cdw_utils.c:229
+#, c-format
+msgid "  -v | --version            : show version of this software\n"
+msgstr ""
+
+#. 2TRANS: this is help text displayed in console;
+#. don't localize anything before colon
+#: src/utilities/cdw_utils.c:232
+#, c-format
+msgid "  --escdelay=X              : modify ESC key delay period;\n"
+msgstr ""
+
+#. 2TRANS: this is help text displayed in console
+#: src/utilities/cdw_utils.c:234
+#, c-format
+msgid "                              'X' is non-negative time in milliseconds\n"
+msgstr ""
+
+#. 2TRANS: this is help text displayed in console;
+#. don't localize anything before colon
+#: src/utilities/cdw_utils.c:237
+#, c-format
+msgid "  --enable-dvd-rp-dl        : enable support for DVD+R DL;\n"
+msgstr ""
+
+#. 2TRANS: this is help text displayed in console;
+#. "buggy" refers to support of DVD+R DL discs
+#: src/utilities/cdw_utils.c:240
+#, c-format
+msgid ""
+"                              (buggy, with dvd+rw-tools only)\n"
+"\n"
+msgstr ""
+
+#. 2TRANS: this string means "unknown type or state";
+#. no more than 2 chars
+#: src/utilities/cdw_utils.c:604
+msgid "?"
+msgstr ""
+
+#. 2TRANS: "N" like in "No, the disc doesn't have this attribute";
+#. no more than 2 chars
+#: src/utilities/cdw_utils.c:607
+msgid "N"
+msgstr ""
+
+#. 2TRANS: "Y" like in "Yes, the disc has this attribute";
+#. no more than 2 chars
+#: src/utilities/cdw_utils.c:610
+msgid "Y"
+msgstr ""
+
+#. 2TRANS: ETA is Expected Time of Arrival, time to finish a task;
+#. three "??" values are number of hours, minutes seconds left,
+#. "??" are used when the time cannot be calculated.
+#. The string will be displayed in progress dialog window. Keep short.
+#: src/utilities/cdw_utils.c:715
+#, c-format
+msgid "ETA: ??:??:??"
+msgstr ""
+
+#. 2TRANS: ETA is Expected Time of Arrival, time to finish a task;
+#. three "%d" values are number of hours, minutes seconds left. The
+#. string will be displayed in progress dialog window. Keep short.
+#: src/utilities/cdw_utils.c:728
+#, c-format
+msgid "ETA: %d:%02d:%02d"
+msgstr ""
diff -Naur orig/po/de.po patched/po/de.po
--- orig/po/de.po	1970-01-01 01:00:00.000000000 +0100
+++ patched/po/de.po	2005-11-06 17:28:39.000000000 +0100
@@ -0,0 +1,980 @@
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# Sebastian Henschel <cdw@kodeaffe.de>, 2003.
+# 
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: cdw-0.2.0\n"
+"POT-Creation-Date: 2003-08-26 18:35+0200\n"
+"PO-Revision-Date: 2003-10-07 16:00+0200\n"
+"Last-Translator: Sebastian Henschel <cdw@kodeaffe.de>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: cddb.c:95 cddb.c:1122 gtk_cddb.c:105 gtk_cddb.c:905
+msgid "Enter password:"
+msgstr "Passwort eingeben:"
+
+#: cddb.c:102 gtk_cddb.c:112
+msgid "CD name"
+msgstr "Name der CD"
+
+#: cddb.c:102 gtk_cddb.c:112
+msgid "Enter CD name:"
+msgstr "Namen der CD eingeben:"
+
+#: cddb.c:103 gtk_cddb.c:113
+msgid "CD Number"
+msgstr "Nummer der CD"
+
+#: cddb.c:103 gtk_cddb.c:113
+msgid "Number of disk:"
+msgstr "Nummer der Disk:"
+
+#: cddb.c:104 gtk_cddb.c:114
+msgid "Category"
+msgstr "Kategorie"
+
+#: cddb.c:104 gtk_cddb.c:114
+msgid "Enter category:"
+msgstr "Kategorie eingeben:"
+
+#: cddb.c:106 gtk_cddb.c:116
+msgid "Mounting cdrom..."
+msgstr "Mounte cdrom..."
+
+#: cddb.c:109 gtk_cddb.c:119
+msgid "Unmounting cdrom..."
+msgstr "Entmounte cdrom..."
+
+#: cddb.c:161 cddb.c:211 cddb.c:244 cddb.c:258 cddb.c:281 cddb.c:301
+#: cddb.c:316 cddb.c:333 cddb.c:356 cddb.c:367 cddb.c:379 cddb.c:394
+#: cddb.c:401 cddb.c:415 cddb.c:423 gtk_cddb.c:195 gtk_cddb.c:228
+#: gtk_cddb.c:261 gtk_cddb.c:275 gtk_cddb.c:298 gtk_cddb.c:318 gtk_cddb.c:333
+#: gtk_cddb.c:350 gtk_cddb.c:373 gtk_cddb.c:384 gtk_cddb.c:396 gtk_cddb.c:411
+#: gtk_cddb.c:418 gtk_cddb.c:432 gtk_cddb.c:440
+msgid "Failed"
+msgstr "Fehlgeschlagen"
+
+#: cddb.c:179 gtk_cddb.c:75
+msgid "Unknown error! Check the settings!"
+msgstr "Unbekannter Fehler! berprfe die Einstellungen!"
+
+#: cddb.c:180 main.c:844
+msgid "Error"
+msgstr "Fehler"
+
+#: cddb.c:612 cddb.c:614 cddb.c:994
+msgid " Search [ ] "
+msgstr " Suche  [ ] "
+
+#: cddb.c:612
+msgid " Search [X] "
+msgstr " Suche  [X] "
+
+#: cddb.c:619 cddb.c:624 gtk_cddb.c:642 gtk_cddb.c:645
+msgid "Name: "
+msgstr "Name: "
+
+#: cddb.c:629 gtk_cddb.c:649
+msgid "Size: "
+msgstr "Gre: "
+
+#: cddb.c:634 gtk_cddb.c:652
+msgid "Type: "
+msgstr "Typ : "
+
+#: cddb.c:640 gtk_cddb.c:656
+msgid "Disk: "
+msgstr "Disk: "
+
+#: cddb.c:893 cddb.c:1185 gtk_cddb.c:864
+msgid "Are you sure do you want to delete category:"
+msgstr "Sicher, dass die Kategorie gelscht werden soll:"
+
+#: cddb.c:894 cddb.c:908 cddb.c:1186 cddb.c:1200
+msgid "Confirm"
+msgstr "Besttigen"
+
+#: cddb.c:907 cddb.c:1199 gtk_cddb.c:879
+msgid "Are you sure do you want to delete disk:"
+msgstr "Sicher, dass die CD gelscht werden soll:"
+
+#: cddb.c:954
+msgid "Disk Catalog"
+msgstr "Disk Katalog"
+
+#: cddb.c:958
+msgid " Show all disks "
+msgstr " Zeige alle Disks "
+
+#: cddb.c:959
+msgid " Add disk       "
+msgstr " Disk anfgen     "
+
+#: cddb.c:960
+msgid " Search         "
+msgstr " Suche            "
+
+#: cddb.c:961
+msgid " Delete         "
+msgstr " Lsche           "
+
+#: cddb.c:962
+msgid " Quit Catalog   "
+msgstr " Verlasse Katalog "
+
+#: cddb.c:985
+msgid "Catalog Menu"
+msgstr "Katalog Men"
+
+#: cddb.c:989 gtk_cddb.c:925
+msgid "Catalogized files"
+msgstr "Katalogisierte Dateien"
+
+#: cddb.c:1045 gtk_cddb.c:802
+msgid "Search in content"
+msgstr "Durchsuche Inhalt"
+
+#: cddb.c:1045 gtk_cddb.c:802
+msgid "Enter query string:"
+msgstr "Suchwort eingeben:"
+
+#: cddb.c:1121 gtk_cddb.c:904
+msgid "password"
+msgstr "Passwort"
+
+#: gtk_cddb.c:906 gtkgui.c:1277
+msgid "Disk catalog"
+msgstr "CD-Katalog"
+
+#: gtk_cddb.c:914
+msgid "Show all"
+msgstr "Zeige alle"
+
+#: gtk_cddb.c:914
+msgid "Show all disks"
+msgstr "Zeige alle CDs "
+
+#: gtk_cddb.c:915 gtkgui.c:1278
+msgid "Add disk"
+msgstr "CD hinzufgen"
+
+#: gtk_cddb.c:915
+msgid "Add new disk to catalog"
+msgstr "CD zum Katalog hinzufgen"
+
+#: gtk_cddb.c:916 gtk_cddb.c:939
+msgid "Search"
+msgstr "Suche"
+
+#: gtk_cddb.c:916
+msgid "Search files and directories"
+msgstr "Durchsuche Dateien und Verzeichnisse"
+
+#: gtk_cddb.c:917
+msgid "Delete"
+msgstr "Lschen"
+
+#: gtk_cddb.c:917
+msgid "Delete selected item"
+msgstr "Lsche gewhltes Element"
+
+#: gtk_cddb.c:918
+msgid "Up"
+msgstr "Hoch"
+
+#: gtk_cddb.c:918
+msgid "Go up one level"
+msgstr "Gehe eine Ebene hoch"
+
+#: gtk_cddb.c:930
+msgid "Filename/Dirname"
+msgstr "Datei-/Verzeichnisname"
+
+#: gtk_cddb.c:932 gtkgui.c:1341
+msgid "Size/Type"
+msgstr "Gre/Typ"
+
+#: gtk_thread.c:97 gtk_thread.c:225 thread.c:81 thread.c:225
+msgid "Fixating..."
+msgstr "Fixiere..."
+
+#: gtk_thread.c:124 gtk_thread.c:179 thread.c:108 thread.c:171
+#, c-format
+msgid "  Fifo: %d%%  "
+msgstr "  Fifo: %d%%  "
+
+#: gtk_thread.c:140 gtk_thread.c:189 gtk_thread.c:414 thread.c:125
+#: thread.c:183 thread.c:425
+#, c-format
+msgid "%d / %d MB done"
+msgstr "%d / %d MB fertig"
+
+#: gtk_thread.c:142 gtk_thread.c:191 thread.c:127 thread.c:185
+#, c-format
+msgid "%2.1f%% done"
+msgstr "%2.1f%% fertig"
+
+#: gtk_thread.c:152 thread.c:141
+#, c-format
+msgid "%d MB"
+msgstr "%d MB"
+
+#: gtk_thread.c:163 gtk_thread.c:213 gtkgui.c:837 gtkgui.c:851 gtkgui.c:861
+#: main.c:884 main.c:899 main.c:910 thread.c:154 thread.c:214
+#, c-format
+msgid "Track: %d"
+msgstr "Track: %d"
+
+#: gtk_thread.c:201 thread.c:199
+#, c-format
+msgid "%d MB done"
+msgstr "%d MB fertig"
+
+#: gtk_thread.c:292 gtkgui.c:697 gtkgui.c:838 gtkgui.c:852 gtkgui.c:862
+#: main.c:650 main.c:885 main.c:900 main.c:911 thread.c:292
+msgid "Grab Audio CD"
+msgstr "Grabbe Audio-CD"
+
+#: gtk_thread.c:300 thread.c:310
+msgid "done"
+msgstr "fertig"
+
+#: gtk_thread.c:308 gtk_thread.c:328 gtkgui.c:1010 main.c:1354 thread.c:325
+#: thread.c:350
+msgid "Write direct"
+msgstr "Schreibe direkt"
+
+#: gtk_thread.c:318 gtk_thread.c:337 gtk_thread.c:416 thread.c:335
+#: thread.c:359 thread.c:427
+#, c-format
+msgid "%d%% done"
+msgstr "%d%% fertig"
+
+#: gtk_thread.c:371
+msgid "Please wait..."
+msgstr "Bitte warten..."
+
+#: gtk_thread.c:443 thread.c:458
+msgid "Cannot create logfile..."
+msgstr "Kann Log nicht anlegen..."
+
+#: gtk_thread.c:456 thread.c:472
+msgid "Fork Failure\n"
+msgstr "Fehler beim Fork\n"
+
+#: gtkgui.c:122
+msgid "About"
+msgstr "ber"
+
+#: gtkgui.c:198
+msgid "Log window"
+msgstr "Log-Fenster"
+
+#: gtkgui.c:206 gtkgui.c:681 gtkgui.c:975 main.c:629 main.c:1163 main.c:1315
+msgid "Load CD info..."
+msgstr "Lade CD-Info..."
+
+#: gtkgui.c:207 gtkgui.c:1274 main.c:1164
+msgid "CD info"
+msgstr "CD-Info"
+
+#: gtkgui.c:213 gtkgui.c:890 gtkgui.c:958 gtkgui.c:1023 main.c:1136
+#: main.c:1229
+msgid "Volume ID"
+msgstr "Volume ID"
+
+#: gtkgui.c:213 gtkgui.c:890 gtkgui.c:958 gtkgui.c:1023 main.c:1136
+#: main.c:1229
+msgid "Enter volume label:"
+msgstr "Volume-Etikett eingeben:"
+
+#: gtkgui.c:219 main.c:1142
+msgid "CD record parameters"
+msgstr "Parameter fr Aufnahme"
+
+#: gtkgui.c:219 main.c:1142
+msgid "Enter parameter:"
+msgstr "Parameter eingeben:"
+
+#: gtkgui.c:229 main.c:544
+msgid "CD size"
+msgstr "Gre der CD"
+
+#: gtkgui.c:235
+msgid "Select CD size:"
+msgstr "CD-Gre whlen"
+
+#: gtkgui.c:307 gtkgui.c:1086
+msgid "Select files"
+msgstr "Whle Dateien"
+
+#: gtkgui.c:389 options.c:968
+msgid "Options"
+msgstr "Optionen"
+
+#: gtkgui.c:399
+msgid "SCSI device"
+msgstr "SCSI-Gert"
+
+#: gtkgui.c:400
+msgid "Image file"
+msgstr "Image-Datei"
+
+#: gtkgui.c:401
+msgid "Logfile"
+msgstr "Logdatei"
+
+#: gtkgui.c:402
+msgid "CD-ROM device"
+msgstr "CD-ROM Laufwerk"
+
+#: gtkgui.c:403
+msgid "CD-RW device"
+msgstr "CD-RW Laufwerk"
+
+#: gtkgui.c:405
+msgid "Write CD from image"
+msgstr "Schreibe CD von Image"
+
+#: gtkgui.c:406
+msgid "Blank fast"
+msgstr "Schnell lschen"
+
+#: gtkgui.c:407
+msgid "Eject CD tray when finished"
+msgstr "CD-Schublade auswerfen wenn fertig"
+
+#: gtkgui.c:408
+msgid "Disk at once"
+msgstr "Disk at once"
+
+#: gtkgui.c:409
+msgid "Joliet information"
+msgstr "Joliet-Informationen"
+
+#: gtkgui.c:410
+msgid "Rock Ridge"
+msgstr "Rock Ridge"
+
+#: gtkgui.c:411
+msgid "Usefull Rock Ridge attributes"
+msgstr "Sinnvolle Rock Ridge-Attribute"
+
+#: gtkgui.c:412
+msgid "Dummy write"
+msgstr "Dummy-Modus"
+
+#: gtkgui.c:413 gtkgui.c:1215
+msgid "Speed"
+msgstr "Geschwindigkeit"
+
+#: gtkgui.c:414
+msgid "Show log after write"
+msgstr "Zeige Log nach Schreiben"
+
+#: gtkgui.c:415
+msgid "Auto show volume edit dialog"
+msgstr "Auto-Zeige Bearbeiten-Dialog"
+
+#: gtkgui.c:416
+msgid "Pad"
+msgstr "Auffllen"
+
+#: gtkgui.c:417
+msgid "Write in multi-session"
+msgstr "Schreibe Multi-session"
+
+#: gtkgui.c:418
+msgid "Burnproof"
+msgstr "Burnproof"
+
+#: gtkgui.c:419
+msgid "Auto disk catalog"
+msgstr "Auto-CD-Katalog"
+
+#: gtkgui.c:420 gtkgui.c:725
+msgid "Grab stereo mode"
+msgstr "Grabbe in Stereo"
+
+#: gtkgui.c:421 gtkgui.c:726
+msgid "Echo to soundcard"
+msgstr "Echo zur Soundkarte"
+
+#: gtkgui.c:422 gtkgui.c:727
+msgid "High quality"
+msgstr "Hohe Qualitt"
+
+#: gtkgui.c:423 gtkgui.c:728
+msgid "Encode audio:"
+msgstr "Enkodiere Audio:"
+
+#: gtkgui.c:424
+msgid "CD mountpoint"
+msgstr "CD Mountpunkt"
+
+#: gtkgui.c:425
+msgid "MySQL host"
+msgstr "MySQL-Host"
+
+#: gtkgui.c:426
+msgid "MySQL user"
+msgstr "MySQL-User"
+
+#: gtkgui.c:427
+msgid "Audio directory"
+msgstr "Audio-Verzeichnis"
+
+#: gtkgui.c:428 gtkgui.c:729
+msgid "Bits per channel"
+msgstr "Bits pro Kanal"
+
+#: gtkgui.c:429 gtkgui.c:730
+msgid "Bitrate"
+msgstr "Bitrate"
+
+#: gtkgui.c:430 gtkgui.c:731
+msgid "Encode to Ogg Vorbis"
+msgstr "Enkodiere zu OggVorbis"
+
+#: gtkgui.c:431 gtkgui.c:732
+msgid "Encode to MP3"
+msgstr "Enkodiere zu MP3"
+
+#: gtkgui.c:432 gtkgui.c:733
+msgid "Encode to:"
+msgstr "Enkodiere zu:"
+
+#: gtkgui.c:684 gtkgui.c:977 log.c:142 main.c:633 main.c:1318
+msgid "Cannot open file..."
+msgstr "Kann Datei nicht ffnen..."
+
+#: gtkgui.c:706
+msgid "Number of tracks: "
+msgstr "Anzahl der Tracks:"
+
+#: gtkgui.c:709 gtkgui.c:717
+msgid "Start track"
+msgstr "Start-Track"
+
+#: gtkgui.c:711 gtkgui.c:719
+msgid "End track"
+msgstr "End-Track"
+
+#: gtkgui.c:715 main.c:657
+msgid "No audio CD!"
+msgstr "Keine Audio-CD!"
+
+#: gtkgui.c:787 main.c:842
+msgid ""
+"Audio directory not exist!\n"
+"Do you wish to create?"
+msgstr ""
+"Audio-Verzeichnis existiert nicht!\n"
+"Soll es erzeugt werden?"
+
+#: gtkgui.c:904 gtkgui.c:927 main.c:1248 main.c:1263
+msgid ""
+"Image file exist!\n"
+"Do you wish to overwrite it?"
+msgstr ""
+"Image-Datei existiert!\n"
+"Soll sie berschrieben werden?"
+
+#: gtkgui.c:908 gtkgui.c:1291 main.c:1252
+msgid "Create image"
+msgstr "Image erzeugen"
+
+#: gtkgui.c:917 gtkgui.c:1296 main.c:1411
+msgid "Blank CD-RW"
+msgstr "Lsche CD-RW"
+
+#: gtkgui.c:931 gtkgui.c:1292 main.c:1267
+msgid "Copy CD image"
+msgstr "Kopiere CD-Image"
+
+#: gtkgui.c:951 main.c:1286
+msgid "Write image"
+msgstr "Schreibe Image"
+
+#: gtkgui.c:1011
+msgid "Write direct log"
+msgstr "Log: Schreibe direkt"
+
+#: gtkgui.c:1039 main.c:1383
+msgid "Write audio"
+msgstr "Schreibe Audio"
+
+#: gtkgui.c:1040
+msgid "Write audio log"
+msgstr "Log: Schreibe Audio"
+
+#: gtkgui.c:1060 gtkgui.c:1295 main.c:1402
+msgid "Copy data CD"
+msgstr "Kopiere Daten-CD"
+
+#: gtkgui.c:1061
+msgid "Copy data CD log"
+msgstr "Log: Kopiere Daten-CD"
+
+#: gtkgui.c:1151 main.c:613
+#, c-format
+msgid "Used: %2.1f%%, Wasted: %.0f/%d MB"
+msgstr "Verbrauch: %2.1f%%, Verschnitt: %.0f/%d MB"
+
+#: gtkgui.c:1154 main.c:615
+#, c-format
+msgid "Used: %2.1f%%, Wasted: %d MB"
+msgstr "Verbrauch: %2.1f%%, Verschnitt: %d MB"
+
+#: gtkgui.c:1203 main.c:957
+#, c-format
+msgid "Size: %.0f Mb in %d files"
+msgstr "Gre: %.0f MB in %d Dateien"
+
+#: gtkgui.c:1212 main.c:104
+msgid "Write from image"
+msgstr "Schreibe von Image"
+
+#: gtkgui.c:1214 main.c:106
+msgid "Write direct    "
+msgstr "Schreibe direkt "
+
+#: gtkgui.c:1218 main.c:109
+msgid "Multi-session "
+msgstr "Multi-Session "
+
+#: gtkgui.c:1220 main.c:111
+msgid "Single session"
+msgstr "Single-Session"
+
+#: gtkgui.c:1270
+msgid "CD label"
+msgstr "Etikett der CD"
+
+#: gtkgui.c:1270
+#, fuzzy
+msgid "Display CD label editor window"
+msgstr "Zeige Fenster zum Bearbeiten der CD-Etiketten"
+
+#: gtkgui.c:1271
+msgid "Parameters"
+msgstr "Parameter"
+
+#: gtkgui.c:1271
+msgid "Edit cdrecord parameters"
+msgstr "Parameter fr cdrecord bearbeiten"
+
+#: gtkgui.c:1272
+msgid "CD Size"
+msgstr "Gre der CD"
+
+#: gtkgui.c:1272
+msgid "Select the size of disk"
+msgstr "Gre der CD auswhlen"
+
+#: gtkgui.c:1273
+msgid "Log"
+msgstr "Log"
+
+#: gtkgui.c:1273
+msgid "Display the content of log"
+msgstr "Zeige den Inhalt des Logs"
+
+#: gtkgui.c:1274
+msgid "Display information about CD"
+msgstr "Zeige Informationen ber die CD"
+
+#: gtkgui.c:1275
+msgid "Eject CD"
+msgstr "CD auswerfen"
+
+#: gtkgui.c:1275
+msgid "Eject CD tray"
+msgstr "CD-Schublade auswerfen"
+
+#: gtkgui.c:1277
+msgid "Display disk catalog"
+msgstr "Zeige CD-Katalog"
+
+#: gtkgui.c:1278
+msgid "Add CD to disk catalog"
+msgstr "CD zu Katalog hinzufgen"
+
+#: gtkgui.c:1280
+msgid "CD rip"
+msgstr "CD rip"
+
+#: gtkgui.c:1280
+msgid "Rip Audio CD"
+msgstr "Rippe Audio-CD"
+
+#: gtkgui.c:1281 help.c:38 help.c:69
+msgid "Help"
+msgstr "Hilfe"
+
+#: gtkgui.c:1281
+msgid "Display help window"
+msgstr "Zeige Hilfe-Fenster"
+
+#: gtkgui.c:1283 main.c:448
+msgid "Menu"
+msgstr "Men"
+
+#: gtkgui.c:1289
+msgid "Add files..."
+msgstr "Dateien hinzufgen"
+
+#: gtkgui.c:1290
+msgid "Delete files"
+msgstr "Lsche Dateien"
+
+#: gtkgui.c:1293
+msgid "Write data CD"
+msgstr "Schreibe Daten-CD"
+
+#: gtkgui.c:1294
+msgid "Write audio CD"
+msgstr "Schreibe Audio-CD"
+
+#: gtkgui.c:1297
+msgid "Options..."
+msgstr "Optionen..."
+
+#: gtkgui.c:1298
+msgid "Quit"
+msgstr "Beenden"
+
+#: gtkgui.c:1317 main.c:453
+msgid "Info"
+msgstr "Info"
+
+#: gtkgui.c:1331
+msgid "Selected files:"
+msgstr "Gewhlte Dateien"
+
+#: gtkgui.c:1340
+msgid "Filename"
+msgstr "Dateiname"
+
+#: gtkgui.c:1348
+msgid "Size:"
+msgstr "Gre:"
+
+#: help.c:40 help.c:71
+msgid "Press ESC to close window"
+msgstr "ESC drcken um Fenster zu schlieen"
+
+#: help.c:41
+msgid "F1  - Show help"
+msgstr "F1  - Zeige Hilfe"
+
+#: help.c:42
+msgid "F2  - CD label window"
+msgstr "F2  - Fenster fr CD-Label"
+
+#: help.c:43
+msgid "F3  - Edit cdrecord parameters"
+msgstr "F3  - Parameter fr cdrecord bearbeiten"
+
+#: help.c:44
+msgid "F4  - Select CD size"
+msgstr "F4  - CD-Gre auswhlen"
+
+#: help.c:45
+msgid "F5  - View last log"
+msgstr "F5  - Letztes Log ansehen"
+
+#: help.c:46
+msgid "F6  - Information about raw disk material"
+msgstr "F6  - Information ber die rohe CD"
+
+#: help.c:47
+msgid "F10 - View the GPL"
+msgstr "F10 - GPL betrachten"
+
+#: help.c:48
+msgid "E   - Eject tray of CD-RW"
+msgstr "E     - CD(-RW) auswerfen"
+
+#: help.c:49
+msgid "C   - Disk catalog"
+msgstr "C   - CD-Katalog"
+
+#: help.c:50
+msgid "A   - Add disk into Disk catalog"
+msgstr "A   - CD zu Katalog hinzufgen"
+
+#: help.c:51
+msgid "G   - Grab audio CD"
+msgstr "G   - Audio-CD grabben"
+
+#: help.c:52
+msgid "Q   - Quit"
+msgstr "Q   - Ende"
+
+#: help.c:72
+msgid "->     - Step into catalogized files window"
+msgstr "->     - Zum Fenster mit den katalogisierten Dateien"
+
+#: help.c:73
+msgid "<-     - Step into menu window"
+msgstr "<-     - Zum Men-Fenster"
+
+#: help.c:74
+msgid "ENTER  - Change category or disk or directory"
+msgstr "ENTER  - Wechsle Kategorie oder Disk oder Verzeichnis"
+
+#: help.c:75
+msgid "BSPACE"
+msgstr "BSPACE"
+
+#: help.c:75
+msgid "/      - Move one level up"
+msgstr "/      - Eine Ebene hher"
+
+#: help.c:76
+msgid "DEL    - Delete category or disk"
+msgstr "DEL    - Lsche Kategorie oder Disk"
+
+#: help.c:77
+msgid "A      - Add disk into catalog"
+msgstr "A      - Disk zum Katalog hinzufgen"
+
+#: help.c:78
+msgid "S      - Show all disks"
+msgstr "S      - Zeige alle Disks"
+
+#: help.c:79
+msgid "Q      - Quit Disk catalog"
+msgstr "Q      - Beende CD-Katalog"
+
+#: log.c:83 log.c:87 log.c:98 log.c:107
+msgid "Ok"
+msgstr "Ok"
+
+#: log.c:89 log.c:100 log.c:109
+msgid "Cancel"
+msgstr "Abbrechen"
+
+#: main.c:107
+#, c-format
+msgid "Speed: %sX "
+msgstr "Geschwindigkeit: %sX "
+
+#: main.c:143 main.c:160 main.c:347
+#, c-format
+msgid "File: %s not found!"
+msgstr "Datei: %s wurde nicht gefunden!"
+
+#: main.c:188 main.c:230 main.c:385
+msgid "Add files"
+msgstr "Dateien hinzufgen"
+
+#: main.c:411
+msgid " Add files           "
+msgstr " Dateien hinzufgen  "
+
+#: main.c:412
+msgid " Delete files        "
+msgstr " Dateien lschen     "
+
+#: main.c:413
+msgid " Create image        "
+msgstr " Image erzeugen      "
+
+#: main.c:414
+msgid " Copy CD image       "
+msgstr " Kopiere CD-Image    "
+
+#: main.c:415
+msgid " Write data CD       "
+msgstr " Schreibe Daten-CD   "
+
+#: main.c:416
+msgid " Write audio CD      "
+msgstr " Schreibe Audio-CD   "
+
+#: main.c:417
+msgid " Copy data CD        "
+msgstr " Kopiere Daten-CD    "
+
+#: main.c:418
+msgid " Blank CD-RW         "
+msgstr " CD-RW lschen       "
+
+#: main.c:419
+msgid " Options             "
+msgstr " Optionen            "
+
+#: main.c:420
+msgid " Quit                "
+msgstr " Beenden             "
+
+#: main.c:457
+msgid "Selected files"
+msgstr "Gewhlte Dateien"
+
+#: main.c:546
+msgid "Select CD size"
+msgstr "CD-Gre whlen"
+
+#: main.c:652
+msgid "Press G to start or ESC to exit"
+msgstr "Drcke G zum Start oder ESC zum Beenden"
+
+#: main.c:654
+msgid "Number of tracks:"
+msgstr "Anzahl der Tracks:"
+
+#: main.c:662
+msgid "Stereo"
+msgstr "Stereo"
+
+#: main.c:663
+msgid "Bits/Channel"
+msgstr "Bits/Kanal"
+
+#: main.c:664 options.c:737
+msgid "Echo to sound dev."
+msgstr "Echo zur Sndkarte"
+
+#: main.c:670 options.c:743
+msgid "Encode to Ogg"
+msgstr "Enkodiere OggVorbis"
+
+#: main.c:672
+msgid "High Quality"
+msgstr "Hohe Qualitt"
+
+#: main.c:684 options.c:751
+msgid "Encode to Mp3"
+msgstr "Enkodiere MP3"
+
+#: main.c:842
+msgid "Directory not exist"
+msgstr "Verzeichnis existiert nicht"
+
+#: main.c:844
+msgid "Cannot create directory!"
+msgstr "Kann Verzeichnis nicht anlegen!"
+
+#: main.c:1008
+#, c-format
+msgid "Usage: %s\n"
+msgstr "Nutzung: %s\n"
+
+#: main.c:1030 main.c:1089
+msgid "Needed min 80x25 terminal!"
+msgstr "Bentige mind. ein 80x25-Terminal!"
+
+#: main.c:1051
+#, c-format
+msgid ""
+"Usage: %s [options]\n"
+"\n"
+msgstr ""
+"Nutzung: %s [Optionen]\n"
+"\n"
+
+#: main.c:1052
+msgid ""
+"Options:\n"
+"\n"
+msgstr ""
+"Optionen:\n"
+"\n"
+
+#: main.c:1054
+msgid "  --catalog | -c            : start in Disk Catalog mode\n"
+msgstr "  --catalog | -c            : Starte im CD-Katalog-Modus\n"
+
+#: main.c:1057
+#, fuzzy
+msgid "  --gui     | -g            : start cdw in GUI mode\n"
+msgstr "  --gui     | -g            : Starte cdw im GUI-Modus\n"
+
+#: main.c:1059
+msgid "  --help    | -h            : show this screen\n"
+msgstr "  --help    | -h            : Zeige diese Hilfe\n"
+
+#: main.c:1060
+msgid ""
+"  --version | -v            : show version\n"
+"\n"
+msgstr ""
+"  --version | -v            : Zeige Version\n"
+"\n"
+
+#: main.c:1063
+#, c-format
+msgid "%s: invalid option -- %s\n"
+msgstr "%s: ungltige Option -- %s\n"
+
+#: main.c:1064
+#, c-format
+msgid "Try `%s --help`\n"
+msgstr "Versuche `%s --help`\n"
+
+#: main.c:1156
+msgid "Last log"
+msgstr "Letztes Log"
+
+#: main.c:1177
+msgid "License"
+msgstr "Lizenz"
+
+#: main.c:1248 main.c:1263
+msgid "Image exist"
+msgstr "Image existiert"
+
+#: options.c:423 options.c:716
+msgid "<F1> General"
+msgstr "<F1> Allgemein"
+
+#: options.c:426 options.c:720
+msgid "<F2> Other"
+msgstr "<F2> Andere"
+
+#: options.c:434
+msgid "CD-ROM"
+msgstr "CD-ROM"
+
+#: options.c:438
+msgid "Eject when done"
+msgstr "Auswurf wenn fertig"
+
+#: options.c:442
+msgid "Useful RR attribs"
+msgstr "Ntzl. RR-Attribute"
+
+#: options.c:445
+msgid "Auto show volume"
+msgstr "Vol. autozeign"
+
+#: options.c:448 options.c:541 options.c:548 options.c:588 options.c:595
+msgid "Multi-session"
+msgstr "Multi-Session"
+
+#: options.c:729
+msgid "Auto Disk Catalog"
+msgstr "Auto-CD-Katalog"
+
+#: options.c:970
+msgid "Press F10 to save config or ESC to cancel"
+msgstr "F10 zum Speichern oder ESC zum Abbrechen drcken"
+
+#: thread.c:441 thread.c:509
+msgid "     Press any key     "
+msgstr " Beliebige Taste drcken     "
+
+msgid "General"
+msgstr "Allgemein"
+
+msgid "Other"
+msgstr "Andere"
+
+msgid "Version"
+msgstr "Version"
diff -Naur orig/po/es.po patched/po/es.po
--- orig/po/es.po	1970-01-01 01:00:00.000000000 +0100
+++ patched/po/es.po	2004-02-07 13:46:50.000000000 +0100
@@ -0,0 +1,979 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR Free Software Foundation, Inc.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: cdw-0.2.0\n"
+"POT-Creation-Date: 2003-12-4 21:04+0200\n"
+"PO-Revision-Date: 2003-12-4 21:04+0200\n"
+"Last-Translator: Jess Espino <jespino@gul.uc3m.es>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=iso-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: cddb.c:95 cddb.c:1122 gtk_cddb.c:105 gtk_cddb.c:905
+msgid "Enter password:"
+msgstr "Introduzca contrasea:"
+
+#: cddb.c:102 gtk_cddb.c:112
+msgid "CD name"
+msgstr "Nombre del CD"
+
+#: cddb.c:102 gtk_cddb.c:112
+msgid "Enter CD name:"
+msgstr "Introduzca nombre del CD:"
+
+#: cddb.c:103 gtk_cddb.c:113
+msgid "CD Number"
+msgstr "Nmero de CD"
+
+#: cddb.c:103 gtk_cddb.c:113
+msgid "Number of disk:"
+msgstr "Nmero de disco:"
+
+#: cddb.c:104 gtk_cddb.c:114
+msgid "Category"
+msgstr "Categora"
+
+#: cddb.c:104 gtk_cddb.c:114
+msgid "Enter category:"
+msgstr "Introduzca categora"
+
+#: cddb.c:106 gtk_cddb.c:116
+msgid "Mounting cdrom..."
+msgstr "Montando cdrom..."
+
+#: cddb.c:109 gtk_cddb.c:119
+msgid "Unmounting cdrom..."
+msgstr "Desmontando cdrom..."
+
+#: cddb.c:161 cddb.c:211 cddb.c:244 cddb.c:258 cddb.c:281 cddb.c:301
+#: cddb.c:316 cddb.c:333 cddb.c:356 cddb.c:367 cddb.c:379 cddb.c:394
+#: cddb.c:401 cddb.c:415 cddb.c:423 gtk_cddb.c:195 gtk_cddb.c:228
+#: gtk_cddb.c:261 gtk_cddb.c:275 gtk_cddb.c:298 gtk_cddb.c:318 gtk_cddb.c:333
+#: gtk_cddb.c:350 gtk_cddb.c:373 gtk_cddb.c:384 gtk_cddb.c:396 gtk_cddb.c:411
+#: gtk_cddb.c:418 gtk_cddb.c:432 gtk_cddb.c:440
+msgid "Failed"
+msgstr "Fall"
+
+#: cddb.c:179 gtk_cddb.c:75
+msgid "Unknown error! Check the settings!"
+msgstr "Error desconocido! Compruebe la configuracin!"
+
+#: cddb.c:180 main.c:844
+msgid "Error"
+msgstr "Error"
+
+#: cddb.c:612 cddb.c:614 cddb.c:994
+msgid " Search [ ] "
+msgstr " Buscar [ ] "
+
+#: cddb.c:612
+msgid " Search [X] "
+msgstr " Buscar [X] "
+
+#: cddb.c:619 cddb.c:624 gtk_cddb.c:642 gtk_cddb.c:645
+msgid "Name: "
+msgstr "Nombre: "
+
+#: cddb.c:629 gtk_cddb.c:649
+msgid "Size: "
+msgstr "Tamao: "
+
+#: cddb.c:634 gtk_cddb.c:652
+msgid "Type: "
+msgstr "Tipo: "
+
+#: cddb.c:640 gtk_cddb.c:656
+msgid "Disk: "
+msgstr "Disco: "
+
+#: cddb.c:893 cddb.c:1185 gtk_cddb.c:864
+msgid "Are you sure do you want to delete category:"
+msgstr "Esta seguro de que desea borrar esta categora:"
+
+#: cddb.c:894 cddb.c:908 cddb.c:1186 cddb.c:1200
+msgid "Confirm"
+msgstr "Confirmar"
+
+#: cddb.c:907 cddb.c:1199 gtk_cddb.c:879
+msgid "Are you sure do you want to delete disk:"
+msgstr "Esta seguro de que quiere borrar el disco:"
+
+#: cddb.c:954
+msgid "Disk Catalog"
+msgstr "Catlogo de disco"
+
+#: cddb.c:958
+msgid " Show all disks "
+msgstr " Mostrar todos  "
+
+#: cddb.c:959
+msgid " Add disk       "
+msgstr " Aadir disco   "
+
+#: cddb.c:960
+msgid " Search         "
+msgstr " Buscar         "
+
+#: cddb.c:961
+msgid " Delete         "
+msgstr " Borrar         "
+
+#: cddb.c:962
+msgid " Quit Catalog   "
+msgstr " Salir Catlogo "
+
+#: cddb.c:985
+msgid "Catalog Menu"
+msgstr "Men Catlogo"
+
+#: cddb.c:989 gtk_cddb.c:925
+msgid "Catalogized files"
+msgstr "Archivos catalogados"
+
+#: cddb.c:1045 gtk_cddb.c:802
+msgid "Search in content"
+msgstr "Buscar en contenido"
+
+#: cddb.c:1045 gtk_cddb.c:802
+msgid "Enter query string:"
+msgstr "Introducir consulta:"
+
+#: cddb.c:1121 gtk_cddb.c:904
+msgid "password"
+msgstr "contrasea"
+
+#: gtk_cddb.c:906 gtkgui.c:1277
+msgid "Disk catalog"
+msgstr "Catlogo de disco"
+
+#: gtk_cddb.c:914
+msgid "Show all"
+msgstr "Mostrar todo"
+
+#: gtk_cddb.c:914
+msgid "Show all disks"
+msgstr "Mostrar todos los discos"
+
+#: gtk_cddb.c:915 gtkgui.c:1278
+msgid "Add disk"
+msgstr "Aadir disco"
+
+#: gtk_cddb.c:915
+msgid "Add new disk to catalog"
+msgstr "Aadir nuevo disco al catlogo"
+
+#: gtk_cddb.c:916 gtk_cddb.c:939
+msgid "Search"
+msgstr "Buscar"
+
+#: gtk_cddb.c:916
+msgid "Search files and directories"
+msgstr "Buscar archivos y directorios"
+
+#: gtk_cddb.c:917
+msgid "Delete"
+msgstr "Borrar"
+
+#: gtk_cddb.c:917
+msgid "Delete selected item"
+msgstr "Borrar objetos seleccionados"
+
+#: gtk_cddb.c:918
+msgid "Up"
+msgstr "Subir"
+
+#: gtk_cddb.c:918
+msgid "Go up one level"
+msgstr "Subir un nivel"
+
+#: gtk_cddb.c:930
+msgid "Filename/Dirname"
+msgstr "Nombre de archivo/directorio"
+
+#: gtk_cddb.c:932 gtkgui.c:1341
+msgid "Size/Type"
+msgstr "Tamao/Tipo"
+
+#: gtk_thread.c:97 gtk_thread.c:225 thread.c:81 thread.c:225
+msgid "Fixating..."
+msgstr "Arreglando..."
+
+#: gtk_thread.c:124 gtk_thread.c:179 thread.c:108 thread.c:171
+#, c-format
+msgid "  Fifo: %d%%  "
+msgstr "  Fifo: %d%%  "
+
+#: gtk_thread.c:140 gtk_thread.c:189 gtk_thread.c:414 thread.c:125
+#: thread.c:183 thread.c:425
+#, c-format
+msgid "%d / %d MB done"
+msgstr "%d / %d MB echo"
+
+#: gtk_thread.c:142 gtk_thread.c:191 thread.c:127 thread.c:185
+#, c-format
+msgid "%2.1f%% done"
+msgstr "%2.1f%% echo"
+
+#: gtk_thread.c:152 thread.c:141
+#, c-format
+msgid "%d MB"
+msgstr "%d MB"
+
+#: gtk_thread.c:163 gtk_thread.c:213 gtkgui.c:837 gtkgui.c:851 gtkgui.c:861
+#: main.c:884 main.c:899 main.c:910 thread.c:154 thread.c:214
+#, c-format
+msgid "Track: %d"
+msgstr "Pista: %d"
+
+#: gtk_thread.c:201 thread.c:199
+#, c-format
+msgid "%d MB done"
+msgstr "%d MB echo"
+
+#: gtk_thread.c:292 gtkgui.c:697 gtkgui.c:838 gtkgui.c:852 gtkgui.c:862
+#: main.c:650 main.c:885 main.c:900 main.c:911 thread.c:292
+msgid "Grab Audio CD"
+msgstr "Grabar CD de Audio"
+
+#: gtk_thread.c:300 thread.c:310
+msgid "done"
+msgstr "echo"
+
+#: gtk_thread.c:308 gtk_thread.c:328 gtkgui.c:1010 main.c:1354 thread.c:325
+#: thread.c:350
+msgid "Write direct"
+msgstr "Escritura directa"
+
+#: gtk_thread.c:318 gtk_thread.c:337 gtk_thread.c:416 thread.c:335
+#: thread.c:359 thread.c:427
+#, c-format
+msgid "%d%% done"
+msgstr "%d%% echo"
+
+#: gtk_thread.c:371
+msgid "Please wait..."
+msgstr "Por favor espere..."
+
+#: gtk_thread.c:443 thread.c:458
+msgid "Cannot create logfile..."
+msgstr "No se puede crear el fichero de log..."
+
+#: gtk_thread.c:456 thread.c:472
+msgid "Fork Failure\n"
+msgstr "Fallo de bifurcacin\n"
+
+#: gtkgui.c:122
+msgid "About"
+msgstr "Sobre"
+
+#: gtkgui.c:198
+msgid "Log window"
+msgstr "Ventana de Log"
+
+#: gtkgui.c:206 gtkgui.c:681 gtkgui.c:975 main.c:629 main.c:1163 main.c:1315
+msgid "Load CD info..."
+msgstr "Carga informacin del CD..."
+
+#: gtkgui.c:207 gtkgui.c:1274 main.c:1164
+msgid "CD info"
+msgstr "Informacin del CD"
+
+#: gtkgui.c:213 gtkgui.c:890 gtkgui.c:958 gtkgui.c:1023 main.c:1136
+#: main.c:1229
+msgid "Volume ID"
+msgstr "ID del Volumen"
+
+#: gtkgui.c:213 gtkgui.c:890 gtkgui.c:958 gtkgui.c:1023 main.c:1136
+#: main.c:1229
+msgid "Enter volume label:"
+msgstr "Introduzca la etiqueta del volumen:"
+
+#: gtkgui.c:219 main.c:1142
+msgid "CD record parameters"
+msgstr "Parmetros de grabado de CD"
+
+#: gtkgui.c:219 main.c:1142
+msgid "Enter parameter:"
+msgstr "Introduzca parmetro:"
+
+#: gtkgui.c:229 main.c:544
+msgid "CD size"
+msgstr "Tamao del CD"
+
+#: gtkgui.c:235
+msgid "Select CD size:"
+msgstr "Seleccione el tamao del CD:"
+
+#: gtkgui.c:307 gtkgui.c:1086
+msgid "Select files"
+msgstr "Seleccione los archivos"
+
+#: gtkgui.c:389 options.c:968
+msgid "Options"
+msgstr "Opciones"
+
+#: gtkgui.c:399
+msgid "SCSI device"
+msgstr "Dispositivo SCSI"
+
+#: gtkgui.c:400
+msgid "Image file"
+msgstr "Archivo de imagen"
+
+#: gtkgui.c:401
+msgid "Logfile"
+msgstr "Archivo de log"
+
+#: gtkgui.c:402
+msgid "CD-ROM device"
+msgstr "Dispositivo de CD-ROM"
+
+#: gtkgui.c:403
+msgid "CD-RW device"
+msgstr "Dispositivo de CD-RW"
+
+#: gtkgui.c:405
+msgid "Write CD from image"
+msgstr "Escribir CD desde imagen"
+
+#: gtkgui.c:406
+msgid "Blank fast"
+msgstr "Borrado rpido"
+
+#: gtkgui.c:407
+msgid "Eject CD tray when finished"
+msgstr "Expulsar CD al terminar"
+
+#: gtkgui.c:408
+msgid "Disk at once"
+msgstr "Disco de una vez"
+
+#: gtkgui.c:409
+msgid "Joliet information"
+msgstr "Informacin Joilet"
+
+#: gtkgui.c:410
+msgid "Rock Ridge"
+msgstr "Rock Ridge"
+
+#: gtkgui.c:411
+msgid "Usefull Rock Ridge attributes"
+msgstr "Atributos tiles de Rock Ridge"
+
+#: gtkgui.c:412
+msgid "Dummy write"
+msgstr "Simulacin de escritura"
+
+#: gtkgui.c:413 gtkgui.c:1215
+msgid "Speed"
+msgstr "Velocidad"
+
+#: gtkgui.c:414
+msgid "Show log after write"
+msgstr "Mostrar log despus de grabar"
+
+#: gtkgui.c:415
+msgid "Auto show volume edit dialog"
+msgstr "Mostrar automticamente el dialogo de edicin de volumen"
+
+#: gtkgui.c:416
+msgid "Pad"
+msgstr "Pad"
+
+#: gtkgui.c:417
+msgid "Write in multi-session"
+msgstr "Grabar en multi-sesin"
+
+#: gtkgui.c:418
+msgid "Burnproof"
+msgstr "Burnproof"
+
+#: gtkgui.c:419
+msgid "Auto disk catalog"
+msgstr "Auto-catalogar disco"
+
+#: gtkgui.c:420 gtkgui.c:725
+msgid "Grab stereo mode"
+msgstr "Grabar en modo estreo"
+
+#: gtkgui.c:421 gtkgui.c:726
+msgid "Echo to soundcard"
+msgstr "Eco a la tarjeta de sonido"
+
+#: gtkgui.c:422 gtkgui.c:727
+msgid "High quality"
+msgstr "Alta calidad"
+
+#: gtkgui.c:423 gtkgui.c:728
+msgid "Encode audio:"
+msgstr "Codificar audio:"
+
+#: gtkgui.c:424
+msgid "CD mountpoint"
+msgstr "Punto de montaje del CD"
+
+#: gtkgui.c:425
+msgid "MySQL host"
+msgstr "Servidor MySQL"
+
+#: gtkgui.c:426
+msgid "MySQL user"
+msgstr "Usuario MySQL"
+
+#: gtkgui.c:427
+msgid "Audio directory"
+msgstr "Directorio de audio"
+
+#: gtkgui.c:428 gtkgui.c:729
+msgid "Bits per channel"
+msgstr "Bits por canal"
+
+#: gtkgui.c:429 gtkgui.c:730
+msgid "Bitrate"
+msgstr "Bitrate"
+
+#: gtkgui.c:430 gtkgui.c:731
+msgid "Encode to Ogg Vorbis"
+msgstr "Codificar a Vorbis Ogg"
+
+#: gtkgui.c:431 gtkgui.c:732
+msgid "Encode to MP3"
+msgstr "Codificar a Mp3"
+
+#: gtkgui.c:432 gtkgui.c:733
+msgid "Encode to:"
+msgstr "Codificar a:"
+
+#: gtkgui.c:684 gtkgui.c:977 log.c:142 main.c:633 main.c:1318
+msgid "Cannot open file..."
+msgstr "No se puede abrir el fichero..."
+
+#: gtkgui.c:706
+msgid "Number of tracks: "
+msgstr "Nmero de pistas: "
+
+#: gtkgui.c:709 gtkgui.c:717
+msgid "Start track"
+msgstr "Inicio de pista"
+
+#: gtkgui.c:711 gtkgui.c:719
+msgid "End track"
+msgstr "Final de pista"
+
+#: gtkgui.c:715 main.c:657
+msgid "No audio CD!"
+msgstr "No es un CD de audio!"
+
+#: gtkgui.c:787 main.c:842
+msgid ""
+"Audio directory not exist!\n"
+"Do you wish to create?"
+msgstr ""
+"El directorio de audio no existe!\n"
+"Desea crearlo?"
+
+#: gtkgui.c:904 gtkgui.c:927 main.c:1248 main.c:1263
+msgid ""
+"Image file exist!\n"
+"Do you wish to overwrite it?"
+msgstr ""
+"Existe el fichero de imagen!\n"
+"Desea sobreescribirlo?"
+
+#: gtkgui.c:908 gtkgui.c:1291 main.c:1252
+msgid "Create image"
+msgstr "Crear imagen"
+
+#: gtkgui.c:917 gtkgui.c:1296 main.c:1411
+msgid "Blank CD-RW"
+msgstr "Borrar CD-RW"
+
+#: gtkgui.c:931 gtkgui.c:1292 main.c:1267
+msgid "Copy CD image"
+msgstr "Copiar imagen de CD"
+
+#: gtkgui.c:951 main.c:1286
+msgid "Write image"
+msgstr "Grabar imagen"
+
+#: gtkgui.c:1011
+msgid "Write direct log"
+msgstr "Escribir log directamente"
+
+#: gtkgui.c:1039 main.c:1383
+msgid "Write audio"
+msgstr "Grabar audio"
+
+#: gtkgui.c:1040
+msgid "Write audio log"
+msgstr "Escribir log de audio"
+
+#: gtkgui.c:1060 gtkgui.c:1295 main.c:1402
+msgid "Copy data CD"
+msgstr "Copiar CD de datos"
+
+#: gtkgui.c:1061
+msgid "Copy data CD log"
+msgstr "Log de copia de CD de datos"
+
+#: gtkgui.c:1151 main.c:613
+#, c-format
+msgid "Used: %2.1f%%, Wasted: %.0f/%d MB"
+msgstr "Usado: %2.1f%%, Desperdiciado: %.0f/%d MB"
+
+#: gtkgui.c:1154 main.c:615
+#, c-format
+msgid "Used: %2.1f%%, Wasted: %d MB"
+msgstr "Usado: %2.1f%%, Desperdiciado: %d MB"
+
+#: gtkgui.c:1203 main.c:957
+#, c-format
+msgid "Size: %.0f Mb in %d files"
+msgstr "Tamao: %.0f Mb en %d archivos"
+
+#: gtkgui.c:1212 main.c:104
+msgid "Write from image"
+msgstr "Grabar desde imagen"
+
+#: gtkgui.c:1214 main.c:106
+msgid "Write direct    "
+msgstr "Grabar directo  "
+
+#: gtkgui.c:1218 main.c:109
+msgid "Multi-session "
+msgstr "Multi-sesin "
+
+#: gtkgui.c:1220 main.c:111
+msgid "Single session"
+msgstr "Sesin nica"
+
+#: gtkgui.c:1270
+msgid "CD label"
+msgstr "Etiqueta del CD"
+
+#: gtkgui.c:1270
+msgid "Display CD label editor window"
+msgstr "Mostrar la ventana de edicin de etiqueta del CD"
+
+#: gtkgui.c:1271
+msgid "Parameters"
+msgstr "Parmetros"
+
+#: gtkgui.c:1271
+msgid "Edit cdrecord parameters"
+msgstr "Editar parmetros del cdrecord"
+
+#: gtkgui.c:1272
+msgid "CD Size"
+msgstr "Tamao del CD"
+
+#: gtkgui.c:1272
+msgid "Select the size of disk"
+msgstr "Seleccione el tamao del disco"
+
+#: gtkgui.c:1273
+msgid "Log"
+msgstr "Log"
+
+#: gtkgui.c:1273
+msgid "Display the content of log"
+msgstr "Mostrar el contenido del log"
+
+#: gtkgui.c:1274
+msgid "Display information about CD"
+msgstr "Mostrar informacin sobre el CD"
+
+#: gtkgui.c:1275
+msgid "Eject CD"
+msgstr "Expulsar CD"
+
+#: gtkgui.c:1275
+msgid "Eject CD tray"
+msgstr "Expulsar bandeja del CD"
+
+#: gtkgui.c:1277
+msgid "Display disk catalog"
+msgstr "Mostrar catlogo de discos"
+
+#: gtkgui.c:1278
+msgid "Add CD to disk catalog"
+msgstr "Aadir CD al catlogo de discos"
+
+#: gtkgui.c:1280
+msgid "CD rip"
+msgstr "CD rip"
+
+#: gtkgui.c:1280
+msgid "Rip Audio CD"
+msgstr "Rip CD de audio"
+
+#: gtkgui.c:1281 help.c:38 help.c:69
+msgid "Help"
+msgstr "Ayuda"
+
+#: gtkgui.c:1281
+msgid "Display help window"
+msgstr "Mostrar ventana de ayuda"
+
+#: gtkgui.c:1283 main.c:448
+msgid "Menu"
+msgstr "Men"
+
+#: gtkgui.c:1289
+msgid "Add files..."
+msgstr "Aadir archivos..."
+
+#: gtkgui.c:1290
+msgid "Delete files"
+msgstr "Borrar archivos"
+
+#: gtkgui.c:1293
+msgid "Write data CD"
+msgstr "Escribir CD de datos"
+
+#: gtkgui.c:1294
+msgid "Write audio CD"
+msgstr "Escribir CD de audio"
+
+#: gtkgui.c:1297
+msgid "Options..."
+msgstr "Opciones..."
+
+#: gtkgui.c:1298
+msgid "Quit"
+msgstr "Salir"
+
+#: gtkgui.c:1317 main.c:453
+msgid "Info"
+msgstr "Informacin"
+
+#: gtkgui.c:1331
+msgid "Selected files:"
+msgstr "Archivos seleccionados:"
+
+#: gtkgui.c:1340
+msgid "Filename"
+msgstr "Nombre de archivo"
+
+#: gtkgui.c:1348
+msgid "Size:"
+msgstr "Tamao:"
+
+#: help.c:40 help.c:71
+msgid "Press ESC to close window"
+msgstr "Pulse ESC para cerrar la ventana"
+
+#: help.c:41
+msgid "F1  - Show help"
+msgstr "F1 - Muestra ayuda"
+
+#: help.c:42
+msgid "F2  - CD label window"
+msgstr "F2 - Ventana de etiqueta del CD"
+
+#: help.c:43
+msgid "F3  - Edit cdrecord parameters"
+msgstr "F3 - Editar parmetros del cdrecord"
+
+#: help.c:44
+msgid "F4  - Select CD size"
+msgstr "F4 - Seleccionar tamao del CD"
+
+#: help.c:45
+msgid "F5  - View last log"
+msgstr "F5 - Ver el ultimo log"
+
+#: help.c:46
+msgid "F6  - Information about raw disk material"
+msgstr "F6 - Informacin sobre la materia prima del disco"
+
+#: help.c:47
+msgid "F10 - View the GPL"
+msgstr "F10 - Ver la licencia GPL"
+
+#: help.c:48
+msgid "E   - Eject tray of CD-RW"
+msgstr "E   - Expulsar bandeja del CD-RW"
+
+#: help.c:49
+msgid "C   - Disk catalog"
+msgstr "C   - Catlogo de discos"
+
+#: help.c:50
+msgid "A   - Add disk into Disk catalog"
+msgstr "A   - Aadir disco en el catlogo"
+
+#: help.c:51
+msgid "G   - Grab audio CD"
+msgstr "G   - Grabar CD de audio"
+
+#: help.c:52
+msgid "Q   - Quit"
+msgstr "Q   - Salir"
+
+#: help.c:72
+msgid "->     - Step into catalogized files window"
+msgstr "->     - Ir a la ventana de archivos catalogados"
+
+#: help.c:73
+msgid "<-     - Step into menu window"
+msgstr "<-     - Ir a la ventana del men"
+
+#: help.c:74
+msgid "ENTER  - Change category or disk or directory"
+msgstr "ENTER  - Cambiar categora o disco o directorio"
+
+#: help.c:75
+msgid "BSPACE"
+msgstr "BSPACE"
+
+#: help.c:75
+msgid "/      - Move one level up"
+msgstr "/      - Subir un nivel"
+
+#: help.c:76
+msgid "DEL    - Delete category or disk"
+msgstr "DEL    - Borrar categora o disco"
+
+#: help.c:77
+msgid "A      - Add disk into catalog"
+msgstr "A      - Aadir disco en el catlogo"
+
+#: help.c:78
+msgid "S      - Show all disks"
+msgstr "S      - Mostrar todos los discos"
+
+#: help.c:79
+msgid "Q      - Quit Disk catalog"
+msgstr "Q      - Salir del catlogo de discos"
+
+#: log.c:83 log.c:87 log.c:98 log.c:107
+msgid "Ok"
+msgstr "Aceptar"
+
+#: log.c:89 log.c:100 log.c:109
+msgid "Cancel"
+msgstr "Cancelar"
+
+#: main.c:107
+#, c-format
+msgid "Speed: %sX "
+msgstr "Velocidad: %sX"
+
+#: main.c:143 main.c:160 main.c:347
+#, c-format
+msgid "File: %s not found!"
+msgstr "Archivo: %s no encontrado!"
+
+#: main.c:188 main.c:230 main.c:385
+msgid "Add files"
+msgstr "Aadir archivos"
+
+#: main.c:411
+msgid " Add files           "
+msgstr " Aadir archivos     "
+
+#: main.c:412
+msgid " Delete files        "
+msgstr " Borrar archivos     "
+
+#: main.c:413
+msgid " Create image        "
+msgstr " Crear imagen        "
+
+#: main.c:414
+msgid " Copy CD image       "
+msgstr " Copiar imagen de CD "
+
+#: main.c:415
+msgid " Write data CD       "
+msgstr " Grabar CD de datos  "
+
+#: main.c:416
+msgid " Write audio CD      "
+msgstr " Grabar CD de audio  "
+
+#: main.c:417
+msgid " Copy data CD        "
+msgstr " Copiar CD de datos  "
+
+#: main.c:418
+msgid " Blank CD-RW         "
+msgstr " Borrar CD-RW        "
+
+#: main.c:419
+msgid " Options             "
+msgstr " Opciones            "
+
+#: main.c:420
+msgid " Quit                "
+msgstr " Salir               "
+
+#: main.c:457
+msgid "Selected files"
+msgstr "Archivos seleccionados"
+
+#: main.c:546
+msgid "Select CD size"
+msgstr "Seleccionar tamao del CD"
+
+#: main.c:652
+msgid "Press G to start or ESC to exit"
+msgstr "Pulse G para empezar o ESC para salir"
+
+#: main.c:654
+msgid "Number of tracks:"
+msgstr "Nmero de pistas:"
+
+#: main.c:662
+msgid "Stereo"
+msgstr "Estreo"
+
+#: main.c:663
+msgid "Bits/Channel"
+msgstr "Bits/Canal"
+
+#: main.c:664 options.c:737
+msgid "Echo to sound dev."
+msgstr "Eco disp. sonido"
+
+#: main.c:670 options.c:743
+msgid "Encode to Ogg"
+msgstr "Codificar a Ogg"
+
+#: main.c:672
+msgid "High Quality"
+msgstr "Alta Calidad"
+
+#: main.c:684 options.c:751
+msgid "Encode to Mp3"
+msgstr "Codificar a Mp3"
+
+#: main.c:842
+msgid "Directory not exist"
+msgstr "El directorio no existe"
+
+#: main.c:844
+msgid "Cannot create directory!"
+msgstr "No se puede crear el directorio!"
+
+#: main.c:1008
+#, c-format
+msgid "Usage: %s\n"
+msgstr "Uso: %s\n"
+
+#: main.c:1030 main.c:1089
+msgid "Needed min 80x25 terminal!"
+msgstr "Necesita como mnimo un terminal de 80x25!"
+
+#: main.c:1051
+#, c-format
+msgid ""
+"Usage: %s [options]\n"
+"\n"
+msgstr ""
+"Uso: %s [opciones]\n"
+"\n"
+
+#: main.c:1052
+msgid ""
+"Options:\n"
+"\n"
+msgstr ""
+"Opciones:\n"
+"\n"
+
+#: main.c:1054
+msgid "  --catalog | -c            : start in Disk Catalog mode\n"
+msgstr "  --catalog | -c           : iniciar en el modo de catlogo de discos\n"
+
+#: main.c:1057
+msgid "  --gui     | -g            : start cdw in GUI mode\n"
+msgstr "  --gui     | -g            : iniciar cdw en el modo GUI\n"
+
+#: main.c:1059
+msgid "  --help    | -h            : show this screen\n"
+msgstr "  --help    | -h            : mostrar esta ayuda\n"
+
+#: main.c:1060
+msgid ""
+"  --version | -v            : show version\n"
+"\n"
+msgstr ""
+"  --version | -v            : mostrar versin\n"
+"\n"
+
+#: main.c:1063
+#, c-format
+msgid "%s: invalid option -- %s\n"
+msgstr "%s: opcin incorrecta -- %s\n"
+
+#: main.c:1064
+#, c-format
+msgid "Try `%s --help`\n"
+msgstr "Pruebe `%s --help`\n"
+
+#: main.c:1156
+msgid "Last log"
+msgstr "Ultimo log"
+
+#: main.c:1177
+msgid "License"
+msgstr "Licencia"
+
+#: main.c:1248 main.c:1263
+msgid "Image exist"
+msgstr "Existe la imagen"
+
+#: options.c:423 options.c:716
+msgid "<F1> General"
+msgstr "<F1> General"
+
+#: options.c:426 options.c:720
+msgid "<F2> Other"
+msgstr "<F2> Otro"
+
+#: options.c:434
+msgid "CD-ROM"
+msgstr "CD-ROM"
+
+#: options.c:438
+msgid "Eject when done"
+msgstr "Exp. CD al terminar"
+
+#: options.c:442
+msgid "Useful RR attribs"
+msgstr "Atrib. tiles de RR"
+
+#: options.c:445
+msgid "Auto show vol"
+msgstr "Automost. vol"
+
+#: options.c:448 options.c:541 options.c:548 options.c:588 options.c:595
+msgid "Multi-session"
+msgstr "Multi-sesin"
+
+#: options.c:729
+msgid "Auto Disk Catalog"
+msgstr "Autocatalog. disco"
+
+#: options.c:970
+msgid "Press F10 to save config or ESC to cancel"
+msgstr "Pulse F10 para guardar la conf. o ESC para cancelar"
+
+#: thread.c:441 thread.c:509
+msgid "     Press any key     "
+msgstr "Pulse una tecla para continuar"
+
+msgid "General"
+msgstr "General"
+
+msgid "Other"
+msgstr "Otro"
+
+msgid "Version"
+msgstr "Versin"
diff -Naur orig/po/hu.po patched/po/hu.po
--- orig/po/hu.po	1970-01-01 01:00:00.000000000 +0100
+++ patched/po/hu.po	2005-11-07 10:18:38.000000000 +0100
@@ -0,0 +1,986 @@
+# translation of hu.po to Hungarian
+# translation of hu.po to hungarian
+# translation of cdw.merge.po to hungarian
+# cdw-0.1.5
+# Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+# Balazs Varkonyi <vbali@linuxforum.hu> 2002
+# Marcel Hilzinger <hili@suselinux.hu>, 2003.
+# Gabor Sari <saga@chello.hu>, 2003
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: hu\n"
+"POT-Creation-Date: 2003-08-26 18:35+0200\n"
+"PO-Revision-Date: 2003-10-13 19:17+0200\n"
+"Last-Translator: Gabor Sari <saga@chello.hu>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-2\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language-Team: Hungarian <hu@li.org>\n"
+"X-Generator: KBabel 1.0.1\n"
+
+#: cddb.c:95 cddb.c:1122 gtk_cddb.c:105 gtk_cddb.c:905
+msgid "Enter password:"
+msgstr "Add meg a jelszt:"
+
+#: cddb.c:102 gtk_cddb.c:112
+msgid "CD name"
+msgstr "CD neve"
+
+#: cddb.c:102 gtk_cddb.c:112
+msgid "Enter CD name:"
+msgstr "Add meg a CD nevt:"
+
+#: cddb.c:103 gtk_cddb.c:113
+msgid "CD Number"
+msgstr "CD sorszm"
+
+#: cddb.c:103 gtk_cddb.c:113
+msgid "Number of disk:"
+msgstr "Lemez szma:"
+
+#: cddb.c:104 gtk_cddb.c:114
+msgid "Category"
+msgstr "Kategria"
+
+#: cddb.c:104 gtk_cddb.c:114
+msgid "Enter category:"
+msgstr "Add meg a kategrit:"
+
+#: cddb.c:106 gtk_cddb.c:116
+msgid "Mounting cdrom..."
+msgstr "CD csatolsa..."
+
+#: cddb.c:109 gtk_cddb.c:119
+msgid "Unmounting cdrom..."
+msgstr "CD levlasztsa..."
+
+#: cddb.c:161 cddb.c:211 cddb.c:244 cddb.c:258 cddb.c:281 cddb.c:301
+#: cddb.c:316 cddb.c:333 cddb.c:356 cddb.c:367 cddb.c:379 cddb.c:394
+#: cddb.c:401 cddb.c:415 cddb.c:423 gtk_cddb.c:195 gtk_cddb.c:228
+#: gtk_cddb.c:261 gtk_cddb.c:275 gtk_cddb.c:298 gtk_cddb.c:318 gtk_cddb.c:333
+#: gtk_cddb.c:350 gtk_cddb.c:373 gtk_cddb.c:384 gtk_cddb.c:396 gtk_cddb.c:411
+#: gtk_cddb.c:418 gtk_cddb.c:432 gtk_cddb.c:440
+msgid "Failed"
+msgstr "Sikertelen"
+
+#: cddb.c:179 gtk_cddb.c:75
+msgid "Unknown error! Check the settings!"
+msgstr "Ismertlen hiba! Ellenrizd a belltsokat!"
+
+#: cddb.c:180 main.c:844
+msgid "Error"
+msgstr "Hiba"
+
+#: cddb.c:612 cddb.c:614 cddb.c:994
+msgid " Search [ ] "
+msgstr " Keress  [ ] "
+
+#: cddb.c:612
+msgid " Search [X] "
+msgstr " Keress  [X] "
+
+#: cddb.c:619 cddb.c:624 gtk_cddb.c:642 gtk_cddb.c:645
+msgid "Name: "
+msgstr "Nv : "
+
+#: cddb.c:629 gtk_cddb.c:649
+msgid "Size: "
+msgstr "Mret:"
+
+#: cddb.c:634 gtk_cddb.c:652
+msgid "Type: "
+msgstr "Tpus:"
+
+#: cddb.c:640 gtk_cddb.c:656
+msgid "Disk: "
+msgstr "Lemez:"
+
+#: cddb.c:893 cddb.c:1185 gtk_cddb.c:864
+msgid "Are you sure do you want to delete category:"
+msgstr "Biztosan trlni akarod a kategrit:"
+
+#: cddb.c:894 cddb.c:908 cddb.c:1186 cddb.c:1200
+msgid "Confirm"
+msgstr "Megerst"
+
+#: cddb.c:907 cddb.c:1199 gtk_cddb.c:879
+msgid "Are you sure do you want to delete disk:"
+msgstr "Biztosan trlni akarod a lemezt:"
+
+#: cddb.c:954
+msgid "Disk Catalog"
+msgstr "Katalgus"
+
+#: cddb.c:958
+msgid " Show all disks "
+msgstr " sszes mutatsa"
+
+#: cddb.c:959
+msgid " Add disk       "
+msgstr " Hozzads "
+
+#: cddb.c:960
+msgid " Search         "
+msgstr " Keress        "
+
+#: cddb.c:961
+msgid " Delete         "
+msgstr " Trls         "
+
+#: cddb.c:962
+msgid " Quit Catalog   "
+msgstr " Kilps          "
+
+#: cddb.c:985
+msgid "Catalog Menu"
+msgstr "Katalgus men"
+
+#: cddb.c:989 gtk_cddb.c:925
+msgid "Catalogized files"
+msgstr "Katalogizlt fjlok"
+
+#: cddb.c:1045 gtk_cddb.c:802
+msgid "Search in content"
+msgstr "Keress a tartalomban"
+
+#: cddb.c:1045 gtk_cddb.c:802
+msgid "Enter query string:"
+msgstr "Keresend szveg:"
+
+#: cddb.c:1121 gtk_cddb.c:904
+msgid "password"
+msgstr "jelsz"
+
+#: gtk_cddb.c:906 gtkgui.c:1277
+msgid "Disk catalog"
+msgstr "Katalgus"
+
+#: gtk_cddb.c:914
+msgid "Show all"
+msgstr "sszes megjelentse"
+
+#: gtk_cddb.c:914
+msgid "Show all disks"
+msgstr "sszes lemez megjelentse"
+
+#: gtk_cddb.c:915 gtkgui.c:1278
+msgid "Add disk"
+msgstr "Hozzads"
+
+#: gtk_cddb.c:915
+msgid "Add new disk to catalog"
+msgstr "j lemez hozzadsa a katalgushoz"
+
+#: gtk_cddb.c:916 gtk_cddb.c:939
+msgid "Search"
+msgstr "Keress"
+
+#: gtk_cddb.c:916
+msgid "Search files and directories"
+msgstr "Fjlok s knyvtrak keresse"
+
+#: gtk_cddb.c:917
+msgid "Delete"
+msgstr "Trls"
+
+#: gtk_cddb.c:917
+msgid "Delete selected item"
+msgstr "A kivlasztott elem trlse"
+
+#: gtk_cddb.c:918
+msgid "Up"
+msgstr "Fel"
+
+#: gtk_cddb.c:918
+msgid "Go up one level"
+msgstr "Egy szinttel feljebb"
+
+#: gtk_cddb.c:930
+msgid "Filename/Dirname"
+msgstr "Fjl-/knyvtrnv"
+
+#: gtk_cddb.c:932 gtkgui.c:1341
+msgid "Size/Type"
+msgstr "Mret/tpus"
+
+#: gtk_thread.c:97 gtk_thread.c:225 thread.c:81 thread.c:225
+msgid "Fixating..."
+msgstr "Lezrs..."
+
+#: gtk_thread.c:124 gtk_thread.c:179 thread.c:108 thread.c:171
+#, c-format
+msgid "  Fifo: %d%%  "
+msgstr "  Fifo: %d%%  "
+
+#: gtk_thread.c:140 gtk_thread.c:189 gtk_thread.c:414 thread.c:125
+#: thread.c:183 thread.c:425
+#, c-format
+msgid "%d / %d MB done"
+msgstr "%d / %d MB ksz"
+
+#: gtk_thread.c:142 gtk_thread.c:191 thread.c:127 thread.c:185
+#, c-format
+msgid "%2.1f%% done"
+msgstr "%2.1f%% ksz"
+
+#: gtk_thread.c:152 thread.c:141
+#, c-format
+msgid "%d MB"
+msgstr "%d MB"
+
+#: gtk_thread.c:163 gtk_thread.c:213 gtkgui.c:837 gtkgui.c:851 gtkgui.c:861
+#: main.c:884 main.c:899 main.c:910 thread.c:154 thread.c:214
+#, c-format
+msgid "Track: %d"
+msgstr "%d. sv"
+
+#: gtk_thread.c:201 thread.c:199
+#, c-format
+msgid "%d MB done"
+msgstr "%d MB ksz"
+
+#: gtk_thread.c:292 gtkgui.c:697 gtkgui.c:838 gtkgui.c:852 gtkgui.c:862
+#: main.c:650 main.c:885 main.c:900 main.c:911 thread.c:292
+msgid "Grab Audio CD"
+msgstr "Audio CD beolvassa"
+
+#: gtk_thread.c:300 thread.c:310
+msgid "done"
+msgstr "ksz"
+
+#: gtk_thread.c:308 gtk_thread.c:328 gtkgui.c:1010 main.c:1354 thread.c:325
+#: thread.c:350
+msgid "Write direct"
+msgstr "Kzvetlen rs"
+
+#: gtk_thread.c:318 gtk_thread.c:337 gtk_thread.c:416 thread.c:335
+#: thread.c:359 thread.c:427
+#, c-format
+msgid "%d%% done"
+msgstr "%d%% ksz"
+
+#: gtk_thread.c:371
+msgid "Please wait..."
+msgstr "Egy pillanat..."
+
+#: gtk_thread.c:443 thread.c:458
+msgid "Cannot create logfile..."
+msgstr "A naplfjl ltrehozsa nem sikerlt..."
+
+#: gtk_thread.c:456 thread.c:472
+msgid "Fork Failure\n"
+msgstr "Fork hiba\n"
+
+#: gtkgui.c:122
+msgid "About"
+msgstr "Nvjegy"
+
+#: gtkgui.c:198
+msgid "Log window"
+msgstr "Naplablak"
+
+#: gtkgui.c:206 gtkgui.c:681 gtkgui.c:975 main.c:629 main.c:1163 main.c:1315
+msgid "Load CD info..."
+msgstr "CD inf beolvassa..."
+
+#: gtkgui.c:207 gtkgui.c:1274 main.c:1164
+msgid "CD info"
+msgstr "CD inf"
+
+#: gtkgui.c:213 gtkgui.c:890 gtkgui.c:958 gtkgui.c:1023 main.c:1136
+#: main.c:1229
+msgid "Volume ID"
+msgstr "Lemez cmke"
+
+#: gtkgui.c:213 gtkgui.c:890 gtkgui.c:958 gtkgui.c:1023 main.c:1136
+#: main.c:1229
+msgid "Enter volume label:"
+msgstr "Lemezcmke megadsa:"
+
+#: gtkgui.c:219 main.c:1142
+msgid "CD record parameters"
+msgstr "Cdrecord paramterek"
+
+#: gtkgui.c:219 main.c:1142
+msgid "Enter parameter:"
+msgstr "Paramterek megadsa:"
+
+#: gtkgui.c:229 main.c:544
+msgid "CD size"
+msgstr "CD mret"
+
+#: gtkgui.c:235
+msgid "Select CD size:"
+msgstr "A CD mretnek kivlasztsa:"
+
+#: gtkgui.c:307 gtkgui.c:1086
+msgid "Select files"
+msgstr "Fjlok hozzadsa"
+
+#: gtkgui.c:389 options.c:968
+msgid "Options"
+msgstr "Belltsok"
+
+#: gtkgui.c:399
+msgid "SCSI device"
+msgstr "SCSI eszkz"
+
+#: gtkgui.c:400
+msgid "Image file"
+msgstr "Kpmsfjl"
+
+#: gtkgui.c:401
+msgid "Logfile"
+msgstr "Naplfjl"
+
+#: gtkgui.c:402
+msgid "CD-ROM device"
+msgstr "CD-ROM eszkz"
+
+#: gtkgui.c:403
+msgid "CD-RW device"
+msgstr "CD-RW eszkz"
+
+#: gtkgui.c:406
+msgid "Blank fast"
+msgstr "Gyorstrls"
+
+#: gtkgui.c:407
+msgid "Eject CD tray when finished"
+msgstr "A CD tlca kiadsa rs utn"
+
+#: gtkgui.c:408
+msgid "Disk at once"
+msgstr "Egy menetben"
+
+#: gtkgui.c:409
+msgid "Joliet information"
+msgstr "Joliet informci"
+
+#: gtkgui.c:410
+msgid "Rock Ridge"
+msgstr "Rock Ridge"
+
+#: gtkgui.c:412
+msgid "Dummy write"
+msgstr "rs szimullt mdban"
+
+#: gtkgui.c:413 gtkgui.c:1215
+msgid "Speed"
+msgstr "rsi sebessg"
+
+#: gtkgui.c:414
+msgid "Show log after write"
+msgstr "A Napl megtekintse rs utn"
+
+#: gtkgui.c:415
+msgid "Auto show volume edit dialog"
+msgstr "A Lemezcmke ablak automatikus megjelentse"
+
+#: gtkgui.c:416
+msgid "Pad"
+msgstr "Pad"
+
+#: gtkgui.c:417
+msgid "Write in multi-session"
+msgstr "Tbbmenetes rs"
+
+#: gtkgui.c:418
+msgid "Burnproof"
+msgstr "Burnproof"
+
+#: gtkgui.c:419
+msgid "Auto disk catalog"
+msgstr "A Lemezkatalgus automatikus megnyitsa"
+
+#: gtkgui.c:420 gtkgui.c:725
+msgid "Grab stereo mode"
+msgstr "Olvass sztereban"
+
+#: gtkgui.c:421 gtkgui.c:726
+msgid "Echo to soundcard"
+msgstr "Hangkrtyra is"
+
+#: gtkgui.c:422 gtkgui.c:727
+msgid "High quality"
+msgstr "HQ minsgben"
+
+#: gtkgui.c:423 gtkgui.c:728
+msgid "Encode audio"
+msgstr "Audio-CD olvassa"
+
+#: gtkgui.c:424
+msgid "CD mountpoint"
+msgstr "CD csatolsi pont"
+
+#: gtkgui.c:425
+msgid "MySQL host"
+msgstr "MySQL gpnv"
+
+#: gtkgui.c:426
+msgid "MySQL user"
+msgstr "MySQL felhasznl"
+
+#: gtkgui.c:427
+msgid "Audio directory"
+msgstr "Audio knyvtr"
+
+#: gtkgui.c:428 gtkgui.c:729
+msgid "Bits per channel"
+msgstr "Bit/csatorna"
+
+#: gtkgui.c:429 gtkgui.c:730
+msgid "Bitrate"
+msgstr "Bitrta"
+
+#: gtkgui.c:430 gtkgui.c:731
+msgid "Encode to Ogg Vorbis"
+msgstr "tkdols Ogg Vorbis-ba"
+
+#: gtkgui.c:431 gtkgui.c:732
+msgid "Encode to MP3"
+msgstr "tkdols MP3-ba"
+
+#: gtkgui.c:432 gtkgui.c:733
+msgid "Encode to"
+msgstr "tkdols erre"
+
+#: gtkgui.c:684 gtkgui.c:977 log.c:142 main.c:633 main.c:1318
+msgid "Cannot open file..."
+msgstr "A fjlt nem lehet megnyitni..."
+
+#: gtkgui.c:706
+msgid "Number of tracks"
+msgstr "Svok szma"
+
+#: gtkgui.c:709 gtkgui.c:717
+msgid "Start track"
+msgstr "Kezd sv"
+
+#: gtkgui.c:711 gtkgui.c:719
+msgid "End track"
+msgstr "Utols sv"
+
+#: gtkgui.c:715 main.c:657
+msgid "No audio CD!"
+msgstr "A meghajtban nincs audio CD!"
+
+#: gtkgui.c:787 main.c:842
+msgid ""
+"Audio directory not exist!\n"
+"Do you wish to create?"
+msgstr ""
+"Az audio knyvtr nem ltezik!\n"
+"Ltre akarod hozni?"
+
+#: gtkgui.c:904 gtkgui.c:927 main.c:1248 main.c:1263
+msgid ""
+"Image file exist!\n"
+"Do you wish to overwrite it?"
+msgstr ""
+"A kpmsfjl ltezik!\n"
+"Szeretnd fellrni?"
+
+#: gtkgui.c:908 gtkgui.c:1291 main.c:1252
+msgid "Create image"
+msgstr "Kpms ksztse"
+
+#: gtkgui.c:917 gtkgui.c:1296 main.c:1411
+msgid "Blank CD-RW"
+msgstr "CD-RW trlse"
+
+#: gtkgui.c:931 gtkgui.c:1292 main.c:1267
+msgid "Copy CD image"
+msgstr "CD kpms msolsa"
+
+#: gtkgui.c:951 main.c:1286
+msgid "Write image"
+msgstr "Kpms rsa"
+
+#: gtkgui.c:1011
+msgid "Write direct log"
+msgstr "Kzvetlen rs naplja"
+
+#: gtkgui.c:1039 main.c:1383
+msgid "Write audio"
+msgstr "Audio rsa"
+
+#: gtkgui.c:1040
+msgid "Write audio log"
+msgstr "Audio rs naplja"
+
+#: gtkgui.c:1060 gtkgui.c:1295 main.c:1402
+msgid "Copy data CD"
+msgstr "Adat CD msolsa"
+
+#: gtkgui.c:1061
+msgid "Copy data CD log"
+msgstr "Adat CD msolsnak naplja"
+
+#: gtkgui.c:1151 main.c:613
+#, c-format
+msgid "Used: %2.1f%%, Wasted: %.0f/%d MB"
+msgstr "Felhasznlt: %2.1f%%, Mg szabad: %.0f/%d MB"
+
+#: gtkgui.c:1154 main.c:615
+#, c-format
+msgid "Used: %2.1f%%, Wasted: %d MB"
+msgstr "Hasznlt: %2.1f%%, Marad: %d MB"
+
+#: gtkgui.c:1203 main.c:957
+#, c-format
+msgid "Size: %.0f Mb in %d files"
+msgstr "Mret: %.0f MB %d fjl"
+
+#: gtkgui.c:1212 main.c:104
+msgid "Write from image"
+msgstr "rs kpmsfjlbl"
+
+#: gtkgui.c:1214 main.c:106
+msgid "Write direct    "
+msgstr "Kzvetlen rs     "
+
+#: gtkgui.c:1218 main.c:109
+msgid "Multi-session "
+msgstr "Tbbmenetes "
+
+#: gtkgui.c:1220 main.c:111
+msgid "Single session"
+msgstr "Egymenetes"
+
+#: gtkgui.c:1270
+msgid "CD label"
+msgstr "CD cmke"
+
+#: gtkgui.c:1270
+msgid "Display CD label editor window"
+msgstr "A CD cmke ablak megjelentse"
+
+#: gtkgui.c:1271
+msgid "Parameters"
+msgstr "Paramterek"
+
+#: gtkgui.c:1271
+msgid "Edit cdrecord parameters"
+msgstr "A cdrecord paramtereinek szerkesztse"
+
+#: gtkgui.c:1272
+msgid "CD Size"
+msgstr "CD mret"
+
+#: gtkgui.c:1272
+msgid "Select the size of disk"
+msgstr "A CD mretnek kivlasztsa"
+
+#: gtkgui.c:1273
+msgid "Log"
+msgstr "Napl"
+
+#: gtkgui.c:1273
+msgid "Display the content of log"
+msgstr "A naplfjl megtekintse"
+
+#: gtkgui.c:1274
+msgid "Display information about CD"
+msgstr "A CD informciinak megjelentse"
+
+#: gtkgui.c:1275
+msgid "Eject CD"
+msgstr "A CD kiadsa"
+
+#: gtkgui.c:1275
+msgid "Eject CD tray"
+msgstr "A CD tlca kiadsa"
+
+#: gtkgui.c:1277
+msgid "Display disk catalog"
+msgstr "Lemezkatalgus megjelentse"
+
+#: gtkgui.c:1278
+msgid "Add CD to disk catalog"
+msgstr "Lemez hozzadsa a lemezkatalgushoz"
+
+#: gtkgui.c:1280
+msgid "CD rip"
+msgstr "CD olvassa"
+
+#: gtkgui.c:1280
+msgid "Rip Audio CD"
+msgstr "Audio CD olvassa"
+
+#: gtkgui.c:1281 help.c:38 help.c:69
+msgid "Help"
+msgstr "Segtsg"
+
+#: gtkgui.c:1281
+msgid "Display help window"
+msgstr "A Segtsg ablak megjelentse"
+
+#: gtkgui.c:1283 main.c:448
+msgid "Menu"
+msgstr "Men"
+
+#: gtkgui.c:1289
+msgid "Add files..."
+msgstr "Fjl(ok) hozzadsa"
+
+#: gtkgui.c:1290
+msgid "Delete files"
+msgstr "Fjl(ok) trlse"
+
+#: gtkgui.c:1293
+msgid "Write data CD"
+msgstr "Adat CD rsa"
+
+#: gtkgui.c:1294
+msgid "Write audio CD"
+msgstr "Audio CD rsa"
+
+#: gtkgui.c:1297
+msgid "Options..."
+msgstr "Belltsok..."
+
+#: gtkgui.c:1298
+msgid "Quit"
+msgstr "Kilps"
+
+#: gtkgui.c:1317 main.c:453
+msgid "Info"
+msgstr "Informcik"
+
+#: gtkgui.c:1331
+msgid "Selected files:"
+msgstr "Kivlasztott fjl(ok):"
+
+#: gtkgui.c:1340
+msgid "Filename"
+msgstr "Fjlnv"
+
+#: gtkgui.c:1348
+msgid "Size:"
+msgstr "Mret:"
+
+#: help.c:40 help.c:71
+msgid "Press ESC to close window"
+msgstr "ESC: ablak bezrsa"
+
+#: help.c:41
+msgid "F1  - Show help"
+msgstr "F1  - Segtsg megjelentse"
+
+#: help.c:42
+msgid "F2  - CD label window"
+msgstr "F2  - CD cmke ablak"
+
+#: help.c:43
+msgid "F3  - Edit cdrecord parameters"
+msgstr "F3  - A cdrecord paramtereinek szerkesztse"
+
+#: help.c:44
+msgid "F4  - Select CD size"
+msgstr "F4  - CD mret kivlasztsa"
+
+#: help.c:45
+msgid "F5  - View last log"
+msgstr "F5  - A legutbbi napl megtekintse"
+
+#: help.c:46
+msgid "F6  - Information about raw disk material"
+msgstr "F6  - Informcik a lemezrl"
+
+#: help.c:47
+msgid "F10 - View the GPL"
+msgstr "F10 - A GPL megtekintse"
+
+#: help.c:48
+msgid "E   - Eject tray of CD-RW"
+msgstr "E   - CD-RW tlca kiadsa"
+
+#: help.c:49
+msgid "C   - Disk catalog"
+msgstr "C   - Lemezkatalgus"
+
+#: help.c:50
+msgid "A   - Add disk into Disk catalog"
+msgstr "A   - A lemez hozzadsa a lemezkatalgushoz"
+
+#: help.c:51
+msgid "G   - Grab audio CD"
+msgstr "G   - Audio CD msolsa"
+
+#: help.c:52
+msgid "Q   - Quit"
+msgstr "Q   - Kilps"
+
+#: help.c:72
+msgid "->     - Step into catalogized files window"
+msgstr "->     - Vlts a katalogizlt fjlok ablakra"
+
+#: help.c:73
+msgid "<-     - Step into menu window"
+msgstr "<-     - Vissza a menbe"
+
+#: help.c:74
+msgid "ENTER  - Change category or disk or directory"
+msgstr "ENTER  - Kategria-, lemez- vagy knyvtrvlts"
+
+#: help.c:75
+msgid "BSPACE"
+msgstr "BSPACE"
+
+#: help.c:76
+msgid "/      - Move one level up"
+msgstr "/      - Egy szintel feljebb"
+
+#: help.c:76
+msgid "DEL    - Delete category or disk"
+msgstr "DEL    - Kategria vagy lemez trlse"
+
+#: help.c:77
+msgid "A      - Add disk into catalog"
+msgstr "A      - Lemez hozzadsa a katalgushoz"
+
+#: help.c:78
+msgid "S      - Show all disks"
+msgstr "S      - sszes lemez mutatsa"
+
+#: help.c:79
+msgid "Q      - Quit Disk catalog"
+msgstr "Q      - Kilps a Lemez katalgusbl"
+
+#: log.c:83 log.c:87 log.c:98 log.c:107
+msgid "Ok"
+msgstr "OK"
+
+#: log.c:89 log.c:100 log.c:109
+msgid "Cancel"
+msgstr "Mgsem"
+
+#: main.c:107
+#, c-format
+msgid "Speed: %sX "
+msgstr "Sebessg: %sx"
+
+#: main.c:143 main.c:160 main.c:347
+#, c-format
+msgid "File: %s not found!"
+msgstr "A(z) %s fjl nem tallhat!"
+
+#: main.c:188 main.c:230 main.c:385
+msgid "Add files"
+msgstr "Fjl(ok) hozzadsa"
+
+#: main.c:411
+msgid " Add files           "
+msgstr " Fjl(ok) hozzadsa "
+
+#: main.c:412
+msgid " Delete files        "
+msgstr " Fjl(ok) trlse    "
+
+#: main.c:413
+msgid " Create image        "
+msgstr " Kpms ksztse    "
+
+#: main.c:414
+msgid " Copy CD image       "
+msgstr " CD kpms msolsa  "
+
+#: main.c:415
+msgid " Write data CD       "
+msgstr " Adat CD rsa       "
+
+#: main.c:416
+msgid " Write audio CD      "
+msgstr " Audio CD rsa      "
+
+#: main.c:417
+msgid " Copy data CD        "
+msgstr " Adat CD msolsa    "
+
+#: main.c:418
+msgid " Blank CD-RW         "
+msgstr " CD-RW trlse       "
+
+#: main.c:419
+msgid " Options             "
+msgstr " Belltsok         "
+
+#: main.c:420
+msgid " Quit                "
+msgstr " Kilps             "
+
+#: main.c:457
+msgid "Selected files"
+msgstr "Kivlasztott fjl(ok)"
+
+#: main.c:546
+msgid "Select CD size"
+msgstr "CD mret vlaszts"
+
+#: main.c:652
+msgid "Press G to start or ESC to exit"
+msgstr "G: indts, ESC: kilps"
+
+#: main.c:662
+msgid "Stereo"
+msgstr "Sztere"
+
+#: main.c:663
+msgid "Bits/Channel"
+msgstr "Bit/Csatorna"
+
+#: main.c:664 options.c:737
+msgid "Echo to sound dev."
+msgstr " Hangkrtyra is"
+
+#: main.c:670 options.c:743
+msgid "Encode to Ogg"
+msgstr "Ogg-ba kdols"
+
+#: main.c:672
+msgid "High Quality"
+msgstr "J minsg"
+
+#: main.c:684 options.c:751
+msgid "Encode to Mp3"
+msgstr "MP3-ba kdols"
+
+#: main.c:842
+msgid "Directory not exist"
+msgstr "A knyvtr nem ltezik"
+
+#: main.c:844
+msgid "Cannot create directory!"
+msgstr "A knyvtr ltrehozsa nem sikerlt!"
+
+#: main.c:1008
+#, c-format
+msgid "Usage: %s\n"
+msgstr "Hasznlat: %s\n"
+
+#: main.c:1030 main.c:1089
+msgid "Needed min 80x25 terminal!"
+msgstr "Minimum 80x25-s terminl szksges!"
+
+#: main.c:1051
+#, c-format
+msgid ""
+"Usage: %s [options]\n"
+"\n"
+msgstr ""
+"Hasznlat: %s [opcik]\n"
+"\n"
+
+#: main.c:1052
+msgid ""
+"Options:\n"
+"\n"
+msgstr ""
+"Opcik:\n"
+"\n"
+
+#: main.c:1054
+msgid "  --catalog | -c            : start in Disk Catalog mode\n"
+msgstr "  --catalog | -c            : indts lemezkatalgus mdban\n"
+
+#: main.c:1057
+msgid "  --gui     | -g            : start cdw in GUI mode\n"
+msgstr "  --gui     | -g            : a cdw indtsa grafikus fellettel\n"
+
+#: main.c:1059
+msgid "  --help    | -h            : show this screen\n"
+msgstr "  --help    | -h            : e kperny megjelentse\n"
+
+#: main.c:1060
+msgid ""
+"  --version | -v            : show version\n"
+"\n"
+msgstr ""
+"  --version | -v            : verzi megjelentse\n"
+"\n"
+
+#: main.c:1063
+#, c-format
+msgid "%s: invalid option -- %s\n"
+msgstr "%s: hibs opci -- %s\n"
+
+#: main.c:1064
+#, c-format
+msgid "Try `%s --help`\n"
+msgstr "Prbld gy `%s --help`\n"
+
+#: main.c:1156
+msgid "Last log"
+msgstr "Utols log"
+
+#: main.c:1177
+msgid "License"
+msgstr "Licenc"
+
+#: main.c:1248 main.c:1263
+msgid "Image exist"
+msgstr "A kpms mr ltezik"
+
+#: options.c:423 options.c:716
+msgid "<F1> General"
+msgstr "<F1> ltalnos"
+
+#: options.c:426 options.c:720
+msgid "<F2> Other"
+msgstr "<F2> Egyb"
+
+#: options.c:432
+msgid "Write CD from image"
+msgstr "CD rs kpmsbl"
+
+#: options.c:434
+msgid "CD-ROM"
+msgstr "CD-ROM"
+
+#: options.c:438
+msgid "Eject when done"
+msgstr "Kiads ha ksz"
+
+#: options.c:442
+msgid "Usefull RR attributes"
+msgstr "RR attribtumok"
+
+#: options.c:445
+msgid "Auto show volume"
+msgstr "Auto cmke"
+
+#: options.c:448 options.c:541 options.c:548 options.c:588 options.c:595
+msgid "Multi-session"
+msgstr "Multi-session"
+
+#: options.c:729
+msgid "Auto Disk Catalog"
+msgstr "Auto Lemez Katalgus"
+
+#: options.c:970
+msgid "Press F10 to save config or ESC to cancel"
+msgstr "F10: ments, ESC: kilp ments nlkl"
+
+#: thread.c:441 thread.c:509
+msgid "     Press any key     "
+msgstr " ss le egy billentyt "
+
+#~ msgid "<P> MySQL passwd:"
+#~ msgstr "<P> MySQL jelsz:"
+
+msgid "General"
+msgstr "ltalnos"
+
+msgid "Other"
+msgstr "Egyb"
+
+msgid "Version"
+msgstr "Verzi"
+
+msgid "SQLite DB file"
+msgstr "SQLite adatbzis"
+
+msgid "SQLite database file not exists!\nMay I create it?"
+msgstr "A SQLite adatbzis nem ltezik!\nLtrehozhatom?"
diff -Naur orig/po/POTFILES.in patched/po/POTFILES.in
--- orig/po/POTFILES.in	1970-01-01 01:00:00.000000000 +0100
+++ patched/po/POTFILES.in	2007-12-12 19:53:45.000000000 +0100
@@ -0,0 +1,15 @@
+src/cdda2wav.c
+src/cddb.c
+src/cdrom_ctrl.c
+src/cdw_cdio.c
+src/cdw_ui.c
+src/cdw_widgets.c
+src/commands.c
+src/help.c
+src/log.c
+src/main.c
+src/options.c
+src/pipe_regexp.c
+src/processwin.c
+src/thread.c
+src/utils.c
diff -Naur orig/src/cddb.c patched/src/cddb.c
--- orig/src/cddb.c	2011-04-17 16:35:51.000000000 +0200
+++ patched/src/cddb.c	2014-01-19 20:49:58.000000000 +0100
@@ -13,7 +13,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #include <stdio.h>
 #include <unistd.h>
@@ -27,7 +27,7 @@
 
 #include "cdw_ncurses.h"
 
-#include "config.h"
+#include "config_cdw.h"
 
 #include "cdw_config.h"
 #include "gettext.h"
diff -Naur orig/src/config_cdw_undefine.h patched/src/config_cdw_undefine.h
--- orig/src/config_cdw_undefine.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/config_cdw_undefine.h	2014-04-06 22:20:18.000000000 +0200
@@ -0,0 +1,39 @@
+#ifndef H_CONFIG_CDW_UNDEFINE
+#define H_CONFIG_CDW_UNDEFINE
+
+/* Undefine some values that may have been defined in library headers
+   included by cdw. This is to avoid clash of names in global
+   namespace: VERSION may be defined by cdw's config.h as well as in
+   some library's config.h. */
+
+#ifdef VERSION
+#undef VERSION
+#endif
+
+#ifdef PACKAGE
+#undef PACKAGE
+#endif
+
+#ifdef PACKAGE_VERSION
+#undef PACKAGE_VERSION
+#endif
+
+#ifdef PACKAGE_TARNAME
+#undef PACKAGE_TARNAME
+#endif
+
+#ifdef PACKAGE_STRING
+#undef PACKAGE_STRING
+#endif
+
+#ifdef PACKAGE_NAME
+#undef PACKAGE_NAME
+#endif
+
+#ifdef PACKAGE_BUGREPORT
+#undef PACKAGE_BUGREPORT
+#endif
+
+
+
+#endif // #ifndef H_CONFIG_CDW_UNDEFINE
diff -Naur orig/src/configuration/cdw_config.c patched/src/configuration/cdw_config.c
--- orig/src/configuration/cdw_config.c	2012-03-28 20:24:49.000000000 +0200
+++ patched/src/configuration/cdw_config.c	2014-04-12 20:21:08.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -42,7 +42,6 @@
 #include <sys/types.h>
 
 
-#include "config.h"
 #include "cdw_config.h"
 #include "cdw_config_window.h"
 #include "gettext.h"
@@ -53,10 +52,15 @@
 #include "cdw_debug.h"
 #include "cdw_utils.h"
 #include "cdw_ext_tools.h"
+#include "cdw_mkudffs_options.h"
 #include "cdw_erase_disc.h"
 #include "cdw_drive.h"
 #include "cdw_iso9660.h"
 
+#include "config_cdw_undefine.h"
+
+#include "config_cdw.h"
+
 extern const char *cdw_log_file_name;
 
 
@@ -92,7 +96,7 @@
 
 static char *cdw_config_init_config_dir(const char *base_dir);
 static cdw_rv_t cdw_config_read_from_file(const char *fullpath);
-
+static void cdw_config_free_paths(void);
 
 
 /** \brief Hardwired name of cdw configuration file */
@@ -122,6 +126,13 @@
 static cdw_rv_t cdw_config_var_set_defaults(cdw_config_t *_config);
 static cdw_rv_t cdw_config_module_set_paths(void);
 
+static bool cdw_config_option_match(char *option_name, char *option_value, const char *searched_option_name, const char *option_values[], cdw_id_t *option, int init, int max);
+
+
+static cdw_rv_t cdw_config_general_copy(cdw_config_general_t *dest, cdw_config_general_t *src);
+static cdw_rv_t cdw_config_general_set_defaults(cdw_config_general_t *general);
+static void     cdw_config_debug_general_print_options(cdw_config_general_t *general);
+
 
 struct cdw_config_vst_t {
 	cdw_id_t id;
@@ -133,7 +144,7 @@
 
 
 static struct cdw_config_vst_t cdw_config_volume_size_table[] = {
-	/*         id;                      old_label             new_label;               size   */
+	/*         id;                      old_label             new_label;               size                            */
 	{ CDW_CONFIG_VOLUME_SIZE_CD74,        "650",                "cd74",                681984000  / (1024 * 1024)     },
 	{ CDW_CONFIG_VOLUME_SIZE_CD80,        "703",                "cd80",                737280000  / (1024 * 1024)     },
 	{ CDW_CONFIG_VOLUME_SIZE_DVD_GENERIC, "4482",               "dvd",                 4700372992 / (1024 * 1024)     },
@@ -143,9 +154,9 @@
 	{ CDW_CONFIG_VOLUME_SIZE_DVD_RWP,     "4482",               "dvd+rw",              4700372992 / (1024 * 1024)     },
 	{ CDW_CONFIG_VOLUME_SIZE_DVD_R_DL,    "dvd-r dl",           "dvd-r dl",            8543666176 / (1024 * 1024)     },
 	{ CDW_CONFIG_VOLUME_SIZE_DVD_RP_DL,   "dvd+r dl",           "dvd+r dl",            8547991552 / (1024 * 1024)     },
-	{ CDW_CONFIG_VOLUME_SIZE_CUSTOM,      "custom",             "custom",              0      },
-	{ CDW_CONFIG_VOLUME_SIZE_AUTO,        "auto",               "auto",                0      },
-	{ -1,                                 (char *) NULL,        (char *) NULL,         0      } };
+	{ CDW_CONFIG_VOLUME_SIZE_CUSTOM,      "custom",             "custom",              0                              },
+	{ CDW_CONFIG_VOLUME_SIZE_AUTO,        "auto",               "auto",                0                              },
+	{ -1,                                 (char *) NULL,        (char *) NULL,         0                              } };
 
 
 long int cdw_config_get_volume_size_mb_by_id(cdw_id_t id)
@@ -193,6 +204,10 @@
  */
 cdw_rv_t cdw_config_module_init(void)
 {
+	/* FIXME: problem with including cdw_task.h leads to using
+	   magic number. */
+	global_config.task_id = 0; //CDW_TASK_NONE;
+
 	cdw_rv_t crv = cdw_config_module_set_paths();
 	if (crv == CDW_NO || crv == CDW_OK) { /* paths are set correctly... */
 		if (crv == CDW_NO) { /* ... but not to $HOME */
@@ -236,7 +251,7 @@
 	   file, don't create config file if it doesn't exist already */
 
 	char *path = config_file_fullpath;
-	if (old_config_file_fullpath != (char *) NULL) {
+	if (old_config_file_fullpath) {
 		if (!access(old_config_file_fullpath, F_OK)) {
 			/* can't log into log file, since it is not configured yet */
 
@@ -291,10 +306,10 @@
 		return CDW_CANCEL;
 	}
 
-	cdw_assert (config_file_fullpath != (char *) NULL, "full path to config file is null\n");
+	cdw_assert (config_file_fullpath, "full path to config file is null\n");
 
 	FILE *config_file = fopen(config_file_fullpath, "w");
-	if (config_file == (FILE *) NULL) {
+	if (!config_file) {
 		int e = errno;
 		cdw_vdm ("ERROR: failed open config file \"%s\" for writing\n", config_file_fullpath);
 
@@ -347,10 +362,10 @@
 		return CDW_CANCEL; /* emergency mode, don't work with filesystem */
 	}
 
-	cdw_assert (fullpath != (char *) NULL, "full path to config file is null\n");
+	cdw_assert (fullpath, "full path to config file is null\n");
 
 	FILE *config_file = fopen(fullpath, "r");
-	if (config_file == (FILE *) NULL) {
+	if (!config_file) {
 		int e = errno;
 		cdw_vdm ("WARNING: failed open config file \"%s\" for reading (errno = \"%s\")\n",
 			 fullpath, strerror(e));
@@ -419,13 +434,13 @@
 */
 cdw_rv_t cdw_config_module_set_paths(void)
 {
-	cdw_assert (base_dir_fullpath == (char *) NULL,
+	cdw_assert (!base_dir_fullpath,
 		    "ERROR: called this function when base dir is already initialized\n");
-	cdw_assert (config_file_fullpath == (char *) NULL,
+	cdw_assert (!config_file_fullpath,
 		    "ERROR: called this function when base dir is already initialized\n");
 
 	base_dir_fullpath = cdw_fs_get_home_or_tmp_dirpath();
-	if (base_dir_fullpath == (char *) NULL) {
+	if (!base_dir_fullpath) {
 		cdw_vdm ("ERROR: failed to create base dir fullpath\n");
 		return CDW_ERROR;
 	}
@@ -433,31 +448,22 @@
 	/* at this point we have path to user home directory
 	   or some tmp directory; now we set path to conf file */
 	config_dir_fullpath = cdw_config_init_config_dir(base_dir_fullpath);
-	if (config_dir_fullpath == (char *) NULL) {
-		free(base_dir_fullpath);
-		base_dir_fullpath = (char *) NULL;
+	if (!config_dir_fullpath) {
+		cdw_config_free_paths();
 		cdw_vdm ("ERROR: failed to create base dir fullpath\n");
 		return CDW_ERROR;
 	}
 
 	config_file_fullpath = cdw_string_concat(config_dir_fullpath, config_file_name, (char *) NULL);
-	if (config_file_fullpath == (char *) NULL) {
-		free(base_dir_fullpath);
-		base_dir_fullpath = (char *) NULL;
-		free(config_dir_fullpath);
-		config_dir_fullpath = (char *) NULL;
+	if (!config_file_fullpath) {
+		cdw_config_free_paths();
 		cdw_vdm ("ERROR: failed to create config file fullpath\n");
 		return CDW_ERROR;
 	}
 
 	old_config_file_fullpath = cdw_string_concat(base_dir_fullpath, old_config_file_name, (char *) NULL);
-	if (old_config_file_fullpath == (char *) NULL) {
-		free(base_dir_fullpath);
-		base_dir_fullpath = (char *) NULL;
-		free(config_dir_fullpath);
-		config_dir_fullpath = (char *) NULL;
-		free(config_file_fullpath);
-		config_file_fullpath = (char *) NULL;
+	if (!old_config_file_fullpath) {
+		cdw_config_free_paths();
 		cdw_vdm ("ERROR: failed to create config file fullpath\n");
 		return CDW_ERROR;
 	}
@@ -480,7 +486,7 @@
 char *cdw_config_init_config_dir(const char *base_dir)
 {
 	char *dir = cdw_string_concat(base_dir, ".cdw/", (char *) NULL);
-	if (dir == (char *) NULL) {
+	if (!dir) {
 		cdw_vdm ("ERROR: failed to concat config dir\n");
 		return (char *) NULL;
 	}
@@ -526,13 +532,13 @@
 */
 void cdw_config_module_clean(void)
 {
-	if (config_file_fullpath != (char *) NULL) {
+	if (config_file_fullpath) {
 		/* some changes could be made outside of cdw configuration window,
 		   this line ensures that the changes will be saved */
 		cdw_config_write_to_file();
 
 		/* part of migrating cdw config file to new location */
-		if (old_config_file_fullpath != (char *) NULL) {
+		if (old_config_file_fullpath) {
 			if (!access(old_config_file_fullpath, F_OK)) {
 				unlink(old_config_file_fullpath);
 			}
@@ -544,28 +550,42 @@
 		cdw_vdm ("ERROR: path to config file not initialized\n");
 	}
 
-	if (config_file_fullpath != (char *) NULL) {
+	cdw_config_free_paths();
+
+	cdw_config_var_free_fields(&global_config);
+
+	return;
+}
+
+
+
+
+
+/*
+  Free all strings with paths used by cdw_config module.
+*/
+void cdw_config_free_paths(void)
+{
+	if (config_file_fullpath) {
 		free(config_file_fullpath);
 		config_file_fullpath = (char *) NULL;
 	}
 
-	if (old_config_file_fullpath != (char *) NULL) {
+	if (old_config_file_fullpath) {
 		free(old_config_file_fullpath);
 		old_config_file_fullpath = (char *) NULL;
 	}
 
-	if (config_dir_fullpath != (char *) NULL) {
+	if (config_dir_fullpath) {
 		free(config_dir_fullpath);
 		config_dir_fullpath = (char *) NULL;
 	}
 
-	if (base_dir_fullpath != (char *) NULL) {
+	if (base_dir_fullpath) {
 		free(base_dir_fullpath);
 		base_dir_fullpath = (char *) NULL;
 	}
 
-	cdw_config_var_free_fields(&global_config);
-
 	return;
 }
 
@@ -586,33 +606,16 @@
 */
 cdw_rv_t cdw_config_var_copy(cdw_config_t *dest, cdw_config_t *src)
 {
-	cdw_rv_t ss = CDW_ERROR;
+	dest->task_id = src->task_id;
 
+	/* Write. */
+	cdw_write_copy(&dest->burn, &src->burn);
 
-	/* page A (writing) */
-	dest->write_pad = src->write_pad;
-	dest->write_pad_size = src->write_pad_size;
-	dest->erase_mode = src->erase_mode;
-	dest->eject = src->eject;
-	dest->burnproof = src->burnproof;
-	ss = cdw_string_set(&(dest->other_cdrecord_options), src->other_cdrecord_options);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set other_cdrecord_options from src = \"%s\"\n", src->other_cdrecord_options);
-		return CDW_ERROR;
-	}
-	ss = cdw_string_set(&(dest->other_growisofs_options), src->other_growisofs_options);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set other_growisofs_options from src = \"%s\"\n", src->other_growisofs_options);
-		return CDW_ERROR;
-	}
-	ss = cdw_string_set(&(dest->other_xorriso_burn_options), src->other_xorriso_burn_options);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set other_xorriso_burn_options from src = \"%s\"\n", src->other_xorriso_burn_options);
-		return CDW_ERROR;
-	}
+	/* Erase. */
+	cdw_erase_copy(&dest->erase, &src->erase);
 
 
-	/* page B (hardware) */
+	/* CONFIG_PAGE_ID_HW */
 	strncpy(dest->custom_drive, src->custom_drive, OPTION_FIELD_LEN_MAX);
 	dest->custom_drive[OPTION_FIELD_LEN_MAX] = '\0';
 	strncpy(dest->selected_drive, src->selected_drive, OPTION_FIELD_LEN_MAX);
@@ -621,70 +624,65 @@
 	dest->scsi[OPTION_FIELD_LEN_MAX] = '\0';
 
 
-	/* page C (audio) */
-	ss = cdw_string_set(&(dest->audiodir), src->audiodir);
-	if (ss != CDW_OK) {
+	/* CONFIG_PAGE_ID_AUDIO */
+	cdw_rv_t crv = cdw_string_set(&(dest->audiodir), src->audiodir);
+	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to set audiodir from src = \"%s\"\n", src->audiodir);
 		return CDW_ERROR;
 	}
 
 
-	/* page D (iso filesystem) */
-	strcpy(dest->volume_id, src->volume_id);
-	strcpy(dest->volume_set_id, src->volume_set_id);
-	strcpy(dest->preparer, src->preparer);
-	strcpy(dest->publisher, src->publisher);
-	strcpy(dest->system_id, src->system_id);
-	strcpy(dest->copyright, src->copyright);
-	strcpy(dest->abstract, src->abstract);
-
-	dest->iso_level = src->iso_level;
-	dest->joliet = src->joliet;
-	dest->rock_ridge = src->rock_ridge;
-	dest->joliet_long = src->joliet_long;
-	dest->follow_symlinks = src->follow_symlinks;
-	ss = cdw_string_set(&(dest->iso_image_full_path), src->iso_image_full_path);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set iso_image_full path from src = \"%s\"\n", src->iso_image_full_path);
-		return CDW_ERROR;
-	}
-	ss = cdw_string_set(&(dest->boot_disc_options), src->boot_disc_options);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set boot_disc options = \"%s\"\n", src->boot_disc_options);
-		return CDW_ERROR;
-	}
-	ss = cdw_string_set(&(dest->mkisofs_root_dir), src->mkisofs_root_dir);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set root_dir from src = \"%s\"\n", src->mkisofs_root_dir);
+	/* ISO9660 filesystem. */
+	crv = cdw_iso9660_copy(&(dest->iso9660), &(src->iso9660));
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to copy ISO9660 options\n");
 		return CDW_ERROR;
 	}
-	ss = cdw_string_set(&(dest->other_mkisofs_options), src->other_mkisofs_options);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set other_mkisofs_options from src = \"%s\"\n", src->other_mkisofs_options);
+
+
+	/* UDF filesystem. */
+	crv = cdw_udf_copy(&(dest->udf), &(src->udf));
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to copy UDF options\n");
 		return CDW_ERROR;
 	}
-	ss = cdw_string_set(&(dest->other_xorriso_iso_options), src->other_xorriso_iso_options);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set other_xorriso_options from src = \"%s\"\n", src->other_xorriso_iso_options);
+
+
+	/* General options, including options from CONFIG_PAGE_ID_OTHER page. */
+	crv = cdw_config_general_copy(&dest->general, &src->general);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to copy general options\n");
 		return CDW_ERROR;
 	}
 
+	return CDW_OK;
+}
+
 
-	/* page F (log and other) */
-	ss = cdw_string_set(&(dest->log_full_path), src->log_full_path);
-	if (ss != CDW_OK) {
-		cdw_vdm ("ERROR: failed to set log_full_path from src = \"%s\"\n", src->log_full_path);
+
+
+
+cdw_rv_t cdw_config_general_copy(cdw_config_general_t *dest, cdw_config_general_t *src)
+{
+	cdw_rv_t crv = cdw_string_set(&(dest->image_fullpath), src->image_fullpath);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set image_full_path from src = \"%s\"\n", src->image_fullpath);
 		return CDW_ERROR;
 	}
-	dest->showlog = src->showlog;
 
-	dest->volume_size_id = src->volume_size_id;
-	dest->volume_size_custom_value = src->volume_size_custom_value;
+	crv = cdw_string_set(&(dest->log_fullpath), src->log_fullpath);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set log_full_path from src = \"%s\"\n", src->log_fullpath);
+		return CDW_ERROR;
+	}
 
-	/* other, without field in config window */
-	dest->support_dvd_rp_dl = src->support_dvd_rp_dl;
+	dest->show_log                    = src->show_log;
+	dest->volume_size_id              = src->volume_size_id;
+	dest->volume_size_custom_value    = src->volume_size_custom_value;
+	dest->selected_follow_symlinks    = src->selected_follow_symlinks;
+	dest->display_hidden_files        = src->display_hidden_files;     /* This one is in "general.", but is not displayed in Configuration window. */
+	dest->support_dvd_rp_dl           = src->support_dvd_rp_dl;
 	dest->show_dvd_rw_support_warning = src->show_dvd_rw_support_warning;
-	dest->fs.display_hidden_files = src->fs.display_hidden_files;
 
 	return CDW_OK;
 }
@@ -696,26 +694,26 @@
 /**
    \brief Check if values in config variable are valid
 
-   Check values stored in given configuration variable.
-   Function checks only one specified subset of all config variable fields,
-   or all verifiable config variable fields, depending on value of \p page.
-   Use page symbolic name PAGE_{A,B,C,D,E}_INDEX to select one, specific
-   subset corresponding to page in configuration window (see definitions
-   in cdw_config_ui.h). Set \p page to -1 if you want to check all
-   verifiable values from all pages. Page numbers correspond to
-   configuration pages created in options_ui.c file, and fields of
-   configuration variable are grouped just like fields in options_ui.c.
-
-   If page, for which caller requested validation (or any page if \p page
-   is set to -1) contains errors, then \p page will be set to number of
-   page that has errors, and \p field will be set to number of invalid
-   field in that page. CDW_NO is returned.
-
-   If there are no invalid fields, value of \p field is unspecified, and
-   CDW_OK is returned.
+   Check values stored in given configuration variable *AND* displayed
+   in main configuration window. Important: the function validates
+   only variables that are displayed in main configuration window of
+   the application.
+
+   Function can check variables from all pages of the configuration
+   window: you should pass -1 via \page.
+
+   Function can also check variables from a specific page of the
+   configuration window only: you should pass one of values declared
+   in cdw_config.h/'enum c_pages_order' via \page. ORing the IDs of
+   pages doesn't work.
+
+   If page, for which caller requested validation (or any page if \p
+   page is set to -1) contains errors, then \p page will be set to ID
+   of page that has errors, and \p field will be set to index of
+   invalid field in that page. CDW_NO is returned.
 
-   Currently only part of field values are checked. E.g. 'pad' field is
-   not checked.
+   If there are no invalid fields, value of \p field and \p page is
+   unspecified, and CDW_OK is returned.
 
    \param config - configuration variable to be checked
    \param page - number of page, from which parameters should be checked
@@ -728,8 +726,7 @@
 {
 	/* IDs are defined in cdw_config.h  */
 
-	cdw_rv_t crv;
-	/* hardware */
+	/* CONFIG_PAGE_ID_HW */
 	if (*page == -1 || *page == CONFIG_PAGE_ID_HW) {
 		/* FIXME: use ID instead of string */
 		if (!strcmp(config->selected_drive, "custom")) {
@@ -745,7 +742,7 @@
 			}
 		}
 
-		crv = cdw_string_security_parser(config->custom_drive, (char *) NULL);
+		cdw_rv_t crv = cdw_string_security_parser(config->custom_drive, (char *) NULL);
 		if (crv == CDW_NO) {
 			*field = f_custom_drive_i;
 			*page = CONFIG_PAGE_ID_HW;
@@ -757,8 +754,7 @@
 		   validate and fix path entered by user */
 		size_t len = strlen(config->custom_drive);
 		if (len > 1) {
-			size_t i = 0;
-			for (i = len - 1; i > 0; i--) {
+			for (size_t i = len - 1; i > 0; i--) {
 				if (config->custom_drive[i] == '/') {
 					config->custom_drive[i] = '\0';
 				} else {
@@ -778,8 +774,10 @@
 
 	}
 
-	if (*page == -1 || *page == CONFIG_PAGE_ID_AUDIO) { /* "audio" page */
-		crv = cdw_string_security_parser(config->audiodir, (char *) NULL);
+
+	/* CONFIG_PAGE_ID_AUDIO */
+	if (*page == -1 || *page == CONFIG_PAGE_ID_AUDIO) {
+		cdw_rv_t crv = cdw_string_security_parser(config->audiodir, (char *) NULL);
 		if (crv == CDW_NO) {
 			*field = f_audiodir_i;
 			*page = CONFIG_PAGE_ID_AUDIO;
@@ -788,7 +786,8 @@
 	}
 
 
-	if (*page == -1 || *page == CONFIG_PAGE_ID_TOOLS) { /* "tools" page */
+	/* CONFIG_PAGE_ID_TOOLS */
+	if (*page == -1 || *page == CONFIG_PAGE_ID_TOOLS) {
 		; /* tool paths are read from "which" output, I won't validate this */
 		; /* WARNING for the future: keep in mind that at some
 		     occasions "tools" page is hidden, and it must not be
@@ -796,20 +795,30 @@
 		     be unable to visit the page to fix the errors */
 	}
 
-	if (*page == -1 || *page == CONFIG_PAGE_ID_OTHER) { /* "log and other" page */
-		if (!strlen(config->log_full_path)) {
+
+	/* CONFIG_PAGE_ID_OTHER */
+	if (*page == -1 || *page == CONFIG_PAGE_ID_OTHER) {
+		if (!strlen(config->general.log_fullpath)) {
 			/* there has to be some log path specified */
 			*field = f_log_fp_i;
 			*page = CONFIG_PAGE_ID_OTHER;
 			return CDW_NO;
 		}
-		crv = cdw_string_security_parser(config->log_full_path, (char *) NULL);
+		cdw_rv_t crv = cdw_string_security_parser(config->general.log_fullpath, (char *) NULL);
 		if (crv == CDW_NO) {
 			*field = f_log_fp_i;
 			*page = CONFIG_PAGE_ID_OTHER;
 			return CDW_NO;
 		}
-		if (config->volume_size_custom_value == -1) {
+		if (config->general.volume_size_custom_value < 0) {
+			*field = f_cust_volume_size_i;
+			*page = CONFIG_PAGE_ID_OTHER;
+			return CDW_NO;
+		}
+
+		if (config->general.volume_size_id == CDW_CONFIG_VOLUME_SIZE_CUSTOM
+		    && config->general.volume_size_custom_value == 0) {
+
 			*field = f_cust_volume_size_i;
 			*page = CONFIG_PAGE_ID_OTHER;
 			return CDW_NO;
@@ -849,39 +858,36 @@
 */
 cdw_rv_t cdw_config_var_init_fields(cdw_config_t *config)
 {
-	cdw_assert (config != (cdw_config_t *) NULL, "passing null config variable\n");
+	cdw_assert (config, "ERROR: passed NULL config variable\n");
 
-	/* page A (writing) */
-	config->other_cdrecord_options = (char *) NULL;
-	config->other_growisofs_options = (char *) NULL;
-	config->other_xorriso_burn_options = (char *) NULL;
-	config->log_full_path = (char *) NULL;
 
-
-	/* page C (audio) */
+	/* CONFIG_PAGE_ID_AUDIO */
 	config->audiodir = (char *) NULL;
 
 
-	/* page D (iso filesystem) */
-	config->volume_id[0] = '\0'; /* empty string */
-	config->volume_set_id[0] = '\0';
-	config->preparer[0] = '\0';
-	config->publisher[0] = '\0';
-	config->system_id[0] = '\0';
-	config->copyright[0] = '\0';
-	config->abstract[0] = '\0';
-
-	config->iso_image_full_path = (char *) NULL;
-	config->boot_disc_options = (char *) NULL;
-	config->mkisofs_root_dir = (char *) NULL;
-	config->other_mkisofs_options = (char *) NULL;
-	config->other_xorriso_iso_options = (char *) NULL;
+	/* CONFIG_PAGE_ID_HW */
+	/* No pointers to initialize. */
 
 
-	/* page E (external tools) */
-	/* paths external tools are initialized by other module;
+	/* CONFIG_PAGE_ID_TOOLS */
+	/* Paths to external tools are initialized by other module;
 	   the paths aren't tightly related to options in this file */
 
+
+	/* General options, including those presented in
+	   CONFIG_PAGE_ID_OTHER page. */
+	config->general.image_fullpath = (char *) NULL;
+	config->general.log_fullpath = (char *) NULL;
+
+
+	/* ISO9660 and UDF options. */
+	cdw_iso9660_init(&(config->iso9660));
+	cdw_udf_init(&(config->udf));
+
+
+	/* Other. */
+	cdw_write_init(&config->burn);
+
 	return CDW_OK;
 }
 
@@ -904,58 +910,36 @@
 */
 cdw_rv_t cdw_config_var_free_fields(cdw_config_t *config)
 {
-	cdw_assert (config != (cdw_config_t *) NULL, "passing null config pointer\n");
-
-	/* page A - writing */
-	if (config->other_cdrecord_options != (char *) NULL) {
-		free(config->other_cdrecord_options);
-		config->other_cdrecord_options = (char *) NULL;
-	}
-	if (config->other_growisofs_options != (char *) NULL) {
-		free(config->other_growisofs_options);
-		config->other_growisofs_options = (char *) NULL;
-	}
-	if (config->other_xorriso_burn_options != (char *) NULL) {
-		free(config->other_xorriso_burn_options);
-		config->other_xorriso_burn_options = (char *) NULL;
-	}
+	cdw_assert (config, "passing null config pointer\n");
 
 
-	/* page C - audio */
-	if (config->audiodir != (char *) NULL) {
+	/* CONFIG_PAGE_ID_AUDIO */
+	if (config->audiodir) {
 		free(config->audiodir);
 		config->audiodir = (char *) NULL;
 	}
 
 
-	/* page D - iso filesystem */
-	if (config->iso_image_full_path != (char *) NULL) {
-		free(config->iso_image_full_path);
-		config->iso_image_full_path = (char *) NULL;
-	}
-	if (config->boot_disc_options != (char *) NULL) {
-		free(config->boot_disc_options);
-		config->boot_disc_options = (char *) NULL;
-	}
-	if (config->mkisofs_root_dir != (char *) NULL) {
-		free(config->mkisofs_root_dir);
-		config->mkisofs_root_dir = (char *) NULL;
-	}
-	if (config->other_mkisofs_options != (char *) NULL) {
-		free(config->other_mkisofs_options);
-		config->other_mkisofs_options = (char *) NULL;
+	/* ISO9660 and UDF options. */
+	cdw_iso9660_clean(&(config->iso9660));
+	cdw_udf_clean(&(config->udf));
+
+
+	/* General options, including those presented in
+	   CONFIG_PAGE_ID_OTHER page. */
+	if (config->general.image_fullpath) {
+		free(config->general.image_fullpath);
+		config->general.image_fullpath = (char *) NULL;
 	}
-	if (config->other_xorriso_iso_options != (char *) NULL) {
-		free(config->other_xorriso_iso_options);
-		config->other_xorriso_iso_options = (char *) NULL;
+
+	if (config->general.log_fullpath) {
+		free(config->general.log_fullpath);
+		config->general.log_fullpath = (char *) NULL;
 	}
 
 
-	/* page F - log */
-	if (config->log_full_path != (char *) NULL) {
-		free(config->log_full_path);
-		config->log_full_path = (char *) NULL;
-	}
+	/* Other options that aren't presented in Configuration window. */
+	cdw_write_clean(&config->burn);
 
 	return CDW_OK;
 }
@@ -1003,54 +987,16 @@
  */
 cdw_rv_t cdw_config_var_set_defaults(cdw_config_t *config)
 {
-	cdw_assert (base_dir_fullpath != (char *) NULL, "base_dir_fullpath must not be null\n");
-
-
-	/* page A - writing */
-	config->write_pad = true;
-	/* the "150" value is selected after small tests with DVD; originally it was 63, which
-	   worked just fine for CDs, but for DVDs it was insufficient;
-	   TODO: the same value is used in code creating configuration forms,
-	   so it should be a constant defined in some header */
-	/* OLD COMMENT: value of 63 is taken from here:
-	   http://www.troubleshooters.com/linux/coasterless.htm */
-	config->write_pad_size = 150;
-	config->erase_mode = CDW_ERASE_MODE_FAST;
-	config->eject = false;
-	config->burnproof = true;
-
-	/* can't set to (char *) NULL because these options are used as
-	argument of concat() in some places */
-	cdw_string_set(&(config->other_cdrecord_options), " ");
-	if (config->other_cdrecord_options == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to set other_cdrecord_options\n");
-		return CDW_ERROR;
-	}
-	cdw_string_set(&(config->other_growisofs_options), " ");
-	if (config->other_growisofs_options == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to set other_growisofs_options\n");
-		return CDW_ERROR;
-	}
-	cdw_string_set(&(config->other_xorriso_burn_options), " ");
-	if (config->other_xorriso_burn_options == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to set other_xorriso_burn_options\n");
-		return CDW_ERROR;
-	}
+	cdw_assert (base_dir_fullpath, "ERROR: base_dir_fullpath must not be NULL\n");
 
 
-	/* page B - hardware */
-	strcpy(config->custom_drive, "");
-	strcpy(config->selected_drive, "default");
-	strcpy(config->scsi,""); /* some (most?) users will prefer to leave it empty */
-
-
-	/* page C - audio */
+	/* CONFIG_PAGE_ID_AUDIO */
 	cdw_rv_t crv = CDW_NO;
 	if (failsafe_mode) {
 		crv = cdw_string_set(&(config->audiodir), "/tmp/audio/");
 	} else {
 		char *tmp2 = cdw_string_concat(base_dir_fullpath, "audio/", (char *) NULL);
-		if (tmp2 == (char *) NULL) {
+		if (!tmp2) {
 			cdw_vdm ("ERROR: failed to concat string for audiodir\n");
 			return CDW_ERROR;
 		} else {
@@ -1060,37 +1006,68 @@
 			tmp2 = (char *) NULL;
 		}
 	}
-	if (config->audiodir == (char *) NULL || crv != CDW_OK) {
+	if (!(config->audiodir) || crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to set audiodir\n");
 		return CDW_ERROR;
 	}
 
 
 
-	/* page D - iso filesystem */
-	/* 2TRANS: this is a default label for ISO9660 volume */
-	strncpy(config->volume_id, _("my volume"), CDW_ISO9660_VOLI_LEN);
-	config->volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
-	config->iso_level = 3;
-	config->joliet = true;
-	config->rock_ridge = CDW_ISO9660_RR_USEFUL;
-	config->joliet_long = false; /* breaks a standard, use with care */
-	config->follow_symlinks = false;
-
-	cdw_string_set(&(config->iso_image_full_path), "/tmp/image.iso");
-	if (config->iso_image_full_path == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to set iso_image_full_path\n");
+	/* CONFIG_PAGE_ID_HW */
+	strcpy(config->custom_drive, "");
+	strcpy(config->selected_drive, "default");
+	strcpy(config->scsi,""); /* some (most?) users will prefer to leave it empty */
+
+
+
+	/* ISO9660 and UDF options/ */
+	crv = cdw_iso9660_set_defaults(&(config->iso9660));
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set defaults for ISO9660 options\n");
+		return CDW_ERROR;
+	}
+
+	crv = cdw_udf_set_defaults(&(config->udf));
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set defaults for UDF options\n");
+		return CDW_ERROR;
+	}
+
+
+
+	/* General options, including those presented in
+	   CONFIG_PAGE_ID_OTHER page. */
+	crv = cdw_config_general_set_defaults(&config->general);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set defaults for general options\n");
 		return CDW_ERROR;
 	}
-	cdw_string_set(&(config->boot_disc_options), "");
-	/* can't set to (char *) NULL because these options are used as
-	   argument of concat() in some places */
-	cdw_string_set(&(config->mkisofs_root_dir), " ");
-	cdw_string_set(&(config->other_mkisofs_options), " ");
-	cdw_string_set(&(config->other_xorriso_iso_options), " ");
 
 
-	/* page F - log and other */
+	/* Other options, not presented in configuration window. */
+	cdw_erase_set_defaults(&config->erase);
+
+	crv = cdw_write_set_defaults(&config->burn);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set defaults for write options\n");
+		return CDW_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_config_general_set_defaults(cdw_config_general_t *general)
+{
+	cdw_rv_t crv = cdw_string_set(&(general->image_fullpath), "/tmp/image.iso");
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set image_full_path\n");
+		return CDW_ERROR;
+	}
+
 #ifndef NDEBUG
 	size_t len = strlen(base_dir_fullpath);
 	cdw_assert (base_dir_fullpath[len - 1] == '/',
@@ -1098,40 +1075,49 @@
 		    base_dir_fullpath);
 #endif
 	char *tmp = cdw_string_concat(config_dir_fullpath, cdw_log_file_name, (char *) NULL);
-	if (tmp == (char *) NULL) {
+	if (!tmp) {
 		cdw_vdm ("ERROR: failed to concat string for log_full_path\n");
 		return CDW_ERROR;
 	} else {
-		cdw_string_set(&(config->log_full_path), tmp);
+		crv = cdw_string_set(&(general->log_fullpath), tmp);
 		free(tmp);
 		tmp = (char *) NULL;
 
-		if (config->log_full_path == (char *) NULL) {
+		if (crv != CDW_OK) {
 			cdw_vdm ("ERROR: failed to set log_full_path to \"%s\"\n", tmp);
 			return CDW_ERROR;
 		}
 	}
 
-	config->showlog = true;
-
-	config->volume_size_id = CDW_CONFIG_VOLUME_SIZE_CD74;
-	if (config->volume_size_custom_value < 0) {
-		config->volume_size_custom_value = 0;
-	}
-
-	/* other - not saved in config file */
-	config->support_dvd_rp_dl = false;
-	/* show warning dialog; dialog code will display a message box,
-	   and will set this flag to "false", to not to annoy user with
-	   repeated messages */
-	config->show_dvd_rw_support_warning = true;
-	config->fs.display_hidden_files = true;
+	general->show_log = true;
+	general->volume_size_id = CDW_CONFIG_VOLUME_SIZE_CD74;
+	if (general->volume_size_custom_value < 0) {
+		general->volume_size_custom_value = 0;
+	}
+	general->selected_follow_symlinks = false;
+	general->display_hidden_files = true;     /* Not included in Configuration window. */
+	general->support_dvd_rp_dl = false;
+	/* Show warning dialog. Dialog code will display a message
+	   box, and will set this flag to "false", to not to annoy
+	   user with repeated messages. */
+	general->show_dvd_rw_support_warning = true;
 
 	return CDW_OK;
 }
 
 
 
+extern const char *cdw_mkudffs_option_blocksize[];
+extern const char *cdw_mkudffs_option_udfrev[];
+extern const char *cdw_mkudffs_option_strategy[];
+extern const char *cdw_mkudffs_option_spartable[];
+extern const char *cdw_mkudffs_option_media_type[];
+extern const char *cdw_mkudffs_option_space[];
+extern const char *cdw_mkudffs_option_ad[];
+extern const char *cdw_mkudffs_option_encoding[];
+
+
+
 
 
 /**
@@ -1158,17 +1144,26 @@
 
 	fprintf(config_file, "\n\n\n");
 	fprintf(config_file, "### \"Writing\" options\n");
-	fprintf(config_file, "pad=%d\n", config->write_pad ? 1 : 0);
-	fprintf(config_file, "pad_size=%d\n", config->write_pad_size);
+	fprintf(config_file, "pad=%d\n",       config->burn.cdrecord_pad ? 1 : 0);
+	fprintf(config_file, "pad_size=%d\n",  config->burn.cdrecord_pad_size);
+	fprintf(config_file, "eject=%d\n",     config->burn.eject ? 1 : 0);
+	fprintf(config_file, "burnproof=%d\n", config->burn.cdrecord_burnproof ? 1 : 0);
+
+	fprintf(config_file, "other_cdrecord_options=%s\n",     config->burn.cdrecord_other_options     ? config->burn.cdrecord_other_options : "");
+	fprintf(config_file, "other_growisofs_options=%s\n",    config->burn.growisofs_other_options    ? config->burn.growisofs_other_options : "");
+	fprintf(config_file, "other_xorriso_burn_options=%s\n", config->burn.xorriso_burn_other_options ? config->burn.xorriso_burn_other_options : "");
+
+
+	fprintf(config_file, "\n\n\n");
+	fprintf(config_file, "### Erase options\n");
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
 	fprintf(config_file, "# fast / all\n");
-	fprintf(config_file, "blank=%s\n", config->erase_mode == CDW_ERASE_MODE_FAST ? "fast" : "all");
-	fprintf(config_file, "eject=%d\n", config->eject ? 1 : 0);
-	fprintf(config_file, "burnproof=%d\n", config->burnproof ? 1 : 0);
-
-	fprintf(config_file, "other_cdrecord_options=%s\n", (config->other_cdrecord_options != (char *) NULL) ? config->other_cdrecord_options : "");
-	fprintf(config_file, "other_growisofs_options=%s\n", (config->other_growisofs_options != (char *) NULL) ? config->other_growisofs_options : "");
-	fprintf(config_file, "other_xorriso_burn_options=%s\n", (config->other_xorriso_burn_options != (char *) NULL) ? config->other_xorriso_burn_options : "");
+	fprintf(config_file, "blank=%s\n",            config->erase.erase_mode == CDW_ERASE_MODE_FAST ? "fast" : "all");
+	fprintf(config_file, "erase.erase_mode=%s\n", config->erase.erase_mode == CDW_ERASE_MODE_FAST ? "fast" : "all");
 
+	fprintf(config_file, "\n");
+	fprintf(config_file, "erase.eject=%d\n", config->erase.eject ? 1 : 0);
 
 
 	fprintf(config_file, "\n\n");
@@ -1182,38 +1177,116 @@
 	fprintf(config_file, "scsi=%s\n", config->scsi);
 
 
+
 	fprintf(config_file, "\n\n\n");
 	fprintf(config_file, "### \"Audio\" options\n");
-	fprintf(config_file, "audiodir=%s\n", (config->audiodir != (char *) NULL) ? config->audiodir : "");
+	fprintf(config_file, "audiodir=%s\n", config->audiodir ? config->audiodir : "");
+
 
 
+	/* "iso9660." notation for options in this section has been
+	   introduced in cdw version 0.8.0. Remove the old notation
+	   someday in the future. */
 	fprintf(config_file, "\n\n");
-	fprintf(config_file, "### \"ISO9660 file system\" options\n");
-	fprintf(config_file, "# allowed values for iso_level are 1, 2, 3, 4\n");
-	fprintf(config_file, "iso_level=%lld\n", config->iso_level);
-
-	fprintf(config_file, "joliet=%d\n", config->joliet ? 1 : 0);
-	fprintf(config_file, "rock_ridge=%lld\n", config->rock_ridge);
-	fprintf(config_file, "joliet_long=%d\n", config->joliet_long ? 1 : 0);
-	fprintf(config_file, "follow_symlinks=%d\n", config->follow_symlinks ? 1 : 0);
-
-	fprintf(config_file, "iso_image_full_path=%s\n", (config->iso_image_full_path != (char *) NULL) ? config->iso_image_full_path : "");
-	fprintf(config_file, "# well, in fact this field stores all options related to boot disc\n");
-	fprintf(config_file, "boot_image_path=%s\n", (config->boot_disc_options != (char *) NULL) ? config->boot_disc_options : "");
-	fprintf(config_file, "other_mkisofs_options=%s\n", (config->other_mkisofs_options != (char *) NULL) ? config->other_mkisofs_options : "");
-	fprintf(config_file, "other_xorriso_iso_options=%s\n", (config->other_xorriso_iso_options != (char *) NULL) ? config->other_xorriso_iso_options : "");
+	fprintf(config_file, "### ISO9660 file system options\n");
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "joliet=%d\n",                            config->iso9660.joliet_information ? 1 : 0);
+	fprintf(config_file, "iso9660.joliet_information=%d\n",        config->iso9660.joliet_information ? 1 : 0);
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "joliet_long=%d\n",                       config->iso9660.joliet_long ? 1 : 0);
+	fprintf(config_file, "iso9660.joliet_long=%d\n",               config->iso9660.joliet_long ? 1 : 0);
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "rock_ridge=%lld\n",                      config->iso9660.rock_ridge);
+	fprintf(config_file, "iso9660.rock_ridge=%lld\n",              config->iso9660.rock_ridge);
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "follow_symlinks=%d\n",                   config->iso9660.follow_symlinks ? 1 : 0);
+	fprintf(config_file, "iso9660.follow_symlinks=%d\n",           config->iso9660.follow_symlinks ? 1 : 0);
+
+	fprintf(config_file, "iso9660.pad=%d\n",                       config->iso9660.pad ? 1 : 0);
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "# Allowed values for iso_level are 1, 2, 3, 4.\n");
+	fprintf(config_file, "iso_level=%lld\n",                       config->iso9660.iso_level);
+	fprintf(config_file, "iso9660.iso_level=%lld\n",               config->iso9660.iso_level);
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "other_mkisofs_options=%s\n",             config->iso9660.mkisofs_other_options ? config->iso9660.mkisofs_other_options : "");
+	fprintf(config_file, "iso9660.mkisofs_other_options=%s\n",     config->iso9660.mkisofs_other_options ? config->iso9660.mkisofs_other_options : "");
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "other_xorriso_iso_options=%s\n",         config->iso9660.xorriso_iso_other_options ? config->iso9660.xorriso_iso_other_options : "");
+	fprintf(config_file, "iso9660.xorriso_iso_other_options=%s\n", config->iso9660.xorriso_iso_other_options ? config->iso9660.xorriso_iso_other_options : "");
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "# Well, in fact this field stores all options related to boot disc.\n");
+	fprintf(config_file, "boot_image_path=%s\n",                   config->iso9660.boot_disc_options ? config->iso9660.boot_disc_options : "");
+	fprintf(config_file, "iso9660.boot_disc_options=%s\n",         config->iso9660.boot_disc_options ? config->iso9660.boot_disc_options : "");
+
+
 
 	fprintf(config_file, "\n\n");
-	fprintf(config_file, "### \"Log and other\" options\n");
+	fprintf(config_file, "### UDF file system options ###\n");
 
-	fprintf(config_file, "showlog=%d\n", config->showlog ? 1 : 0);
-	fprintf(config_file, "logfile=%s\n", (config->log_full_path != (char *) NULL) ? config->log_full_path : "");
+	fprintf(config_file, "udf.mkudffs_blocksize=%s\n",  cdw_mkudffs_option_blocksize[config->udf.mkudffs_blocksize]);
+	fprintf(config_file, "udf.mkudffs_udfrev=%s\n",     cdw_mkudffs_option_udfrev[config->udf.mkudffs_udfrev]);
+	fprintf(config_file, "udf.mkudffs_strategy=%s\n",   cdw_mkudffs_option_strategy[config->udf.mkudffs_strategy]);
+	fprintf(config_file, "udf.mkudffs_spartable=%s\n",  cdw_mkudffs_option_spartable[config->udf.mkudffs_spartable]);
+	fprintf(config_file, "udf.mkudffs_media_type=%s\n", cdw_mkudffs_option_media_type[config->udf.mkudffs_media_type]);
+	fprintf(config_file, "udf.mkudffs_space=%s\n",      cdw_mkudffs_option_space[config->udf.mkudffs_space]);
+	fprintf(config_file, "udf.mkudffs_ad=%s\n",         cdw_mkudffs_option_ad[config->udf.mkudffs_ad]);
+	fprintf(config_file, "udf.mkudffs_noefe=%d\n",      config->udf.mkudffs_noefe ? 1 : 0);
+	fprintf(config_file, "udf.mkudffs_encoding=%s\n",   cdw_mkudffs_option_encoding[config->udf.mkudffs_encoding]);
 
+	fprintf(config_file, "udf.mkudffs_other_options=%s\n", config->udf.mkudffs_other_options);
 
+	fprintf(config_file, "udf.mkudffs_lvid=%s\n",  config->udf.mkudffs_lvid);
+	fprintf(config_file, "udf.mkudffs_vid=%s\n",   config->udf.mkudffs_vid);
+	fprintf(config_file, "udf.mkudffs_vsid=%s\n",  config->udf.mkudffs_vsid);
+	fprintf(config_file, "udf.mkudffs_fsid=%s\n",  config->udf.mkudffs_fsid);
+
+	fprintf(config_file, "udf.rsync_options=%s\n", config->udf.rsync_options);
+
+	fprintf(config_file, "udf.mount_point=%s\n",   config->udf.mount_point);
+
+
+
+	/* "general." notation for options in this section has been
+	   introduced in cdw version 0.8.0. Remove the old notation
+	   someday in the future. */
 	fprintf(config_file, "\n\n");
-	fprintf(config_file, "cdsize=%s\n", cdw_config_volume_size_table[config->volume_size_id].new_label);
-	fprintf(config_file, "cdsize=%s\n", cdw_config_volume_size_table[config->volume_size_id].old_label);
-	fprintf(config_file, "user_cdsize=%ld\n", config->volume_size_custom_value);
+	fprintf(config_file, "### General options ###\n");
+
+	fprintf(config_file, "\n# Full path to both ISO9660 and UDF image file.\n");
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "iso_image_full_path=%s\n",               config->general.image_fullpath ? config->general.image_fullpath : "");
+	fprintf(config_file, "general.image_full_path=%s\n",           config->general.image_fullpath ? config->general.image_fullpath : "");
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "logfile=%s\n",                           config->general.log_fullpath ? config->general.log_fullpath : "");
+	fprintf(config_file, "general.log_full_path=%s\n",             config->general.log_fullpath ? config->general.log_fullpath : "");
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "showlog=%d\n",                           config->general.show_log ? 1 : 0);
+	fprintf(config_file, "general.show_log=%d\n",                  config->general.show_log ? 1 : 0);
+
+	fprintf(config_file, "\n# These three entries refer to the same option. The third one is a new notation for options.\n");
+	fprintf(config_file, "cdsize=%s\n",                            cdw_config_volume_size_table[config->general.volume_size_id].new_label);
+	fprintf(config_file, "cdsize=%s\n",                            cdw_config_volume_size_table[config->general.volume_size_id].old_label);
+	fprintf(config_file, "general.volume_size_id=%s\n",            cdw_config_volume_size_table[config->general.volume_size_id].new_label);
+
+	fprintf(config_file, "\n# These two entries refer to the same option. The second one is a new notation for options.\n");
+	fprintf(config_file, "user_cdsize=%ld\n",                      config->general.volume_size_custom_value);
+	fprintf(config_file, "general.volume_size_custom_value=%ld\n", config->general.volume_size_custom_value);
+
+	fprintf(config_file, "\n# Follow symbolic links when calculating size of selected files in main window.\n");
+	fprintf(config_file, "general.selected_follow_symlinks=%d\n",  config->general.selected_follow_symlinks ? 1 : 0);
+
+	fprintf(config_file, "\n# Display hidden files in browsers of native file system.\n");
+	fprintf(config_file, "general.display_hidden_files=%d\n",      config->general.display_hidden_files ? 1 : 0);
 
 	return;
 }
@@ -1245,21 +1318,30 @@
  */
 cdw_rv_t cdw_config_var_read_from_file(FILE *config_file, cdw_config_t *config)
 {
-	cdw_rv_t ss = CDW_ERROR;
+	cdw_rv_t crv = CDW_ERROR;
+
+	cdw_option_t option = {
+		.name = (char *) NULL,
+		.value = (char *) NULL
+	};
 
 	char *line = (char *) NULL;
+
 	while (1) {
-		if (line != (char *) NULL) {
+		if (line) {
 			free(line);
 			line = (char *) NULL;
 		}
 
 		line = my_readline_10k(config_file);
-		if (line == (char *) NULL) {
+		if (!line) {
 			break;
 		}
+		cdw_string_rtrim(line);
+
+		/* Deallocate strings from previous loop iteration. */
+		cdw_config_option_free(&option);
 
-		cdw_option_t option;
 		if (!cdw_config_split_options_line(&option, line)) {
 			continue; /* empty or invalid line, or comment */
 		}
@@ -1272,43 +1354,30 @@
 		}
 
 
-		/* page A - writing */
+		/* Writing. */
 		if (!strcasecmp(option.name, "pad")) {
-			cdw_string_get_bool_value(option.value, &(config->write_pad));
+			cdw_string_get_bool_value(option.value, &(config->burn.cdrecord_pad));
 			continue;
 		}
 
 		if (!strcasecmp(option.name, "pad_size")) {
-			config->write_pad_size = atoi(option.value);
-			continue;
-		}
-
-
-		if (!strcasecmp(option.name, "blank")) {
-			/* compare ignoring case, but store with correct case */
-			if (!strcasecmp(option.value, "fast")) {
-				config->erase_mode = CDW_ERASE_MODE_FAST;
-			} else if (!strcasecmp(option.value, "all")) {
-				config->erase_mode = CDW_ERASE_MODE_ALL;
-			} else {
-				; /* there should be some default value in option.name already */
-			}
+			config->burn.cdrecord_pad_size = atoi(option.value);
 			continue;
 		}
 
 		if (!strcasecmp(option.name, "eject")) {
-			cdw_string_get_bool_value(option.value, &(config->eject));
+			cdw_string_get_bool_value(option.value, &(config->burn.eject));
 			continue;
 		}
 
 		if (!strcasecmp(option.name, "burnproof")) {
-			cdw_string_get_bool_value(option.value, &(config->burnproof));
+			cdw_string_get_bool_value(option.value, &(config->burn.cdrecord_burnproof));
 			continue;
 		}
 
 		if (!strcasecmp(option.name, "other_cdrecord_options")) {
-			ss = cdw_string_set(&(config->other_cdrecord_options), option.value);
-			if (ss != CDW_OK) {
+			crv = cdw_string_set(&(config->burn.cdrecord_other_options), option.value);
+			if (crv != CDW_OK) {
 				cdw_vdm ("ERROR: failed to set other_cdrecord_options from option.value = \"%s\"\n", option.value);
 				return CDW_ERROR;
 			}
@@ -1316,27 +1385,51 @@
 		}
 
 		if (!strcasecmp(option.name, "other_growisofs_options")) {
-			ss = cdw_string_set(&(config->other_growisofs_options), option.value);
-			if (ss != CDW_OK) {
+			crv = cdw_string_set(&(config->burn.growisofs_other_options), option.value);
+			if (crv != CDW_OK) {
 				cdw_vdm ("ERROR: failed to set other_growisofs_options from option.value = \"%s\"\n", option.value);
 				return CDW_ERROR;
 			}
-
 			continue;
 		}
 		if (!strcasecmp(option.name, "other_xorriso_burn_options")) {
-			ss = cdw_string_set(&(config->other_xorriso_burn_options), option.value);
-			if (ss != CDW_OK) {
+			crv = cdw_string_set(&(config->burn.xorriso_burn_other_options), option.value);
+			if (crv != CDW_OK) {
 				cdw_vdm ("ERROR: failed to set other_xorriso_burn_options from option.value = \"%s\"\n", option.value);
 				return CDW_ERROR;
 			}
+			continue;
+		}
+
+
+
+		/* Erase. */
+		if (!strcasecmp(option.name, "blank")
+		    || !strcasecmp(option.name, "erase.erase_mode")) {
+
+			if (!strcasecmp(option.value, "fast")) {
+				config->erase.erase_mode = CDW_ERASE_MODE_FAST;
+			} else if (!strcasecmp(option.value, "all")) {
+				config->erase.erase_mode = CDW_ERASE_MODE_ALL;
+			} else {
+				; /* there should be some default value in option.name already */
+			}
+			continue;
+		}
 
+		if (!strcasecmp(option.name, "erase.eject")) {
+			cdw_string_get_bool_value(option.value, &(config->erase.eject));
 			continue;
 		}
 
 
-		/* page B - hardware */
-		/* ** hardware ** */
+
+		/* CONFIG_PAGE_ID_HW */
+		if (!strcasecmp(option.name, "selected_drive")) {
+			strncpy(config->selected_drive, option.value, OPTION_FIELD_LEN_MAX);
+			config->selected_drive[OPTION_FIELD_LEN_MAX] = '\0';
+			continue;
+		}
 
 		if (!strcasecmp(option.name, "custom_drive")) {
 			if (!strlen(option.value)) {
@@ -1350,12 +1443,6 @@
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "selected_drive")) {
-			strncpy(config->selected_drive, option.value, OPTION_FIELD_LEN_MAX);
-			config->selected_drive[OPTION_FIELD_LEN_MAX] = '\0';
-			continue;
-		}
-
 		if (!strcasecmp(option.name, "scsi")) {
 			strncpy(config->scsi, option.value, OPTION_FIELD_LEN_MAX);
 			config->scsi[OPTION_FIELD_LEN_MAX] = '\0';
@@ -1363,10 +1450,11 @@
 		}
 
 
-		/* page C - audio */
+
+		/* CONFIG_PAGE_ID_AUDIO */
 		if (!strcasecmp(option.name, "audiodir")) {
-			ss = cdw_string_set(&(config->audiodir), option.value);
-			if (ss != CDW_OK) {
+			crv = cdw_string_set(&(config->audiodir), option.value);
+			if (crv != CDW_OK) {
 				cdw_vdm ("ERROR: failed to set audiodir from option.value = \"%s\"\n", option.value);
 				return CDW_ERROR;
 			}
@@ -1375,218 +1463,275 @@
 
 
 
-		/* page D - iso filesystem */
-		if (!strcasecmp(option.name, "iso_level")) {
-			int i = atoi(option.value);
-			if (i < 1 || i > 4) {
-				; /* probably "trash" value, rejecting completely */
-			} else {
-				config->iso_level = i;
-			}
+		/* ISO9660 filesystem. */
+		if (!strcasecmp(option.name, "joliet")
+		    || !strcasecmp(option.name, "iso9660.joliet_information")) {
+
+			cdw_string_get_bool_value(option.value, &(config->iso9660.joliet_information));
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "joliet")) {
-			cdw_string_get_bool_value(option.value, &(config->joliet));
+		if (!strcasecmp(option.name, "joliet_long")
+		    || !strcasecmp(option.name, "iso9660.joliet_long")) {
+
+			cdw_string_get_bool_value(option.value, &(config->iso9660.joliet_long));
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "rock_ridge")) {
+		if (!strcasecmp(option.name, "rock_ridge")
+		    || !strcasecmp(option.name, "iso9660.rock_ridge")) {
+
 			int i = atoi(option.value);
 			if (i < 0 || i > 2) {
 				; /* probably "trash" value, rejecting completely */
 			} else {
-				config->rock_ridge = i;
+				config->iso9660.rock_ridge = i;
 			}
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "joliet_long")) {
-			cdw_string_get_bool_value(option.value, &(config->joliet_long));
-			continue;
-		}
+		if (!strcasecmp(option.name, "follow_symlinks")
+		    || !strcasecmp(option.name, "iso9660.follow_symlinks")) {
 
-		if (!strcasecmp(option.name, "follow_symlinks")) {
-			cdw_string_get_bool_value(option.value, &(config->follow_symlinks));
+			cdw_string_get_bool_value(option.value, &(config->iso9660.follow_symlinks));
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "iso_image_full_path")) {
-			ss = cdw_string_set(&(config->iso_image_full_path), option.value);
-			if (ss != CDW_OK) {
-				cdw_vdm ("ERROR: failed to set iso_image_full_path from option.value = \"%s\"\n", option.value);
-				return CDW_ERROR;
-			}
+		if (!strcasecmp(option.name, "iso9660.pad")) {
+			cdw_string_get_bool_value(option.value, &(config->iso9660.pad));
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "boot_image_path")) {
-			ss = cdw_string_set(&(config->boot_disc_options), option.value);
-			if (ss != CDW_OK) {
-				cdw_vdm ("ERROR: failed to set boot_disc_options from option.value = \"%s\"\n", option.value);
-				return CDW_ERROR;
-			}
+		if (!strcasecmp(option.name, "iso_level")
+		    || !strcasecmp(option.name, "iso9660.iso_level")) {
 
+			int i = atoi(option.value);
+			if (i < 1 || i > 4) {
+				; /* probably "trash" value, rejecting completely */
+			} else {
+				config->iso9660.iso_level = i;
+			}
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "other_mkisofs_options")) {
-			ss = cdw_string_set(&(config->other_mkisofs_options), option.value);
-			if (ss != CDW_OK) {
+		if (!strcasecmp(option.name, "other_mkisofs_options")
+		    || !strcasecmp(option.name, "iso9660.mkisofs_other_options")) {
+
+			crv = cdw_string_set(&(config->iso9660.mkisofs_other_options), option.value);
+			if (crv != CDW_OK) {
 				cdw_vdm ("ERROR: failed to set other_mkisofs_options from option.value = \"%s\"\n", option.value);
 				return CDW_ERROR;
 			}
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "other_xorriso_iso_options")) {
-			ss = cdw_string_set(&(config->other_xorriso_iso_options), option.value);
-			if (ss != CDW_OK) {
+		if (!strcasecmp(option.name, "other_xorriso_iso_options")
+		    || !strcasecmp(option.name, "iso9660.xorriso_iso_other_options")) {
+
+			crv = cdw_string_set(&(config->iso9660.xorriso_iso_other_options), option.value);
+			if (crv != CDW_OK) {
 				cdw_vdm ("ERROR: failed to set other_xorriso_iso_options from option.value = \"%s\"\n", option.value);
 				return CDW_ERROR;
 			}
 			continue;
 		}
 
+		if (!strcasecmp(option.name, "boot_image_path")
+		    || !strcasecmp(option.name, "iso9660.boot_disc_options")) {
 
-		/* page F - log and other */
-		if (!strcasecmp(option.name, "logfile")) {
-			ss = cdw_string_set(&(config->log_full_path), option.value);
-			if (ss != CDW_OK) {
-				cdw_vdm ("ERROR: failed to set log_full_path from option.value = \"%s\"\n", option.value);
+			crv = cdw_string_set(&(config->iso9660.boot_disc_options), option.value);
+			if (crv != CDW_OK) {
+				cdw_vdm ("ERROR: failed to set boot_disc_options from option.value = \"%s\"\n", option.value);
 				return CDW_ERROR;
 			}
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "showlog")) {
-			cdw_string_get_bool_value(option.value, &(config->showlog));
+
+
+
+		/* UDF options */
+
+		if (cdw_config_option_match(option.name, option.value, "udf.mkudffs_blocksize", cdw_mkudffs_option_blocksize, &(config->udf.mkudffs_blocksize), CDW_MKUDFFS_BLOCKSIZE_UNSPECIFIED, CDW_MKUDFFS_BLOCKSIZE_MAX)) {
+			continue;
+		}
+
+		if (cdw_config_option_match(option.name, option.value, "udf.mkudffs_udfrev", cdw_mkudffs_option_udfrev, &(config->udf.mkudffs_udfrev), CDW_MKUDFFS_UDFREV_UNSPECIFIED, CDW_MKUDFFS_UDFREV_MAX)) {
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "cdsize")) {
-			cdw_id_t id = cdw_config_volume_id_by_label(option.value);
-			if (id != -1) {
-				config->volume_size_id = id;
-			}
+		if (cdw_config_option_match(option.name, option.value, "udf.mkudffs_strategy", cdw_mkudffs_option_strategy, &(config->udf.mkudffs_strategy), CDW_MKUDFFS_STRATEGY_UNSPECIFIED, CDW_MKUDFFS_STRATEGY_MAX)) {
 			continue;
 		}
 
-		if (!strcasecmp(option.name, "user_cdsize")) {
-			config->volume_size_custom_value = strtol(option.value, (char **) NULL, 10);
+		if (cdw_config_option_match(option.name, option.value, "udf.mkudffs_spartable", cdw_mkudffs_option_spartable, &(config->udf.mkudffs_spartable), CDW_MKUDFFS_SPARTABLE_UNSPECIFIED, CDW_MKUDFFS_SPARTABLE_MAX)) {
 			continue;
 		}
 
-	} /* while () */
-	if (line != (char *) NULL) {
-		free(line);
-		line = (char *) NULL;
-	}
+		if (cdw_config_option_match(option.name, option.value, "udf.mkudffs_media_type", cdw_mkudffs_option_media_type, &(config->udf.mkudffs_media_type), CDW_MKUDFFS_MEDIA_TYPE_UNSPECIFIED, CDW_MKUDFFS_MEDIA_TYPE_MAX)) {
+			continue;
+		}
 
-	return CDW_OK;
-}
+		if (cdw_config_option_match(option.name, option.value, "udf.mkudffs_space", cdw_mkudffs_option_space, &(config->udf.mkudffs_space), CDW_MKUDFFS_SPACE_UNSPECIFIED, CDW_MKUDFFS_SPACE_MAX)) {
+			continue;
+		}
 
+		if (cdw_config_option_match(option.name, option.value, "udf.mkudffs_ad", cdw_mkudffs_option_ad, &(config->udf.mkudffs_ad), CDW_MKUDFFS_AD_UNSPECIFIED, CDW_MKUDFFS_AD_MAX)) {
+			continue;
+		}
 
+		if (!strcasecmp(option.name, "udf.mkudffs_noefe")) {
+			cdw_string_get_bool_value(option.value, &(config->udf.mkudffs_noefe));
+			continue;
+		}
 
+		if (cdw_config_option_match(option.name, option.value, "udf.mkudffs_encoding", cdw_mkudffs_option_encoding, &(config->udf.mkudffs_encoding), CDW_MKUDFFS_ENCODING_UNSPECIFIED, CDW_MKUDFFS_ENCODING_MAX)) {
+			continue;
+		}
 
 
-/**
-   \brief Split line containing '=' char into 'name' and 'value' part
+		if (!strcasecmp(option.name, "udf.mkudffs_other_options")) {
+			strncpy(config->udf.mkudffs_other_options, option.value, CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX);
+			config->udf.mkudffs_other_options[CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX] = '\0';
+			continue;
+		}
 
-   \date Function's top-level comment reviewed on 2012-02-07
-   \date Function's body reviewed on 2012-02-07
+		if (!strcasecmp(option.name, "udf.mkudffs_lvid")) {
+			strncpy(config->udf.mkudffs_lvid, option.value, CDW_UDF_LVID_LEN_MAX);
+			config->udf.mkudffs_lvid[CDW_UDF_LVID_LEN_MAX] = '\0';
+			continue;
+		}
 
-   The function takes one 'char *' string, recognizes where is first
-   '=' char in it. What is on the left side of the char is treated
-   as option name, and what is on the right side of the char is treated
-   as option value. Pointers to beginning of both name and value are placed
-   in \p option. These pointers point to substrings of original string.
+		if (!strcasecmp(option.name, "udf.mkudffs_vid")) {
+			strncpy(config->udf.mkudffs_vid, option.value, CDW_UDF_VID_LEN_MAX);
+			config->udf.mkudffs_vid[CDW_UDF_VID_LEN_MAX] = '\0';
+			continue;
+		}
 
-   Original string is modified so that strings representing name and value
-   don't have any white chars at the beginning and end. '\0' chars are
-   also inserted into original string (function's argument) to properly
-   delimit the two substrings.
+		if (!strcasecmp(option.name, "udf.mkudffs_vsid")) {
+			strncpy(config->udf.mkudffs_vsid, option.value, CDW_UDF_VSID_LEN_MAX);
+			config->udf.mkudffs_vsid[CDW_UDF_VSID_LEN_MAX] = '\0';
+			continue;
+		}
 
-   The function heavily modifies its \p line argument!
+		if (!strcasecmp(option.name, "udf.mkudffs_fsid")) {
+			strncpy(config->udf.mkudffs_fsid, option.value, CDW_UDF_FSID_LEN_MAX);
+			config->udf.mkudffs_fsid[CDW_UDF_FSID_LEN_MAX] = '\0';
+			continue;
+		}
 
-   The function recognizes '#' as comment char and erases everything from
-   line starting from '#' char;
+		if (!strcasecmp(option.name, "udf.rsync_options")) {
+			strncpy(config->udf.rsync_options, option.value, CDW_RSYNC_OPTIONS_LEN_MAX);
+			config->udf.rsync_options[CDW_RSYNC_OPTIONS_LEN_MAX] = '\0';
+			continue;
+		}
 
-   \p line must be proper char * string ending with '\0'
+		if (!strcasecmp(option.name, "udf.mount_point")) {
+			crv = cdw_string_set(&(config->udf.mount_point), option.value);
+			if (crv != CDW_OK) {
+				cdw_vdm ("ERROR: failed to set udf.mount_point from option.value = \"%s\"\n", option.value);
+				return CDW_ERROR;
+			}
+			continue;
+		}
 
-   Both fields of \p option are set to NULL if:
-   \li function's \p line argument is NULL;
-   \li function's \p line argument is empty;
-   \li function's \p line argument does not contain '=' char;
-   \li function's \p line argument is a comment line.
-   \li function's \p line argument has '=' char but don't have any option name
 
-   Otherwise the fields of \p option are set with valid pointers pointing
-   to two substrings in function's \p line argument. Again: these substrings
-   are proper C strings and are ended with '\0'.
 
-   Don't use cdw_config_option_free_new() on \p option!
+		/* General options (including options from CONFIG_PAGE_ID_OTHER page). */
 
-   This function is similar to cdw_config_split_options_line_new(),
-   the difference being that name and value are substrings in \p line,
-   and not freshly allocated strings.
+		if (!strcasecmp(option.name, "iso_image_full_path")
+		    || !strcasecmp(option.name, "general.image_full_path")) {
 
-   \param option - variable where pointers to substrings are placed
-   \param line - line that you want to extract option from
+			crv = cdw_string_set(&(config->general.image_fullpath), option.value);
+			if (crv != CDW_OK) {
+				cdw_vdm ("ERROR: failed to set image_full_path from option.value = \"%s\"\n", option.value);
+				return CDW_ERROR;
+			}
+			continue;
+		}
 
-   \return true on success (both fields of \p option are set)
-   \return false otherwise
-*/
-bool cdw_config_split_options_line(cdw_option_t *option, char *line)
-{
-	cdw_sdm ("input line = '%s'\n", line);
+		if (!strcasecmp(option.name, "logfile")
+		    || !strcasecmp(option.name, "general.log_full_path")) {
 
-	option->name = (char *) NULL;
-	option->value = (char *) NULL;
+			crv = cdw_string_set(&(config->general.log_fullpath), option.value);
+			if (crv != CDW_OK) {
+				cdw_vdm ("ERROR: failed to set log_full_path from option.value = \"%s\"\n", option.value);
+				return CDW_ERROR;
+			}
+			continue;
+		}
 
-	if (line == (char *) NULL) {
-		return false;
-	}
+		if (!strcasecmp(option.name, "showlog")
+		    || !strcasecmp(option.name, "general.show_log")) {
 
-	/* this will make sure that comment, starting at any position
-	   in line, will be erased from line */
-	char *comment = strstr(line, "#"); /* beginning of in-line comment */
-	if (comment != (char *) NULL) {
-		size_t len = strlen(comment);
-		size_t i = 0;
-		for (i = 0; i < len; i++) {
-			*(comment + i) = '\0';
+			cdw_string_get_bool_value(option.value, &(config->general.show_log));
+			continue;
 		}
-	}
 
-	char *tline = cdw_string_ltrim(cdw_string_rtrim(line));
-	char *eq = strstr(tline, "="); /* first occurrence of '=' in line */
+		if (!strcasecmp(option.name, "cdsize")
+		    || !strcasecmp(option.name, "general.volume_size_id")) {
 
-	if (eq == (char *) NULL) {
-		cdw_vdm ("ERROR: line is invalid: \"%s\"\n", line);
+			cdw_id_t id = cdw_config_volume_id_by_label(option.value);
+			if (id != -1) {
+				config->general.volume_size_id = id;
+			}
+			continue;
+		}
 
-		return false;
-	} else {
-		option->name = tline;
-		*eq = '\0';
-		option->name = cdw_string_rtrim(option->name);
+		if (!strcasecmp(option.name, "user_cdsize")
+		    || !strcasecmp(option.name, "general.volume_size_custom_value")) {
 
-		if (!strcmp(option->name, "")) {
-			option->name = (char *) NULL;
-			option->value = (char *) NULL;
-			return false;
+			config->general.volume_size_custom_value = strtol(option.value, (char **) NULL, 10);
+			continue;
+		}
+
+		if (!strcasecmp(option.name, "general.selected_follow_symlinks")) {
+			cdw_string_get_bool_value(option.value, &(config->general.selected_follow_symlinks));
+			continue;
+		}
+
+		if (!strcasecmp(option.name, "general.display_hidden_files")) {
+			cdw_string_get_bool_value(option.value, &(config->general.display_hidden_files));
+			continue;
 		}
 
-		option->value = cdw_string_ltrim(eq + 1);
-		/* value may be empty string too, but this is not an error
-		   condition, since given option value can be empty
-		   (no value set) - this is correct situation */
+	} /* while () */
 
-		cdw_sdm ("   option.name = '%s'\n", option->name);
-		cdw_sdm ("   option.value = '%s'\n", option->value);
+	cdw_config_option_free(&option);
+	cdw_string_delete(&line);
 
-		return true;
+	return CDW_OK;
+}
+
+
+
+
+
+/*
+  Check if \p option_name matches \p searched_option_name.  If it
+  does, look up \p option_value in \p option_values and return index
+  of matched option value through \p option.
+
+  If \p option_name and \p searched_option_name match, initial/default
+  value \p init will be assigned to \p option.
+
+  \p max is a number of options values in \p option_values.
+
+  \return true when both option name and option value matches have been made/found
+  \return false otherwise
+*/
+bool cdw_config_option_match(char *option_name, char *option_value, const char *searched_option_name, const char *option_values[], cdw_id_t *option, int init, int max)
+{
+	if (!strcasecmp(option_name, searched_option_name)) {
+		*option = init;
+		for (cdw_id_t i = 0; i < max; i++) {
+			if (!strcasecmp(option_value, option_values[i])) {
+				*option = i;
+				return true;
+			}
+		}
 	}
+	return false;
 }
 
 
@@ -1623,20 +1768,16 @@
    Otherwise the fields of \p option are set with freshly allocated
    strings: name and value of option.
 
-   Use cdw_config_option_free_new() on \p option to conveniently
+   Use cdw_config_option_free() on \p option to conveniently
    deallocate both strings.
 
-   This function is similar to cdw_config_split_options_line(), the
-   difference being that name and value are freshly allocated strings,
-   and not substrings in \p line.
-
    \param option - variable where new strings with name and value are placed
    \param line - line that you want to extract option from
 
    \return true on success (both fields of \p option are set)
    \return false otherwise
 */
-bool cdw_config_split_options_line_new(cdw_option_t *option, char *line)
+bool cdw_config_split_options_line(cdw_option_t *option, char *line)
 {
 	if (!line) {
 		cdw_vdm ("ERROR: input line is NULL\n");
@@ -1656,6 +1797,16 @@
 		line[n] = '\0';
 	}
 
+	if (line[0] == '\0') {
+		cdw_sdm ("INFO: empty line\n");
+		return false;
+	} else if (line[0] == '#') {
+		cdw_sdm ("INFO: comment line: \"%s\"\n", line);
+		return false;
+	} else {
+		; /* The line potentially is valid. */
+	}
+
 	char *eq = strstr(line, "=");
 	if (!eq) {
 		cdw_vdm ("WARNING: line is invalid (\"%s\")\n", line);
@@ -1699,11 +1850,11 @@
    pointers to NULL after deallocation.
 
    Call this function only for \p option processed by
-   cdw_config_split_options_line_new().
+   cdw_config_split_options_line().
 
    \param option - variable which you want to process
 */
-void cdw_config_option_free_new(cdw_option_t *option)
+void cdw_config_option_free(cdw_option_t *option)
 {
 	cdw_assert (option, "ERROR: pointer is NULL\n");
 
@@ -1745,19 +1896,19 @@
 
 /* get either custom value of ISO9660 volume size,
    or one of predefined volume size values */
-long int cdw_config_get_current_volume_size_value(void)
+long int cdw_config_get_current_volume_size_value_megabytes(void)
 {
-	cdw_assert (global_config.volume_size_id != CDW_CONFIG_VOLUME_SIZE_AUTO,
+	cdw_assert (global_config.general.volume_size_id != CDW_CONFIG_VOLUME_SIZE_AUTO,
 		    "ERROR: current volume size ID is \"auto\", so you should fetch volume size from disc\n");
 
-	if (global_config.volume_size_id == CDW_CONFIG_VOLUME_SIZE_CUSTOM) {
+	if (global_config.general.volume_size_id == CDW_CONFIG_VOLUME_SIZE_CUSTOM) {
 		/* value entered by user in configuration window */
-		cdw_vdm ("INFO: returning custom value %ld\n", global_config.volume_size_custom_value);
-		return global_config.volume_size_custom_value;
+		cdw_vdm ("INFO: returning custom value %ld\n", global_config.general.volume_size_custom_value);
+		return global_config.general.volume_size_custom_value;
 	} else {
 		/* one of predefined values, corresponding to total
 		   capacity of selected disc type */
-		return cdw_config_get_volume_size_mb_by_id(global_config.volume_size_id);
+		return cdw_config_get_volume_size_mb_by_id(global_config.general.volume_size_id);
 	}
 }
 
@@ -1768,20 +1919,15 @@
 {
 	cdw_vdm ("\n\nINFO: configuration:\n\n");
 #if 1
-	cdw_vdm ("INFO: Page A, \"writing\" settings:\n");
-	cdw_vdm ("INFO:                 erase mode = \"%s\"\n", config->erase_mode == CDW_ERASE_MODE_FAST ? "fast" : "all");
-	cdw_vdm ("INFO:                      eject = \"%s\"\n", config->eject ? "true" : "false");
-	cdw_vdm ("INFO:                  write pad = \"%s\"\n", config->write_pad ? "true" : "false");
-	cdw_vdm ("INFO:             write pad size = \"%d\"\n", config->write_pad_size);
-	cdw_vdm ("INFO:                  burnproof = \"%s\"\n", config->burnproof ? "true" : "false");
-	cdw_vdm ("INFO:     other cdrecord options = \"%s\"\n", config->other_cdrecord_options);
-	cdw_vdm ("INFO:    other growisofs options = \"%s\"\n", config->other_growisofs_options);
-	cdw_vdm ("INFO: other xorriso burn options = \"%s\"\n\n", config->other_xorriso_burn_options);
+	cdw_erase_debug_print_options(&config->erase);
 #endif
 
+#if 1
+	cdw_write_debug_print_options(&config->burn);
+#endif
 
 #if 1
-	cdw_vdm ("INFO: Page B, \"hardware\" settings:\n");
+	cdw_vdm ("INFO: Hardware options:\n");
 	cdw_vdm ("INFO:   custom drive = \"%s\"\n", config->custom_drive);
 	cdw_vdm ("INFO: selected drive = \"%s\"\n", config->selected_drive);
 	cdw_vdm ("INFO:           scsi = \"%s\"\n\n", config->scsi);
@@ -1793,50 +1939,29 @@
 
 
 #if 1
-
-	cdw_vdm ("INFO: Page C, \"audio\" settings:\n");
+	cdw_vdm ("INFO: Audio options:\n");
 	cdw_vdm ("INFO: audiodir = \"%s\"\n\n", config->audiodir);
 #endif
 
 
 #if 1
-	cdw_vdm ("INFO: Page D, \"ISO filesystem\" settings:\n");
-	cdw_vdm ("INFO:                 volume id = \"%s\"\n", config->volume_id);
-	cdw_vdm ("INFO:                 iso level = \"%lld\"\n", config->iso_level);
-	cdw_vdm ("INFO:                    joliet = \"%s\"\n", config->joliet ? "true" : "false");
-	cdw_vdm ("INFO:                rock_ridge = \"%lld\"\n", config->rock_ridge);
-	cdw_vdm ("INFO:               joliet long = \"%s\"\n", config->joliet_long ? "true" : "false");
-	cdw_vdm ("INFO:           follow_symlinks = \"%s\"\n", config->follow_symlinks ? "true" : "false");
-	cdw_vdm ("INFO:       iso image full path = \"%s\"\n", config->iso_image_full_path);
-	cdw_vdm ("INFO:         boot disc options = \"%s\"\n", config->boot_disc_options);
-	cdw_vdm ("INFO:          mkisofs root dir = \"%s\"\n", config->mkisofs_root_dir);
-	cdw_vdm ("INFO:     other mkisofs options = \"%s\"\n", config->other_mkisofs_options);
-	cdw_vdm ("INFO: other xorriso iso_options = \"%s\"\n\n", config->other_xorriso_iso_options);
+	cdw_iso9660_debug_print_options(&config->iso9660);
 #endif
 
 
 #if 1
-	cdw_vdm ("INFO: Page E, \"tools\" settings:\n");
-	cdw_ext_tools_debug_print_config();
+	cdw_udf_debug_print_options(&config->udf);
 #endif
 
 
 #if 1
-	cdw_vdm ("INFO: Page F, \"logging and other\" settings:\n");
-	cdw_vdm ("INFO:            log full path = \"%s\"\n", config->log_full_path);
-	cdw_vdm ("INFO:                 show log = \"%s\"\n", config->showlog ? "true" : "false");
-	cdw_vdm ("INFO:           volume size id = \"%s\" (%lld)\n",
-		 cdw_utils_id_label_table_get_label(cdw_config_volume_size_items, config->volume_size_id),
-		 config->volume_size_id);
-	cdw_vdm ("INFO: volume size custom value = %ld\n", config->volume_size_custom_value);
-
+	cdw_vdm ("INFO: External tools options:\n");
+	cdw_ext_tools_debug_print_config();
 #endif
 
+
 #if 1
-	cdw_vdm ("INFO: Other setting:\n");
-	cdw_vdm ("INFO:           support DVD+RP DL = \"%s\"\n", config->support_dvd_rp_dl ? "true" : "false");
-	cdw_vdm ("INFO: show DVD-RW support warning = \"%s\"\n", config->show_dvd_rw_support_warning ? "true" : "false");
-	cdw_vdm ("INFO:        display hidden files = \"%s\"\n", config->fs.display_hidden_files ? "true" : "false");
+	cdw_config_debug_general_print_options(&config->general);
 #endif
 
 	return;
@@ -1846,9 +1971,29 @@
 
 
 
+void cdw_config_debug_general_print_options(cdw_config_general_t *general)
+{
+	cdw_vdm ("INFO: General options:\n");
+	cdw_vdm ("INFO:             image full path = \"%s\"\n", general->image_fullpath);
+	cdw_vdm ("INFO:               log full path = \"%s\"\n", general->log_fullpath);
+	cdw_vdm ("INFO:                    show log = %s\n",     general->show_log ? "true" : "false");
+	cdw_vdm ("INFO:              volume size id = %s (%lld)\n", cdw_utils_id_label_table_get_label(cdw_config_volume_size_items, general->volume_size_id), general->volume_size_id);
+	cdw_vdm ("INFO:    volume size custom value = %ld\n",    general->volume_size_custom_value);
+	cdw_vdm ("INFO:    selected follow symlinks = %s\n",     general->selected_follow_symlinks ? "true" : "false");
+	cdw_vdm ("INFO:        display hidden files = %s\n",     general->display_hidden_files ? "true" : "false");
+	cdw_vdm ("INFO:           support DVD+RP DL = %s\n",     general->support_dvd_rp_dl ? "true" : "false");
+	cdw_vdm ("INFO: show DVD-RW support warning = %s\n",     general->show_dvd_rw_support_warning ? "true" : "false");
+
+	return;
+}
+
+
+
+
+
 bool cdw_config_support_dvd_rp_dl(void)
 {
-	return global_config.support_dvd_rp_dl;
+	return global_config.general.support_dvd_rp_dl;
 }
 
 
@@ -1857,7 +2002,7 @@
 
 bool cdw_config_follow_symlinks(void)
 {
-	return global_config.follow_symlinks;
+	return global_config.general.selected_follow_symlinks;
 }
 
 
@@ -1873,7 +2018,6 @@
 
 
 static void test_cdw_config_split_options_line(void);
-static void test_cdw_config_split_options_line_new(void);
 
 
 void cdw_config_run_tests(void)
@@ -1881,7 +2025,6 @@
 	fprintf(stderr, "testing cdw_config.c\n");
 
 	test_cdw_config_split_options_line();
-	test_cdw_config_split_options_line_new();
 
 	fprintf(stderr, "done\n\n");
 
@@ -1971,135 +2114,6 @@
 		  (char *) NULL, (char *) NULL }
 	};
 
-	/* remember that option fields are pointers to places inside
-	   input strings, not pointers to newly allocated strings */
-	cdw_option_t option;
-
-	int i = 0;
-	while (input_data[i].expected_null_name == input_data[i].expected_null_value) {
-		char *line = (char *) NULL;
-		if (input_data[i].line) {
-			line = strdup(input_data[i].line);
-		}
-
-		bool rv = cdw_config_split_options_line(&option, line);
-		cdw_assert (input_data[i].expected_return_value == rv, "ERROR: failed at function call#%d\n", i);
-
-		if (input_data[i].expected_null_name) {
-			cdw_assert (!option.name, "ERROR: name is not NULL (#%d)\n", i);
-		} else {
-			cdw_assert (option.name, "ERROR: name is NULL (#%d)\n", i);
-		}
-
-		if (input_data[i].expected_null_value) {
-			cdw_assert (!option.value, "ERROR: value is not NULL (#%d)\n", i);
-		} else {
-			cdw_assert (option.value, "ERROR: value is NULL (#%d)\n", i);
-		}
-
-		if (!input_data[i].expected_null_name && input_data[i].expected_null_value) {
-
-			cdw_assert (!strcmp(option.name, input_data[i].expected_name), "ERROR: unexpected name #%d: \"%s\"\n", i, option.name);
-			cdw_assert (!strcmp(option.value, input_data[i].expected_value), "ERROR: unexpected value #%d: \"%s\"\n", i, option.value);
-		}
-
-		if (line) {
-			free(line);
-			line = (char *) NULL;
-		}
-
-		i++;
-	}
-
-
-	fprintf(stderr, "OK\n");
-
-	return;
-}
-
-
-
-
-
-void test_cdw_config_split_options_line_new(void)
-{
-	fprintf(stderr, "\ttesting cdw_config_split_options_line_new()... ");
-
-	struct {
-		const char *line;
-		bool expected_return_value;
-		bool expected_null_name;
-		bool expected_null_value;
-		const char *expected_name;
-		const char *expected_value;
-
-	} input_data[] = {
-		/* correct line */
-		{ "option name=value string",
-		  true,
-		  false, false,
-		  "option name", "value string" },
-
-		/* correct line */
-		{ "\t option name \t\t = \t value string \t",
-		  true,
-		  false, false,
-		  "option name", "value string" },
-
-		/* correct line, but no value */
-		{ "\t option name = \t \t",
-		  true,
-		  false, false,
-		  "option name", "" },
-
-		/* correct line, but no value (2) */
-		{ "\t option name = #value string\t \t",
-		  true,
-		  false, false,
-		  "option name", "" },
-
-		/* incorrect line, no '=' char (1) */
-		{ "\t option name \t # = value string\t \t",
-		  false,
-		  true, true,
-		  (char *) NULL, (char *) NULL },
-
-		/* incorrect line, no '=' char (2) */
-		{ "\t option name \t  value string\t \t",
-		  false,
-		  true, true,
-		  (char *) NULL, (char *) NULL },
-
-		/* incorrect line, all content is comment */
-		{ " \t #\t option name = value string\t \t",
-		  false,
-		  true, true,
-		  (char *) NULL, (char *) NULL },
-
-		/* incorrect line, empty line */
-		{ "",
-		  false,
-		  true, true,
-		  (char *) NULL, (char *) NULL },
-
-		/* incorrect line, empty line (2) */
-		{ " \t \t    \t\t\t\t     \t               \t#    ",
-		  false,
-		  true, true,
-		  (char *) NULL, (char *) NULL },
-
-		/* incorrect line, line = NULL */
-		{ (char *) NULL,
-		  false,
-		  true, true,
-		  (char *) NULL, (char *) NULL },
-
-		{ (char *) NULL,
-		  false,
-		  false, true, /* <-- guard */
-		  (char *) NULL, (char *) NULL }
-	};
-
 	cdw_option_t option;
 	option.name = (char *) NULL;
 	option.value = (char *) NULL;
@@ -2110,7 +2124,7 @@
 			line = strdup(input_data[i].line);
 		}
 
-		bool rv = cdw_config_split_options_line_new(&option, line);
+		bool rv = cdw_config_split_options_line(&option, line);
 		cdw_assert (input_data[i].expected_return_value == rv, "ERROR: failed at function call#%d\n", i);
 
 		if (input_data[i].expected_null_name) {
@@ -2130,7 +2144,7 @@
 			cdw_assert (!strcmp(option.value, input_data[i].expected_value), "ERROR: unexpected value #%d: \"%s\"\n", i, option.value);
 		}
 
-		cdw_config_option_free_new(&option);
+		cdw_config_option_free(&option);
 		if (line) {
 			free(line);
 			line = (char *) NULL;
diff -Naur orig/src/configuration/cdw_config.h patched/src/configuration/cdw_config.h
--- orig/src/configuration/cdw_config.h	2012-02-11 18:52:48.000000000 +0100
+++ patched/src/configuration/cdw_config.h	2014-04-12 20:21:28.000000000 +0200
@@ -5,6 +5,10 @@
 
 #include "main.h"
 #include "cdw_iso9660.h"
+#include "cdw_udf.h"
+#include "cdw_burn_disc.h"
+#include "cdw_erase_disc.h"
+
 
 /** \brief Maximal length of some char tables storing long option values */
 #define OPTION_FIELD_LEN_MAX 950
@@ -42,25 +46,56 @@
 } cdw_option_t;
 
 
+bool cdw_config_split_options_line_old(cdw_option_t *option, char *line);
 bool cdw_config_split_options_line(cdw_option_t *option, char *line);
-bool cdw_config_split_options_line_new(cdw_option_t *option, char *line);
-void cdw_config_option_free_new(cdw_option_t *option);
+void cdw_config_option_free(cdw_option_t *option);
+
+
+
+
+typedef struct {
+	/* This option is presented in "Create image" wizard.
+
+	   Used when creating new image from selected files, or when
+	   burning an image to optical disc.  */
+	char *image_fullpath;                /**< \brief Current full path to ISO9660 or UDF image file. */
+
+	char *log_fullpath;                  /**< \brief Full path to cdw log file */
+	bool show_log;                       /**< \brief Show cdw log after finishing operation */
+
+	cdw_id_t volume_size_id;             /**< \brief ID of preferred standard size of target media/iso file */
+	long int volume_size_custom_value;   /**< \brief Custom size of target media/iso file, MB */
+
+	bool selected_follow_symlinks;       /**< \brief Follow symlinks when calculating size of selected files. */
+
+	/* This one doesn't appear in Configuration window
+	   (yet). */
+	bool display_hidden_files;           /**< Display hidden files in browsers of native file system. */
+
+	/* Options not displayed in configuration window and not saved
+	   to config file */
+	bool support_dvd_rp_dl;
+	bool show_dvd_rw_support_warning;
+} cdw_config_general_t;
+
 
 
 /** \brief Main cdw configuration variable, storing all major options used by cdw */
 typedef struct {
 
-	/* Options related to writing or erasing */
-	bool write_pad;            /**< \brief Pad written track with blanks (cdrecord) */
-	int write_pad_size;
-	cdw_id_t erase_mode;     /**< \brief Select mode of blanking a disc: fast / all */
-	bool eject;          /**< \brief Should cdw eject drive tray after finished writing or blanking? */
-	bool burnproof;      /**< \brief Should a tool use technique that helps avoiding buffer underrun? */
-	char *other_cdrecord_options;     /**< \brief Place for other cdrecord options, specified manually */
-	char *other_growisofs_options; /**< \brief Place for other growisofs options, specified manually */
-	char *other_xorriso_burn_options;
+	/* I need a place to globally store ID of current/last
+	   executed task. This is the place. */
+	cdw_id_t task_id;
 
 
+	/* Some of the fields in the cdw_write_t data structure aren't
+	   used by configuration module, but to have a single data
+	   type storing writing-related variables, and to use single
+	   code that handles them, I'm (re-)using cdw_write_t. */
+	cdw_write_t burn;
+
+	cdw_erase_t erase;
+
 	/* Hardware configuration */
 
 	/* device name in form of /dev/xxx - it is used as default device
@@ -69,6 +104,7 @@
 	   only this entry to access reading/writing device (I don't mention
 	   here cddb nor legacy cdda2wav code, because it is currently
 	   unmaintained) */
+	/* TODO: isn't there any better name for length of the buffer? */
 	char custom_drive[OPTION_FIELD_LEN_MAX + 1]; /**< \brief Path to CD/DVD reader/burner */
 	/* state of "drive" dropdown in configuration window */
 	char selected_drive[OPTION_FIELD_LEN_MAX + 1];
@@ -81,26 +117,11 @@
 	/* Audio configuration */
 	char *audiodir;
 
+	/* ISO9660 filesystem options. */
+	cdw_iso9660_t iso9660;
 
-	/* ISO9660 filesystem options **/
-	char volume_id[CDW_ISO9660_VOLI_LEN + 1];   /**< \brief Label of disc visible in file managers */
-	char volume_set_id[CDW_ISO9660_VOLS_LEN + 1];
-	char preparer[CDW_ISO9660_PREP_LEN + 1];
-	char publisher[CDW_ISO9660_PUBL_LEN + 1];
-	char system_id[CDW_ISO9660_SYSI_LEN + 1];
-	char copyright[CDW_ISO9660_COPY_LEN + 1];
-	char abstract[CDW_ISO9660_ABST_LEN + 1];
-	cdw_id_t iso_level;          /**< \brief Level of conformance with ISO9660; valid values are 1 to 4 */
-	bool joliet;            /**< \brief Turn on creting Joliet filenames (-J, mkisofs option) */
-	cdw_id_t rock_ridge;         /* 0 = none (no option), 1 = useful only (-r), 2 = full (-R) */
-	bool joliet_long;       /**< \brief "Allow  Joliet  filenames  to  be  up to 103 Unicode characters, instead of 64." */
-	bool follow_symlinks;   /**< \brief Follow symbolic links when generating the filesystem */
-
-	char *mkisofs_root_dir;
-	char *iso_image_full_path;     /**< \brief Current full path to ISO9660 image file */
-	char *boot_disc_options;       /**< \brief Options for creating a bootable disc */
-	char *other_mkisofs_options;   /**< \brief Place for other mkisofs options, specified manually */
-	char *other_xorriso_iso_options;   /**< \brief Place for other xorriso options, specified manually */
+	/* UDF filesystem options. */
+	cdw_udf_t udf;
 
 
 	/* Configuration of external tools */
@@ -108,20 +129,9 @@
 	   are no settings (yet) that should be stored in config file */
 
 
-	/* Log file settings, other setting  */
-	char *log_full_path; /**< \brief Full path to cdw log file */
-	bool showlog;        /**< \brief Show cdw log after finishing operation */
-
-        cdw_id_t volume_size_id;             /**< \brief ID of preferred standard size of target media/iso file */
-	long int volume_size_custom_value;   /**< \brief Custom size of target media/iso file, MB */
-
-	/* Options not displayed in configuration window and not saved to config file */
-	bool support_dvd_rp_dl;
-	bool show_dvd_rw_support_warning;
-
-	struct {
-		bool display_hidden_files;
-	} fs;
+	/* Log file settings, other setting.
+	   Some of these options are not stored in config file. */
+	cdw_config_general_t general;
 
 } cdw_config_t;
 
@@ -141,7 +151,7 @@
 void cdw_config_debug_print_config(cdw_config_t *config);
 
 long int cdw_config_get_volume_size_mb_by_id(cdw_id_t id);
-long int cdw_config_get_current_volume_size_value(void);
+long int cdw_config_get_current_volume_size_value_megabytes(void);
 cdw_id_t cdw_config_volume_id_by_label(const char *label);
 
 bool cdw_config_support_dvd_rp_dl(void);
@@ -151,11 +161,13 @@
 
 /* this is mostly for cdw_config_window.h, but also for
    cdw_config.c/cdw_config_var_validate() */
-#define CONFIG_PAGE_ID_AUDIO   0
-#define CONFIG_PAGE_ID_HW      1
-#define CONFIG_PAGE_ID_TOOLS   2
-#define CONFIG_PAGE_ID_OTHER   3
-
+enum c_pages_order {
+	CONFIG_PAGE_ID_AUDIO = 0,
+	CONFIG_PAGE_ID_HW    = 1,
+	CONFIG_PAGE_ID_TOOLS = 2,
+	CONFIG_PAGE_ID_OTHER = 3,
+	CONFIG_PAGE_ID_UDF   = 4
+};
 
 /* unit tests */
 
diff -Naur orig/src/configuration/cdw_config_window.c patched/src/configuration/cdw_config_window.c
--- orig/src/configuration/cdw_config_window.c	2012-03-28 20:27:18.000000000 +0200
+++ patched/src/configuration/cdw_config_window.c	2014-04-12 20:21:49.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _GNU_SOURCE /* asprintf() */
@@ -49,16 +49,16 @@
    One important note:
    tabbed window tabs in c_twindow must be referred to by index:
    c_twindow->tabs[i];
-   config pages in c_pages must be referred to by id of a page:
-   c_pages[id];
+   options pages in o_pages must be referred to by id of a page:
+   o_pages[id];
 
    id is taken from c_twindow, like this:
    int i = c_twindow->current_tab;
    cdw_id_t id = c_twindow->tabs[i].id;
-   FORM *form = c_pages[id].cdw_form->form;
+   FORM *form = o_pages[id].cdw_form->form;
 
    This is because tabs in tabbed window are always a non-sparse table,
-   and pages table (c_pages) may be sparse (some of pages in the table may
+   and pages table (o_pages) may be sparse (some of pages in the table may
    be unused, i.e. may be uninitialized).
 */
 
@@ -116,7 +116,7 @@
 				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
 		return CDW_ERROR;
 	}
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 	crv = cdw_config_window_driver(&tmp_config);
 	if (crv == CDW_OK) { /* "save changes and exit from cdw config window" */
 		cdw_config_var_copy(&global_config, &tmp_config);
@@ -145,11 +145,11 @@
 
 	cdw_config_var_free_fields(&tmp_config);
 	cdw_config_window_destroy();
-	/* user may have changed "ISO volume size", make this change
+	/* user may have changed "Volume size", make this change
 	   visible in main window */
-	cdw_main_window_volume_info_view_update(-1, -1, false, global_config.follow_symlinks);
+	cdw_main_window_volume_info_view_update(-1, -1, false);
 
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	return CDW_OK;
 }
@@ -189,16 +189,18 @@
 #define PAGE_HW_N_FIELDS         7  /* hardware */
 #define PAGE_AUDIO_N_FIELDS      3
 #define PAGE_TOOLS_N_FIELDS     15
-#define PAGE_OTHER_N_FIELDS     11  /* log and other */
+#define PAGE_OTHER_N_FIELDS     12  /* log and other */
+#define PAGE_UDF_N_FIELDS        2
 
 
 /* number of pages in configuration window */
-#define N_CONFIG_PAGES_ALL       4
+#define N_CONFIG_PAGES_ALL       5
 
 
 
 static cdw_rv_t page_audio_build_fields(cdw_form_t *cdw_form, void *cdw_config, int dummy1, int dummy2, int dummy3, int dummy4);
 static cdw_rv_t page_hw_build_fields(cdw_form_t *cdw_form, void *cdw_config, int dummy1, int dummy2, int dummy3, int dummy4);
+static cdw_rv_t page_udf_build_fields(cdw_form_t *cdw_form, void *cdw_config, int first_col, int second_col, int width_wide, int width_narrow);
 static cdw_rv_t page_tools_build_fields(cdw_form_t *cdw_form, void *cdw_config, int dummy1, int dummy2, int dummy3, int dummy4);
 static cdw_rv_t page_other_build_fields(cdw_form_t *cdw_form, void *cdw_config, int dummy1, int dummy2, int dummy3, int dummy4);
 
@@ -212,6 +214,9 @@
 
 static char *cdw_config_window_page_tools_message(int n_cols);
 static char *cdw_config_window_page_hw_message(int n_cols);
+static char *cdw_config_window_page_udf_message_tools(int n_cols);
+static char *cdw_config_window_page_udf_message_options(int n_cols);
+static char *cdw_config_window_page_misc_symlinks_txt(int n_cols);
 static cdw_rv_t cdw_config_window_draw(void);
 
 static CDW_DROPDOWN *cdw_config_window_make_volume_size_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
@@ -230,7 +235,10 @@
 
 static cdw_form_text_maker_t text_makers[] = {
 	cdw_config_window_page_hw_message,
-	cdw_config_window_page_tools_message
+	cdw_config_window_page_tools_message,
+	cdw_config_window_page_udf_message_tools,
+	cdw_config_window_page_udf_message_options,
+	cdw_config_window_page_misc_symlinks_txt
 };
 
 
@@ -242,6 +250,7 @@
 static FIELD *page_audio_fields[PAGE_AUDIO_N_FIELDS + 1]; /* +1 for last field == NULL */
 static FIELD *page_tools_fields[PAGE_TOOLS_N_FIELDS + 1]; /* +1 for last field == NULL */
 static FIELD *page_other_fields[PAGE_OTHER_N_FIELDS + 1]; /* +1 for last field == NULL */
+static FIELD *page_udf_fields[PAGE_UDF_N_FIELDS + 1]; /* +1 for last field == NULL */
 
 
 /* text displayed at the bottom of configuration window */
@@ -251,21 +260,28 @@
 
 /* this is first main component of configuration window: a big table
    aggregating data and functions that prepare the data; the data
-   represents widgets displayed in pages of configuration window */
-static cdw_config_page_t c_pages[] = {
+   represents widgets displayed in pages of configuration window.
+*/
+static cdw_options_page_t o_pages[] = {
 	/* 2TRANS: this is name of tab of notepad-style widget:
 	   "Audio" means 'audio cd ripping configuration' */
 	{ false, PAGE_AUDIO_N_FIELDS,   page_audio_build_fields,   gettext_noop("Audio"),          (cdw_form_t *) NULL },
 	/* 2TRANS: this is name of tab of notepad-style widget:
 	   "Hardware" refers to CD/DVD drives */
 	{ false, PAGE_HW_N_FIELDS,      page_hw_build_fields,      gettext_noop("Hardware"),       (cdw_form_t *) NULL },
+
 	/* 2TRANS: this is name of tab of notepad-style widget: "tools" are
 	   external programs (like cdrecord or dvd+rw-mediainfo) used by cdw */
 	{ false, PAGE_TOOLS_N_FIELDS,   page_tools_build_fields,   gettext_noop("Tools"),          (cdw_form_t *) NULL },
+
 	/* 2TRANS: this is name of tab of notepad-style widget: "log" is a
 	   file where the program writes various stuff that can be later
 	   examined by user; "misc" means "miscellaneous settings" */
-	{ false, PAGE_OTHER_N_FIELDS,   page_other_build_fields,   gettext_noop("Log and misc"),  (cdw_form_t *) NULL }};
+	{ false, PAGE_OTHER_N_FIELDS,   page_other_build_fields,   gettext_noop("Log and misc"),   (cdw_form_t *) NULL },
+
+	{ false, PAGE_UDF_N_FIELDS,     page_udf_build_fields,     gettext_noop("UDF"),            (cdw_form_t *) NULL }
+
+};
 
 
 /* this is a pointer to second main component of configuration window:
@@ -297,7 +313,7 @@
 	int rv = asprintf(&cdw_config_window_tip,
 			  _("Press F%d / F%d key to save changes or ESC to cancel"),
 			  CDW_CONFIG_UI_SnC_KEY_B, CDW_CONFIG_UI_SnC_KEY_A);
-	if (cdw_config_window_tip == (char *) NULL || rv == -1) {
+	if (!cdw_config_window_tip || rv == -1) {
 		cdw_vdm ("ERROR: failed to create window tip\n");
 		return CDW_ERROR;
 	}
@@ -311,19 +327,23 @@
 	cdw_id_t id = 0;
 
 	id = CONFIG_PAGE_ID_OTHER;
-	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label); /* log and misc */
+	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), o_pages[id].label); /* log and misc */
 	ind++;
 
 	id = CONFIG_PAGE_ID_TOOLS;
-	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label); /* tools */
+	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), o_pages[id].label); /* tools */
 	ind++;
 
 	id = CONFIG_PAGE_ID_AUDIO;
-	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label); /* audio */
+	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), o_pages[id].label); /* audio */
 	ind++;
 
 	id = CONFIG_PAGE_ID_HW;
-	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label); /* hardware */
+	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), o_pages[id].label); /* hardware */
+	ind++;
+
+	id = CONFIG_PAGE_ID_UDF;
+	cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), o_pages[id].label); /* hardware */
 	ind++;
 
 	cdw_tabs_window_add_return_keys(c_twindow, KEY_F(CDW_CONFIG_UI_SnC_KEY_A), KEY_F(CDW_CONFIG_UI_SnC_KEY_B),
@@ -337,31 +357,36 @@
 	for (int i = 0; i < N_CONFIG_PAGES_ALL; i++) {
 		id = c_twindow->tabs[i].id;
 
-		c_pages[id].cdw_form = cdw_form_new(c_pages[id].n_fields);
-		c_pages[id].cdw_form->form_id = id;
-		c_pages[id].cdw_form->window = c_twindow->tabs[i].window;
-		c_pages[id].cdw_form->subwindow = c_twindow->tabs[i].subwindow;
+		o_pages[id].cdw_form = cdw_form_new(o_pages[id].n_fields);
+		o_pages[id].cdw_form->form_id = id;
+		o_pages[id].cdw_form->window = c_twindow->tabs[i].window;
+		o_pages[id].cdw_form->subwindow = c_twindow->tabs[i].subwindow;
 
-		c_pages[id].visible = true;
+		o_pages[id].visible = true;
 
-		cdw_rv_t crv = c_pages[id].fields_builder(c_pages[id].cdw_form, config, FIRST_COL, SECOND_COL, WIDE_FIELD_WIDTH, LABEL_WIDTH);
+		cdw_rv_t crv = o_pages[id].fields_builder(o_pages[id].cdw_form, config, FIRST_COL, SECOND_COL, WIDE_FIELD_WIDTH, LABEL_WIDTH);
 		if (crv != CDW_OK) {
-			cdw_vdm ("ERROR: failed to build fields in page #%d\n", i);
+			cdw_vdm ("ERROR: failed to build fields in page #%d / %s\n", i, o_pages[id].label);
 			break;
 		}
 
-		c_pages[id].cdw_form->form = cdw_ncurses_new_form(c_pages[id].cdw_form->window,
-								  c_pages[id].cdw_form->subwindow,
-								  c_pages[id].cdw_form->fields);
+		o_pages[id].cdw_form->form = cdw_ncurses_new_form(o_pages[id].cdw_form->window,
+								  o_pages[id].cdw_form->subwindow,
+								  o_pages[id].cdw_form->fields);
+
+		if (!o_pages[id].cdw_form->form) {
+			cdw_vdm ("ERROR: failed to create cdw form for page #%d / %s\n", i, o_pages[id].label);
+			break;
+		}
 
 		for (int j = 0; j < N_CONFIG_PAGES_ALL; j++) {
-			cdw_form_add_return_char(c_pages[id].cdw_form, KEY_F(j + CDW_CONFIG_UI_FX_START_KEY));
+			cdw_form_add_return_char(o_pages[id].cdw_form, KEY_F(j + CDW_CONFIG_UI_FX_START_KEY));
 		}
-		cdw_form_add_return_char(c_pages[id].cdw_form, KEY_F(CDW_CONFIG_UI_SnC_KEY_A));
-		cdw_form_add_return_char(c_pages[id].cdw_form, KEY_F(CDW_CONFIG_UI_SnC_KEY_B));
-		cdw_form_add_return_char(c_pages[id].cdw_form, 'q'); /* will work only for non-text fields */
+		cdw_form_add_return_char(o_pages[id].cdw_form, KEY_F(CDW_CONFIG_UI_SnC_KEY_A));
+		cdw_form_add_return_char(o_pages[id].cdw_form, KEY_F(CDW_CONFIG_UI_SnC_KEY_B));
+		cdw_form_add_return_char(o_pages[id].cdw_form, 'q'); /* will work only for non-text fields */
 	}
-	c_twindow->user_data = (void *) c_pages;
+	c_twindow->user_data = (void *) o_pages;
 
 	cdw_tabs_window_draw_tabs(c_twindow);
 	cdw_config_window_draw();
@@ -378,18 +403,18 @@
 */
 void cdw_config_window_destroy(void)
 {
-	if (cdw_config_window_tip != (char *) NULL) {
+	if (cdw_config_window_tip) {
 		free(cdw_config_window_tip);
 		cdw_config_window_tip = (char *) NULL;
 	}
 
 	for (int i = 0; i < c_twindow->n_tabs; i++) {
 		cdw_id_t id = c_twindow->tabs[i].id;
-		if (c_pages[id].cdw_form != (cdw_form_t *) NULL) {
-			cdw_form_delete_form_objects(c_pages[id].cdw_form);
+		if (o_pages[id].cdw_form) {
+			cdw_form_delete_form_objects(o_pages[id].cdw_form);
 		}
-		if (c_pages[id].cdw_form != (cdw_form_t *) NULL) {
-			cdw_form_delete(&(c_pages[id].cdw_form));
+		if (o_pages[id].cdw_form) {
+			cdw_form_delete(&(o_pages[id].cdw_form));
 		}
 	}
 
@@ -433,10 +458,10 @@
 			/* flush */
 			for (int i = 0; i < c_twindow->n_tabs; i++) {
 				cdw_id_t id = c_twindow->tabs[i].id;
-				form_driver(c_pages[id].cdw_form->form, REQ_VALIDATION);
+				form_driver(o_pages[id].cdw_form->form, REQ_VALIDATION);
 			}
 
-			bool old_follow_symlinks = config->follow_symlinks;
+			bool old_follow_symlinks = config->general.selected_follow_symlinks;
 
 			/* this function also saves indexes of selected
 			   tool paths into cdw_tools[] */
@@ -461,7 +486,7 @@
 						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
 
 				cdw_tabs_window_show_tab_by_id(c_twindow, page_id);
-				cdw_form_driver_go_to_field(c_pages[page_id].cdw_form, fi);
+				cdw_form_driver_go_to_field(o_pages[page_id].cdw_form, fi);
 
 				/* loop */
 			} else { /* valid == CDW_OK */
@@ -473,7 +498,7 @@
 				   be saved in other places */
 				cdw_config_window_save_non_config_fields();
 
-				cdw_main_ui_handle_follow_symlinks_change(old_follow_symlinks, config->follow_symlinks);
+				cdw_main_window_handle_follow_symlinks_change(old_follow_symlinks, config->general.selected_follow_symlinks);
 
 				/* CDW_OK means: values from "config" function
 				   argument can be saved to global config variable */
@@ -510,22 +535,26 @@
 	cdw_form->fields = page_hw_fields;
 	int help_lines = CONF_HEIGHT - 2 - 9;
 	cdw_form_descr_t descr[] = {
-		/*     type      begin_y   begin_x     n_cols     n_lines   field enum           data1                           data2 */
+		/* type                       begin_y   begin_x     n_cols     n_lines   field enum           data1                           data2 */
 
 		/* 2TRANS: this is label in configuration window, "drive" is an optical drive */
-		{ CDW_WIDGET_LABEL,    1,  first_col,  width_narrow,    1,  f_selected_drive_l,  _("cdw should use this drive:"),    0 },
-		{ CDW_WIDGET_DROPDOWN, 2,  first_col,  width_wide - 3,  1,  f_selected_drive_dd, dropdown_makers,                    1 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,       1,  first_col,  width_narrow,    1,  f_selected_drive_l,  _("cdw should use this drive:"),    0 },
+		{ CDW_WIDGET_ID_DROPDOWN,           2,  first_col,  width_wide - 3,  1,  f_selected_drive_dd, dropdown_makers,                    1 },
+
 		/* 2TRANS: this is input field label: keep no longer than original;
 		   input field holds path to cd reader/writer device */
-		{ CDW_WIDGET_LABEL,    4,  first_col,  width_narrow,    1,  f_custom_drive_l,    _("Custom path to drive:"),         0 },
-		{ CDW_WIDGET_INPUT,    5,  first_col,  width_wide,      1,  f_custom_drive_i,    config->custom_drive,               0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,      4,  first_col,  width_narrow,    1,  f_custom_drive_l,    _("Custom path to drive:"),         0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,    5,  first_col,  width_wide,      1,  f_custom_drive_i,    config->custom_drive,               0 },
+
 		/* 2TRANS: this is input field label: keep no longer than original;
 		   input field holds address of scsi writing device */
-		{ CDW_WIDGET_LABEL,    6,  first_col,  width_narrow,    1,  f_scsi_l,            _("SCSI device (for cdrecord):"),   0 },
-		{ CDW_WIDGET_INPUT,    7,  first_col,  width_wide,      1,  f_scsi_i,            config->scsi,                       0 },
-		{ CDW_WIDGET_TEXT,     9,  1,          width_wide,      help_lines, f_hw_txt_t,  text_makers,                        0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,      6,  first_col,  width_narrow,    1,  f_scsi_l,            _("SCSI device (for cdrecord):"),   0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,    7,  first_col,  width_wide,      1,  f_scsi_i,            config->scsi,                       0 },
+
+		{ CDW_WIDGET_ID_TEXT,               9,  1,          width_wide,      help_lines, f_hw_txt_t,  text_makers,                        0 },
+
 		/* guard */
-		{ -1,                  0,  0,          0,               0,  0,                   (void *) NULL,                      0 }};
+		{ -1,                               0,  0,          0,               0,  0,                   (void *) NULL,                      0 }};
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
@@ -533,6 +562,35 @@
 		return CDW_ERROR;
 	} else {
 		/* set_field_type(fields[f_scsi_i], TYPE_REGEXP, "^(ATAPI:|REMOTE:){0,1}[0-9],[0-9],[0-9]"); */
+		cdw_form_bind_input_and_label(cdw_form, f_custom_drive_i, f_custom_drive_l);
+		cdw_form_bind_input_and_label(cdw_form, f_scsi_i, f_scsi_l);
+		return CDW_OK;
+	}
+}
+
+
+
+
+
+cdw_rv_t page_udf_build_fields(cdw_form_t *cdw_form, __attribute__((unused)) void *cdw_config, int first_col, __attribute__((unused)) int second_col, int width_wide, __attribute__((unused)) int width_narrow)
+{
+	cdw_form->fields = page_udf_fields;
+	int help_lines1 = 15; /* There are 10 lines in English language. 15 should be more than enough for other languages. */
+	int help_lines2 = CONF_HEIGHT - 3 - help_lines1;
+
+	cdw_form_descr_t descr[] = {
+		/* type                         begin_y   begin_x     n_cols        n_lines        field enum           data1                           data2 */
+		{ CDW_WIDGET_ID_TEXT,                 1,  first_col,  width_wide,   help_lines1,   f_udf_tools_t,       text_makers,                        2 },
+		{ CDW_WIDGET_ID_TEXT,   help_lines1 + 1,  first_col,  width_wide,   help_lines2,   f_udf_options_t,     text_makers,                        3 },
+
+		/* guard */
+		{ -1,                                 0,  0,          0,            0,             0,                   (void *) NULL,                      0 }};
+
+	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to convert form description to form (page UDF)\n");
+		return CDW_ERROR;
+	} else {
 		return CDW_OK;
 	}
 }
@@ -558,27 +616,29 @@
 {
 	cdw_config_t *config = cdw_config;
 	cdw_form->fields = page_audio_fields;
-	int audio_dir_button_col =  first_col + width_wide - 3;
+	int audio_dir_button_col = first_col + width_wide - 3;
 	cdw_form_descr_t descr[] = {
-		/*      type    begin_y   begin_x     n_cols     n_lines   field enum       data1               data2 */
+		/* type                        begin_y   begin_x     n_cols     n_lines   field enum     data1               data2 */
 
 		/* 2TRANS: this is input field label: keep no longer than original;  input field
 		   holds path to directory, into which audio tracks will be ripped */
-		{ CDW_WIDGET_LABEL,   1,  first_col,  width_narrow,    1,  f_audiodir_l,  _("Audio output dir"),  0 },
-		{ CDW_WIDGET_INPUT,   2,  first_col,  width_wide - 3,  1,  f_audiodir_i,  config->audiodir,       0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,       1,  first_col,  width_narrow,    1,  f_audiodir_l,  _("Audio output dir"),  0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,     2,  first_col,  width_wide - 3,  1,  f_audiodir_i,  config->audiodir,       0 },
 		/* this fields is created only because there will be a button
 		   here, that I need to be able to navigate to, so string can be empty */
 		/* 2TRANS: do not translate */
-		{ CDW_WIDGET_BUTTON,  2,  audio_dir_button_col,  1,    1,  f_audiodir_b,  _(">"), CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,              2,  audio_dir_button_col,  1,    1,  f_audiodir_b,  _(">"), CDW_COLORS_DIALOG },
+
 		/* guard */
-		{ -1,                 0,  0,          0,               0,  0,             (void *) NULL,          0 } };
+		{ -1,                                0,  0,                     0,    0,  0,             (void *) NULL,          0 } };
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
-		cdw_form_set_function(cdw_form, f_audiodir_b, page_audio_handle_enter_on_audiodir_button);
+		cdw_form_set_widget_callback(cdw_form, f_audiodir_b, page_audio_handle_enter_on_audiodir_button);
+		cdw_form_bind_input_and_label(cdw_form, f_audiodir_i, f_audiodir_l);
 		return CDW_OK;
 	}
 }
@@ -605,46 +665,46 @@
 	cdw_form->fields = page_tools_fields;
 	bool ms = cdw_ext_tools_config_is_manual();
 	cdw_form_descr_t descr[] = {
-		/*     type        begin_y   begin_x         n_cols     n_lines   field enum                           data1                       data2 */
+		/* type                   begin_y   begin_x         n_cols     n_lines   field enum                           data1                       data2 */
 
-		{ CDW_WIDGET_TEXT,       1,  first_col,      width_wide,      2,  f_ext_tools_no_save_t,               text_makers,                    1 },
-		{ CDW_WIDGET_CHECKBOX,   3,  first_col + 1,  1,               1,  f_ext_tools_manual_selection_cb,     (void *) NULL,         ms ? 1 : 0 },
+		{ CDW_WIDGET_ID_TEXT,           1,  first_col,      width_wide,      2,  f_ext_tools_no_save_t,               text_makers,                    1 },
+		{ CDW_WIDGET_ID_CHECKBOX,       3,  first_col + 1,  1,               1,  f_ext_tools_manual_selection_cb,     (void *) NULL,         ms ? 1 : 0 },
 		/* 2TRANS: this is checkbox label, it means that user will perform manual
 		   selection of values in dropdowns representing available tools */
-		{ CDW_WIDGET_LABEL,      3,  first_col + 4,  width_wide - 3,  1,  f_ext_tools_manual_selection_l,      _("Configure tools manually"),  0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,   3,  first_col + 4,  width_wide - 3,  1,  f_ext_tools_manual_selection_l,      _("Configure tools manually"),  0 },
 
 		/* 2TRANS: this is label of input field */
-		{ CDW_WIDGET_LABEL,      5,  first_col,      width_wide,      1,  f_ext_tools_iso9660_l,               _("Tool for creating stand alone ISO9660 file:"),  0 },
-		{ CDW_WIDGET_DROPDOWN,   6,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_iso9660_dd,              dropdown_makers,                2 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,   5,  first_col,      width_wide,      1,  f_ext_tools_iso9660_l,               _("Tool for creating stand alone ISO9660 file:"),  0 },
+		{ CDW_WIDGET_ID_DROPDOWN,       6,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_iso9660_dd,              dropdown_makers,                2 },
 
 		/* 2TRANS: this is label of input field; "path" is path in filesystem */
-		{ CDW_WIDGET_LABEL,      7,  first_col,      width_narrow,           1,  f_ext_tools_cd_handlers_l,    _("Tools for handling CDs:"),   0 },
-		{ CDW_WIDGET_DROPDOWN,   8,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_cd_handlers_dd,          dropdown_makers,                3 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,   7,  first_col,      width_narrow,    1,  f_ext_tools_cd_handlers_l,           _("Tools for handling CDs:"),   0 },
+		{ CDW_WIDGET_ID_DROPDOWN,       8,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_cd_handlers_dd,          dropdown_makers,                3 },
 
 		/* 2TRANS: this is label of input field; */
-		{ CDW_WIDGET_LABEL,      9,  first_col,      width_wide,      1,  f_ext_tools_dvd_handlers_l,          _("Tools for handling DVDs:"),  0 },
-		{ CDW_WIDGET_DROPDOWN,  10,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_dvd_handlers_dd,         dropdown_makers,                4 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,   9,  first_col,      width_wide,      1,  f_ext_tools_dvd_handlers_l,          _("Tools for handling DVDs:"),  0 },
+		{ CDW_WIDGET_ID_DROPDOWN,      10,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_dvd_handlers_dd,         dropdown_makers,                4 },
 
 		/* 2TRANS: this is label of input field; "path" is path in filesystem */
-		{ CDW_WIDGET_LABEL,     11,  first_col,      width_narrow,           1,  f_ext_tools_mkisofs_path_l,   _("Path to mkisofs:"),          0 },
-		{ CDW_WIDGET_DROPDOWN,  12,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_mkisofs_path_dd,         dropdown_makers,                5 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,  11,  first_col,      width_narrow,    1,  f_ext_tools_mkisofs_path_l,          _("Path to mkisofs:"),          0 },
+		{ CDW_WIDGET_ID_DROPDOWN,      12,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_mkisofs_path_dd,         dropdown_makers,                5 },
 		/* 2TRANS: this is label of input field; "path" is path in filesystem */
-		{ CDW_WIDGET_LABEL,     13,  first_col,      width_narrow,           1,  f_ext_tools_cdrecord_path_l,  _("Path to cdrecord:"),         0 },
-		{ CDW_WIDGET_DROPDOWN,  14,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_cdrecord_path_dd,        dropdown_makers,                6 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,  13,  first_col,      width_narrow,    1,  f_ext_tools_cdrecord_path_l,         _("Path to cdrecord:"),         0 },
+		{ CDW_WIDGET_ID_DROPDOWN,      14,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_cdrecord_path_dd,        dropdown_makers,                6 },
 
 		/* 2TRANS: this is label of input field */
-		{ CDW_WIDGET_LABEL,     15,  first_col,      width_wide,           1,  f_ext_tools_digest_handlers_l,  _("Digest tool:"),              0 },
-		{ CDW_WIDGET_DROPDOWN,  16,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_digest_handlers_dd,      dropdown_makers,                7 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,  15,  first_col,      width_wide,      1,  f_ext_tools_digest_handlers_l,       _("Digest tool:"),              0 },
+		{ CDW_WIDGET_ID_DROPDOWN,      16,  first_col + 2,  width_wide - 3,  1,  f_ext_tools_digest_handlers_dd,      dropdown_makers,                7 },
 
 		/* guard */
-		{ -1,                    0,  0,              0,                     0,  0,                             (void *) NULL,                  0 }};
+		{ -1,                           0,  0,              0,               0,  0,                                   (void *) NULL,                  0 }};
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
-		cdw_form_set_function(cdw_form, f_ext_tools_manual_selection_cb, page_tools_toggle_manual_selection);
+		cdw_form_set_widget_callback(cdw_form, f_ext_tools_manual_selection_cb, page_tools_toggle_manual_selection);
 		return CDW_OK;
 	}
 }
@@ -670,55 +730,61 @@
 {
 	cdw_config_t *config = cdw_config;
 	cdw_form->fields = page_other_fields;
-#define CDW_CVF_WIDTH 6 /* CVF = custom value field */
+#define CDW_CVF_WIDTH 10 /* CVF = custom value field */
+
+	second_col = 28;
+	int third_col = second_col + CDW_CVF_WIDTH;
 
 	char cvf_buffer[CDW_CVF_WIDTH + 1];
-	if (config->volume_size_custom_value <= 0) {
-		config->volume_size_custom_value = 0;
+	if (config->general.volume_size_custom_value <= 0) {
+		config->general.volume_size_custom_value = 0;
 	} else {
-		if ((floor(log10((double) config->volume_size_custom_value)) + 1) > CDW_CVF_WIDTH) {
-			config->volume_size_custom_value = 0;
+		if ((floor(log10((double) config->general.volume_size_custom_value)) + 1) > CDW_CVF_WIDTH) {
+			config->general.volume_size_custom_value = 0;
 		}
 	}
-	snprintf(cvf_buffer, CDW_CVF_WIDTH + 1, "%ld", config->volume_size_custom_value);
+	snprintf(cvf_buffer, CDW_CVF_WIDTH + 1, "%ld", config->general.volume_size_custom_value);
 
 	int log_path_button_col = first_col + width_wide - 3;
 	cdw_form_descr_t descr[] = {
-		/*    type        begin_y   begin_x         n_cols      n_lines  field enum              data1                             data2 */
+		/*    type                  begin_y   begin_x            n_cols       n_lines   field enum               data1                             data2 */
 
 		/* 2TRANS: this is input field label: keep no longer than original;
 		   input field holds full path to log file */
-		{ CDW_WIDGET_LABEL,     1,  first_col,       width_wide,      1,  f_log_fp_l,            _("Log file path (obligatory):"),     0 },
-		{ CDW_WIDGET_INPUT,     2,  first_col,       width_wide - 3,  1,  f_log_fp_i,            config->log_full_path,                0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,    1,  first_col,         width_wide,        1,  f_log_fp_l,              _("Log file path (obligatory):"),    0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,  2,  first_col,         width_wide - 3,    1,  f_log_fp_i,              config->general.log_fullpath,        0 },
 		/* this fields is created only because there will be a button
 		   here, that I need to be able to navigate to, so string can be empty */
 		/* 2TRANS: do not translate */
-		{ CDW_WIDGET_BUTTON,    2,  log_path_button_col,  3,          1,  f_log_fp_b,            _(">"),               CDW_COLORS_DIALOG },
-		{ CDW_WIDGET_CHECKBOX,  3,  first_col + 1,   1,               1,  f_showlog_cb,          (void *) NULL,  config->showlog ? 1 : 0 },
+		{ CDW_WIDGET_ID_BUTTON,           2,  log_path_button_col,  3,              1,  f_log_fp_b,              _(">"),              CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_CHECKBOX,         3,  first_col + 1,     1,                 1,  f_showlog_cb,            (void *) NULL, config->general.show_log ? 1 : 0 },
 		/* 2TRANS: this is checkbox label: keep no longer than original */
-		{ CDW_WIDGET_LABEL,     3,  first_col + 4,   width_narrow,    1,  f_showlog_l,           _("Show log after actions"),          0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,     3,  first_col + 4,     width_narrow,      1,  f_showlog_l,             _("Show log after actions"),         0 },
 
-		/* 2TRANS: this is label above a dropdown, a maximal size of created/update ISO9660 volume */
-		{ CDW_WIDGET_LABEL,     6,  first_col,       width_narrow,    1,  f_volume_size_l,       _("ISO volume size:"),                0 },
-		{ CDW_WIDGET_DROPDOWN,  7,  first_col + 2,   width_wide - 3,  1,  f_volume_size_dd,      dropdown_makers,                      0 },
-		/* 2TRANS: this is input field label, user can enter into the field a custom value of max. size of ISO volume; "MB" is megabytes */
-		{ CDW_WIDGET_LABEL,     8,  first_col,       width_narrow,    1,  f_cust_volume_size_l,  _("Custom ISO volume size (MB):"),    0 },
-		{ CDW_WIDGET_INPUT,     8,  second_col + 5,  CDW_CVF_WIDTH,   1,  f_cust_volume_size_i,  cvf_buffer,               CDW_CVF_WIDTH },
-
-		{ CDW_WIDGET_CHECKBOX, 11,  first_col + 1,   1,               1,  f_follow_symlinks_cb,  (void *) NULL,  config->follow_symlinks ? 1 : 0 },
-		/* 2TRANS: this is checkbox label: keep no longer than original */
-		{ CDW_WIDGET_LABEL,    11,  first_col + 4,   width_wide - 3,  1,  f_follow_symlinks_l,  _("Follow added symbolic links"),      0 },
+		/* 2TRANS: this is label above a dropdown, a maximal size of created/updated ISO9660/UDF volume */
+		{ CDW_WIDGET_ID_STATIC_LABEL,     6,  first_col,         width_narrow - 5,  1,  f_volume_size_l,         _("Volume size:"),                   0 },
+		{ CDW_WIDGET_ID_DROPDOWN,         6,  width_narrow - 3,  width_narrow,      1,  f_volume_size_dd,        dropdown_makers,                     0 },
+
+		/* 2TRANS: this is input field label, user can enter into the field a custom value of max. size of ISO/UDF volume; "MB" is megabytes */
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,    7,  first_col,         width_narrow,      1,  f_cust_volume_size_l,    _("Custom volume size:"),            0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,  7,  second_col,        CDW_CVF_WIDTH,     1,  f_cust_volume_size_i,    cvf_buffer,              CDW_CVF_WIDTH },
+		{ CDW_WIDGET_ID_STATIC_LABEL,     7,  third_col,         17,                1,  f_cust_volume_size_l2,   _("MB (MB = 2^20 B)"),               0 },
 
+		{ CDW_WIDGET_ID_CHECKBOX,        11,  first_col + 1,     1,                 1,  f_follow_symlinks_cb,    (void *) NULL,  config->general.selected_follow_symlinks ? 1 : 0 },
+		{ CDW_WIDGET_ID_TEXT,            11,  first_col + 4,     width_wide - 6,    8,  f_follow_symlinks_l,     text_makers,                         4 },
 
 		/* guard */
-		{ -1,                   0,  0,             0,                 0,  0,                     (void *) NULL,                        0 } };
+		{ -1,                             0,  0,                 0,                 0,  0,                       (void *) NULL,                       0 } };
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
-		cdw_form_set_function(cdw_form, f_log_fp_b, page_other_handle_enter_on_log_path_button);
+		cdw_form_bind_input_and_label(cdw_form, f_log_fp_i, f_log_fp_l);
+		cdw_form_bind_input_and_label(cdw_form, f_cust_volume_size_i, f_cust_volume_size_l);
+
+		cdw_form_set_widget_callback(cdw_form, f_log_fp_b, page_other_handle_enter_on_log_path_button);
 		return CDW_OK;
 	}
 }
@@ -735,13 +801,13 @@
 cdw_rv_t cdw_config_window_draw(void)
 {
 	cdw_id_t id = CONFIG_PAGE_ID_TOOLS;
-	if (c_pages[id].visible) {
-		CDW_CHECKBOX *checkbox = cdw_form_get_checkbox(c_pages[id].cdw_form, f_ext_tools_manual_selection_cb);
+	if (o_pages[id].visible) {
+		CDW_CHECKBOX *checkbox = cdw_form_get_checkbox(o_pages[id].cdw_form, f_ext_tools_manual_selection_cb);
 		bool state = cdw_checkbox_get_state(checkbox);
-		checkbox->on_toggle(c_pages[id].cdw_form, &state);
+		checkbox->on_toggle_callback(o_pages[id].cdw_form, &state);
 	}
 
-	cdw_config_ui_tabs_window_form_draw(c_twindow, c_pages);
+	cdw_config_ui_tabs_window_form_draw(c_twindow);
 
 	return CDW_OK;
 }
@@ -753,14 +819,14 @@
 void cdw_config_window_save_non_config_fields(void)
 {
 	/* *** HARDWARE *** */
-	CDW_DROPDOWN *dropdown = cdw_form_get_dropdown(c_pages[CONFIG_PAGE_ID_HW].cdw_form, f_selected_drive_dd);
+	CDW_DROPDOWN *dropdown = cdw_form_get_dropdown(o_pages[CONFIG_PAGE_ID_HW].cdw_form, f_selected_drive_dd);
 	cdw_id_t id = cdw_dropdown_get_current_item_id(dropdown);
 	cdw_drive_save_configuration(id);
 
 	/* *** AUDIO *** */
 
 	/* *** TOOLS *** */
-	cdw_form_t *cdw_form = c_pages[CONFIG_PAGE_ID_TOOLS].cdw_form;
+	cdw_form_t *cdw_form = o_pages[CONFIG_PAGE_ID_TOOLS].cdw_form;
 	cdw_ext_tools_configuration_t etc;
 
 	etc.manual_selection = cdw_form_get_checkbox_state(cdw_form, f_ext_tools_manual_selection_cb);
@@ -792,7 +858,7 @@
 {
 
 	/* *** HARDWARE *** */
-	cdw_form_t *cdw_form = c_pages[CONFIG_PAGE_ID_HW].cdw_form;
+	cdw_form_t *cdw_form = o_pages[CONFIG_PAGE_ID_HW].cdw_form;
 	snprintf(config->custom_drive, OPTION_FIELD_LEN_MAX + 1, "%s", cdw_ncurses_get_field_string(*(cdw_form->fields + f_custom_drive_i)));
 	snprintf(config->scsi, OPTION_FIELD_LEN_MAX + 1, "%s", cdw_ncurses_get_field_string(*(cdw_form->fields + f_scsi_i)));
 
@@ -802,7 +868,7 @@
 
 
 	/* *** AUDIO *** */
-	cdw_form = c_pages[CONFIG_PAGE_ID_AUDIO].cdw_form;
+	cdw_form = o_pages[CONFIG_PAGE_ID_AUDIO].cdw_form;
 	cdw_string_set((&config->audiodir), cdw_ncurses_get_field_string(*(cdw_form->fields + f_audiodir_i)));
 
 
@@ -811,36 +877,36 @@
 
 
 	/* *** LOGGING AND OTHER *** */
-	cdw_form = c_pages[CONFIG_PAGE_ID_OTHER].cdw_form;
-	cdw_string_set(&(config->log_full_path), cdw_ncurses_get_field_string(*(cdw_form->fields + f_log_fp_i)));
-	config->showlog = cdw_form_get_checkbox_state(cdw_form, f_showlog_cb);
+	cdw_form = o_pages[CONFIG_PAGE_ID_OTHER].cdw_form;
+	cdw_string_set(&(config->general.log_fullpath), cdw_ncurses_get_field_string(*(cdw_form->fields + f_log_fp_i)));
+	config->general.show_log = cdw_form_get_checkbox_state(cdw_form, f_showlog_cb);
 	dropdown = cdw_form_get_dropdown(cdw_form, f_volume_size_dd);
-	config->volume_size_id = cdw_dropdown_get_current_item_id(dropdown);
+	config->general.volume_size_id = cdw_dropdown_get_current_item_id(dropdown);
 
 	char *cvs_buffer = cdw_ncurses_get_field_string(*(cdw_form->fields + f_cust_volume_size_i));
 	char *cvs_buffer_rest = (char *) NULL;
-	config->volume_size_custom_value = strtol(cvs_buffer, &cvs_buffer_rest, 10);
+	config->general.volume_size_custom_value = strtol(cvs_buffer, &cvs_buffer_rest, 10);
 	cdw_vdm ("INFO: volume size: buf = \"%s\", rest = \"%s\"\n", cvs_buffer, cvs_buffer_rest);
 	if (strlen(cvs_buffer_rest)) {
 		/* "-1" will be recognized as indicator of invalid buffer
 		   content at time of validation of config variable */
-		config->volume_size_custom_value = -1;
+		config->general.volume_size_custom_value = -1;
 		cdw_vdm ("WARNING: invalid substring \"%s\" in custom volume size string \"%s\"\n", cvs_buffer_rest, cvs_buffer);
 	} else {
-		cdw_vdm ("INFO: volume size string \"%s\" converted to int %ld\n", cvs_buffer, config->volume_size_custom_value);
+		cdw_vdm ("INFO: volume size string \"%s\" converted to int %ld\n", cvs_buffer, config->general.volume_size_custom_value);
 	}
 
-	config->follow_symlinks = cdw_form_get_checkbox_state(cdw_form, f_follow_symlinks_cb);
+	config->general.selected_follow_symlinks = cdw_form_get_checkbox_state(cdw_form, f_follow_symlinks_cb);
 
 #if 0
 
 	/* TODO: not a best place to set config->volume_size_value,
 	   because if volume_size_id == AUTO then it will be hard to
 	   do disc check here */
-	if (config->volume_size_id == CDW_CONFIG_VOLUME_SIZE_CUSTOM) {
-		config->volume_size_value = config->volume_size_custom_value;
+	if (config->general.volume_size_id == CDW_CONFIG_VOLUME_SIZE_CUSTOM) {
+		config->general.volume_size_value = config->general.volume_size_custom_value;
 	} else {
-		config->volume_size_value = cdw_config_volume_size_by_id(config->volume_size_id);
+		config->general.volume_size_value = cdw_config_volume_size_by_id(config->volume_size_id);
 	}
 #endif
 	return;
@@ -863,10 +929,14 @@
 	for (int i = f_ext_tools_manual_selection_l + 1; i < cdw_form->n_fields; i++) {
 		field_opts_toggle(*(cdw_form->fields + i), O_VISIBLE);
 
-		CDW_DROPDOWN *dd = cdw_form_get_dropdown(cdw_form, i);
-		if (dd != (CDW_DROPDOWN *) NULL) {
-			/* the field really is a dropdown (and not a label) */
-			dd_toggle(dd);
+		if (cdw_form->field_widget_types[i] == CDW_WIDGET_ID_DROPDOWN) {
+
+			CDW_DROPDOWN *dd = cdw_form_get_dropdown(cdw_form, i);
+			if (dd) {
+				dd_toggle(dd);
+			} else {
+				cdw_vdm ("ERROR: NULL dropdown widget #%d\n", i);
+			}
 		}
 	}
 
@@ -888,20 +958,20 @@
 						window, explaining what file should be
 						selected */
 					     _("Select new or existing log file"),
-					     &(local_config->log_full_path),
+					     &(local_config->general.log_fullpath),
 					     CDW_FS_FILE,
 					     R_OK | W_OK,
 					     CDW_FS_NEW | CDW_FS_EXISTING);
 	if (crv == CDW_OK) {
-		int rv = set_field_buffer(cdw_form->fields[f_log_fp_i], 0, local_config->log_full_path);
+		int rv = set_field_buffer(cdw_form->fields[f_log_fp_i], 0, local_config->general.log_fullpath);
 		if (rv != E_OK) {
-			cdw_vdm ("ERROR: failed to set field buffer with string = \"%s\"\n", local_config->log_full_path);
+			cdw_vdm ("ERROR: failed to set field buffer with string = \"%s\"\n", local_config->general.log_fullpath);
 		} else {
 			form_driver(cdw_form->form, REQ_END_LINE);
 		}
 	}
 
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 	cdw_config_window_refresh_page(cdw_form->form_id);
 
 	return 'a';
@@ -932,7 +1002,7 @@
 		}
 	}
 
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 	cdw_config_window_refresh_page(cdw_form->form_id);
 
 	return 'a';
@@ -944,10 +1014,10 @@
 
 void cdw_config_window_refresh_page(cdw_id_t id)
 {
-	redrawwin(c_pages[id].cdw_form->subwindow);
-	wrefresh(c_pages[id].cdw_form->subwindow);
-	redrawwin(c_pages[id].cdw_form->window);
-	wrefresh(c_pages[id].cdw_form->window);
+	redrawwin(o_pages[id].cdw_form->subwindow);
+	wrefresh(o_pages[id].cdw_form->subwindow);
+	redrawwin(o_pages[id].cdw_form->window);
+	wrefresh(o_pages[id].cdw_form->window);
 
 	return;
 }
@@ -970,7 +1040,7 @@
 	{ CDW_CONFIG_VOLUME_SIZE_CUSTOM,             gettext_noop("Custom value") },
 	/* 2TRANS: this is dropdown item label:
 	   "automatic" = automatic detection/resolution of size of ISO volume */
-	{ CDW_CONFIG_VOLUME_SIZE_AUTO,               gettext_noop("Get sizes from disc") }
+	{ CDW_CONFIG_VOLUME_SIZE_AUTO,               gettext_noop("Get size from disc") }
 };
 
 
@@ -980,7 +1050,7 @@
 	int n_items = 0;
 	for (int i = 0; i < CDW_CONFIG_VOLUME_ITEMS_MAX; i++) {
 		if (cdw_config_volume_size_items[i].id == CDW_CONFIG_VOLUME_SIZE_DVD_RP_DL
-		    && !local_config->support_dvd_rp_dl) {
+		    && !local_config->general.support_dvd_rp_dl) {
 			/* skipping this item won't introduce empty
 			   item in dropdown */
 			continue;
@@ -992,16 +1062,16 @@
 
 	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, n_items, items);
 
-	if (local_config->volume_size_id == CDW_CONFIG_VOLUME_SIZE_DVD_RP_DL
-	    && !local_config->support_dvd_rp_dl) {
+	if (local_config->general.volume_size_id == CDW_CONFIG_VOLUME_SIZE_DVD_RP_DL
+	    && !local_config->general.support_dvd_rp_dl) {
 		/* this may happen when value saved in config file is
 		   "DVD+R DL" (because previously cdw was called with
 		   enabled DVD+R DL support, and user has selected DVD+R DL
 		   in this dropdown, but this time cdw is called with support
 		   for DVD+R DL disabled; in such case try with CD-R */
-		local_config->volume_size_id = CDW_CONFIG_VOLUME_SIZE_CD74;
+		local_config->general.volume_size_id = CDW_CONFIG_VOLUME_SIZE_CD74;
 	}
-	cdw_dropdown_set_current_item_by_id(dd, local_config->volume_size_id);
+	cdw_dropdown_set_current_item_by_id(dd, local_config->general.volume_size_id);
 
 	return dd;
 }
@@ -1022,6 +1092,49 @@
 
 
 
+char *cdw_config_window_page_udf_message_tools(int n_cols)
+{
+	/* 2TRANS: this is a description in one of configuration
+	   window panels. It explains what commands are needed to be
+	   executed by cdw to create UDF file. */
+	return cdw_string_wrap(_("In order to create stand-alone UDF image cdw needs to be able to run these commands:\n"
+
+				 "$ truncate <image file>\n"
+				 "$ mkudffs <options> <image file>\n"
+				 "$ sudo mount -oloop,rw <image file> <mount point>\n"
+				 "$ rsync <options> <files> <mount point>\n"
+				 "$ sync\n"
+				 "$ sudo umount <mount point>\n"
+
+				 "These commands must exist on your system, and you must have proper permissions to run them. The sudo commands must be executed without providing password."), (size_t) n_cols, CDW_ALIGN_LEFT);
+}
+
+
+
+
+
+char *cdw_config_window_page_udf_message_options(int n_cols)
+{
+	/* 2TRANS: this is a description in one of configuration
+	   window panels. It explains that some options for creating
+	   UDF image should be set in configuration window. */
+	return cdw_string_wrap(_("Don't forget to check \"Volume size\" option in \"Log and misc\" tab in this window.\n"
+				 "Also don't forget to set proper handling of symlinks in image wizard's options window."), (size_t) n_cols, CDW_ALIGN_LEFT);
+}
+
+
+
+char *cdw_config_window_page_misc_symlinks_txt(int n_cols)
+{
+	/* 2TRANS: this is a message in configuration window about "follow symbolic links" checkbox. */
+	return cdw_string_wrap(_("When calculating size of files selected in main window, follow symbolic links.\n"
+				 "This option applies *only* to size of selected files that you see in main window.\n"
+				 "You will *have to* use proper options for symlinks in image wizard options when creating ISO9660 or UDF file system."),
+			       (size_t) n_cols, CDW_ALIGN_LEFT);
+}
+
+
+
 char *cdw_config_window_page_hw_message(int n_cols)
 {
 	char *message = cdw_drive_get_help_message();
@@ -1037,20 +1150,22 @@
 
 
 
-
-
 /**
    \brief Draw widgets in configuration window
 
    \return CDW_OK if there were no problems
 */
-cdw_rv_t cdw_config_ui_tabs_window_form_draw(cdw_tabs_window_t *twindow, cdw_config_page_t *config_pages)
+cdw_rv_t cdw_config_ui_tabs_window_form_draw(cdw_tabs_window_t *twindow)
 {
+	/* Data linked to the tabbed window: options pages. */
+	cdw_options_page_t *options_pages = twindow->user_data;
+	cdw_assert (options_pages, "ERROR: no options pages associated with tabbed window\n");
+
 	for (int i = 0; i < twindow->n_tabs; i++) {
 		cdw_id_t id = twindow->tabs[i].id;
-		cdw_assert (config_pages[id].visible, "ERROR: page #%d (id = %lld) is not visible\n", i, id);
-		cdw_form_redraw_widgets(config_pages[id].cdw_form);
-		form_driver(config_pages[id].cdw_form->form, REQ_FIRST_FIELD);
+		cdw_assert (options_pages[id].visible, "ERROR: page #%d (id = %lld) is not visible\n", i, id);
+		cdw_form_redraw_widgets(options_pages[id].cdw_form);
+		form_driver(options_pages[id].cdw_form->form, REQ_FIRST_FIELD);
 	}
 
 	return CDW_OK;
@@ -1072,18 +1187,32 @@
    form/window, provided that the key has been configured as "return key" for
    this specific form.
 
-   \param dummy - the function does not make any use of the argument
+   \param twindow - tabbed window
 
    \return function returns key pressed in a page of configuration window
 */
 int cdw_config_ui_tabs_window_form_reader(void *twindow)
 {
+	/* A tabbed window as a whole. */
 	cdw_tabs_window_t *t_window = (cdw_tabs_window_t *) twindow;
+
+	/* References to specific tab in the window (current tab):
+	   index and ID of the tab. */
 	int ind = t_window->current_tab;
-	cdw_config_page_t *config_pages = t_window->user_data;
 	cdw_id_t id = t_window->tabs[ind].id;
-	int fi = field_index(current_field(config_pages[id].cdw_form->form));
-	return cdw_form_driver(config_pages[id].cdw_form, fi);
-}
 
+	/* Data linked to the tabbed window: options pages. */
+	cdw_options_page_t *options_pages = t_window->user_data;
+
+	/* Index of specific field in cdw form being part of specific options page. */
+	int fi = field_index(current_field(options_pages[id].cdw_form->form));
 
+	/* A cdw form has a driver function.  There is an old driver,
+	   for forms created long time ago, and there is a newer
+	   driver, for forms that were created or updated
+	   recently. Two different form drivers - this is why we use
+	   function pointer.
+
+	   Use form driver, and tell it to start at initial field fi. */
+	return cdw_form_driver(options_pages[id].cdw_form, fi);
+}
diff -Naur orig/src/configuration/cdw_config_window.h patched/src/configuration/cdw_config_window.h
--- orig/src/configuration/cdw_config_window.h	2012-03-13 20:12:56.000000000 +0100
+++ patched/src/configuration/cdw_config_window.h	2014-03-04 21:12:46.000000000 +0100
@@ -14,18 +14,19 @@
 
 typedef cdw_rv_t (* fields_builder_function_t)(cdw_form_t *, void *, int, int, int, int);
 
+
 typedef struct {
-	bool visible;           /* on some occasions some config pages are disabled = invisible */
-	int n_fields;           /* number of fields in ncurses form (last field=NULL not included) */
-	fields_builder_function_t fields_builder;  /* function that defines fields description and creates the fields */
-	const char *label;      /* text label specific to each page; it will be passed to function creating tabs of tabbed window */
-	cdw_form_t *cdw_form;   /* data structure build on top of ncurses fields, and combined with "tabbed windows" window and subwindow */
-} cdw_config_page_t;
+	bool visible;           /* On some occasions some options pages are disabled = invisible. */
+	int n_fields;           /* Number of fields in ncurses form (last field=NULL not included). */
+	fields_builder_function_t fields_builder;  /* Function that defines fields description and creates the fields in the options page. */
+	const char *label;      /* Text label specific to each options page. It will be passed to function creating tabs of tabbed window. */
+	cdw_form_t *cdw_form;   /* Data structure built on top of ncurses fields, and combined with "tabbed windows" window and subwindow. */
+} cdw_options_page_t;
 
 cdw_rv_t cdw_config_window(void);
 
 
-cdw_rv_t cdw_config_ui_tabs_window_form_draw(cdw_tabs_window_t *twindow, cdw_config_page_t *c_pages);
+cdw_rv_t cdw_config_ui_tabs_window_form_draw(cdw_tabs_window_t *twindow);
 int      cdw_config_ui_tabs_window_form_reader(void *twindow);
 
 
@@ -71,6 +72,12 @@
 	f_audiodir_i,
 	f_audiodir_b };
 
+/* field indexes for page with UDF settings */
+enum {
+	f_udf_tools_t = 0,
+	f_udf_options_t
+};
+
 /* field indexes for page with tool settings */
 enum {
 	f_ext_tools_no_save_t = 0,
@@ -101,10 +108,10 @@
 	f_volume_size_dd,
 	f_cust_volume_size_l,
 	f_cust_volume_size_i,
+	f_cust_volume_size_l2,
 	f_follow_symlinks_cb,
 	f_follow_symlinks_l
 };
 
 
 #endif /* H_CDW_CONFIG_WINDOW */
-
diff -Naur orig/src/configuration/Makefile.in patched/src/configuration/Makefile.in
--- orig/src/configuration/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/configuration/Makefile.in	2014-01-19 20:51:29.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,20 +76,24 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/configuration
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwconfiguration_a_AR = $(AR) $(ARFLAGS)
 libcdwconfiguration_a_LIBADD =
 am__objects_1 = cdw_config.$(OBJEXT) cdw_config_window.$(OBJEXT)
@@ -58,24 +106,71 @@
 am_libcdwconfiguration_check_a_OBJECTS = $(am__objects_2)
 libcdwconfiguration_check_a_OBJECTS =  \
 	$(am_libcdwconfiguration_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwconfiguration_a_SOURCES) \
 	$(libcdwconfiguration_check_a_SOURCES)
 DIST_SOURCES = $(libcdwconfiguration_a_SOURCES) \
 	$(libcdwconfiguration_check_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -285,14 +380,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwconfiguration.a: $(libcdwconfiguration_a_OBJECTS) $(libcdwconfiguration_a_DEPENDENCIES) $(EXTRA_libcdwconfiguration_a_DEPENDENCIES) 
-	-rm -f libcdwconfiguration.a
-	$(libcdwconfiguration_a_AR) libcdwconfiguration.a $(libcdwconfiguration_a_OBJECTS) $(libcdwconfiguration_a_LIBADD)
-	$(RANLIB) libcdwconfiguration.a
+	$(AM_V_at)-rm -f libcdwconfiguration.a
+	$(AM_V_AR)$(libcdwconfiguration_a_AR) libcdwconfiguration.a $(libcdwconfiguration_a_OBJECTS) $(libcdwconfiguration_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwconfiguration.a
+
 libcdwconfiguration_check.a: $(libcdwconfiguration_check_a_OBJECTS) $(libcdwconfiguration_check_a_DEPENDENCIES) $(EXTRA_libcdwconfiguration_check_a_DEPENDENCIES) 
-	-rm -f libcdwconfiguration_check.a
-	$(libcdwconfiguration_check_a_AR) libcdwconfiguration_check.a $(libcdwconfiguration_check_a_OBJECTS) $(libcdwconfiguration_check_a_LIBADD)
-	$(RANLIB) libcdwconfiguration_check.a
+	$(AM_V_at)-rm -f libcdwconfiguration_check.a
+	$(AM_V_AR)$(libcdwconfiguration_check_a_AR) libcdwconfiguration_check.a $(libcdwconfiguration_check_a_OBJECTS) $(libcdwconfiguration_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwconfiguration_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -306,67 +403,56 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwconfiguration_check_a-cdw_config.o: cdw_config.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwconfiguration_check_a-cdw_config.o -MD -MP -MF $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Tpo -c -o libcdwconfiguration_check_a-cdw_config.o `test -f 'cdw_config.c' || echo '$(srcdir)/'`cdw_config.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Tpo $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_config.c' object='libcdwconfiguration_check_a-cdw_config.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwconfiguration_check_a-cdw_config.o -MD -MP -MF $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Tpo -c -o libcdwconfiguration_check_a-cdw_config.o `test -f 'cdw_config.c' || echo '$(srcdir)/'`cdw_config.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Tpo $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_config.c' object='libcdwconfiguration_check_a-cdw_config.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwconfiguration_check_a-cdw_config.o `test -f 'cdw_config.c' || echo '$(srcdir)/'`cdw_config.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwconfiguration_check_a-cdw_config.o `test -f 'cdw_config.c' || echo '$(srcdir)/'`cdw_config.c
 
 libcdwconfiguration_check_a-cdw_config.obj: cdw_config.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwconfiguration_check_a-cdw_config.obj -MD -MP -MF $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Tpo -c -o libcdwconfiguration_check_a-cdw_config.obj `if test -f 'cdw_config.c'; then $(CYGPATH_W) 'cdw_config.c'; else $(CYGPATH_W) '$(srcdir)/cdw_config.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Tpo $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_config.c' object='libcdwconfiguration_check_a-cdw_config.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwconfiguration_check_a-cdw_config.obj -MD -MP -MF $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Tpo -c -o libcdwconfiguration_check_a-cdw_config.obj `if test -f 'cdw_config.c'; then $(CYGPATH_W) 'cdw_config.c'; else $(CYGPATH_W) '$(srcdir)/cdw_config.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Tpo $(DEPDIR)/libcdwconfiguration_check_a-cdw_config.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_config.c' object='libcdwconfiguration_check_a-cdw_config.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwconfiguration_check_a-cdw_config.obj `if test -f 'cdw_config.c'; then $(CYGPATH_W) 'cdw_config.c'; else $(CYGPATH_W) '$(srcdir)/cdw_config.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwconfiguration_check_a-cdw_config.obj `if test -f 'cdw_config.c'; then $(CYGPATH_W) 'cdw_config.c'; else $(CYGPATH_W) '$(srcdir)/cdw_config.c'; fi`
 
 libcdwconfiguration_check_a-cdw_config_window.o: cdw_config_window.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwconfiguration_check_a-cdw_config_window.o -MD -MP -MF $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Tpo -c -o libcdwconfiguration_check_a-cdw_config_window.o `test -f 'cdw_config_window.c' || echo '$(srcdir)/'`cdw_config_window.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Tpo $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_config_window.c' object='libcdwconfiguration_check_a-cdw_config_window.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwconfiguration_check_a-cdw_config_window.o -MD -MP -MF $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Tpo -c -o libcdwconfiguration_check_a-cdw_config_window.o `test -f 'cdw_config_window.c' || echo '$(srcdir)/'`cdw_config_window.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Tpo $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_config_window.c' object='libcdwconfiguration_check_a-cdw_config_window.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwconfiguration_check_a-cdw_config_window.o `test -f 'cdw_config_window.c' || echo '$(srcdir)/'`cdw_config_window.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwconfiguration_check_a-cdw_config_window.o `test -f 'cdw_config_window.c' || echo '$(srcdir)/'`cdw_config_window.c
 
 libcdwconfiguration_check_a-cdw_config_window.obj: cdw_config_window.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwconfiguration_check_a-cdw_config_window.obj -MD -MP -MF $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Tpo -c -o libcdwconfiguration_check_a-cdw_config_window.obj `if test -f 'cdw_config_window.c'; then $(CYGPATH_W) 'cdw_config_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_config_window.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Tpo $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_config_window.c' object='libcdwconfiguration_check_a-cdw_config_window.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwconfiguration_check_a-cdw_config_window.obj -MD -MP -MF $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Tpo -c -o libcdwconfiguration_check_a-cdw_config_window.obj `if test -f 'cdw_config_window.c'; then $(CYGPATH_W) 'cdw_config_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_config_window.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Tpo $(DEPDIR)/libcdwconfiguration_check_a-cdw_config_window.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_config_window.c' object='libcdwconfiguration_check_a-cdw_config_window.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwconfiguration_check_a-cdw_config_window.obj `if test -f 'cdw_config_window.c'; then $(CYGPATH_W) 'cdw_config_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_config_window.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwconfiguration_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwconfiguration_check_a-cdw_config_window.obj `if test -f 'cdw_config_window.c'; then $(CYGPATH_W) 'cdw_config_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_config_window.c'; fi`
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -378,15 +464,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -395,6 +477,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -536,18 +633,19 @@
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean \
-	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES ctags \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # used by flymake
diff -Naur orig/src/disc_and_drive/cdw_cdio.c patched/src/disc_and_drive/cdw_cdio.c
--- orig/src/disc_and_drive/cdw_cdio.c	2012-03-27 21:29:39.000000000 +0200
+++ patched/src/disc_and_drive/cdw_cdio.c	2014-04-12 21:17:18.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -31,8 +31,12 @@
 
 
 #include <cdio/mmc.h>
+#include <cdio/mmc_cmds.h>
 #include <cdio/logging.h>
 
+#include "config_cdw_undefine.h"
+#include "config_cdw.h"
+
 #include "cdw_cdio.h"
 #include "cdw_cdio_drives.h"
 #include "cdw_ofs.h"
@@ -42,7 +46,6 @@
 #include "gettext.h"
 #include "cdw_debug.h"
 #include "cdw_logging.h"
-#include "config.h"
 #include "cdw_sys.h"
 
 
@@ -1831,4 +1834,3 @@
 
 	return;
 }
-
diff -Naur orig/src/disc_and_drive/cdw_cdio_drives.c patched/src/disc_and_drive/cdw_cdio_drives.c
--- orig/src/disc_and_drive/cdw_cdio_drives.c	2012-02-26 15:25:19.000000000 +0100
+++ patched/src/disc_and_drive/cdw_cdio_drives.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #include <stdio.h>
 #include <unistd.h>
@@ -143,9 +143,14 @@
 
 		cdw_rv_t crv = cdw_cdio_drives_get_drive_capabilities(saved);
 		if (crv != CDW_OK) {
-			cdw_vdm ("ERROR: can't get capabilities for drive #%d: \"%s\"\n",
+			/* May be e.g. a /dev/loop1 device for ISO
+			   image mounted by root user.  Skip it,
+			   forget it, move on. */
+			cdw_vdm ("WARNING: can't get capabilities for drive #%d: \"%s\"\n",
 				 saved, cdw_cdio_drives[saved].fullpath);
-			return CDW_ERROR;
+			free(cdw_cdio_drives[saved].fullpath);
+			cdw_cdio_drives[saved].fullpath = (char *) NULL;
+			continue;
 		}
 		saved++;
 	}
diff -Naur orig/src/disc_and_drive/cdw_cdio.h patched/src/disc_and_drive/cdw_cdio.h
--- orig/src/disc_and_drive/cdw_cdio.h	2012-02-19 22:11:05.000000000 +0100
+++ patched/src/disc_and_drive/cdw_cdio.h	2014-01-19 20:49:59.000000000 +0100
@@ -6,6 +6,9 @@
 #include <cdio/cdio.h>
 #include <cdio/cd_types.h>
 #include <cdio/iso9660.h>
+
+#include "config_cdw_undefine.h"
+
 #include "main.h"
 #include "cdw_ofs.h"
 
@@ -94,4 +97,3 @@
 
 
 #endif /* H_CDW_CDIO */
-
diff -Naur orig/src/disc_and_drive/cdw_disc.c patched/src/disc_and_drive/cdw_disc.c
--- orig/src/disc_and_drive/cdw_disc.c	2012-03-03 21:09:28.000000000 +0100
+++ patched/src/disc_and_drive/cdw_disc.c	2014-04-06 23:06:53.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -621,7 +621,7 @@
 				      program cannot get metadata from disc */
 				   _("Cannot get information about disc."),
 				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 
 		return CDW_ERROR;
 	}
@@ -635,19 +635,19 @@
 		   supported (this was more true in cdw v. 0.3.91,
 		   situation has improved in 0.3.92). */
 
-		if (global_config.show_dvd_rw_support_warning) {
+		if (global_config.general.show_dvd_rw_support_warning) {
 
 			/* 2TRANS: this is title of dialog window */
 			cdw_buttons_dialog(_("Warning"),
 					   /* 2TRANS: this is message dialog window */
 					   _("This is DVD-RW disc, it is not fully supported by cdw. You may have some problems."),
 					   CDW_BUTTONS_OK, CDW_COLORS_WARNING);
-			cdw_main_ui_main_window_wrefresh();
+			cdw_main_window_wrefresh();
 
 			/* don't annoy user with this message anymore
 			   in current run of cdw; this option is
 			   not saved to configuration file */
-			global_config.show_dvd_rw_support_warning = false;
+			global_config.general.show_dvd_rw_support_warning = false;
 		}
 	}
 
@@ -704,7 +704,7 @@
 				      program cannot get metadata from disc */
 				   _("Cannot get basic information about disc."),
 				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		return CDW_ERROR;
 	}
 
@@ -1004,7 +1004,7 @@
 		   || t == CDW_DVD_R_SEQ
 		   || t == CDW_DVD_R_RES
 		   || t == CDW_DVD_RP
-		   || (t == CDW_DVD_RP_DL && global_config.support_dvd_rp_dl)) {
+		   || (t == CDW_DVD_RP_DL && global_config.general.support_dvd_rp_dl)) {
 
 		disc->type_erasable = CDW_FALSE;
 		disc->type_writable = CDW_TRUE;
@@ -1132,7 +1132,7 @@
 	char *l = disc->type_label;
 
 	if (disc->type == CDW_DVD_RP_DL &&
-	    ! global_config.support_dvd_rp_dl) {
+	    ! global_config.general.support_dvd_rp_dl) {
 
 		strncpy(l, cdw_disc_type_labels[CDW_DISC_TYPE_UNKNOWN], CDW_DISC_TYPE_LABEL_LEN);
 	} else {
@@ -1330,6 +1330,7 @@
 		disc->capacity.sectors_used = disc->xorriso_info.sectors_used >= 0 ? disc->xorriso_info.sectors_used : disc->cdio->ofs->n_sectors;
 	} else if (disc->libburn_info.unformatted_size != 0) {
 		cdw_vdm ("INFO: using libburn info\n");
+		/* FIXME: are you sure that this is always 2048? */
 		disc->capacity.sectors_total = disc->libburn_info.unformatted_size / 2048;
 		disc->capacity.sectors_used = 0;
 		if (disc->cdio->ofs->n_sectors > 0) {
@@ -1445,3 +1446,55 @@
 	return disc->cdio->n_tracks;
 }
 
+
+
+
+
+/*
+  Capacity of Blu-ray Standard disc size, XL 4 layer: 128 001 769 472 bytes
+  Capacity of uint32_t type:                            4 294 967 295
+  Capacity of uint64_t type:               18 446 744 073 709 551 615
+
+  \return zero on errors
+  \return total disc capacity (in bytes) on success
+*/
+uint64_t cdw_disc_get_total_capacity_bytes(void)
+{
+	cdw_disc_t *disc = cdw_disc_new();
+	if (!disc) {
+		cdw_vdm ("ERROR: failed to make new disc\n");
+		return 0;
+	}
+
+	cdw_rv_t crv = cdw_disc_get(disc);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to get disc info\n");
+		cdw_disc_delete(&disc);
+		return 0;
+	}
+
+	cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, false);
+
+	uint64_t capacity = 0;
+	if (disc->capacity.sectors_total < 0) {
+		cdw_vdm ("ERROR: failed to get sectors total from disc\n");
+		capacity = 0;
+	} else {
+		/* 2048 bytes per sector is a kind of lowest common
+		   denominator. Most (but not all) discs supported by
+		   cdw (CD and DVD discs) will have at least 2048
+		   bytes per sector.
+
+		   FIXME: if you ever decide to support other disc
+		   types, the sector size will may be different (I
+		   haven't checked this).
+
+		   FIXME: this may be true for empty CD discs, but for
+		   CD discs that already have some tracks in different
+		   formats this is not exactly true. */
+		capacity = ((uint64_t) disc->capacity.sectors_total) * 2048;
+	}
+
+	cdw_disc_delete(&disc);
+	return capacity;
+}
diff -Naur orig/src/disc_and_drive/cdw_disc.h patched/src/disc_and_drive/cdw_disc.h
--- orig/src/disc_and_drive/cdw_disc.h	2012-03-03 21:07:34.000000000 +0100
+++ patched/src/disc_and_drive/cdw_disc.h	2014-03-13 22:17:39.000000000 +0100
@@ -7,6 +7,8 @@
 #include <cdio/iso9660.h>
 #include <libburn/libburn.h>
 
+#include "config_cdw_undefine.h"
+
 #include "main.h"
 #include "cdw_cdio.h"
 #include "cdw_ofs.h"
@@ -69,9 +71,6 @@
 
 /* applicable to dvd (and maybe blu-ray) discs only */
 typedef struct {
-	/* table of starting sectors of tracks on DVD disc */
-	// long int track_address[100];
-	// long int n_tracks;
 
 	ssize_t read_capacity; /* number of 2048-bytes blocks, can be -1 as initial value */
 	char disc_status; /* first letter of "blank", "appendable", "complete", "other" */
@@ -186,6 +185,8 @@
 bool cdw_disc_is_disc_type_writable(cdw_disc_t *disc);
 
 
+uint64_t cdw_disc_get_total_capacity_bytes(void);
+
 
 /* use when you need to get writing speed index based on config.speed_range */
 int cdw_disc_get_initial_write_speed_id(cdw_disc_t *disc);
@@ -194,4 +195,3 @@
 
 
 #endif /* H_CDW_DISC */
-
diff -Naur orig/src/disc_and_drive/cdw_drive.c patched/src/disc_and_drive/cdw_drive.c
--- orig/src/disc_and_drive/cdw_drive.c	2012-03-11 17:53:02.000000000 +0100
+++ patched/src/disc_and_drive/cdw_drive.c	2014-03-15 13:33:46.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -384,7 +384,7 @@
 
 		cdw_rv_t crv = cdw_buttons_dialog(title, message,
 						  buttons, CDW_COLORS_ERROR);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		if (buttons == CDW_BUTTONS_OK) {
 			break; /* break loop, go to final error message */
 		} else {
@@ -403,7 +403,7 @@
 			      occurred while accessing drive */
 			   _("Something went wrong.\nPlease check settings in Configuration -> Hardware and try once more."),
 			   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	return CDW_NO; /* user couldn't decide what to do or hardware settings in cdw options are invalid */
 }
@@ -429,11 +429,11 @@
    \param device_fullpath - path to device that you want to control
    \param final_eject - should the function look at config.eject to check if tray should be left open?
  */
-void cdw_drive_reload_tray_with_ui_update(const char *device_fullpath, bool final_eject)
+void cdw_drive_reload_tray_with_ui_update(const char *device_fullpath, bool final_eject, bool config_eject)
 {
 	cdw_drive_eject_tray_with_ui_update(device_fullpath);
 	if (final_eject) {
-		if (global_config.eject) { /* leave tray open */
+		if (config_eject) { /* leave tray open */
 			return;
 		}
 	}
@@ -460,7 +460,7 @@
 
 	/* update information about disc size and usage:
 	   0, 0 = sectors used, sectors total */
-	cdw_main_window_volume_info_view_update(0, 0, false, global_config.follow_symlinks);
+	cdw_main_window_volume_info_view_update(0, 0, false);
 
 	return;
 }
@@ -482,9 +482,9 @@
 
 	cdw_disc_t *disc = cdw_disc_new();
 	cdw_disc_get(disc);
-	cdw_main_ui_disc_info_view_display_data(disc);
+	cdw_main_window_disc_info_view_display_data(disc);
 	/* update information about disc size and usage */
-	cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, false, global_config.follow_symlinks);
+	cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, false);
 	cdw_disc_delete(&disc);
 
 	return;
@@ -618,9 +618,9 @@
 		cdw_vdm ("ERROR: failed to toggle drive tray\n");
 	}
 
-	cdw_main_ui_disc_info_view_display_data(disc);
+	cdw_main_window_disc_info_view_display_data(disc);
 	/* update information about disc size and usage */
-	cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, false, global_config.follow_symlinks);
+	cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, false);
 	/* 2TRANS: this is message in process window,
 	    "drive" is "optical drive" - a burner */
 	cdw_processwin_destroy(_("Drive state changed"), false);
@@ -803,4 +803,3 @@
 {
 	return drives.current_drive_id;
 }
-
diff -Naur orig/src/disc_and_drive/cdw_drive.h patched/src/disc_and_drive/cdw_drive.h
--- orig/src/disc_and_drive/cdw_drive.h	2012-01-21 16:49:06.000000000 +0100
+++ patched/src/disc_and_drive/cdw_drive.h	2014-03-15 13:31:13.000000000 +0100
@@ -38,19 +38,16 @@
 
 cdw_rv_t cdw_drive_eject_tray(const char *device_fullpath);
 cdw_rv_t cdw_drive_close_tray(const char *device_fullpath);
-//cdw_rv_t cdw_drive_toggle_tray(const char *device_fullpath);
 void cdw_drive_eject_tray_with_ui_update(const char *device_fullpath);
 void cdw_drive_close_tray_with_ui_update(const char *device_fullpath);
 
 void cdw_drive_toggle_tray_with_ui_update2(void);
-//void cdw_drive_toggle_tray_with_ui_update(void);
-void cdw_drive_reload_tray_with_ui_update(const char *device_fullpath, bool final_eject);
+void cdw_drive_reload_tray_with_ui_update(const char *device_fullpath, bool final_eject, bool config_eject);
 
 
 cdw_rv_t cdw_drive_disc_availability(void);
 
 CDW_DROPDOWN *cdw_drive_make_drives_dropdown(WINDOW *window, int row, int col, int width);
-//cdw_rv_t cdw_drive_print_help_message(WINDOW *window);
 char *cdw_drive_get_help_message(void);
 
 #endif /* H_CDW_DRIVE */
diff -Naur orig/src/disc_and_drive/Makefile.in patched/src/disc_and_drive/Makefile.in
--- orig/src/disc_and_drive/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/disc_and_drive/Makefile.in	2014-01-19 20:51:29.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,20 +76,24 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/disc_and_drive
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwdiscanddrive_a_AR = $(AR) $(ARFLAGS)
 libcdwdiscanddrive_a_LIBADD =
 am__objects_1 = cdw_cdio.$(OBJEXT) cdw_cdio_drives.$(OBJEXT) \
@@ -61,24 +109,71 @@
 am_libcdwdiscanddrive_check_a_OBJECTS = $(am__objects_2)
 libcdwdiscanddrive_check_a_OBJECTS =  \
 	$(am_libcdwdiscanddrive_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwdiscanddrive_a_SOURCES) \
 	$(libcdwdiscanddrive_check_a_SOURCES)
 DIST_SOURCES = $(libcdwdiscanddrive_a_SOURCES) \
 	$(libcdwdiscanddrive_check_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -290,14 +385,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwdiscanddrive.a: $(libcdwdiscanddrive_a_OBJECTS) $(libcdwdiscanddrive_a_DEPENDENCIES) $(EXTRA_libcdwdiscanddrive_a_DEPENDENCIES) 
-	-rm -f libcdwdiscanddrive.a
-	$(libcdwdiscanddrive_a_AR) libcdwdiscanddrive.a $(libcdwdiscanddrive_a_OBJECTS) $(libcdwdiscanddrive_a_LIBADD)
-	$(RANLIB) libcdwdiscanddrive.a
+	$(AM_V_at)-rm -f libcdwdiscanddrive.a
+	$(AM_V_AR)$(libcdwdiscanddrive_a_AR) libcdwdiscanddrive.a $(libcdwdiscanddrive_a_OBJECTS) $(libcdwdiscanddrive_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwdiscanddrive.a
+
 libcdwdiscanddrive_check.a: $(libcdwdiscanddrive_check_a_OBJECTS) $(libcdwdiscanddrive_check_a_DEPENDENCIES) $(EXTRA_libcdwdiscanddrive_check_a_DEPENDENCIES) 
-	-rm -f libcdwdiscanddrive_check.a
-	$(libcdwdiscanddrive_check_a_AR) libcdwdiscanddrive_check.a $(libcdwdiscanddrive_check_a_OBJECTS) $(libcdwdiscanddrive_check_a_LIBADD)
-	$(RANLIB) libcdwdiscanddrive_check.a
+	$(AM_V_at)-rm -f libcdwdiscanddrive_check.a
+	$(AM_V_AR)$(libcdwdiscanddrive_check_a_AR) libcdwdiscanddrive_check.a $(libcdwdiscanddrive_check_a_OBJECTS) $(libcdwdiscanddrive_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwdiscanddrive_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -315,95 +412,84 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwdiscanddrive_check_a-cdw_cdio.o: cdw_cdio.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_cdio.o -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Tpo -c -o libcdwdiscanddrive_check_a-cdw_cdio.o `test -f 'cdw_cdio.c' || echo '$(srcdir)/'`cdw_cdio.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdio.c' object='libcdwdiscanddrive_check_a-cdw_cdio.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_cdio.o -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Tpo -c -o libcdwdiscanddrive_check_a-cdw_cdio.o `test -f 'cdw_cdio.c' || echo '$(srcdir)/'`cdw_cdio.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdio.c' object='libcdwdiscanddrive_check_a-cdw_cdio.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_cdio.o `test -f 'cdw_cdio.c' || echo '$(srcdir)/'`cdw_cdio.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_cdio.o `test -f 'cdw_cdio.c' || echo '$(srcdir)/'`cdw_cdio.c
 
 libcdwdiscanddrive_check_a-cdw_cdio.obj: cdw_cdio.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_cdio.obj -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Tpo -c -o libcdwdiscanddrive_check_a-cdw_cdio.obj `if test -f 'cdw_cdio.c'; then $(CYGPATH_W) 'cdw_cdio.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdio.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdio.c' object='libcdwdiscanddrive_check_a-cdw_cdio.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_cdio.obj -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Tpo -c -o libcdwdiscanddrive_check_a-cdw_cdio.obj `if test -f 'cdw_cdio.c'; then $(CYGPATH_W) 'cdw_cdio.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdio.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdio.c' object='libcdwdiscanddrive_check_a-cdw_cdio.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_cdio.obj `if test -f 'cdw_cdio.c'; then $(CYGPATH_W) 'cdw_cdio.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdio.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_cdio.obj `if test -f 'cdw_cdio.c'; then $(CYGPATH_W) 'cdw_cdio.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdio.c'; fi`
 
 libcdwdiscanddrive_check_a-cdw_cdio_drives.o: cdw_cdio_drives.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_cdio_drives.o -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Tpo -c -o libcdwdiscanddrive_check_a-cdw_cdio_drives.o `test -f 'cdw_cdio_drives.c' || echo '$(srcdir)/'`cdw_cdio_drives.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdio_drives.c' object='libcdwdiscanddrive_check_a-cdw_cdio_drives.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_cdio_drives.o -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Tpo -c -o libcdwdiscanddrive_check_a-cdw_cdio_drives.o `test -f 'cdw_cdio_drives.c' || echo '$(srcdir)/'`cdw_cdio_drives.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdio_drives.c' object='libcdwdiscanddrive_check_a-cdw_cdio_drives.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_cdio_drives.o `test -f 'cdw_cdio_drives.c' || echo '$(srcdir)/'`cdw_cdio_drives.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_cdio_drives.o `test -f 'cdw_cdio_drives.c' || echo '$(srcdir)/'`cdw_cdio_drives.c
 
 libcdwdiscanddrive_check_a-cdw_cdio_drives.obj: cdw_cdio_drives.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_cdio_drives.obj -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Tpo -c -o libcdwdiscanddrive_check_a-cdw_cdio_drives.obj `if test -f 'cdw_cdio_drives.c'; then $(CYGPATH_W) 'cdw_cdio_drives.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdio_drives.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdio_drives.c' object='libcdwdiscanddrive_check_a-cdw_cdio_drives.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_cdio_drives.obj -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Tpo -c -o libcdwdiscanddrive_check_a-cdw_cdio_drives.obj `if test -f 'cdw_cdio_drives.c'; then $(CYGPATH_W) 'cdw_cdio_drives.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdio_drives.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_cdio_drives.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdio_drives.c' object='libcdwdiscanddrive_check_a-cdw_cdio_drives.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_cdio_drives.obj `if test -f 'cdw_cdio_drives.c'; then $(CYGPATH_W) 'cdw_cdio_drives.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdio_drives.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_cdio_drives.obj `if test -f 'cdw_cdio_drives.c'; then $(CYGPATH_W) 'cdw_cdio_drives.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdio_drives.c'; fi`
 
 libcdwdiscanddrive_check_a-cdw_disc.o: cdw_disc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_disc.o -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Tpo -c -o libcdwdiscanddrive_check_a-cdw_disc.o `test -f 'cdw_disc.c' || echo '$(srcdir)/'`cdw_disc.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_disc.c' object='libcdwdiscanddrive_check_a-cdw_disc.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_disc.o -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Tpo -c -o libcdwdiscanddrive_check_a-cdw_disc.o `test -f 'cdw_disc.c' || echo '$(srcdir)/'`cdw_disc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_disc.c' object='libcdwdiscanddrive_check_a-cdw_disc.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_disc.o `test -f 'cdw_disc.c' || echo '$(srcdir)/'`cdw_disc.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_disc.o `test -f 'cdw_disc.c' || echo '$(srcdir)/'`cdw_disc.c
 
 libcdwdiscanddrive_check_a-cdw_disc.obj: cdw_disc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_disc.obj -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Tpo -c -o libcdwdiscanddrive_check_a-cdw_disc.obj `if test -f 'cdw_disc.c'; then $(CYGPATH_W) 'cdw_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_disc.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_disc.c' object='libcdwdiscanddrive_check_a-cdw_disc.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_disc.obj -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Tpo -c -o libcdwdiscanddrive_check_a-cdw_disc.obj `if test -f 'cdw_disc.c'; then $(CYGPATH_W) 'cdw_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_disc.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_disc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_disc.c' object='libcdwdiscanddrive_check_a-cdw_disc.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_disc.obj `if test -f 'cdw_disc.c'; then $(CYGPATH_W) 'cdw_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_disc.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_disc.obj `if test -f 'cdw_disc.c'; then $(CYGPATH_W) 'cdw_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_disc.c'; fi`
 
 libcdwdiscanddrive_check_a-cdw_drive.o: cdw_drive.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_drive.o -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Tpo -c -o libcdwdiscanddrive_check_a-cdw_drive.o `test -f 'cdw_drive.c' || echo '$(srcdir)/'`cdw_drive.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_drive.c' object='libcdwdiscanddrive_check_a-cdw_drive.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_drive.o -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Tpo -c -o libcdwdiscanddrive_check_a-cdw_drive.o `test -f 'cdw_drive.c' || echo '$(srcdir)/'`cdw_drive.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_drive.c' object='libcdwdiscanddrive_check_a-cdw_drive.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_drive.o `test -f 'cdw_drive.c' || echo '$(srcdir)/'`cdw_drive.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_drive.o `test -f 'cdw_drive.c' || echo '$(srcdir)/'`cdw_drive.c
 
 libcdwdiscanddrive_check_a-cdw_drive.obj: cdw_drive.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_drive.obj -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Tpo -c -o libcdwdiscanddrive_check_a-cdw_drive.obj `if test -f 'cdw_drive.c'; then $(CYGPATH_W) 'cdw_drive.c'; else $(CYGPATH_W) '$(srcdir)/cdw_drive.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_drive.c' object='libcdwdiscanddrive_check_a-cdw_drive.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwdiscanddrive_check_a-cdw_drive.obj -MD -MP -MF $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Tpo -c -o libcdwdiscanddrive_check_a-cdw_drive.obj `if test -f 'cdw_drive.c'; then $(CYGPATH_W) 'cdw_drive.c'; else $(CYGPATH_W) '$(srcdir)/cdw_drive.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Tpo $(DEPDIR)/libcdwdiscanddrive_check_a-cdw_drive.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_drive.c' object='libcdwdiscanddrive_check_a-cdw_drive.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_drive.obj `if test -f 'cdw_drive.c'; then $(CYGPATH_W) 'cdw_drive.c'; else $(CYGPATH_W) '$(srcdir)/cdw_drive.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwdiscanddrive_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwdiscanddrive_check_a-cdw_drive.obj `if test -f 'cdw_drive.c'; then $(CYGPATH_W) 'cdw_drive.c'; else $(CYGPATH_W) '$(srcdir)/cdw_drive.c'; fi`
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -415,15 +501,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -432,6 +514,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -573,18 +670,19 @@
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean \
-	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES ctags \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # used by flymake
diff -Naur orig/src/external_tools/cdw_cdrecord.c patched/src/external_tools/cdw_cdrecord.c
--- orig/src/external_tools/cdw_cdrecord.c	2012-02-26 15:26:27.000000000 +0100
+++ patched/src/external_tools/cdw_cdrecord.c	2014-04-06 23:05:31.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdlib.h>
@@ -28,7 +28,7 @@
 #include <fcntl.h>
 
 #include "gettext.h"
-#include "cdw_thread.h" /* run_command() */
+#include "cdw_thread.h" /* cdw_thread_run_command() */
 #include "cdw_widgets.h"
 #include "cdw_config.h"
 #include "cdw_config_window.h"
@@ -163,7 +163,7 @@
 
 
 
-/* used in only one function: cdw_rv_t run_command_cdrecord_write_direct(void);
+/* used in only one function: cdw_rv_t cdw_cdrecord_write_from_files(void);
    I know that it is an awful solution, but it has to stay for now */
 #define CDRECORD_WRITE_DATA_FREE_RESOURCES \
 	/* ANSI C allows free(NULL); */\
@@ -251,7 +251,7 @@
 	cdw_vdm ("INFO: final command for writing image to optical disc:\n");
 	cdw_vdm ("INFO: \"%s\"\n", command);
 
-	int rv = run_command(command, task);
+	int rv = cdw_thread_run_command(command, task);
 	free(command);
 	command = (char *) NULL;
 
@@ -270,7 +270,7 @@
    \brief Write files selected by user to optical disc
 
    Create command line string (program name + arguments) for writing files
-   to optical disc. Run the command (using run_command()), show a window with
+   to optical disc. Run the command (using cdw_thread_run_command()), show a window with
    process information to the user.
 
    The command line string (when passed to shell) will do the following:
@@ -321,7 +321,7 @@
 	   that will be used by program writing to disk - read
 	   cdw_cdrecord_create_command_for_writing() function for explanation */
 	tsize_command = cdw_string_concat("tsize=`", mkisofs_command, " --print-size -quiet`", (char *) NULL);
-	if (tsize_command == CDW_OK) {
+	if (!tsize_command) {
 		cdw_cdrecord_internal_error_dialog(2);
 		CDRECORD_WRITE_DATA_FREE_RESOURCES;
 		cdw_vdm ("ERROR: failed to prepare tsize command string\n");
@@ -371,9 +371,9 @@
 	   (program name + options) passed to shell */
 	cdw_logging_write(_("Command for cdrecord: \"%s\"\n"), cdrecord_command);
 	cdw_logging_write("\n\n");
-	/* no need to print "final_command" to log - this is done in run_command() */
+	/* no need to print "final_command" to log - this is done in cdw_thread_run_command() */
 
-	int rv = run_command(final_command, task);
+	int rv = cdw_thread_run_command(final_command, task);
 
 	CDRECORD_WRITE_DATA_FREE_RESOURCES;
 	if (rv == 0) {
@@ -394,7 +394,7 @@
 
    This function does the following:
    \li Prepares blanking command
-   \li Calls run_command() to blank disc
+   \li Calls cdw_thread_run_command() to blank disc
    \li If blanking could not be performed, user is informed about this
 
    Media should be checked for "erasability" before calling this function.
@@ -441,7 +441,7 @@
 
 	cdw_vdm ("command = \"%s\"\n", command);
 
-	int rv = run_command(command, task);
+	int rv = cdw_thread_run_command(command, task);
 
 	free(command);
 	command = (char *) NULL;
@@ -452,7 +452,7 @@
 
 	/* it might occur during blanking that 'this media does not
 	   support blanking, ignoring', and disc->type_erasable was
-	   set to 'MEDIA_ERASABLE_NO' in run_command(); let's inform user
+	   set to 'MEDIA_ERASABLE_NO' in cdw_thread_run_command(); let's inform user
 	   about this sad fact */
 	if (disc->type_erasable == CDW_FALSE) {
 		if (task->erase.erase_mode == CDW_ERASE_MODE_FAST) {
@@ -560,7 +560,7 @@
 			   it is about getting some meta information from
 			   optical disc */
 			cdw_processwin_display_sub_info(_("Getting ATIP information"));
-			int rv = run_command(command, task);
+			int rv = cdw_thread_run_command(command, task);
 			free(command);
 			command = (char *) NULL;
 			cdw_task_check_tool_status(task);
@@ -586,7 +586,7 @@
 			   it is about getting some meta information from
 			   optical disc */
 			cdw_processwin_display_sub_info(_("Getting PRCAP information"));
-			int rv = run_command(command, task);
+			int rv = cdw_thread_run_command(command, task);
 			free(command);
 			command = (char *) NULL;
 			cdw_task_check_tool_status(task);
@@ -613,7 +613,7 @@
 			   it is about getting some meta information from
 			   optical disc */
 			cdw_processwin_display_sub_info(_("Getting TOC information"));
-			int rv = run_command(command, task);
+			int rv = cdw_thread_run_command(command, task);
 			free(command);
 			command = (char *) NULL;
 			cdw_task_check_tool_status(task);
@@ -639,7 +639,7 @@
 			   it is about getting some meta information from
 			   optical disc */
 			cdw_processwin_display_sub_info(_("Getting MSINFO information"));
-			int rv = run_command(command, task);
+			int rv = cdw_thread_run_command(command, task);
 			free(command);
 			command = (char *) NULL;
 			cdw_task_check_tool_status(task);
@@ -667,7 +667,7 @@
 
    Go through all supported CDRECORD options and if given option is enabled,
    put its value into one string. Put path to CDRECORD at the beginning of
-   the string. This creates a string that can be passed to run_command().
+   the string. This creates a string that can be passed to cdw_thread_run_command().
 
    \pre \p task->source is set to either OBJ_DATA_FILES or OBJ_ISO_IMAGE.
    These two values identify two valid sources of data that can be
@@ -704,7 +704,7 @@
 	if (task->id == CDW_TASK_BURN_FROM_FILES) {
 		strcpy(tsize_value, "${tsize}");
 	} else { /* task->id == CDW_TASK_BURN_FROM_IMAGE */
-		long long int fs_size = cdw_fs_get_file_size(task->burn.iso9660_file_fullpath);
+		long long int fs_size = cdw_fs_get_file_size(task->image_file_fullpath);
 		snprintf(tsize_value, TSIZE_LEN + 1, "%lld", fs_size / 2048);
 		cdw_vdm ("INFO: tsize_value string = \"%s\", strlen(tsize_value) = %zd\n", tsize_value, strlen(tsize_value));
 	}
@@ -731,11 +731,11 @@
 	   chars (not including ending \0); last +1 below is for ending \0 */
 	size_t pad_len_max = 9 + CDW_CDRECORD_OPTIONS_PADSIZE_FIELD_LEN_MAX + 7;
 	char pad_string[pad_len_max + 1];
-	if (task->burn.cdrecord.pad_size > 0) {
+	if (task->burn.cdrecord_pad_size > 0) {
 		snprintf(pad_string, pad_len_max + 1,
-			 " padsize=%ds %s ", task->burn.cdrecord.pad_size, task->burn.cdrecord.pad ? "-pad" : " ");
+			 " padsize=%ds %s ", task->burn.cdrecord_pad_size, task->burn.cdrecord_pad ? "-pad" : " ");
 	} else {
-		snprintf(pad_string, pad_len_max + 1, " %s ", task->burn.cdrecord.pad ? "-pad" : " ");
+		snprintf(pad_string, pad_len_max + 1, " %s ", task->burn.cdrecord_pad ? "-pad" : " ");
 	}
 	cdw_vdm ("pad string is \"%s\", %zd / %zd chars\n", pad_string, strlen(pad_string), pad_len_max);
 
@@ -766,7 +766,7 @@
 					  strlen(disc_mode) ? disc_mode : " ",
 
 					  task->burn.dummy ? " -dummy " : " ",
-					  task->burn.cdrecord.burnproof ? " driveropts=burnfree " : " ",
+					  task->burn.cdrecord_burnproof ? " driveropts=burnfree " : " ",
 
 					  /* cdrecord man page says: "Values below
 					     2 seconds are not recommended to give
@@ -776,7 +776,7 @@
 
 					  add_multi ? " -multi " : " ",
 
-					  " ", task->burn.cdrecord.other_cdrecord_options, " ",
+					  " ", task->burn.cdrecord_other_options, " ",
 
 					  pad_string,
 
@@ -792,7 +792,7 @@
 					     path to iso file may contain spaces, so put
 					     the path in quotes */
 					  read_from_stdin ? " - " : "\"",
-					  read_from_stdin ? "  " : task->burn.iso9660_file_fullpath,
+					  read_from_stdin ? "  " : task->image_file_fullpath,
 					  read_from_stdin ? "  " : "\"",
 
 					  /* last argument passed to concat() must be NULL */
@@ -1042,120 +1042,3 @@
 		return false;
 	}
 }
-
-
-
-
-
-/* *** unused code below *** */
-
-#if 0
-
-
-/**
-   \brief Create process writing audio CD; this code is currently not maintained
-
-   \param task - variable describing current task
-
-   \return CDW_OK
- */
-cdw_rv_t run_command_cdrecord_write_audio(cdw_task_t *task)
-{
-	char command[500];
-	cdw_rv_t crv = CDW_OK;
-
-	crv = cdw_config_ui_conditional_volume_label_dialog();
-	bool use_scsi = cdw_config_has_scsi_device();
-	const char *device = use_scsi ? global_config.scsi : cdw_drive_get_drive_fullpath();
-
-	if (crv == CDW_OK) { /* user entered label: empty or non-empty, but continue in both cases */
-		cdw_assert (task->burn.tool.fullpath != (char *) NULL, "ERROR: tool fullpath is NULL\n");
-		sprintf(command, "%s -v speed=%d dev=%s -audio", task->burn.tool.fullpath, task->burn.speed, device);
-		if (global_config.pad) {
-			/* when you go back to maintaining this code, don't
-			   forget to add padsize */
-			strcat(command, " -pad ");
-		}
-		if (task->burn.disc_mode == CDW_DISC_MODE_DAO) {
-			strcat(command, " -dao ");
-		}
-		if (global_config.dummy) {
-			strcat(command, " -dummy ");
-		}
-		if (global_config.burnproof) {
-			strcat(command, " -driveropts=burnproof ");
-		}
-		sprintf(command, "%s %s/*.wav", command, global_config.audiodir);
-		/* 2TRANS: this is dialog window title
-		   (writing audio files to CD) */
-		cdw_processwin_create(_("Write audio"),
-				      /* 2TRANS: this is message in dialog
-					 window: writing audio CD is in
-					 progress */
-				      _("Writing audio..."), true);
-
-		run_command(command, task);
-
-		/* 2TRANS: this is message in dialog window; result of
-		   operation is unknown */
-		cdw_processwin_destroy(_("Writing audio finished"), true);
-
-		/* 2TRANS: this string will be used as title of window
-		   displaying log of operation (of writing audio CD) */
-		after_event(_("Write audio log"), 1);
-	}
-
-	return CDW_OK;
-}
-
-
-
-
-
-/**
-   \brief Create process copying CD disk; this code is currently not maintained
-
-   \param task - variable describing current task
-
-   \return CDW_OK
- */
-cdw_rv_t run_command_cdrecord_copy_disk(cdw_task_t *task)
-{
-	char command[500];
-	int in_fd;
-	bool use_scsi = cdw_config_has_scsi_device();
-	const char *device = use_scsi ? global_config.scsi : cdw_drive_get_drive_fullpath();
-
-	if ((in_fd = open("/dev/cdrom", O_RDONLY)) != -1) {
-		close(in_fd);
-		cdw_assert (task->burn.tool.fullpath != (char *) NULL, "ERROR: tool fullpath is NULL\n");
-		sprintf(command, "%s -v speed=%d dev=%s %s", task->burn.tool.fullpath, task->burn.speed, device, lobal_config.other_cdrecord_options);
-		if (global_config.eject) {
-			strcat(command, " -eject");
-		}
-		if (global_config.dummy) {
-			strcat(command, " -dummy");
-		}
-
-		sprintf(command, "%s -isosize %s", command, global_config.cdrw_device);
-		/* 2TRANS: this is dialog window title */
-		cdw_processwin_create(_("Copy data CD"), (char *) NULL, true);
-
-		run_command(command, task);
-
-		/* 2TRANS: this is message in dialog window:
-		   result of operation (success/failure) unknown */
-		cdw_processwin_destroy(_("Copying data CD finished"), true);
-
-		/* 2TRANS: this string will be used as title of
-		   window displaying log of operation (of copying CD) */
-		after_event(_("Copy data CD log"), 1);
-	}
-
-	return CDW_OK;
-}
-
-
-
-#endif
-
diff -Naur orig/src/external_tools/cdw_cdrecord_options.c patched/src/external_tools/cdw_cdrecord_options.c
--- orig/src/external_tools/cdw_cdrecord_options.c	2012-03-28 20:31:02.000000000 +0200
+++ patched/src/external_tools/cdw_cdrecord_options.c	2014-03-12 22:04:42.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -61,7 +61,7 @@
 
 	int padsize_width = CDW_CDRECORD_OPTIONS_PADSIZE_FIELD_LEN_MAX;
 	char pad_size[CDW_CDRECORD_OPTIONS_PADSIZE_FIELD_LEN_MAX + 1];
-	snprintf(pad_size, (size_t) padsize_width + 1, "%d", task->burn.cdrecord.pad_size);
+	snprintf(pad_size, (size_t) padsize_width + 1, "%d", task->burn.cdrecord_pad_size);
 	int Xs_col = second_col + padsize_width;
 
 	/* the "150" value below is selected after small tests with DVD;
@@ -71,35 +71,37 @@
 	   so it should be a constant defined in some header */
 
 	cdw_form_descr_t descr[] = {
-		/*     type        begin_y   begin_x       n_cols           n_lines  field enum              data1                                       data2 */
+		/* type                      begin_y   begin_x        n_cols    n_lines   field enum                data1                                                data2 */
 
-		{ CDW_WIDGET_CHECKBOX, 1,  first_col + 1,          1,     1,  f_cdrecord_pad_cb,        (void *) NULL,         task->burn.cdrecord.pad ? 1 : 0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          1,  first_col + 1,          1,     1,  f_cdrecord_pad_cb,        (void *) NULL,         task->burn.cdrecord_pad ? 1 : 0 },
 		/* 2TRANS: this is checkbox label in config window; a noun (?); "pad" -> "padding" -> "some bytes added at the end of proper data" */
-		{ CDW_WIDGET_LABEL,    1,  first_col + 4, width_wide,     1,  f_cdrecord_pad_l,         _("Pad"),                                            0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      1,  first_col + 4, width_wide,     1,  f_cdrecord_pad_l,         _("Pad"),                                            0 },
 
 		/* 2TRANS: this is checkbox label: keep no longer than original; "Pad" refers to adding empty data at the end of track */
-		{ CDW_WIDGET_LABEL,    2,  first_col,     width_wide,     1,  f_cdrecord_pad_size_l,    _("Pad size (number >= 0, '150' is recommended)"),   0 },
-		{ CDW_WIDGET_INPUT,    3,  second_col,    padsize_width,  1,  f_cdrecord_pad_size_i,    pad_size,                       (size_t) padsize_width },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     2,  first_col,     width_wide,     1,  f_cdrecord_pad_size_l,    _("Pad size (number >= 0, '150' is recommended)"),   0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   3,  second_col,    padsize_width,  1,  f_cdrecord_pad_size_i,    pad_size,                       (size_t) padsize_width },
 		/* padsize, Xs */
 		/* 2TRANS: do not translate */
-		{ CDW_WIDGET_LABEL,    3,  Xs_col,  1,                    1,  f_cdrecord_pad_size_xl,   _("s"),                                              0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      3,  Xs_col,  1,                    1,  f_cdrecord_pad_size_xl,   _("s"),                                              0 },
 
-		{ CDW_WIDGET_CHECKBOX, 5,  first_col + 1,          1,     1,  f_cdrecord_burnproof_cb,  (void *) NULL,   task->burn.cdrecord.burnproof ? 1 : 0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          5,  first_col + 1,          1,     1,  f_cdrecord_burnproof_cb,  (void *) NULL,   task->burn.cdrecord_burnproof ? 1 : 0 },
 		/* 2TRANS: this is checkbox label in configuration window; see documentation of cdrecord for definition of "burnproof" */
-		{ CDW_WIDGET_LABEL,    5,  first_col + 4, width_wide,     1,  f_cdrecord_burnproof_l,   _("Burnproof"),                                      0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      5,  first_col + 4, width_wide,     1,  f_cdrecord_burnproof_l,   _("Burnproof"),                                      0 },
 
 		/* 2TRANS: this is label of input field in configuration window; the field contains other options passed to cdrecord */
-		{ CDW_WIDGET_LABEL,    6,  first_col,     width_wide,     1,  f_cdrecord_other_l,       _("Other cdrecord options:"),                        0 },
-		{ CDW_WIDGET_INPUT,    7,  first_col,     width_wide - 3, 1,  f_cdrecord_other_i,       task->burn.cdrecord.other_cdrecord_options,          0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     6,  first_col,     width_wide,     1,  f_cdrecord_other_l,       _("Other cdrecord options:"),                        0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   7,  first_col,     width_wide - 3, 1,  f_cdrecord_other_i,       task->burn.cdrecord_other_options,                   0 },
 
 		/* guard */
-		{ -1,                  0,  0,           0,              0,  0,                          (void *) NULL,                                       0 }};
+		{ -1,                              0,  0,             0,              0,  0,                        (void *) NULL,                                       0 }};
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
+		cdw_form_bind_input_and_label(cdw_form, f_cdrecord_pad_size_i, f_cdrecord_pad_size_l);
+		cdw_form_bind_input_and_label(cdw_form, f_cdrecord_other_i, f_cdrecord_other_l);
 		return CDW_OK;
 	}
 }
@@ -108,10 +110,9 @@
 
 
 
-cdw_rv_t cdw_cdrecord_options_validate(cdw_form_t *cdw_form, int *fi)
+cdw_rv_t cdw_cdrecord_options_validate(cdw_task_t *task, int *fi)
 {
-	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_cdrecord_other_i));
-	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	cdw_rv_t crv = cdw_string_security_parser(task->burn.cdrecord_other_options, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_cdrecord_other_i;
 		return CDW_NO;
@@ -126,15 +127,14 @@
 
 cdw_rv_t cdw_cdrecord_options_save(cdw_form_t *cdw_form, cdw_task_t *task)
 {
-	task->burn.cdrecord.pad = cdw_form_get_checkbox_state(cdw_form, f_cdrecord_pad_cb);
+	task->burn.cdrecord_pad = cdw_form_get_checkbox_state(cdw_form, f_cdrecord_pad_cb);
 
 	const char *buf = cdw_form_get_string(cdw_form, f_cdrecord_pad_size_i);
-	task->burn.cdrecord.pad_size = atoi(buf);
+	task->burn.cdrecord_pad_size = atoi(buf);
 
-	task->burn.cdrecord.burnproof = cdw_form_get_checkbox_state(cdw_form, f_cdrecord_burnproof_cb);
+	task->burn.cdrecord_burnproof = cdw_form_get_checkbox_state(cdw_form, f_cdrecord_burnproof_cb);
 
-	cdw_string_set(&(task->burn.cdrecord.other_cdrecord_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_cdrecord_other_i)));
+	cdw_string_set(&(task->burn.cdrecord_other_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_cdrecord_other_i)));
 
 	return CDW_OK;
 }
-
diff -Naur orig/src/external_tools/cdw_cdrecord_options.h patched/src/external_tools/cdw_cdrecord_options.h
--- orig/src/external_tools/cdw_cdrecord_options.h	2011-03-14 20:42:30.000000000 +0100
+++ patched/src/external_tools/cdw_cdrecord_options.h	2014-03-10 20:16:22.000000000 +0100
@@ -12,7 +12,7 @@
 #define CDW_CDRECORD_OPTIONS_N_FIELDS   9
 
 cdw_rv_t cdw_cdrecord_options_form(cdw_form_t *cdw_form, void *task, int first_col, int second_col, int width_wide, int width_narrow);
-cdw_rv_t cdw_cdrecord_options_validate(cdw_form_t *cdw_form, int *fi);
+cdw_rv_t cdw_cdrecord_options_validate(cdw_task_t *task, int *fi);
 cdw_rv_t cdw_cdrecord_options_save(cdw_form_t *cdw_form, cdw_task_t *task);
 
 
diff -Naur orig/src/external_tools/cdw_cdrecord_regex.c patched/src/external_tools/cdw_cdrecord_regex.c
--- orig/src/external_tools/cdw_cdrecord_regex.c	2012-03-03 21:07:56.000000000 +0100
+++ patched/src/external_tools/cdw_cdrecord_regex.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdio.h>
diff -Naur orig/src/external_tools/cdw_digest.c patched/src/external_tools/cdw_digest.c
--- orig/src/external_tools/cdw_digest.c	2012-02-26 15:27:34.000000000 +0100
+++ patched/src/external_tools/cdw_digest.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdlib.h>
@@ -38,7 +38,7 @@
 	}
 
 
-	int rv = run_command(command, task);
+	int rv = cdw_thread_run_command(command, task);
 	free(command);
 	command = (char *) NULL;
 
@@ -48,4 +48,3 @@
 		return CDW_ERROR;
 	}
 }
-
diff -Naur orig/src/external_tools/cdw_digest_regex.c patched/src/external_tools/cdw_digest_regex.c
--- orig/src/external_tools/cdw_digest_regex.c	2012-02-26 15:26:37.000000000 +0100
+++ patched/src/external_tools/cdw_digest_regex.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdlib.h>
@@ -157,4 +157,3 @@
 	}
 	return;
 }
-
diff -Naur orig/src/external_tools/cdw_dvd_rw_format.c patched/src/external_tools/cdw_dvd_rw_format.c
--- orig/src/external_tools/cdw_dvd_rw_format.c	2012-02-26 15:25:52.000000000 +0100
+++ patched/src/external_tools/cdw_dvd_rw_format.c	2014-03-15 13:34:29.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdio.h>
@@ -52,16 +52,16 @@
 		   important to know not only if this should be 'fast' or
 		   'all', but also mode in which formatted disc should be:
 		   'Restricted Overwrite' or 'Incremental Sequential' */
-		if (task->erase.format_mode == CDW_ERASE_DVD_RW_FORMAT_SEQ) {
-			cdw_sdm ("INFO: task->erase.format_mode == DVD_RW_FORMAT_SEQ\n");
+		if (task->erase.dvd_rw_format_mode == CDW_ERASE_DVD_RW_FORMAT_SEQ) {
+			cdw_sdm ("INFO: task->erase.dvd_rw_format_mode == DVD_RW_FORMAT_SEQ\n");
 			cdw_assert (task->erase.tool.label != (char *) NULL, "ERROR: tool fullpath is NULL\n");
 			command = cdw_string_concat(task->erase.tool.label,
 						    " -speed=", speed_string, " ",
 						    " -blank", task->erase.erase_mode == CDW_ERASE_MODE_FAST ? " " : "=full ",
 						    drive,
 						    (char *) NULL);
-		} else if (task->erase.format_mode == CDW_ERASE_DVD_RW_FORMAT_RES) {
-			cdw_sdm ("INFO: task->erase.format_mode == DVD_RW_FORMAT_RES\n");
+		} else if (task->erase.dvd_rw_format_mode == CDW_ERASE_DVD_RW_FORMAT_RES) {
+			cdw_sdm ("INFO: task->erase.dvd_rw_format_mode == DVD_RW_FORMAT_RES\n");
 			cdw_assert (task->erase.tool.label != (char *) NULL, "ERROR: tool fullpath is NULL\n");
 			command = cdw_string_concat(task->erase.tool.label,
 						    " -speed=", speed_string, " ",
@@ -69,8 +69,8 @@
 						    drive,
 						    (char *) NULL);
 		} else {
-			cdw_assert (0, "ERROR: task->erase.format_mode is incorrect: %lld\n",
-				    task->erase.format_mode);
+			cdw_assert (0, "ERROR: task->erase.dvd_rw_format_mode is incorrect: %lld\n",
+				    task->erase.dvd_rw_format_mode);
 		}
 
 	} else if (disc->type == CDW_DVD_RWP) {
@@ -99,7 +99,7 @@
 	cdw_processwin_display_sub_info(_("Preparing to erase. Please wait."));
 
 	cdw_sdm ("INFO: command is \"%s\"\n", command);
-	int rv = run_command(command, task);
+	int rv = cdw_thread_run_command(command, task);
 	free(command);
 	command = (char *) NULL;
 	if (rv != 0) {
@@ -117,4 +117,3 @@
 
 	return CDW_OK;
 }
-
diff -Naur orig/src/external_tools/cdw_dvd_rw_format_regex.c patched/src/external_tools/cdw_dvd_rw_format_regex.c
--- orig/src/external_tools/cdw_dvd_rw_format_regex.c	2012-02-26 15:26:50.000000000 +0100
+++ patched/src/external_tools/cdw_dvd_rw_format_regex.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdlib.h>
@@ -182,4 +182,3 @@
 
 	return;
 }
-
diff -Naur orig/src/external_tools/cdw_dvd_rw_mediainfo.c patched/src/external_tools/cdw_dvd_rw_mediainfo.c
--- orig/src/external_tools/cdw_dvd_rw_mediainfo.c	2012-02-26 15:29:53.000000000 +0100
+++ patched/src/external_tools/cdw_dvd_rw_mediainfo.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -22,7 +22,7 @@
 #include <stdlib.h>
 
 #include "gettext.h"
-#include "cdw_thread.h" /* run_command() */
+#include "cdw_thread.h" /* cdw_thread_run_command() */
 #include "cdw_config.h"
 #include "cdw_processwin.h"
 #include "cdw_widgets.h"
@@ -60,7 +60,7 @@
 
 	/* 2TRANS: this is message displayed in process window */
 	cdw_processwin_display_sub_info(_("Getting disc information"));
-	int rv = run_command(command, task);
+	int rv = cdw_thread_run_command(command, task);
 	free(command);
 	command = (char *) NULL;
 
@@ -177,4 +177,3 @@
 		return CDW_ERROR;
 	}
 }
-
diff -Naur orig/src/external_tools/cdw_dvd_rw_mediainfo_regex.c patched/src/external_tools/cdw_dvd_rw_mediainfo_regex.c
--- orig/src/external_tools/cdw_dvd_rw_mediainfo_regex.c	2012-02-19 22:08:00.000000000 +0100
+++ patched/src/external_tools/cdw_dvd_rw_mediainfo_regex.c	2014-02-28 22:37:41.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdlib.h>
@@ -382,7 +382,7 @@
 		thread_task->disc->type = CDW_DVD_ROM;
 
 	} else if (!strcmp(submatch, "DVD+R Double Layer")
-		   && global_config.support_dvd_rp_dl) {
+		   && global_config.general.support_dvd_rp_dl) {
 		thread_task->disc->type = CDW_DVD_RP_DL;
 
 	} else {
diff -Naur orig/src/external_tools/cdw_ext_tools.c patched/src/external_tools/cdw_ext_tools.c
--- orig/src/external_tools/cdw_ext_tools.c	2012-03-28 20:32:48.000000000 +0200
+++ patched/src/external_tools/cdw_ext_tools.c	2014-04-06 23:03:39.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _BSD_SOURCE /* strdup() */
@@ -85,6 +85,7 @@
 #define CDW_TOOL_DVD_RW_FORMAT_NAME      "dvd+rw-format"
 #define CDW_TOOL_DVD_RW_MEDIAINFO_NAME   "dvd+rw-mediainfo"
 #define CDW_TOOL_XORRISO_NAME            "xorriso"
+#define CDW_TOOL_MKUDFFS_NAME            "mkudffs"
 #define CDW_TOOL_MD5SUM_NAME             "md5sum"
 #define CDW_TOOL_SHA1SUM_NAME            "sha1sum"
 #define CDW_TOOL_SHA224SUM_NAME          "sha224sum"
@@ -92,6 +93,23 @@
 #define CDW_TOOL_SHA384SUM_NAME          "sha384sum"
 #define CDW_TOOL_SHA512SUM_NAME          "sha512sum"
 
+/* These 7 tools below are helpers for creating UDF image
+   (a.k.a. mkudffs helpers). They are used exclusively for creating
+   UDF image file.
+
+   I don't intend to make it possible to select instances of these
+   tools - when invoking them, I just use hardwired names. But I still
+   need to verify that they are available on user's system. The
+   verification will be performed just like for any other tool: with
+   cdw_which. */
+#define CDW_TOOL_TRUNCATE_NAME           "truncate"
+#define CDW_TOOL_SUDO_NAME               "sudo"
+#define CDW_TOOL_MOUNT_NAME              "mount"
+#define CDW_TOOL_UMOUNT_NAME             "umount"
+#define CDW_TOOL_SYNC_NAME               "sync"
+#define CDW_TOOL_RSYNC_NAME              "rsync"
+
+
 
 
 typedef struct {
@@ -156,6 +174,9 @@
 		   mkisofs + xorriso */
 		cdw_ext_tools_handler_config_t iso9660_handlers;
 
+		/* Tools for creating stand alone UDF file. */
+		cdw_ext_tools_handler_config_t udf_handlers;
+
 		/* cdrecord + xorriso */
 		cdw_ext_tools_handler_config_t cd_handlers;
 
@@ -185,6 +206,7 @@
 static void     cdw_ext_tools_build_cd_handlers(void);
 static void     cdw_ext_tools_build_dvd_handlers(void);
 static void     cdw_ext_tools_build_iso9660_handlers(void);
+static void     cdw_ext_tools_build_udf_handlers(void);
 static void     cdw_ext_tools_build_digest_handlers(void);
 static cdw_rv_t cdw_ext_tools_build_tool_config(cdw_id_t tool_id, cdw_ext_tools_tool_config_t *tool_config);
 static void     cdw_ext_tools_build_handlers(cdw_ext_tools_handler_config_t *handlers, cdw_id_clabel_t input_items[], int n_items_max);
@@ -249,6 +271,7 @@
 	cdw_ext_tools_build_cd_handlers();
 	cdw_ext_tools_build_dvd_handlers();
 	cdw_ext_tools_build_iso9660_handlers();
+	cdw_ext_tools_build_udf_handlers();
 	cdw_ext_tools_build_digest_handlers();
 
 	cdw_ext_tools_build_tool_config(CDW_TOOL_MKISOFS, &cdw_ext_tools.config.mkisofs);
@@ -298,6 +321,8 @@
 	cdw_ext_tools.config.cd_handlers.n_items = 0;
 	cdw_ext_tools.config.iso9660_handlers.current_ind = 0;
 	cdw_ext_tools.config.iso9660_handlers.n_items = 0;
+	cdw_ext_tools.config.udf_handlers.current_ind = 0;
+	cdw_ext_tools.config.udf_handlers.n_items = 0;
 	cdw_ext_tools.config.digest_handlers.current_ind = 0;
 	cdw_ext_tools.config.digest_handlers.n_items = 0;
 
@@ -308,6 +333,8 @@
 		cdw_ext_tools.config.cd_handlers.items[t].label = (char *) NULL;
 		cdw_ext_tools.config.iso9660_handlers.items[t].id = CDW_TOOL_NONE;
 		cdw_ext_tools.config.iso9660_handlers.items[t].label = (char *) NULL;
+		cdw_ext_tools.config.udf_handlers.items[t].id = CDW_TOOL_NONE;
+		cdw_ext_tools.config.udf_handlers.items[t].label = (char *) NULL;
 		cdw_ext_tools.config.digest_handlers.items[t].id = CDW_TOOL_NONE;
 		cdw_ext_tools.config.digest_handlers.items[t].label = (char *) NULL;
 	}
@@ -330,6 +357,8 @@
 	strcpy(cdw_ext_tools.tools[CDW_TOOL_DVD_RW_FORMAT].name,    CDW_TOOL_DVD_RW_FORMAT_NAME);
 	strcpy(cdw_ext_tools.tools[CDW_TOOL_DVD_RW_MEDIAINFO].name, CDW_TOOL_DVD_RW_MEDIAINFO_NAME);
 	strcpy(cdw_ext_tools.tools[CDW_TOOL_XORRISO].name,   CDW_TOOL_XORRISO_NAME);
+	strcpy(cdw_ext_tools.tools[CDW_TOOL_MKUDFFS].name,   CDW_TOOL_MKUDFFS_NAME);
+
 	strcpy(cdw_ext_tools.tools[CDW_TOOL_MD5SUM].name,    CDW_TOOL_MD5SUM_NAME);
 	strcpy(cdw_ext_tools.tools[CDW_TOOL_SHA1SUM].name,   CDW_TOOL_SHA1SUM_NAME);
 	strcpy(cdw_ext_tools.tools[CDW_TOOL_SHA224SUM].name, CDW_TOOL_SHA224SUM_NAME);
@@ -337,6 +366,13 @@
 	strcpy(cdw_ext_tools.tools[CDW_TOOL_SHA384SUM].name, CDW_TOOL_SHA384SUM_NAME);
 	strcpy(cdw_ext_tools.tools[CDW_TOOL_SHA512SUM].name, CDW_TOOL_SHA512SUM_NAME);
 
+	strcpy(cdw_ext_tools.tools[CDW_TOOL_TRUNCATE].name, CDW_TOOL_TRUNCATE_NAME);
+	strcpy(cdw_ext_tools.tools[CDW_TOOL_SUDO].name,     CDW_TOOL_SUDO_NAME);
+	strcpy(cdw_ext_tools.tools[CDW_TOOL_MOUNT].name,    CDW_TOOL_MOUNT_NAME);
+	strcpy(cdw_ext_tools.tools[CDW_TOOL_UMOUNT].name,   CDW_TOOL_UMOUNT_NAME);
+	strcpy(cdw_ext_tools.tools[CDW_TOOL_SYNC].name,     CDW_TOOL_SYNC_NAME);
+	strcpy(cdw_ext_tools.tools[CDW_TOOL_RSYNC].name,    CDW_TOOL_RSYNC_NAME);
+
 	return;
 }
 
@@ -359,6 +395,7 @@
 		   tools[t].name, that is available in paths specified in
 		   environment variable PATH */
 		cdw_dll_t *instances = (cdw_dll_t *) NULL;
+		cdw_vdm ("INFO: looking for tool #%d (%s)\n", t, cdw_ext_tools.tools[t].name);
 		if (!cdw_which(cdw_ext_tools.tools[t].name, &instances)) {
 			cdw_vdm ("WARNING: can't get instances table for tool \"%s\"\n",
 				 cdw_ext_tools.tools[t].name);
@@ -460,6 +497,24 @@
 	cdw_assert (cdw_ext_tools.config.iso9660_handlers.items[i].label != (char *) NULL, "ERROR: label #%d of ISO9660 handler is NULL\n", i);
 	cdw_vdm ("INFO: ISO9660 #%d label = \"%s\"\n", i, cdw_ext_tools.config.iso9660_handlers.items[i].label);
 
+
+	/* UDF handlers aren't mutually exclusive alternatives, they
+	   are a set of tools needed by "create UDF file" recipe. So
+	   don't list "current" tool, because "current" doesn't make
+	   sense in this context. List all tools from the recipe. */
+	for (int j = 0;
+	     j < cdw_ext_tools.config.udf_handlers.n_items;
+	     j++) {
+
+		/* Some tools needed by the recipe may be
+		   missing. Don't assert. */
+#if 0
+		cdw_assert (cdw_ext_tools.config.udf_handlers.items[j].label != (char *) NULL, "ERROR: label #%d of UDF handler is NULL\n", j);
+#endif
+		cdw_vdm ("INFO: UDF tool #%d label = \"%s\"\n", j, cdw_ext_tools.config.udf_handlers.items[j].label);
+	}
+
+
 	i = cdw_ext_tools.config.cd_handlers.current_ind;
 	cdw_assert (cdw_ext_tools.config.cd_handlers.items[i].label != (char *) NULL, "ERROR: label #%d of CD handler is NULL\n", i);
 	cdw_vdm ("INFO: CD handler #%d label = \"%s\"\n", i, cdw_ext_tools.config.cd_handlers.items[i].label);
@@ -662,7 +717,7 @@
 */
 bool cdw_ext_tools_is_tool_available(cdw_id_t tool_id)
 {
-	cdw_assert (tool_id >= CDW_TOOL_MKISOFS && tool_id <= CDW_TOOL_SHA512SUM,
+	cdw_assert (tool_id >= CDW_TOOL_MKISOFS && tool_id <= CDW_TOOL_RSYNC,
 		    "ERROR: incorrect tool id: %lld\n", tool_id);
 
 	return cdw_ext_tools.tools[tool_id].available;
@@ -859,6 +914,32 @@
 
 
 
+void cdw_ext_tools_build_udf_handlers(void)
+{
+	/* For now the list includes only a tool that directly handles
+	   UDF file system, although a full recipe for creating UDF
+	   file perhaps includes few more tools.
+
+	   Perhaps the tools should be counted as "UDF handlers" as well.
+
+	   For now I don't intend to support any UDF creators other
+	   than mkudffs, so I won't have to include them in the list
+	   below. So the list may be "a list of all tools needed in
+	   all steps of recipe for creating UDF file" - udf_recipe_tools. */
+
+	/* For now let's just put here the mkudffs, I will add rest of
+	   tools later. */
+
+	cdw_id_clabel_t tool_ids[] = {{ CDW_TOOL_MKUDFFS, CDW_TOOL_MKUDFFS_NAME }};
+	cdw_ext_tools_build_handlers(&(cdw_ext_tools.config.udf_handlers), tool_ids, 1);
+
+	return;
+}
+
+
+
+
+
 const char *clabel_dvd_rw_tools_mkisofs = "dvd+rw-tools (+ mkisofs)";
 const char *clabel_dvd_rw_tools = "dvd+rw-tools";
 
@@ -908,6 +989,41 @@
 
 
 
+bool cdw_ext_tools_iso9660_sa_tool_available(void)
+{
+	if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)
+	    || cdw_ext_tools_is_tool_available(CDW_TOOL_XORRISO)) {
+
+		return true;
+	} else {
+		return false;
+	}
+}
+
+
+
+
+
+bool cdw_ext_tools_udf_sa_tools_tools_available(void)
+{
+	if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKUDFFS)
+	    && cdw_ext_tools_is_tool_available(CDW_TOOL_TRUNCATE)
+	    && cdw_ext_tools_is_tool_available(CDW_TOOL_SUDO)
+	    && cdw_ext_tools_is_tool_available(CDW_TOOL_MOUNT)
+	    && cdw_ext_tools_is_tool_available(CDW_TOOL_UMOUNT)
+	    && cdw_ext_tools_is_tool_available(CDW_TOOL_SYNC)
+	    && cdw_ext_tools_is_tool_available(CDW_TOOL_RSYNC)) {
+
+		return true;
+	} else {
+		return false;
+	}
+}
+
+
+
+
+
 bool cdw_ext_tools_config_is_manual(void)
 {
 	return cdw_ext_tools.config.manual_selection;
@@ -1146,6 +1262,10 @@
 		cdw_ext_tools.config.cd_handlers.current_ind = cdw_dropdown_get_current_item_ind(etc->cd_handlers);
 		cdw_ext_tools.config.dvd_handlers.current_ind = cdw_dropdown_get_current_item_ind(etc->dvd_handlers);
 		cdw_ext_tools.config.iso9660_handlers.current_ind = cdw_dropdown_get_current_item_ind(etc->iso9660);
+
+		/* Is this necessary? The list is not presented in UI, so it won't be changed by user. */
+		cdw_ext_tools.config.udf_handlers.current_ind = cdw_dropdown_get_current_item_ind(etc->udf);
+
 		cdw_ext_tools.config.digest_handlers.current_ind = cdw_dropdown_get_current_item_ind(etc->digest_handlers);
 
 		cdw_ext_tools.config.mkisofs.current_ind = cdw_dropdown_get_current_item_ind(etc->mkisofs);
@@ -1590,6 +1710,7 @@
 
 
 
+/* _sa_ = stand alone */
 bool cdw_ext_tools_set_iso9660_sa_tool(cdw_id_label_t *tool)
 {
 	int impl_ind = 0;
@@ -1600,6 +1721,7 @@
 			return false;
 		}
 		impl_ind = cdw_ext_tools_get_manual_selection_ind(tool->id);
+		cdw_vdm ("INFO: manual selection, tool id = %lld\n", tool->id);
 	} else {
 		if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)) {
 			tool->id = CDW_TOOL_MKISOFS;
@@ -1609,6 +1731,7 @@
 			return false;
 		}
 		impl_ind = CDW_EXT_TOOLS_SYSTEM_DEFAULT_INSTANCE_IND;
+		cdw_vdm ("INFO: auto selection, tool id = %lld, impl ind = %d\n", tool->id, impl_ind);
 	}
 
 	cdw_assert (cdw_ext_tools_is_tool_available(tool->id), "ERROR: tool was in dd, but is not available\n");
@@ -1617,6 +1740,7 @@
 		cdw_vdm ("ERROR: fullpath #%d to ISO9660 tool %lld is NULL\n", impl_ind, tool->id);
 		return false;
 	} else {
+		cdw_vdm ("INFO: selected tool %lld / %s\n", tool->id, tool->label);
 		return true;
 	}
 }
@@ -1625,6 +1749,32 @@
 
 
 
+bool cdw_ext_tools_set_udf_sa_tool(cdw_id_label_t *tool)
+{
+	if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKUDFFS)) {
+		tool->id = CDW_TOOL_MKUDFFS;
+	} else {
+		return false;
+	}
+
+	int impl_ind = CDW_EXT_TOOLS_SYSTEM_DEFAULT_INSTANCE_IND;
+	cdw_assert (cdw_ext_tools_is_tool_available(tool->id), "ERROR: tool was in dd, but is not available\n");
+	tool->label = cdw_ext_tools.tools[tool->id].instances[impl_ind];
+	if (!tool->label) {
+		cdw_vdm ("ERROR: fullpath #%d to UDF tool %lld is NULL\n", impl_ind, tool->id);
+		return false;
+	} else {
+		cdw_vdm ("INFO: selected tool %lld / %s\n", tool->id, tool->label);
+		return true;
+	}
+}
+
+
+
+
+
+
+
 bool cdw_ext_tools_set_erase_tool(cdw_disc_t *disc, cdw_id_label_t *tool)
 {
 	int impl_ind = 0;
@@ -1745,42 +1895,23 @@
 
 
 
-/* unused code below */
-
-#if 0
 
-
-
-/* for now it only works for growisofs */
-cdw_rv_t cdw_ext_tools_check_versions(void)
+/**
+   Simple getter, since struct cdw_ext_tools is local in this file.
+*/
+int cdw_ext_tools_get_n_iso9660_handlers(void)
 {
-	int i = 0;
-	char *fullpath = cdw_ext_tools.tools[CDW_TOOL_GROWISOFS].instances[i];
+	return cdw_ext_tools.config.iso9660_handlers.n_items;
+}
 
-	while (fullpath != (char *) NULL) {
-		char *command = cdw_string_concat(fullpath, " --version", (char *) NULL);
-		if (command == (char *) NULL) {
-			cdw_vdm ("ERROR: failed to create command for fullpath \"%s\"\n", fullpath);
-			return CDW_ERROR;
-		} else {
-			/* need the task only for pipe regexp dispatcher,
-			   and the dispatcher checks for some specific fields,
-			   which we have to set here */
-			cdw_task_t task;
-			task.burn.tool.id = CDW_TOOL_GROWISOFS;
-			task.id = CDW_TASK_BURN_FROM_IMAGE;
-
-			run_command(command, &task);
-			free(command);
-			command = (char *) NULL;
 
-			i++;
-			fullpath = cdw_ext_tools.tools[CDW_TOOL_GROWISOFS].instances[i];
-		}
-	}
 
-	return CDW_OK;
-}
 
-#endif
 
+/**
+   Simple getter, since struct cdw_ext_tools is local in this file.
+*/
+int cdw_ext_tools_get_n_udf_handlers(void)
+{
+	return cdw_ext_tools.config.udf_handlers.n_items;
+}
diff -Naur orig/src/external_tools/cdw_ext_tools.h patched/src/external_tools/cdw_ext_tools.h
--- orig/src/external_tools/cdw_ext_tools.h	2011-05-18 19:09:05.000000000 +0200
+++ patched/src/external_tools/cdw_ext_tools.h	2014-02-12 22:58:29.000000000 +0100
@@ -25,6 +25,8 @@
 
 	CDW_TOOL_XORRISO,
 
+	CDW_TOOL_MKUDFFS,
+
 	CDW_TOOL_MD5SUM,
 	CDW_TOOL_SHA1SUM,
 	CDW_TOOL_SHA224SUM,
@@ -32,20 +34,33 @@
 	CDW_TOOL_SHA384SUM,
 	CDW_TOOL_SHA512SUM,
 
+	CDW_TOOL_TRUNCATE,
+	CDW_TOOL_SUDO,
+	CDW_TOOL_MOUNT,
+	CDW_TOOL_UMOUNT,
+	CDW_TOOL_SYNC,
+	CDW_TOOL_RSYNC,
+
+
 	CDW_TOOL_LIBCDIO
 }; /** \brief Tool used to perform given task */
 
 #define CDW_EXT_TOOLS_N_DIGEST_TOOLS 6 /* md5sum, sha1sum, sha224sum, sha256sum, sha384, sha512sum */
 
 
-/* twelve external tools available:
+
+
+/* There are 19 external tools that cdw will look for with "which":
    cdrecord, mkisofs,
-   growisofs, dvd-rw+mediainfo, dvd-rw+format, xorriso,
-   md5sum, sha1sum, sha224sum, sha256sum, sha384, sha512sum;
+   growisofs, dvd-rw+mediainfo, dvd-rw+format,
+   xorriso,
+   mkudffs,
+   md5sum, sha1sum, sha224sum, sha256sum, sha384, sha512sum,
+   truncate, sudo, mount, umount, sync, rsync;
 
    I'm not including "libcdio", because this is a library (although
-   I should check for it somehow)  */
-#define CDW_EXT_TOOLS_N_TOOLS 12
+   I should check for it somehow). */
+#define CDW_EXT_TOOLS_N_TOOLS 19
 
 
 /* maximal number of instances of a tool (locations in filesystem), that can
@@ -66,13 +81,26 @@
 cdw_id_t cdw_ext_tools_config_get_cd_handler_id(void);
 cdw_id_t cdw_ext_tools_config_get_dvd_handler_id(void);
 cdw_id_t cdw_ext_tools_config_get_iso9660_id(void);
+
+/* For asking about some very specific details. */
 bool cdw_ext_tools_config_is_manual(void);
 bool cdw_ext_tools_is_cdrecord_wodim(void);
-bool cdw_ext_tools_digest_tool_available(void);
+
+/* Check if specific subset of tools is available, or - to put it
+   differently - if tools detected by cdw allow performing some
+   specific task. */
+bool cdw_ext_tools_digest_tool_available(void);           /* Any tool needed to calculate digest of a file (md5, sha). */
+bool cdw_ext_tools_iso9660_sa_tool_available(void);       /* Any tool capable of creating from A to Z a stand-alone (sa) ISO9660 image file. */
+bool cdw_ext_tools_udf_sa_tools_tools_available(void);    /* A complete toolset needed to create from A to Z a stand-alone (sa) UDF image file. */
+
+
+int cdw_ext_tools_get_n_iso9660_handlers(void);
+int cdw_ext_tools_get_n_udf_handlers(void);
 
 typedef struct {
 	bool manual_selection;
 	CDW_DROPDOWN *iso9660;
+	CDW_DROPDOWN *udf; /* FIXME: there is no UDF dropdown in configuration window. I'm including this for now, but probably should be removed. */
 	CDW_DROPDOWN *cd_handlers;
 	CDW_DROPDOWN *dvd_handlers;
 	CDW_DROPDOWN *mkisofs;
@@ -86,6 +114,7 @@
 bool cdw_ext_tools_set_digest_tool(cdw_id_label_t *tool);
 bool cdw_ext_tools_set_iso9660_otf_tool(cdw_disc_t *disc, cdw_id_label_t *tool);
 bool cdw_ext_tools_set_iso9660_sa_tool(cdw_id_label_t *tool);
+bool cdw_ext_tools_set_udf_sa_tool(cdw_id_label_t *tool);
 bool cdw_ext_tools_set_erase_tool(cdw_disc_t *disc, cdw_id_label_t *tool);
 bool cdw_ext_tools_set_media_info_tool(cdw_disc_t *disc, cdw_id_label_t *tool);
 
diff -Naur orig/src/external_tools/cdw_growisofs.c patched/src/external_tools/cdw_growisofs.c
--- orig/src/external_tools/cdw_growisofs.c	2012-02-26 15:27:24.000000000 +0100
+++ patched/src/external_tools/cdw_growisofs.c	2014-03-10 20:41:39.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,12 +14,12 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
    \file growisofs_interface.c
-   \brief Interface to growisofs: building command line calls and calling run_command() to run them
+   \brief Interface to growisofs: building command line calls and calling cdw_thread_run_command() to run them
 
    Fragments from man page:
 
@@ -255,7 +255,7 @@
    \brief Call growisofs to write iso image file to DVD disc
 
    Call one function to create command line string, and then call
-   run_command() to execute this string in shell. Create processwin to
+   cdw_thread_run_command() to execute this string in shell. Create processwin to
    show some progress to the user. Finish with some meaningful message
    displayed in processwin.
 
@@ -277,7 +277,7 @@
 	   preparation to writing, but the writing hasn't started yet */
 	cdw_processwin_display_sub_info(_("Preparing to write. Please wait."));
 
-	int rv = run_command(command, task);
+	int rv = cdw_thread_run_command(command, task);
 
 	free(command);
 	command = (char *) NULL;
@@ -297,7 +297,7 @@
    \brief Call growisofs to write selected files to DVD disc
 
    Call one function to create command line string, and then call
-   run_command() to execute this string in shell. Create processwin to
+   cdw_thread_run_command() to execute this string in shell. Create processwin to
    show some progress to the user. Finish with some meaningful message
    displayed in processwin.
 
@@ -319,7 +319,7 @@
 	   preparation to writing, but the writing hasn't started yet */
 	cdw_processwin_display_sub_info(_("Preparing to write. Please wait."));
 
-	int rv = run_command(command, task);
+	int rv = cdw_thread_run_command(command, task);
 
 	free(command);
 	command = (char *) NULL;
@@ -401,14 +401,14 @@
 				     " -speed=", speed_string, " ",
 				     dao ? " -use-the-force-luke=dao " : " ",
 				     task->burn.dummy ? " -use-the-force-luke=dummy " : " ",
-				     " ", task->burn.growisofs.other_growisofs_options, " ",
+				     " ", task->burn.growisofs_other_options, " ",
 
 				     dvd_compat ? " -dvd-compat " : " ",
 
 				     " -Z ",
 				     /* path to ISO file may contain spaces, so
 					surround the path with quotes */
-				     drive, "=", "\"", task->burn.iso9660_file_fullpath, "\"",
+				     drive, "=", "\"", task->image_file_fullpath, "\"",
 
 				     (char *) NULL);
 
@@ -578,7 +578,7 @@
 					  task->burn.dummy ? " -use-the-force-luke=dummy " : " ",
 					  " -use-the-force-luke=moi ",
 
-					  " ", task->burn.growisofs.other_growisofs_options, " ",
+					  " ", task->burn.growisofs_other_options, " ",
 
 					  dvd_compat ? " -dvd-compat " : " ",
 
@@ -707,7 +707,7 @@
 	   preparation to erasing, but the erasing hasn't started yet */
 	cdw_processwin_display_sub_info(_("Preparing to erase. Please wait."));
 
-	int rv = run_command(command, task);
+	int rv = cdw_thread_run_command(command, task);
 
 	free(command);
 	command = (char *) NULL;
@@ -728,4 +728,3 @@
 
 
 #endif
-
diff -Naur orig/src/external_tools/cdw_growisofs_options.c patched/src/external_tools/cdw_growisofs_options.c
--- orig/src/external_tools/cdw_growisofs_options.c	2012-02-26 15:29:40.000000000 +0100
+++ patched/src/external_tools/cdw_growisofs_options.c	2014-03-12 22:04:42.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -52,20 +52,21 @@
 	cdw_form->fields = page_growisofs_fields;
 
 	cdw_form_descr_t descr[] = {
-		/*     type       begin_y  begin_x   n_cols     n_lines  field enum            data1                                       data2 */
+		/* type                      begin_y   begin_x     n_cols    n_lines   field enum            data1                                       data2 */
 
 		/* 2TRANS: this is a label for input field: "Other options passed to growisofs */
-		{ CDW_WIDGET_LABEL,  1,  first_col,  width_wide,     1,  f_growisofs_other_l,  _("Other growisofs options:"),                 0 },
-		{ CDW_WIDGET_INPUT,  2,  first_col,  width_wide - 3, 1,  f_growisofs_other_i,  task->burn.growisofs.other_growisofs_options,  0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     1,  first_col,  width_wide,     1,  f_growisofs_other_l,  _("Other growisofs options:"),                 0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   2,  first_col,  width_wide - 3, 1,  f_growisofs_other_i,  task->burn.growisofs_other_options,            0 },
 
 		/* guard */
-		{ -1,                0,  0,          0,              0,  0,                   (void *) NULL,                                  0 }};
+		{ -1,                              0,  0,          0,              0,  0,                    (void *) NULL,                                 0 }};
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
+		cdw_form_bind_input_and_label(cdw_form, f_growisofs_other_i, f_growisofs_other_l);
 		return CDW_OK;
 	}
 }
@@ -74,10 +75,9 @@
 
 
 
-cdw_rv_t cdw_growisofs_options_validate(cdw_form_t *cdw_form, int *fi)
+cdw_rv_t cdw_growisofs_options_validate(cdw_task_t *task, int *fi)
 {
-	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_growisofs_other_i));
-	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	cdw_rv_t crv = cdw_string_security_parser(task->burn.growisofs_other_options, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_growisofs_other_i;
 		return CDW_NO;
@@ -92,8 +92,7 @@
 
 cdw_rv_t cdw_growisofs_options_save(cdw_form_t *cdw_form, cdw_task_t *task)
 {
-	cdw_string_set(&(task->burn.growisofs.other_growisofs_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_growisofs_other_i)));
+	cdw_string_set(&(task->burn.growisofs_other_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_growisofs_other_i)));
 
 	return CDW_OK;
 }
-
diff -Naur orig/src/external_tools/cdw_growisofs_options.h patched/src/external_tools/cdw_growisofs_options.h
--- orig/src/external_tools/cdw_growisofs_options.h	2011-03-14 20:43:04.000000000 +0100
+++ patched/src/external_tools/cdw_growisofs_options.h	2014-03-10 20:16:22.000000000 +0100
@@ -9,7 +9,7 @@
 
 
 cdw_rv_t cdw_growisofs_options_form(cdw_form_t *cdw_form, void *task, int first_col, int second_col, int width_wide, int width_narrow);
-cdw_rv_t cdw_growisofs_options_validate(cdw_form_t *cdw_form, int *fi);
+cdw_rv_t cdw_growisofs_options_validate(cdw_task_t *task, int *fi);
 cdw_rv_t cdw_growisofs_options_save(cdw_form_t *cdw_form, cdw_task_t *task);
 
 
diff -Naur orig/src/external_tools/cdw_growisofs_regex.c patched/src/external_tools/cdw_growisofs_regex.c
--- orig/src/external_tools/cdw_growisofs_regex.c	2012-02-26 15:27:58.000000000 +0100
+++ patched/src/external_tools/cdw_growisofs_regex.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
diff -Naur orig/src/external_tools/cdw_libburn.c patched/src/external_tools/cdw_libburn.c
--- orig/src/external_tools/cdw_libburn.c	2012-02-26 15:28:11.000000000 +0100
+++ patched/src/external_tools/cdw_libburn.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <libburn/libburn.h>
@@ -158,5 +158,3 @@
 
 	return CDW_OK;
 }
-
-
diff -Naur orig/src/external_tools/cdw_mkisofs.c patched/src/external_tools/cdw_mkisofs.c
--- orig/src/external_tools/cdw_mkisofs.c	2012-03-25 18:44:37.000000000 +0200
+++ patched/src/external_tools/cdw_mkisofs.c	2014-04-12 20:24:54.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,16 +14,16 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
-   \file mkisofs_interface.c
+   \file cdw_mkisofs.c
 
    \brief Functions creating calls to mkisofs and calling mkisofs
 
    Functions for creating mkisofs command line strings, creating string
-   with cdrecord parameters, and for calling run_command()
+   with cdrecord parameters, and for calling cdw_thread_run_command()
    with prepared command line string.
 */
 
@@ -96,12 +96,12 @@
 */
 char *cdw_mkisofs_create_command(cdw_task_t *task, cdw_disc_t *disc)
 {
-	cdw_assert (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_CREATE_IMAGE,
-		    "ERROR: incorrect task id that is neither CDW_TASK_BURN_FROM_FILES nor CDW_TASK_CREATE_IMAGE: %lld\n", task->id);
-	cdw_assert (task->create_image.rock_ridge == CDW_ISO9660_RR_NONE
-		    || task->create_image.rock_ridge == CDW_ISO9660_RR_USEFUL
-		    || task->create_image.rock_ridge == CDW_ISO9660_RR_FULL,
-		    "ERROR: Rock Ridge value out of range: %lld\n", task->create_image.rock_ridge);
+	cdw_assert (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_CREATE_IMAGE_ISO9660,
+		    "ERROR: incorrect task id that is neither CDW_TASK_BURN_FROM_FILES nor CDW_TASK_CREATE_IMAGE_ISO9660: %lld\n", task->id);
+	cdw_assert (task->create_image.iso9660.rock_ridge == CDW_ISO9660_RR_NONE
+		    || task->create_image.iso9660.rock_ridge == CDW_ISO9660_RR_USEFUL
+		    || task->create_image.iso9660.rock_ridge == CDW_ISO9660_RR_FULL,
+		    "ERROR: Rock Ridge value out of range: %lld\n", task->create_image.iso9660.rock_ridge);
 
 	bool include_mkisofs = false;
 	bool write_to_stdout = false;
@@ -132,7 +132,7 @@
 			append_multi = false;
 		}
 
-	} else { /* task->id == CDW_TASK_CREATE_IMAGE */
+	} else { /* task->id == CDW_TASK_CREATE_IMAGE_ISO9660 */
 		cdw_assert (task->create_image.tool.id == CDW_TOOL_MKISOFS,
 			    "ERROR: incorrect tool id in \"create image\" task: %lld\n", task->create_image.tool.id);
 		/* command for creating ISO image only - obviously mkisofs
@@ -175,7 +175,7 @@
 	   number of characters (e.g. 1) */
 	size_t iso_len_max = strlen(" -iso-level X ");
 	char iso_level_string[iso_len_max + 1];
-	int sn = snprintf(iso_level_string, iso_len_max + 1, " -iso-level %lld ", task->create_image.mkisofs.iso_level);
+	int sn = snprintf(iso_level_string, iso_len_max + 1, " -iso-level %lld ", task->create_image.iso9660.iso_level);
 	cdw_vdm ("INFO: iso level string = \"%s\", %d bytes written, %zd chars in string / %zd chars limit\n",
 		 iso_level_string, sn, strlen(iso_level_string), iso_len_max);
 
@@ -193,16 +193,17 @@
 
 	char *meta_information = cdw_mkisofs_create_meta_information_string(task);
 
-	bool has_root_dir = !cdw_string_is_all_spaces(task->create_image.mkisofs.root_dir);
+	/* FIXME: this is the most stupid function in whole code base. */
+	bool has_root_dir = !cdw_string_is_all_spaces(task->create_image.iso9660.root_dir);
 
 	char *command = cdw_string_concat(
 
 			include_mkisofs ? tool_fullpath : " ",
 			iso_level_string, /* surrounded by spaces */
-			task->create_image.joliet_information ? " -J " : " ",
-			rock_ridge[task->create_image.rock_ridge],
-			task->create_image.mkisofs.joliet_long ? " -joliet-long " : " ",
-			task->create_image.follow_symlinks ? " -f " : " ",
+			task->create_image.iso9660.joliet_information ? " -J " : " ",
+			rock_ridge[task->create_image.iso9660.rock_ridge],
+			task->create_image.iso9660.joliet_long ? " -joliet-long " : " ",
+			task->create_image.iso9660.follow_symlinks ? " -f " : " ",
 
 			append_multi ? multi_string : " ",
 
@@ -210,10 +211,10 @@
 
 			/* options entered by user in Configuration window
 			   in 'Other mkisofs options' field */
-			" ", task->create_image.mkisofs.other_mkisofs_options, " ",
+			" ", task->create_image.iso9660.mkisofs_other_options, " ",
 
 			has_root_dir ? " -root \"" : "",
-			has_root_dir ? task->create_image.mkisofs.root_dir : "",
+			has_root_dir ? task->create_image.iso9660.root_dir : "",
 			has_root_dir ? "\" " : "",
 
 			/* 'graft points' means text file with
@@ -226,7 +227,7 @@
 			write_to_stdout ? " " : " -o ",
 			/* put file name in quotes, because the name may contain spaces */
 			write_to_stdout ? " " : "\"",
-			write_to_stdout ? " " : task->create_image.iso9660_file_fullpath,
+			write_to_stdout ? " " : task->image_file_fullpath,
 			write_to_stdout ? " " : "\"",
 
 			/* NULL is obligatory last concat() argument */
@@ -269,12 +270,12 @@
    \param disc - variable describing current disc
 
    \return CDW_OK when iso file is created
-   \return CDW_GEN_ERROR if operation_failed
+   \return CDW_ERROR if operation_failed
 */
 cdw_rv_t cdw_mkisofs_run_task(cdw_task_t *task, cdw_disc_t *disc)
 {
-	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE,
-		    "ERROR: incorrect task id is not CDW_TASK_CREATE_IMAGE: %lld\n", task->id);
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_ISO9660,
+		    "ERROR: incorrect task id is not CDW_TASK_CREATE_IMAGE_ISO9660: %lld\n", task->id);
 	cdw_assert (task->create_image.tool.id == CDW_TOOL_MKISOFS,
 		    "ERROR: incorrect tool id is not CDW_TOOL_MKISOFS in \"create image\" task: %lld\n", task->create_image.tool.id);
 
@@ -284,7 +285,7 @@
 		return CDW_ERROR;
 	} else {
 		cdw_sdm ("INFO: created command string \"%s\"\n", command);
-		int rv = run_command(command, task);
+		int rv = cdw_thread_run_command(command, task);
 		free(command);
 		command = (char *) NULL;
 
@@ -385,61 +386,46 @@
 
 char *cdw_mkisofs_create_meta_information_string(cdw_task_t *task)
 {
-	/* there will always be a volume ID, either from
-	   config file, or from wizard's form field */
-	size_t volume_id = strlen(task->create_image.volume_id);
-
-	size_t preparer = 0;
-	size_t publisher = 0;
-	size_t system_id = 0;
-	size_t copyright = 0;
-	size_t volume_set_id = 0;
-	size_t abstract = 0;
-
-	if (task->id == CDW_TASK_BURN_FROM_FILES) {
-		/* this is to avoid adding (possibly outdated/invalid) meta
-		   information; the information may come from previous
-		   'create image' task, but now it may be invalid for
-		   purposes of 'burn from files' task;
-		   TODO: this should be fixed by adding 'meta' tab to
-		   configuration panel in write wizard */
-		;
-	} else {
-		preparer = strlen(task->create_image.preparer);
-		publisher = strlen(task->create_image.publisher);
-		system_id = strlen(task->create_image.system_id);
-		copyright = strlen(task->create_image.copyright);
-		volume_set_id = strlen(task->create_image.volume_set_id);
-		abstract = strlen(task->create_image.abstract);
-	}
+	/* This data can be edited in main window of "burn from files"
+	   wizard or "crate image" wizard. */
+	size_t volume_id = strlen(task->create_image.iso9660.volume_id);
+
+	/* This data can be edited in "meta data" page of "Options
+	   window" in "create image" or "burn from files" wizard. */
+	size_t preparer      = strlen(task->create_image.iso9660.preparer);
+	size_t publisher     = strlen(task->create_image.iso9660.publisher);
+	size_t system_id     = strlen(task->create_image.iso9660.system_id);
+	size_t copyright     = strlen(task->create_image.iso9660.copyright);
+	size_t volume_set_id = strlen(task->create_image.iso9660.volume_set_id);
+	size_t abstract      = strlen(task->create_image.iso9660.abstract);
 
 	char *s = cdw_string_concat(" ",
 				    volume_id ? " -V \"" : "",
-				    volume_id ? task->create_image.volume_id : "",
+				    volume_id ? task->create_image.iso9660.volume_id : "",
 				    volume_id ? "\" " : "",
 
 				    preparer ? " -p \"" : "",
-				    preparer ? task->create_image.preparer : "",
+				    preparer ? task->create_image.iso9660.preparer : "",
 				    preparer ? "\" " : "",
 
 				    publisher ? " -publisher \"" : " ",
-				    publisher ? task->create_image.publisher : "",
+				    publisher ? task->create_image.iso9660.publisher : "",
 				    publisher ? "\" " : "",
 
 				    system_id ? " -sysid \"" : "",
-				    system_id ? task->create_image.system_id : "",
+				    system_id ? task->create_image.iso9660.system_id : "",
 				    system_id ? "\" " : "",
 
 				    copyright ? " -copyright \"" : "",
-				    copyright ? task->create_image.copyright : "",
+				    copyright ? task->create_image.iso9660.copyright : "",
 				    copyright ? "\" " : "",
 
 				    volume_set_id ? " -volset \"" : "",
-				    volume_set_id ? task->create_image.volume_set_id : "",
+				    volume_set_id ? task->create_image.iso9660.volume_set_id : "",
 				    volume_set_id ? "\" " : "",
 
 				    abstract ? " -abstract \"" : "",
-				    abstract ? task->create_image.abstract : "",
+				    abstract ? task->create_image.iso9660.abstract : "",
 				    abstract ? "\" " : "",
 
 				    " ", (char *) NULL);
diff -Naur orig/src/external_tools/cdw_mkisofs_options.c patched/src/external_tools/cdw_mkisofs_options.c
--- orig/src/external_tools/cdw_mkisofs_options.c	2012-03-30 22:16:38.000000000 +0200
+++ patched/src/external_tools/cdw_mkisofs_options.c	2014-04-12 20:24:54.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,27 +14,26 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
 #include <stdio.h>
 #include <string.h>
 
-#include "cdw_task.h"
 #include "gettext.h"
 #include "cdw_string.h"
 #include "cdw_widgets.h"
 #include "cdw_debug.h"
 #include "cdw_mkisofs_options.h"
-#include "cdw_iso9660.h"
 
 
-static cdw_task_t *local_task = (cdw_task_t *) NULL;
 
+static cdw_iso9660_t *local_iso = (cdw_iso9660_t *) NULL;
 
 
-static FIELD *page_mkisofs_fields[CDW_MKISOFS_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
+
+static FIELD *page_mkisofs_fields[CDW_MKISOFS_ISO_MAIN_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
 
 static CDW_DROPDOWN *cdw_mkisofs_options_make_rock_ridge_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
 static CDW_DROPDOWN *cdw_mkisofs_options_make_iso_level_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
@@ -65,56 +64,60 @@
 
 
 
-cdw_rv_t cdw_mkisofs_options_form(cdw_form_t *cdw_form, void *cdw_task, int first_col, int second_col, int width_wide, int width_narrow)
+cdw_rv_t cdw_mkisofs_options_form(cdw_form_t *cdw_form, void *cdw_iso, int first_col, int second_col, int width_wide, int width_narrow)
 {
-	cdw_task_t *task = (cdw_task_t *) cdw_task;
-	local_task = task;
+	cdw_iso9660_t *iso = (cdw_iso9660_t *) cdw_iso;
+	local_iso = iso;
 	cdw_form->fields = page_mkisofs_fields;
+	second_col += 5;
+	width_narrow += 5;
 
 	int rr_width = 15;
 	cdw_form_descr_t descr[] = {
-		/*     type      begin_y   begin_x      n_cols    n_lines   field enum                    data1                                          data2 */
+		/* type                      begin_y   begin_x          n_cols    n_lines   field enum                    data1                                          data2 */
 
 		/* 2TRANS: this is checkbox label; use Joliet extensions to ISO9660 (add Joliet information to ISO file system) */
-		{ CDW_WIDGET_LABEL,    1,  first_col,   width_narrow,   1,  f_mkisofs_joliet_l,           _("Joliet information"),                           0 },
-		{ CDW_WIDGET_CHECKBOX, 1,  second_col,  0,              0,  f_mkisofs_joliet_cb,          (void *) NULL,  task->create_image.joliet_information ? 1 : 0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      1,  first_col,       width_narrow,   1,  f_mkisofs_joliet_l,           _("Joliet information"),                           0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          1,  second_col,      0,              0,  f_mkisofs_joliet_cb,          (void *) NULL,       iso->joliet_information ? 1 : 0 },
 
 		/* 2TRANS: this is checkbox label; specify Rock Ridge extensions to ISO9660 (add Rock Ridge information to ISO file system) */
-		{ CDW_WIDGET_LABEL,    2,  first_col,   width_narrow,   1,  f_mkisofs_rock_ridge_l,       _("Rock Ridge information"),                       0 },
-		{ CDW_WIDGET_DROPDOWN, 2,  second_col,  rr_width,       1,  f_mkisofs_rock_ridge_dd,      dropdown_makers,                                   0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      2,  first_col,       width_narrow,   1,  f_mkisofs_rock_ridge_l,       _("Rock Ridge information"),                       0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          2,  second_col - 1,  rr_width,       1,  f_mkisofs_rock_ridge_dd,      dropdown_makers,                                   0 },
 
 		/* 2TRANS: this is checkbox label; when traversing file system, follow UNIX symbolic links */
-		{ CDW_WIDGET_LABEL,    3,  first_col,   width_narrow,   1,  f_mkisofs_follow_symlinks_l,  _("Follow added symbolic links"),                  0 },
-		{ CDW_WIDGET_CHECKBOX, 3,  second_col,  0,              0,  f_mkisofs_follow_symlinks_cb, (void *) NULL,     task->create_image.follow_symlinks ? 1 : 0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      3,  first_col,       width_narrow,   1,  f_mkisofs_follow_symlinks_l,  _("Follow added symbolic links (-l)"),             0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          3,  second_col,      0,              0,  f_mkisofs_follow_symlinks_cb, (void *) NULL,          iso->follow_symlinks ? 1 : 0 },
 
 		/* 2TRANS: this is a label next to dropdown list; select ISO9660 level from the dropdown */
-		{ CDW_WIDGET_LABEL,    4,  first_col,   width_narrow,   1,  f_mkisofs_iso_level_l,        _("ISO level"),                                    0 },
-		{ CDW_WIDGET_DROPDOWN, 4,  second_col,  rr_width,       1,  f_mkisofs_iso_level_dd,       dropdown_makers,                                   1 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      4,  first_col,       width_narrow,   1,  f_mkisofs_iso_level_l,        _("ISO level"),                                    0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          4,  second_col - 1,  rr_width,       1,  f_mkisofs_iso_level_dd,       dropdown_makers,                                   1 },
 
 		/* 2TRANS: this is a checkbox label; allow long file names in ISO9660 file system; "Joliet" is an extension to ISO9660 standard */
-		{ CDW_WIDGET_LABEL,    5,  first_col,   width_narrow,   1,  f_mkisofs_joliet_long_l,      _("Long Joliet file names"),                       0 },
-		{ CDW_WIDGET_CHECKBOX, 5,  second_col,  1,              1,  f_mkisofs_joliet_long_cb,     (void *) NULL, task->create_image.mkisofs.joliet_long ? 1 : 0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      5,  first_col,       width_narrow,   1,  f_mkisofs_joliet_long_l,      _("Long Joliet file names"),                       0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          5,  second_col,      1,              1,  f_mkisofs_joliet_long_cb,     (void *) NULL,              iso->joliet_long ? 1 : 0 },
 
 		/* 2TRANS: this is a checkbox label; add additional bytes after proper data payload */
-		{ CDW_WIDGET_LABEL,    6,  first_col,   width_narrow,   1,  f_mkisofs_pad_l,              _("Pad at the end"),                               0 },
-		{ CDW_WIDGET_CHECKBOX, 6,  second_col,  0,              0,  f_mkisofs_pad_cb,             (void *) NULL,        task->create_image.pad ? 1 : 0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      6,  first_col,       width_narrow,   1,  f_mkisofs_pad_l,              _("Pad at the end"),                               0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          6,  second_col,      0,              0,  f_mkisofs_pad_cb,             (void *) NULL,                      iso->pad ? 1 : 0 },
 
 		/* 2TRANS: this is an input field label: define additional top level (root) directory for created file system */
-		{ CDW_WIDGET_LABEL,    8,  first_col,   width_wide,     1,  f_mkisofs_root_l,             _("Root directory:"),                              0 },
-		{ CDW_WIDGET_INPUT,    9,  first_col,   width_wide - 3, 1,  f_mkisofs_root_i,             task->create_image.mkisofs.root_dir,               0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     8,  first_col,       width_wide,     1,  f_mkisofs_root_l,             _("Root directory:"),                              0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   9,  first_col,       width_wide - 3, 1,  f_mkisofs_root_i,             iso->root_dir,                                     0 },
 
 		/* 2TRANS: this is an input field label; define other options passed to mkisofs */
-		{ CDW_WIDGET_LABEL,   10,  first_col,   width_wide,     1,  f_mkisofs_other_l,            _("Other mkisofs options:"),                       0 },
-		{ CDW_WIDGET_INPUT,   11,  first_col,   width_wide - 3, 1,  f_mkisofs_other_i,            task->create_image.mkisofs.other_mkisofs_options,  0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,    10,  first_col,       width_wide,     1,  f_mkisofs_other_l,            _("Other mkisofs options:"),                       0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,  11,  first_col,       width_wide - 3, 1,  f_mkisofs_other_i,            iso->mkisofs_other_options,                        0 },
 
 		/* guard */
-		{ -1,                  0,  0,           0,              0,  0,                            (void *) NULL,                                     0 }};
+		{ -1,                              0,  0,               0,              0,  0,                            (void *) NULL,                                     0 }};
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
+		cdw_form_bind_input_and_label(cdw_form, f_mkisofs_root_i, f_mkisofs_root_l);
+		cdw_form_bind_input_and_label(cdw_form, f_mkisofs_other_i, f_mkisofs_other_l);
 		return CDW_OK;
 	}
 }
@@ -137,7 +140,7 @@
 
 CDW_DROPDOWN *cdw_mkisofs_options_make_iso_level_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
 {
-	cdw_id_t iso_level = local_task->create_image.mkisofs.iso_level;
+	cdw_id_t iso_level = local_iso->iso_level;
 	cdw_assert (iso_level > 0 && iso_level < 5,
 		    "ERROR: invalid value of iso level: %lld\n", iso_level);
 
@@ -163,7 +166,7 @@
 
 CDW_DROPDOWN *cdw_mkisofs_options_make_rock_ridge_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
 {
-	cdw_id_t rock_ridge = local_task->create_image.rock_ridge;
+	cdw_id_t rock_ridge = local_iso->rock_ridge;
 	cdw_assert (rock_ridge >= CDW_ISO9660_RR_NONE && rock_ridge <= CDW_ISO9660_RR_FULL,
 		    "ERROR: invalid value of Rock Ridge: %lld\n", rock_ridge);
 	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, N_RR_ITEMS_MAX, rr_items);
@@ -176,17 +179,15 @@
 
 
 
-cdw_rv_t cdw_mkisofs_options_validate(cdw_form_t *cdw_form, int *fi)
+cdw_rv_t cdw_mkisofs_options_validate(cdw_iso9660_t *iso, int *fi)
 {
-	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofs_root_i));
-	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	cdw_rv_t crv = cdw_string_security_parser(iso->root_dir, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_mkisofs_root_i;
 		return CDW_NO;
 	}
 
-	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofs_other_i));
-	crv = cdw_string_security_parser(s, (char *) NULL);
+	crv = cdw_string_security_parser(iso->mkisofs_other_options, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_mkisofs_other_i;
 		return CDW_NO;
@@ -199,9 +200,9 @@
 
 
 
-cdw_rv_t cdw_mkisofs_options_save(cdw_form_t *cdw_form, cdw_task_t *task)
+cdw_rv_t cdw_mkisofs_options_save(cdw_form_t *cdw_form, cdw_iso9660_t *iso)
 {
-	task->create_image.joliet_information = cdw_form_get_checkbox_state(cdw_form, f_mkisofs_joliet_cb);
+	iso->joliet_information = cdw_form_get_checkbox_state(cdw_form, f_mkisofs_joliet_cb);
 
 
 	CDW_DROPDOWN *dd = cdw_form_get_dropdown(cdw_form, f_mkisofs_rock_ridge_dd);
@@ -209,29 +210,27 @@
 	cdw_assert (rr == CDW_ISO9660_RR_NONE
 		    || rr == CDW_ISO9660_RR_USEFUL
 		    || rr == CDW_ISO9660_RR_FULL, "ERROR: field stores invalid value of Rock Ridge: %lld\n", rr);
-	task->create_image.rock_ridge = rr;
+	iso->rock_ridge = rr;
 
 
-	task->create_image.follow_symlinks = cdw_form_get_checkbox_state(cdw_form, f_mkisofs_follow_symlinks_cb);
+	iso->follow_symlinks = cdw_form_get_checkbox_state(cdw_form, f_mkisofs_follow_symlinks_cb);
 
 
 	dd = cdw_form_get_dropdown(cdw_form, f_mkisofs_iso_level_dd);
 	int il = (int) cdw_dropdown_get_current_item_id(dd);
 	cdw_assert (il >=1 && il <= 4,
 		    "ERROR: field stores invalid value of ISO level: %d\n", il);
-	task->create_image.mkisofs.iso_level = il;
+	iso->iso_level = il;
 
 
-	task->create_image.mkisofs.joliet_long = cdw_form_get_checkbox_state(cdw_form, f_mkisofs_joliet_long_cb);
+	iso->joliet_long = cdw_form_get_checkbox_state(cdw_form, f_mkisofs_joliet_long_cb);
 
 
-	task->create_image.pad = cdw_form_get_checkbox_state(cdw_form, f_mkisofs_pad_cb);
+	iso->pad = cdw_form_get_checkbox_state(cdw_form, f_mkisofs_pad_cb);
 
 
-	cdw_string_set(&(task->create_image.mkisofs.root_dir), cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofs_root_i)));
-	cdw_string_set(&(task->create_image.mkisofs.other_mkisofs_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofs_other_i)));
+	cdw_string_set(&(iso->root_dir), cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofs_root_i)));
+	cdw_string_set(&(iso->mkisofs_other_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofs_other_i)));
 
 	return CDW_OK;
 }
-
-
diff -Naur orig/src/external_tools/cdw_mkisofs_options.h patched/src/external_tools/cdw_mkisofs_options.h
--- orig/src/external_tools/cdw_mkisofs_options.h	2011-02-16 13:46:34.000000000 +0100
+++ patched/src/external_tools/cdw_mkisofs_options.h	2014-03-19 20:41:21.000000000 +0100
@@ -3,16 +3,15 @@
 
 #include "main.h"
 #include "cdw_form.h"
-#include "cdw_task.h"
+#include "cdw_iso9660.h"
 
-#define CDW_MKISOFS_OPTIONS_N_FIELDS  16
+#define CDW_MKISOFS_ISO_MAIN_OPTIONS_N_FIELDS  16
 
 
 cdw_rv_t cdw_mkisofs_options_form(cdw_form_t *cdw_form, void *task, int first_col, int second_col, int width_wide, int width_narrow);
-cdw_rv_t cdw_mkisofs_options_validate(cdw_form_t *cdw_form, int *fi);
-cdw_rv_t cdw_mkisofs_options_save(cdw_form_t *cdw_form, cdw_task_t *task);
+cdw_rv_t cdw_mkisofs_options_validate(cdw_iso9660_t *iso, int *fi);
+cdw_rv_t cdw_mkisofs_options_save(cdw_form_t *cdw_form, cdw_iso9660_t *iso);
 
 
 
 #endif /* H_CDW_MKISOFS_OPTIONS */
-
diff -Naur orig/src/external_tools/cdw_mkisofsrc.c patched/src/external_tools/cdw_mkisofsrc.c
--- orig/src/external_tools/cdw_mkisofsrc.c	2012-03-28 20:46:47.000000000 +0200
+++ patched/src/external_tools/cdw_mkisofsrc.c	2014-03-22 18:11:07.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -67,8 +67,8 @@
 	f_mkisofsrc_system_id_i };
 
 
-static FIELD *page_mkisofsrc_fields[CDW_MKISOFSRC_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
-static cdw_task_t *local_task = (cdw_task_t *) NULL;
+static FIELD *page_mkisofsrc_fields[CDW_MKISOFS_ISO_META_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
+static cdw_iso9660_t *local_iso = (cdw_iso9660_t *) NULL;
 
 
 
@@ -78,45 +78,45 @@
    \return CDW_OK when all fields were created (probably) without problems
    \return CDW_ERROR if one of fields was created incorrectly
 */
-cdw_rv_t cdw_mkisofsrc_options_form(cdw_form_t *cdw_form, void *cdw_task, int first_col, __attribute__((unused)) int second_col, int width_wide, __attribute__((unused)) int width_narrow)
+cdw_rv_t cdw_mkisofsrc_options_form(cdw_form_t *cdw_form, void *cdw_iso, int first_col, __attribute__((unused)) int second_col, int width_wide, __attribute__((unused)) int width_narrow)
 {
-	cdw_task_t *task = (cdw_task_t *) cdw_task;
-	local_task = task;
+	cdw_iso9660_t *iso = (cdw_iso9660_t *) cdw_iso;
+	local_iso = iso;
 	cdw_form->fields = page_mkisofsrc_fields;
 
 	cdw_form_descr_t descr[] = {
-		/*     type      begin_y  begin_x       n_cols           n_lines  field enum                   data1                                   data2 */
+		/* type                       begin_y   begin_x     n_cols           n_lines  field enum                     data1                               data2 */
 
-		{ CDW_WIDGET_TEXT,    1,  0,          width_wide + 3,        6,  f_mkisofsrc_top_message_l,    text_makers,                                      0 },
+		{ CDW_WIDGET_ID_TEXT,               1,  0,          width_wide + 3,        6,  f_mkisofsrc_top_message_l,    text_makers,                            0 },
 		/* 2TRANS: this is button label; a verb: read data from config file */
-		{ CDW_WIDGET_BUTTON,  8,  1,          1,                     1,  f_mkisofsrc_top_message_b,    _("Read"),                        CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,             8,  1,          1,                     1,  f_mkisofsrc_top_message_b,    _("Read"),              CDW_COLORS_DIALOG },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter abstract of ISO9660 volume; don't localize "ABST" */
-		{ CDW_WIDGET_LABEL,   9,  first_col,  width_wide,            1,  f_mkisofsrc_abstract_l,       _("Abstract (ABST)"),                             0 },
-		{ CDW_WIDGET_INPUT,  10,  first_col,  CDW_ISO9660_ABST_LEN,  1,  f_mkisofsrc_abstract_i,       task->create_image.abstract,   CDW_ISO9660_ABST_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,      9,  first_col,  width_wide,            1,  f_mkisofsrc_abstract_l,       _("Abstract (ABST)"),                   0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   10,  first_col,  CDW_ISO9660_ABST_LEN,  1,  f_mkisofsrc_abstract_i,       iso->abstract,       CDW_ISO9660_ABST_LEN },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter ID of ISO9660 volume set; don't localize "VOLS" */
-		{ CDW_WIDGET_LABEL,  11,  first_col,  width_wide,            1,  f_mkisofsrc_volume_set_id_l,  _("Volume set ID (VOLS)"),                            0 },
-		{ CDW_WIDGET_INPUT,  12,  first_col,  width_wide,            1,  f_mkisofsrc_volume_set_id_i,  task->create_image.volume_set_id,  CDW_ISO9660_VOLS_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     11,  first_col,  width_wide,            1,  f_mkisofsrc_volume_set_id_l,  _("Volume set ID (VOLS)"),              0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   12,  first_col,  width_wide,            1,  f_mkisofsrc_volume_set_id_i,  iso->volume_set_id,  CDW_ISO9660_VOLS_LEN },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter copyright of ISO9660 volume; don't localize "COPY" */
-		{ CDW_WIDGET_LABEL,  13,  first_col,  width_wide,            1,  f_mkisofsrc_copyright_l,      _("Copyright (COPY)"),                            0 },
-		{ CDW_WIDGET_INPUT,  14,  first_col,  CDW_ISO9660_COPY_LEN,  1,  f_mkisofsrc_copyright_i,      task->create_image.copyright,  CDW_ISO9660_COPY_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     13,  first_col,  width_wide,            1,  f_mkisofsrc_copyright_l,      _("Copyright (COPY)"),                  0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   14,  first_col,  CDW_ISO9660_COPY_LEN,  1,  f_mkisofsrc_copyright_i,      iso->copyright,      CDW_ISO9660_COPY_LEN },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter information about publisher of ISO9660 volume; don't localize "PUBL" */
-		{ CDW_WIDGET_LABEL,  15,  first_col,  width_wide,            1,  f_mkisofsrc_publisher_l,      _("Publisher (PUBL)"),                            0 },
-		{ CDW_WIDGET_INPUT,  16,  first_col,  width_wide,            1,  f_mkisofsrc_publisher_i,      task->create_image.publisher,  CDW_ISO9660_PUBL_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     15,  first_col,  width_wide,            1,  f_mkisofsrc_publisher_l,      _("Publisher (PUBL)"),                  0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   16,  first_col,  width_wide,            1,  f_mkisofsrc_publisher_i,      iso->publisher,      CDW_ISO9660_PUBL_LEN },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter information about preparer of ISO9660 volume; don't localize "PREP" */
-		{ CDW_WIDGET_LABEL,  17,  first_col,  width_wide,            1,  f_mkisofsrc_preparer_l,       _("Preparer (PREP)"),                             0 },
-		{ CDW_WIDGET_INPUT,  18,  first_col,  width_wide,            1,  f_mkisofsrc_preparer_i,       task->create_image.preparer,   CDW_ISO9660_PREP_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     17,  first_col,  width_wide,            1,  f_mkisofsrc_preparer_l,       _("Preparer (PREP)"),                   0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   18,  first_col,  width_wide,            1,  f_mkisofsrc_preparer_i,       iso->preparer,       CDW_ISO9660_PREP_LEN },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter information about system on which ISO9660 volume has been created; don't localize "SYSI" */
-		{ CDW_WIDGET_LABEL,  19,  first_col,  width_wide,            1,  f_mkisofsrc_system_id_l,      _("System ID (SYSI)"),                            0 },
-		{ CDW_WIDGET_INPUT,  20,  first_col,  CDW_ISO9660_SYSI_LEN,  1,  f_mkisofsrc_system_id_i,      task->create_image.system_id,  CDW_ISO9660_SYSI_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     19,  first_col,  width_wide,            1,  f_mkisofsrc_system_id_l,      _("System ID (SYSI)"),                  0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   20,  first_col,  CDW_ISO9660_SYSI_LEN,  1,  f_mkisofsrc_system_id_i,      iso->system_id,      CDW_ISO9660_SYSI_LEN },
 
 		/* guard */
-		{ -1,                 0,  0,          0,                     0,  0,                            (void *) NULL,                                    0 }};
+		{ -1,                               0,  0,          0,                     0,  0,                            (void *) NULL,                          0 }};
 
 	/* the function adds guard at the end of fields */
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
@@ -124,7 +124,15 @@
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
-		cdw_form_set_function(cdw_form, f_mkisofsrc_top_message_b, cdw_mkisofsrc_read);
+		cdw_form_set_widget_callback(cdw_form, f_mkisofsrc_top_message_b, cdw_mkisofsrc_read);
+
+		cdw_form_bind_input_and_label(cdw_form, f_mkisofsrc_abstract_i, f_mkisofsrc_abstract_l);
+		cdw_form_bind_input_and_label(cdw_form, f_mkisofsrc_volume_set_id_i, f_mkisofsrc_volume_set_id_l);
+		cdw_form_bind_input_and_label(cdw_form, f_mkisofsrc_copyright_i, f_mkisofsrc_copyright_l);
+		cdw_form_bind_input_and_label(cdw_form, f_mkisofsrc_publisher_i, f_mkisofsrc_publisher_l);
+		cdw_form_bind_input_and_label(cdw_form, f_mkisofsrc_preparer_i, f_mkisofsrc_preparer_l);
+		cdw_form_bind_input_and_label(cdw_form, f_mkisofsrc_system_id_i, f_mkisofsrc_system_id_l);
+
 		return CDW_OK;
 	}
 }
@@ -133,45 +141,39 @@
 
 
 
-cdw_rv_t cdw_mkisofsrc_options_validate(cdw_form_t *cdw_form, int *fi)
+cdw_rv_t cdw_mkisofsrc_options_validate(cdw_iso9660_t *iso, int *fi)
 {
-	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_abstract_i));
-	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	cdw_rv_t crv = cdw_string_security_parser(iso->abstract, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_mkisofsrc_abstract_i;
 		return CDW_NO;
 	}
 
-	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_volume_set_id_i));
-	crv = cdw_string_security_parser(s, (char *) NULL);
+	crv = cdw_string_security_parser(iso->volume_set_id, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_mkisofsrc_volume_set_id_i;
 		return CDW_NO;
 	}
 
-	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_copyright_i));
-	crv = cdw_string_security_parser(s, (char *) NULL);
+	crv = cdw_string_security_parser(iso->copyright, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_mkisofsrc_copyright_i;
 		return CDW_NO;
 	}
 
-	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_publisher_i));
-	crv = cdw_string_security_parser(s, (char *) NULL);
+	crv = cdw_string_security_parser(iso->publisher, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_mkisofsrc_publisher_i;
 		return CDW_NO;
 	}
 
-	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_preparer_i));
-	crv = cdw_string_security_parser(s, (char *) NULL);
+	crv = cdw_string_security_parser(iso->preparer, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_mkisofsrc_preparer_i;
 		return CDW_NO;
 	}
 
-	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_system_id_i));
-	crv = cdw_string_security_parser(s, (char *) NULL);
+	crv = cdw_string_security_parser(iso->system_id, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_mkisofsrc_system_id_i;
 		return CDW_NO;
@@ -184,31 +186,31 @@
 
 
 
-cdw_rv_t cdw_mkisofsrc_options_save(cdw_form_t *cdw_form, cdw_task_t *task)
+cdw_rv_t cdw_mkisofsrc_options_save(cdw_form_t *cdw_form, cdw_iso9660_t *iso)
 {
 	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_abstract_i));
-	strncpy(task->create_image.abstract, s, CDW_ISO9660_ABST_LEN);
-	task->create_image.abstract[CDW_ISO9660_ABST_LEN] = '\0';
+	strncpy(iso->abstract, s, CDW_ISO9660_ABST_LEN);
+	        iso->abstract[CDW_ISO9660_ABST_LEN] = '\0';
 
 	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_volume_set_id_i));
-	strncpy(task->create_image.volume_set_id, s, CDW_ISO9660_VOLS_LEN);
-	task->create_image.volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
+	strncpy(iso->volume_set_id, s, CDW_ISO9660_VOLS_LEN);
+	        iso->volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
 
 	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_copyright_i));
-	strncpy(task->create_image.copyright, s, CDW_ISO9660_COPY_LEN);
-	task->create_image.copyright[CDW_ISO9660_COPY_LEN] = '\0';
+	strncpy(iso->copyright, s, CDW_ISO9660_COPY_LEN);
+	        iso->copyright[CDW_ISO9660_COPY_LEN] = '\0';
 
 	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_publisher_i));
-	strncpy(task->create_image.publisher, s, CDW_ISO9660_PUBL_LEN);
-	task->create_image.publisher[CDW_ISO9660_PUBL_LEN] = '\0';
+	strncpy(iso->publisher, s, CDW_ISO9660_PUBL_LEN);
+	        iso->publisher[CDW_ISO9660_PUBL_LEN] = '\0';
 
 	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_preparer_i));
-	strncpy(task->create_image.preparer, s, CDW_ISO9660_PREP_LEN);
-	task->create_image.preparer[CDW_ISO9660_PREP_LEN] = '\0';
+	strncpy(iso->preparer, s, CDW_ISO9660_PREP_LEN);
+	        iso->preparer[CDW_ISO9660_PREP_LEN] = '\0';
 
 	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_system_id_i));
-	strncpy(task->create_image.system_id, s, CDW_ISO9660_SYSI_LEN);
-	task->create_image.system_id[CDW_ISO9660_SYSI_LEN] = '\0';
+	strncpy(iso->system_id, s, CDW_ISO9660_SYSI_LEN);
+	        iso->system_id[CDW_ISO9660_SYSI_LEN] = '\0';
 
 	return CDW_OK;
 }
@@ -240,7 +242,7 @@
 	file = fopen(path, "r");
 	free(path);
 	path = (char *) NULL;
-	if (file == (FILE *) NULL) {
+	if (!file) {
 		/* 2TRANS: this is message printed to log file;
 		   '%s' is configuration file name */
 		cdw_logging_write("WARNING: can't open %s file in home directory\n", file_name);
@@ -250,13 +252,13 @@
 
 	char *line = (char *) NULL;
 	while (1) {
-		if (line != (char *) NULL) {
+		if (line) {
 			free(line);
 			line = (char *) NULL;
 		}
 
 		line = my_readline_10k(file);
-		if (line == (char *) NULL) {
+		if (!line) {
 			break;
 		}
 
@@ -293,6 +295,7 @@
 	if (v != CDW_OK) {
 		cdw_vdm ("WARNING: option value \"%s=%s\" from mkisofsrc file rejected as insecure\n",
 			 option.name, option.value);
+		cdw_config_option_free(&option);
 		return;
 	}
 
@@ -301,6 +304,7 @@
 	buffer[len] = '\0';
 	set_field_buffer(cdw_form->fields[fi], 0, buffer);
 
+	cdw_config_option_free(&option);
+
 	return;
 }
-
diff -Naur orig/src/external_tools/cdw_mkisofsrc.h patched/src/external_tools/cdw_mkisofsrc.h
--- orig/src/external_tools/cdw_mkisofsrc.h	2011-02-16 13:53:41.000000000 +0100
+++ patched/src/external_tools/cdw_mkisofsrc.h	2014-03-19 20:41:21.000000000 +0100
@@ -2,14 +2,14 @@
 #define H_CDW_MKISOFSRC
 
 #include "cdw_form.h"
-#include "cdw_task.h"
+#include "cdw_iso9660.h"
 
-#define CDW_MKISOFSRC_OPTIONS_N_FIELDS 14
+#define CDW_MKISOFS_ISO_META_OPTIONS_N_FIELDS 14
 
 
-cdw_rv_t cdw_mkisofsrc_options_form(cdw_form_t *cdw_form, void *task, int first_col, int second_col, int width_wide, int width_narrow);
-cdw_rv_t cdw_mkisofsrc_options_validate(cdw_form_t *cdw_form, int *fi);
-cdw_rv_t cdw_mkisofsrc_options_save(cdw_form_t *cdw_form, cdw_task_t *task);
+cdw_rv_t cdw_mkisofsrc_options_form(cdw_form_t *cdw_form, void *cdw_iso, int first_col, int second_col, int width_wide, int width_narrow);
+cdw_rv_t cdw_mkisofsrc_options_validate(cdw_iso9660_t *iso, int *fi);
+cdw_rv_t cdw_mkisofsrc_options_save(cdw_form_t *cdw_form, cdw_iso9660_t *iso);
 
 
 
diff -Naur orig/src/external_tools/cdw_mkisofs_regex.c patched/src/external_tools/cdw_mkisofs_regex.c
--- orig/src/external_tools/cdw_mkisofs_regex.c	2012-03-28 20:21:15.000000000 +0200
+++ patched/src/external_tools/cdw_mkisofs_regex.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdlib.h>
@@ -436,7 +436,7 @@
 int cdw_mkisofs_handle_image_creation(regex_t *regex, regmatch_t *matches)
 {
 	/* additional check is to avoid mistake with direct writing */
-	if (thread_task->id != CDW_TASK_CREATE_IMAGE) {
+	if (thread_task->id != CDW_TASK_CREATE_IMAGE_ISO9660) {
 		return 0;
 	}
 
@@ -502,7 +502,7 @@
 int cdw_mkisofs_handle_image_creation_100percent(__attribute__((unused)) regex_t *regex, __attribute__((unused)) regmatch_t *matches)
 {
 	/* additional check is to avoid mistake with direct writing */
-	if (thread_task->id != CDW_TASK_CREATE_IMAGE) {
+	if (thread_task->id != CDW_TASK_CREATE_IMAGE_ISO9660) {
 		return 0;
 	}
 
@@ -591,5 +591,3 @@
 		return 0;
 	}
 }
-
-
diff -Naur orig/src/external_tools/cdw_mkudffs.c patched/src/external_tools/cdw_mkudffs.c
--- orig/src/external_tools/cdw_mkudffs.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/external_tools/cdw_mkudffs.c	2014-04-12 20:26:33.000000000 +0200
@@ -0,0 +1,155 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+   \file cdw_mkudffs.c
+*/
+
+#define _GNU_SOURCE /* asprintf() */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "gettext.h"
+#include "cdw_thread.h"
+#include "cdw_string.h"
+#include "cdw_graftpoints.h"
+#include "cdw_debug.h"
+#include "cdw_ext_tools.h"
+#include "cdw_mkudffs.h"
+#include "cdw_mkudffs_options.h"
+#include "cdw_mkudffs_helpers.h"
+#include "cdw_file_manager.h"
+
+
+extern const char *cdw_mkudffs_option_blocksize[];
+extern const char *cdw_mkudffs_option_udfrev[];
+extern const char *cdw_mkudffs_option_strategy[];
+extern const char *cdw_mkudffs_option_spartable[];
+extern const char *cdw_mkudffs_option_media_type[];
+extern const char *cdw_mkudffs_option_space[];
+extern const char *cdw_mkudffs_option_ad[];
+extern const char *cdw_mkudffs_option_encoding[];
+
+
+
+
+
+/**
+
+   \param task - variable describing current task
+   \param disc - variable describing current disc
+
+*/
+cdw_rv_t cdw_mkudffs_run_task(cdw_task_t *task)
+{
+
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_UDF,
+		    "ERROR: incorrect task id is not CDW_TASK_CREATE_IMAGE_UDF: %lld\n", task->id);
+	cdw_assert (task->create_image.tool.id == CDW_TOOL_MKUDFFS,
+		    "ERROR: incorrect tool id is not CDW_TOOL_MKUDFFS in \"create image\" task: %lld\n", task->create_image.tool.id);
+	cdw_assert (task->create_image.tool.label,
+		    "ERROR: \"create image\" tool fullpath is not initialized (is NULL)\n");
+
+
+
+	cdw_udf_t *udf = &(task->create_image.udf);
+
+	/* I'm using the explicit tool's name. Even if there are more
+	   instances, I will use the default one. Instances of mkudffs
+	   are not configurable. */
+	char *command = cdw_string_concat("mkudffs ",
+					  udf->mkudffs_blocksize != CDW_MKUDFFS_BLOCKSIZE_UNSPECIFIED ? " --blocksize=" : "",
+					  udf->mkudffs_blocksize != CDW_MKUDFFS_BLOCKSIZE_UNSPECIFIED ? cdw_mkudffs_option_blocksize[udf->mkudffs_blocksize] : "",
+					  udf->mkudffs_blocksize != CDW_MKUDFFS_BLOCKSIZE_UNSPECIFIED ? " " : "",
+
+					  udf->mkudffs_udfrev != CDW_MKUDFFS_UDFREV_UNSPECIFIED ? " --udfrev=" : "",
+					  udf->mkudffs_udfrev != CDW_MKUDFFS_UDFREV_UNSPECIFIED ? cdw_mkudffs_option_udfrev[udf->mkudffs_udfrev] : "",
+					  udf->mkudffs_udfrev != CDW_MKUDFFS_UDFREV_UNSPECIFIED ? " " : "",
+
+					  udf->mkudffs_strategy != CDW_MKUDFFS_STRATEGY_UNSPECIFIED ? " --strategy=" : "",
+					  udf->mkudffs_strategy != CDW_MKUDFFS_STRATEGY_UNSPECIFIED ? cdw_mkudffs_option_strategy[udf->mkudffs_strategy] : "",
+					  udf->mkudffs_strategy != CDW_MKUDFFS_STRATEGY_UNSPECIFIED ? " " : "",
+
+					  udf->mkudffs_spartable != CDW_MKUDFFS_SPARTABLE_UNSPECIFIED ? " --spartable=" : "",
+					  udf->mkudffs_spartable != CDW_MKUDFFS_SPARTABLE_UNSPECIFIED ? cdw_mkudffs_option_spartable[udf->mkudffs_spartable] : "",
+					  udf->mkudffs_spartable != CDW_MKUDFFS_SPARTABLE_UNSPECIFIED ? " " : "",
+
+					  udf->mkudffs_media_type != CDW_MKUDFFS_MEDIA_TYPE_UNSPECIFIED ? " --media-type=" : "",
+					  udf->mkudffs_media_type != CDW_MKUDFFS_MEDIA_TYPE_UNSPECIFIED ? cdw_mkudffs_option_media_type[udf->mkudffs_media_type] : "",
+					  udf->mkudffs_media_type != CDW_MKUDFFS_MEDIA_TYPE_UNSPECIFIED ? " " : "",
+
+					  udf->mkudffs_space != CDW_MKUDFFS_SPACE_UNSPECIFIED ? " --space=" : "",
+					  udf->mkudffs_space != CDW_MKUDFFS_SPACE_UNSPECIFIED ? cdw_mkudffs_option_space[udf->mkudffs_space] : "",
+					  udf->mkudffs_space != CDW_MKUDFFS_SPACE_UNSPECIFIED ? " " : "",
+
+					  udf->mkudffs_ad != CDW_MKUDFFS_AD_UNSPECIFIED ? " --ad=" : "",
+					  udf->mkudffs_ad != CDW_MKUDFFS_AD_UNSPECIFIED ? cdw_mkudffs_option_ad[udf->mkudffs_ad] : "",
+					  udf->mkudffs_ad != CDW_MKUDFFS_AD_UNSPECIFIED ? " " : "",
+
+					  udf->mkudffs_encoding != CDW_MKUDFFS_ENCODING_UNSPECIFIED ? " --" : "",
+					  udf->mkudffs_encoding != CDW_MKUDFFS_ENCODING_UNSPECIFIED ? cdw_mkudffs_option_encoding[udf->mkudffs_encoding] : "",
+					  udf->mkudffs_encoding != CDW_MKUDFFS_ENCODING_UNSPECIFIED ? " " : "",
+
+					  udf->mkudffs_noefe ? " --noefe " : "",
+
+					  strlen(udf->mkudffs_lvid) ? " --lvid=\"" : "",
+					  strlen(udf->mkudffs_lvid) ? udf->mkudffs_lvid : "",
+					  strlen(udf->mkudffs_lvid) ? "\"" : "",
+
+					  strlen(udf->mkudffs_vid) ? " --vid=\"" : "",
+					  strlen(udf->mkudffs_vid) ? udf->mkudffs_vid : "",
+					  strlen(udf->mkudffs_vid) ? "\"" : "",
+
+					  strlen(udf->mkudffs_vsid) ? " --vsid=\"" : "",
+					  strlen(udf->mkudffs_vsid) ? udf->mkudffs_vsid : "",
+					  strlen(udf->mkudffs_vsid) ? "\"" : "",
+
+					  strlen(udf->mkudffs_fsid) ? " --fsid=\"" : "",
+					  strlen(udf->mkudffs_fsid) ? udf->mkudffs_fsid : "",
+					  strlen(udf->mkudffs_fsid) ? "\"" : "",
+
+					  " ", strlen(udf->mkudffs_other_options) ? udf->mkudffs_other_options : " ",
+
+					  /* Path may contain spaces, so use opening and closing quotes. */
+					  " \"", task->image_file_fullpath, "\" ", (char *) NULL);
+	if (!command) {
+		cdw_vdm ("ERROR: failed to get command for creating UDF file system\n");
+		return CDW_ERROR;
+	} else {
+		cdw_sdm ("INFO: created command string \"%s\"\n", command);
+		int rv = cdw_thread_run_command(command, task);
+		free(command);
+		command = (char *) NULL;
+
+		cdw_vdm ("INFO: exit status of \"mkudffs\" is %d\n", task->tool_status.child_exit_status);
+
+		if (rv == 0
+		    && task->tool_status.mkudffs_general == CDW_TOOL_STATUS_OK
+		    && task->tool_status.mkudffs == CDW_TOOL_STATUS_OK
+		    && task->tool_status.child_exit_status == 0) {
+
+			return CDW_OK;
+		} else {
+			return CDW_ERROR;
+		}
+	}
+}
diff -Naur orig/src/external_tools/cdw_mkudffs.h patched/src/external_tools/cdw_mkudffs.h
--- orig/src/external_tools/cdw_mkudffs.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/external_tools/cdw_mkudffs.h	2014-02-05 22:34:13.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef H_CDW_MKUDFFS
+#define H_CDW_MKUDFFS
+
+#include "main.h"
+#include "cdw_task.h"
+
+
+cdw_rv_t cdw_mkudffs_run_task(cdw_task_t *task);
+
+#endif /* H_CDW_MKUDFFS */
diff -Naur orig/src/external_tools/cdw_mkudffs_helpers.c patched/src/external_tools/cdw_mkudffs_helpers.c
--- orig/src/external_tools/cdw_mkudffs_helpers.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/external_tools/cdw_mkudffs_helpers.c	2014-04-06 22:35:21.000000000 +0200
@@ -0,0 +1,430 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+   \file cdw_mkudffs_helpers.c
+
+   \brief Functions creating command strings for mkudffs helpers,
+   i.e. for external tools that accompany mkudffs in creating UDF
+   image file: truncate, sudo mount, rsync, sudo umount.
+*/
+
+#define _GNU_SOURCE /* asprintf() */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <inttypes.h>
+
+#include "gettext.h"
+#include "cdw_thread.h"
+#include "cdw_string.h"
+#include "cdw_debug.h"
+#include "cdw_ext_tools.h"
+#include "cdw_mkudffs_helpers.h"
+#include "cdw_file.h"
+#include "cdw_file_manager.h"
+#include "cdw_processwin.h"
+
+
+
+
+
+
+/**
+
+   \param task - variable describing current task
+
+   \return CDW_ERROR on errors in the function or while running a task
+   \return CDW_OK on success
+*/
+cdw_rv_t cdw_truncate_run_task(cdw_task_t *task)
+{
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_UDF,
+		    "ERROR: incorrect task id is not CDW_TASK_CREATE_IMAGE_UDF: %lld\n", task->id);
+	/* This function is for "truncate", but the main tool used for
+	   creating UDF file system is mkudffs. This is a kind of
+	   umbrella ID for all tools involved in creating UDF
+	   image. */
+	cdw_assert (task->create_image.tool.id == CDW_TOOL_MKUDFFS,
+		    "ERROR: incorrect tool id is not CDW_TOOL_MKUDFFS in \"create image\" task: %lld\n", task->create_image.tool.id);
+	cdw_assert (task->create_image.tool.label,
+		    "ERROR: \"create image\" tool fullpath is not initialized (is NULL)\n");
+	cdw_assert (task->create_image.udf.volume_size_bytes > 0,
+		    "ERROR: volume size is zero bytes\n");
+
+	char *size_string = (char *) NULL;
+	int n = asprintf(&size_string, "%"PRIu64"", task->create_image.udf.volume_size_bytes);
+	if (n == -1) {
+		cdw_vdm ("ERROR: failed to allocate memory for size string\n");
+		return CDW_ERROR;
+	} else {
+		cdw_vdm ("INFO: successfully created size string: \"%s\"\n",
+			 size_string);
+	}
+
+	/* I'm using the explicit tool's name. Even if there are more
+	   instances, I will use the default one. Instances of helpers
+	   for mkudffs are not configurable. */
+	char *command = cdw_string_concat("truncate ",
+					  " --size=",
+					  size_string,
+					  /* Path may contain spaces, so use opening and closing quotes. */
+					  " \"", task->image_file_fullpath, "\" ", (char *) NULL);
+
+	free(size_string);
+	size_string = (char *) NULL;
+
+	if (!command) {
+		cdw_vdm ("ERROR: failed to create command for truncating file\n");
+		return CDW_ERROR;
+	} else {
+		cdw_sdm ("INFO: command string for \"truncate\" is \"%s\"\n", command);
+		int rv = cdw_thread_run_command(command, task);
+		free(command);
+		command = (char *) NULL;
+
+		cdw_vdm ("INFO: exit status of \"truncate\" is %d\n", task->tool_status.child_exit_status);
+
+		if (rv == 0
+		    && task->tool_status.mkudffs_general == CDW_TOOL_STATUS_OK
+		    && task->tool_status.truncate == CDW_TOOL_STATUS_OK
+		    && task->tool_status.child_exit_status == 0) {     /* Some other error that wasn't caught by regex code, so task->tool_status.mkudffs has not been set. */
+			return CDW_OK;
+		} else {
+			return CDW_ERROR;
+		}
+	}
+}
+
+
+
+
+
+/**
+
+   \param task - variable describing current task
+
+   \return CDW_ERROR on errors in the function or while running a task
+   \return CDW_OK on success
+*/
+cdw_rv_t cdw_mount_run_task(cdw_task_t *task)
+{
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_UDF,
+		    "ERROR: incorrect task id is not CDW_TASK_CREATE_IMAGE_UDF: %lld\n", task->id);
+	/* This function is for "mount", but the main tool used for
+	   creating UDF file system is mkudffs. This is a kind of
+	   umbrella ID for all tools involved in creating UDF
+	   image. */
+	cdw_assert (task->create_image.tool.id == CDW_TOOL_MKUDFFS,
+		    "ERROR: incorrect tool id is not CDW_TOOL_MKUDFFS in \"create image\" task: %lld\n", task->create_image.tool.id);
+	cdw_assert (task->create_image.tool.label,
+		    "ERROR: \"create image\" tool fullpath is not initialized (is NULL)\n");
+
+
+	/* uid option is used to ensure proper permissions for mount
+	   point, so that copying files into mounted file system is
+	   possible. */
+	char *uid_string = (char *) NULL;
+	int n = asprintf(&uid_string, "uid=%d", (int) getuid());
+	if (n == -1) {
+		cdw_vdm ("ERROR: asprintf() failed\n");
+		return CDW_ERROR;
+	} else {
+		cdw_vdm ("INFO: mount uid option = \"%s\"\n", uid_string);
+	}
+
+	/* I'm using the explicit tool's name. Even if there are more
+	   instances, I will use the default one. Instances of helpers
+	   for mkudffs are not configurable. */
+	/*
+	  man sudo(8):
+          "
+	  -n, --non-interactive
+	         Avoid prompting the user for input of any kind.  If a
+                 password is required for the command to run, sudo
+                 will display an error message and exit.
+	  "
+
+	  Otherwise sudo would print prompt to current tty, and no
+	  amount of redirecting stdout/stderr output by cdw would
+	  help.
+
+	  The error message mentioned in man page is
+	  "sudo: a password is required"
+	*/
+	char *command = cdw_string_concat("sudo -n mount ",
+					  " -t udf ",
+					  " -oloop,rw,",   /* No space between this string and uid string! */
+					  uid_string,
+					  /* Paths may contain spaces, so use opening and closing quotes. */
+					  " \"", task->image_file_fullpath, "\" ",
+					  " \"", task->create_image.udf.mount_point, "\" ",
+					  (char *) NULL);
+	free(uid_string);
+	uid_string = (char *) NULL;
+
+	if (!command) {
+		cdw_vdm ("ERROR: failed to create command for mounting\n");
+		return CDW_ERROR;
+	} else {
+		cdw_sdm ("INFO: command string for \"sudo mount\" is \"%s\"\n", command);
+		int rv = cdw_thread_run_command(command, task);
+		free(command);
+		command = (char *) NULL;
+
+		cdw_vdm ("INFO: exit status of \"sudo mount\" is %d\n", task->tool_status.child_exit_status);
+
+		if (rv == 0
+		    && task->tool_status.mkudffs_general == CDW_TOOL_STATUS_OK
+		    && task->tool_status.sudo == CDW_TOOL_STATUS_OK
+		    && task->tool_status.mount == CDW_TOOL_STATUS_OK
+		    && task->tool_status.child_exit_status == 0) {     /* Some other error that wasn't caught by regex code, so task->tool_status.mkudffs has not been set. */
+
+			return CDW_OK;
+		} else {
+			return CDW_ERROR;
+		}
+	}
+}
+
+
+
+
+
+/**
+
+   \param task - variable describing current task
+
+   \return CDW_ERROR on errors in the function or while running a task
+   \return CDW_OK on success
+*/
+cdw_rv_t cdw_umount_run_task(cdw_task_t *task)
+{
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_UDF,
+		    "ERROR: incorrect task id is not CDW_TASK_CREATE_IMAGE_UDF: %lld\n", task->id);
+	/* This function is for "umount", but the main tool used for
+	   creating UDF file system is mkudffs. This is a kind of
+	   umbrella ID for all tools involved in creating UDF
+	   image. */
+	cdw_assert (task->create_image.tool.id == CDW_TOOL_MKUDFFS,
+		    "ERROR: incorrect tool id is not CDW_TOOL_MKUDFFS in \"create image\" task: %lld\n", task->create_image.tool.id);
+	cdw_assert (task->create_image.tool.label,
+		    "ERROR: \"create image\" tool fullpath is not initialized (is NULL)\n");
+
+
+	/* I'm using the explicit tool's name. Even if there are more
+	   instances, I will use the default one. Instances of helpers
+	   for mkudffs are not configurable. */
+	/*
+	  man sudo(8):
+          "
+	  -n, --non-interactive
+	         Avoid prompting the user for input of any kind.  If a
+                 password is required for the command to run, sudo
+                 will display an error message and exit.
+	  "
+
+	  Otherwise sudo would print prompt to current tty, and no
+	  amount of redirecting stdout/stderr output by cdw would
+	  help.
+
+	  The error message mentioned in man page is
+	  "sudo: a password is required"
+	*/
+	char *command = cdw_string_concat("sudo -n umount ",
+					  /* Path may contain spaces, so use opening and closing quotes. */
+					  " \"", task->create_image.udf.mount_point, "\" ",
+					  (char *) NULL);
+
+	if (!command) {
+		cdw_vdm ("ERROR: failed to create command for unmounting\n");
+		return CDW_ERROR;
+	} else {
+		cdw_sdm ("INFO: command string for \"sudo umount\" is \"%s\"\n", command);
+		int rv = cdw_thread_run_command(command, task);
+		free(command);
+		command = (char *) NULL;
+
+		cdw_vdm ("INFO: exit status of \"umount\" is %d\n", task->tool_status.child_exit_status);
+
+		if (rv == 0
+		    && task->tool_status.mkudffs_general == CDW_TOOL_STATUS_OK
+		    && task->tool_status.sudo == CDW_TOOL_STATUS_OK
+		    && task->tool_status.umount == CDW_TOOL_STATUS_OK
+		    && task->tool_status.child_exit_status == 0) {     /* Some other error that wasn't caught by regex code, so task->tool_status.mkudffs has not been set. */
+
+			return CDW_OK;
+		} else {
+			return CDW_ERROR;
+		}
+	}
+}
+
+
+
+
+
+/**
+
+   \param task - variable describing current task
+
+   \return CDW_ERROR on errors in the function or while running a task
+   \return CDW_OK on success
+*/
+cdw_rv_t cdw_rsync_run_task(cdw_task_t *task)
+{
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_UDF,
+		    "ERROR: incorrect task id is not CDW_TASK_CREATE_IMAGE_UDF: %lld\n", task->id);
+	/* This function is for "rsync", but the main tool used for
+	   creating UDF file system is mkudffs. This is a kind of
+	   umbrella ID for all tools involved in creating UDF
+	   image. */
+	cdw_assert (task->create_image.tool.id == CDW_TOOL_MKUDFFS,
+		    "ERROR: incorrect tool id is not CDW_TOOL_MKUDFFS in \"create image\" task: %lld\n", task->create_image.tool.id);
+	cdw_assert (task->create_image.tool.label,
+		    "ERROR: \"create image\" tool fullpath is not initialized (is NULL)\n");
+
+
+	cdw_dll_item_t *f = cdw_file_manager_get_list_of_selected_files(); /* head */
+	cdw_assert (f, "ERROR: called the function when list of selected files is empty\n")
+
+	size_t files_i = 1;
+	size_t files_n = cdw_file_manager_number_of_selected_files();
+
+	for (; f; f = f->next) {
+		cdw_file_t *file = (cdw_file_t *) f->data;
+		cdw_assert (file->fullpath, "ERROR: file has no fullpath\n");
+		cdw_assert (strlen(file->fullpath) != 0, "ERROR: file full path length == 0\n");
+		cdw_assert (file->name_start > 0, "ERROR: file has no name\n");
+		cdw_assert (strlen(file->fullpath + file->name_start) != 0, "ERROR: file name length == 0\n");
+
+		/* I'm using the explicit tool's name. Even if there are more
+		   instances, I will use the default one. Instances of helpers
+		   for mkudffs are not configurable. */
+		char *command = cdw_string_concat("rsync ",
+						  /* These two options are hardwired because I don't think that any user would object having them. And I find them useful and needed. */
+						  "--verbose ",
+						  "--progress "
+
+						  /* Any other options that user needs, including options for symbolic links. */
+						  " ", task->create_image.udf.rsync_options, " ",
+
+						  /* SOURCE */
+						  /* Path may contain spaces, so use opening and closing quotes. */
+						  " \"", file->fullpath, "\" ",
+
+						  /* TARGET */
+						  /* Paths may contain spaces, so use opening and closing quotes. */
+						  /* The "/" is used to be sure that a slash exists at the end of mount point dir. */
+						  " \"", task->create_image.udf.mount_point,"/",file->fullpath + file->name_start, "\" ",
+						  (char *) NULL);
+
+		if (!command) {
+			cdw_vdm ("ERROR: failed to create command for copying file \"%s\"\n", file->fullpath);
+			return CDW_ERROR;
+		} else {
+			/* -(2 * 2) for spaces on left and right side of string, +1 for NULL. */
+#define PROGRESS_LEN (PROCESSWIN_COLS - (2 * 2))
+			char files_progress[PROGRESS_LEN + 1];
+			snprintf(files_progress, PROGRESS_LEN + 1, "Selected file %zd/%zd", files_i, files_n);
+			cdw_processwin_display_sub_info(files_progress);
+
+
+			cdw_sdm ("INFO: command string for \"rsync\" is \"%s\"\n", command);
+			int rv = cdw_thread_run_command(command, task);
+			free(command);
+			command = (char *) NULL;
+
+			cdw_vdm ("INFO: exit status of \"rsync\" is %d\n", task->tool_status.child_exit_status);
+
+			if (rv == 0
+			    && task->tool_status.mkudffs_general == CDW_TOOL_STATUS_OK
+			    && task->tool_status.rsync == CDW_TOOL_STATUS_OK
+			    && task->tool_status.child_exit_status == 0) {     /* Some other error that wasn't caught by regex code, so task->tool_status.mkudffs has not been set. */
+			} else {
+				return CDW_ERROR;
+			}
+		}
+
+		files_i++;
+	}
+
+	/* Hide progress information. */
+	cdw_processwin_display_sub_info("");
+	cdw_processwin_delete_progress_bar();
+	cdw_processwin_wrefresh();
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+
+   \param task - variable describing current task
+
+   \return CDW_ERROR on errors in the function or while running a task
+   \return CDW_OK on success
+*/
+cdw_rv_t cdw_sync_run_task(cdw_task_t *task)
+{
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_UDF,
+		    "ERROR: incorrect task id is not CDW_TASK_CREATE_IMAGE_UDF: %lld\n", task->id);
+	/* This function is for "sync", but the main tool used for
+	   creating UDF file system is mkudffs. This is a kind of
+	   umbrella ID for all tools involved in creating UDF
+	   image. */
+	cdw_assert (task->create_image.tool.id == CDW_TOOL_MKUDFFS,
+		    "ERROR: incorrect tool id is not CDW_TOOL_MKUDFFS in \"create image\" task: %lld\n", task->create_image.tool.id);
+	cdw_assert (task->create_image.tool.label,
+		    "ERROR: \"create image\" tool fullpath is not initialized (is NULL)\n");
+
+
+	/* I'm using the explicit tool's name. Even if there are more
+	   instances, I will use the default one. Instances of helpers
+	   for mkudffs are not configurable. */
+	char *command = cdw_string_concat("sync",
+					  (char *) NULL);
+
+	if (!command) {
+		cdw_vdm ("ERROR: failed to create command for syncing\n");
+		return CDW_ERROR;
+	} else {
+		cdw_sdm ("INFO: command string for \"sync\" is \"%s\"\n", command);
+		int rv = cdw_thread_run_command(command, task);
+		free(command);
+		command = (char *) NULL;
+
+		cdw_vdm ("INFO: exit status of \"sync\" is %d\n", task->tool_status.child_exit_status);
+
+		if (rv == 0
+		    && task->tool_status.mkudffs_general == CDW_TOOL_STATUS_OK
+		    && task->tool_status.sync == CDW_TOOL_STATUS_OK
+		    && task->tool_status.child_exit_status == 0) {     /* Some other error that wasn't caught by regex code, so task->tool_status.mkudffs has not been set. */
+
+			return CDW_OK;
+		} else {
+			return CDW_ERROR;
+		}
+	}
+}
diff -Naur orig/src/external_tools/cdw_mkudffs_helpers.h patched/src/external_tools/cdw_mkudffs_helpers.h
--- orig/src/external_tools/cdw_mkudffs_helpers.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/external_tools/cdw_mkudffs_helpers.h	2014-04-06 22:35:46.000000000 +0200
@@ -0,0 +1,14 @@
+#ifndef H_CDW_MKUDFFS_HELPERS
+#define H_CDW_MKUDFFS_HELPERS
+
+#include "main.h"
+#include "cdw_task.h"
+
+
+cdw_rv_t cdw_truncate_run_task(cdw_task_t *task);
+cdw_rv_t cdw_mount_run_task(cdw_task_t *task);
+cdw_rv_t cdw_umount_run_task(cdw_task_t *task);
+cdw_rv_t cdw_rsync_run_task(cdw_task_t *task);
+cdw_rv_t cdw_sync_run_task(cdw_task_t *task);
+
+#endif /* H_CDW_MKUDFFS_HELPERS */
diff -Naur orig/src/external_tools/cdw_mkudffs_options.c patched/src/external_tools/cdw_mkudffs_options.c
--- orig/src/external_tools/cdw_mkudffs_options.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/external_tools/cdw_mkudffs_options.c	2014-04-12 20:26:33.000000000 +0200
@@ -0,0 +1,793 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "gettext.h"
+#include "cdw_config.h"
+#include "cdw_mkudffs_options.h"
+#include "cdw_fs.h"
+#include "cdw_string.h"
+#include "cdw_debug.h"
+#include "cdw_utils.h"
+#include "cdw_form.h"
+#include "cdw_logging.h"
+#include "cdw_file_picker.h"
+#include "cdw_file_manager.h"
+#include "cdw_main_window.h"
+#include "canonicalize.h"
+
+
+
+
+
+
+/*
+mkudffs 1.0.0b2 for UDF FS 1.0.0-cvs, 2002/02/09
+Usage:
+	mkudffs [options] device [blocks-count]
+Switches:
+	--help               - don't include
+	--blocksize=, -b     - first page, dropdown
+	--udfrev=, -r        - first page, dropdown
+	--lvid=              - main page of wizard, input field
+	--vid=               - second page, input field
+	--vsid=              - second page, input field
+	--fsid=              - second page, input field
+	--strategy=          - first page, dropdown
+	--spartable=         - first page, dropdown
+	--packetlen=         - ???
+	--media-type=        - first page, dropdown
+	--space=             - first page, dropdown
+	--ad=                - first page, dropdown
+	--noefe              - first page, checkbox
+	--u8                 - first page, common dropdown
+	--u16                - first page, common dropdown
+	--utf8               - first page, common dropdown
+	--bridge             - ???
+	--closed             - ???
+*/
+
+
+
+
+
+/* First page. */
+enum {
+	f_blocksize_l = 0,
+	f_blocksize_dd,
+	f_udfrev_l,
+	f_udfrev_dd,
+	f_strategy_l,
+	f_strategy_dd,
+	f_spartable_l,
+	f_spartable_dd,
+	f_media_type_l,
+	f_media_type_dd,
+	f_space_l,
+	f_space_dd,
+	f_ad_l,
+	f_ad_dd,
+	f_noefe_l,
+	f_noefe_cb,
+	f_encoding_l,
+	f_encoding_dd,
+	f_mkudffs_other_l,
+	f_mkudffs_other_i,
+	f_mount_point_l,
+	f_mount_point_i,
+	f_mount_point_b,
+	f_rsync_options_t,
+	f_rsync_options_dl,
+	f_rsync_options_i
+};
+
+
+static struct {
+
+	cdw_udf_t *udf;
+
+	cdw_form_t *cdw_form_p1;
+	cdw_form_t *cdw_form_p2;
+
+} options_window;
+
+
+
+static FIELD *mkudffs_fields_p1[CDW_MKUDFFS_UDF_MAIN_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
+
+
+static int cdw_mkudffs_options_on_mount_point(void *dummy1, void *dummy2);
+
+
+static CDW_DROPDOWN *cdw_mkudffs_blocksize_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_mkudffs_udfrev_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_mkudffs_strategy_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_mkudffs_spartable_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_mkudffs_media_type_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_mkudffs_space_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_mkudffs_ad_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_mkudffs_encoding_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+
+static cdw_form_dropdown_maker_t dropdown_makers[] = {
+	cdw_mkudffs_blocksize_dropdown,
+	cdw_mkudffs_udfrev_dropdown,
+	cdw_mkudffs_strategy_dropdown,
+	cdw_mkudffs_spartable_dropdown,
+	cdw_mkudffs_media_type_dropdown,
+	cdw_mkudffs_space_dropdown,
+	cdw_mkudffs_ad_dropdown,
+	cdw_mkudffs_encoding_dropdown
+};
+
+
+static char *cdw_mkudffs_symlinks_text(int n_cols);
+
+static cdw_form_text_maker_t text_makers[] = {
+	cdw_mkudffs_symlinks_text
+};
+
+
+
+/**
+   \brief Create fields that are shown on "XXX" page in options
+
+   \return CDW_OK when all fields were created (probably) without problems
+   \return CDW_GEN_ERROR if one of fields was created incorrectly
+*/
+cdw_rv_t cdw_mkudffs_options_form_p1(cdw_form_t *cdw_form, void *cdw_udf, int first_col, __attribute__((unused)) int second_col, __attribute__((unused)) int width_wide, int width_narrow)
+{
+	options_window.udf = (cdw_udf_t *) cdw_udf;
+	options_window.cdw_form_p1 = cdw_form;
+	options_window.cdw_form_p1->fields = mkudffs_fields_p1;
+	cdw_udf_t *udf = options_window.udf;
+
+	second_col += 3;
+	int third_col = first_col + width_wide - 4;
+	int width_narrow1 = width_narrow + 3;
+	int width_narrow2 = (int) (width_narrow / 1.5);
+
+	cdw_assert (CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX == 200, "ERROR: maximal length of string has changed. Update the text message in code below.\n");
+	cdw_assert (CDW_RSYNC_OPTIONS_LEN_MAX == 600, "ERROR: maximal length of string changed. Update the text message in code below.\n");
+
+	cdw_form_descr_t descr[] = {
+		/* type                      begin_y   begin_x      n_cols    n_lines   field enum            data1                                       data2 */
+		{ CDW_WIDGET_ID_STATIC_LABEL,      1,  first_col,   width_narrow1,  1,  f_blocksize_l,        _("Block size:"),                               0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          1,  second_col,  width_narrow2,  1,  f_blocksize_dd,       dropdown_makers,                                0 },
+
+		{ CDW_WIDGET_ID_STATIC_LABEL,      2,  first_col,   width_narrow1,  1,  f_udfrev_l,           _("UDF revision:"),                             0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          2,  second_col,  width_narrow2,  1,  f_udfrev_dd,          dropdown_makers,                                1 },
+
+		{ CDW_WIDGET_ID_STATIC_LABEL,      3,  first_col,   width_narrow1,  1,  f_strategy_l,         _("Allocation strategy:"),                      0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          3,  second_col,  width_narrow2,  1,  f_strategy_dd,        dropdown_makers,                                2 },
+
+		{ CDW_WIDGET_ID_STATIC_LABEL,      4,  first_col,   width_narrow1,  1,  f_spartable_l,        _("Sparing tables:"),                           0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          4,  second_col,  width_narrow2,  1,  f_spartable_dd,       dropdown_makers,                                3 },
+
+		{ CDW_WIDGET_ID_STATIC_LABEL,      5,  first_col,   width_narrow1,  1,  f_media_type_l,       _("Media type:"),                               0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          5,  second_col,  width_narrow2,  1,  f_media_type_dd,      dropdown_makers,                                4 },
+
+		{ CDW_WIDGET_ID_STATIC_LABEL,      6,  first_col,   width_narrow1,  1,  f_space_l,            _("Space:"),                                    0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          6,  second_col,  width_narrow2,  1,  f_space_dd,           dropdown_makers,                                5 },
+
+		{ CDW_WIDGET_ID_STATIC_LABEL,      7,  first_col,   width_narrow1,  1,  f_ad_l,               _("Allocation descriptors:"),                   0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          7,  second_col,  width_narrow2,  1,  f_ad_dd,              dropdown_makers,                                6 },
+
+		{ CDW_WIDGET_ID_STATIC_LABEL,      8,  first_col,   width_narrow1,  1,  f_noefe_l,            _("Don't use Extended File Entries:"),          0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          8,  second_col + 1,  1,          1,  f_noefe_cb,           (void *) NULL,                 udf->mkudffs_noefe },
+
+		{ CDW_WIDGET_ID_STATIC_LABEL,      9,  first_col,   width_narrow1,  1,  f_encoding_l,         _("Encoding of file names:"),                   0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          9,  second_col,  width_narrow2,  1,  f_encoding_dd,        dropdown_makers,                                7 },
+
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,    10,  first_col,   width_wide,     1,  f_mkudffs_other_l,    _("Other mkudffs options (200 chars max):"),    0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,  11,  first_col,   width_wide,     1,  f_mkudffs_other_i,    udf->mkudffs_other_options,   CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX },
+
+		/* This isn't really mkudffs option. It is used by
+		   "mount", which is a step in a recipe using mkudffs
+		   to create UDF image. */
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,    13,  first_col,   width_wide,      1,  f_mount_point_l,     _("Existing mount directory (mount point):"),   0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,  14,  first_col,   width_wide - 5,  1,  f_mount_point_i,     udf->mount_point,                               0 },
+		/* 2TRANS: do not translate */
+		{ CDW_WIDGET_ID_BUTTON,           14,  third_col,   1,               1,  f_mount_point_b,     _(">"),                         CDW_COLORS_DIALOG },
+
+		{ CDW_WIDGET_ID_TEXT,             15,  first_col,   width_wide,      2,  f_rsync_options_t,   text_makers,                                    0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,    17,  first_col,   width_wide,      1,  f_rsync_options_dl,  _("rsync options string (600 chars max):"),     0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,  18,  first_col,   width_wide,      1,  f_rsync_options_i,   udf->rsync_options,     CDW_RSYNC_OPTIONS_LEN_MAX },
+
+		/* guard */
+		{ -1,                              0,  0,           0,               0,  0,                   (void *) NULL,                                   0 }};
+
+
+	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to convert form description to form\n");
+		return CDW_ERROR;
+	} else {
+		cdw_form_bind_input_and_label(cdw_form, f_mkudffs_other_i, f_mkudffs_other_l);
+		cdw_form_bind_input_and_label(cdw_form, f_rsync_options_i, f_rsync_options_dl);
+		cdw_form_bind_input_and_label(cdw_form, f_mount_point_i, f_mount_point_l);
+		cdw_form_set_widget_callback(cdw_form, f_mount_point_b, (cdw_form_widget_function_t) cdw_mkudffs_options_on_mount_point);
+
+		return CDW_OK;
+	}
+}
+
+
+
+
+
+cdw_rv_t cdw_mkudffs_options_validate_p1(cdw_udf_t *udf, int *fi)
+{
+	cdw_rv_t crv = cdw_string_security_parser(udf->mkudffs_other_options, (char *) NULL);
+	if (crv == CDW_NO) {
+		*fi = f_mkudffs_other_i;
+		return CDW_NO;
+	}
+
+
+
+	crv = cdw_string_security_parser(udf->mount_point, (char *) NULL);
+	if (crv == CDW_NO) {
+		*fi = f_mount_point_i;
+		return CDW_NO;
+	}
+
+	int rv = cdw_fs_check_existing_path(udf->mount_point, W_OK, CDW_FS_DIR);
+	if (rv != 0) {
+		cdw_sdm ("INFO: \"%s\": errno: %s\n", udf->mount_point, strerror(rv));
+		/* 2TRANS: this is title of dialog window. */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window. "Mount point" as an entry in /etc/fstab. */
+				   _("Mount point is not an existing, writable directory."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		*fi = f_mount_point_i;
+		return CDW_NO;
+	}
+
+	/* The function does only very, very simple check, not looking
+	   for symlinks deep in structure of selected files. For now
+	   it will have to be enough. */
+	crv = cdw_selected_files_search(udf->mount_point, CAN_EXISTING);
+	if (crv == CDW_OK || crv == CDW_ERROR) {
+		/* 2TRANS: this is title of dialog window. */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window. "Mount point" as an entry in /etc/fstab. */
+				   _("Mount point directory is on list of selected files."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		*fi = f_mount_point_i;
+		return CDW_NO;
+	}
+
+
+
+	crv = cdw_string_security_parser(udf->rsync_options, (char *) NULL);
+	if (crv == CDW_NO) {
+		*fi = f_rsync_options_i;
+		return CDW_NO;
+	}
+
+	if (!strlen(udf->rsync_options)) {
+		/* 2TRANS: this is title of dialog window. */
+		crv = cdw_buttons_dialog(_("Warning"),
+					 /* 2TRANS: this is message in dialog window. */
+					 _("No options for rsync are set.\nImage file created with empty rsync options may be invalid or incomplete. Press OK to continue, or press Cancel to go back to Options."),
+					 CDW_BUTTONS_OK_CANCEL, CDW_COLORS_WARNING);
+
+		if (crv == CDW_OK) {
+			; /* Pass */
+		} else { /* CDW_NO */
+			*fi = f_rsync_options_i;
+			return CDW_NO;
+		}
+	}
+
+
+	/*
+	  man mkudffs(1):
+	  --spartable= spartable-number
+
+                  Specify the number of sparing tables to write to
+                  disc. Valid numbers are 1 - 4.  This option implies
+                  --media-type=cdrw.
+	*/
+	if (udf->mkudffs_spartable != CDW_MKUDFFS_SPARTABLE_UNSPECIFIED) {
+		if (udf->mkudffs_media_type == CDW_MKUDFFS_MEDIA_TYPE_UNSPECIFIED
+		    || udf->mkudffs_media_type == CDW_MKUDFFS_MEDIA_TYPE_CDRW) {
+
+			; /* Pass. */
+		} else {
+			/* 2TRANS: this is title of dialog window. */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window, informing about dependencies between options. */
+					   _("Selecting specific value of \"Sparing table\" requires either not specifying \"Media type\" or setting it to \"CD-RW\"."),
+					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+
+			*fi = f_media_type_dd;
+			return CDW_NO;
+		}
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_mkudffs_options_save_p1(cdw_udf_t *udf, cdw_form_t *cdw_form)
+{
+	CDW_DROPDOWN *dd = NULL;
+
+	dd = cdw_form_get_dropdown(cdw_form, f_blocksize_dd);
+	udf->mkudffs_blocksize = cdw_dropdown_get_current_item_id(dd);
+
+	dd = cdw_form_get_dropdown(cdw_form, f_udfrev_dd);
+	udf->mkudffs_udfrev = cdw_dropdown_get_current_item_id(dd);
+
+	dd = cdw_form_get_dropdown(cdw_form, f_strategy_dd);
+	udf->mkudffs_strategy = cdw_dropdown_get_current_item_id(dd);
+
+	dd = cdw_form_get_dropdown(cdw_form, f_spartable_dd);
+	udf->mkudffs_spartable = cdw_dropdown_get_current_item_id(dd);
+
+	dd = cdw_form_get_dropdown(cdw_form, f_media_type_dd);
+	udf->mkudffs_media_type = cdw_dropdown_get_current_item_id(dd);
+
+	dd = cdw_form_get_dropdown(cdw_form, f_space_dd);
+	udf->mkudffs_space = cdw_dropdown_get_current_item_id(dd);
+
+	dd = cdw_form_get_dropdown(cdw_form, f_ad_dd);
+	udf->mkudffs_ad = cdw_dropdown_get_current_item_id(dd);
+
+	udf->mkudffs_noefe = cdw_form_get_checkbox_state(cdw_form, f_noefe_cb);
+
+	dd = cdw_form_get_dropdown(cdw_form, f_encoding_dd);
+	udf->mkudffs_encoding = cdw_dropdown_get_current_item_id(dd);
+
+	const char *s = cdw_form_get_string(cdw_form, f_mkudffs_other_i);
+	strncpy(udf->mkudffs_other_options, s, CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX);
+	        udf->mkudffs_other_options[CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX] = '\0';
+
+	s = cdw_form_get_string(cdw_form, f_rsync_options_i);
+	strncpy(udf->rsync_options, s, CDW_RSYNC_OPTIONS_LEN_MAX);
+	        udf->rsync_options[CDW_RSYNC_OPTIONS_LEN_MAX] = '\0';
+
+	s = cdw_form_get_string(cdw_form, f_mount_point_i);
+	cdw_string_set(&(udf->mount_point), s);
+
+	return CDW_OK;
+}
+
+
+
+
+
+
+
+
+
+
+static cdw_id_clabel_t block_size_items[CDW_MKUDFFS_BLOCKSIZE_MAX] = {
+	{ CDW_MKUDFFS_BLOCKSIZE_UNSPECIFIED,  gettext_noop("Unspecified") },
+	{ CDW_MKUDFFS_BLOCKSIZE_1024,         gettext_noop("1024")        },
+	{ CDW_MKUDFFS_BLOCKSIZE_2048,         gettext_noop("2048")        },
+	{ CDW_MKUDFFS_BLOCKSIZE_4096,         gettext_noop("4096")        }
+};
+
+const char *cdw_mkudffs_option_blocksize[CDW_MKUDFFS_BLOCKSIZE_MAX] = {
+	"",
+	"1024",
+	"2048",
+	"4096"
+};
+
+
+CDW_DROPDOWN *cdw_mkudffs_blocksize_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, CDW_MKUDFFS_BLOCKSIZE_MAX, block_size_items);
+
+	cdw_dropdown_set_current_item_by_id(dd, options_window.udf->mkudffs_blocksize);
+
+	return dd;
+}
+
+
+
+
+
+static cdw_id_clabel_t udfrev_items[CDW_MKUDFFS_UDFREV_MAX] = {
+	{ CDW_MKUDFFS_UDFREV_UNSPECIFIED,  gettext_noop("Unspecified") },
+	{ CDW_MKUDFFS_UDFREV_0x0201,       gettext_noop("2.01")        },
+	{ CDW_MKUDFFS_UDFREV_0x0200,       gettext_noop("2.00")        },
+	{ CDW_MKUDFFS_UDFREV_0x0150,       gettext_noop("1.50")        },
+	{ CDW_MKUDFFS_UDFREV_0x0102,       gettext_noop("1.02")        }
+};
+
+const char *cdw_mkudffs_option_udfrev[CDW_MKUDFFS_UDFREV_MAX] = {
+	"",
+	"0x0201",
+	"0x0200",
+	"0x0150",
+	"0x0102"
+};
+
+CDW_DROPDOWN *cdw_mkudffs_udfrev_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, CDW_MKUDFFS_UDFREV_MAX, udfrev_items);
+
+	cdw_dropdown_set_current_item_by_id(dd, options_window.udf->mkudffs_udfrev);
+
+	return dd;
+}
+
+
+
+
+
+static cdw_id_clabel_t strategy_items[CDW_MKUDFFS_STRATEGY_MAX] = {
+	{ CDW_MKUDFFS_STRATEGY_UNSPECIFIED,  gettext_noop("Unspecified") },
+	{ CDW_MKUDFFS_STRATEGY_4,            gettext_noop("4")           },
+	{ CDW_MKUDFFS_STRATEGY_4096,         gettext_noop("4096")        }
+};
+
+const char *cdw_mkudffs_option_strategy[CDW_MKUDFFS_STRATEGY_MAX] = {
+	"",
+	"4",
+	"4096"
+};
+
+CDW_DROPDOWN *cdw_mkudffs_strategy_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, CDW_MKUDFFS_STRATEGY_MAX, strategy_items);
+
+	cdw_dropdown_set_current_item_by_id(dd, options_window.udf->mkudffs_strategy);
+
+	return dd;
+}
+
+
+
+
+
+static cdw_id_clabel_t spartable_items[CDW_MKUDFFS_SPARTABLE_MAX] = {
+	{ CDW_MKUDFFS_SPARTABLE_UNSPECIFIED,  gettext_noop("Unspecified") },
+	{ CDW_MKUDFFS_SPARTABLE_1,            gettext_noop("1")           },
+	{ CDW_MKUDFFS_SPARTABLE_2,            gettext_noop("2")           },
+	{ CDW_MKUDFFS_SPARTABLE_3,            gettext_noop("3")           },
+	{ CDW_MKUDFFS_SPARTABLE_4,            gettext_noop("4")           }
+};
+
+const char *cdw_mkudffs_option_spartable[CDW_MKUDFFS_SPARTABLE_MAX] = {
+	"",
+	"1",
+	"2",
+	"3",
+	"4"
+};
+
+CDW_DROPDOWN *cdw_mkudffs_spartable_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, CDW_MKUDFFS_SPARTABLE_MAX, spartable_items);
+
+	cdw_dropdown_set_current_item_by_id(dd, options_window.udf->mkudffs_spartable);
+
+	return dd;
+}
+
+
+
+
+
+static cdw_id_clabel_t media_type_items[CDW_MKUDFFS_MEDIA_TYPE_MAX] = {
+	{ CDW_MKUDFFS_MEDIA_TYPE_UNSPECIFIED,  gettext_noop("Unspecified") },
+	{ CDW_MKUDFFS_MEDIA_TYPE_HD,           gettext_noop("Hard Disc")   },
+	{ CDW_MKUDFFS_MEDIA_TYPE_DVD,          gettext_noop("DVD")         },
+	{ CDW_MKUDFFS_MEDIA_TYPE_DVDRAM,       gettext_noop("DVD-RAM")     },
+	{ CDW_MKUDFFS_MEDIA_TYPE_WORM,         gettext_noop("WORM")        },
+	{ CDW_MKUDFFS_MEDIA_TYPE_MO,           gettext_noop("MO")          },
+	{ CDW_MKUDFFS_MEDIA_TYPE_CDRW,         gettext_noop("CD-RW")       }
+};
+
+const char *cdw_mkudffs_option_media_type[CDW_MKUDFFS_MEDIA_TYPE_MAX] = {
+	"",
+	"hd",
+	"dvd",
+	"dvdram",
+	"worm",
+	"mo",
+	"cdrw"
+};
+
+CDW_DROPDOWN *cdw_mkudffs_media_type_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, CDW_MKUDFFS_MEDIA_TYPE_MAX, media_type_items);
+
+	cdw_dropdown_set_current_item_by_id(dd, options_window.udf->mkudffs_media_type);
+
+	return dd;
+}
+
+
+
+
+
+
+
+static cdw_id_clabel_t space_items[CDW_MKUDFFS_SPACE_MAX] = {
+	{ CDW_MKUDFFS_SPACE_UNSPECIFIED,    gettext_noop("Unspecified")  },
+	{ CDW_MKUDFFS_SPACE_FREEDBITMAP,    gettext_noop("freedbitmap")  },
+	{ CDW_MKUDFFS_SPACE_FREEDTABLE,     gettext_noop("freedtable")   },
+	{ CDW_MKUDFFS_SPACE_UNALLOCBITMAP,  gettext_noop("unallocbitmap")},
+	{ CDW_MKUDFFS_SPACE_UNALLOCTABLE,   gettext_noop("unalloctable") }
+};
+
+const char *cdw_mkudffs_option_space[CDW_MKUDFFS_SPACE_MAX] = {
+	"",
+	"freedbitmap",
+	"freedtable",
+	"unallocbitmap",
+	"unalloctable"
+};
+
+CDW_DROPDOWN *cdw_mkudffs_space_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, CDW_MKUDFFS_SPACE_MAX, space_items);
+
+	cdw_dropdown_set_current_item_by_id(dd, options_window.udf->mkudffs_space);
+
+	return dd;
+}
+
+
+
+
+
+static cdw_id_clabel_t ad_items[CDW_MKUDFFS_AD_MAX] = {
+	{ CDW_MKUDFFS_AD_UNSPECIFIED,    gettext_noop("Unspecified") },
+	{ CDW_MKUDFFS_AD_INICB,          gettext_noop("In ICB")      },
+	{ CDW_MKUDFFS_AD_SHORT,          gettext_noop("Short")       },
+	{ CDW_MKUDFFS_AD_LONG,           gettext_noop("Long")        }
+};
+
+const char *cdw_mkudffs_option_ad[CDW_MKUDFFS_AD_MAX] = {
+	"",
+	"inicb",
+	"short",
+	"long"
+};
+
+CDW_DROPDOWN *cdw_mkudffs_ad_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, CDW_MKUDFFS_AD_MAX, ad_items);
+
+	cdw_dropdown_set_current_item_by_id(dd, options_window.udf->mkudffs_ad);
+
+	return dd;
+}
+
+
+
+
+
+
+
+static cdw_id_clabel_t encoding_items[CDW_MKUDFFS_ENCODING_MAX] = {
+	{ CDW_MKUDFFS_ENCODING_UNSPECIFIED,    gettext_noop("Unspecified")    },
+	{ CDW_MKUDFFS_ENCODING_U8,             gettext_noop("8-bit Unicode")  },
+	{ CDW_MKUDFFS_ENCODING_U16,            gettext_noop("16-bit Unicode") },
+	{ CDW_MKUDFFS_ENCODING_UTF8,           gettext_noop("UTF-8")          }
+};
+
+const char *cdw_mkudffs_option_encoding[CDW_MKUDFFS_ENCODING_MAX] = {
+	"",
+	"u8",
+	"u16",
+	"utf8"
+};
+
+CDW_DROPDOWN *cdw_mkudffs_encoding_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, CDW_MKUDFFS_ENCODING_MAX, encoding_items);
+
+	cdw_dropdown_set_current_item_by_id(dd, options_window.udf->mkudffs_encoding);
+
+	return dd;
+}
+
+
+
+
+
+char *cdw_mkudffs_symlinks_text(int n_cols)
+{
+	/* 2TRANS: this is a message displayed in options panel. It is
+	   about rsync's options for handling symbolic links. "vvv" is
+	   a kind of arrow pointing downwards to said field. */
+	return cdw_string_wrap(_("You should specify options for handling of symlinks in field below vvv"), (size_t) n_cols, CDW_ALIGN_LEFT);
+}
+
+
+
+
+/* *** Second page. *** */
+
+
+
+
+
+enum {
+	f_vid_l = 0, /* Volume Identifier. */
+	f_vid_i,
+	f_vsid_l,    /* Volume Set Identifier. */
+	f_vsid_i,
+	f_fsid_l,    /* File Set Identifier. */
+	f_fsid_i
+};
+
+
+
+
+static FIELD *mkudffs_fields_p2[CDW_MKUDFFS_UDF_META_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
+
+
+
+
+/**
+   \brief Create fields that are shown on "XXX" page in options
+
+   \return CDW_OK when all fields were created (probably) without problems
+   \return CDW_GEN_ERROR if one of fields was created incorrectly
+*/
+cdw_rv_t cdw_mkudffs_options_form_p2(cdw_form_t *cdw_form, void *cdw_udf, int first_col, __attribute__((unused)) int second_col, int width_wide, __attribute__((unused)) int width_narrow)
+{
+	options_window.udf = (cdw_udf_t *) cdw_udf;
+	options_window.cdw_form_p2 = cdw_form;
+	options_window.cdw_form_p2->fields = mkudffs_fields_p2;
+	cdw_udf_t *udf = options_window.udf;
+
+	int w_vid = CDW_UDF_VID_LEN_MAX < width_wide ? CDW_UDF_VID_LEN_MAX : width_wide;
+	int w_fsid = CDW_UDF_FSID_LEN_MAX < width_wide ? CDW_UDF_FSID_LEN_MAX : width_wide;
+
+	cdw_assert (CDW_UDF_VID_LEN_MAX == 30, "ERROR: value of option has changed. Update the text message in code below.\n");
+	cdw_assert (CDW_UDF_VSID_LEN_MAX == 126, "ERROR: value of option has changed. Update the text message in code below.\n");
+	cdw_assert (CDW_UDF_FSID_LEN_MAX == 30, "ERROR: value of option has changed. Update the text message in code below.\n");
+	cdw_form_descr_t descr[] = {
+		/* type                      begin_y   begin_x     n_cols  n_lines  field enum        data1                                         data2 */
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     2,  first_col,  width_wide,  1,  f_vid_l,          _("Volume Identifier (30 chars max):"),           0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   3,  first_col,  w_vid,       1,  f_vid_i,          udf->mkudffs_vid,               CDW_UDF_VID_LEN_MAX },
+
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     4,  first_col,  width_wide,  1,  f_vsid_l,         _("Volume Set Identifier (126 chars max):"),      0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   5,  first_col,  width_wide,  1,  f_vsid_i,         udf->mkudffs_vsid,             CDW_UDF_VSID_LEN_MAX },
+
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     6,  first_col,  width_wide,  1,  f_fsid_l,         _("File Set Identifier (30 chars max):"),         0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   7,  first_col,  w_fsid,      1,  f_fsid_i,         udf->mkudffs_fsid,             CDW_UDF_FSID_LEN_MAX },
+
+		/* guard */
+		{ -1,                              0,  0,          0,           0,  0,                (void *) NULL,                                                          0 }};
+
+
+	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to convert form description to form\n");
+		return CDW_ERROR;
+	} else {
+		cdw_form_bind_input_and_label(cdw_form, f_vid_i, f_vid_l);
+		cdw_form_bind_input_and_label(cdw_form, f_vsid_i, f_vsid_l);
+		cdw_form_bind_input_and_label(cdw_form, f_fsid_i, f_fsid_l);
+
+		return CDW_OK;
+	}
+}
+
+
+
+
+
+cdw_rv_t cdw_mkudffs_options_validate_p2(cdw_udf_t *udf, int *fi)
+{
+	cdw_rv_t crv = cdw_string_security_parser(udf->mkudffs_vid, (char *) NULL);
+	if (crv == CDW_NO) {
+		*fi = f_vid_i;
+		return CDW_NO;
+	}
+
+	crv = cdw_string_security_parser(udf->mkudffs_vsid, (char *) NULL);
+	if (crv == CDW_NO) {
+		*fi = f_vsid_i;
+		return CDW_NO;
+		}
+
+	crv = cdw_string_security_parser(udf->mkudffs_fsid, (char *) NULL);
+	if (crv == CDW_NO) {
+		*fi = f_fsid_i;
+		return CDW_NO;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_mkudffs_options_save_p2(cdw_udf_t *udf, cdw_form_t *cdw_form)
+{
+	const char *s = NULL;
+
+	s = cdw_form_get_string(cdw_form, f_vid_i);
+	strncpy(udf->mkudffs_vid, s, CDW_UDF_VID_LEN_MAX);
+	        udf->mkudffs_vid[CDW_UDF_VID_LEN_MAX] = '\0';
+
+	s = cdw_form_get_string(cdw_form, f_vsid_i);
+	strncpy(udf->mkudffs_vsid, s, CDW_UDF_VSID_LEN_MAX);
+	        udf->mkudffs_vsid[CDW_UDF_VSID_LEN_MAX] = '\0';
+
+	s = cdw_form_get_string(cdw_form, f_fsid_i);
+	strncpy(udf->mkudffs_fsid, s, CDW_UDF_FSID_LEN_MAX);
+	        udf->mkudffs_fsid[CDW_UDF_FSID_LEN_MAX] = '\0';
+
+
+	return CDW_OK;
+}
+
+
+
+
+
+int cdw_mkudffs_options_on_mount_point(__attribute__((unused)) void *dummy1, __attribute__((unused)) void *dummy2)
+{
+	/* 2TRANS: this is title of dialog window */
+	cdw_rv_t crv = cdw_fs_ui_file_picker(_("Path to mount point"),
+					     /* 2TRANS: this is message in dialog window;
+					     below it there is an input field where user can
+					     enter path to ISO9660 or UDF image file */
+					     _("Please enter FULL path to mount point (mount directory):"),
+					     &(options_window.udf->mount_point),
+					     CDW_FS_DIR, R_OK | W_OK, CDW_FS_EXISTING);
+
+	cdw_main_window_wrefresh();
+
+	redrawwin(options_window.cdw_form_p1->subwindow);
+	wrefresh(options_window.cdw_form_p1->subwindow);
+	redrawwin(options_window.cdw_form_p1->window);
+	wrefresh(options_window.cdw_form_p1->window);
+
+
+	char *fp = options_window.udf->mount_point;
+	if (crv == CDW_OK) {
+		int rv = set_field_buffer(options_window.cdw_form_p1->fields[f_mount_point_i], 0, fp);
+		if (rv != E_OK) {
+			cdw_vdm ("ERROR: failed to set field buffer with string = \"%s\"\n", fp);
+		} else {
+			form_driver(options_window.cdw_form_p1->form, REQ_END_LINE);
+		}
+		cdw_vdm ("INFO: file picker returns \"%s\"\n", fp);
+		return 1;
+	} else if (crv == CDW_CANCEL) {
+		cdw_vdm ("INFO: pressed escape in file picker, fullpath is \"%s\"\n", fp);
+		return 0;
+	} else {
+		cdw_vdm ("INFO: file picker returns CDW_ERROR, fullpath is \"%s\"\n", fp);
+		return 0;
+	}
+}
diff -Naur orig/src/external_tools/cdw_mkudffs_options.h patched/src/external_tools/cdw_mkudffs_options.h
--- orig/src/external_tools/cdw_mkudffs_options.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/external_tools/cdw_mkudffs_options.h	2014-03-19 20:41:21.000000000 +0100
@@ -0,0 +1,93 @@
+#ifndef H_CDW_MKUDFFS_OPTIONS
+#define H_CDW_MKUDFFS_OPTIONS
+
+#include "main.h"
+#include "cdw_form.h"
+#include "cdw_udf.h"
+
+/* Does not include extra field for guard. */
+#define CDW_MKUDFFS_UDF_MAIN_OPTIONS_N_FIELDS   26
+#define CDW_MKUDFFS_UDF_META_OPTIONS_N_FIELDS    6
+
+
+
+#define CDW_MKUDFFS_BLOCKSIZE_MAX     4
+enum {
+	CDW_MKUDFFS_BLOCKSIZE_UNSPECIFIED = 0,
+	CDW_MKUDFFS_BLOCKSIZE_1024,
+	CDW_MKUDFFS_BLOCKSIZE_2048,
+	CDW_MKUDFFS_BLOCKSIZE_4096
+};
+
+#define CDW_MKUDFFS_UDFREV_MAX       5
+enum {
+	CDW_MKUDFFS_UDFREV_UNSPECIFIED = 0,
+	CDW_MKUDFFS_UDFREV_0x0201,
+	CDW_MKUDFFS_UDFREV_0x0200,
+	CDW_MKUDFFS_UDFREV_0x0150,
+	CDW_MKUDFFS_UDFREV_0x0102
+};
+
+#define CDW_MKUDFFS_STRATEGY_MAX     3
+enum {
+	CDW_MKUDFFS_STRATEGY_UNSPECIFIED = 0,
+	CDW_MKUDFFS_STRATEGY_4,
+	CDW_MKUDFFS_STRATEGY_4096
+};
+
+#define CDW_MKUDFFS_SPARTABLE_MAX     5
+enum {
+	CDW_MKUDFFS_SPARTABLE_UNSPECIFIED = 0,
+	CDW_MKUDFFS_SPARTABLE_1,
+	CDW_MKUDFFS_SPARTABLE_2,
+	CDW_MKUDFFS_SPARTABLE_3,
+	CDW_MKUDFFS_SPARTABLE_4
+};
+
+#define CDW_MKUDFFS_MEDIA_TYPE_MAX     7
+enum {
+	CDW_MKUDFFS_MEDIA_TYPE_UNSPECIFIED = 0,
+	CDW_MKUDFFS_MEDIA_TYPE_HD,
+	CDW_MKUDFFS_MEDIA_TYPE_DVD,
+	CDW_MKUDFFS_MEDIA_TYPE_DVDRAM,
+	CDW_MKUDFFS_MEDIA_TYPE_WORM,
+	CDW_MKUDFFS_MEDIA_TYPE_MO,
+	CDW_MKUDFFS_MEDIA_TYPE_CDRW
+};
+
+#define CDW_MKUDFFS_SPACE_MAX     5
+enum {
+	CDW_MKUDFFS_SPACE_UNSPECIFIED = 0,
+	CDW_MKUDFFS_SPACE_FREEDBITMAP,
+	CDW_MKUDFFS_SPACE_FREEDTABLE,
+	CDW_MKUDFFS_SPACE_UNALLOCBITMAP,
+	CDW_MKUDFFS_SPACE_UNALLOCTABLE
+};
+#define CDW_MKUDFFS_AD_MAX     4
+enum {
+	CDW_MKUDFFS_AD_UNSPECIFIED = 0,
+	CDW_MKUDFFS_AD_INICB,
+	CDW_MKUDFFS_AD_SHORT,
+	CDW_MKUDFFS_AD_LONG
+};
+
+#define CDW_MKUDFFS_ENCODING_MAX     4
+enum {
+	CDW_MKUDFFS_ENCODING_UNSPECIFIED = 0,
+	CDW_MKUDFFS_ENCODING_U8,
+	CDW_MKUDFFS_ENCODING_U16,
+	CDW_MKUDFFS_ENCODING_UTF8
+};
+
+
+cdw_rv_t cdw_mkudffs_options_form_p1(cdw_form_t *cdw_form, void *cdw_udf, int first_col, int second_col, int width_wide, int width_narrow);
+cdw_rv_t cdw_mkudffs_options_validate_p1(cdw_udf_t *udf, int *fi);
+cdw_rv_t cdw_mkudffs_options_save_p1(cdw_udf_t *udf, cdw_form_t *cdw_form);
+
+cdw_rv_t cdw_mkudffs_options_form_p2(cdw_form_t *cdw_form, void *cdw_udf, int first_col, int second_col, int width_wide, int width_narrow);
+cdw_rv_t cdw_mkudffs_options_validate_p2(cdw_udf_t *udf, int *fi);
+cdw_rv_t cdw_mkudffs_options_save_p2(cdw_udf_t *udf, cdw_form_t *cdw_form);
+
+
+
+#endif /* H_CDW_MKUDFFS_OPTIONS */
diff -Naur orig/src/external_tools/cdw_mkudffs_regex.c patched/src/external_tools/cdw_mkudffs_regex.c
--- orig/src/external_tools/cdw_mkudffs_regex.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/external_tools/cdw_mkudffs_regex.c	2014-04-06 23:06:06.000000000 +0200
@@ -0,0 +1,356 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+   \file cdw_mkudffs_regex.c
+
+   Regex code for tools used to create UDF file system: mkudffs and
+   its helpers.
+
+   There is too little code to create separate *.c file for each tool,
+   so I'm putting everything into this single file.
+*/
+
+
+
+
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "cdw_thread.h" /* PIPE_BUFFER_SIZE */
+#include "cdw_regex_dispatch.h"
+#include "cdw_debug.h"
+#include "cdw_mkudffs_regex.h"
+#include "cdw_config.h"
+#include "cdw_processwin.h"
+#include "cdw_logging.h"
+#include "gettext.h"
+
+
+extern char stdout_pipe_buffer[PIPE_BUFFER_SIZE + 1];
+extern char stderr_pipe_buffer[PIPE_BUFFER_SIZE + 1];
+
+
+extern cdw_config_t global_config;
+extern cdw_task_t *thread_task;
+
+/* stdout */
+static int cdw_mkudffs_handle_rsync_progress(regex_t *regex, regmatch_t *matches);
+
+/* stderr */
+static int cdw_mkudffs_handle_sudo_password(regex_t *regex, regmatch_t *matches);
+static int cdw_mkudffs_handle_segmentation_fault(regex_t *regex, regmatch_t *matches);
+static int cdw_mkudffs_handle_mount_failure(regex_t *regex, regmatch_t *matches);
+static int cdw_mkudffs_handle_umount_not_mounted(regex_t *regex, regmatch_t *matches);
+static int cdw_mkudffs_handle_rsync_no_space_left(regex_t *regex, regmatch_t *matches);
+
+
+
+
+static cdw_regex_t stdout_regex[] = {
+	{ "rsync progress", 15001,
+	  /*  "92,569,600  22%   44.15MB/s    0:00:07" */
+	  "([0-9]+)%",
+	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
+	  cdw_mkudffs_handle_rsync_progress },
+
+	{ "table guard", -1,
+	  /* guard: debug_id = -1 */
+	  "",
+	  (regex_t *) NULL, (regmatch_t *) NULL, 0,
+	  (cdw_regex_handler_t) NULL }
+};
+
+
+
+
+
+static cdw_regex_t stderr_regex[] = {
+	{ "sudo password", 16001,
+	  /*  "sudo: a password is required" */
+	  "^sudo: a password",
+	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
+	  cdw_mkudffs_handle_sudo_password },
+
+	{ "segmentation fault", 16002,
+	  /*  "Segmentation fault" */
+	  "^Segmentation fault",
+	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
+	  cdw_mkudffs_handle_segmentation_fault },
+
+	{ "mount: wrong", 16003,
+	  /* "mount: wrong fs type, bad option, bad superblock on /dev/loop0"... */
+	  "^mount: wrong fs type, bad option",
+	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
+	  cdw_mkudffs_handle_mount_failure },
+
+	{ "not mounted", 16004,
+	  /*  "umount: /home/acerion/udf: not mounted" */
+	  "^umount: (.+): not mounted",
+	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
+	  cdw_mkudffs_handle_umount_not_mounted },
+
+	{ "mount: according", 16005,
+	  /* "mount: according to mtab /home/acerion/u21.udf is already mounted on /home/acerion/udf as loop" */
+	  "^mount: according to mtab",
+	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
+	  cdw_mkudffs_handle_mount_failure },
+
+	{ "rsync: no space left", 16006,
+	  /* "rsync: write failed on "/home/acerion/udf/big_file.txt": No space left on device (28)" */
+	  "^rsync: (.+)o space left on device",
+	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
+	  cdw_mkudffs_handle_rsync_no_space_left },
+
+	{ "table guard", -1,
+	  /* guard: debug_id = -1 */
+	  "",
+	  (regex_t *) NULL, (regmatch_t *) NULL, 0,
+	  (cdw_regex_handler_t) NULL }
+};
+
+
+
+
+
+/**
+   \brief Do some initialization and call cdw_regex_prepare_regexes_table() for stdout regexes table
+*/
+void cdw_mkudffs_stdout_regex_prepare(void)
+{
+	cdw_rv_t crv = cdw_regex_prepare_regexes_table(stdout_regex);
+	if (crv != CDW_OK) {
+		cdw_vdm("ERROR: failed to prepare regexes table for stdout\n");
+	}
+	return;
+}
+
+
+
+
+
+/**
+   \brief Do some initialization and call cdw_regex_execute_regexes_table()
+   for stdout regexes table and stdout pipe buffer.
+*/
+void cdw_mkudffs_stdout_regex_execute(void)
+{
+	stdout_pipe_buffer[PIPE_BUFFER_SIZE] = '\0';
+	cdw_regex_execute_regexes_table(stdout_regex, stdout_pipe_buffer);
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Call cdw_regex_clean_up_regexes_table() for stdout regexes table
+*/
+void cdw_mkudffs_stdout_regex_destroy(void)
+{
+	cdw_regex_clean_up_regexes_table(stdout_regex);
+	return;
+}
+
+
+
+
+
+/**
+   \brief Do some initialization and call cdw_regex_prepare_regexes_table() for stderr regexes table
+*/
+void cdw_mkudffs_stderr_regex_prepare(void)
+{
+	cdw_rv_t crv = cdw_regex_prepare_regexes_table(stderr_regex);
+	if (crv != CDW_OK) {
+		cdw_vdm("ERROR: failed to prepare regexes table for stderr\n");
+	}
+	return;
+}
+
+
+
+
+
+/**
+   \brief Do some initialization and call cdw_regex_execute_regexes_table()
+   for stderr regexes table and stderr pipe buffer.
+*/
+void cdw_mkudffs_stderr_regex_execute(void)
+{
+	stderr_pipe_buffer[PIPE_BUFFER_SIZE] = '\0';
+	cdw_regex_execute_regexes_table(stderr_regex, stderr_pipe_buffer);
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Call cdw_regex_clean_up_regexes_table() for stderr regexes table
+*/
+void cdw_mkudffs_stderr_regex_destroy(void)
+{
+	cdw_regex_clean_up_regexes_table(stderr_regex);
+	return;
+}
+
+
+
+
+
+/**
+   sudo is prompting user for password
+
+   cdw doesn't provide any way to pass password to sudo. User should
+   know that "sudo mount" and "sudo umount" must be set up to be
+   invoked without prompting for password.
+*/
+int cdw_mkudffs_handle_sudo_password(__attribute__((unused)) regex_t *regex, __attribute__((unused)) regmatch_t *matches)
+{
+	/* There is a regex defined in regex table, but we don't have
+	   to extract any information from it.
+
+	   Terminate child process (sudo prompting for password) by
+	   sending Ctrl-D (EOT) to it. */
+
+	thread_task->tool_status.sudo |= CDW_TOOL_STATUS_SUDO_PASSWORD_PROMPT;
+
+	cdw_rv_t crv = cdw_thread_send_key_to_child_process(CDW_KEY_EOT);
+	if (crv == CDW_OK) {
+		return 0;
+	} else {
+		cdw_vdm ("ERROR: sending key to child process failed\n");
+		return -1;
+	}
+}
+
+
+
+
+
+/**
+   Segmentation fault
+
+   Most probably mkudffs, but we won't investigate this further.
+*/
+int cdw_mkudffs_handle_segmentation_fault(__attribute__((unused)) regex_t *regex, __attribute__((unused)) regmatch_t *matches)
+{
+	thread_task->tool_status.mkudffs_general |= CDW_TOOL_STATUS_MKUDFFS_GENERAL_SEGMENTATION_FAULT;
+
+	return 0;
+}
+
+
+
+
+
+int cdw_mkudffs_handle_rsync_progress(regex_t *regex, regmatch_t *matches)
+{
+	/* regex for capturing progress information:
+               1
+	   "([0-9]+)%" */
+
+	cdw_regex_assert_subex_number(regex->re_nsub, 1);
+
+	int done_percent = 0;
+
+	for (unsigned int i = 0; i <= regex->re_nsub; i++) {
+		if (i != 1) {
+			continue;
+		}
+		char submatch[PIPE_BUFFER_SIZE + 1];
+		int len = cdw_regex_get_submatch(matches, i, stdout_pipe_buffer, submatch);
+		if (len == -1) {
+			cdw_vdm ("ERROR: len of subexpr %d is negative: %d\n", i, len);
+			continue;
+		}
+
+		if (i == 1) {
+			done_percent = atoi(submatch);
+			cdw_vdm ("INFO: submatch %d, done percent = \"%s\" -> %d\n", i, submatch, done_percent);
+		} else {
+			cdw_vdm ("WARNING: unexpected submatch %d = %s\n", i, submatch);
+		}
+	}
+
+	cdw_processwin_display_progress((long) done_percent, 100, (char *) NULL);
+
+	cdw_processwin_wrefresh();
+
+	return 0;
+}
+
+
+
+
+
+/* Failed to mount UDF file system under specified directory. Most
+   probably problems with UDF file system in image file. */
+int cdw_mkudffs_handle_mount_failure(__attribute__((unused)) regex_t *regex, __attribute__((unused)) regmatch_t *matches)
+{
+	thread_task->tool_status.mount |= CDW_TOOL_STATUS_MOUNT_FAILURE;
+
+	return 0;
+}
+
+
+
+
+
+/* Trying to umount a directory that is not mounted. Most probably
+   problems with creating UDF file system caused failure to mount, so
+   there is nothing to umount. */
+int cdw_mkudffs_handle_umount_not_mounted(regex_t *regex, regmatch_t *matches)
+{
+	/* regex for capturing "not mounted" message
+	              1
+	  "^umount: (.+): not mounted" */
+
+	cdw_regex_assert_subex_number(regex->re_nsub, 1);
+
+	char submatch[PIPE_BUFFER_SIZE + 1];
+	int len = cdw_regex_get_submatch(matches, 1, stderr_pipe_buffer, submatch);
+	if (len == -1) {
+		cdw_vdm ("ERROR: len of subexpr %d is negative: %d\n", 1, len);
+		return -1;
+	}
+
+	cdw_logging_write(_("ERROR: mount directory \"%s\" has not been mounted properly by cdw.\n"), submatch);
+
+	thread_task->tool_status.umount |= CDW_TOOL_STATUS_UMOUNT_NOT_MOUNTED;
+
+	return 0;
+}
+
+
+
+
+
+int cdw_mkudffs_handle_rsync_no_space_left(__attribute__((unused)) regex_t *regex, __attribute__((unused)) regmatch_t *matches)
+{
+	thread_task->tool_status.rsync |= CDW_TOOL_STATUS_RSYNC_NO_SPACE_LEFT;
+
+	return 0;
+}
diff -Naur orig/src/external_tools/cdw_mkudffs_regex.h patched/src/external_tools/cdw_mkudffs_regex.h
--- orig/src/external_tools/cdw_mkudffs_regex.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/external_tools/cdw_mkudffs_regex.h	2014-02-09 21:15:23.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef H_CDW_MKUDFFS_REGEX
+#define H_CDW_MKUDFFS_REGEX
+
+void cdw_mkudffs_stdout_regex_prepare(void);
+void cdw_mkudffs_stderr_regex_prepare(void);
+
+void cdw_mkudffs_stdout_regex_execute(void);
+void cdw_mkudffs_stderr_regex_execute(void);
+
+void cdw_mkudffs_stdout_regex_destroy(void);
+void cdw_mkudffs_stderr_regex_destroy(void);
+
+
+#endif /* #ifndef H_CDW_MKUDFFS_REGEX */
diff -Naur orig/src/external_tools/cdw_regex_dispatch.c patched/src/external_tools/cdw_regex_dispatch.c
--- orig/src/external_tools/cdw_regex_dispatch.c	2012-02-26 15:28:33.000000000 +0100
+++ patched/src/external_tools/cdw_regex_dispatch.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
@@ -168,6 +168,7 @@
 #include "cdw_dvd_rw_format_regex.h"
 #include "cdw_digest_regex.h"
 #include "cdw_xorriso_regex.h"
+#include "cdw_mkudffs_regex.h"
 #include "cdw_ext_tools.h"
 
 
@@ -189,9 +190,10 @@
 	mkisofs_stdout_regexp_prepare,
 	cdrecord_stdout_regexp_prepare,
 	growisofs_stdout_regexp_prepare,
-	(cdw_regex_function_t) NULL, /* we don't capture data on dvd+rw-format stdout */
+	(cdw_regex_function_t) NULL,    /* we don't capture data on dvd+rw-format stdout */
 	dvd_rw_mediainfo_stdout_regexp_prepare,
 	cdw_xorriso_stdout_regex_prepare,
+	cdw_mkudffs_stdout_regex_prepare,
 	cdw_digest_stdout_regex_prepare
 };
 
@@ -199,47 +201,56 @@
 	mkisofs_stdout_regexp_execute,
 	cdrecord_stdout_regexp_execute,
 	growisofs_stdout_regexp_execute,
-	(cdw_regex_function_t) NULL, /* we don't capture data on dvd+rw-format stdout */
+	(cdw_regex_function_t) NULL,    /* we don't capture data on dvd+rw-format stdout */
 	dvd_rw_mediainfo_stdout_regexp_execute,
 	cdw_xorriso_stdout_regex_execute,
-	cdw_digest_stdout_regex_execute };
+	cdw_mkudffs_stdout_regex_execute,
+	cdw_digest_stdout_regex_execute
+};
 
 static cdw_regex_function_t stdout_destroyers[CDW_EXT_TOOLS_N_TOOLS] = {
 	mkisofs_stdout_regexp_destroy,
 	cdrecord_stdout_regexp_destroy,
 	growisofs_stdout_regexp_destroy,
-	(cdw_regex_function_t) NULL, /* we don't capture data on dvd+rw-format stdout */
+	(cdw_regex_function_t) NULL,    /* we don't capture data on dvd+rw-format stdout */
 	dvd_rw_mediainfo_stdout_regexp_destroy,
 	cdw_xorriso_stdout_regex_destroy,
-	cdw_digest_stdout_regex_destroy };
+	cdw_mkudffs_stdout_regex_destroy,
+	cdw_digest_stdout_regex_destroy
+};
 
 static cdw_regex_function_t stderr_preparers[CDW_EXT_TOOLS_N_TOOLS] = {
 	mkisofs_stderr_regexp_prepare,
 	cdrecord_stderr_regexp_prepare,
 	growisofs_stderr_regexp_prepare,
 	cdw_dvd_rw_format_stderr_regexp_prepare,
-	(cdw_regex_function_t) NULL,     /* we don't capture data on dvd+rw-mediainfo stderr */
+	(cdw_regex_function_t) NULL,    /* we don't capture data on dvd+rw-mediainfo stderr */
 	cdw_xorriso_stderr_regex_prepare,
-	(cdw_regex_function_t) NULL };   /* we don't capture data on digest tool stderr */
-
+	cdw_mkudffs_stderr_regex_prepare,
+	(cdw_regex_function_t) NULL     /* we don't capture data on digest tool stderr */
+};
 
 static cdw_regex_function_t stderr_executers[CDW_EXT_TOOLS_N_TOOLS] = {
 	mkisofs_stderr_regexp_execute,
 	cdrecord_stderr_regexp_execute,
 	growisofs_stderr_regexp_execute,
 	cdw_dvd_rw_format_stderr_regexp_execute,
-	(cdw_regex_function_t) NULL,     /* we don't capture data on dvd+rw-mediainfo stderr */
+	(cdw_regex_function_t) NULL,    /* we don't capture data on dvd+rw-mediainfo stderr */
 	cdw_xorriso_stderr_regex_execute,
-	(cdw_regex_function_t) NULL };   /* we don't capture data on digest tool stderr */
+	cdw_mkudffs_stderr_regex_execute,
+	(cdw_regex_function_t) NULL     /* we don't capture data on digest tool stderr */
+};
 
 static cdw_regex_function_t stderr_destroyers[CDW_EXT_TOOLS_N_TOOLS] = {
 	mkisofs_stderr_regexp_destroy,
 	cdrecord_stderr_regexp_destroy,
 	growisofs_stderr_regexp_destroy,
 	cdw_dvd_rw_format_stderr_regexp_destroy,
-	(cdw_regex_function_t) NULL,     /* we don't capture data on dvd+rw-mediainfo stderr */
+	(cdw_regex_function_t) NULL,    /* we don't capture data on dvd+rw-mediainfo stderr */
 	cdw_xorriso_stderr_regex_destroy,
-	(cdw_regex_function_t) NULL };   /* we don't capture data on digest tool stderr */
+	cdw_mkudffs_stderr_regex_destroy,
+	(cdw_regex_function_t) NULL     /* we don't capture data on digest tool stderr */
+};
 
 
 
@@ -250,7 +261,8 @@
 }
 void cdw_regex_stdout_execute(const cdw_task_t *task)
 {
-	cdw_sdm ("INFO: STDOUT PIPE: %s\n", stdout_pipe_buffer);
+	cdw_vdm ("INFO: task id = %lld\n", task->id);
+	cdw_vdm ("INFO: STDOUT PIPE: %s\n", stdout_pipe_buffer);
 	cdw_regex_caller(task, stdout_executers, cdw_stdout);
 	return;
 }
@@ -321,7 +333,7 @@
 			cdw_vdm ("INFO: %s: dispatching to mkisofs\n", file_label);
 			functions[CDW_TOOL_MKISOFS]();
 		}
-	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+	} else if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
 		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
 			cdw_vdm ("INFO: %s: dispatching to mkisofs\n", file_label);
 			functions[CDW_TOOL_MKISOFS]();
@@ -368,13 +380,13 @@
 		} else {
 			;
 		} /* we don't capture data on md5sum stderr */
+	} else if (task->id == CDW_TASK_CREATE_IMAGE_UDF) {
+		cdw_vdm ("INFO: %s: dispatching to %s\n", file_label, cdw_ext_tools_get_tool_name(task->create_image.tool.id));
+		cdw_assert (functions[CDW_TOOL_MKUDFFS], "ERROR: a function for MKUDFFS is NULL\n");
+		functions[CDW_TOOL_MKUDFFS]();
 	} else {
 		cdw_assert (0, "ERROR: unknown task id %lld\n", task->id);
 	}
 
 	return;
 }
-
-
-
-
diff -Naur orig/src/external_tools/cdw_thread.c patched/src/external_tools/cdw_thread.c
--- orig/src/external_tools/cdw_thread.c	2012-03-28 20:48:52.000000000 +0200
+++ patched/src/external_tools/cdw_thread.c	2014-04-06 23:02:52.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -23,9 +23,9 @@
  * \brief Code creating threads and processes used in communication
  *        with external tools
  *
- * Main function in this file is run_command(): its main tasks are:
+ * Main function in this file is cdw_thread_run_command(): its main tasks are:
  * \li creating pairs of sockets for communication with child process
- *     (run_command() calls socketpair())
+ *     (cdw_thread_run_command() calls socketpair())
  * \li creating child process using fork()
  * \li replacing child process with external tool process using exec() call
  *     (this happens in child process)
@@ -33,7 +33,7 @@
  *     child process (this happens in parent process)
  * \li waiting for thread functions to return
  *
- * run_command() hides threads and exec() from rest of project code.
+ * cdw_thread_run_command() hides threads and exec() from rest of project code.
  *
  * Thread functions are read_child_stdout() and read_child_stderr() (and
  * calculate_digest.read_and_write() - see below). They are executed in parent
@@ -72,6 +72,10 @@
 #include <sys/socket.h>
 #include <errno.h>
 
+/* wait() */
+#include <sys/types.h>
+#include <sys/wait.h>
+
 #include "gettext.h"
 #include "cdw_logging.h"
 #include "cdw_regex_dispatch.h"
@@ -121,7 +125,8 @@
 /* two generic thread functions */
 static void *read_child_stdout(void *dummy);
 static void *read_child_stderr(void *dummy);
-static void cdw_thread_set_child_env(void);
+static void  cdw_thread_wait(cdw_task_t *thread_task);
+static void  cdw_thread_set_child_env(void);
 
 #define CDW_THREAD_EVAL_READ(m_char_buf, m_i, m_pipe_buf, m_new_lines, m_f) \
 	cdw_assert (m_f == cdw_stdout || m_f == cdw_stderr, "ERROR: incorrect file %d\n", m_f);	\
@@ -270,18 +275,20 @@
    Function makes 'task' available as 'thread_task' so that thread functions
    (working in parent code) and regexp functions can set task->tool_status.
 
+   TODO: make the function return values of type cdw_rv_t, for consistency.
+
    \param command - name of program (tool) that you want to run + it's arguments
    \param task - variable describing current task
 
    \return 0 on success
    \return -1 on failure
 */
-int run_command(const char *command, cdw_task_t *task)
+int cdw_thread_run_command(const char *command, cdw_task_t *task)
 {
 	thread_task = task;
-	cdw_sdm ("non-masked tool_status = 0x%04x\n", task->tool_status);
+	cdw_sdm ("INFO: non-masked tool_status = 0x%04x\n", task->tool_status);
 
-	cdw_logging_write_separator();
+	//cdw_logging_write_separator();
 
 	time0 = time(NULL);
 	/* 2TRANS: this is time stamp (current time) printed to log file;
@@ -296,7 +303,7 @@
 	cdw_logging_write(_("Full command issued to shell: \"%s\"\n"), command);
 	/* 2TRANS: this is message printed in log file; 'external tools' are
 	   programs like cdrecord or mkisofs */
-	cdw_logging_write(_("Output from external tool(s) follow:\n\n"));
+	cdw_logging_write(_("Output from external tool(s):\n\n"));
 
 	if ((socketpair(AF_UNIX, SOCK_STREAM, 0, stdin_pipe) == 0)
 		    && (socketpair(AF_UNIX, SOCK_STREAM, 0, stdout_pipe) == 0)
@@ -448,19 +455,38 @@
 				cdw_sdm ("INFO: created thread read_child_stdout\n");
 			}
 
-			/* threads are created; now we must wait for them to complete
-			   their job and return (both of them);
-			   when thread functions end we can execute pthread_join()s */
+
+			/* First let the child process exit, then wait
+			   for threads reading from stdout/stderr of
+			   the exited child process. This order seems
+			   to be better: the functions return on
+			   reading EOF, which in turn (if memory
+			   serves me well) is pushed through the pipe
+			   on child process exiting. So first wait for
+			   the child (wait()), and then wait for
+			   threads (pthread_join()). */
+
+
+			/* Perhaps for some external tool we won't be
+			   able to parse its stdout/stderr output. Let's at
+			   least have exit code of the tool. */
+			cdw_thread_wait(thread_task);
+
+
+			/* Threads have been created above. When
+			   thread functions end we can execute
+			   pthread_join()s */
 			pthread_join(thread_2, NULL);
 			pthread_join(thread_1, NULL);
 
-			/* this file descriptor most probably has been
+
+			/* This file descriptor most probably has been
 			   already closed by read/write function (otherwise
 			   child process would still wait for data on open
 			   stdin, so it would still be active, so thread would
-			   be still active and could not have been joined;
+			   be still active and could not have been joined).;
 
-			   but just to be sure: close it again;
+			   But just to be sure: close it again;
 			   closing file equals marking end of input (eof) for
 			   external processes (like md5sum) waiting for more data */
 			close(stdin_pipe[PARENTS_END]);
@@ -478,6 +504,24 @@
 }
 
 
+
+
+
+void cdw_thread_wait(cdw_task_t *task)
+{
+	wait(&(task->tool_status.child_exit_status_raw));
+	if (WIFEXITED (task->tool_status.child_exit_status_raw)) {
+		cdw_vdm ("INFO: child process called exit(%d)\n", WEXITSTATUS(task->tool_status.child_exit_status_raw));
+	} else {
+		cdw_vdm ("ERROR: child process terminated by signal %d\n", WTERMSIG (task->tool_status.child_exit_status_raw));
+	}
+
+	task->tool_status.child_exit_status = WEXITSTATUS(task->tool_status.child_exit_status_raw);
+
+	return;
+}
+
+
 
 
 
diff -Naur orig/src/external_tools/cdw_thread.h patched/src/external_tools/cdw_thread.h
--- orig/src/external_tools/cdw_thread.h	2010-05-08 23:23:24.000000000 +0200
+++ patched/src/external_tools/cdw_thread.h	2014-02-14 23:15:03.000000000 +0100
@@ -11,7 +11,7 @@
 
 
 
-int run_command(const char *command, cdw_task_t *task);
+int      cdw_thread_run_command(const char *command, cdw_task_t *task);
 cdw_rv_t cdw_thread_send_key_to_child_process(int key);
 
 #endif /* #ifndef H_CDW_THREAD */
diff -Naur orig/src/external_tools/cdw_which.c patched/src/external_tools/cdw_which.c
--- orig/src/external_tools/cdw_which.c	2012-03-03 21:08:03.000000000 +0100
+++ patched/src/external_tools/cdw_which.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _GNU_SOURCE /* asprintf() */
diff -Naur orig/src/external_tools/cdw_xorriso.c patched/src/external_tools/cdw_xorriso.c
--- orig/src/external_tools/cdw_xorriso.c	2012-03-27 21:21:28.000000000 +0200
+++ patched/src/external_tools/cdw_xorriso.c	2014-04-12 20:25:56.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
@@ -23,7 +23,7 @@
    \brief Functions creating calls to xorriso and calling xorriso
 
    Functions for creating xorriso command line strings, creating string
-   with xorriso parameters, and for calling run_command()
+   with xorriso parameters, and for calling cdw_thread_run_command()
    with prepared command line string.
 */
 
@@ -52,7 +52,7 @@
 static char *cdw_xorriso_create_meta_information_string(cdw_task_t *task);
 static char *cdw_xorriso_create_command_create_iso_fs(cdw_task_t *task);
 static char *cdw_xorriso_create_command_burn_from_files(cdw_task_t *task, cdw_disc_t *disc);
-static char *cdw_xorriso_create_command_burn_from_image(cdw_task_t *task);
+static char *cdw_xorriso_create_command_burn_from_image(cdw_task_t *task, cdw_disc_t *disc);
 static char *cdw_xorriso_create_command_erase(cdw_task_t *task, cdw_disc_t *disc);
 static bool  cdw_xorriso_close_disc(cdw_task_t *task);
 
@@ -76,12 +76,12 @@
 cdw_rv_t cdw_xorriso_run_task(cdw_task_t *task, cdw_disc_t *disc)
 {
 	char *command = (char *) NULL;
-	if (task->id == CDW_TASK_CREATE_IMAGE) {
+	if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
 		command = cdw_xorriso_create_command_create_image(task);
 	} else if (task->id == CDW_TASK_BURN_FROM_FILES) {
 		command = cdw_xorriso_create_command_burn_from_files(task, disc);
 	} else if (task->id == CDW_TASK_BURN_FROM_IMAGE) {
-		command = cdw_xorriso_create_command_burn_from_image(task);
+		command = cdw_xorriso_create_command_burn_from_image(task, disc);
 	} else if (task->id == CDW_TASK_MEDIA_INFO) {
 		const char *drive_path = cdw_drive_get_drive_fullpath();
 		cdw_rv_t crv = cdw_libburn_get_meta_info(disc, drive_path);
@@ -96,11 +96,8 @@
 		cdw_assert (0, "ERROR: incorrect task id %lld\n", task->id);
 	}
 
-	if (command == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to create xorriso command string\n");
-		return CDW_ERROR;
-	} else {
-		int rv = run_command(command, task);
+	if (command) {
+		int rv = cdw_thread_run_command(command, task);
 		free(command);
 		command = (char *) NULL;
 
@@ -109,6 +106,9 @@
 		} else {
 			return CDW_ERROR;
 		}
+	} else {
+		cdw_vdm ("ERROR: failed to create xorriso command string\n");
+		return CDW_ERROR;
 	}
 }
 
@@ -118,20 +118,19 @@
 
 char *cdw_xorriso_create_command_create_image(cdw_task_t *task)
 {
-	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE,
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_ISO9660,
 		    "ERROR: incorrect task id: %lld\n", task->id);
 	cdw_assert (task->create_image.tool.id == CDW_TOOL_XORRISO,
 		    "ERROR: incorrect tool id: %lld\n", task->create_image.tool.id);
-	cdw_assert (task->create_image.tool.label != (char *) NULL,
-		    "ERROR: tool fullpath is NULL\n");
+	cdw_assert (task->create_image.tool.label, "ERROR: tool fullpath is NULL\n");
 
 	char *fs_command = cdw_xorriso_create_command_create_iso_fs(task);
-	if (fs_command == (char *) NULL) {
+	if (!fs_command) {
 		cdw_vdm ("ERROR: failed to create string with IS9660 parameters\n");
 		return (char *) NULL;
 	}
 	char *command = cdw_string_concat(task->create_image.tool.label,
-					  " -outdev ", task->create_image.iso9660_file_fullpath, " ",
+					  " -outdev ", task->image_file_fullpath, " ",
 					  fs_command,
 					  " -blank fast ", /* to start writing to image from scratch */
 
@@ -141,12 +140,12 @@
 	free(fs_command);
 	fs_command = (char *) NULL;
 
-	if (command == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to create xorriso command string\n");
-		return (char *) NULL;
-	} else {
+	if (command) {
 		cdw_vdm ("INFO: xorriso command for creating ISO9660 image: \"%s\"\n", command);
 		return command;
+	} else {
+		cdw_vdm ("ERROR: failed to create xorriso command string\n");
+		return (char *) NULL;
 	}
 }
 
@@ -166,14 +165,13 @@
 		    "ERROR: tool fullpath is NULL\n");
 
 	char *fs_command = cdw_xorriso_create_command_create_iso_fs(task);
-	if (fs_command == (char *) NULL) {
+	if (!fs_command) {
 		cdw_vdm ("ERROR: failed to create string with IS9660 parameters\n");
 		return (char *) NULL;
 	}
 
 	const char *device_fullpath = cdw_drive_get_drive_fullpath();
-	cdw_assert (device_fullpath != (char *) NULL,
-		    "ERROR: \"device fullpath\" is NULL\n");
+	cdw_assert (device_fullpath, "ERROR: \"device fullpath\" is NULL\n");
 
 	bool close = cdw_xorriso_close_disc(task);
 	char speed_string[5 + 1];
@@ -182,10 +180,10 @@
 	char *command = cdw_string_concat(task->burn.tool.label,
 					  " -dev ", device_fullpath,
 					  " -speed ", speed_string,
-					  fs_command,
+					  fs_command, /* ISO9660 main options + ISO9660 meta data options. */
 
 					  " ", task->burn.dummy ? " -dummy on " : " ",
-					  " ", task->burn.xorriso.other_xorriso_burn_options == (char *) NULL ? " " : task->burn.xorriso.other_xorriso_burn_options, " ",
+					  " ", task->burn.xorriso_burn_other_options ? task->burn.xorriso_burn_other_options : " ", " ",
 
 					  close ? " -close on " : " -close off ",
 
@@ -195,12 +193,12 @@
 	free(fs_command);
 	fs_command = (char *) NULL;
 
-	if (command == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to create xorriso command string\n");
-		return (char *) NULL;
-	} else {
+	if (command) {
 		cdw_vdm ("INFO: xorriso command for burning from files: \"%s\"\n", command);
 		return command;
+	} else {
+		cdw_vdm ("ERROR: failed to create xorriso command string\n");
+		return (char *) NULL;
 	}
 }
 
@@ -209,7 +207,7 @@
 
 
 /* xorriso -as cdrecord -vv -dev=/dev/scd0 /tmp/image.iso */
-char *cdw_xorriso_create_command_burn_from_image(cdw_task_t *task)
+char *cdw_xorriso_create_command_burn_from_image(cdw_task_t *task, cdw_disc_t *disc)
 {
 	cdw_assert (task->id == CDW_TASK_BURN_FROM_IMAGE,
 		    "ERROR: incorrect task id: %lld\n", task->id);
@@ -217,15 +215,13 @@
 		    "ERROR: session mode is not set properly\n");
 	cdw_assert (task->burn.tool.id == CDW_TOOL_XORRISO,
 		    "ERROR: incorrect tool id: %lld\n", task->burn.tool.id);
-	cdw_assert (task->burn.tool.label != (char *) NULL,
-		    "ERROR: tool fullpath is NULL\n");
+	cdw_assert (task->burn.tool.label, "ERROR: tool fullpath is NULL\n");
 
 	const char *device_fullpath = cdw_drive_get_drive_fullpath();
-	cdw_assert (device_fullpath != (char *) NULL,
-		    "ERROR: \"device fullpath\" is NULL\n");
+	cdw_assert (device_fullpath, "ERROR: \"device fullpath\" is NULL\n");
 
 	char speed_string[5 + 1];
-	snprintf(speed_string, 5 + 1, "%lld ", task->erase.speed_id);
+	snprintf(speed_string, 5 + 1, "%lld%s ", task->burn.speed_id, disc->cdio->simple_type == CDW_DISC_SIMPLE_TYPE_CD ? "c" : "d");
 
 	bool close = cdw_xorriso_close_disc(task);
 
@@ -237,21 +233,22 @@
 					     xorriso's dummy option */
 					  " ", task->burn.dummy ? " -dummy " : " ",
 					  " speed=", speed_string,
-					  task->burn.iso9660_file_fullpath,
+					  task->image_file_fullpath,
 
 					  " -- ",
 
-					  " ", task->burn.xorriso.other_xorriso_burn_options == (char *) NULL ? " " : task->burn.xorriso.other_xorriso_burn_options, " ",
+					  /* TODO: where is "dummy" option? Answer: look few lines up, you silly. */
+					  " ", task->burn.xorriso_burn_other_options ? task->burn.xorriso_burn_other_options : " ", " ",
 
 					  close ? " -close on " : " -close off ",
 					  (char *) NULL);
 
-	if (command == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to create xorriso command string\n");
-		return (char *) NULL;
-	} else {
+	if (command) {
 		cdw_vdm ("INFO: xorriso command for burning from image: \"%s\"\n", command);
 		return command;
+	} else {
+		cdw_vdm ("ERROR: failed to create xorriso command string\n");
+		return (char *) NULL;
 	}
 }
 
@@ -261,43 +258,40 @@
 
 char *cdw_xorriso_create_command_create_iso_fs(cdw_task_t *task)
 {
-	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_ISO9660
 		    || task->id == CDW_TASK_BURN_FROM_FILES,
 		    "ERROR: incorrect task id: %lld\n", task->id);
 	cdw_assert (task->create_image.tool.id == CDW_TOOL_XORRISO,
 		    "ERROR: incorrect tool id: %lld\n", task->create_image.tool.id);
+
 	const char *graftpoints_fullpath = cdw_graftpoints_get_fullpath();
-	cdw_assert (graftpoints_fullpath != (char *) NULL,
-		    "ERROR: graftpoints fullpath is NULL\n");
+	cdw_assert (graftpoints_fullpath, "ERROR: graftpoints fullpath is NULL\n");
 
-	bool useful_rock_ridge = task->create_image.rock_ridge == CDW_ISO9660_RR_USEFUL ? true : false;
+	bool useful_rr = task->create_image.iso9660.rock_ridge == CDW_ISO9660_RR_USEFUL;
 	char *meta_information = cdw_xorriso_create_meta_information_string(task);
 
-	char *command = cdw_string_concat(task->create_image.joliet_information ? " -joliet on " : " -joliet off ",
-					  task->create_image.follow_symlinks ? " -follow link " : "",
+	char *command = cdw_string_concat(task->create_image.iso9660.joliet_information ? " -joliet on " : " -joliet off ",
+					  task->create_image.iso9660.follow_symlinks ? " -follow link " : "",
 					  " -pathspecs on ",
 
-					  task->create_image.pad ? " -padding 300k " : " -padding 0 ",
+					  task->create_image.iso9660.pad ? " -padding 300k " : " -padding 0 ",
 
 
 					  " -path_list ", graftpoints_fullpath, " ",
 					  meta_information ? meta_information : "", /* already surrounded by spaces */
-					  " ", task->create_image.xorriso.other_xorriso_iso_options == (char *) NULL ? " " : task->create_image.xorriso.other_xorriso_iso_options, " ",
-					  useful_rock_ridge ? " -find / -true -exec mkisofs_r -- " : "",
+					  " ", task->create_image.iso9660.xorriso_iso_other_options ? task->create_image.iso9660.xorriso_iso_other_options : " ", " ",
+					  useful_rr ? " -find / -true -exec mkisofs_r -- " : "",
 
 					  (char *) NULL);
 
-	if (meta_information) {
-		free(meta_information);
-		meta_information = (char *) NULL;
-	}
+	cdw_string_delete(&meta_information);
 
-	if (command == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to create xorriso command string for ISO9660 fs\n");
-		return (char *) NULL;
-	} else {
+	if (command) {
 		cdw_vdm ("INFO: xorriso command string for ISO9660 fs: \"%s\"\n", command);
 		return command;
+	} else {
+		cdw_vdm ("ERROR: failed to create xorriso command string for ISO9660 fs\n");
+		return (char *) NULL;
 	}
 }
 
@@ -307,43 +301,31 @@
 
 char *cdw_xorriso_create_meta_information_string(cdw_task_t *task)
 {
-	/* there will always be a volume ID, either from
-	   config file, or from wizard's form field */
-	size_t volume_id = strlen(task->create_image.volume_id);
-
-	size_t publisher = 0;
-	size_t system_id = 0;
-	size_t volume_set_id = 0;
-
-	if (task->id == CDW_TASK_BURN_FROM_FILES) {
-		/* this is to avoid adding (possibly outdated/invalid) meta
-		   information; the information may come from previous
-		   'create image' task, but now it may be invalid for
-		   purposes of 'burn from files' task;
-		   TODO: this should be fixed by adding 'meta' tab to
-		   configuration panel in write wizard */
-		;
-	} else {
-		publisher = strlen(task->create_image.publisher);
-		system_id = strlen(task->create_image.system_id);
-		volume_set_id = strlen(task->create_image.volume_set_id);
-	}
+	/* This data can be edited in main window of "burn from files"
+	   wizard or "crate image" wizard. */
+	size_t volume_id = strlen(task->create_image.iso9660.volume_id);
+
+	/* This data can be edited in "meta data" page of "Options
+	   window" in "create image" or "burn from files" wizard. */
+	size_t publisher     = strlen(task->create_image.iso9660.publisher);
+	size_t system_id     = strlen(task->create_image.iso9660.system_id);
+	size_t volume_set_id = strlen(task->create_image.iso9660.volume_set_id);
 
 	char *s = cdw_string_concat(" ",
 				    volume_id ? " -volid \"" : "",
-				    volume_id ? task->create_image.volume_id : "",
+				    volume_id ? task->create_image.iso9660.volume_id : "",
 				    volume_id ? "\" " : "",
 
 				    publisher ? " -publisher \"" : " ",
-				    publisher ? task->create_image.publisher : "",
+				    publisher ? task->create_image.iso9660.publisher : "",
 				    publisher ? "\" " : "",
 
 				    system_id ? " -system_id \"" : "",
-				    system_id ? task->create_image.system_id : "",
+				    system_id ? task->create_image.iso9660.system_id : "",
 				    system_id ? "\" " : "",
 
 				    volume_set_id ? " -volset_id \"" : "",
-				    volume_set_id ? task->create_image.volume_set_id : "",
+				    volume_set_id ? task->create_image.iso9660.volume_set_id : "",
 				    volume_set_id ? "\" " : "",
 
 				    " ", (char *) NULL);
@@ -358,24 +340,22 @@
 
 char *cdw_xorriso_create_command_media_info(cdw_task_t *task)
 {
-	cdw_assert (task->media_info.tool.label != (char *) NULL,
-		    "ERROR: tool fullpath is NULL\n");
+	cdw_assert (task->media_info.tool.label, "ERROR: tool fullpath is NULL\n");
 
 	const char *device = cdw_drive_get_drive_fullpath();
-	cdw_assert (device != (char *) NULL,
-		    "ERROR: \"device\" fullpath is NULL\n");
+	cdw_assert (device, "ERROR: \"device\" fullpath is NULL\n");
 
 	char *command = cdw_string_concat(task->media_info.tool.label,
 					  " -indev ",
 					  device, " -toc ",
 					  (char *) NULL);
 
-	if (command == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to create xorriso command string for media info\n");
-		return (char *) NULL;
-	} else {
+	if (command) {
 		cdw_vdm ("INFO: xorriso command string for media info: \"%s\"\n", command);
 		return command;
+	} else {
+		cdw_vdm ("ERROR: failed to create xorriso command string for media info\n");
+		return (char *) NULL;
 	}
 }
 
@@ -385,12 +365,10 @@
 
 char *cdw_xorriso_create_command_erase(cdw_task_t *task, cdw_disc_t *disc)
 {
-	cdw_assert (task->erase.tool.label != (char *) NULL,
-		    "ERROR: \"erase\" tool fullpath is NULL\n");
+	cdw_assert (task->erase.tool.label, "ERROR: \"erase\" tool fullpath is NULL\n");
 
 	const char *device = cdw_drive_get_drive_fullpath();
-	cdw_assert (device != (char *) NULL,
-		    "ERROR: \"device\" fullpath is NULL\n");
+	cdw_assert (device, "ERROR: \"device\" fullpath is NULL\n");
 
 	char blank_mode[30 + 1];
 	if (disc->type == CDW_CD_RW) {
@@ -403,18 +381,22 @@
 		cdw_assert (0, "ERROR: xorriso can't work with media type %d\n", disc->type);
 	}
 
+	char speed_string[5 + 1];
+	snprintf(speed_string, 5 + 1, "%lld%s ", task->erase.speed_id, disc->cdio->simple_type == CDW_DISC_SIMPLE_TYPE_CD ? "c" : "d");
+
+
 	char *command = cdw_string_concat(task->erase.tool.label,
-					  " -dev ",  device,
+					  " -dev ",  device, " ",
 					  blank_mode,
-
+					  " -speed ", speed_string, " ",
 					  (char *) NULL);
 
-	if (command == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to create xorriso command string for erasing\n");
-		return (char *) NULL;
-	} else {
+	if (command) {
 		cdw_vdm ("INFO: xorriso command string for erasing: \"%s\"\n", command);
 		return command;
+	} else {
+		cdw_vdm ("ERROR: failed to create xorriso command string for erasing\n");
+		return (char *) NULL;
 	}
 }
 
@@ -489,5 +471,3 @@
 {
 	return true;
 }
-
-
diff -Naur orig/src/external_tools/cdw_xorriso_options.c patched/src/external_tools/cdw_xorriso_options.c
--- orig/src/external_tools/cdw_xorriso_options.c	2012-03-28 20:49:31.000000000 +0200
+++ patched/src/external_tools/cdw_xorriso_options.c	2014-04-12 20:25:56.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,27 +14,26 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
 #include <stdio.h>
 #include <string.h>
 
-#include "cdw_task.h"
 #include "gettext.h"
 #include "cdw_string.h"
 #include "cdw_widgets.h"
 #include "cdw_debug.h"
 #include "cdw_form.h"
 #include "cdw_xorriso_options.h"
-#include "cdw_iso9660.h"
 
 
-static cdw_task_t *local_task = (cdw_task_t *) NULL;
 
+static cdw_iso9660_t *local_iso = (cdw_iso9660_t *) NULL;
 
-static FIELD *page_xorriso_iso_fields[CDW_XORRISO_ISO_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
+
+static FIELD *page_xorriso_iso_fields[CDW_XORRISO_ISO_MAIN_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
 
 static CDW_DROPDOWN *cdw_xorriso_iso_options_make_rock_ridge_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
 
@@ -59,44 +58,45 @@
 
 
 
-cdw_rv_t cdw_xorriso_iso_options_form(cdw_form_t *cdw_form, void *cdw_task, int first_col, int second_col, int width_wide, int width_narrow)
+cdw_rv_t cdw_xorriso_iso_options_form(cdw_form_t *cdw_form, void *cdw_iso, int first_col, int second_col, int width_wide, int width_narrow)
 {
-	cdw_task_t *task = (cdw_task_t *) cdw_task;
-	local_task = task;
+	cdw_iso9660_t *iso = (cdw_iso9660_t *) cdw_iso;
+	local_iso = iso;
 	cdw_form->fields = page_xorriso_iso_fields;
 
 	int rr_width = 15;
 	cdw_form_descr_t descr[] = {
-		/*     type        begin_y   begin_x       n_cols           n_lines  field enum              data1                                       data2 */
+		/* type                      begin_y   begin_x         n_cols    n_lines  field enum                          data1                                       data2 */
 
-		{ CDW_WIDGET_CHECKBOX, 1,  first_col + 1,  0,              0,  f_xorriso_iso_joliet_cb,           (void *) NULL,  task->create_image.joliet_information ? 1 : 0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          1,  first_col + 1,  0,              0,  f_xorriso_iso_joliet_cb,           (void *) NULL,    iso->joliet_information ? 1 : 0 },
 		/* 2TRANS: this is checkbox label; use Joliet extensions to ISO9660 (add Joliet information to ISO file system) */
-		{ CDW_WIDGET_LABEL,    1,  first_col + 4,  width_narrow,   1,  f_xorriso_iso_joliet_l,            _("Joliet information"),                                    0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      1,  first_col + 4,  width_narrow,   1,  f_xorriso_iso_joliet_l,            _("Joliet information"),                        0 },
 
 		/* 2TRANS: this is checkbox label; specify Rock Ridge extensions to ISO9660 (add Rock Ridge information to ISO file system) */
-		{ CDW_WIDGET_LABEL,    2,  first_col,      width_narrow,   1,  f_xorriso_iso_rock_ridge_l,        _("Rock Ridge information"),                                0 },
-		{ CDW_WIDGET_DROPDOWN, 2,  second_col,     rr_width,       1,  f_xorriso_iso_rock_ridge_dd,       dropdown_makers,                                            0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      2,  first_col,      width_narrow,   1,  f_xorriso_iso_rock_ridge_l,        _("Rock Ridge information"),                    0 },
+		{ CDW_WIDGET_ID_DROPDOWN,          2,  second_col,     rr_width,       1,  f_xorriso_iso_rock_ridge_dd,       dropdown_makers,                                0 },
 
-		{ CDW_WIDGET_CHECKBOX, 3,  first_col + 1,  0,              0,  f_xorriso_iso_follow_symlinks_cb,  (void *) NULL,     task->create_image.follow_symlinks ? 1 : 0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          3,  first_col + 1,  0,              0,  f_xorriso_iso_follow_symlinks_cb,  (void *) NULL,       iso->follow_symlinks ? 1 : 0 },
 		/* 2TRANS: this is checkbox label; when traversing file system, follow UNIX symbolic links */
-		{ CDW_WIDGET_LABEL,    3,  first_col + 4,  width_narrow,   1,  f_xorriso_iso_follow_symlinks_l,   _("Follow added symbolic links"),                           0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      3,  first_col + 4,  width_narrow,   1,  f_xorriso_iso_follow_symlinks_l,   _("Follow added symbolic links"),               0 },
 
-		{ CDW_WIDGET_CHECKBOX, 4,  first_col + 1,  0,              0,  f_xorriso_iso_pad_cb,              (void *) NULL,                 task->create_image.pad ? 1 : 0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          4,  first_col + 1,  0,              0,  f_xorriso_iso_pad_cb,              (void *) NULL,                   iso->pad ? 1 : 0 },
 		/* 2TRANS: this is a checkbox label; add additional bytes after proper data payload */
-		{ CDW_WIDGET_LABEL,    4,  first_col + 4,  width_narrow,   1,  f_xorriso_iso_pad_l,               _("Pad at the end"),                                        0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      4,  first_col + 4,  width_narrow,   1,  f_xorriso_iso_pad_l,               _("Pad at the end"),                            0 },
 
 		/* 2TRANS: this is an input field label; define other options passed to xorriso, related to creating ISO9660 file system */
-		{ CDW_WIDGET_LABEL,    6,  first_col,      width_wide,     1,  f_xorriso_iso_other_l,             _("Other xorriso options for ISO9660:"),                    0 },
-		{ CDW_WIDGET_INPUT,    7,  first_col,      width_wide - 3, 1,  f_xorriso_iso_other_i,             task->create_image.xorriso.other_xorriso_iso_options,       0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     6,  first_col,      width_wide,     1,  f_xorriso_iso_other_l,             _("Other xorriso options for ISO9660:"),        0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   7,  first_col,      width_wide - 3, 1,  f_xorriso_iso_other_i,             iso->xorriso_iso_other_options,                 0 },
 
 		/* guard */
-		{ -1,                  0,  0,              0,              0,  0,                                 (void *) NULL,                                              0 }};
+		{ -1,                          0,  0,              0,              0,  0,                                 (void *) NULL,                                  0 }};
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
+		cdw_form_bind_input_and_label(cdw_form, f_xorriso_iso_other_i, f_xorriso_iso_other_l);
 		return CDW_OK;
 	}
 }
@@ -115,7 +115,7 @@
 
 CDW_DROPDOWN *cdw_xorriso_iso_options_make_rock_ridge_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
 {
-	cdw_id_t rock_ridge = local_task->create_image.rock_ridge;
+	cdw_id_t rock_ridge = local_iso->rock_ridge;
 	cdw_assert (rock_ridge >= CDW_ISO9660_RR_USEFUL && rock_ridge <= CDW_ISO9660_RR_FULL,
 		    "ERROR: invalid value of Rock Ridge: %lld\n", rock_ridge);
 	if (rock_ridge == CDW_ISO9660_RR_NONE) {
@@ -131,10 +131,9 @@
 
 
 
-cdw_rv_t cdw_xorriso_iso_options_validate(cdw_form_t *cdw_form, int *fi)
+cdw_rv_t cdw_xorriso_iso_options_validate(cdw_iso9660_t *iso, int *fi)
 {
-	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorriso_iso_other_i));
-	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	cdw_rv_t crv = cdw_string_security_parser(iso->xorriso_iso_other_options, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_xorriso_iso_other_i;
 		return CDW_NO;
@@ -147,26 +146,28 @@
 
 
 
-cdw_rv_t cdw_xorriso_iso_options_save(cdw_form_t *cdw_form, cdw_task_t *task)
+cdw_rv_t cdw_xorriso_iso_options_save(cdw_form_t *cdw_form, cdw_iso9660_t *iso)
 {
-	task->create_image.joliet_information = cdw_form_get_checkbox_state(cdw_form, f_xorriso_iso_joliet_cb);
+	iso->joliet_information = cdw_form_get_checkbox_state(cdw_form, f_xorriso_iso_joliet_cb);
 
 
 	CDW_DROPDOWN *dd = cdw_form_get_dropdown(cdw_form, f_xorriso_iso_rock_ridge_dd);
 	int rr = (int) cdw_dropdown_get_current_item_id(dd);
+
+	/* TODO: should _NONE be an option here? xorriso doesn't support "none". */
 	cdw_assert (rr == CDW_ISO9660_RR_NONE
 		    || rr == CDW_ISO9660_RR_USEFUL
 		    || rr == CDW_ISO9660_RR_FULL, "ERROR: field stores invalid value of Rock Ridge: %d\n", rr);
-	task->create_image.rock_ridge = rr;
+	iso->rock_ridge = rr;
 
 
-	task->create_image.follow_symlinks = cdw_form_get_checkbox_state(cdw_form, f_xorriso_iso_follow_symlinks_cb);
+	iso->follow_symlinks = cdw_form_get_checkbox_state(cdw_form, f_xorriso_iso_follow_symlinks_cb);
 
 
-	task->create_image.pad = cdw_form_get_checkbox_state(cdw_form, f_xorriso_iso_pad_cb);
+	iso->pad = cdw_form_get_checkbox_state(cdw_form, f_xorriso_iso_pad_cb);
 
 
-	cdw_string_set(&(task->create_image.xorriso.other_xorriso_iso_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorriso_iso_other_i)));
+	cdw_string_set(&(iso->xorriso_iso_other_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorriso_iso_other_i)));
 
 	return CDW_OK;
 }
@@ -178,8 +179,8 @@
 
 
 enum {
-	f_xorriso_burn_other_l,
-	f_xorriso_burn_other_i };
+	f_xorriso_other_burn_l,
+	f_xorriso_other_burn_i };
 
 
 static FIELD *page_xorriso_burn_fields[CDW_XORRISO_BURN_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
@@ -188,24 +189,24 @@
 cdw_rv_t cdw_xorriso_burn_options_form(cdw_form_t *cdw_form, void *cdw_task, int first_col, __attribute__((unused)) int second_col, int width_wide, __attribute__((unused)) int width_narrow)
 {
 	cdw_task_t *task = (cdw_task_t *) cdw_task;
-	local_task = task;
 	cdw_form->fields = page_xorriso_burn_fields;
 
 	cdw_form_descr_t descr[] = {
-		/*     type     begin_y  begin_x     n_cols    n_lines   field enum               data1                                       data2 */
+		/* type                      begin_y   begin_x     n_cols    n_lines   field enum               data1                                           data2 */
 
 		/* 2TRANS: this is an input field label; define other options passed to xorriso, related to burning discs */
-		{ CDW_WIDGET_LABEL,  6,  first_col,  width_wide,     1,  f_xorriso_burn_other_l,  _("Other xorriso options for writing:"),        0 },
-		{ CDW_WIDGET_INPUT,  7,  first_col,  width_wide - 3, 1,  f_xorriso_burn_other_i,  task->burn.xorriso.other_xorriso_burn_options,  0 },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     6,  first_col,  width_wide,     1,  f_xorriso_other_burn_l,  _("Other xorriso options for writing:"),        0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   7,  first_col,  width_wide - 3, 1,  f_xorriso_other_burn_i,  task->burn.xorriso_burn_other_options,          0 },
 
 		/* guard */
-		{ -1,                0,  0,          0,              0,  0,                       (void *) NULL,                                  0 }};
+		{ -1,                              0,  0,          0,              0,  0,                       (void *) NULL,                                  0 }};
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
+		cdw_form_bind_input_and_label(cdw_form, f_xorriso_other_burn_i, f_xorriso_other_burn_l);
 		return CDW_OK;
 	}
 }
@@ -214,12 +215,11 @@
 
 
 
-cdw_rv_t cdw_xorriso_burn_options_validate(cdw_form_t *cdw_form, int *fi)
+cdw_rv_t cdw_xorriso_burn_options_validate(cdw_task_t *task, int *fi)
 {
-	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorriso_burn_other_i));
-	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	cdw_rv_t crv = cdw_string_security_parser(task->burn.xorriso_burn_other_options, (char *) NULL);
 	if (crv != CDW_OK) {
-		*fi = f_xorriso_burn_other_i;
+		*fi = f_xorriso_other_burn_i;
 		return CDW_NO;
 	}
 
@@ -232,7 +232,7 @@
 
 cdw_rv_t cdw_xorriso_burn_options_save(cdw_form_t *cdw_form, cdw_task_t *task)
 {
-	cdw_string_set(&(task->burn.xorriso.other_xorriso_burn_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorriso_burn_other_i)));
+	cdw_string_set(&(task->burn.xorriso_burn_other_options), cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorriso_other_burn_i)));
 
 	return CDW_OK;
 }
diff -Naur orig/src/external_tools/cdw_xorriso_options.h patched/src/external_tools/cdw_xorriso_options.h
--- orig/src/external_tools/cdw_xorriso_options.h	2011-03-14 19:39:54.000000000 +0100
+++ patched/src/external_tools/cdw_xorriso_options.h	2014-03-19 20:41:21.000000000 +0100
@@ -3,18 +3,19 @@
 
 #include "main.h"
 #include "cdw_form.h"
+#include "cdw_iso9660.h"
 #include "cdw_task.h"
 
-#define CDW_XORRISO_ISO_OPTIONS_N_FIELDS  10
+#define CDW_XORRISO_ISO_MAIN_OPTIONS_N_FIELDS  10
 #define CDW_XORRISO_BURN_OPTIONS_N_FIELDS  2
 
-cdw_rv_t cdw_xorriso_iso_options_form(cdw_form_t *cdw_form, void *task, int first_col, int second_col, int width_wide, int width_narrow);
-cdw_rv_t cdw_xorriso_iso_options_validate(cdw_form_t *cdw_form, int *fi);
-cdw_rv_t cdw_xorriso_iso_options_save(cdw_form_t *cdw_form, cdw_task_t *task);
+cdw_rv_t cdw_xorriso_iso_options_form(cdw_form_t *cdw_form, void *cdw_iso, int first_col, int second_col, int width_wide, int width_narrow);
+cdw_rv_t cdw_xorriso_iso_options_validate(cdw_iso9660_t *iso, int *fi);
+cdw_rv_t cdw_xorriso_iso_options_save(cdw_form_t *cdw_form, cdw_iso9660_t *iso);
 
 
-cdw_rv_t cdw_xorriso_burn_options_form(cdw_form_t *cdw_form, void *task, int first_col, int second_col, int width_wide, int width_narrow);
-cdw_rv_t cdw_xorriso_burn_options_validate(cdw_form_t *cdw_form, int *fi);
+cdw_rv_t cdw_xorriso_burn_options_form(cdw_form_t *cdw_form, void *cdw_task, int first_col, int second_col, int width_wide, int width_narrow);
+cdw_rv_t cdw_xorriso_burn_options_validate(cdw_task_t *task, int *fi);
 cdw_rv_t cdw_xorriso_burn_options_save(cdw_form_t *cdw_form, cdw_task_t *task);
 
 
diff -Naur orig/src/external_tools/cdw_xorrisorc.c patched/src/external_tools/cdw_xorrisorc.c
--- orig/src/external_tools/cdw_xorrisorc.c	2012-03-28 20:46:57.000000000 +0200
+++ patched/src/external_tools/cdw_xorrisorc.c	2014-04-06 23:03:59.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -33,6 +33,23 @@
 #include "cdw_form.h"
 #include "cdw_logging.h"
 
+/*
+  Code in this file operates on only three ISO9660 meta-data fields:
+  - publisher
+  - volume set id
+  - system id
+
+  These three fields are displayed in "Meta data" tab in wizard
+  options ("create image" wizard and "burn from files" wizard).
+
+  There is also a fourth ISO9660 meta-data field: "volume id", but it
+  is displayed in main window of wizard, so it is handled directly by
+  wizard code.
+
+  Notice that cdw_mkisofsrc handles more ISO9660 meta-data fields than
+  cdw_xorrisorc.
+*/
+
 
 /* the value must be larger than any of CDW_ISO9660_*_LEN values
    defined in optical_file_systems/cdw_iso9660.h */
@@ -48,7 +65,6 @@
 	cdw_xorrisorc_top_message,
 };
 
-static cdw_task_t *local_task = (cdw_task_t *) NULL;
 
 
 
@@ -65,7 +81,7 @@
 
 
 
-static FIELD *xorrisorc_fields[CDW_XORRISORC_N_FIELDS + 1]; /* +1 for last field == NULL */
+static FIELD *xorrisorc_fields[CDW_XORRISO_ISO_META_OPTIONS_N_FIELDS + 1]; /* +1 for last field == NULL */
 
 
 /**
@@ -74,40 +90,43 @@
    \return CDW_OK when all fields were created (probably) without problems
    \return CDW_GEN_ERROR if one of fields was created incorrectly
 */
-cdw_rv_t cdw_xorrisorc_form(cdw_form_t *cdw_form, void *cdw_task, int first_col, __attribute__((unused)) int second_col, int width_wide, __attribute__((unused)) int width_narrow)
+cdw_rv_t cdw_xorrisorc_options_form(cdw_form_t *cdw_form, __attribute__((unused)) void *cdw_iso, int first_col, __attribute__((unused)) int second_col, int width_wide, __attribute__((unused)) int width_narrow)
 {
-	cdw_task_t *task = (cdw_task_t *) cdw_task;
-	local_task = task;
 	cdw_form->fields = xorrisorc_fields;
 
 	cdw_form_descr_t descr[] = {
-		/*     type      begin_y  begin_x       n_cols          n_lines  field enum                    data1                               data2 */
+		/*     type                   begin_y   begin_x     n_cols           n_lines  field enum                     data1                               data2 */
 
-		{ CDW_WIDGET_TEXT,    1,  1,          width_wide + 2,        7,  f_xorrisorc_top_message_l,    text_makers,                            0 },
+		{ CDW_WIDGET_ID_TEXT,               1,  1,          width_wide + 2,        7,  f_xorrisorc_top_message_l,    text_makers,                            0 },
 		/* 2TRANS: this is button label; a verb: read data from config file */
-		{ CDW_WIDGET_BUTTON, 10,  1,          1,                     1,  f_xorrisorc_top_message_b,    _("Read"),              CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,            10,  1,          1,                     1,  f_xorrisorc_top_message_b,    _("Read"),              CDW_COLORS_DIALOG },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter information about publisher of ISO9660 volume */
-		{ CDW_WIDGET_LABEL,  12,  first_col,  width_wide,            1,  f_xorrisorc_publisher_l,      _("Publisher"),                         0 },
-		{ CDW_WIDGET_INPUT,  13,  first_col,  width_wide,            1,  f_xorrisorc_publisher_i,      (char *) NULL,       CDW_ISO9660_PUBL_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     12,  first_col,  width_wide,            1,  f_xorrisorc_publisher_l,      _("Publisher"),                         0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   13,  first_col,  width_wide,            1,  f_xorrisorc_publisher_i,      (char *) NULL,       CDW_ISO9660_PUBL_LEN },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter information about ID of ISO9660 volume set */
-		{ CDW_WIDGET_LABEL,  14,  first_col,  width_wide,            1,  f_xorrisorc_volume_set_id_l,  _("Volume set ID"),                     0 },
-		{ CDW_WIDGET_INPUT,  15,  first_col,  width_wide,            1,  f_xorrisorc_volume_set_id_i,  (char *) NULL,       CDW_ISO9660_VOLS_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     14,  first_col,  width_wide,            1,  f_xorrisorc_volume_set_id_l,  _("Volume set ID"),                     0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   15,  first_col,  width_wide,            1,  f_xorrisorc_volume_set_id_i,  (char *) NULL,       CDW_ISO9660_VOLS_LEN },
 
 		/* 2TRANS: this is a label next to input field, in which user can enter information about system on which ISO9660 volume has been created */
-		{ CDW_WIDGET_LABEL,  16,  first_col,  width_wide,            1,  f_xorrisorc_system_id_l,      _("System ID"),                         0 },
-		{ CDW_WIDGET_INPUT,  17,  first_col,  CDW_ISO9660_SYSI_LEN,  1,  f_xorrisorc_system_id_i,      (char *) NULL,       CDW_ISO9660_SYSI_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     16,  first_col,  width_wide,            1,  f_xorrisorc_system_id_l,      _("System ID"),                         0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   17,  first_col,  CDW_ISO9660_SYSI_LEN,  1,  f_xorrisorc_system_id_i,      (char *) NULL,       CDW_ISO9660_SYSI_LEN },
 
 		/* guard */
-		{ -1,                 0,  0,          0,                     0,  0,                            (void *) NULL,                          0 }};
+		{ -1,                               0,  0,          0,                     0,  0,                            (void *) NULL,                          0 }};
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
 	} else {
-		cdw_form_set_function(cdw_form, f_xorrisorc_top_message_b, cdw_xorrisorc_read_config_file);
+		cdw_form_set_widget_callback(cdw_form, f_xorrisorc_top_message_b, cdw_xorrisorc_read_config_file);
+
+		cdw_form_bind_input_and_label(cdw_form, f_xorrisorc_publisher_i, f_xorrisorc_publisher_l);
+		cdw_form_bind_input_and_label(cdw_form, f_xorrisorc_volume_set_id_i, f_xorrisorc_volume_set_id_l);
+		cdw_form_bind_input_and_label(cdw_form, f_xorrisorc_system_id_i, f_xorrisorc_system_id_l);
+
 		return CDW_OK;
 	}
 }
@@ -116,24 +135,21 @@
 
 
 
-cdw_rv_t cdw_xorrisorc_validate(cdw_form_t *cdw_form, int *fi)
+cdw_rv_t cdw_xorrisorc_options_validate(cdw_iso9660_t *iso, int *fi)
 {
-	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_publisher_i));
-	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	cdw_rv_t crv = cdw_string_security_parser(iso->publisher, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_xorrisorc_publisher_i;
 		return CDW_NO;
 	}
 
-	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_volume_set_id_i));
-	crv = cdw_string_security_parser(s, (char *) NULL);
+	crv = cdw_string_security_parser(iso->volume_set_id, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_xorrisorc_volume_set_id_i;
 		return CDW_NO;
 	}
 
-	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_system_id_i));
-	crv = cdw_string_security_parser(s, (char *) NULL);
+	crv = cdw_string_security_parser(iso->system_id, (char *) NULL);
 	if (crv != CDW_OK) {
 		*fi = f_xorrisorc_system_id_i;
 		return CDW_NO;
@@ -146,19 +162,19 @@
 
 
 
-cdw_rv_t cdw_xorrisorc_save(cdw_form_t *cdw_form, cdw_task_t *task)
+cdw_rv_t cdw_xorrisorc_options_save(cdw_form_t *cdw_form, cdw_iso9660_t *iso)
 {
 	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_volume_set_id_i));
-	strncpy(task->create_image.volume_set_id, s, CDW_ISO9660_VOLS_LEN);
-	task->create_image.volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
+	strncpy(iso->volume_set_id, s, CDW_ISO9660_VOLS_LEN);
+	        iso->volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
 
 	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_publisher_i));
-	strncpy(task->create_image.publisher, s, CDW_ISO9660_PUBL_LEN);
-	task->create_image.publisher[CDW_ISO9660_PUBL_LEN] = '\0';
+	strncpy(iso->publisher, s, CDW_ISO9660_PUBL_LEN);
+	        iso->publisher[CDW_ISO9660_PUBL_LEN] = '\0';
 
 	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_system_id_i));
-	strncpy(task->create_image.system_id, s, CDW_ISO9660_SYSI_LEN);
-	task->create_image.system_id[CDW_ISO9660_SYSI_LEN] = '\0';
+	strncpy(iso->system_id, s, CDW_ISO9660_SYSI_LEN);
+	        iso->system_id[CDW_ISO9660_SYSI_LEN] = '\0';
 
 	return CDW_OK;
 }
@@ -317,4 +333,3 @@
 
 	return;
 }
-
diff -Naur orig/src/external_tools/cdw_xorrisorc.h patched/src/external_tools/cdw_xorrisorc.h
--- orig/src/external_tools/cdw_xorrisorc.h	2011-02-17 10:44:43.000000000 +0100
+++ patched/src/external_tools/cdw_xorrisorc.h	2014-03-19 20:41:21.000000000 +0100
@@ -3,13 +3,13 @@
 
 #include "main.h"
 #include "cdw_form.h"
-#include "cdw_task.h"
+#include "cdw_iso9660.h"
 
-#define CDW_XORRISORC_N_FIELDS    8
+#define CDW_XORRISO_ISO_META_OPTIONS_N_FIELDS    8
 
-cdw_rv_t cdw_xorrisorc_form(cdw_form_t *cdw_form, void *task, int first_col, int second_col, int width_wide, int width_narrow);
-cdw_rv_t cdw_xorrisorc_validate(cdw_form_t *cdw_form, int *fi);
-cdw_rv_t cdw_xorrisorc_save(cdw_form_t *cdw_form, cdw_task_t *task);
+cdw_rv_t cdw_xorrisorc_options_form(cdw_form_t *cdw_form, void *cdw_iso, int first_col, int second_col, int width_wide, int width_narrow);
+cdw_rv_t cdw_xorrisorc_options_validate(cdw_iso9660_t *iso, int *fi);
+cdw_rv_t cdw_xorrisorc_options_save(cdw_form_t *cdw_form, cdw_iso9660_t *iso);
 
 
 #endif /* H_CDW_XORRISORC */
diff -Naur orig/src/external_tools/cdw_xorriso_regex.c patched/src/external_tools/cdw_xorriso_regex.c
--- orig/src/external_tools/cdw_xorriso_regex.c	2012-03-28 20:50:33.000000000 +0200
+++ patched/src/external_tools/cdw_xorriso_regex.c	2014-04-06 23:02:31.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdio.h>
@@ -35,6 +35,7 @@
 #include "cdw_drive.h"
 #include "cdw_utils.h"
 #include "cdw_logging.h"
+#include "cdw_string.h"
 
 extern char stdout_pipe_buffer[PIPE_BUFFER_SIZE + 1];
 extern char stderr_pipe_buffer[PIPE_BUFFER_SIZE + 1];
@@ -207,6 +208,12 @@
 	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
 	  cdw_xorriso_handle_not_a_known_option },
 
+	{ "FAILURE : Not a known command", 1011,
+	  /* Unknown option passed to xorriso */
+	  "FAILURE : Not a known command: (.+)",
+	  (regex_t *) NULL, (regmatch_t *) NULL, REG_EXTENDED,
+	  cdw_xorriso_handle_not_a_known_option },
+
 
 	{ "table guard", -1,
 	  /* guard: debug_id = -1 */
@@ -429,7 +436,7 @@
 
 int cdw_xorriso_handle_media_status(regex_t *regex, regmatch_t *matches)
 {
-	if (thread_task->id == CDW_TASK_CREATE_IMAGE) {
+	if (thread_task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
 		/* xorriso output for ISO files (no disc):
 		   "Drive current: -outdev '/tmp/image.iso'
 		   Media current: stdio file, overwriteable
@@ -903,9 +910,11 @@
 
 int cdw_xorriso_handle_not_a_known_option(regex_t *regex, regmatch_t *matches)
 {
-	/* regexp for catching unknown option
+	/* regexp for catching unknown option/command
 	                                    1
-	   "FAILURE : Not a known option: (.+)" */
+	   "FAILURE : Not a known option: (.+)"
+           "FAILURE : Not a known command: (.+)"
+	*/
 	cdw_regex_assert_subex_number(regex->re_nsub, 1);
 
 	char submatch[PIPE_BUFFER_SIZE];
diff -Naur orig/src/external_tools/Makefile.am patched/src/external_tools/Makefile.am
--- orig/src/external_tools/Makefile.am	2011-03-20 23:04:30.000000000 +0100
+++ patched/src/external_tools/Makefile.am	2014-02-09 21:16:58.000000000 +0100
@@ -8,6 +8,10 @@
 	cdw_mkisofs_regex.c cdw_mkisofs_regex.h \
 	cdw_mkisofs_options.c cdw_mkisofs_options.h \
 	cdw_mkisofsrc.c cdw_mkisofsrc.h \
+	cdw_mkudffs.c cdw_mkudffs.h \
+	cdw_mkudffs_helpers.c cdw_mkudffs_helpers.h \
+	cdw_mkudffs_options.c cdw_mkudffs_options.h \
+	cdw_mkudffs_regex.c cdw_mkudffs_regex.h \
 	cdw_growisofs.c cdw_growisofs.h \
 	cdw_growisofs_options.c cdw_growisofs_options.h \
 	cdw_growisofs_regex.c cdw_growisofs_regex.h \
@@ -40,4 +44,4 @@
 # library built only for purposes of testing (checking)
 check_LIBRARIES = libcdwexternaltools_check.a
 libcdwexternaltools_check_a_SOURCES = $(sources)
-libcdwexternaltools_check_a_CPPFLAGS = -DCDW_UNIT_TEST_CODE $(AM_CPPFLAGS)
\ Nincs jsor a fjl vgn
+libcdwexternaltools_check_a_CPPFLAGS = -DCDW_UNIT_TEST_CODE $(AM_CPPFLAGS)
diff -Naur orig/src/external_tools/Makefile.in patched/src/external_tools/Makefile.in
--- orig/src/external_tools/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/external_tools/Makefile.in	2014-02-09 21:17:12.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,26 +76,32 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/external_tools
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwexternaltools_a_AR = $(AR) $(ARFLAGS)
 libcdwexternaltools_a_LIBADD =
 am__objects_1 = cdw_which.$(OBJEXT) cdw_cdrecord.$(OBJEXT) \
 	cdw_cdrecord_regex.$(OBJEXT) cdw_cdrecord_options.$(OBJEXT) \
 	cdw_mkisofs.$(OBJEXT) cdw_mkisofs_regex.$(OBJEXT) \
 	cdw_mkisofs_options.$(OBJEXT) cdw_mkisofsrc.$(OBJEXT) \
+	cdw_mkudffs.$(OBJEXT) cdw_mkudffs_helpers.$(OBJEXT) \
+	cdw_mkudffs_options.$(OBJEXT) cdw_mkudffs_regex.$(OBJEXT) \
 	cdw_growisofs.$(OBJEXT) cdw_growisofs_options.$(OBJEXT) \
 	cdw_growisofs_regex.$(OBJEXT) cdw_dvd_rw_format.$(OBJEXT) \
 	cdw_dvd_rw_format_regex.$(OBJEXT) \
@@ -74,6 +124,10 @@
 	libcdwexternaltools_check_a-cdw_mkisofs_regex.$(OBJEXT) \
 	libcdwexternaltools_check_a-cdw_mkisofs_options.$(OBJEXT) \
 	libcdwexternaltools_check_a-cdw_mkisofsrc.$(OBJEXT) \
+	libcdwexternaltools_check_a-cdw_mkudffs.$(OBJEXT) \
+	libcdwexternaltools_check_a-cdw_mkudffs_helpers.$(OBJEXT) \
+	libcdwexternaltools_check_a-cdw_mkudffs_options.$(OBJEXT) \
+	libcdwexternaltools_check_a-cdw_mkudffs_regex.$(OBJEXT) \
 	libcdwexternaltools_check_a-cdw_growisofs.$(OBJEXT) \
 	libcdwexternaltools_check_a-cdw_growisofs_options.$(OBJEXT) \
 	libcdwexternaltools_check_a-cdw_growisofs_regex.$(OBJEXT) \
@@ -94,24 +148,71 @@
 am_libcdwexternaltools_check_a_OBJECTS = $(am__objects_2)
 libcdwexternaltools_check_a_OBJECTS =  \
 	$(am_libcdwexternaltools_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwexternaltools_a_SOURCES) \
 	$(libcdwexternaltools_check_a_SOURCES)
 DIST_SOURCES = $(libcdwexternaltools_a_SOURCES) \
 	$(libcdwexternaltools_check_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -210,6 +311,10 @@
 	cdw_mkisofs_regex.c cdw_mkisofs_regex.h \
 	cdw_mkisofs_options.c cdw_mkisofs_options.h \
 	cdw_mkisofsrc.c cdw_mkisofsrc.h \
+	cdw_mkudffs.c cdw_mkudffs.h \
+	cdw_mkudffs_helpers.c cdw_mkudffs_helpers.h \
+	cdw_mkudffs_options.c cdw_mkudffs_options.h \
+	cdw_mkudffs_regex.c cdw_mkudffs_regex.h \
 	cdw_growisofs.c cdw_growisofs.h \
 	cdw_growisofs_options.c cdw_growisofs_options.h \
 	cdw_growisofs_regex.c cdw_growisofs_regex.h \
@@ -344,14 +449,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwexternaltools.a: $(libcdwexternaltools_a_OBJECTS) $(libcdwexternaltools_a_DEPENDENCIES) $(EXTRA_libcdwexternaltools_a_DEPENDENCIES) 
-	-rm -f libcdwexternaltools.a
-	$(libcdwexternaltools_a_AR) libcdwexternaltools.a $(libcdwexternaltools_a_OBJECTS) $(libcdwexternaltools_a_LIBADD)
-	$(RANLIB) libcdwexternaltools.a
+	$(AM_V_at)-rm -f libcdwexternaltools.a
+	$(AM_V_AR)$(libcdwexternaltools_a_AR) libcdwexternaltools.a $(libcdwexternaltools_a_OBJECTS) $(libcdwexternaltools_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwexternaltools.a
+
 libcdwexternaltools_check.a: $(libcdwexternaltools_check_a_OBJECTS) $(libcdwexternaltools_check_a_DEPENDENCIES) $(EXTRA_libcdwexternaltools_check_a_DEPENDENCIES) 
-	-rm -f libcdwexternaltools_check.a
-	$(libcdwexternaltools_check_a_AR) libcdwexternaltools_check.a $(libcdwexternaltools_check_a_OBJECTS) $(libcdwexternaltools_check_a_LIBADD)
-	$(RANLIB) libcdwexternaltools_check.a
+	$(AM_V_at)-rm -f libcdwexternaltools_check.a
+	$(AM_V_AR)$(libcdwexternaltools_check_a_AR) libcdwexternaltools_check.a $(libcdwexternaltools_check_a_OBJECTS) $(libcdwexternaltools_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwexternaltools_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -377,6 +484,10 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_mkisofs_options.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_mkisofs_regex.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_mkisofsrc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_mkudffs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_mkudffs_helpers.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_mkudffs_options.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_mkudffs_regex.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_regex_dispatch.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_thread.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_which.Po@am__quote@
@@ -402,6 +513,10 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_helpers.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_options.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_regex.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Po@am__quote@
@@ -411,389 +526,434 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwexternaltools_check_a-cdw_which.o: cdw_which.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_which.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Tpo -c -o libcdwexternaltools_check_a-cdw_which.o `test -f 'cdw_which.c' || echo '$(srcdir)/'`cdw_which.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_which.c' object='libcdwexternaltools_check_a-cdw_which.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_which.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Tpo -c -o libcdwexternaltools_check_a-cdw_which.o `test -f 'cdw_which.c' || echo '$(srcdir)/'`cdw_which.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_which.c' object='libcdwexternaltools_check_a-cdw_which.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_which.o `test -f 'cdw_which.c' || echo '$(srcdir)/'`cdw_which.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_which.o `test -f 'cdw_which.c' || echo '$(srcdir)/'`cdw_which.c
 
 libcdwexternaltools_check_a-cdw_which.obj: cdw_which.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_which.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Tpo -c -o libcdwexternaltools_check_a-cdw_which.obj `if test -f 'cdw_which.c'; then $(CYGPATH_W) 'cdw_which.c'; else $(CYGPATH_W) '$(srcdir)/cdw_which.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_which.c' object='libcdwexternaltools_check_a-cdw_which.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_which.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Tpo -c -o libcdwexternaltools_check_a-cdw_which.obj `if test -f 'cdw_which.c'; then $(CYGPATH_W) 'cdw_which.c'; else $(CYGPATH_W) '$(srcdir)/cdw_which.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_which.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_which.c' object='libcdwexternaltools_check_a-cdw_which.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_which.obj `if test -f 'cdw_which.c'; then $(CYGPATH_W) 'cdw_which.c'; else $(CYGPATH_W) '$(srcdir)/cdw_which.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_which.obj `if test -f 'cdw_which.c'; then $(CYGPATH_W) 'cdw_which.c'; else $(CYGPATH_W) '$(srcdir)/cdw_which.c'; fi`
 
 libcdwexternaltools_check_a-cdw_cdrecord.o: cdw_cdrecord.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord.o `test -f 'cdw_cdrecord.c' || echo '$(srcdir)/'`cdw_cdrecord.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdrecord.c' object='libcdwexternaltools_check_a-cdw_cdrecord.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord.o `test -f 'cdw_cdrecord.c' || echo '$(srcdir)/'`cdw_cdrecord.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdrecord.c' object='libcdwexternaltools_check_a-cdw_cdrecord.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord.o `test -f 'cdw_cdrecord.c' || echo '$(srcdir)/'`cdw_cdrecord.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord.o `test -f 'cdw_cdrecord.c' || echo '$(srcdir)/'`cdw_cdrecord.c
 
 libcdwexternaltools_check_a-cdw_cdrecord.obj: cdw_cdrecord.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord.obj `if test -f 'cdw_cdrecord.c'; then $(CYGPATH_W) 'cdw_cdrecord.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdrecord.c' object='libcdwexternaltools_check_a-cdw_cdrecord.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord.obj `if test -f 'cdw_cdrecord.c'; then $(CYGPATH_W) 'cdw_cdrecord.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdrecord.c' object='libcdwexternaltools_check_a-cdw_cdrecord.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord.obj `if test -f 'cdw_cdrecord.c'; then $(CYGPATH_W) 'cdw_cdrecord.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord.obj `if test -f 'cdw_cdrecord.c'; then $(CYGPATH_W) 'cdw_cdrecord.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord.c'; fi`
 
 libcdwexternaltools_check_a-cdw_cdrecord_regex.o: cdw_cdrecord_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord_regex.o `test -f 'cdw_cdrecord_regex.c' || echo '$(srcdir)/'`cdw_cdrecord_regex.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdrecord_regex.c' object='libcdwexternaltools_check_a-cdw_cdrecord_regex.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord_regex.o `test -f 'cdw_cdrecord_regex.c' || echo '$(srcdir)/'`cdw_cdrecord_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdrecord_regex.c' object='libcdwexternaltools_check_a-cdw_cdrecord_regex.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord_regex.o `test -f 'cdw_cdrecord_regex.c' || echo '$(srcdir)/'`cdw_cdrecord_regex.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord_regex.o `test -f 'cdw_cdrecord_regex.c' || echo '$(srcdir)/'`cdw_cdrecord_regex.c
 
 libcdwexternaltools_check_a-cdw_cdrecord_regex.obj: cdw_cdrecord_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord_regex.obj `if test -f 'cdw_cdrecord_regex.c'; then $(CYGPATH_W) 'cdw_cdrecord_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord_regex.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdrecord_regex.c' object='libcdwexternaltools_check_a-cdw_cdrecord_regex.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord_regex.obj `if test -f 'cdw_cdrecord_regex.c'; then $(CYGPATH_W) 'cdw_cdrecord_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdrecord_regex.c' object='libcdwexternaltools_check_a-cdw_cdrecord_regex.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord_regex.obj `if test -f 'cdw_cdrecord_regex.c'; then $(CYGPATH_W) 'cdw_cdrecord_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord_regex.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord_regex.obj `if test -f 'cdw_cdrecord_regex.c'; then $(CYGPATH_W) 'cdw_cdrecord_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord_regex.c'; fi`
 
 libcdwexternaltools_check_a-cdw_cdrecord_options.o: cdw_cdrecord_options.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord_options.o `test -f 'cdw_cdrecord_options.c' || echo '$(srcdir)/'`cdw_cdrecord_options.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdrecord_options.c' object='libcdwexternaltools_check_a-cdw_cdrecord_options.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord_options.o `test -f 'cdw_cdrecord_options.c' || echo '$(srcdir)/'`cdw_cdrecord_options.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdrecord_options.c' object='libcdwexternaltools_check_a-cdw_cdrecord_options.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord_options.o `test -f 'cdw_cdrecord_options.c' || echo '$(srcdir)/'`cdw_cdrecord_options.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord_options.o `test -f 'cdw_cdrecord_options.c' || echo '$(srcdir)/'`cdw_cdrecord_options.c
 
 libcdwexternaltools_check_a-cdw_cdrecord_options.obj: cdw_cdrecord_options.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord_options.obj `if test -f 'cdw_cdrecord_options.c'; then $(CYGPATH_W) 'cdw_cdrecord_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord_options.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdrecord_options.c' object='libcdwexternaltools_check_a-cdw_cdrecord_options.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_cdrecord_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Tpo -c -o libcdwexternaltools_check_a-cdw_cdrecord_options.obj `if test -f 'cdw_cdrecord_options.c'; then $(CYGPATH_W) 'cdw_cdrecord_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord_options.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_cdrecord_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdrecord_options.c' object='libcdwexternaltools_check_a-cdw_cdrecord_options.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord_options.obj `if test -f 'cdw_cdrecord_options.c'; then $(CYGPATH_W) 'cdw_cdrecord_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord_options.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_cdrecord_options.obj `if test -f 'cdw_cdrecord_options.c'; then $(CYGPATH_W) 'cdw_cdrecord_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdrecord_options.c'; fi`
 
 libcdwexternaltools_check_a-cdw_mkisofs.o: cdw_mkisofs.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs.o `test -f 'cdw_mkisofs.c' || echo '$(srcdir)/'`cdw_mkisofs.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_mkisofs.c' object='libcdwexternaltools_check_a-cdw_mkisofs.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs.o `test -f 'cdw_mkisofs.c' || echo '$(srcdir)/'`cdw_mkisofs.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkisofs.c' object='libcdwexternaltools_check_a-cdw_mkisofs.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs.o `test -f 'cdw_mkisofs.c' || echo '$(srcdir)/'`cdw_mkisofs.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs.o `test -f 'cdw_mkisofs.c' || echo '$(srcdir)/'`cdw_mkisofs.c
 
 libcdwexternaltools_check_a-cdw_mkisofs.obj: cdw_mkisofs.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs.obj `if test -f 'cdw_mkisofs.c'; then $(CYGPATH_W) 'cdw_mkisofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_mkisofs.c' object='libcdwexternaltools_check_a-cdw_mkisofs.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs.obj `if test -f 'cdw_mkisofs.c'; then $(CYGPATH_W) 'cdw_mkisofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkisofs.c' object='libcdwexternaltools_check_a-cdw_mkisofs.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs.obj `if test -f 'cdw_mkisofs.c'; then $(CYGPATH_W) 'cdw_mkisofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs.obj `if test -f 'cdw_mkisofs.c'; then $(CYGPATH_W) 'cdw_mkisofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs.c'; fi`
 
 libcdwexternaltools_check_a-cdw_mkisofs_regex.o: cdw_mkisofs_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs_regex.o `test -f 'cdw_mkisofs_regex.c' || echo '$(srcdir)/'`cdw_mkisofs_regex.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_mkisofs_regex.c' object='libcdwexternaltools_check_a-cdw_mkisofs_regex.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs_regex.o `test -f 'cdw_mkisofs_regex.c' || echo '$(srcdir)/'`cdw_mkisofs_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkisofs_regex.c' object='libcdwexternaltools_check_a-cdw_mkisofs_regex.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs_regex.o `test -f 'cdw_mkisofs_regex.c' || echo '$(srcdir)/'`cdw_mkisofs_regex.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs_regex.o `test -f 'cdw_mkisofs_regex.c' || echo '$(srcdir)/'`cdw_mkisofs_regex.c
 
 libcdwexternaltools_check_a-cdw_mkisofs_regex.obj: cdw_mkisofs_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs_regex.obj `if test -f 'cdw_mkisofs_regex.c'; then $(CYGPATH_W) 'cdw_mkisofs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs_regex.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_mkisofs_regex.c' object='libcdwexternaltools_check_a-cdw_mkisofs_regex.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs_regex.obj `if test -f 'cdw_mkisofs_regex.c'; then $(CYGPATH_W) 'cdw_mkisofs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkisofs_regex.c' object='libcdwexternaltools_check_a-cdw_mkisofs_regex.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs_regex.obj `if test -f 'cdw_mkisofs_regex.c'; then $(CYGPATH_W) 'cdw_mkisofs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs_regex.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs_regex.obj `if test -f 'cdw_mkisofs_regex.c'; then $(CYGPATH_W) 'cdw_mkisofs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs_regex.c'; fi`
 
 libcdwexternaltools_check_a-cdw_mkisofs_options.o: cdw_mkisofs_options.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs_options.o `test -f 'cdw_mkisofs_options.c' || echo '$(srcdir)/'`cdw_mkisofs_options.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_mkisofs_options.c' object='libcdwexternaltools_check_a-cdw_mkisofs_options.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs_options.o `test -f 'cdw_mkisofs_options.c' || echo '$(srcdir)/'`cdw_mkisofs_options.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkisofs_options.c' object='libcdwexternaltools_check_a-cdw_mkisofs_options.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs_options.o `test -f 'cdw_mkisofs_options.c' || echo '$(srcdir)/'`cdw_mkisofs_options.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs_options.o `test -f 'cdw_mkisofs_options.c' || echo '$(srcdir)/'`cdw_mkisofs_options.c
 
 libcdwexternaltools_check_a-cdw_mkisofs_options.obj: cdw_mkisofs_options.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs_options.obj `if test -f 'cdw_mkisofs_options.c'; then $(CYGPATH_W) 'cdw_mkisofs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs_options.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_mkisofs_options.c' object='libcdwexternaltools_check_a-cdw_mkisofs_options.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofs_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofs_options.obj `if test -f 'cdw_mkisofs_options.c'; then $(CYGPATH_W) 'cdw_mkisofs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs_options.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofs_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkisofs_options.c' object='libcdwexternaltools_check_a-cdw_mkisofs_options.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs_options.obj `if test -f 'cdw_mkisofs_options.c'; then $(CYGPATH_W) 'cdw_mkisofs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs_options.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofs_options.obj `if test -f 'cdw_mkisofs_options.c'; then $(CYGPATH_W) 'cdw_mkisofs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofs_options.c'; fi`
 
 libcdwexternaltools_check_a-cdw_mkisofsrc.o: cdw_mkisofsrc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofsrc.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofsrc.o `test -f 'cdw_mkisofsrc.c' || echo '$(srcdir)/'`cdw_mkisofsrc.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_mkisofsrc.c' object='libcdwexternaltools_check_a-cdw_mkisofsrc.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofsrc.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofsrc.o `test -f 'cdw_mkisofsrc.c' || echo '$(srcdir)/'`cdw_mkisofsrc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkisofsrc.c' object='libcdwexternaltools_check_a-cdw_mkisofsrc.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofsrc.o `test -f 'cdw_mkisofsrc.c' || echo '$(srcdir)/'`cdw_mkisofsrc.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofsrc.o `test -f 'cdw_mkisofsrc.c' || echo '$(srcdir)/'`cdw_mkisofsrc.c
 
 libcdwexternaltools_check_a-cdw_mkisofsrc.obj: cdw_mkisofsrc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofsrc.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofsrc.obj `if test -f 'cdw_mkisofsrc.c'; then $(CYGPATH_W) 'cdw_mkisofsrc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofsrc.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_mkisofsrc.c' object='libcdwexternaltools_check_a-cdw_mkisofsrc.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkisofsrc.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Tpo -c -o libcdwexternaltools_check_a-cdw_mkisofsrc.obj `if test -f 'cdw_mkisofsrc.c'; then $(CYGPATH_W) 'cdw_mkisofsrc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofsrc.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkisofsrc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkisofsrc.c' object='libcdwexternaltools_check_a-cdw_mkisofsrc.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofsrc.obj `if test -f 'cdw_mkisofsrc.c'; then $(CYGPATH_W) 'cdw_mkisofsrc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofsrc.c'; fi`
+
+libcdwexternaltools_check_a-cdw_mkudffs.o: cdw_mkudffs.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkudffs.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs.Tpo -c -o libcdwexternaltools_check_a-cdw_mkudffs.o `test -f 'cdw_mkudffs.c' || echo '$(srcdir)/'`cdw_mkudffs.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkudffs.c' object='libcdwexternaltools_check_a-cdw_mkudffs.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkudffs.o `test -f 'cdw_mkudffs.c' || echo '$(srcdir)/'`cdw_mkudffs.c
+
+libcdwexternaltools_check_a-cdw_mkudffs.obj: cdw_mkudffs.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkudffs.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs.Tpo -c -o libcdwexternaltools_check_a-cdw_mkudffs.obj `if test -f 'cdw_mkudffs.c'; then $(CYGPATH_W) 'cdw_mkudffs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkudffs.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkudffs.c' object='libcdwexternaltools_check_a-cdw_mkudffs.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkudffs.obj `if test -f 'cdw_mkudffs.c'; then $(CYGPATH_W) 'cdw_mkudffs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkudffs.c'; fi`
+
+libcdwexternaltools_check_a-cdw_mkudffs_helpers.o: cdw_mkudffs_helpers.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkudffs_helpers.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_helpers.Tpo -c -o libcdwexternaltools_check_a-cdw_mkudffs_helpers.o `test -f 'cdw_mkudffs_helpers.c' || echo '$(srcdir)/'`cdw_mkudffs_helpers.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_helpers.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_helpers.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkudffs_helpers.c' object='libcdwexternaltools_check_a-cdw_mkudffs_helpers.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkudffs_helpers.o `test -f 'cdw_mkudffs_helpers.c' || echo '$(srcdir)/'`cdw_mkudffs_helpers.c
+
+libcdwexternaltools_check_a-cdw_mkudffs_helpers.obj: cdw_mkudffs_helpers.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkudffs_helpers.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_helpers.Tpo -c -o libcdwexternaltools_check_a-cdw_mkudffs_helpers.obj `if test -f 'cdw_mkudffs_helpers.c'; then $(CYGPATH_W) 'cdw_mkudffs_helpers.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkudffs_helpers.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_helpers.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_helpers.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkudffs_helpers.c' object='libcdwexternaltools_check_a-cdw_mkudffs_helpers.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkudffs_helpers.obj `if test -f 'cdw_mkudffs_helpers.c'; then $(CYGPATH_W) 'cdw_mkudffs_helpers.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkudffs_helpers.c'; fi`
+
+libcdwexternaltools_check_a-cdw_mkudffs_options.o: cdw_mkudffs_options.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkudffs_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_mkudffs_options.o `test -f 'cdw_mkudffs_options.c' || echo '$(srcdir)/'`cdw_mkudffs_options.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkudffs_options.c' object='libcdwexternaltools_check_a-cdw_mkudffs_options.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkudffs_options.o `test -f 'cdw_mkudffs_options.c' || echo '$(srcdir)/'`cdw_mkudffs_options.c
+
+libcdwexternaltools_check_a-cdw_mkudffs_options.obj: cdw_mkudffs_options.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkudffs_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_mkudffs_options.obj `if test -f 'cdw_mkudffs_options.c'; then $(CYGPATH_W) 'cdw_mkudffs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkudffs_options.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkudffs_options.c' object='libcdwexternaltools_check_a-cdw_mkudffs_options.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkudffs_options.obj `if test -f 'cdw_mkudffs_options.c'; then $(CYGPATH_W) 'cdw_mkudffs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkudffs_options.c'; fi`
+
+libcdwexternaltools_check_a-cdw_mkudffs_regex.o: cdw_mkudffs_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkudffs_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_mkudffs_regex.o `test -f 'cdw_mkudffs_regex.c' || echo '$(srcdir)/'`cdw_mkudffs_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkudffs_regex.c' object='libcdwexternaltools_check_a-cdw_mkudffs_regex.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkudffs_regex.o `test -f 'cdw_mkudffs_regex.c' || echo '$(srcdir)/'`cdw_mkudffs_regex.c
+
+libcdwexternaltools_check_a-cdw_mkudffs_regex.obj: cdw_mkudffs_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_mkudffs_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_mkudffs_regex.obj `if test -f 'cdw_mkudffs_regex.c'; then $(CYGPATH_W) 'cdw_mkudffs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkudffs_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_mkudffs_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_mkudffs_regex.c' object='libcdwexternaltools_check_a-cdw_mkudffs_regex.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkisofsrc.obj `if test -f 'cdw_mkisofsrc.c'; then $(CYGPATH_W) 'cdw_mkisofsrc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkisofsrc.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_mkudffs_regex.obj `if test -f 'cdw_mkudffs_regex.c'; then $(CYGPATH_W) 'cdw_mkudffs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_mkudffs_regex.c'; fi`
 
 libcdwexternaltools_check_a-cdw_growisofs.o: cdw_growisofs.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs.o `test -f 'cdw_growisofs.c' || echo '$(srcdir)/'`cdw_growisofs.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_growisofs.c' object='libcdwexternaltools_check_a-cdw_growisofs.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs.o `test -f 'cdw_growisofs.c' || echo '$(srcdir)/'`cdw_growisofs.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_growisofs.c' object='libcdwexternaltools_check_a-cdw_growisofs.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs.o `test -f 'cdw_growisofs.c' || echo '$(srcdir)/'`cdw_growisofs.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs.o `test -f 'cdw_growisofs.c' || echo '$(srcdir)/'`cdw_growisofs.c
 
 libcdwexternaltools_check_a-cdw_growisofs.obj: cdw_growisofs.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs.obj `if test -f 'cdw_growisofs.c'; then $(CYGPATH_W) 'cdw_growisofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_growisofs.c' object='libcdwexternaltools_check_a-cdw_growisofs.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs.obj `if test -f 'cdw_growisofs.c'; then $(CYGPATH_W) 'cdw_growisofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_growisofs.c' object='libcdwexternaltools_check_a-cdw_growisofs.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs.obj `if test -f 'cdw_growisofs.c'; then $(CYGPATH_W) 'cdw_growisofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs.obj `if test -f 'cdw_growisofs.c'; then $(CYGPATH_W) 'cdw_growisofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs.c'; fi`
 
 libcdwexternaltools_check_a-cdw_growisofs_options.o: cdw_growisofs_options.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs_options.o `test -f 'cdw_growisofs_options.c' || echo '$(srcdir)/'`cdw_growisofs_options.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_growisofs_options.c' object='libcdwexternaltools_check_a-cdw_growisofs_options.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs_options.o `test -f 'cdw_growisofs_options.c' || echo '$(srcdir)/'`cdw_growisofs_options.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_growisofs_options.c' object='libcdwexternaltools_check_a-cdw_growisofs_options.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs_options.o `test -f 'cdw_growisofs_options.c' || echo '$(srcdir)/'`cdw_growisofs_options.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs_options.o `test -f 'cdw_growisofs_options.c' || echo '$(srcdir)/'`cdw_growisofs_options.c
 
 libcdwexternaltools_check_a-cdw_growisofs_options.obj: cdw_growisofs_options.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs_options.obj `if test -f 'cdw_growisofs_options.c'; then $(CYGPATH_W) 'cdw_growisofs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs_options.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_growisofs_options.c' object='libcdwexternaltools_check_a-cdw_growisofs_options.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs_options.obj `if test -f 'cdw_growisofs_options.c'; then $(CYGPATH_W) 'cdw_growisofs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs_options.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_growisofs_options.c' object='libcdwexternaltools_check_a-cdw_growisofs_options.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs_options.obj `if test -f 'cdw_growisofs_options.c'; then $(CYGPATH_W) 'cdw_growisofs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs_options.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs_options.obj `if test -f 'cdw_growisofs_options.c'; then $(CYGPATH_W) 'cdw_growisofs_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs_options.c'; fi`
 
 libcdwexternaltools_check_a-cdw_growisofs_regex.o: cdw_growisofs_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs_regex.o `test -f 'cdw_growisofs_regex.c' || echo '$(srcdir)/'`cdw_growisofs_regex.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_growisofs_regex.c' object='libcdwexternaltools_check_a-cdw_growisofs_regex.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs_regex.o `test -f 'cdw_growisofs_regex.c' || echo '$(srcdir)/'`cdw_growisofs_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_growisofs_regex.c' object='libcdwexternaltools_check_a-cdw_growisofs_regex.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs_regex.o `test -f 'cdw_growisofs_regex.c' || echo '$(srcdir)/'`cdw_growisofs_regex.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs_regex.o `test -f 'cdw_growisofs_regex.c' || echo '$(srcdir)/'`cdw_growisofs_regex.c
 
 libcdwexternaltools_check_a-cdw_growisofs_regex.obj: cdw_growisofs_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs_regex.obj `if test -f 'cdw_growisofs_regex.c'; then $(CYGPATH_W) 'cdw_growisofs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs_regex.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_growisofs_regex.c' object='libcdwexternaltools_check_a-cdw_growisofs_regex.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_growisofs_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_growisofs_regex.obj `if test -f 'cdw_growisofs_regex.c'; then $(CYGPATH_W) 'cdw_growisofs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_growisofs_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_growisofs_regex.c' object='libcdwexternaltools_check_a-cdw_growisofs_regex.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs_regex.obj `if test -f 'cdw_growisofs_regex.c'; then $(CYGPATH_W) 'cdw_growisofs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs_regex.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_growisofs_regex.obj `if test -f 'cdw_growisofs_regex.c'; then $(CYGPATH_W) 'cdw_growisofs_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_growisofs_regex.c'; fi`
 
 libcdwexternaltools_check_a-cdw_dvd_rw_format.o: cdw_dvd_rw_format.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_format.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format.o `test -f 'cdw_dvd_rw_format.c' || echo '$(srcdir)/'`cdw_dvd_rw_format.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dvd_rw_format.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_format.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_format.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format.o `test -f 'cdw_dvd_rw_format.c' || echo '$(srcdir)/'`cdw_dvd_rw_format.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dvd_rw_format.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_format.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format.o `test -f 'cdw_dvd_rw_format.c' || echo '$(srcdir)/'`cdw_dvd_rw_format.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format.o `test -f 'cdw_dvd_rw_format.c' || echo '$(srcdir)/'`cdw_dvd_rw_format.c
 
 libcdwexternaltools_check_a-cdw_dvd_rw_format.obj: cdw_dvd_rw_format.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_format.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format.obj `if test -f 'cdw_dvd_rw_format.c'; then $(CYGPATH_W) 'cdw_dvd_rw_format.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_format.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dvd_rw_format.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_format.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_format.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format.obj `if test -f 'cdw_dvd_rw_format.c'; then $(CYGPATH_W) 'cdw_dvd_rw_format.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_format.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dvd_rw_format.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_format.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format.obj `if test -f 'cdw_dvd_rw_format.c'; then $(CYGPATH_W) 'cdw_dvd_rw_format.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_format.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format.obj `if test -f 'cdw_dvd_rw_format.c'; then $(CYGPATH_W) 'cdw_dvd_rw_format.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_format.c'; fi`
 
 libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o: cdw_dvd_rw_format_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o `test -f 'cdw_dvd_rw_format_regex.c' || echo '$(srcdir)/'`cdw_dvd_rw_format_regex.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dvd_rw_format_regex.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o `test -f 'cdw_dvd_rw_format_regex.c' || echo '$(srcdir)/'`cdw_dvd_rw_format_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dvd_rw_format_regex.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o `test -f 'cdw_dvd_rw_format_regex.c' || echo '$(srcdir)/'`cdw_dvd_rw_format_regex.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.o `test -f 'cdw_dvd_rw_format_regex.c' || echo '$(srcdir)/'`cdw_dvd_rw_format_regex.c
 
 libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj: cdw_dvd_rw_format_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj `if test -f 'cdw_dvd_rw_format_regex.c'; then $(CYGPATH_W) 'cdw_dvd_rw_format_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_format_regex.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dvd_rw_format_regex.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj `if test -f 'cdw_dvd_rw_format_regex.c'; then $(CYGPATH_W) 'cdw_dvd_rw_format_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_format_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dvd_rw_format_regex.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj `if test -f 'cdw_dvd_rw_format_regex.c'; then $(CYGPATH_W) 'cdw_dvd_rw_format_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_format_regex.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_format_regex.obj `if test -f 'cdw_dvd_rw_format_regex.c'; then $(CYGPATH_W) 'cdw_dvd_rw_format_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_format_regex.c'; fi`
 
 libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o: cdw_dvd_rw_mediainfo.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o `test -f 'cdw_dvd_rw_mediainfo.c' || echo '$(srcdir)/'`cdw_dvd_rw_mediainfo.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dvd_rw_mediainfo.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o `test -f 'cdw_dvd_rw_mediainfo.c' || echo '$(srcdir)/'`cdw_dvd_rw_mediainfo.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dvd_rw_mediainfo.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o `test -f 'cdw_dvd_rw_mediainfo.c' || echo '$(srcdir)/'`cdw_dvd_rw_mediainfo.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.o `test -f 'cdw_dvd_rw_mediainfo.c' || echo '$(srcdir)/'`cdw_dvd_rw_mediainfo.c
 
 libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj: cdw_dvd_rw_mediainfo.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj `if test -f 'cdw_dvd_rw_mediainfo.c'; then $(CYGPATH_W) 'cdw_dvd_rw_mediainfo.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_mediainfo.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dvd_rw_mediainfo.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj `if test -f 'cdw_dvd_rw_mediainfo.c'; then $(CYGPATH_W) 'cdw_dvd_rw_mediainfo.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_mediainfo.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dvd_rw_mediainfo.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj `if test -f 'cdw_dvd_rw_mediainfo.c'; then $(CYGPATH_W) 'cdw_dvd_rw_mediainfo.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_mediainfo.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo.obj `if test -f 'cdw_dvd_rw_mediainfo.c'; then $(CYGPATH_W) 'cdw_dvd_rw_mediainfo.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_mediainfo.c'; fi`
 
 libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o: cdw_dvd_rw_mediainfo_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o `test -f 'cdw_dvd_rw_mediainfo_regex.c' || echo '$(srcdir)/'`cdw_dvd_rw_mediainfo_regex.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dvd_rw_mediainfo_regex.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o `test -f 'cdw_dvd_rw_mediainfo_regex.c' || echo '$(srcdir)/'`cdw_dvd_rw_mediainfo_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dvd_rw_mediainfo_regex.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o `test -f 'cdw_dvd_rw_mediainfo_regex.c' || echo '$(srcdir)/'`cdw_dvd_rw_mediainfo_regex.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.o `test -f 'cdw_dvd_rw_mediainfo_regex.c' || echo '$(srcdir)/'`cdw_dvd_rw_mediainfo_regex.c
 
 libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj: cdw_dvd_rw_mediainfo_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj `if test -f 'cdw_dvd_rw_mediainfo_regex.c'; then $(CYGPATH_W) 'cdw_dvd_rw_mediainfo_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_mediainfo_regex.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dvd_rw_mediainfo_regex.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj `if test -f 'cdw_dvd_rw_mediainfo_regex.c'; then $(CYGPATH_W) 'cdw_dvd_rw_mediainfo_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_mediainfo_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dvd_rw_mediainfo_regex.c' object='libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj `if test -f 'cdw_dvd_rw_mediainfo_regex.c'; then $(CYGPATH_W) 'cdw_dvd_rw_mediainfo_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_mediainfo_regex.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_dvd_rw_mediainfo_regex.obj `if test -f 'cdw_dvd_rw_mediainfo_regex.c'; then $(CYGPATH_W) 'cdw_dvd_rw_mediainfo_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dvd_rw_mediainfo_regex.c'; fi`
 
 libcdwexternaltools_check_a-cdw_digest.o: cdw_digest.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_digest.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Tpo -c -o libcdwexternaltools_check_a-cdw_digest.o `test -f 'cdw_digest.c' || echo '$(srcdir)/'`cdw_digest.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_digest.c' object='libcdwexternaltools_check_a-cdw_digest.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_digest.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Tpo -c -o libcdwexternaltools_check_a-cdw_digest.o `test -f 'cdw_digest.c' || echo '$(srcdir)/'`cdw_digest.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_digest.c' object='libcdwexternaltools_check_a-cdw_digest.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_digest.o `test -f 'cdw_digest.c' || echo '$(srcdir)/'`cdw_digest.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_digest.o `test -f 'cdw_digest.c' || echo '$(srcdir)/'`cdw_digest.c
 
 libcdwexternaltools_check_a-cdw_digest.obj: cdw_digest.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_digest.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Tpo -c -o libcdwexternaltools_check_a-cdw_digest.obj `if test -f 'cdw_digest.c'; then $(CYGPATH_W) 'cdw_digest.c'; else $(CYGPATH_W) '$(srcdir)/cdw_digest.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_digest.c' object='libcdwexternaltools_check_a-cdw_digest.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_digest.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Tpo -c -o libcdwexternaltools_check_a-cdw_digest.obj `if test -f 'cdw_digest.c'; then $(CYGPATH_W) 'cdw_digest.c'; else $(CYGPATH_W) '$(srcdir)/cdw_digest.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_digest.c' object='libcdwexternaltools_check_a-cdw_digest.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_digest.obj `if test -f 'cdw_digest.c'; then $(CYGPATH_W) 'cdw_digest.c'; else $(CYGPATH_W) '$(srcdir)/cdw_digest.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_digest.obj `if test -f 'cdw_digest.c'; then $(CYGPATH_W) 'cdw_digest.c'; else $(CYGPATH_W) '$(srcdir)/cdw_digest.c'; fi`
 
 libcdwexternaltools_check_a-cdw_digest_regex.o: cdw_digest_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_digest_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_digest_regex.o `test -f 'cdw_digest_regex.c' || echo '$(srcdir)/'`cdw_digest_regex.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_digest_regex.c' object='libcdwexternaltools_check_a-cdw_digest_regex.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_digest_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_digest_regex.o `test -f 'cdw_digest_regex.c' || echo '$(srcdir)/'`cdw_digest_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_digest_regex.c' object='libcdwexternaltools_check_a-cdw_digest_regex.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_digest_regex.o `test -f 'cdw_digest_regex.c' || echo '$(srcdir)/'`cdw_digest_regex.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_digest_regex.o `test -f 'cdw_digest_regex.c' || echo '$(srcdir)/'`cdw_digest_regex.c
 
 libcdwexternaltools_check_a-cdw_digest_regex.obj: cdw_digest_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_digest_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_digest_regex.obj `if test -f 'cdw_digest_regex.c'; then $(CYGPATH_W) 'cdw_digest_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_digest_regex.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_digest_regex.c' object='libcdwexternaltools_check_a-cdw_digest_regex.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_digest_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_digest_regex.obj `if test -f 'cdw_digest_regex.c'; then $(CYGPATH_W) 'cdw_digest_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_digest_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_digest_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_digest_regex.c' object='libcdwexternaltools_check_a-cdw_digest_regex.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_digest_regex.obj `if test -f 'cdw_digest_regex.c'; then $(CYGPATH_W) 'cdw_digest_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_digest_regex.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_digest_regex.obj `if test -f 'cdw_digest_regex.c'; then $(CYGPATH_W) 'cdw_digest_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_digest_regex.c'; fi`
 
 libcdwexternaltools_check_a-cdw_xorriso.o: cdw_xorriso.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso.o `test -f 'cdw_xorriso.c' || echo '$(srcdir)/'`cdw_xorriso.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_xorriso.c' object='libcdwexternaltools_check_a-cdw_xorriso.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso.o `test -f 'cdw_xorriso.c' || echo '$(srcdir)/'`cdw_xorriso.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_xorriso.c' object='libcdwexternaltools_check_a-cdw_xorriso.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso.o `test -f 'cdw_xorriso.c' || echo '$(srcdir)/'`cdw_xorriso.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso.o `test -f 'cdw_xorriso.c' || echo '$(srcdir)/'`cdw_xorriso.c
 
 libcdwexternaltools_check_a-cdw_xorriso.obj: cdw_xorriso.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso.obj `if test -f 'cdw_xorriso.c'; then $(CYGPATH_W) 'cdw_xorriso.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_xorriso.c' object='libcdwexternaltools_check_a-cdw_xorriso.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso.obj `if test -f 'cdw_xorriso.c'; then $(CYGPATH_W) 'cdw_xorriso.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_xorriso.c' object='libcdwexternaltools_check_a-cdw_xorriso.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso.obj `if test -f 'cdw_xorriso.c'; then $(CYGPATH_W) 'cdw_xorriso.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso.obj `if test -f 'cdw_xorriso.c'; then $(CYGPATH_W) 'cdw_xorriso.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso.c'; fi`
 
 libcdwexternaltools_check_a-cdw_xorriso_regex.o: cdw_xorriso_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso_regex.o `test -f 'cdw_xorriso_regex.c' || echo '$(srcdir)/'`cdw_xorriso_regex.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_xorriso_regex.c' object='libcdwexternaltools_check_a-cdw_xorriso_regex.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso_regex.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso_regex.o `test -f 'cdw_xorriso_regex.c' || echo '$(srcdir)/'`cdw_xorriso_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_xorriso_regex.c' object='libcdwexternaltools_check_a-cdw_xorriso_regex.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso_regex.o `test -f 'cdw_xorriso_regex.c' || echo '$(srcdir)/'`cdw_xorriso_regex.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso_regex.o `test -f 'cdw_xorriso_regex.c' || echo '$(srcdir)/'`cdw_xorriso_regex.c
 
 libcdwexternaltools_check_a-cdw_xorriso_regex.obj: cdw_xorriso_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso_regex.obj `if test -f 'cdw_xorriso_regex.c'; then $(CYGPATH_W) 'cdw_xorriso_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso_regex.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_xorriso_regex.c' object='libcdwexternaltools_check_a-cdw_xorriso_regex.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso_regex.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso_regex.obj `if test -f 'cdw_xorriso_regex.c'; then $(CYGPATH_W) 'cdw_xorriso_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_xorriso_regex.c' object='libcdwexternaltools_check_a-cdw_xorriso_regex.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso_regex.obj `if test -f 'cdw_xorriso_regex.c'; then $(CYGPATH_W) 'cdw_xorriso_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso_regex.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso_regex.obj `if test -f 'cdw_xorriso_regex.c'; then $(CYGPATH_W) 'cdw_xorriso_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso_regex.c'; fi`
 
 libcdwexternaltools_check_a-cdw_xorriso_options.o: cdw_xorriso_options.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso_options.o `test -f 'cdw_xorriso_options.c' || echo '$(srcdir)/'`cdw_xorriso_options.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_xorriso_options.c' object='libcdwexternaltools_check_a-cdw_xorriso_options.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso_options.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso_options.o `test -f 'cdw_xorriso_options.c' || echo '$(srcdir)/'`cdw_xorriso_options.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_xorriso_options.c' object='libcdwexternaltools_check_a-cdw_xorriso_options.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso_options.o `test -f 'cdw_xorriso_options.c' || echo '$(srcdir)/'`cdw_xorriso_options.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso_options.o `test -f 'cdw_xorriso_options.c' || echo '$(srcdir)/'`cdw_xorriso_options.c
 
 libcdwexternaltools_check_a-cdw_xorriso_options.obj: cdw_xorriso_options.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso_options.obj `if test -f 'cdw_xorriso_options.c'; then $(CYGPATH_W) 'cdw_xorriso_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso_options.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_xorriso_options.c' object='libcdwexternaltools_check_a-cdw_xorriso_options.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorriso_options.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Tpo -c -o libcdwexternaltools_check_a-cdw_xorriso_options.obj `if test -f 'cdw_xorriso_options.c'; then $(CYGPATH_W) 'cdw_xorriso_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso_options.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorriso_options.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_xorriso_options.c' object='libcdwexternaltools_check_a-cdw_xorriso_options.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso_options.obj `if test -f 'cdw_xorriso_options.c'; then $(CYGPATH_W) 'cdw_xorriso_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso_options.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorriso_options.obj `if test -f 'cdw_xorriso_options.c'; then $(CYGPATH_W) 'cdw_xorriso_options.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorriso_options.c'; fi`
 
 libcdwexternaltools_check_a-cdw_xorrisorc.o: cdw_xorrisorc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorrisorc.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Tpo -c -o libcdwexternaltools_check_a-cdw_xorrisorc.o `test -f 'cdw_xorrisorc.c' || echo '$(srcdir)/'`cdw_xorrisorc.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_xorrisorc.c' object='libcdwexternaltools_check_a-cdw_xorrisorc.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorrisorc.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Tpo -c -o libcdwexternaltools_check_a-cdw_xorrisorc.o `test -f 'cdw_xorrisorc.c' || echo '$(srcdir)/'`cdw_xorrisorc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_xorrisorc.c' object='libcdwexternaltools_check_a-cdw_xorrisorc.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorrisorc.o `test -f 'cdw_xorrisorc.c' || echo '$(srcdir)/'`cdw_xorrisorc.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorrisorc.o `test -f 'cdw_xorrisorc.c' || echo '$(srcdir)/'`cdw_xorrisorc.c
 
 libcdwexternaltools_check_a-cdw_xorrisorc.obj: cdw_xorrisorc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorrisorc.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Tpo -c -o libcdwexternaltools_check_a-cdw_xorrisorc.obj `if test -f 'cdw_xorrisorc.c'; then $(CYGPATH_W) 'cdw_xorrisorc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorrisorc.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_xorrisorc.c' object='libcdwexternaltools_check_a-cdw_xorrisorc.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_xorrisorc.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Tpo -c -o libcdwexternaltools_check_a-cdw_xorrisorc.obj `if test -f 'cdw_xorrisorc.c'; then $(CYGPATH_W) 'cdw_xorrisorc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorrisorc.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_xorrisorc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_xorrisorc.c' object='libcdwexternaltools_check_a-cdw_xorrisorc.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorrisorc.obj `if test -f 'cdw_xorrisorc.c'; then $(CYGPATH_W) 'cdw_xorrisorc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorrisorc.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_xorrisorc.obj `if test -f 'cdw_xorrisorc.c'; then $(CYGPATH_W) 'cdw_xorrisorc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_xorrisorc.c'; fi`
 
 libcdwexternaltools_check_a-cdw_libburn.o: cdw_libburn.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_libburn.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Tpo -c -o libcdwexternaltools_check_a-cdw_libburn.o `test -f 'cdw_libburn.c' || echo '$(srcdir)/'`cdw_libburn.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_libburn.c' object='libcdwexternaltools_check_a-cdw_libburn.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_libburn.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Tpo -c -o libcdwexternaltools_check_a-cdw_libburn.o `test -f 'cdw_libburn.c' || echo '$(srcdir)/'`cdw_libburn.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_libburn.c' object='libcdwexternaltools_check_a-cdw_libburn.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_libburn.o `test -f 'cdw_libburn.c' || echo '$(srcdir)/'`cdw_libburn.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_libburn.o `test -f 'cdw_libburn.c' || echo '$(srcdir)/'`cdw_libburn.c
 
 libcdwexternaltools_check_a-cdw_libburn.obj: cdw_libburn.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_libburn.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Tpo -c -o libcdwexternaltools_check_a-cdw_libburn.obj `if test -f 'cdw_libburn.c'; then $(CYGPATH_W) 'cdw_libburn.c'; else $(CYGPATH_W) '$(srcdir)/cdw_libburn.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_libburn.c' object='libcdwexternaltools_check_a-cdw_libburn.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_libburn.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Tpo -c -o libcdwexternaltools_check_a-cdw_libburn.obj `if test -f 'cdw_libburn.c'; then $(CYGPATH_W) 'cdw_libburn.c'; else $(CYGPATH_W) '$(srcdir)/cdw_libburn.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_libburn.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_libburn.c' object='libcdwexternaltools_check_a-cdw_libburn.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_libburn.obj `if test -f 'cdw_libburn.c'; then $(CYGPATH_W) 'cdw_libburn.c'; else $(CYGPATH_W) '$(srcdir)/cdw_libburn.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_libburn.obj `if test -f 'cdw_libburn.c'; then $(CYGPATH_W) 'cdw_libburn.c'; else $(CYGPATH_W) '$(srcdir)/cdw_libburn.c'; fi`
 
 libcdwexternaltools_check_a-cdw_ext_tools.o: cdw_ext_tools.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_ext_tools.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Tpo -c -o libcdwexternaltools_check_a-cdw_ext_tools.o `test -f 'cdw_ext_tools.c' || echo '$(srcdir)/'`cdw_ext_tools.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_ext_tools.c' object='libcdwexternaltools_check_a-cdw_ext_tools.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_ext_tools.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Tpo -c -o libcdwexternaltools_check_a-cdw_ext_tools.o `test -f 'cdw_ext_tools.c' || echo '$(srcdir)/'`cdw_ext_tools.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_ext_tools.c' object='libcdwexternaltools_check_a-cdw_ext_tools.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_ext_tools.o `test -f 'cdw_ext_tools.c' || echo '$(srcdir)/'`cdw_ext_tools.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_ext_tools.o `test -f 'cdw_ext_tools.c' || echo '$(srcdir)/'`cdw_ext_tools.c
 
 libcdwexternaltools_check_a-cdw_ext_tools.obj: cdw_ext_tools.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_ext_tools.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Tpo -c -o libcdwexternaltools_check_a-cdw_ext_tools.obj `if test -f 'cdw_ext_tools.c'; then $(CYGPATH_W) 'cdw_ext_tools.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ext_tools.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_ext_tools.c' object='libcdwexternaltools_check_a-cdw_ext_tools.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_ext_tools.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Tpo -c -o libcdwexternaltools_check_a-cdw_ext_tools.obj `if test -f 'cdw_ext_tools.c'; then $(CYGPATH_W) 'cdw_ext_tools.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ext_tools.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_ext_tools.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_ext_tools.c' object='libcdwexternaltools_check_a-cdw_ext_tools.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_ext_tools.obj `if test -f 'cdw_ext_tools.c'; then $(CYGPATH_W) 'cdw_ext_tools.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ext_tools.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_ext_tools.obj `if test -f 'cdw_ext_tools.c'; then $(CYGPATH_W) 'cdw_ext_tools.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ext_tools.c'; fi`
 
 libcdwexternaltools_check_a-cdw_regex_dispatch.o: cdw_regex_dispatch.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_regex_dispatch.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Tpo -c -o libcdwexternaltools_check_a-cdw_regex_dispatch.o `test -f 'cdw_regex_dispatch.c' || echo '$(srcdir)/'`cdw_regex_dispatch.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_regex_dispatch.c' object='libcdwexternaltools_check_a-cdw_regex_dispatch.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_regex_dispatch.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Tpo -c -o libcdwexternaltools_check_a-cdw_regex_dispatch.o `test -f 'cdw_regex_dispatch.c' || echo '$(srcdir)/'`cdw_regex_dispatch.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_regex_dispatch.c' object='libcdwexternaltools_check_a-cdw_regex_dispatch.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_regex_dispatch.o `test -f 'cdw_regex_dispatch.c' || echo '$(srcdir)/'`cdw_regex_dispatch.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_regex_dispatch.o `test -f 'cdw_regex_dispatch.c' || echo '$(srcdir)/'`cdw_regex_dispatch.c
 
 libcdwexternaltools_check_a-cdw_regex_dispatch.obj: cdw_regex_dispatch.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_regex_dispatch.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Tpo -c -o libcdwexternaltools_check_a-cdw_regex_dispatch.obj `if test -f 'cdw_regex_dispatch.c'; then $(CYGPATH_W) 'cdw_regex_dispatch.c'; else $(CYGPATH_W) '$(srcdir)/cdw_regex_dispatch.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_regex_dispatch.c' object='libcdwexternaltools_check_a-cdw_regex_dispatch.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_regex_dispatch.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Tpo -c -o libcdwexternaltools_check_a-cdw_regex_dispatch.obj `if test -f 'cdw_regex_dispatch.c'; then $(CYGPATH_W) 'cdw_regex_dispatch.c'; else $(CYGPATH_W) '$(srcdir)/cdw_regex_dispatch.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_regex_dispatch.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_regex_dispatch.c' object='libcdwexternaltools_check_a-cdw_regex_dispatch.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_regex_dispatch.obj `if test -f 'cdw_regex_dispatch.c'; then $(CYGPATH_W) 'cdw_regex_dispatch.c'; else $(CYGPATH_W) '$(srcdir)/cdw_regex_dispatch.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_regex_dispatch.obj `if test -f 'cdw_regex_dispatch.c'; then $(CYGPATH_W) 'cdw_regex_dispatch.c'; else $(CYGPATH_W) '$(srcdir)/cdw_regex_dispatch.c'; fi`
 
 libcdwexternaltools_check_a-cdw_thread.o: cdw_thread.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_thread.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Tpo -c -o libcdwexternaltools_check_a-cdw_thread.o `test -f 'cdw_thread.c' || echo '$(srcdir)/'`cdw_thread.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_thread.c' object='libcdwexternaltools_check_a-cdw_thread.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_thread.o -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Tpo -c -o libcdwexternaltools_check_a-cdw_thread.o `test -f 'cdw_thread.c' || echo '$(srcdir)/'`cdw_thread.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_thread.c' object='libcdwexternaltools_check_a-cdw_thread.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_thread.o `test -f 'cdw_thread.c' || echo '$(srcdir)/'`cdw_thread.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_thread.o `test -f 'cdw_thread.c' || echo '$(srcdir)/'`cdw_thread.c
 
 libcdwexternaltools_check_a-cdw_thread.obj: cdw_thread.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_thread.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Tpo -c -o libcdwexternaltools_check_a-cdw_thread.obj `if test -f 'cdw_thread.c'; then $(CYGPATH_W) 'cdw_thread.c'; else $(CYGPATH_W) '$(srcdir)/cdw_thread.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_thread.c' object='libcdwexternaltools_check_a-cdw_thread.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_thread.obj `if test -f 'cdw_thread.c'; then $(CYGPATH_W) 'cdw_thread.c'; else $(CYGPATH_W) '$(srcdir)/cdw_thread.c'; fi`
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwexternaltools_check_a-cdw_thread.obj -MD -MP -MF $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Tpo -c -o libcdwexternaltools_check_a-cdw_thread.obj `if test -f 'cdw_thread.c'; then $(CYGPATH_W) 'cdw_thread.c'; else $(CYGPATH_W) '$(srcdir)/cdw_thread.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Tpo $(DEPDIR)/libcdwexternaltools_check_a-cdw_thread.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_thread.c' object='libcdwexternaltools_check_a-cdw_thread.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwexternaltools_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwexternaltools_check_a-cdw_thread.obj `if test -f 'cdw_thread.c'; then $(CYGPATH_W) 'cdw_thread.c'; else $(CYGPATH_W) '$(srcdir)/cdw_thread.c'; fi`
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -805,15 +965,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -822,6 +978,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -963,18 +1134,19 @@
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean \
-	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES ctags \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # used by flymake
diff -Naur orig/src/main.c patched/src/main.c
--- orig/src/main.c	2012-03-06 18:57:35.000000000 +0100
+++ patched/src/main.c	2014-03-24 22:18:54.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
@@ -58,7 +58,6 @@
 #include "cdw_utils.h"
 #include "cdw_logging.h"
 #include "cdw_ext_tools.h"
-#include "cdw_config.h"
 #include "cdw_file_manager.h"
 #include "cdw_main_window.h"
 #include "cdw_ncurses.h"
@@ -111,8 +110,8 @@
 
 	/* initialize ncurses - do this as soon as possible,
 	 * some error situations may require use of dialog windows */
-	cdw_rv_t crv = cdw_ncurses_init();
 	atexit(cdw_ncurses_clean);
+	cdw_rv_t crv = cdw_ncurses_init();
 	if (crv != CDW_OK) {
 		exit(EXIT_FAILURE);
 	}
@@ -120,8 +119,8 @@
 	cdw_colors_init_phase1();
 	/* there is no curses_colors_clean() to register with atexit() */
 
-	crv = cdw_fs_init();
 	atexit(cdw_fs_clean);
+	crv = cdw_fs_init();
 	if (crv != CDW_OK) {
 		/* 2TRANS: this is title of dialog window */
 		cdw_buttons_dialog(_("Error"),
@@ -139,9 +138,9 @@
 		/* cdw_config module reads in hardware configuration
 		   from configuration file; from now on "custom device"
 		   and "cdw drive" fields have some valid values */
-		cdw_config_module_init();
 		atexit(cdw_config_module_clean);
-		global_config.support_dvd_rp_dl = cdw_commandline_arguments.support_dvd_rp_dl;
+		cdw_config_module_init();
+		global_config.general.support_dvd_rp_dl = cdw_commandline_arguments.support_dvd_rp_dl;
 
 		/* now we have a config dir path, we can get colors config file */
 		cdw_colors_init_phase2();
@@ -150,28 +149,30 @@
 		/* cdw_cdio_drives module detects drives in user's system;
 		   it seems that it doesn't matter which of the two modules
 		   (config / cdio_drives) will be called first */
-		cdw_cdio_drives_init();
 		atexit(cdw_cdio_drives_clean);
+		cdw_cdio_drives_init();
 
 		/* cdw_drive checks data provided by cdw_config and
 		   cdw_cdio_drive modules and will be able to return
 		   correct value when cdw_drive_get_drive_fullpath()
 		   is called */
-		cdw_drive_init();
 		atexit(cdw_drive_clean);
+		cdw_drive_init();
+
 
 		/* cdw_cdio needs correct fullpath to currently selected
 		   drive - the path is provided by already configured
 		   cdw_drive module */
-		cdw_cdio_init();
 		atexit(cdw_cdio_clean);
+		cdw_cdio_init();
+
 	}
 
 	cdw_disc_init();
 	/* there is no cdw_disc_clean() to register with atexit() */
 
-	crv = cdw_logging_init();
-	atexit(cdw_logging_clean);
+	atexit(cdw_logging_module_clean);
+	crv = cdw_logging_module_init();
 	if (crv != CDW_OK) {
 		/* 2TRANS: this is title of dialog window */
 		cdw_buttons_dialog(_("Error"),
@@ -182,8 +183,8 @@
 		exit(EXIT_FAILURE);
 	}
 
-	crv = cdw_ext_tools_init();
 	atexit(cdw_ext_tools_clean);
+	crv = cdw_ext_tools_init();
 	if (crv == CDW_NO) {
 		/* 2TRANS: this is title of dialog window */
 		cdw_buttons_dialog(_("Error"),
@@ -205,8 +206,8 @@
 		;
 	}
 
-	crv = cdw_file_manager_init();
 	atexit(cdw_file_manager_clean);
+	crv = cdw_file_manager_init();
 	if (crv != CDW_OK) {
 		/* 2TRANS: this is title of dialog window */
 		cdw_buttons_dialog(_("Error"),
@@ -219,8 +220,8 @@
 	}
 
 	/* main app window */
-	crv = cdw_main_ui_init();
-	atexit(cdw_main_ui_clean);
+	atexit(cdw_main_window_module_clean);
+	crv = cdw_main_window_module_init();
 	if (crv != CDW_OK) {
 		/* 2TRANS: this is title of dialog window */
 		cdw_buttons_dialog(_("Error"),
@@ -260,8 +261,8 @@
  */
 int cdw_main_loop(void)
 {
-	MENU *menu = cdw_main_ui_get_main_menu();
-	WINDOW *window = cdw_main_ui_get_main_window();
+	MENU *menu = cdw_main_window_get_main_menu();
+	WINDOW *window = cdw_main_window_get_main_window();
 	int c = 'a';
 
 	while ((c = wgetch(window))
@@ -313,9 +314,9 @@
 			{
 				cdw_disc_t *disc = cdw_disc_new();
 				cdw_disc_get(disc);
-				cdw_main_ui_disc_info_view_display_data(disc);
+				cdw_main_window_disc_info_view_display_data(disc);
 				/* update information about disc size and usage */
-				cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, true, global_config.follow_symlinks);
+				cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, true);
 				cdw_disc_delete(&disc);
 			}
 			break;
@@ -353,7 +354,7 @@
 		case KEY_F(10):
 			/* on some terminals F10 may be used/broken, so
 			   use F9 as well */
-			cdw_main_ui_show_license();
+			cdw_main_window_show_license();
 			break;
 
 #if 0 /* not in this release */
@@ -431,13 +432,13 @@
 			   neatly correspond with menu item numbers */
 
 			if (ii == CDW_MENU_ADD_FILES) { /* Add files to list of files to be written to cd/image */
-				cdw_main_ui_add_to_selected_files();
+				cdw_main_window_add_to_selected_files();
 
 			} else if (ii == CDW_MENU_DELETE_FILES) {
 				/* Delete files from list of files to be
 				written to cd/image; this function regenerates
 				list of files and files info area */
-				cdw_main_ui_delete_from_selected_files();
+				cdw_main_window_delete_from_selected_files();
 
 			} else if (ii == CDW_MENU_CREATE_IMAGE) {
 				/* Create iso image using selected files */
@@ -461,6 +462,8 @@
 				 * allows him modify the options, save options
 				 * to global variable and to disk file */
 				cdw_config_window();
+			} else if (ii == CDW_MENU_ABOUT) {
+				cdw_about();
 			} else if (ii == CDW_MENU_EXIT_CDW) { /* Quit - Exit cdw */
 				/* this function calls exit() only if user
 				   confirms closing appication */
@@ -484,7 +487,7 @@
 		default:
 			break;
 		} /* switch(c) */
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 	} /* while (c = wgetch(main_cdw_win)) */
 
 	return 0;
@@ -529,7 +532,7 @@
 #include <stdlib.h>
 
 #include "main.h"
-#include "config.h"
+#include "config_cdw.h"
 
 #include "cdw_dll.h"
 #include "cdw_string.h"
diff -Naur orig/src/main.h patched/src/main.h
--- orig/src/main.h	2012-02-17 23:00:56.000000000 +0100
+++ patched/src/main.h	2014-04-06 22:20:43.000000000 +0200
@@ -10,13 +10,27 @@
    they tend not to work. '10' and '27' seem to work fine. */
 #define CDW_KEY_ENTER    10
 #define CDW_KEY_ESCAPE   27
-#define CDW_KEY_TAB    '\t'
+#define CDW_KEY_TAB     '\t'
+/* End of Transmission, Ctrl+D. Right now used in place where child
+   process is waiting for keyboard input. */
+#define CDW_KEY_EOT       4
 
 
+/* Length of input fields. Does not include +1 for NUL terminating a
+   (char *) string. */
+/* I think that I'm presenting almost all of mkudffs options (with
+   perhaps one exception), so the field for "other" options doesn't
+   need to be very long. */
+#define CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX    200
+/* rsync provides quite a few command-line options. 600 should be
+   enough to store them. */
+#define CDW_RSYNC_OPTIONS_LEN_MAX            600
 
-/* boolean, but with three values */
+
+/* Boolean, but with three values.
+   FIXME: this is not a good idea, seriously. Fix this, get rid of this enum. */
 enum {
-	CDW_UNKNOWN = -1, /* also known as "init" */
+       	CDW_UNKNOWN = -1, /* Sometimes may be used as initial value. */
 	CDW_FALSE   =  0,
 	CDW_TRUE    = +1
 };
diff -Naur orig/src/Makefile.am patched/src/Makefile.am
--- orig/src/Makefile.am	2011-12-31 17:31:45.000000000 +0100
+++ patched/src/Makefile.am	2014-01-19 18:58:02.000000000 +0100
@@ -11,7 +11,8 @@
 
 
 # define common linker flags
-AM_LDFLAGS = -lmenuw -lformw -lpanelw -lncursesw -lpthread -lcdio -liso9660 -lm -lburn
+# AM_LDFLAGS = -lmenuw -lformw -lpanelw -lncursesw -lpthread -lcdio -liso9660 -lm -lburn
+cdw_LIBS = -lmenuw -lformw -lpanelw -lncursesw -lpthread -lcdio -liso9660 -lm -lburn
 
 
 # list source files
@@ -60,7 +61,8 @@
 	$(top_builddir)/gnulib/lib/libgnulib.a \
 	$(top_builddir)/src/external_tools/libcdwexternaltools.a \
 	$(top_builddir)/src/user_interface/widgets/libcdwwidgets.a \
-	$(top_builddir)/src/tasks/libcdwtasks.a
+	$(top_builddir)/src/tasks/libcdwtasks.a \
+	$(cdw_LIBS)
 
 cdw_SOURCES = $(cdw_source_files)
 
@@ -85,7 +87,8 @@
 	$(top_builddir)/gnulib/lib/libgnulib.a \
 	$(top_builddir)/src/external_tools/libcdwexternaltools_check.a \
 	$(top_builddir)/src/user_interface/widgets/libcdwwidgets_check.a \
-	$(top_builddir)/src/tasks/libcdwtasks_check.a
+	$(top_builddir)/src/tasks/libcdwtasks_check.a \
+	$(cdw_LIBS)
 
 cdw_tests_SOURCES = $(cdw_source_files)
 
diff -Naur orig/src/Makefile.in patched/src/Makefile.in
--- orig/src/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/Makefile.in	2014-01-19 20:51:28.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -17,6 +16,51 @@
 
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -33,8 +77,9 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in $(top_srcdir)/Makefile.cdw.am ChangeLog
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp $(noinst_HEADERS) \
+	$(top_srcdir)/test-driver ChangeLog
 bin_PROGRAMS = cdw$(EXEEXT)
 check_PROGRAMS = cdw_tests$(EXEEXT)
 subdir = src
@@ -43,7 +88,7 @@
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(bindir)"
@@ -51,6 +96,7 @@
 am__objects_1 = cdw-cddb.$(OBJEXT) cdw-main.$(OBJEXT)
 am_cdw_OBJECTS = $(am__objects_1)
 cdw_OBJECTS = $(am_cdw_OBJECTS)
+am__DEPENDENCIES_1 =
 cdw_DEPENDENCIES =  \
 	$(top_builddir)/src/external_tools/libcdwexternaltools.a \
 	$(top_builddir)/src/user_interface/widgets/libcdwwidgets.a \
@@ -66,7 +112,7 @@
 	$(top_builddir)/gnulib/lib/libgnulib.a \
 	$(top_builddir)/src/external_tools/libcdwexternaltools.a \
 	$(top_builddir)/src/user_interface/widgets/libcdwwidgets.a \
-	$(top_builddir)/src/tasks/libcdwtasks.a
+	$(top_builddir)/src/tasks/libcdwtasks.a $(am__DEPENDENCIES_1)
 am__objects_2 = cdw_tests-cddb.$(OBJEXT) cdw_tests-main.$(OBJEXT)
 am_cdw_tests_OBJECTS = $(am__objects_2)
 cdw_tests_OBJECTS = $(am_cdw_tests_OBJECTS)
@@ -85,34 +131,286 @@
 	$(top_builddir)/gnulib/lib/libgnulib.a \
 	$(top_builddir)/src/external_tools/libcdwexternaltools_check.a \
 	$(top_builddir)/src/user_interface/widgets/libcdwwidgets_check.a \
-	$(top_builddir)/src/tasks/libcdwtasks_check.a
+	$(top_builddir)/src/tasks/libcdwtasks_check.a \
+	$(am__DEPENDENCIES_1)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(cdw_SOURCES) $(cdw_tests_SOURCES)
 DIST_SOURCES = $(cdw_SOURCES) $(cdw_tests_SOURCES)
-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
-	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 HEADERS = $(noinst_HEADERS)
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
-AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
-	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
-	distdir
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
+	check recheck distdir
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
-am__tty_colors = \
-red=; grn=; lgn=; blu=; std=
+am__tty_colors_dummy = \
+  mgn= red= grn= lgn= blu= brg= std=; \
+  am__color_tests=no
+am__tty_colors = { \
+  $(am__tty_colors_dummy); \
+  if test "X$(AM_COLOR_TESTS)" = Xno; then \
+    am__color_tests=no; \
+  elif test "X$(AM_COLOR_TESTS)" = Xalways; then \
+    am__color_tests=yes; \
+  elif test "X$$TERM" != Xdumb && { test -t 1; } 2>/dev/null; then \
+    am__color_tests=yes; \
+  fi; \
+  if test $$am__color_tests = yes; then \
+    red='[0;31m'; \
+    grn='[0;32m'; \
+    lgn='[1;32m'; \
+    blu='[1;34m'; \
+    mgn='[0;35m'; \
+    brg='[1m'; \
+    std='[m'; \
+  fi; \
+}
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__recheck_rx = ^[ 	]*:recheck:[ 	]*
+am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*
+am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*
+# A command that, given a newline-separated list of test names on the
+# standard input, print the name of the tests that are to be re-run
+# upon "make recheck".
+am__list_recheck_tests = $(AWK) '{ \
+  recheck = 1; \
+  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
+    { \
+      if (rc < 0) \
+        { \
+          if ((getline line2 < ($$0 ".log")) < 0) \
+	    recheck = 0; \
+          break; \
+        } \
+      else if (line ~ /$(am__recheck_rx)[nN][Oo]/) \
+        { \
+          recheck = 0; \
+          break; \
+        } \
+      else if (line ~ /$(am__recheck_rx)[yY][eE][sS]/) \
+        { \
+          break; \
+        } \
+    }; \
+  if (recheck) \
+    print $$0; \
+  close ($$0 ".trs"); \
+  close ($$0 ".log"); \
+}'
+# A command that, given a newline-separated list of test names on the
+# standard input, create the global log from their .trs and .log files.
+am__create_global_log = $(AWK) ' \
+function fatal(msg) \
+{ \
+  print "fatal: making $@: " msg | "cat >&2"; \
+  exit 1; \
+} \
+function rst_section(header) \
+{ \
+  print header; \
+  len = length(header); \
+  for (i = 1; i <= len; i = i + 1) \
+    printf "="; \
+  printf "\n\n"; \
+} \
+{ \
+  copy_in_global_log = 1; \
+  global_test_result = "RUN"; \
+  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
+    { \
+      if (rc < 0) \
+         fatal("failed to read from " $$0 ".trs"); \
+      if (line ~ /$(am__global_test_result_rx)/) \
+        { \
+          sub("$(am__global_test_result_rx)", "", line); \
+          sub("[ 	]*$$", "", line); \
+          global_test_result = line; \
+        } \
+      else if (line ~ /$(am__copy_in_global_log_rx)[nN][oO]/) \
+        copy_in_global_log = 0; \
+    }; \
+  if (copy_in_global_log) \
+    { \
+      rst_section(global_test_result ": " $$0); \
+      while ((rc = (getline line < ($$0 ".log"))) != 0) \
+      { \
+        if (rc < 0) \
+          fatal("failed to read from " $$0 ".log"); \
+        print line; \
+      }; \
+      printf "\n"; \
+    }; \
+  close ($$0 ".trs"); \
+  close ($$0 ".log"); \
+}'
+# Restructured Text title.
+am__rst_title = { sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo; }
+# Solaris 10 'make', and several other traditional 'make' implementations,
+# pass "-e" to $(SHELL), and POSIX 2008 even requires this.  Work around it
+# by disabling -e (using the XSI extension "set +e") if it's set.
+am__sh_e_setup = case $$- in *e*) set +e;; esac
+# Default flags passed to test drivers.
+am__common_driver_flags = \
+  --color-tests "$$am__color_tests" \
+  --enable-hard-errors "$$am__enable_hard_errors" \
+  --expect-failure "$$am__expect_failure"
+# To be inserted before the command running the test.  Creates the
+# directory for the log if needed.  Stores in $dir the directory
+# containing $f, in $tst the test, in $log the log.  Executes the
+# developer- defined test setup AM_TESTS_ENVIRONMENT (if any), and
+# passes TESTS_ENVIRONMENT.  Set up options for the wrapper that
+# will run the test scripts (or their associated LOG_COMPILER, if
+# thy have one).
+am__check_pre = \
+$(am__sh_e_setup);					\
+$(am__vpath_adj_setup) $(am__vpath_adj)			\
+$(am__tty_colors);					\
+srcdir=$(srcdir); export srcdir;			\
+case "$@" in						\
+  */*) am__odir=`echo "./$@" | sed 's|/[^/]*$$||'`;;	\
+    *) am__odir=.;; 					\
+esac;							\
+test "x$$am__odir" = x"." || test -d "$$am__odir" 	\
+  || $(MKDIR_P) "$$am__odir" || exit $$?;		\
+if test -f "./$$f"; then dir=./;			\
+elif test -f "$$f"; then dir=;				\
+else dir="$(srcdir)/"; fi;				\
+tst=$$dir$$f; log='$@'; 				\
+if test -n '$(DISABLE_HARD_ERRORS)'; then		\
+  am__enable_hard_errors=no; 				\
+else							\
+  am__enable_hard_errors=yes; 				\
+fi; 							\
+case " $(XFAIL_TESTS) " in				\
+  *[\ \	]$$f[\ \	]* | *[\ \	]$$dir$$f[\ \	]*) \
+    am__expect_failure=yes;;				\
+  *)							\
+    am__expect_failure=no;;				\
+esac; 							\
+$(AM_TESTS_ENVIRONMENT) $(TESTS_ENVIRONMENT)
+# A shell command to get the names of the tests scripts with any registered
+# extension removed (i.e., equivalently, the names of the test logs, with
+# the '.log' extension removed).  The result is saved in the shell variable
+# '$bases'.  This honors runtime overriding of TESTS and TEST_LOGS.  Sadly,
+# we cannot use something simpler, involving e.g., "$(TEST_LOGS:.log=)",
+# since that might cause problem with VPATH rewrites for suffix-less tests.
+# See also 'test-harness-vpath-rewrite.sh' and 'test-trs-basic.sh'.
+am__set_TESTS_bases = \
+  bases='$(TEST_LOGS)'; \
+  bases=`for i in $$bases; do echo $$i; done | sed 's/\.log$$//'`; \
+  bases=`echo $$bases`
+RECHECK_LOGS = $(TEST_LOGS)
+TEST_SUITE_LOG = test-suite.log
+TEST_EXTENSIONS = @EXEEXT@ .test
+LOG_DRIVER = $(SHELL) $(top_srcdir)/test-driver
+LOG_COMPILE = $(LOG_COMPILER) $(AM_LOG_FLAGS) $(LOG_FLAGS)
+am__set_b = \
+  case '$@' in \
+    */*) \
+      case '$*' in \
+        */*) b='$*';; \
+          *) b=`echo '$@' | sed 's/\.log$$//'`; \
+       esac;; \
+    *) \
+      b='$*';; \
+  esac
+am__test_logs1 = $(TESTS:=.log)
+am__test_logs2 = $(am__test_logs1:@EXEEXT@.log=.log)
+TEST_LOGS = $(am__test_logs2:.test.log=.log)
+TEST_LOG_DRIVER = $(SHELL) $(top_srcdir)/test-driver
+TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \
+	$(TEST_LOG_FLAGS)
 DIST_SUBDIRS = $(SUBDIRS)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 am__relativize = \
@@ -143,6 +441,7 @@
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -303,7 +602,8 @@
 # use $(top_srcdir); $(top_builddir) would fail during "make distcheck"
 
 # define common linker flags
-AM_LDFLAGS = -lmenuw -lformw -lpanelw -lncursesw -lpthread -lcdio -liso9660 -lm -lburn
+# AM_LDFLAGS = -lmenuw -lformw -lpanelw -lncursesw -lpthread -lcdio -liso9660 -lm -lburn
+cdw_LIBS = -lmenuw -lformw -lpanelw -lncursesw -lpthread -lcdio -liso9660 -lm -lburn
 
 # list source files
 cdw_source_files = cddb.c main.c
@@ -325,7 +625,8 @@
 	$(top_builddir)/gnulib/lib/libgnulib.a \
 	$(top_builddir)/src/external_tools/libcdwexternaltools.a \
 	$(top_builddir)/src/user_interface/widgets/libcdwwidgets.a \
-	$(top_builddir)/src/tasks/libcdwtasks.a
+	$(top_builddir)/src/tasks/libcdwtasks.a \
+	$(cdw_LIBS)
 
 cdw_SOURCES = $(cdw_source_files)
 cdw_tests_CPPFLAGS = -DCDW_UNIT_TEST_CODE $(AM_CPPFLAGS)
@@ -345,7 +646,8 @@
 	$(top_builddir)/gnulib/lib/libgnulib.a \
 	$(top_builddir)/src/external_tools/libcdwexternaltools_check.a \
 	$(top_builddir)/src/user_interface/widgets/libcdwwidgets_check.a \
-	$(top_builddir)/src/tasks/libcdwtasks_check.a
+	$(top_builddir)/src/tasks/libcdwtasks_check.a \
+	$(cdw_LIBS)
 
 cdw_tests_SOURCES = $(cdw_source_files)
 
@@ -359,7 +661,7 @@
 all: all-recursive
 
 .SUFFIXES:
-.SUFFIXES: .c .o .obj
+.SUFFIXES: .c .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in:  $(srcdir)/Makefile.am $(top_srcdir)/Makefile.cdw.am $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
@@ -393,14 +695,18 @@
 $(am__aclocal_m4_deps):
 install-binPROGRAMS: $(bin_PROGRAMS)
 	@$(NORMAL_INSTALL)
-	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
 	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(bindir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
+	fi; \
 	for p in $$list; do echo "$$p $$p"; done | \
 	sed 's/$(EXEEXT)$$//' | \
-	while read p p1; do if test -f $$p; \
-	  then echo "$$p"; echo "$$p"; else :; fi; \
+	while read p p1; do if test -f $$p \
+	  ; then echo "$$p"; echo "$$p"; else :; fi; \
 	done | \
-	sed -e 'p;s,.*/,,;n;h' -e 's|.*|.|' \
+	sed -e 'p;s,.*/,,;n;h' \
+	    -e 's|.*|.|' \
 	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
 	sed 'N;N;N;s,\n, ,g' | \
 	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
@@ -421,7 +727,8 @@
 	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
 	files=`for p in $$list; do echo "$$p"; done | \
 	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
-	      -e 's/$$/$(EXEEXT)/' `; \
+	      -e 's/$$/$(EXEEXT)/' \
+	`; \
 	test -n "$$list" || exit 0; \
 	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
 	cd "$(DESTDIR)$(bindir)" && rm -f $$files
@@ -431,12 +738,14 @@
 
 clean-checkPROGRAMS:
 	-test -z "$(check_PROGRAMS)" || rm -f $(check_PROGRAMS)
+
 cdw$(EXEEXT): $(cdw_OBJECTS) $(cdw_DEPENDENCIES) $(EXTRA_cdw_DEPENDENCIES) 
 	@rm -f cdw$(EXEEXT)
-	$(LINK) $(cdw_OBJECTS) $(cdw_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(cdw_OBJECTS) $(cdw_LDADD) $(LIBS)
+
 cdw_tests$(EXEEXT): $(cdw_tests_OBJECTS) $(cdw_tests_DEPENDENCIES) $(EXTRA_cdw_tests_DEPENDENCIES) 
 	@rm -f cdw_tests$(EXEEXT)
-	$(LINK) $(cdw_tests_OBJECTS) $(cdw_tests_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(cdw_tests_OBJECTS) $(cdw_tests_LDADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -450,92 +759,95 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_tests-main.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 cdw-cddb.o: cddb.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw-cddb.o -MD -MP -MF $(DEPDIR)/cdw-cddb.Tpo -c -o cdw-cddb.o `test -f 'cddb.c' || echo '$(srcdir)/'`cddb.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/cdw-cddb.Tpo $(DEPDIR)/cdw-cddb.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cddb.c' object='cdw-cddb.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw-cddb.o -MD -MP -MF $(DEPDIR)/cdw-cddb.Tpo -c -o cdw-cddb.o `test -f 'cddb.c' || echo '$(srcdir)/'`cddb.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/cdw-cddb.Tpo $(DEPDIR)/cdw-cddb.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cddb.c' object='cdw-cddb.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw-cddb.o `test -f 'cddb.c' || echo '$(srcdir)/'`cddb.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw-cddb.o `test -f 'cddb.c' || echo '$(srcdir)/'`cddb.c
 
 cdw-cddb.obj: cddb.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw-cddb.obj -MD -MP -MF $(DEPDIR)/cdw-cddb.Tpo -c -o cdw-cddb.obj `if test -f 'cddb.c'; then $(CYGPATH_W) 'cddb.c'; else $(CYGPATH_W) '$(srcdir)/cddb.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/cdw-cddb.Tpo $(DEPDIR)/cdw-cddb.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cddb.c' object='cdw-cddb.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw-cddb.obj -MD -MP -MF $(DEPDIR)/cdw-cddb.Tpo -c -o cdw-cddb.obj `if test -f 'cddb.c'; then $(CYGPATH_W) 'cddb.c'; else $(CYGPATH_W) '$(srcdir)/cddb.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/cdw-cddb.Tpo $(DEPDIR)/cdw-cddb.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cddb.c' object='cdw-cddb.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw-cddb.obj `if test -f 'cddb.c'; then $(CYGPATH_W) 'cddb.c'; else $(CYGPATH_W) '$(srcdir)/cddb.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw-cddb.obj `if test -f 'cddb.c'; then $(CYGPATH_W) 'cddb.c'; else $(CYGPATH_W) '$(srcdir)/cddb.c'; fi`
 
 cdw-main.o: main.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw-main.o -MD -MP -MF $(DEPDIR)/cdw-main.Tpo -c -o cdw-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/cdw-main.Tpo $(DEPDIR)/cdw-main.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='main.c' object='cdw-main.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw-main.o -MD -MP -MF $(DEPDIR)/cdw-main.Tpo -c -o cdw-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/cdw-main.Tpo $(DEPDIR)/cdw-main.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='main.c' object='cdw-main.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
 
 cdw-main.obj: main.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw-main.obj -MD -MP -MF $(DEPDIR)/cdw-main.Tpo -c -o cdw-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/cdw-main.Tpo $(DEPDIR)/cdw-main.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='main.c' object='cdw-main.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw-main.obj -MD -MP -MF $(DEPDIR)/cdw-main.Tpo -c -o cdw-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/cdw-main.Tpo $(DEPDIR)/cdw-main.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='main.c' object='cdw-main.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
 
 cdw_tests-cddb.o: cddb.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw_tests-cddb.o -MD -MP -MF $(DEPDIR)/cdw_tests-cddb.Tpo -c -o cdw_tests-cddb.o `test -f 'cddb.c' || echo '$(srcdir)/'`cddb.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/cdw_tests-cddb.Tpo $(DEPDIR)/cdw_tests-cddb.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cddb.c' object='cdw_tests-cddb.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw_tests-cddb.o -MD -MP -MF $(DEPDIR)/cdw_tests-cddb.Tpo -c -o cdw_tests-cddb.o `test -f 'cddb.c' || echo '$(srcdir)/'`cddb.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/cdw_tests-cddb.Tpo $(DEPDIR)/cdw_tests-cddb.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cddb.c' object='cdw_tests-cddb.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw_tests-cddb.o `test -f 'cddb.c' || echo '$(srcdir)/'`cddb.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw_tests-cddb.o `test -f 'cddb.c' || echo '$(srcdir)/'`cddb.c
 
 cdw_tests-cddb.obj: cddb.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw_tests-cddb.obj -MD -MP -MF $(DEPDIR)/cdw_tests-cddb.Tpo -c -o cdw_tests-cddb.obj `if test -f 'cddb.c'; then $(CYGPATH_W) 'cddb.c'; else $(CYGPATH_W) '$(srcdir)/cddb.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/cdw_tests-cddb.Tpo $(DEPDIR)/cdw_tests-cddb.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cddb.c' object='cdw_tests-cddb.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw_tests-cddb.obj -MD -MP -MF $(DEPDIR)/cdw_tests-cddb.Tpo -c -o cdw_tests-cddb.obj `if test -f 'cddb.c'; then $(CYGPATH_W) 'cddb.c'; else $(CYGPATH_W) '$(srcdir)/cddb.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/cdw_tests-cddb.Tpo $(DEPDIR)/cdw_tests-cddb.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cddb.c' object='cdw_tests-cddb.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw_tests-cddb.obj `if test -f 'cddb.c'; then $(CYGPATH_W) 'cddb.c'; else $(CYGPATH_W) '$(srcdir)/cddb.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw_tests-cddb.obj `if test -f 'cddb.c'; then $(CYGPATH_W) 'cddb.c'; else $(CYGPATH_W) '$(srcdir)/cddb.c'; fi`
 
 cdw_tests-main.o: main.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw_tests-main.o -MD -MP -MF $(DEPDIR)/cdw_tests-main.Tpo -c -o cdw_tests-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/cdw_tests-main.Tpo $(DEPDIR)/cdw_tests-main.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='main.c' object='cdw_tests-main.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw_tests-main.o -MD -MP -MF $(DEPDIR)/cdw_tests-main.Tpo -c -o cdw_tests-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/cdw_tests-main.Tpo $(DEPDIR)/cdw_tests-main.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='main.c' object='cdw_tests-main.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw_tests-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw_tests-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
 
 cdw_tests-main.obj: main.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw_tests-main.obj -MD -MP -MF $(DEPDIR)/cdw_tests-main.Tpo -c -o cdw_tests-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/cdw_tests-main.Tpo $(DEPDIR)/cdw_tests-main.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='main.c' object='cdw_tests-main.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cdw_tests-main.obj -MD -MP -MF $(DEPDIR)/cdw_tests-main.Tpo -c -o cdw_tests-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/cdw_tests-main.Tpo $(DEPDIR)/cdw_tests-main.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='main.c' object='cdw_tests-main.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw_tests-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(cdw_tests_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cdw_tests-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
 
 # This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
 	  echo "Making $$target in $$subdir"; \
 	  if test "$$subdir" = "."; then \
 	    dot_seen=yes; \
@@ -550,57 +862,12 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test "$$subdir" = "."; then :; else \
-	    rev="$$subdir $$rev"; \
-	  fi; \
-	done; \
-	rev="$$rev ."; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done && test -z "$$fail"
-tags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
-	done
-ctags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
-	done
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
 
-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
 	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
@@ -616,12 +883,7 @@
 	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -633,15 +895,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -650,102 +908,187 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-check-TESTS: $(TESTS)
-	@failed=0; all=0; xfail=0; xpass=0; skip=0; \
-	srcdir=$(srcdir); export srcdir; \
-	list=' $(TESTS) '; \
-	$(am__tty_colors); \
-	if test -n "$$list"; then \
-	  for tst in $$list; do \
-	    if test -f ./$$tst; then dir=./; \
-	    elif test -f $$tst; then dir=; \
-	    else dir="$(srcdir)/"; fi; \
-	    if $(TESTS_ENVIRONMENT) $${dir}$$tst; then \
-	      all=`expr $$all + 1`; \
-	      case " $(XFAIL_TESTS) " in \
-	      *[\ \	]$$tst[\ \	]*) \
-		xpass=`expr $$xpass + 1`; \
-		failed=`expr $$failed + 1`; \
-		col=$$red; res=XPASS; \
-	      ;; \
-	      *) \
-		col=$$grn; res=PASS; \
-	      ;; \
-	      esac; \
-	    elif test $$? -ne 77; then \
-	      all=`expr $$all + 1`; \
-	      case " $(XFAIL_TESTS) " in \
-	      *[\ \	]$$tst[\ \	]*) \
-		xfail=`expr $$xfail + 1`; \
-		col=$$lgn; res=XFAIL; \
-	      ;; \
-	      *) \
-		failed=`expr $$failed + 1`; \
-		col=$$red; res=FAIL; \
-	      ;; \
-	      esac; \
-	    else \
-	      skip=`expr $$skip + 1`; \
-	      col=$$blu; res=SKIP; \
-	    fi; \
-	    echo "$${col}$$res$${std}: $$tst"; \
-	  done; \
-	  if test "$$all" -eq 1; then \
-	    tests="test"; \
-	    All=""; \
-	  else \
-	    tests="tests"; \
-	    All="All "; \
+# Recover from deleted '.trs' file; this should ensure that
+# "rm -f foo.log; make foo.trs" re-run 'foo.test', and re-create
+# both 'foo.log' and 'foo.trs'.  Break the recipe in two subshells
+# to avoid problems with "make -n".
+.log.trs:
+	rm -f $< $@
+	$(MAKE) $(AM_MAKEFLAGS) $<
+
+# Leading 'am--fnord' is there to ensure the list of targets does not
+# expand to empty, as could happen e.g. with make check TESTS=''.
+am--fnord $(TEST_LOGS) $(TEST_LOGS:.log=.trs): $(am__force_recheck)
+am--force-recheck:
+	@:
+
+$(TEST_SUITE_LOG): $(TEST_LOGS)
+	@$(am__set_TESTS_bases); \
+	am__f_ok () { test -f "$$1" && test -r "$$1"; }; \
+	redo_bases=`for i in $$bases; do \
+	              am__f_ok $$i.trs && am__f_ok $$i.log || echo $$i; \
+	            done`; \
+	if test -n "$$redo_bases"; then \
+	  redo_logs=`for i in $$redo_bases; do echo $$i.log; done`; \
+	  redo_results=`for i in $$redo_bases; do echo $$i.trs; done`; \
+	  if $(am__make_dryrun); then :; else \
+	    rm -f $$redo_logs && rm -f $$redo_results || exit 1; \
 	  fi; \
-	  if test "$$failed" -eq 0; then \
-	    if test "$$xfail" -eq 0; then \
-	      banner="$$All$$all $$tests passed"; \
-	    else \
-	      if test "$$xfail" -eq 1; then failures=failure; else failures=failures; fi; \
-	      banner="$$All$$all $$tests behaved as expected ($$xfail expected $$failures)"; \
-	    fi; \
-	  else \
-	    if test "$$xpass" -eq 0; then \
-	      banner="$$failed of $$all $$tests failed"; \
+	fi; \
+	if test -n "$$am__remaking_logs"; then \
+	  echo "fatal: making $(TEST_SUITE_LOG): possible infinite" \
+	       "recursion detected" >&2; \
+	else \
+	  am__remaking_logs=yes $(MAKE) $(AM_MAKEFLAGS) $$redo_logs; \
+	fi; \
+	if $(am__make_dryrun); then :; else \
+	  st=0;  \
+	  errmsg="fatal: making $(TEST_SUITE_LOG): failed to create"; \
+	  for i in $$redo_bases; do \
+	    test -f $$i.trs && test -r $$i.trs \
+	      || { echo "$$errmsg $$i.trs" >&2; st=1; }; \
+	    test -f $$i.log && test -r $$i.log \
+	      || { echo "$$errmsg $$i.log" >&2; st=1; }; \
+	  done; \
+	  test $$st -eq 0 || exit 1; \
+	fi
+	@$(am__sh_e_setup); $(am__tty_colors); $(am__set_TESTS_bases); \
+	ws='[ 	]'; \
+	results=`for b in $$bases; do echo $$b.trs; done`; \
+	test -n "$$results" || results=/dev/null; \
+	all=`  grep "^$$ws*:test-result:"           $$results | wc -l`; \
+	pass=` grep "^$$ws*:test-result:$$ws*PASS"  $$results | wc -l`; \
+	fail=` grep "^$$ws*:test-result:$$ws*FAIL"  $$results | wc -l`; \
+	skip=` grep "^$$ws*:test-result:$$ws*SKIP"  $$results | wc -l`; \
+	xfail=`grep "^$$ws*:test-result:$$ws*XFAIL" $$results | wc -l`; \
+	xpass=`grep "^$$ws*:test-result:$$ws*XPASS" $$results | wc -l`; \
+	error=`grep "^$$ws*:test-result:$$ws*ERROR" $$results | wc -l`; \
+	if test `expr $$fail + $$xpass + $$error` -eq 0; then \
+	  success=true; \
+	else \
+	  success=false; \
+	fi; \
+	br='==================='; br=$$br$$br$$br$$br; \
+	result_count () \
+	{ \
+	    if test x"$$1" = x"--maybe-color"; then \
+	      maybe_colorize=yes; \
+	    elif test x"$$1" = x"--no-color"; then \
+	      maybe_colorize=no; \
 	    else \
-	      if test "$$xpass" -eq 1; then passes=pass; else passes=passes; fi; \
-	      banner="$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)"; \
+	      echo "$@: invalid 'result_count' usage" >&2; exit 4; \
 	    fi; \
-	  fi; \
-	  dashes="$$banner"; \
-	  skipped=""; \
-	  if test "$$skip" -ne 0; then \
-	    if test "$$skip" -eq 1; then \
-	      skipped="($$skip test was not run)"; \
+	    shift; \
+	    desc=$$1 count=$$2; \
+	    if test $$maybe_colorize = yes && test $$count -gt 0; then \
+	      color_start=$$3 color_end=$$std; \
 	    else \
-	      skipped="($$skip tests were not run)"; \
+	      color_start= color_end=; \
 	    fi; \
-	    test `echo "$$skipped" | wc -c` -le `echo "$$banner" | wc -c` || \
-	      dashes="$$skipped"; \
-	  fi; \
-	  report=""; \
-	  if test "$$failed" -ne 0 && test -n "$(PACKAGE_BUGREPORT)"; then \
-	    report="Please report to $(PACKAGE_BUGREPORT)"; \
-	    test `echo "$$report" | wc -c` -le `echo "$$banner" | wc -c` || \
-	      dashes="$$report"; \
-	  fi; \
-	  dashes=`echo "$$dashes" | sed s/./=/g`; \
-	  if test "$$failed" -eq 0; then \
-	    col="$$grn"; \
-	  else \
-	    col="$$red"; \
-	  fi; \
-	  echo "$${col}$$dashes$${std}"; \
-	  echo "$${col}$$banner$${std}"; \
-	  test -z "$$skipped" || echo "$${col}$$skipped$${std}"; \
-	  test -z "$$report" || echo "$${col}$$report$${std}"; \
-	  echo "$${col}$$dashes$${std}"; \
-	  test "$$failed" -eq 0; \
-	else :; fi
+	    echo "$${color_start}# $$desc $$count$${color_end}"; \
+	}; \
+	create_testsuite_report () \
+	{ \
+	  result_count $$1 "TOTAL:" $$all   "$$brg"; \
+	  result_count $$1 "PASS: " $$pass  "$$grn"; \
+	  result_count $$1 "SKIP: " $$skip  "$$blu"; \
+	  result_count $$1 "XFAIL:" $$xfail "$$lgn"; \
+	  result_count $$1 "FAIL: " $$fail  "$$red"; \
+	  result_count $$1 "XPASS:" $$xpass "$$red"; \
+	  result_count $$1 "ERROR:" $$error "$$mgn"; \
+	}; \
+	{								\
+	  echo "$(PACKAGE_STRING): $(subdir)/$(TEST_SUITE_LOG)" |	\
+	    $(am__rst_title);						\
+	  create_testsuite_report --no-color;				\
+	  echo;								\
+	  echo ".. contents:: :depth: 2";				\
+	  echo;								\
+	  for b in $$bases; do echo $$b; done				\
+	    | $(am__create_global_log);					\
+	} >$(TEST_SUITE_LOG).tmp || exit 1;				\
+	mv $(TEST_SUITE_LOG).tmp $(TEST_SUITE_LOG);			\
+	if $$success; then						\
+	  col="$$grn";							\
+	 else								\
+	  col="$$red";							\
+	  test x"$$VERBOSE" = x || cat $(TEST_SUITE_LOG);		\
+	fi;								\
+	echo "$${col}$$br$${std}"; 					\
+	echo "$${col}Testsuite summary for $(PACKAGE_STRING)$${std}";	\
+	echo "$${col}$$br$${std}"; 					\
+	create_testsuite_report --maybe-color;				\
+	echo "$$col$$br$$std";						\
+	if $$success; then :; else					\
+	  echo "$${col}See $(subdir)/$(TEST_SUITE_LOG)$${std}";		\
+	  if test -n "$(PACKAGE_BUGREPORT)"; then			\
+	    echo "$${col}Please report to $(PACKAGE_BUGREPORT)$${std}";	\
+	  fi;								\
+	  echo "$$col$$br$$std";					\
+	fi;								\
+	$$success || exit 1
+
+check-TESTS:
+	@list='$(RECHECK_LOGS)';           test -z "$$list" || rm -f $$list
+	@list='$(RECHECK_LOGS:.log=.trs)'; test -z "$$list" || rm -f $$list
+	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+	@set +e; $(am__set_TESTS_bases); \
+	log_list=`for i in $$bases; do echo $$i.log; done`; \
+	trs_list=`for i in $$bases; do echo $$i.trs; done`; \
+	log_list=`echo $$log_list`; trs_list=`echo $$trs_list`; \
+	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) TEST_LOGS="$$log_list"; \
+	exit $$?;
+recheck: all $(check_PROGRAMS) $(check_SCRIPTS)
+	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+	@set +e; $(am__set_TESTS_bases); \
+	bases=`for i in $$bases; do echo $$i; done \
+	         | $(am__list_recheck_tests)` || exit 1; \
+	log_list=`for i in $$bases; do echo $$i.log; done`; \
+	log_list=`echo $$log_list`; \
+	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) \
+	        am__force_recheck=am--force-recheck \
+	        TEST_LOGS="$$log_list"; \
+	exit $$?
+greptest.sh.log: greptest.sh
+	@p='greptest.sh'; \
+	b='greptest.sh'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+.test.log:
+	@p='$<'; \
+	$(am__set_b); \
+	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+@am__EXEEXT_TRUE@.test$(EXEEXT).log:
+@am__EXEEXT_TRUE@	@p='$<'; \
+@am__EXEEXT_TRUE@	$(am__set_b); \
+@am__EXEEXT_TRUE@	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
+@am__EXEEXT_TRUE@	--log-file $$b.log --trs-file $$b.trs \
+@am__EXEEXT_TRUE@	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
+@am__EXEEXT_TRUE@	"$$tst" $(AM_TESTS_FD_REDIRECT)
 
 distdir: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
@@ -779,13 +1122,10 @@
 	done
 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
 	    $(am__relativize); \
 	    new_distdir=$$reldir; \
@@ -835,6 +1175,9 @@
 	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
 	fi
 mostlyclean-generic:
+	-test -z "$(TEST_LOGS)" || rm -f $(TEST_LOGS)
+	-test -z "$(TEST_LOGS:.log=.trs)" || rm -f $(TEST_LOGS:.log=.trs)
+	-test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
 
 clean-generic:
 	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
@@ -916,12 +1259,11 @@
 
 uninstall-am: uninstall-binPROGRAMS
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) check-am \
-	ctags-recursive install-am install-strip tags-recursive
+.MAKE: $(am__recursive_targets) check-am install-am install-strip
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-TESTS check-am clean clean-binPROGRAMS \
-	clean-checkPROGRAMS clean-generic ctags ctags-recursive \
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
+	check-TESTS check-am clean clean-binPROGRAMS \
+	clean-checkPROGRAMS clean-generic cscopelist-am ctags ctags-am \
 	distclean distclean-compile distclean-generic distclean-tags \
 	distdir dvi dvi-am html html-am info info-am install \
 	install-am install-binPROGRAMS install-data install-data-am \
@@ -931,7 +1273,7 @@
 	install-ps-am install-strip installcheck installcheck-am \
 	installdirs installdirs-am maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags tags-recursive \
+	mostlyclean-generic pdf pdf-am ps ps-am recheck tags tags-am \
 	uninstall uninstall-am uninstall-binPROGRAMS
 
 
diff -Naur orig/src/native_file_system/cdw_file.c patched/src/native_file_system/cdw_file.c
--- orig/src/native_file_system/cdw_file.c	2012-02-26 15:30:39.000000000 +0100
+++ patched/src/native_file_system/cdw_file.c	2014-02-25 22:32:19.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _GNU_SOURCE /* strndup() */
@@ -97,12 +97,11 @@
 */
 cdw_file_t *cdw_file_new(const char *dirpath, const char *name)
 {
-	cdw_assert (dirpath != (const char *) NULL, "ERROR: passed to the function NULL as dirpath\n");
+	cdw_assert (dirpath, "ERROR: \"dirpath\" argument is NULL\n");
 
-	cdw_file_t *file = (cdw_file_t *) NULL;
-	file = cdw_file_new_base();
-	if (file == (cdw_file_t *) NULL) {
-		cdw_vdm ("ERROR: failed to create new file with cdw_file_new()\n");
+	cdw_file_t *file = cdw_file_new_base();
+	if (!file) {
+		cdw_vdm ("ERROR: failed to create new file with cdw_file_new_base()\n");
 		return (cdw_file_t *) NULL;
 	}
 
@@ -118,7 +117,20 @@
 	} else {
 		file->is_ref_to_parent_dir = false;
 	}
-
+#if 0
+	/* 2014-02-24: I don't want a dirpath to end with a slash
+	   anymore. I'm almost certain that there is a difference in
+	   passing "/path/to/symlink/to/dir/" and
+	   "/path/to/symlink/to/dir". If such a path is on list of
+	   selected directories, lstat() will recognize first path as
+	   a dir (not what I want), and the second path as symlink
+	   (this is what I want). The difference is significant when
+	   you think about state of "follow symlinks when calculating
+	   space" checkbox in Configuration window.
+
+	   TODO: perhaps the function should be rewritten so that it
+	   makes sure that there is no trailing slash in its arg?
+	*/
 	if (file->type == CDW_FS_DIR) {
 		crv = cdw_fs_correct_dir_path_ending(&(file->fullpath));
 		if (crv != CDW_OK) {
@@ -127,7 +139,7 @@
 			return (cdw_file_t *) NULL;
 		}
 	}
-
+#endif
 	return file;
 }
 
@@ -152,10 +164,10 @@
 	int rv = lstat(file->fullpath, &stbuf);
 	if (rv != -1) {
 		if (S_ISLNK(stbuf.st_mode)) {
-			file->link = true;
+			file->is_link = true;
 			cdw_sdm ("IS a link: \"%s\"\n", file->fullpath);
 		} else {
-			file->link = false;
+			file->is_link = false;
 			cdw_sdm ("IN NOT a link: \"%s\"\n", file->fullpath);
 		}
 		file->invalid = false;
@@ -229,7 +241,7 @@
 	file->fullpath = cdw_string_concat(correct_dirpath, name, (char *) NULL);
 	free(correct_dirpath);
 	correct_dirpath = (char *) NULL;
-	if (file->fullpath == (char *) NULL) {
+	if (!file->fullpath) {
 		cdw_assert (0, "ERROR: failed to concatenate dirpath and name: \"%s\" + \"%s\"\n", dirpath, name);
 		return CDW_ERROR;
 	}
@@ -239,14 +251,14 @@
 		cdw_vdm ("ERROR: failed to get start of file name in fullpath \"%s\"\n", file->fullpath);
 		free(file->fullpath);
 		file->fullpath = (char *) NULL;
-		assert (0);
+		cdw_assert (0, "ERROR: failed to get filename start in \"%s\"\n", file->fullpath);
 		return CDW_ERROR;
 	}
 
 	file->printable_fullpath = cdw_string_get_printable_if_needed(file->fullpath);
 
 #ifndef NDEBUG
-	if (file->printable_fullpath != (char *) NULL) {
+	if (file->printable_fullpath) {
 		ssize_t i = cdw_fs_get_filename_start(file->fullpath);
 		ssize_t j = cdw_fs_get_filename_start(file->printable_fullpath);
 		cdw_assert (i == j, "ERROR: wrong assumption about file name start in path and printable path\n");
@@ -273,8 +285,8 @@
 */
 cdw_file_t *cdw_file_new_base(void)
 {
-	cdw_file_t *file = (cdw_file_t *) malloc (sizeof (cdw_file_t));
-	if (file == (cdw_file_t *) NULL) {
+	cdw_file_t *file = (cdw_file_t *) malloc(sizeof (cdw_file_t));
+	if (!file) {
 		cdw_vdm ("ERROR: failed to allocate memory for new file\n");
 		return (cdw_file_t *) NULL;
 	} else {
@@ -283,7 +295,7 @@
 		file->name_start = -1;
 		file->size = 0;
 		file->invalid = true;
-		file->link = false;
+		file->is_link = false;
 		file->type = CDW_FS_OTHER;
 		file->is_ref_to_parent_dir = false;
 
@@ -307,34 +319,40 @@
 */
 cdw_file_t *cdw_file_duplicate(const cdw_file_t *file)
 {
-	cdw_assert (file != (cdw_file_t *) NULL, "ERROR: passing NULL pointer for duplication\n");
-	cdw_assert (file->fullpath + file->name_start != (char *) NULL, "ERROR: passing file with NULL name for duplication\n");
-	cdw_assert (file->fullpath != (char *) NULL, "ERROR: passing file with NULL fullpath for duplication\n");
+	cdw_assert (file, "ERROR: \"file\" argument is NULL\n");
+	cdw_assert (file->fullpath + file->name_start, "ERROR: passing file with NULL name for duplication\n"); /* TODO: is this test valid? */
+	cdw_assert (file->fullpath, "ERROR: file's fullpath is NULL\n");
 
 	cdw_file_t *copy = (cdw_file_t *) malloc(sizeof(cdw_file_t));
-	if (copy == (cdw_file_t *) NULL) {
+	if (!copy) {
 		cdw_vdm ("ERROR: failed to allocate memory for duplicate of file\n");
 		return (cdw_file_t *) NULL;
 	}
 
-	if (file->printable_fullpath != (char *) NULL) {
+	if (file->printable_fullpath) {
 		copy->printable_fullpath = strdup(file->printable_fullpath);
+		if (!copy->printable_fullpath) {
+			cdw_file_delete(&copy);
+
+			cdw_vdm ("ERROR: failed to duplicate printable fullpath of file (\"%s\")\n", file->printable_fullpath);
+			return (cdw_file_t *) NULL;
+		}
 	} else {
 		copy->printable_fullpath = (char *) NULL;
 	}
 	copy->name_start = file->name_start;
 
 	copy->fullpath = strdup(file->fullpath);
-	if (copy->fullpath == (char *) NULL) {
+	if (!copy->fullpath) {
 		cdw_file_delete(&copy);
 
-		cdw_vdm ("ERROR: failed to duplicate fullpath of file\n");
+		cdw_vdm ("ERROR: failed to duplicate fullpath of file (\"%s\")\n", file->fullpath);
 		return (cdw_file_t *) NULL;
 	}
 
 	copy->type = file->type;
 	copy->size = file->size;
-	copy->link = file->link;
+	copy->is_link = file->is_link;
 	copy->invalid = file->invalid;
 	copy->is_ref_to_parent_dir = file->is_ref_to_parent_dir;
 
@@ -357,23 +375,24 @@
 */
 cdw_rv_t cdw_file_delete(cdw_file_t **file)
 {
-	cdw_assert (file != (cdw_file_t **) NULL, "ERROR: passing null pointer to the function\n");
+	cdw_assert (file != (cdw_file_t **) NULL, "ERROR: \"file\" argument is NULL\n");
 
 	if (*file == (cdw_file_t *) NULL) {
-		cdw_vdm ("ERROR: passed pointer to NULL file to function\n");
+		/* TODO: shouldn't we issue only a warning and return CDW_OK? */
+		cdw_vdm ("ERROR: \"file\" pointer points to NULL file\n");
 		return CDW_ERROR;
 	}
 
-	if ((*file)->printable_fullpath != (char *) NULL) {
+	if ((*file)->printable_fullpath) {
 		free((*file)->printable_fullpath);
 		(*file)->printable_fullpath = (char *) NULL;
 	}
 
-	if ((*file)->fullpath == (char *) NULL) {
-		cdw_vdm ("WARNING: passed to function file with null fullpath\n");
-	} else {
+	if ((*file)->fullpath) {
 		free((*file)->fullpath);
 		(*file)->fullpath = (char *) NULL;
+	} else {
+		cdw_vdm ("WARNING: file's fullpath is NULL\n");
 	}
 
 	free(*file);
@@ -398,24 +417,26 @@
 */
 bool cdw_file_equal(const void *_file1, const void *_file2)
 {
-	cdw_assert (_file1 != (const cdw_file_t *) NULL, "ERROR: first argument is null\n");
-	cdw_assert (_file2 != (const cdw_file_t *) NULL, "ERROR: second argument is null\n");
+	cdw_assert (_file1, "ERROR: first argument is NULL\n");
+	cdw_assert (_file2, "ERROR: second argument is NULL\n");
 
 	const cdw_file_t *file1 = (const cdw_file_t *) _file1;
 	const cdw_file_t *file2 = (const cdw_file_t *) _file2;
 
+	cdw_assert (file1, "ERROR: file1 is NULL\n");
+	cdw_assert (file2, "ERROR: file2 is NULL\n");
 	cdw_assert (file1->name_start > 0, "ERROR: file1->name_start <= 0: %zd\n", file1->name_start);
 	cdw_assert (file2->name_start > 0, "ERROR: file1->name_start <= 0: %zd\n", file2->name_start);
-	cdw_assert (file1->fullpath != (char *) NULL, "ERROR: file1->fullpath is NULL\n");
-	cdw_assert (file2->fullpath != (char *) NULL, "ERROR: file2->fullpath is NULL\n");
+	cdw_assert (file1->fullpath, "ERROR: file1->fullpath is NULL\n");
+	cdw_assert (file2->fullpath, "ERROR: file2->fullpath is NULL\n");
 
-	if (file1 == (const cdw_file_t *) NULL || file2 == (const cdw_file_t *) NULL) {
-		cdw_vdm ("ERROR: one (or two) file was null\n");
+	if (!file1 || !file2) {
+		cdw_vdm ("ERROR: one (or two) file was NULL\n");
 		return false;
 	}
 
-	if (file1->fullpath == (char *) NULL || file2->fullpath == (char *) NULL) {
-		cdw_vdm ("ERROR: one (or two) fullpaths was null\n");
+	if (!file1->fullpath || !file2->fullpath) {
+		cdw_vdm ("ERROR: one (or two) fullpath was NULL\n");
 		return false;
 	} else {
 		if (!strcmp(file1->fullpath, file2->fullpath)) {
@@ -427,7 +448,8 @@
 	}
 
 
-	/* values of file names were tested when testing fullpaths */
+	/* Values of file names were tested when testing fullpaths.
+	   TODO: does this test make sense? */
 	if (file1->fullpath + file1->name_start == (char *) NULL
 	    || file2->fullpath + file2->name_start == (char *) NULL) {
 
@@ -435,9 +457,9 @@
 		return false;
 	}
 
-	if (file1->printable_fullpath == (char *) NULL && file2->printable_fullpath == (char *) NULL) {
-		/* null "printable_fullpath" strings are allowed */
-	} else if (file1->printable_fullpath != (char *) NULL && file2->printable_fullpath != (char *) NULL) {
+	if (!file1->printable_fullpath && !file2->printable_fullpath) {
+		/* NULL "printable_fullpath" strings are allowed. */
+	} else if (file1->printable_fullpath && file2->printable_fullpath) {
 		if (!strcmp(file1->printable_fullpath, file2->printable_fullpath)) {
 			;
 		} else {
@@ -445,7 +467,7 @@
 			return false;
 		}
 	} else {
-		cdw_sdm ("INFO: one printable fullpath is is null, the other is non-null\n");
+		cdw_sdm ("INFO: one printable fullpath is NULL, the other is non-NULL\n");
 		return false;
 
 	}
@@ -467,7 +489,7 @@
 		cdw_sdm ("INFO: files differ in file sizes\n");
 		return false;
 	}
-	if (file1->link != file2->link) {
+	if (file1->is_link != file2->is_link) {
 		cdw_sdm ("INFO: files differ in \"link\" values\n");
 		return false;
 	}
@@ -504,15 +526,15 @@
 */
 void cdw_file_display_file(void *display, void *data, size_t row, size_t h_offset, bool isreverse)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "display is NULL\n");
+	cdw_assert (display, "ERROR: \"display\" argument is NULL\n");
 	CDW_LIST_DISPLAY *displ = (CDW_LIST_DISPLAY *) display;
-	cdw_assert (displ->subwindow != (WINDOW *) NULL, "subwindow of display is NULL\n");
+	cdw_assert (displ->subwindow, "ERROR: subwindow of display is NULL\n");
 
 	int n_cols = getmaxx(displ->subwindow);
 	int n_rows = getmaxy(displ->subwindow);
-	cdw_assert (n_cols > 0, "we have subwindow with 0 columns, or null subwindow\n");
-	cdw_assert (n_rows > (int) row, "row number larger than number of rows in subwindow\n");
-	cdw_assert (data != (void *) NULL, "you try to display null file\n");
+	cdw_assert (n_cols > 0, "ERROR: we have subwindow with 0 columns, or NULL subwindow\n");
+	cdw_assert (n_rows > (int) row, "ERROR: row number larger than number of rows in subwindow\n");
+	cdw_assert (data, "ERROR: you try to display NULL file\n");
 	cdw_file_t *file = (cdw_file_t *) data;
 
 	/* this fills space between item name on the left side of the
@@ -521,14 +543,14 @@
 
 	char *string = (char *) NULL;
 	if (displ->display_format == CDW_LIST_DISPLAY_FORMAT_SHORT) {
-		if (file->printable_fullpath != (char *) NULL) {
+		if (file->printable_fullpath) {
 			string = file->printable_fullpath + file->name_start;
 		} else {
 			string = file->fullpath + file->name_start;
 		}
 	} else if (displ->display_format == CDW_LIST_DISPLAY_FORMAT_LONG) {
-		cdw_assert (file->fullpath != (char *) NULL, "using file without fullpath\n");
-		if (file->printable_fullpath != (char *) NULL) {
+		cdw_assert (file->fullpath, "ERROR: using file without fullpath\n");
+		if (file->printable_fullpath) {
 			string = file->printable_fullpath;
 		} else {
 			string = file->fullpath;
@@ -557,7 +579,7 @@
 	if (file->invalid) {
 		strcpy(format, "!%.*s");
 	} else {
-		if (file->link == true) {
+		if (file->is_link) {
 			strcpy(format, "~%.*s");
 		} else {
 			strcpy(format, "%.*s");
@@ -575,16 +597,16 @@
 		wchar_t dest[1000];
 		size_t conv_len = mbstowcs(dest, string, 50);
 		size_t len = strlen(string);
-		fprintf(stderr, "analyzing \"%s\"\n", string);
+		fprintf(stderr, "INFO: analyzing \"%s\"\n", string);
 		for (size_t i = 0; i < len; i++) {
-			fprintf(stderr, " char: %u - > '%c'\n", (unsigned char) string[i], string[i]);
+			fprintf(stderr, "INFO: char: %u - > '%c'\n", (unsigned char) string[i], string[i]);
 		}
-		fprintf(stderr, " char: strlen(string) = %zd\n", strlen(string));
+		fprintf(stderr, "INFO: char: strlen(string) = %zd\n", strlen(string));
 		for (size_t i = 0; i < len; i++) {
-			fprintf(stderr, " wchar: %u - > '%c'\n", (unsigned char) dest[i], dest[i]);
+			fprintf(stderr, "INFO: wchar: %u - > '%c'\n", (unsigned char) dest[i], dest[i]);
 			//perror("d");
 		}
-		fprintf(stderr, " wchar: wcslen(dest) = %zd, mbstowcs(): %zd\n\n\n", wcslen(dest), conv_len);
+		fprintf(stderr, "INFO: wchar: wcslen(dest) = %zd, mbstowcs(): %zd\n\n\n", wcslen(dest), conv_len);
 	}
 #endif
 
@@ -641,13 +663,12 @@
 */
 cdw_rv_t cdw_file_dealloc_files_from_list(cdw_dll_item_t *list)
 {
-	if (list != (cdw_dll_item_t *) NULL) {
-		cdw_dll_item_t *item = list;
-		for ( ; item != (cdw_dll_item_t *) NULL; item = item->next) {
+	if (list) {
+		for (cdw_dll_item_t *item = list; item; item = item->next) {
 			cdw_file_delete((cdw_file_t **) &(item->data));
 		}
 	} else {
-		cdw_vdm ("INFO: passed NULL list to the function\n");
+		cdw_vdm ("WARNING: passed NULL list to the function\n");
 	}
 
 	return CDW_OK;
@@ -699,13 +720,13 @@
 
 	cdw_file_t *file = cdw_file_new_base();
 
-	cdw_assert_test (file != (cdw_file_t *) NULL, "ERROR: function cdw_file_new_base() failed to allocate file\n");
-	cdw_assert_test (file->fullpath == (char *) NULL, "ERROR: fullpath in new file base is not NULL\n");
+	cdw_assert_test (file, "ERROR: function cdw_file_new_base() failed to allocate file\n");
+	cdw_assert_test (!file->fullpath, "ERROR: fullpath in new file base is not NULL\n");
 	cdw_assert_test (file->name_start == -1, "ERROR: name start is -1 by default\n");
 
 	cdw_assert_test (file->size == 0, "ERROR: size of new file is not 0 by default\n");
 	cdw_assert_test (file->invalid == true, "ERROR: file is not invalid by default\n");
-	cdw_assert_test (file->link == false, "ERROR: file is link by default\n");
+	cdw_assert_test (file->is_link == false, "ERROR: file is link by default\n");
 	cdw_assert_test (file->type == CDW_FS_OTHER, "ERROR: file is not CDW_FS_OTHER by default\n");
 	cdw_assert_test (file->is_ref_to_parent_dir == false, "ERROR: file is not ref to parent by default\n");
 
@@ -737,8 +758,8 @@
 	file2.type = CDW_FS_FILE;
 	file1.size = 123456;
 	file2.size = 123456;
-	file1.link = true;
-	file2.link = true;
+	file1.is_link = true;
+	file2.is_link = true;
 	file1.invalid = true;
 	file2.invalid = true;
 	file1.is_ref_to_parent_dir = true;
@@ -835,18 +856,18 @@
 
 
 	/* testing with different "link" field values */
-	file1.link = true;
-	file2.link = true;
+	file1.is_link = true;
+	file2.is_link = true;
 	test = cdw_file_equal((const void *) &file1, (const void *) &file2);
 	cdw_assert_test (test == true, "ERROR: files with the same 'link' fields are recognized as different\n");
 
-	file1.link = false;
-	file2.link = true;
+	file1.is_link = false;
+	file2.is_link = true;
 	test = cdw_file_equal((const void *) &file1, (const void *) &file2);
 	cdw_assert_test (test == false, "ERROR: files with different 'link' fields are recognized as the same\n");
 
-	file1.link = false;
-	file2.link = false;
+	file1.is_link = false;
+	file2.is_link = false;
 	test = cdw_file_equal((const void *) &file1, (const void *) &file2);
 	cdw_assert_test (test == true, "ERROR: files with restored the same 'link' fields are recognized as different\n");
 
@@ -906,16 +927,16 @@
 
 cdw_rv_t test_cdw_file_new_helper(char **cwd, char **dirpath, char **filename)
 {
-	cdw_assert_test (*cwd == (char *) NULL, "ERROR: cwd should be pointer to NULL");
-	cdw_assert_test (*dirpath == (char *) NULL, "ERROR: dirpath should be pointer to NULL");
-	cdw_assert_test (*filename == (char *) NULL, "ERROR: filename should be pointer to NULL");
+	cdw_assert_test (!(*cwd), "ERROR: cwd should be pointer to NULL");
+	cdw_assert_test (!(*dirpath), "ERROR: dirpath should be pointer to NULL");
+	cdw_assert_test (!(*filename), "ERROR: filename should be pointer to NULL");
 
 	/* first get some existing dir path */
 	*cwd = (char *) malloc(PATH_MAX); /* PATH_MAX alreay includes ending null */
-	cdw_assert_test (*cwd != (char *) NULL, "ERROR: failed to allocate memory for cwd\n");
+	cdw_assert_test (*cwd, "ERROR: failed to allocate memory for cwd\n");
 
 	char *res = getcwd(*cwd, PATH_MAX - 1);
-	cdw_assert_test (res != (char *) NULL, "ERROR: failed to get current working directory (1)\n");
+	cdw_assert_test (res, "ERROR: failed to get current working directory (1)\n");
 	cdw_assert_test (res == *cwd, "ERROR: failed to get current working directory (2)\n");
 	cdw_rv_t crv = cdw_fs_correct_dir_path_ending(cwd);
 	cdw_assert_test (crv == CDW_OK, "ERROR: failed to ensure proper ending of cwd\n");
@@ -926,8 +947,7 @@
 	// cdw_vdm ("INFO: cwd = \"%s\", start = %d\n", *cwd, start);
 	*filename = strdup(*cwd + start);
 	*dirpath = strndup(*cwd, (size_t) start);
-	cdw_assert_test (*filename != (char *) NULL && *dirpath != (char *) NULL,
-			 "ERROR: failed to strdup() filename and dirpath\n");
+	cdw_assert_test (*filename && *dirpath, "ERROR: failed to strdup() filename and dirpath\n");
 	// cdw_vdm ("INFO: dirtpath = \"%s\"\n", *dirpath);
 	// cdw_vdm ("INFO: filename = \"%s\"\n", *filename);
 
@@ -951,14 +971,14 @@
 	/* create file and test it */
 
 	cdw_file_t *file = cdw_file_new(dirpath, filename);
-	cdw_assert_test (file != (cdw_file_t *) NULL, "ERROR: function cdw_file_new_base() failed to allocate file\n");
+	cdw_assert_test (file, "ERROR: function cdw_file_new_base() failed to allocate file\n");
 
-	cdw_assert_test (file->fullpath != (char *) NULL, "ERROR: fullpath in new file base is NULL\n");
+	cdw_assert_test (file->fullpath, "ERROR: fullpath in new file base is NULL\n");
 	cdw_assert_test (!strcmp(file->fullpath, cwd), "ERROR: incorrect fullpath: should be \"%s\", is: \"%s\"\n", cwd, file->fullpath);
 	cdw_assert_test (!strcmp(file->fullpath + file->name_start, filename), "ERROR: incorrect name: should be \"%s\", is: \"%s\"\n", filename, file->fullpath + file->name_start);
 	cdw_assert_test (file->size == 0, "ERROR: size of new file is not 0 for dir\n");
 	cdw_assert_test (file->invalid == false, "ERROR: existing file is invalid\n");
-	cdw_assert_test (file->link == false, "ERROR: dir is link\n");
+	cdw_assert_test (file->is_link == false, "ERROR: dir is link\n");
 	cdw_assert_test (file->type == CDW_FS_DIR, "ERROR: dir is not recognized as dir\n");
 	cdw_assert_test (file->is_ref_to_parent_dir == false, "ERROR: current dir should not be reference to parent dir\n");
 
@@ -966,7 +986,7 @@
 
 	// char **f = &(file->fullpath);
 	cdw_file_delete(&file);
-	cdw_assert_test (file == (cdw_file_t *) NULL, "ERROR: failed to correctly delete file, file is not NULL\n");
+	cdw_assert_test (!file, "ERROR: failed to correctly delete file, file is not NULL\n");
 	/* on some occasions this assertion fails, but valgrind doesn't
 	   complain about leaking memory related to file->fullpath */
 	// cdw_assert_test (*f == (char *) NULL, "ERROR: failed to correctly nullify file->fullpath, it doesn't point to NULL\n");
@@ -1001,14 +1021,14 @@
 	/* create file and test it (we tested creating file before, but just in case... */
 
 	cdw_file_t *file = cdw_file_new(dirpath, filename);
-	cdw_assert_test (file != (cdw_file_t *) NULL, "ERROR: function cdw_file_new_base() failed to allocate file\n");
+	cdw_assert_test (file, "ERROR: function cdw_file_new_base() failed to allocate file\n");
 
-	cdw_assert_test (file->fullpath != (char *) NULL, "ERROR: fullpath in new file base is NULL\n");
+	cdw_assert_test (file->fullpath, "ERROR: fullpath in new file base is NULL\n");
 	cdw_assert_test (!strcmp(file->fullpath, cwd), "ERROR: incorrect fullpath: should be \"%s\", is: \"%s\"\n", cwd, file->fullpath);
 	cdw_assert_test (!strcmp(file->fullpath + file->name_start, filename), "ERROR: incorrect name: should be \"%s\", is: \"%s\"\n", filename, file->fullpath + file->name_start);
 	cdw_assert_test (file->size == 0, "ERROR: size of new file is not 0 for dir\n");
 	cdw_assert_test (file->invalid == false, "ERROR: existing file is invalid\n");
-	cdw_assert_test (file->link == false, "ERROR: dir is link\n");
+	cdw_assert_test (file->is_link == false, "ERROR: dir is link\n");
 	cdw_assert_test (file->type == CDW_FS_DIR, "ERROR: dir is not recognized as dir\n");
 	cdw_assert_test (file->is_ref_to_parent_dir == false, "ERROR: current dir should not be reference to parent dir\n");
 
@@ -1020,7 +1040,7 @@
 	/* now do the real testing */
 	cdw_file_t *duplicate = cdw_file_duplicate(file);
 
-	cdw_assert_test (duplicate != (cdw_file_t *) NULL, "ERROR: failed to create duplicate of a file\n");
+	cdw_assert_test (duplicate, "ERROR: failed to create duplicate of a file\n");
 	cdw_assert_test (!strcmp(file->fullpath, duplicate->fullpath),
 			 "ERROR: file and its duplicate have different fullpaths:\nfile->fullpath      = \"%s\"\nduplicate->fullpath = \"%s\"\n",
 			 file->fullpath, duplicate->fullpath);
@@ -1033,19 +1053,19 @@
 	cdw_assert_test (file->invalid == duplicate->invalid,
 			 "ERROR: file and its duplicate have different \"invalid\" field values:\nfile->invalid      = %s\nduplicate->invalid = %s\n",
 			 file->invalid ? "true" : "false", duplicate->invalid ? "true" : "false");
-	cdw_assert_test (file->link == duplicate->link,
-			 "ERROR: file and its duplicate have different \"link\" field values:\nfile->link      = %s\nduplicate->link = %s\n",
-			 file->link ? "true" : "false", duplicate->link ? "true" : "false");
+	cdw_assert_test (file->is_link == duplicate->is_link,
+			 "ERROR: file and its duplicate have different \"link\" field values:\nfile->is_link      = %s\nduplicate->is_link = %s\n",
+			 file->is_link ? "true" : "false", duplicate->is_link ? "true" : "false");
 	cdw_assert_test (file->type == duplicate->type,
-			 "ERROR: file and its duplicate have different \"type\" field values:\nfile->link      = %d\nduplicate->link = %d\n",
+			 "ERROR: file and its duplicate have different \"type\" field values:\nfile->is_link      = %d\nduplicate->is_link = %d\n",
 			 file->type, duplicate->type);
 	cdw_assert_test (file->is_ref_to_parent_dir == duplicate->is_ref_to_parent_dir,
 			 "ERROR: file and its duplicate have different \"is reference to parent dir\" field values\n");
 
 	cdw_file_delete(&file);
-	cdw_assert_test (file == (cdw_file_t *) NULL, "ERROR: failed to correctly delete file, file is not NULL\n");
+	cdw_assert_test (!file, "ERROR: failed to correctly delete file, file is not NULL\n");
 	cdw_file_delete(&duplicate);
-	cdw_assert_test (duplicate == (cdw_file_t *) NULL, "ERROR: failed to correctly delete file duplicate, it is not NULL\n");
+	cdw_assert_test (!duplicate, "ERROR: failed to correctly delete file duplicate, it is not NULL\n");
 
 	free(cwd);
 	cwd = (char *) NULL;
@@ -1096,7 +1116,7 @@
 	name = (char *) NULL;
 	free(file.fullpath);
 	file.fullpath = (char *) NULL;
-	if (file.printable_fullpath != (char *) NULL) {
+	if (file.printable_fullpath) {
 		free(file.printable_fullpath);
 		file.printable_fullpath = (char *) NULL;
 	}
@@ -1107,5 +1127,3 @@
 
 
 #endif /* CDW_UNIT_TEST_CODE */
-
-
diff -Naur orig/src/native_file_system/cdw_file.h patched/src/native_file_system/cdw_file.h
--- orig/src/native_file_system/cdw_file.h	2010-05-23 13:23:34.000000000 +0200
+++ patched/src/native_file_system/cdw_file.h	2014-02-25 22:32:46.000000000 +0100
@@ -45,7 +45,7 @@
 	/* is this file a link? this is an important distinction,
 	   because if file is a link, then "type" field holds information
 	   about target of the link */
-	bool link;
+	bool is_link;
 	/* stat() failed for this file: may be invalid file (e.g. broken link) or other reason */
 	bool invalid;
 } cdw_file_t;
diff -Naur orig/src/native_file_system/cdw_file_manager.c patched/src/native_file_system/cdw_file_manager.c
--- orig/src/native_file_system/cdw_file_manager.c	2012-02-26 15:30:50.000000000 +0100
+++ patched/src/native_file_system/cdw_file_manager.c	2014-03-24 22:25:14.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
@@ -68,6 +68,7 @@
 #include "cdw_graftpoints.h"
 #include "cdw_config.h"
 #include "cdw_logging.h"
+#include "canonicalize.h"
 
 extern cdw_config_t global_config;
 
@@ -209,15 +210,16 @@
 */
 void cdw_file_manager_clean(void)
 {
-	if (selected_files.display != (CDW_LIST_DISPLAY *) NULL) {
+	/* This 'if ()' duplicates code from
+	   cdw_file_manager_delete_selected_files_view() and should be
+	   removed from here, but I will leave it for now. */
+	if (selected_files.display) {
 		cdw_file_dealloc_files_from_list(selected_files.display->list);
 		cdw_list_display_delete(&(selected_files.display));
 	}
 
-	if (file_selector.initial_fullpath != (char *) NULL) {
-		free(file_selector.initial_fullpath);
-		file_selector.initial_fullpath = (char *) NULL;
-	}
+	cdw_string_delete(&file_selector.initial_fullpath);
+
 	return;
 }
 
@@ -274,7 +276,7 @@
 	/* selector window, loop, key handling, adding files to list,
 	   etc. is done by this function */
 	cdw_rv_t crv = cdw_file_selector();
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	cdw_rv_t retval = CDW_ERROR;
 	if (crv == CDW_ERROR) {
@@ -329,7 +331,7 @@
 		if (key == KEY_DC) {
 			crv = cdw_selected_files_remove_file(selected_files.display->current_item_ind);
 			if (crv == CDW_OK) {
-				crv = cdw_main_window_volume_info_view_update(-1, -1, false, global_config.follow_symlinks);
+				crv = cdw_main_window_volume_info_view_update(-1, -1, false);
 				if (crv == CDW_OK) {
 					crv = CDW_OK;
 				} else {
@@ -353,7 +355,7 @@
 	}
 	/* FIXME: this function does not inform user when some errors occur */
 
-	crv = cdw_main_window_volume_info_view_update(-1, -1, true, global_config.follow_symlinks);
+	crv = cdw_main_window_volume_info_view_update(-1, -1, true);
 	if (crv == CDW_OK) {
 		return CDW_OK;
 	} else {
@@ -512,7 +514,7 @@
 	if (selected_files.display->n_items > 0) {
 		/* true - upon finishing adding files recount size of
 		   selected files */
-		cdw_rv_t crv = cdw_main_window_volume_info_view_update(-1, -1, true, global_config.follow_symlinks);
+		cdw_rv_t crv = cdw_main_window_volume_info_view_update(-1, -1, true);
 		if (crv == CDW_OK) {
 			return CDW_OK;
 		} else {
@@ -554,7 +556,7 @@
 
 	/* 1, 1 - begin_y, begin_x */
 	selected_files.display = cdw_list_display_new(parent, n_lines - 2, n_cols - 2, 1, 1, CDW_COLORS_MAIN);
-	if (selected_files.display == (CDW_LIST_DISPLAY *) NULL) {
+	if (!selected_files.display) {
 		cdw_vdm ("ERROR: failed to create 'selected files' display\n");
 		cdw_file_manager_internal_error_dialog(CDW_FM_E_NO_SELECTED);
 
@@ -574,6 +576,20 @@
 
 
 
+void cdw_file_manager_delete_selected_files_view(void)
+{
+	if (selected_files.display) {
+		cdw_file_dealloc_files_from_list(selected_files.display->list);
+		cdw_list_display_delete(&(selected_files.display));
+	}
+
+	return;
+}
+
+
+
+
+
 /**
    \brief Display dialog window with error message
 
@@ -654,12 +670,12 @@
    \return size (in megabytes) of all files on 'selected list' on success
    \return -1 on error
 */
-double cdw_file_manager_calculate_selected_files_size_mb(bool follow_symlinks)
+double cdw_file_manager_calculate_selected_files_size_mb(void)
 {
 	cdw_fs_visitor_data_t vdata;
 	vdata.size = 0;
 	vdata.has_file_over_4GB = false;
-	vdata.follow_symlinks = follow_symlinks;
+	vdata.follow_symlinks = global_config.general.selected_follow_symlinks;
 	selected_files.size_mb = 0.0;
 	selected_files.size = 0;
 
@@ -670,7 +686,11 @@
 			   "ERROR: NULL file #%zd was not found on the list of selected files\n", i);
 		cdw_assert(file->fullpath != (char *) NULL, "ERROR: file #%zd has no fullpath\n", i);
 
+#ifndef NDEBUG
+		fprintf(stderr, "\n\n");
+#endif
 		cdw_vdm ("INFO: traversing file \"%s\"\n", file->fullpath);
+
 		cdw_rv_t crv = cdw_fs_traverse_path(file->fullpath, cdw_fs_visitor, &vdata);
 		if (crv != CDW_OK) {
 			cdw_vdm ("ERROR: failed to get dirsize of \"%s\" item\n", file->fullpath);
@@ -678,7 +698,7 @@
 		} else {
 			/* this is to update size displayed next to file name
 			   in "selected files" view - the size may have changed
-			   after toggling "follow_symlinks" flag */
+			   after toggling "selected_follow_symlinks" flag */
 			file->size = vdata.size;
 
 			selected_files.size += vdata.size;
@@ -926,7 +946,7 @@
 	cdw_fs_visitor_data_t vdata;
 	vdata.size = 0;
 	vdata.has_file_over_4GB = false;
-	vdata.follow_symlinks = global_config.follow_symlinks;
+	vdata.follow_symlinks = global_config.general.selected_follow_symlinks;
 
 	cdw_rv_t crv = cdw_fs_traverse_path(file->fullpath, cdw_fs_visitor, &vdata);
 	if (crv == CDW_OK) {
@@ -938,7 +958,7 @@
 			   size of selected files was updated in
 			   cdw_selected_files_clone_and_append_file(), and
 			   will be recounted again on file selector exit */
-			crv = cdw_main_window_volume_info_view_update(-1, -1, false, global_config.follow_symlinks);
+			crv = cdw_main_window_volume_info_view_update(-1, -1, false);
 			/* updating files info view may disrupt part of file
 			   selector window; redraw file selector */
 			cdw_list_display_refresh(fs_browser->display);
@@ -970,3 +990,66 @@
 }
 
 
+
+
+
+/*
+  \brief Look for \p path on list of selected files
+
+  This is just a very simple implementation. It does not attempt to
+  follow symbolic links that may be in selected files list.
+
+  The \p path is canonicalized before function starts looking for it
+  on list of selected files.
+
+  \p can_mode is canonicalization mode, as seen in
+  gnulib/lib/canonicalize.h. Not completely sure if this argument is
+  useful at all.
+
+  TODO: improve the function so that it covers more cases.
+
+  \param path - path to look for on list of selected files
+  \param can_mode - canonicalization mode
+*/
+cdw_rv_t cdw_selected_files_search(const char *path, int can_mode)
+{
+	char *fullpath = canonicalize_filename_mode(path, can_mode);
+	if (!fullpath) {
+		cdw_vdm ("ERROR: failed to canonicalize path \"%s\"\n", path);
+		return CDW_ERROR;
+	} else {
+		cdw_vdm ("INFO: canonicalized: \"%s\"\n", fullpath);
+	}
+
+
+	size_t n = strlen(fullpath);
+
+	size_t i = 0;
+	for (cdw_dll_item_t *f = selected_files.display->list; f; f = f->next) {
+		cdw_file_t *file = (cdw_file_t *) f->data;
+		cdw_assert(file, "ERROR: NULL file #%zd was not found on the list of selected files\n", i);
+		cdw_assert(file->fullpath, "ERROR: file #%zd has no fullpath\n", i);
+
+		size_t sel = strlen(file->fullpath);
+		int cmp = 0;
+		if (sel >= n) {
+			cmp = strncmp(fullpath, file->fullpath, n);
+		} else {
+			cmp = strncmp(fullpath, file->fullpath, n);
+		}
+
+		if (!cmp) {
+			free(fullpath);
+			fullpath = (char *) NULL;
+
+			return CDW_OK;
+		}
+
+		i++;
+	}
+
+	free(fullpath);
+	fullpath = (char *) NULL;
+
+	return CDW_NO;
+}
diff -Naur orig/src/native_file_system/cdw_file_manager.h patched/src/native_file_system/cdw_file_manager.h
--- orig/src/native_file_system/cdw_file_manager.h	2011-04-05 23:45:23.000000000 +0200
+++ patched/src/native_file_system/cdw_file_manager.h	2014-03-24 22:26:21.000000000 +0100
@@ -12,18 +12,19 @@
 
 
 cdw_rv_t cdw_file_manager_init(void);
-void cdw_file_manager_clean(void);
+void     cdw_file_manager_clean(void);
 
 cdw_rv_t cdw_file_manager_handle_adding_to_selected_files(void);
 cdw_rv_t cdw_file_manager_handle_deleting_from_selected_files(void);
 
 cdw_rv_t cdw_file_manager_create_selected_files_view(WINDOW *window);
 cdw_rv_t cdw_file_manager_regenerate_selected_files_view(void);
+void     cdw_file_manager_delete_selected_files_view(void);
 
-bool cdw_file_manager_any_files_selected(void);
+bool   cdw_file_manager_any_files_selected(void);
 size_t cdw_file_manager_number_of_selected_files(void);
-double cdw_file_manager_calculate_selected_files_size_mb(bool follow_symlinks);
-void cdw_file_manager_scan_selected_files(void);
+double cdw_file_manager_calculate_selected_files_size_mb(void);
+void   cdw_file_manager_scan_selected_files(void);
 
 cdw_rv_t cdw_file_manager_create_graftpoints_file(void);
 void cdw_file_manager_delete_graftpoints_file(void);
@@ -33,8 +34,7 @@
 
 bool      cdw_selected_files_file_over_4gb_present(void);
 long long cdw_selected_files_get_size(void);
-
+cdw_rv_t  cdw_selected_files_search(const char *path, int can_mode);
 
 
 #endif /* H_CDW_FILE_MANAGER */
-
diff -Naur orig/src/native_file_system/cdw_file_picker.c patched/src/native_file_system/cdw_file_picker.c
--- orig/src/native_file_system/cdw_file_picker.c	2012-02-26 15:30:21.000000000 +0100
+++ patched/src/native_file_system/cdw_file_picker.c	2014-03-22 20:46:52.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #define _BSD_SOURCE /* strdup() */
 
@@ -91,9 +91,6 @@
 
 
 
-//static cdw_rv_t cdw_fs_ui_get_path_check(char *fullpath, int cdw_file_type, int perms, int new_or_existing);
-//static cdw_rv_t cdw_fs_ui_get_safe_path(const char *title, const char *message, char **buffer);
-
 static void     cdw_fs_ui_file_picker_init(struct cdw_file_picker *picker);
 static cdw_rv_t cdw_fs_ui_file_picker_build(struct cdw_file_picker *picker, const char *title, const char *message, const char *initial_fullpath);
 static cdw_rv_t cdw_fs_ui_file_picker_driver(struct cdw_file_picker *picker);
@@ -325,15 +322,34 @@
 					   be taken from fs_browser */
 					cdw_file_t *file = cdw_fs_browser_get_current_file(picker->fs_browser);
 					if (file->is_ref_to_parent_dir) {
-						/* don't synchronize: don't put
-						   "/some/path/.." in input line,
-						   because it is annoying */
+						/* Don't put
+						   "/some/path/.." in
+						   input line, because
+						   it is annoying. */
+						char *cut = strdup(file->fullpath);
+						if (cut) {
+							/* Just to be 100% sure that me and the code base agree on contents of the fullpath string. */
+							cdw_assert (cut[file->name_start] == '.'
+								    && cut[file->name_start + 1] == '.',
+								    "ERROR: fullpath to parent dir does not end with '..': \"%s\"\n", file->fullpath);
+
+							cut[file->name_start] = '\0';
+							cdw_input_line_refresh_with_string(picker->input.input_line, cut);
+							cdw_string_set(&picker->fullpath, cut);
+							free(cut);
+							cut = (char *) NULL;
+						} else {
+							cdw_input_line_refresh_with_string(picker->input.input_line, file->fullpath);
+							cdw_string_set(&picker->fullpath, file->fullpath);
+						}
 					} else {
 						cdw_input_line_refresh_with_string(picker->input.input_line, file->fullpath);
 						cdw_string_set(&picker->fullpath, file->fullpath);
-						cdw_vdm ("INFO: SYNCHRONIZATION POINT: non-escape key \"%s\" in fs browser\n", cdw_ncurses_key_label(key));
-						cdw_vdm ("INFO: fs browser fullpath at synchronization point: \"%s\"\n", file->fullpath);
+
 					}
+					cdw_vdm ("INFO: SYNCHRONIZATION POINT: non-escape key \"%s\" in fs browser\n", cdw_ncurses_key_label(key));
+					cdw_vdm ("INFO: fs browser fullpath at synchronization point: \"%s\"\n", picker->fullpath);
+
 					if (key == CDW_KEY_TAB) {
 						break;
 					}
@@ -672,6 +688,3 @@
 		return -1;
 	}
 }
-
-
-
diff -Naur orig/src/native_file_system/cdw_fs_browser.c patched/src/native_file_system/cdw_fs_browser.c
--- orig/src/native_file_system/cdw_fs_browser.c	2012-03-03 21:08:37.000000000 +0100
+++ patched/src/native_file_system/cdw_fs_browser.c	2014-04-06 23:07:32.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
@@ -85,7 +85,7 @@
 cdw_fs_browser_t *cdw_fs_browser_new(WINDOW *window, const char *initial_fullpath)
 {
 	cdw_fs_browser_t *browser = cdw_fs_browser_new_base(window);
-	if (browser == (cdw_fs_browser_t *) NULL) {
+	if (!browser) {
 		cdw_vdm ("ERROR: failed to create browser's base\n");
 		return (cdw_fs_browser_t *) NULL;
 	}
@@ -105,7 +105,7 @@
 		cdw_vdm ("WARNING: failed to get file name start in \"%s\"\n", initial_fullpath);
 	} else {
 		char *parent = strndup(initial_fullpath, (size_t) i);
-		cdw_assert (parent != (char *) NULL, "ERROR: failed to strndup fullpath \"%s\"\n", initial_fullpath);
+		cdw_assert (parent, "ERROR: failed to strndup fullpath \"%s\"\n", initial_fullpath);
 		rv = cdw_fs_browser_browse_to(browser, parent);
 		free(parent);
 		parent = (char *) NULL;
@@ -119,7 +119,7 @@
 	   cdw_fs_get_initial_dirpath() tries to return one of following:
 	   current working dir, "home" dir, "/tmp" dir, or "/" (root) dir */
 	char *tmp = cdw_fs_get_initial_dirpath();
-	if (tmp != (char *) NULL) {
+	if (tmp) {
 		rv = cdw_fs_browser_browse_to(browser, tmp);
 		if (rv == 0) {
 			/* success, browsed to given location and refreshed the view */
@@ -131,7 +131,7 @@
 		cdw_vdm ("ERROR: can't get any safe initial dirpath for fs browser, this is bad\n");
 	}
 
-	cdw_fs_browser_internal_error_dialog(CDW_ERROR);
+	cdw_fs_browser_internal_error_dialog(CDW_FS_CHECK_GEN_ERROR);
 	cdw_fs_browser_delete(&browser);
 	return (cdw_fs_browser_t *) NULL;
 }
@@ -154,10 +154,10 @@
 */
 cdw_fs_browser_t *cdw_fs_browser_new_base(WINDOW *window)
 {
-	cdw_assert (window != (WINDOW *) NULL, "ERROR: \"window\" argument is NULL\n");
+	cdw_assert (window, "ERROR: \"window\" argument is NULL\n");
 
-	cdw_fs_browser_t *browser = (cdw_fs_browser_t *) malloc (sizeof (cdw_fs_browser_t));
-	if (browser == (cdw_fs_browser_t *) NULL) {
+	cdw_fs_browser_t *browser = (cdw_fs_browser_t *) malloc(sizeof (cdw_fs_browser_t));
+	if (!browser) {
 		cdw_vdm ("ERROR: failed to allocate memory for fs browser\n");
 		return (cdw_fs_browser_t *) NULL;
 	}
@@ -173,7 +173,7 @@
 	browser->display = cdw_list_display_new(window, n_lines, n_cols, 1, 1, CDW_COLORS_DIALOG);
 	if (browser->display == (CDW_LIST_DISPLAY *) NULL) {
 		cdw_vdm ("ERROR: failed to create file_browser display\n");
-		cdw_fs_browser_internal_error_dialog(CDW_ERROR);
+		cdw_fs_browser_internal_error_dialog(CDW_FS_CHECK_GEN_ERROR);
 
 		free(browser);
 		browser = (cdw_fs_browser_t *) NULL;
@@ -277,7 +277,7 @@
 		   disc - the disc wasn't reconnected (?) after coming from
 		   suspension to RAM */
 		cdw_vdm ("ERROR: scandir() returns -1 for dirpath \"%s\"\n", dirpath);
-		cdw_fs_browser_internal_error_dialog(CDW_ERROR);
+		cdw_fs_browser_internal_error_dialog(CDW_FS_CHECK_GEN_ERROR);
 		return 0;
 	} else if (n_files == 0) {
 		/* not going to happen, with scandir() called with one(),
@@ -286,7 +286,7 @@
 		return 0;
 	} else {
 		unsigned long long n = (unsigned long long) n_files;
-		unsigned long long cp = cdw_fs_copy_dirent_to_list(list, dirpath, eps, n, global_config.fs.display_hidden_files);
+		unsigned long long cp = cdw_fs_copy_dirent_to_list(list, dirpath, eps, n, global_config.general.display_hidden_files);
 
 		/* eps is no longer needed, all interesting information about
 		   directory content is now in display->list */
@@ -306,6 +306,7 @@
 			cdw_vdm ("ERROR: failed to copy dirent to list for dirpath \"%s\"\n", dirpath);
 			return 0;
 		} else {
+#if 0
 #ifndef NDEBUG
 			cdw_vdm ("INFO: Content of current directory \"%s\":\n", dirpath);
 			for (unsigned long long i = 0; i < cp; i++) {
@@ -315,6 +316,7 @@
 				cdw_vdm ("INFO:       file #%6lld = \"%s\"\n", i, file->fullpath + f);
 			}
 #endif
+#endif
 			return cp;
 		}
 	}
@@ -350,7 +352,7 @@
 */
 cdw_rv_t cdw_fs_browser_change_dir_on_enter(cdw_fs_browser_t *browser)
 {
-	cdw_assert (browser->display != (CDW_LIST_DISPLAY *) NULL, "ERROR: display is null\n");
+	cdw_assert (browser->display, "ERROR: display is NULL\n");
 	cdw_assert (browser->display->n_items > browser->display->current_item_ind,
 		    "ERROR, item index (0-based) is %zd but number of items is %zd\n",
 		    browser->display->current_item_ind, browser->display->n_items);
@@ -372,9 +374,16 @@
 	if (file->is_ref_to_parent_dir) {
 		/* "/some/dir/../", remove last dir from the path */
 		new_dirpath = cdw_fs_shorten_fullpath(file);
-		if (new_dirpath == (char *) NULL) {
+		if (!new_dirpath) {
 			cdw_vdm ("ERROR: failed to shorten fullpath \"%s\"\n", file->fullpath);
 			return CDW_ERROR;
+		} else if (!strcmp(new_dirpath, "/..") || !strcmp(new_dirpath, "/")) {
+			/* Don't attempt to re-read root directory
+			   again. This may fail because the code will
+			   try to find a (null) file to browse to. */
+			free(new_dirpath);
+			new_dirpath = (char *) NULL;
+			return CDW_OK;
 		}
 
 		/* browse_to_file() moves cursor (focus) to directory item from
@@ -384,7 +393,7 @@
 	} else {
 		/* canonicalize because current item may be a link */
 		new_dirpath = canonicalize_filename_mode(file->fullpath, CAN_MISSING);
-		if (new_dirpath == (char *) NULL) {
+		if (!new_dirpath) {
 			/* canonicalization of dirpath failed */
 			cdw_vdm ("ERROR: failed to canonicalize path \"%s\"\n", file->fullpath);
 			return CDW_ERROR;
@@ -393,24 +402,10 @@
 	}
 
 	if (rv != 0) {
-		cdw_vdm ("ERROR: failed to browse to new dirpath \"%s\"\n", new_dirpath);
-
-		if (rv == CDW_FS_CHECK_E_PERM_NO_X) {
-			cdw_vdm ("ERROR: no \"exec\" permissions\n");
-			cdw_fs_browser_internal_error_dialog(rv);
-
-		} else if (rv == CDW_FS_CHECK_E_PERM_NO_R) {
-			cdw_vdm ("ERROR: no \"read\" permissions\n");
-			cdw_fs_browser_internal_error_dialog(rv);
-
-		} else if (rv == CDW_FS_CHECK_SYS_ERROR) {
-			cdw_vdm ("ERROR: system error\n");
-			cdw_fs_browser_internal_error_dialog(rv);
+		cdw_vdm ("ERROR: failed to browse to new dirpath \"%s\": \"%s\"\n", new_dirpath, cdw_fs_check_get_debug_message(rv));
+		cdw_fs_browser_internal_error_dialog(rv);
 
-		} else {
-			cdw_vdm ("ERROR: reason unknown\n");
-			cdw_fs_browser_internal_error_dialog(CDW_ERROR);
-		}
+		/* Refresh the list after displaying dialog window. */
 		cdw_list_display_refresh(browser->display);
 	}
 	free(new_dirpath);
@@ -485,10 +480,10 @@
 				    "ERROR: index of current file is larger than number of files\n");
 #endif
 		} else if (key == '.') {
-			if (global_config.fs.display_hidden_files) {
-				global_config.fs.display_hidden_files = false;
+			if (global_config.general.display_hidden_files) {
+				global_config.general.display_hidden_files = false;
 			} else {
-				global_config.fs.display_hidden_files = true;
+				global_config.general.display_hidden_files = true;
 			}
 			char *f = cdw_fs_browser_get_current_fullpath(browser);
 			/* FIXME: check return values */
@@ -500,7 +495,7 @@
 		} else if (key == KEY_BACKSPACE) {
 			cdw_file_t *file = cdw_fs_browser_get_current_file(browser);
 			char *new_dir = cdw_fs_shorten_fullpath(file);
-			if (new_dir != (char *) NULL) {
+			if (new_dir) {
 				cdw_fs_browser_browse_to_file(browser, new_dir);
 				free(new_dir);
 				new_dir = (char *) NULL;
@@ -548,41 +543,13 @@
 
    Function displays dialog window with error message. Function created to
    avoid repetition of the same dialog in two places.
-
-   FIXME: the function accepts values of regular type int
-   and of type cdw_rv_t, but type of its argument is int.
 */
 void cdw_fs_browser_internal_error_dialog(int rv)
 {
-	char *message = (char *) NULL;
-	if (rv == CDW_ERROR) {
-		/* 2TRANS: this is message in dialog window */
-		message = _("Unexpected error, perhaps some file has been deleted. Please close this window and open it again.");
-	} else if (rv == CDW_FS_CHECK_E_PERM_NO_X) {
-		/* 2TRANS: this is message in dialog window;
-		   "change directory" means "enter into directory" */
-		message = _("Cannot change directory: wrong permissions.");
-	} else if (rv == CDW_FS_CHECK_E_PERM_NO_R) {
-		/* 2TRANS: this is message in dialog window;
-		   "read directory" means "read content of directory" */
-		message = _("Cannot read directory: wrong permissions.");
-	} else if (rv == CDW_FS_CHECK_SYS_ERROR) {
-		/* 2TRANS: this is message in dialog window:
-		   user highlighted a file and pressed enter,
-		   but the file probably does not exit */
-		message = _("File does not exists or cannot change directory.");
-	} else if (rv == CDW_NO) {
-		/* 2TRANS: this is message in dialog window. Some
-		   function returned error value. No further action
-		   will be performed, no other explanations provided */
-		message = _("Cannot display content of current directory. Please close this window and open it again.");
-	} else {
-		return;
-	}
+	const char *message = cdw_fs_check_get_message(rv);
 
 	/* 2TRANS: this is title of dialog window */
-	cdw_buttons_dialog(_("Error"), message,
-			   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	cdw_buttons_dialog(_("Error"), message,  CDW_BUTTONS_OK, CDW_COLORS_ERROR);
 
 	return;
 }
@@ -593,11 +560,11 @@
 
 cdw_file_t *cdw_fs_browser_get_current_file(cdw_fs_browser_t *browser)
 {
-	cdw_assert (browser != (cdw_fs_browser_t *) NULL, "ERROR: browser pointer is NULL\n");
+	cdw_assert (browser, "ERROR: browser pointer is NULL\n");
 
 	void *data = cdw_list_display_get_current_item_data(browser->display);
-	if (data == (void *) NULL) {
-		cdw_assert (data != (void *) NULL,
+	if (!data) {
+		cdw_assert (data,
 			    "ERROR: failed to fetch current file #%zd from fs browser->display\n",
 			    browser->display->current_item_ind);
 		return (cdw_file_t *) NULL;
@@ -616,7 +583,10 @@
 {
 	struct stat finfo;
 	if (stat(fullpath, &finfo) == -1) {
-		cdw_vdm ("ERROR: failed to stat() \"%s\"\n", fullpath);
+		/* This is not an error. It may be a perfectly normal
+		   situation that a file has existed at some point,
+		   but it no longer does. */
+		cdw_vdm ("WARNING: failed to stat() \"%s\"\n", fullpath);
 		return -1;
 	}
 
@@ -700,7 +670,7 @@
 	ssize_t f = cdw_fs_get_filename_start(fullpath);
 	cdw_assert (f >= 0, "ERROR: can't get start of file name in \"%s\"\n", fullpath);
 	char *dirpath = strndup(fullpath, (size_t) f);
-	cdw_assert (dirpath != (char *) NULL, "ERROR: failed to strndup() dirpath from \"%s\"\n", fullpath);
+	cdw_assert (dirpath, "ERROR: failed to strndup() dirpath from \"%s\"\n", fullpath);
 
 	int rv = cdw_fs_browser_browse_into_dir(browser, dirpath);
 	if (rv != 0) {
@@ -746,7 +716,7 @@
 			   this is not an error, handle this gracefully */
 			cdw_vdm ("WARNING: file \"%s\" not found in dir \"%s\"\n", fullpath + f, dirpath);
 			ssize_t start = cdw_fs_get_filename_start(fullpath);
-			if (cdw_fs_is_hidden(fullpath + start) && !global_config.fs.display_hidden_files) {
+			if (cdw_fs_is_hidden(fullpath + start) && !global_config.general.display_hidden_files) {
 				cdw_vdm ("INFO: it may be because displaying hidden files has been disabled\n");
 				cdw_list_display_scroll_to(browser->display, 0, 0, true);
 				return 0;
@@ -764,11 +734,11 @@
 char *cdw_fs_browser_get_current_dirpath(cdw_fs_browser_t *browser)
 {
 	cdw_file_t *file = cdw_fs_browser_get_current_file(browser);
-	cdw_assert (file != (cdw_file_t *) NULL, "ERROR: can't get current file\n");
+	cdw_assert (file, "ERROR: can't get current file\n");
 	ssize_t i = cdw_fs_get_filename_start(file->fullpath);
 	cdw_assert (i > 0, "ERROR: can't get file name start\n");
 	char *dirpath = strndup(file->fullpath, (size_t) i);
-	cdw_assert (dirpath != (char *) NULL, "ERROR: can't strdup dirpath\n");
+	cdw_assert (dirpath, "ERROR: can't strdup dirpath\n");
 	return dirpath;
 }
 
@@ -779,12 +749,12 @@
 char *cdw_fs_browser_get_current_printable_dirpath(cdw_fs_browser_t *browser)
 {
 	cdw_file_t *file = cdw_fs_browser_get_current_file(browser);
-	cdw_assert (file != (cdw_file_t *) NULL, "ERROR: can't get current file\n");
-	if (file->printable_fullpath != (char *) NULL) {
+	cdw_assert (file, "ERROR: can't get current file\n");
+	if (file->printable_fullpath) {
 		ssize_t i = cdw_fs_get_filename_start(file->printable_fullpath);
 		cdw_assert (i > 0, "ERROR: can't get file name start\n");
 		char *dirpath = strndup(file->printable_fullpath, (size_t) i);
-		cdw_assert (dirpath != (char *) NULL, "ERROR: can't strdup dirpath\n");
+		cdw_assert (dirpath, "ERROR: can't strdup dirpath\n");
 		return dirpath;
 	} else {
 		return cdw_fs_browser_get_current_dirpath(browser);
@@ -798,8 +768,8 @@
 char *cdw_fs_browser_get_current_fullpath(cdw_fs_browser_t *browser)
 {
 	cdw_file_t *file = cdw_fs_browser_get_current_file(browser);
-	cdw_assert (file != (cdw_file_t *) NULL, "ERROR: can't get current file\n");
-	cdw_assert (file->fullpath != (char *) NULL, "ERROR: current file has no fullpath\n");
+	cdw_assert (file, "ERROR: can't get current file\n");
+	cdw_assert (file->fullpath, "ERROR: current file has no fullpath\n");
 	/* file->fullpath is a valid pointer at this point, but if
 	   you will pass it to function that re-reads (and thus reallocates)
 	   list with current dir listing, then the pointer becomes
@@ -856,7 +826,7 @@
 					_("Help"),
 					/* 2TRANS: this is helper text at the bottom of help window */
 					_("Press any key to close"));
-	if (window == (WINDOW *) NULL) {
+	if (!window) {
 		cdw_vdm ("ERROR: failed to create new window\n");
 		return;
 	}
@@ -874,5 +844,3 @@
 
 	return;
 }
-
-
diff -Naur orig/src/native_file_system/cdw_fs.c patched/src/native_file_system/cdw_fs.c
--- orig/src/native_file_system/cdw_fs.c	2012-02-19 22:07:33.000000000 +0100
+++ patched/src/native_file_system/cdw_fs.c	2014-04-12 21:11:53.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _BSD_SOURCE /* lstat() */
@@ -893,12 +893,14 @@
 	if (access(dirpath, X_OK) == -1) {
 		/* can't change directory, no point in checking if we can
 		   read its content */
+		cdw_vdm ("ERROR: \"%s\": no X perms\n", dirpath)
 		return CDW_FS_CHECK_E_PERM_NO_X;
 	} else {
 		if (access(dirpath, R_OK) == -1) {
 			/* technically it would be possible to visit
 			   this dir, but caller won't have too much
 			   use of this path - scandir will return -1 for it */
+			cdw_vdm ("ERROR: \"%s\": no R perms\n", dirpath)
 			return CDW_FS_CHECK_E_PERM_NO_R;
 		} else {
 			/* we have execute and read prems for new dir:
@@ -1017,36 +1019,68 @@
 
    \p list won't include hidden files if \p include_hidden is false.
 
+   \p list will be sorted by type of entries: first there will be
+   directories, then there will be files.
+
    \param list - will be set to list of files in given dir
    \param dirpath - path to directory that you scan
    \param eps - list of file names in given dir
    \param n_files - number of file names on \p eps, or in given dir
    \param include_hidden - controls if hidden UNIX file should be copied from eps to list
 
-   \return number of items copied to the list on success (there should be at least one: ".")
+   \return number of items copied to the list on success (there always should be at least one: "..")
    \return 0 on errors
 */
 unsigned long long cdw_fs_copy_dirent_to_list(cdw_dll_item_t **list, const char *dirpath, struct dirent **eps, unsigned long long n_items, bool include_hidden)
 {
-	cdw_assert (*list == (cdw_dll_item_t *) NULL, "ERROR: can't use non-null list\n");
-	cdw_assert (dirpath != (char *) NULL, "ERROR: can't use null dirpath\n");
+	cdw_assert (*list == (cdw_dll_item_t *) NULL, "ERROR: can't use non-NULL list\n");
+	cdw_assert (dirpath, "ERROR: can't use NULL dirpath\n");
 	cdw_assert (n_items > 0, "ERROR: you want to create list of zero files\n");
 
-	cdw_dll_item_t *dirs = (cdw_dll_item_t *) NULL;
-	cdw_dll_item_t *files = (cdw_dll_item_t *) NULL;
+	cdw_dll_item_t *dirs = (cdw_dll_item_t *) NULL;    /* List of dirs copied from eps. */
+	cdw_dll_item_t *files = (cdw_dll_item_t *) NULL;   /* List of files copied from eps. */
 
 	unsigned long long n_dirs = 0;
 	unsigned long long n_files = 0;
 	unsigned long long n_hidden = 0;
 	bool success = true;
 
+	/* If in a given directory there is a directory whose name is
+	   composed only of underscores ('_'), it will be put by
+	   scandir at the beginning of 'eps' list, before '..'.
+
+	   To fix this in this function, I force putting the '..' dir
+	   on top of 'dirs' list before the 'for' loop, and then skip
+	   adding the '..' dir in the 'for' loop.
+
+	   This operation (forcing adding the '..' dir on top of the
+	   list and then skipping it in the loop) shouldn't cause any
+	   problems, because in every dir scanned by scandir there
+	   will be always a '..' dir, even in root directory. */
+	cdw_file_t *parent = cdw_file_new(dirpath, "..");
+	if (!parent) {
+		cdw_vdm ("ERROR: failed to create parent file %s/%s\n", dirpath, "..");
+		return 0;
+	}
+	cdw_dll_append(&dirs, (void *) parent, cdw_file_equal);
+	n_dirs++;
+
 	for (unsigned long long i = 0; i < n_items; i++) {
 		if (cdw_fs_is_hidden(eps[i]->d_name) && !include_hidden) {
 			n_hidden++;
 			continue;
 		}
+
+		/* This is the "skip adding the '..' dir in the 'for'
+		   loop" that I was talking about above. Hopefully
+		   this code is faster than call to strcmp(). */
+		if (eps[i]->d_name[0] == '.' && eps[i]->d_name[1] == '.' && eps[i]->d_name[2] == '\0') {
+			continue;
+		}
+
 		cdw_file_t *file = cdw_file_new(dirpath, eps[i]->d_name);
-		if (file == (cdw_file_t *) NULL) {
+		if (!file) {
+			cdw_vdm ("ERROR: failed to create file for %s/%s\n", dirpath, eps[i]->d_name);
 			success = false;
 			break;
 		}
@@ -1077,12 +1111,12 @@
 		}
 		return n_files + n_dirs;
 	} else {
-		if (dirs != (cdw_dll_item_t *) NULL) {
+		if (dirs) {
 			cdw_file_dealloc_files_from_list(dirs);
 			cdw_dll_clean(dirs);
 			dirs = (cdw_dll_item_t *) NULL;
 		}
-		if (files != (cdw_dll_item_t *) NULL) {
+		if (files) {
 			cdw_file_dealloc_files_from_list(files);
 			cdw_dll_clean(files);
 			dirs = (cdw_dll_item_t *) NULL;
@@ -1148,6 +1182,8 @@
 
 cdw_rv_t cdw_fs_traverse_path(char *fullpath, cdw_fs_visitor_t visitor, cdw_fs_visitor_data_t *visitor_data)
 {
+	cdw_vdm ("INFO: TRAVERSE PATH: \"%s\"\n", fullpath);
+
 	/* WARNING: don't use stat() - it yelds bad results for symlinks;
 	   at this point we don't want to follow symbolic links, we only
 	   need to know if file pointed by path is a symlink or not;
@@ -1175,21 +1211,25 @@
 	cdw_rv_t retval = CDW_NO;
 
 	if ( S_ISREG(finfo.st_mode) ) { /* regular file */
+		cdw_vdm ("INFO: regular file (%s)\n", fullpath);
 		visitor(fullpath, &finfo, visitor_data);
 		retval = CDW_OK;
 	} else if ( S_ISLNK(finfo.st_mode) ) { /* symbolic link */
+		cdw_vdm ("INFO: symbolic link (%s)\n", fullpath);
 		if (visitor_data->follow_symlinks) {
-			cdw_vdm ("INFO: following symlinks\n");
+			cdw_vdm ("INFO: following symbolic link\n");
 			retval = cdw_fs_traverse_symlink(fullpath, visitor, visitor_data);
 		} else {
-			cdw_vdm ("INFO: NOT following link\n");
+			cdw_vdm ("INFO: NOT following symbolic link\n");
 			visitor(fullpath, &finfo, visitor_data);
 			retval = CDW_OK;
 		}
 	} else if ( S_ISDIR(finfo.st_mode) ) { /* directory */
+		cdw_vdm ("INFO: directory (%s)\n", fullpath);
 		visitor(fullpath, &finfo, visitor_data);
 		retval = cdw_fs_traverse_dir(fullpath, visitor, visitor_data);
 	} else { /* other, non-appendable file type */
+		cdw_vdm ("INFO: other file (%s)\n", fullpath);
 		retval = CDW_NO;
 	}
 
@@ -1636,6 +1676,16 @@
 	if (pos == -1) {
 		return (char *) NULL;
 	} else {
+		/* This removes trailing slash from directory name.
+		   The name of a directory shall not contain an ending
+		   slash.
+
+		   'pos > 1' condition is met for all directories
+		   except for root directory. */
+		if (pos > 1 && file->fullpath[pos - 1] == '/') {
+			pos--;
+		}
+
 		char *new_fullpath = strndup(file->fullpath, (size_t) pos);
 		cdw_vdm ("INFO: original fullpath  = \"%s\"\n", file->fullpath);
 		cdw_vdm ("INFO: shortened fullpath = \"%s\"\n", new_fullpath);
@@ -1683,6 +1733,62 @@
 
 
 
+static struct {
+	int id;
+	const char *debug_message;
+	const char *message;
+} cdw_fs_check_messages[CDW_FS_CHECK_N_ITEMS] = {
+	{ CDW_FS_CHECK_OK,            "INFO: check result: OK",             gettext_noop("Check succeeded")                                      },
+	{ CDW_FS_CHECK_IS_FILE,       "INFO: check result: is FILE",        gettext_noop("This is file")                                         },
+	{ CDW_FS_CHECK_IS_DIR,        "INFO: check result: is DIR",         gettext_noop("This is directory")                                    },
+	{ CDW_FS_CHECK_EXISTS,        "INFO: check result: EXISTS",         gettext_noop("File exists")                                          },
+	{ CDW_FS_CHECK_DOESNT_EXIST,  "INFO: check result: DOESN'T EXITS",  gettext_noop("File doesn't exist")                                   },
+	{ CDW_FS_CHECK_NO_PARENT,     "INFO: check result: NO PARENT",      gettext_noop("No parent directory")                                  },
+	{ CDW_FS_CHECK_WRONG_PERM,    "ERROR: check result: WRONG PERM",    gettext_noop("Cannot perform the action: wrong permissions.")        },
+	{ CDW_FS_CHECK_E_PERM_NO_R,   "ERROR: check result: NO R perms",    gettext_noop("Cannot read no \"read\" permissions.")                 },
+	{ CDW_FS_CHECK_E_PERM_NO_W,   "ERROR: check result: NO W perms",    gettext_noop("Cannot write: no \"write\" permissions.")              },
+	{ CDW_FS_CHECK_E_PERM_NO_X,   "ERROR: check result: NO X perms",    gettext_noop("Cannot change directory: no \"execute\" permissions.") },
+	{ CDW_FS_CHECK_SYS_ERROR,     "ERROR: check result: system error",  gettext_noop("File does not exists or cannot change directory.")     },
+	/* This item should always come as the last one. It will be used as fallback message. */
+	{ CDW_FS_CHECK_GEN_ERROR,     "ERROR: check result: general error", gettext_noop("Unexpected error, perhaps some file has been deleted. Please close this window and open it again.") }
+};
+
+
+
+
+
+const char *cdw_fs_check_get_message(int id)
+{
+	for (int i = 0; i < CDW_FS_CHECK_N_ITEMS; i++) {
+		if (cdw_fs_check_messages[i].id == id) {
+			return cdw_fs_check_messages[i].message;
+		}
+	}
+
+	cdw_vdm ("ERROR: id %d not found in the table\n", id);
+	return cdw_fs_check_messages[CDW_FS_CHECK_N_ITEMS - 1].message;
+}
+
+
+
+
+
+const char *cdw_fs_check_get_debug_message(int id)
+{
+	for (int i = 0; i < CDW_FS_CHECK_N_ITEMS; i++) {
+		if (cdw_fs_check_messages[i].id == id) {
+			return cdw_fs_check_messages[i].debug_message;
+		}
+	}
+
+	cdw_vdm ("ERROR: id %d not found in the table\n", id);
+	return cdw_fs_check_messages[CDW_FS_CHECK_N_ITEMS - 1].debug_message;
+}
+
+
+
+
+
 // #define CDW_UNIT_TEST_CODE /* definition used during development of unit tests code */
 #ifdef CDW_UNIT_TEST_CODE
 
@@ -1906,4 +2012,3 @@
 
 
 #endif /* CDW_UNIT_TEST_CODE */
-
diff -Naur orig/src/native_file_system/cdw_fs.h patched/src/native_file_system/cdw_fs.h
--- orig/src/native_file_system/cdw_fs.h	2011-02-27 11:44:24.000000000 +0100
+++ patched/src/native_file_system/cdw_fs.h	2014-04-06 23:08:00.000000000 +0200
@@ -21,6 +21,8 @@
 } cdw_fs_visitor_data_t;
 
 
+#define CDW_FS_CHECK_N_ITEMS   12
+
 enum {
 	CDW_FS_CHECK_OK           = 0x00000001,
 
@@ -36,7 +38,9 @@
 	CDW_FS_CHECK_E_PERM_NO_W  = 0x00000100,
 	CDW_FS_CHECK_E_PERM_NO_X  = 0x00000200,
 
-	CDW_FS_CHECK_SYS_ERROR    = 0x00000400
+	CDW_FS_CHECK_SYS_ERROR    = 0x00000400,
+
+	CDW_FS_CHECK_GEN_ERROR    = 0x00000800
 };
 
 
@@ -76,6 +80,9 @@
 
 cdw_rv_t cdw_fs_errno_handler(int e);
 
+const char *cdw_fs_check_get_message(int id);
+const char *cdw_fs_check_get_debug_message(int id);
+
 /* for unit tests */
 void cdw_fs_run_tests(void);
 
diff -Naur orig/src/native_file_system/Makefile.in patched/src/native_file_system/Makefile.in
--- orig/src/native_file_system/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/native_file_system/Makefile.in	2014-01-19 20:51:29.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,20 +76,24 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/native_file_system
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwnativefilesystem_a_AR = $(AR) $(ARFLAGS)
 libcdwnativefilesystem_a_LIBADD =
 am__objects_1 = cdw_file.$(OBJEXT) cdw_file_manager.$(OBJEXT) \
@@ -64,24 +112,71 @@
 am_libcdwnativefilesystem_check_a_OBJECTS = $(am__objects_2)
 libcdwnativefilesystem_check_a_OBJECTS =  \
 	$(am_libcdwnativefilesystem_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwnativefilesystem_a_SOURCES) \
 	$(libcdwnativefilesystem_check_a_SOURCES)
 DIST_SOURCES = $(libcdwnativefilesystem_a_SOURCES) \
 	$(libcdwnativefilesystem_check_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -294,14 +389,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwnativefilesystem.a: $(libcdwnativefilesystem_a_OBJECTS) $(libcdwnativefilesystem_a_DEPENDENCIES) $(EXTRA_libcdwnativefilesystem_a_DEPENDENCIES) 
-	-rm -f libcdwnativefilesystem.a
-	$(libcdwnativefilesystem_a_AR) libcdwnativefilesystem.a $(libcdwnativefilesystem_a_OBJECTS) $(libcdwnativefilesystem_a_LIBADD)
-	$(RANLIB) libcdwnativefilesystem.a
+	$(AM_V_at)-rm -f libcdwnativefilesystem.a
+	$(AM_V_AR)$(libcdwnativefilesystem_a_AR) libcdwnativefilesystem.a $(libcdwnativefilesystem_a_OBJECTS) $(libcdwnativefilesystem_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwnativefilesystem.a
+
 libcdwnativefilesystem_check.a: $(libcdwnativefilesystem_check_a_OBJECTS) $(libcdwnativefilesystem_check_a_DEPENDENCIES) $(EXTRA_libcdwnativefilesystem_check_a_DEPENDENCIES) 
-	-rm -f libcdwnativefilesystem_check.a
-	$(libcdwnativefilesystem_check_a_AR) libcdwnativefilesystem_check.a $(libcdwnativefilesystem_check_a_OBJECTS) $(libcdwnativefilesystem_check_a_LIBADD)
-	$(RANLIB) libcdwnativefilesystem_check.a
+	$(AM_V_at)-rm -f libcdwnativefilesystem_check.a
+	$(AM_V_AR)$(libcdwnativefilesystem_check_a_AR) libcdwnativefilesystem_check.a $(libcdwnativefilesystem_check_a_OBJECTS) $(libcdwnativefilesystem_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwnativefilesystem_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -321,109 +418,98 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwnativefilesystem_check_a-cdw_file.o: cdw_file.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file.o `test -f 'cdw_file.c' || echo '$(srcdir)/'`cdw_file.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_file.c' object='libcdwnativefilesystem_check_a-cdw_file.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file.o `test -f 'cdw_file.c' || echo '$(srcdir)/'`cdw_file.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_file.c' object='libcdwnativefilesystem_check_a-cdw_file.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file.o `test -f 'cdw_file.c' || echo '$(srcdir)/'`cdw_file.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file.o `test -f 'cdw_file.c' || echo '$(srcdir)/'`cdw_file.c
 
 libcdwnativefilesystem_check_a-cdw_file.obj: cdw_file.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file.obj `if test -f 'cdw_file.c'; then $(CYGPATH_W) 'cdw_file.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_file.c' object='libcdwnativefilesystem_check_a-cdw_file.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file.obj `if test -f 'cdw_file.c'; then $(CYGPATH_W) 'cdw_file.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_file.c' object='libcdwnativefilesystem_check_a-cdw_file.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file.obj `if test -f 'cdw_file.c'; then $(CYGPATH_W) 'cdw_file.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file.obj `if test -f 'cdw_file.c'; then $(CYGPATH_W) 'cdw_file.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file.c'; fi`
 
 libcdwnativefilesystem_check_a-cdw_file_manager.o: cdw_file_manager.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file_manager.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file_manager.o `test -f 'cdw_file_manager.c' || echo '$(srcdir)/'`cdw_file_manager.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_file_manager.c' object='libcdwnativefilesystem_check_a-cdw_file_manager.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file_manager.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file_manager.o `test -f 'cdw_file_manager.c' || echo '$(srcdir)/'`cdw_file_manager.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_file_manager.c' object='libcdwnativefilesystem_check_a-cdw_file_manager.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file_manager.o `test -f 'cdw_file_manager.c' || echo '$(srcdir)/'`cdw_file_manager.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file_manager.o `test -f 'cdw_file_manager.c' || echo '$(srcdir)/'`cdw_file_manager.c
 
 libcdwnativefilesystem_check_a-cdw_file_manager.obj: cdw_file_manager.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file_manager.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file_manager.obj `if test -f 'cdw_file_manager.c'; then $(CYGPATH_W) 'cdw_file_manager.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file_manager.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_file_manager.c' object='libcdwnativefilesystem_check_a-cdw_file_manager.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file_manager.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file_manager.obj `if test -f 'cdw_file_manager.c'; then $(CYGPATH_W) 'cdw_file_manager.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file_manager.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_manager.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_file_manager.c' object='libcdwnativefilesystem_check_a-cdw_file_manager.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file_manager.obj `if test -f 'cdw_file_manager.c'; then $(CYGPATH_W) 'cdw_file_manager.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file_manager.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file_manager.obj `if test -f 'cdw_file_manager.c'; then $(CYGPATH_W) 'cdw_file_manager.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file_manager.c'; fi`
 
 libcdwnativefilesystem_check_a-cdw_file_picker.o: cdw_file_picker.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file_picker.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file_picker.o `test -f 'cdw_file_picker.c' || echo '$(srcdir)/'`cdw_file_picker.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_file_picker.c' object='libcdwnativefilesystem_check_a-cdw_file_picker.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file_picker.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file_picker.o `test -f 'cdw_file_picker.c' || echo '$(srcdir)/'`cdw_file_picker.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_file_picker.c' object='libcdwnativefilesystem_check_a-cdw_file_picker.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file_picker.o `test -f 'cdw_file_picker.c' || echo '$(srcdir)/'`cdw_file_picker.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file_picker.o `test -f 'cdw_file_picker.c' || echo '$(srcdir)/'`cdw_file_picker.c
 
 libcdwnativefilesystem_check_a-cdw_file_picker.obj: cdw_file_picker.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file_picker.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file_picker.obj `if test -f 'cdw_file_picker.c'; then $(CYGPATH_W) 'cdw_file_picker.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file_picker.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_file_picker.c' object='libcdwnativefilesystem_check_a-cdw_file_picker.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_file_picker.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Tpo -c -o libcdwnativefilesystem_check_a-cdw_file_picker.obj `if test -f 'cdw_file_picker.c'; then $(CYGPATH_W) 'cdw_file_picker.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file_picker.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_file_picker.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_file_picker.c' object='libcdwnativefilesystem_check_a-cdw_file_picker.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file_picker.obj `if test -f 'cdw_file_picker.c'; then $(CYGPATH_W) 'cdw_file_picker.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file_picker.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_file_picker.obj `if test -f 'cdw_file_picker.c'; then $(CYGPATH_W) 'cdw_file_picker.c'; else $(CYGPATH_W) '$(srcdir)/cdw_file_picker.c'; fi`
 
 libcdwnativefilesystem_check_a-cdw_fs_browser.o: cdw_fs_browser.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_fs_browser.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Tpo -c -o libcdwnativefilesystem_check_a-cdw_fs_browser.o `test -f 'cdw_fs_browser.c' || echo '$(srcdir)/'`cdw_fs_browser.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_fs_browser.c' object='libcdwnativefilesystem_check_a-cdw_fs_browser.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_fs_browser.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Tpo -c -o libcdwnativefilesystem_check_a-cdw_fs_browser.o `test -f 'cdw_fs_browser.c' || echo '$(srcdir)/'`cdw_fs_browser.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_fs_browser.c' object='libcdwnativefilesystem_check_a-cdw_fs_browser.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_fs_browser.o `test -f 'cdw_fs_browser.c' || echo '$(srcdir)/'`cdw_fs_browser.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_fs_browser.o `test -f 'cdw_fs_browser.c' || echo '$(srcdir)/'`cdw_fs_browser.c
 
 libcdwnativefilesystem_check_a-cdw_fs_browser.obj: cdw_fs_browser.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_fs_browser.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Tpo -c -o libcdwnativefilesystem_check_a-cdw_fs_browser.obj `if test -f 'cdw_fs_browser.c'; then $(CYGPATH_W) 'cdw_fs_browser.c'; else $(CYGPATH_W) '$(srcdir)/cdw_fs_browser.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_fs_browser.c' object='libcdwnativefilesystem_check_a-cdw_fs_browser.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_fs_browser.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Tpo -c -o libcdwnativefilesystem_check_a-cdw_fs_browser.obj `if test -f 'cdw_fs_browser.c'; then $(CYGPATH_W) 'cdw_fs_browser.c'; else $(CYGPATH_W) '$(srcdir)/cdw_fs_browser.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs_browser.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_fs_browser.c' object='libcdwnativefilesystem_check_a-cdw_fs_browser.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_fs_browser.obj `if test -f 'cdw_fs_browser.c'; then $(CYGPATH_W) 'cdw_fs_browser.c'; else $(CYGPATH_W) '$(srcdir)/cdw_fs_browser.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_fs_browser.obj `if test -f 'cdw_fs_browser.c'; then $(CYGPATH_W) 'cdw_fs_browser.c'; else $(CYGPATH_W) '$(srcdir)/cdw_fs_browser.c'; fi`
 
 libcdwnativefilesystem_check_a-cdw_fs.o: cdw_fs.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_fs.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Tpo -c -o libcdwnativefilesystem_check_a-cdw_fs.o `test -f 'cdw_fs.c' || echo '$(srcdir)/'`cdw_fs.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_fs.c' object='libcdwnativefilesystem_check_a-cdw_fs.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_fs.o -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Tpo -c -o libcdwnativefilesystem_check_a-cdw_fs.o `test -f 'cdw_fs.c' || echo '$(srcdir)/'`cdw_fs.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_fs.c' object='libcdwnativefilesystem_check_a-cdw_fs.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_fs.o `test -f 'cdw_fs.c' || echo '$(srcdir)/'`cdw_fs.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_fs.o `test -f 'cdw_fs.c' || echo '$(srcdir)/'`cdw_fs.c
 
 libcdwnativefilesystem_check_a-cdw_fs.obj: cdw_fs.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_fs.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Tpo -c -o libcdwnativefilesystem_check_a-cdw_fs.obj `if test -f 'cdw_fs.c'; then $(CYGPATH_W) 'cdw_fs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_fs.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_fs.c' object='libcdwnativefilesystem_check_a-cdw_fs.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_fs.obj `if test -f 'cdw_fs.c'; then $(CYGPATH_W) 'cdw_fs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_fs.c'; fi`
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwnativefilesystem_check_a-cdw_fs.obj -MD -MP -MF $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Tpo -c -o libcdwnativefilesystem_check_a-cdw_fs.obj `if test -f 'cdw_fs.c'; then $(CYGPATH_W) 'cdw_fs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_fs.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Tpo $(DEPDIR)/libcdwnativefilesystem_check_a-cdw_fs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_fs.c' object='libcdwnativefilesystem_check_a-cdw_fs.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwnativefilesystem_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwnativefilesystem_check_a-cdw_fs.obj `if test -f 'cdw_fs.c'; then $(CYGPATH_W) 'cdw_fs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_fs.c'; fi`
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -435,15 +521,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -452,6 +534,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -593,18 +690,19 @@
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean \
-	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES ctags \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # used by flymake
diff -Naur orig/src/optical_file_systems/cdw_graftpoints.c patched/src/optical_file_systems/cdw_graftpoints.c
--- orig/src/optical_file_systems/cdw_graftpoints.c	2012-02-26 15:20:02.000000000 +0100
+++ patched/src/optical_file_systems/cdw_graftpoints.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -406,6 +406,3 @@
 
 	return;
 }
-
-
-
diff -Naur orig/src/optical_file_systems/cdw_iso9660.c patched/src/optical_file_systems/cdw_iso9660.c
--- orig/src/optical_file_systems/cdw_iso9660.c	2012-02-19 22:27:26.000000000 +0100
+++ patched/src/optical_file_systems/cdw_iso9660.c	2014-04-12 20:13:58.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _BSD_SOURCE /* lstat() */
@@ -22,6 +22,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <string.h>
+#include <stdlib.h>
 /* open() */
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -35,6 +36,7 @@
 #include "cdw_debug.h"
 #include "cdw_widgets.h"
 #include "gettext.h"
+#include "cdw_string.h"
 
 extern cdw_config_t global_config;      /* variable holding cdw configuration */
 
@@ -47,8 +49,8 @@
 */
 long long cdw_iso_image_get_n_sectors(void)
 {
-	cdw_vdm ("INFO: inspecting file \"%s\"\n", global_config.iso_image_full_path);
-	int f = open(global_config.iso_image_full_path, O_RDONLY);
+	cdw_vdm ("INFO: inspecting file \"%s\"\n", global_config.general.image_fullpath);
+	int f = open(global_config.general.image_fullpath, O_RDONLY);
 	if (f == -1) {
 		cdw_fs_errno_handler(errno);
 		cdw_vdm ("ERROR: failed to open iso file image\n");
@@ -57,7 +59,7 @@
 	long long iso_size = isosize(f);
 	close(f);
 
-	long long fs_size = cdw_fs_get_file_size(global_config.iso_image_full_path);
+	long long fs_size = cdw_fs_get_file_size(global_config.general.image_fullpath);
 	cdw_vdm ("INFO: iso_size = %lld, fs_size = %lld\n", iso_size, fs_size);
 
 	if (iso_size % 2048) {
@@ -116,3 +118,182 @@
 
 
 
+
+
+void cdw_iso9660_debug_print_options(cdw_iso9660_t *iso)
+{
+	cdw_vdm ("INFO: ISO9660 options:\n");
+	cdw_vdm ("INFO:        joliet information = %s\n",     iso->joliet_information ? "true" : "false");
+	cdw_vdm ("INFO:               joliet long = %s\n",     iso->joliet_long ? "true" : "false");
+	cdw_vdm ("INFO:                rock ridge = %lld\n",   iso->rock_ridge);
+	cdw_vdm ("INFO:           follow symlinks = %s\n",     iso->follow_symlinks ? "true" : "false");
+	cdw_vdm ("INFO:                       pad = %s\n",     iso->pad ? "true" : "false");
+	cdw_vdm ("INFO:                 iso level = %lld\n",   iso->iso_level);
+
+	cdw_vdm ("INFO:                  root dir = \"%s\"\n", iso->root_dir);
+
+	cdw_vdm ("INFO:     other mkisofs options = \"%s\"\n", iso->mkisofs_other_options);
+	cdw_vdm ("INFO: other xorriso ISO options = \"%s\"\n", iso->xorriso_iso_other_options);
+
+	cdw_vdm ("INFO:         boot disc options = \"%s\"\n", iso->boot_disc_options);
+
+	cdw_vdm ("INFO:                 volume ID = \"%s\"\n", iso->volume_id);
+	cdw_vdm ("INFO:             volume set ID = \"%s\"\n", iso->volume_set_id);
+	cdw_vdm ("INFO:                  preparer = \"%s\"\n", iso->preparer);
+	cdw_vdm ("INFO:                 publisher = \"%s\"\n", iso->publisher);
+	cdw_vdm ("INFO:                 system id = \"%s\"\n", iso->system_id);
+	cdw_vdm ("INFO:                 copyright = \"%s\"\n", iso->copyright);
+	cdw_vdm ("INFO:                  abstract = \"%s\"\n", iso->abstract);
+
+	return;
+}
+
+
+
+
+
+cdw_rv_t cdw_iso9660_copy(cdw_iso9660_t *target, cdw_iso9660_t *source)
+{
+	target->joliet_information  = source->joliet_information;
+	target->joliet_long         = source->joliet_long;
+	target->rock_ridge          = source->rock_ridge;
+	target->follow_symlinks     = source->follow_symlinks;
+	target->pad                 = source->pad;
+	target->iso_level           = source->iso_level;
+
+	int crv = cdw_string_set(&(target->root_dir), source->root_dir);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set root_dir with \"%s\"\n", source->root_dir);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(target->mkisofs_other_options), source->mkisofs_other_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set mkisofs_other_options with \"%s\"\n", source->mkisofs_other_options);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(target->xorriso_iso_other_options), source->xorriso_iso_other_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set xorriso_iso_other_options with \"%s\"\n", source->xorriso_iso_other_options);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(target->boot_disc_options), source->boot_disc_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set boot_disc_options with \"%s\"\n", source->boot_disc_options);
+		return CDW_ERROR;
+	}
+
+	strncpy(target->volume_id, source->volume_id, CDW_ISO9660_VOLI_LEN);
+	        target->volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
+
+	strncpy(target->volume_set_id, source->volume_set_id, CDW_ISO9660_VOLS_LEN);
+	        target->volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
+
+	strncpy(target->preparer, source->preparer, CDW_ISO9660_PREP_LEN);
+	        target->preparer[CDW_ISO9660_PREP_LEN] = '\0';
+
+	strncpy(target->publisher, source->publisher, CDW_ISO9660_PUBL_LEN);
+	        target->publisher[CDW_ISO9660_PUBL_LEN] = '\0';
+
+	strncpy(target->system_id, source->system_id, CDW_ISO9660_SYSI_LEN);
+	        target->system_id[CDW_ISO9660_SYSI_LEN] = '\0';
+
+	strncpy(target->copyright, source->copyright, CDW_ISO9660_COPY_LEN);
+	        target->copyright[CDW_ISO9660_COPY_LEN] = '\0';
+
+	strncpy(target->abstract, source->abstract, CDW_ISO9660_ABST_LEN);
+	        target->abstract[CDW_ISO9660_ABST_LEN] = '\0';
+
+	return CDW_OK;
+}
+
+
+
+
+
+/*
+  Initialize pointers from \p iso with NULL, so that \p iso can be
+  later safely passed to cdw_iso9660_set_defaults().
+*/
+cdw_rv_t cdw_iso9660_init(cdw_iso9660_t *iso)
+{
+	iso->root_dir = (char *) NULL;
+	iso->mkisofs_other_options = (char *) NULL;
+	iso->xorriso_iso_other_options = (char *) NULL;
+	iso->boot_disc_options = (char *) NULL;
+
+	return CDW_OK;
+}
+
+
+
+
+
+/*
+  Set default values for all fields in \p iso.
+  You have to initialize \p iso with cw_iso9660_init() before calling this function.
+*/
+cdw_rv_t cdw_iso9660_set_defaults(cdw_iso9660_t *iso)
+{
+	iso->joliet_information = true;
+	iso->joliet_long = false;         /* "Joliet long" breaks a standard, use with care. */
+	iso->rock_ridge = CDW_ISO9660_RR_FULL;
+	iso->follow_symlinks = false;
+	iso->pad = true;
+	iso->iso_level = 3;
+
+	cdw_rv_t crv = cdw_string_set(&(iso->root_dir), "");
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set root_dir with empty string\n");
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(iso->mkisofs_other_options), "");
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set mkisofs_other_options with empty string\n");
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(iso->xorriso_iso_other_options), "");
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set xorriso_iso_other_options with empty string\n");
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(iso->boot_disc_options), "");
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set boot_disc_options with empty string\n");
+		return CDW_ERROR;
+	}
+
+	/* 2TRANS: this is a default label for ISO9660 volume */
+	strncpy(iso->volume_id, _("my volume"), CDW_ISO9660_VOLI_LEN);
+	        iso->volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
+	iso->volume_set_id[0] = '\0';
+	iso->preparer[0]      = '\0';
+	iso->publisher[0]     = '\0';
+	iso->system_id[0]     = '\0';
+	iso->copyright[0]     = '\0';
+	iso->abstract[0]      = '\0';
+
+	return CDW_OK;
+}
+
+
+
+
+
+/*
+  Deallocate all pointers from \p iso, but not the \p iso itself.
+*/
+cdw_rv_t cdw_iso9660_clean(cdw_iso9660_t *iso)
+{
+	cdw_string_delete(&iso->root_dir);
+	cdw_string_delete(&iso->mkisofs_other_options);
+	cdw_string_delete(&iso->xorriso_iso_other_options);
+	cdw_string_delete(&iso->boot_disc_options);
+
+	return CDW_OK;
+}
diff -Naur orig/src/optical_file_systems/cdw_iso9660.h patched/src/optical_file_systems/cdw_iso9660.h
--- orig/src/optical_file_systems/cdw_iso9660.h	2012-02-19 22:26:54.000000000 +0100
+++ patched/src/optical_file_systems/cdw_iso9660.h	2014-04-12 20:15:10.000000000 +0200
@@ -2,6 +2,8 @@
 #define H_CDW_ISO9660
 
 
+#include "main.h"
+
 
 long long cdw_iso_image_get_n_sectors(void);
 double cdw_iso_image_get_size_mb(const char *fullpath);
@@ -21,8 +23,56 @@
 #define CDW_ISO9660_PREP_LEN  128
 #define CDW_ISO9660_SYSI_LEN   32
 #define CDW_ISO9660_VOLS_LEN  128
-#define CDW_ISO9660_VOLI_LEN   32
+#define CDW_ISO9660_VOLI_LEN   32    /* "Volume ID" */
 
 
-#endif /* #ifndef H_CDW_ISO9660 */
+typedef struct {
+	/* Turn on creting Joliet filenames. */
+	bool joliet_information;                       /* mkisofs: -J;               xorriso: -joliet on|off */
+
+	/* "Allow  Joliet  filenames  to  be  up to 103 Unicode characters, instead of 64." */
+	bool joliet_long;                              /* mkisofs: -joliet-long;     xorriso: N/A */
+
+	/* none/useful/full
+	   mkisofs: -r for "useful", -R for "full"
+	   xorriso: full is always on, "none is not allowed", and for "useful": "-find / -true -exec mkisofs_r --" */
+	cdw_id_t rock_ridge;
+
+	/* Follow symbolic links when generating ISO9660 filesystem. */
+	bool follow_symlinks;                          /* mkisofs: -f;               xorriso: -follow link */
+
+	bool pad;                                      /* mkisofs: -pad (hardwired value 300k);    xorriso: -padding Xk|m */
+
+	/* Level of conformance with ISO9660; valid values are 1 to 4. */
+	cdw_id_t iso_level;                            /* mkisofs: -iso-level;       xorriso: N/A */
+
+	char *root_dir;                                /* mkisofs: -root;            xorriso: N/A */
 
+	/* Place for other mkisofs options, specified manually. */
+	char *mkisofs_other_options;
+
+	/* Place for other xorriso ISO9660 options, specified manually. */
+	char *xorriso_iso_other_options;
+
+	/* Options for creating a bootable ISO9660 disc. */
+	char *boot_disc_options;
+
+	/* +1 for ending '\0' */
+	/* Label of disc visible in file managers. */
+	char volume_id[CDW_ISO9660_VOLI_LEN + 1];      /* mkisofs: -V;               xorriso: -volid     */
+	char volume_set_id[CDW_ISO9660_VOLS_LEN + 1];  /* mkisofs: -volset           xorriso: -volset_id */
+	char preparer[CDW_ISO9660_PREP_LEN + 1];       /* mkisofs: -p                xorriso: N/A        */
+	char publisher[CDW_ISO9660_PUBL_LEN + 1];      /* mkisofs: -publisher        xorriso: -publisher */
+	char system_id[CDW_ISO9660_SYSI_LEN + 1];      /* mkisofs: -sysid            xorriso: -system_id */
+	char copyright[CDW_ISO9660_COPY_LEN + 1];      /* mkisofs: -copyright        xorriso: N/A        */
+	char abstract[CDW_ISO9660_ABST_LEN + 1];       /* mkisofs: -abstract         xorriso: N/A        */
+} cdw_iso9660_t;
+
+
+void     cdw_iso9660_debug_print_options(cdw_iso9660_t *iso);
+cdw_rv_t cdw_iso9660_init(cdw_iso9660_t *iso);
+cdw_rv_t cdw_iso9660_set_defaults(cdw_iso9660_t *iso);
+cdw_rv_t cdw_iso9660_copy(cdw_iso9660_t *target, cdw_iso9660_t *source);
+cdw_rv_t cdw_iso9660_clean(cdw_iso9660_t *iso);
+
+#endif /* #ifndef H_CDW_ISO9660 */
diff -Naur orig/src/optical_file_systems/cdw_ofs.c patched/src/optical_file_systems/cdw_ofs.c
--- orig/src/optical_file_systems/cdw_ofs.c	2012-03-30 19:04:08.000000000 +0200
+++ patched/src/optical_file_systems/cdw_ofs.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
diff -Naur orig/src/optical_file_systems/cdw_ofs.h patched/src/optical_file_systems/cdw_ofs.h
--- orig/src/optical_file_systems/cdw_ofs.h	2012-03-30 19:03:09.000000000 +0200
+++ patched/src/optical_file_systems/cdw_ofs.h	2014-01-19 20:49:59.000000000 +0100
@@ -7,6 +7,7 @@
 #include <cdio/cd_types.h>
 #include <cdio/iso9660.h>
 
+#include "config_cdw_undefine.h"
 #include "main.h"
 
 #define CDW_OFS_VOLUME_ID_LEN_MAX ISO_MAX_VOLUME_ID
diff -Naur orig/src/optical_file_systems/cdw_udf.c patched/src/optical_file_systems/cdw_udf.c
--- orig/src/optical_file_systems/cdw_udf.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/optical_file_systems/cdw_udf.c	2014-04-12 20:14:34.000000000 +0200
@@ -0,0 +1,192 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "cdw_string.h"
+#include "gettext.h"
+#include "cdw_debug.h"
+#include "cdw_utils.h"
+#include "cdw_udf.h"
+#include "cdw_mkudffs_options.h"
+
+
+
+
+
+extern const char *cdw_mkudffs_option_blocksize[];
+extern const char *cdw_mkudffs_option_udfrev[];
+extern const char *cdw_mkudffs_option_strategy[];
+extern const char *cdw_mkudffs_option_spartable[];
+extern const char *cdw_mkudffs_option_media_type[];
+extern const char *cdw_mkudffs_option_space[];
+extern const char *cdw_mkudffs_option_ad[];
+extern const char *cdw_mkudffs_option_encoding[];
+
+
+
+
+void cdw_udf_debug_print_options(cdw_udf_t *udf)
+{
+	cdw_vdm ("INFO: UDF options:\n");
+
+	cdw_vdm ("INFO: UDF option: volume size        = %"PRIu64" bytes\n", udf->volume_size_bytes);
+
+	cdw_vdm ("INFO: UDF option: mkudffs blocksize  = %s\n", cdw_mkudffs_option_blocksize[udf->mkudffs_blocksize]);
+	cdw_vdm ("INFO: UDF option: mkudffs udfrev     = %s\n", cdw_mkudffs_option_udfrev[udf->mkudffs_udfrev]);
+	cdw_vdm ("INFO: UDF option: mkudffs strategy   = %s\n", cdw_mkudffs_option_strategy[udf->mkudffs_strategy]);
+	cdw_vdm ("INFO: UDF option: mkudffs spartable  = %s\n", cdw_mkudffs_option_spartable[udf->mkudffs_spartable]);
+	cdw_vdm ("INFO: UDF option: mkudffs media type = %s\n", cdw_mkudffs_option_media_type[udf->mkudffs_media_type]);
+	cdw_vdm ("INFO: UDF option: mkudffs space      = %s\n", cdw_mkudffs_option_space[udf->mkudffs_space]);
+	cdw_vdm ("INFO: UDF option: mkudffs ad         = %s\n", cdw_mkudffs_option_ad[udf->mkudffs_ad]);
+	cdw_vdm ("INFO: UDF option: mkudffs noefe      = %s\n", udf->mkudffs_noefe ? "true" : "false");
+	cdw_vdm ("INFO: UDF option: mkudffs encoding   = %s\n", cdw_mkudffs_option_encoding[udf->mkudffs_encoding]);
+
+	cdw_vdm ("INFO: UDF option: mkudffs other options = %s\n", udf->mkudffs_other_options);
+
+	cdw_vdm ("INFO: UDF option: mkudffs lvid  = %s\n", udf->mkudffs_lvid);
+	cdw_vdm ("INFO: UDF option: mkudffs vid   = %s\n", udf->mkudffs_vid);
+	cdw_vdm ("INFO: UDF option: mkudffs vsid  = %s\n", udf->mkudffs_vsid);
+	cdw_vdm ("INFO: UDF option: mkudffs fsid  = %s\n", udf->mkudffs_fsid);
+
+	cdw_vdm ("INFO: UDF option: rsync options = %s\n", udf->rsync_options);
+	cdw_vdm ("INFO: UDF option: mount point   = %s\n", udf->mount_point);
+
+	return;
+}
+
+
+
+
+
+cdw_rv_t cdw_udf_copy(cdw_udf_t *target, cdw_udf_t *source)
+{
+	target->volume_size_bytes  = source->volume_size_bytes;
+
+	target->mkudffs_blocksize  = source->mkudffs_blocksize;
+	target->mkudffs_udfrev     = source->mkudffs_udfrev;
+	target->mkudffs_strategy   = source->mkudffs_strategy;
+	target->mkudffs_spartable  = source->mkudffs_spartable;
+	target->mkudffs_media_type = source->mkudffs_media_type;
+	target->mkudffs_space      = source->mkudffs_space;
+	target->mkudffs_ad         = source->mkudffs_ad;
+	target->mkudffs_noefe      = source->mkudffs_noefe;
+	target->mkudffs_encoding   = source->mkudffs_encoding;
+
+	strncpy(target->mkudffs_other_options, source->mkudffs_other_options, CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX);
+	        target->mkudffs_other_options[CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX] = '\0';
+
+	strncpy(target->mkudffs_lvid, source->mkudffs_lvid, CDW_UDF_LVID_LEN_MAX);
+	        target->mkudffs_lvid[CDW_UDF_LVID_LEN_MAX] = '\0';
+	strncpy(target->mkudffs_vid,  source->mkudffs_vid,  CDW_UDF_VID_LEN_MAX);
+	        target->mkudffs_vid[CDW_UDF_VID_LEN_MAX] = '\0';
+	strncpy(target->mkudffs_vsid, source->mkudffs_vsid, CDW_UDF_VSID_LEN_MAX);
+	        target->mkudffs_vsid[CDW_UDF_VSID_LEN_MAX] = '\0';
+	strncpy(target->mkudffs_fsid, source->mkudffs_fsid, CDW_UDF_FSID_LEN_MAX);
+	        target->mkudffs_fsid[CDW_UDF_FSID_LEN_MAX] = '\0';
+
+	strncpy(target->rsync_options, source->rsync_options, CDW_RSYNC_OPTIONS_LEN_MAX);
+	        target->rsync_options[CDW_RSYNC_OPTIONS_LEN_MAX] = '\0';
+
+	cdw_string_set(&(target->mount_point), source->mount_point);
+
+	return CDW_OK;
+}
+
+
+
+
+
+/*
+  Initialize pointers from \p udf with NULL, so that \p udf can be
+  later safely passed to cdw_udf_set_defaults().
+*/
+cdw_rv_t cdw_udf_init(cdw_udf_t *udf)
+{
+	udf->mount_point = (char *) NULL;
+
+	return CDW_OK;
+}
+
+
+
+
+
+/*
+  Set default values for all fields in \p udf.
+  You have to initialize \p udf with cw_udf_init() before calling this function.
+*/
+cdw_rv_t cdw_udf_set_defaults(cdw_udf_t *udf)
+{
+	udf->volume_size_bytes  = 0;
+
+	udf->mkudffs_blocksize  = CDW_MKUDFFS_BLOCKSIZE_UNSPECIFIED;
+	udf->mkudffs_udfrev     = CDW_MKUDFFS_UDFREV_UNSPECIFIED;
+	udf->mkudffs_strategy   = CDW_MKUDFFS_STRATEGY_UNSPECIFIED;
+	udf->mkudffs_spartable  = CDW_MKUDFFS_SPARTABLE_UNSPECIFIED;
+	udf->mkudffs_media_type = CDW_MKUDFFS_MEDIA_TYPE_UNSPECIFIED;
+	udf->mkudffs_space      = CDW_MKUDFFS_SPACE_UNSPECIFIED;
+	udf->mkudffs_ad         = CDW_MKUDFFS_AD_UNSPECIFIED;
+	udf->mkudffs_noefe      = false;  /* The default situation is that the command line flag is not passed to mkudffs. */
+	udf->mkudffs_encoding   = CDW_MKUDFFS_ENCODING_UNSPECIFIED;
+
+	udf->mkudffs_other_options[0] = '\0';
+
+	udf->mkudffs_lvid[0] = '\0';
+	udf->mkudffs_vid[0]  = '\0';
+	udf->mkudffs_vsid[0] = '\0';
+	udf->mkudffs_fsid[0] = '\0';
+
+	udf->rsync_options[0] = '\0';
+
+	/* This is a path that sooner or later will be passed to file
+	   picker. The file picker won't accept NULL pointer as
+	   initial argument. If the field won't be set to non-NULL
+	   value by any other code, the picker would flop. To prevent
+	   this, call strdup() here.
+
+	   The string is empty because I can't make any assumptions
+	   about where user would like to mount the UDF image. Once
+	   the user sets value of mount point, it will be stored in
+	   config file. After this first-time configuration by user,
+	   the value will be re-used. But initial value must be empty
+	   string. */
+	udf->mount_point = strdup("");
+
+	return CDW_OK;
+}
+
+
+
+
+
+/*
+  Deallocate all pointers from \p udf, but not the \p udf itself.
+*/
+cdw_rv_t cdw_udf_clean(cdw_udf_t *udf)
+{
+	if (udf->mount_point) {
+		free(udf->mount_point);
+		udf->mount_point = (char *) NULL;
+	}
+
+	return CDW_OK;
+}
diff -Naur orig/src/optical_file_systems/cdw_udf.h patched/src/optical_file_systems/cdw_udf.h
--- orig/src/optical_file_systems/cdw_udf.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/optical_file_systems/cdw_udf.h	2014-04-12 20:16:00.000000000 +0200
@@ -0,0 +1,51 @@
+#ifndef H_CDW_UDF
+#define H_CDW_UDF
+
+#include <inttypes.h>
+
+#include "main.h"
+
+
+/* These values don't include ending NUL character. */
+#define CDW_UDF_LVID_LEN_MAX  126  /* "Logical Volume Identifier" */
+#define CDW_UDF_VID_LEN_MAX    30  /* "Volume Identifier" */
+#define CDW_UDF_VSID_LEN_MAX  126  /* "Volume Set Identifier" */
+#define CDW_UDF_FSID_LEN_MAX   30  /* "File Set Identifier" */
+
+
+
+
+/* Options related to creating UDF file system. */
+typedef struct {
+	uint64_t volume_size_bytes;  /* This field won't be saved to config file. */
+
+	cdw_id_t mkudffs_blocksize;
+	cdw_id_t mkudffs_udfrev;
+	cdw_id_t mkudffs_strategy;
+	cdw_id_t mkudffs_spartable;
+	cdw_id_t mkudffs_media_type;
+	cdw_id_t mkudffs_space;
+	cdw_id_t mkudffs_ad;
+	bool     mkudffs_noefe;
+	cdw_id_t mkudffs_encoding;
+
+	char mkudffs_other_options[CDW_MKUDFFS_OTHER_OPTIONS_LEN_MAX + 1]; /* Other mkudffs options, not specified by other fields. */
+
+	char mkudffs_lvid[CDW_UDF_LVID_LEN_MAX + 1];  /* Logical Volume Identifier. */
+	char mkudffs_vid[CDW_UDF_VID_LEN_MAX + 1];    /* Volume Identifier. */
+	char mkudffs_vsid[CDW_UDF_VSID_LEN_MAX + 1];  /* Volume Set Identifier. */
+	char mkudffs_fsid[CDW_UDF_FSID_LEN_MAX + 1];  /* File Set Identifier. */
+
+	char rsync_options[CDW_RSYNC_OPTIONS_LEN_MAX + 1];
+	char *mount_point;
+} cdw_udf_t;
+
+
+cdw_rv_t cdw_udf_copy(cdw_udf_t *target, cdw_udf_t *source);
+cdw_rv_t cdw_udf_init(cdw_udf_t *udf);
+cdw_rv_t cdw_udf_set_defaults(cdw_udf_t *udf);
+cdw_rv_t cdw_udf_clean(cdw_udf_t *udf);
+void     cdw_udf_debug_print_options(cdw_udf_t *udf);
+
+
+#endif /* #ifndef H_CDW_UDF */
diff -Naur orig/src/optical_file_systems/isosize.c patched/src/optical_file_systems/isosize.c
--- orig/src/optical_file_systems/isosize.c	2010-08-01 20:48:52.000000000 +0200
+++ patched/src/optical_file_systems/isosize.c	2014-01-19 16:07:16.000000000 +0100
@@ -17,8 +17,8 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; see the file COPYING.  If not, write to
- * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _BSD_SOURCE
diff -Naur orig/src/optical_file_systems/Makefile.am patched/src/optical_file_systems/Makefile.am
--- orig/src/optical_file_systems/Makefile.am	2012-03-30 22:16:21.000000000 +0200
+++ patched/src/optical_file_systems/Makefile.am	2014-02-16 15:41:43.000000000 +0100
@@ -4,7 +4,8 @@
 	cdw_iso9660.c cdw_iso9660.h \
 	cdw_ofs.c cdw_ofs.h \
 	iso9660.h isosize.c \
-	isosize.h
+	isosize.h \
+	cdw_udf.c cdw_udf.h
 
 # defines values of AM_CPPFLAGS and AM_CFLAGS
 # defines target used by flymake
@@ -21,4 +22,3 @@
 check_LIBRARIES = libcdwopticalfilesystems_check.a
 libcdwopticalfilesystems_check_a_SOURCES = $(sources)
 libcdwopticalfilesystems_check_a_CPPFLAGS = -DCDW_UNIT_TEST_CODE $(AM_CPPFLAGS)
-
diff -Naur orig/src/optical_file_systems/Makefile.in patched/src/optical_file_systems/Makefile.in
--- orig/src/optical_file_systems/Makefile.in	2012-03-30 22:24:04.000000000 +0200
+++ patched/src/optical_file_systems/Makefile.in	2014-02-16 15:42:10.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,24 +76,28 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/optical_file_systems
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwopticalfilesystems_a_AR = $(AR) $(ARFLAGS)
 libcdwopticalfilesystems_a_LIBADD =
 am__objects_1 = cdw_graftpoints.$(OBJEXT) cdw_iso9660.$(OBJEXT) \
-	cdw_ofs.$(OBJEXT) isosize.$(OBJEXT)
+	cdw_ofs.$(OBJEXT) isosize.$(OBJEXT) cdw_udf.$(OBJEXT)
 am_libcdwopticalfilesystems_a_OBJECTS = $(am__objects_1)
 libcdwopticalfilesystems_a_OBJECTS =  \
 	$(am_libcdwopticalfilesystems_a_OBJECTS)
@@ -59,28 +107,76 @@
 	libcdwopticalfilesystems_check_a-cdw_graftpoints.$(OBJEXT) \
 	libcdwopticalfilesystems_check_a-cdw_iso9660.$(OBJEXT) \
 	libcdwopticalfilesystems_check_a-cdw_ofs.$(OBJEXT) \
-	libcdwopticalfilesystems_check_a-isosize.$(OBJEXT)
+	libcdwopticalfilesystems_check_a-isosize.$(OBJEXT) \
+	libcdwopticalfilesystems_check_a-cdw_udf.$(OBJEXT)
 am_libcdwopticalfilesystems_check_a_OBJECTS = $(am__objects_2)
 libcdwopticalfilesystems_check_a_OBJECTS =  \
 	$(am_libcdwopticalfilesystems_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwopticalfilesystems_a_SOURCES) \
 	$(libcdwopticalfilesystems_check_a_SOURCES)
 DIST_SOURCES = $(libcdwopticalfilesystems_a_SOURCES) \
 	$(libcdwopticalfilesystems_check_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -175,7 +271,8 @@
 	cdw_iso9660.c cdw_iso9660.h \
 	cdw_ofs.c cdw_ofs.h \
 	iso9660.h isosize.c \
-	isosize.h
+	isosize.h \
+	cdw_udf.c cdw_udf.h
 
 
 # _FILE_OFFSET_BITS=64 - large file support (>2GB on 32-bit systems);
@@ -293,14 +390,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwopticalfilesystems.a: $(libcdwopticalfilesystems_a_OBJECTS) $(libcdwopticalfilesystems_a_DEPENDENCIES) $(EXTRA_libcdwopticalfilesystems_a_DEPENDENCIES) 
-	-rm -f libcdwopticalfilesystems.a
-	$(libcdwopticalfilesystems_a_AR) libcdwopticalfilesystems.a $(libcdwopticalfilesystems_a_OBJECTS) $(libcdwopticalfilesystems_a_LIBADD)
-	$(RANLIB) libcdwopticalfilesystems.a
+	$(AM_V_at)-rm -f libcdwopticalfilesystems.a
+	$(AM_V_AR)$(libcdwopticalfilesystems_a_AR) libcdwopticalfilesystems.a $(libcdwopticalfilesystems_a_OBJECTS) $(libcdwopticalfilesystems_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwopticalfilesystems.a
+
 libcdwopticalfilesystems_check.a: $(libcdwopticalfilesystems_check_a_OBJECTS) $(libcdwopticalfilesystems_check_a_DEPENDENCIES) $(EXTRA_libcdwopticalfilesystems_check_a_DEPENDENCIES) 
-	-rm -f libcdwopticalfilesystems_check.a
-	$(libcdwopticalfilesystems_check_a_AR) libcdwopticalfilesystems_check.a $(libcdwopticalfilesystems_check_a_OBJECTS) $(libcdwopticalfilesystems_check_a_LIBADD)
-	$(RANLIB) libcdwopticalfilesystems_check.a
+	$(AM_V_at)-rm -f libcdwopticalfilesystems_check.a
+	$(AM_V_AR)$(libcdwopticalfilesystems_check_a_AR) libcdwopticalfilesystems_check.a $(libcdwopticalfilesystems_check_a_OBJECTS) $(libcdwopticalfilesystems_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwopticalfilesystems_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -311,102 +410,107 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_graftpoints.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_iso9660.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_ofs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_udf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isosize.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_udf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwopticalfilesystems_check_a-cdw_graftpoints.o: cdw_graftpoints.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_graftpoints.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_graftpoints.o `test -f 'cdw_graftpoints.c' || echo '$(srcdir)/'`cdw_graftpoints.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_graftpoints.c' object='libcdwopticalfilesystems_check_a-cdw_graftpoints.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_graftpoints.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_graftpoints.o `test -f 'cdw_graftpoints.c' || echo '$(srcdir)/'`cdw_graftpoints.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_graftpoints.c' object='libcdwopticalfilesystems_check_a-cdw_graftpoints.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_graftpoints.o `test -f 'cdw_graftpoints.c' || echo '$(srcdir)/'`cdw_graftpoints.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_graftpoints.o `test -f 'cdw_graftpoints.c' || echo '$(srcdir)/'`cdw_graftpoints.c
 
 libcdwopticalfilesystems_check_a-cdw_graftpoints.obj: cdw_graftpoints.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_graftpoints.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_graftpoints.obj `if test -f 'cdw_graftpoints.c'; then $(CYGPATH_W) 'cdw_graftpoints.c'; else $(CYGPATH_W) '$(srcdir)/cdw_graftpoints.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_graftpoints.c' object='libcdwopticalfilesystems_check_a-cdw_graftpoints.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_graftpoints.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_graftpoints.obj `if test -f 'cdw_graftpoints.c'; then $(CYGPATH_W) 'cdw_graftpoints.c'; else $(CYGPATH_W) '$(srcdir)/cdw_graftpoints.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_graftpoints.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_graftpoints.c' object='libcdwopticalfilesystems_check_a-cdw_graftpoints.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_graftpoints.obj `if test -f 'cdw_graftpoints.c'; then $(CYGPATH_W) 'cdw_graftpoints.c'; else $(CYGPATH_W) '$(srcdir)/cdw_graftpoints.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_graftpoints.obj `if test -f 'cdw_graftpoints.c'; then $(CYGPATH_W) 'cdw_graftpoints.c'; else $(CYGPATH_W) '$(srcdir)/cdw_graftpoints.c'; fi`
 
 libcdwopticalfilesystems_check_a-cdw_iso9660.o: cdw_iso9660.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_iso9660.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_iso9660.o `test -f 'cdw_iso9660.c' || echo '$(srcdir)/'`cdw_iso9660.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_iso9660.c' object='libcdwopticalfilesystems_check_a-cdw_iso9660.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_iso9660.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_iso9660.o `test -f 'cdw_iso9660.c' || echo '$(srcdir)/'`cdw_iso9660.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_iso9660.c' object='libcdwopticalfilesystems_check_a-cdw_iso9660.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_iso9660.o `test -f 'cdw_iso9660.c' || echo '$(srcdir)/'`cdw_iso9660.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_iso9660.o `test -f 'cdw_iso9660.c' || echo '$(srcdir)/'`cdw_iso9660.c
 
 libcdwopticalfilesystems_check_a-cdw_iso9660.obj: cdw_iso9660.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_iso9660.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_iso9660.obj `if test -f 'cdw_iso9660.c'; then $(CYGPATH_W) 'cdw_iso9660.c'; else $(CYGPATH_W) '$(srcdir)/cdw_iso9660.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_iso9660.c' object='libcdwopticalfilesystems_check_a-cdw_iso9660.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_iso9660.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_iso9660.obj `if test -f 'cdw_iso9660.c'; then $(CYGPATH_W) 'cdw_iso9660.c'; else $(CYGPATH_W) '$(srcdir)/cdw_iso9660.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_iso9660.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_iso9660.c' object='libcdwopticalfilesystems_check_a-cdw_iso9660.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_iso9660.obj `if test -f 'cdw_iso9660.c'; then $(CYGPATH_W) 'cdw_iso9660.c'; else $(CYGPATH_W) '$(srcdir)/cdw_iso9660.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_iso9660.obj `if test -f 'cdw_iso9660.c'; then $(CYGPATH_W) 'cdw_iso9660.c'; else $(CYGPATH_W) '$(srcdir)/cdw_iso9660.c'; fi`
 
 libcdwopticalfilesystems_check_a-cdw_ofs.o: cdw_ofs.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_ofs.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_ofs.o `test -f 'cdw_ofs.c' || echo '$(srcdir)/'`cdw_ofs.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_ofs.c' object='libcdwopticalfilesystems_check_a-cdw_ofs.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_ofs.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_ofs.o `test -f 'cdw_ofs.c' || echo '$(srcdir)/'`cdw_ofs.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_ofs.c' object='libcdwopticalfilesystems_check_a-cdw_ofs.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_ofs.o `test -f 'cdw_ofs.c' || echo '$(srcdir)/'`cdw_ofs.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_ofs.o `test -f 'cdw_ofs.c' || echo '$(srcdir)/'`cdw_ofs.c
 
 libcdwopticalfilesystems_check_a-cdw_ofs.obj: cdw_ofs.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_ofs.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_ofs.obj `if test -f 'cdw_ofs.c'; then $(CYGPATH_W) 'cdw_ofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ofs.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_ofs.c' object='libcdwopticalfilesystems_check_a-cdw_ofs.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_ofs.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_ofs.obj `if test -f 'cdw_ofs.c'; then $(CYGPATH_W) 'cdw_ofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ofs.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_ofs.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_ofs.c' object='libcdwopticalfilesystems_check_a-cdw_ofs.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_ofs.obj `if test -f 'cdw_ofs.c'; then $(CYGPATH_W) 'cdw_ofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ofs.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_ofs.obj `if test -f 'cdw_ofs.c'; then $(CYGPATH_W) 'cdw_ofs.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ofs.c'; fi`
 
 libcdwopticalfilesystems_check_a-isosize.o: isosize.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-isosize.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Tpo -c -o libcdwopticalfilesystems_check_a-isosize.o `test -f 'isosize.c' || echo '$(srcdir)/'`isosize.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='isosize.c' object='libcdwopticalfilesystems_check_a-isosize.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-isosize.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Tpo -c -o libcdwopticalfilesystems_check_a-isosize.o `test -f 'isosize.c' || echo '$(srcdir)/'`isosize.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='isosize.c' object='libcdwopticalfilesystems_check_a-isosize.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-isosize.o `test -f 'isosize.c' || echo '$(srcdir)/'`isosize.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-isosize.o `test -f 'isosize.c' || echo '$(srcdir)/'`isosize.c
 
 libcdwopticalfilesystems_check_a-isosize.obj: isosize.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-isosize.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Tpo -c -o libcdwopticalfilesystems_check_a-isosize.obj `if test -f 'isosize.c'; then $(CYGPATH_W) 'isosize.c'; else $(CYGPATH_W) '$(srcdir)/isosize.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='isosize.c' object='libcdwopticalfilesystems_check_a-isosize.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-isosize.obj `if test -f 'isosize.c'; then $(CYGPATH_W) 'isosize.c'; else $(CYGPATH_W) '$(srcdir)/isosize.c'; fi`
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-isosize.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Tpo -c -o libcdwopticalfilesystems_check_a-isosize.obj `if test -f 'isosize.c'; then $(CYGPATH_W) 'isosize.c'; else $(CYGPATH_W) '$(srcdir)/isosize.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-isosize.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='isosize.c' object='libcdwopticalfilesystems_check_a-isosize.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-isosize.obj `if test -f 'isosize.c'; then $(CYGPATH_W) 'isosize.c'; else $(CYGPATH_W) '$(srcdir)/isosize.c'; fi`
+
+libcdwopticalfilesystems_check_a-cdw_udf.o: cdw_udf.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_udf.o -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_udf.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_udf.o `test -f 'cdw_udf.c' || echo '$(srcdir)/'`cdw_udf.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_udf.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_udf.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_udf.c' object='libcdwopticalfilesystems_check_a-cdw_udf.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_udf.o `test -f 'cdw_udf.c' || echo '$(srcdir)/'`cdw_udf.c
+
+libcdwopticalfilesystems_check_a-cdw_udf.obj: cdw_udf.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwopticalfilesystems_check_a-cdw_udf.obj -MD -MP -MF $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_udf.Tpo -c -o libcdwopticalfilesystems_check_a-cdw_udf.obj `if test -f 'cdw_udf.c'; then $(CYGPATH_W) 'cdw_udf.c'; else $(CYGPATH_W) '$(srcdir)/cdw_udf.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_udf.Tpo $(DEPDIR)/libcdwopticalfilesystems_check_a-cdw_udf.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_udf.c' object='libcdwopticalfilesystems_check_a-cdw_udf.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwopticalfilesystems_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwopticalfilesystems_check_a-cdw_udf.obj `if test -f 'cdw_udf.c'; then $(CYGPATH_W) 'cdw_udf.c'; else $(CYGPATH_W) '$(srcdir)/cdw_udf.c'; fi`
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -418,15 +522,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -435,6 +535,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -576,18 +691,19 @@
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean \
-	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES ctags \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # used by flymake
diff -Naur orig/src/tasks/cdw_burn_disc.c patched/src/tasks/cdw_burn_disc.c
--- orig/src/tasks/cdw_burn_disc.c	2012-03-25 18:26:19.000000000 +0200
+++ patched/src/tasks/cdw_burn_disc.c	2014-04-12 20:17:46.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,13 +14,14 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #define _BSD_SOURCE /* lstat() */
 
 #include <sys/stat.h>
 #include <errno.h>
 #include <unistd.h>
+#include <stdlib.h>
 
 #include "main.h"
 #include "cdw_config.h"
@@ -31,6 +32,7 @@
 #include "cdw_burn_disc.h"
 #include "cdw_write_wizard.h"
 
+#include "cdw_string.h"
 #include "cdw_utils.h"
 #include "cdw_drive.h"
 #include "cdw_file_picker.h"
@@ -102,8 +104,9 @@
 		return CDW_NO;
 	}
 
-	/* update information about disc size and usage */
-	cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, true, cdw_config_follow_symlinks());
+	/* Update information about disc type, size and usage. */
+	cdw_main_window_disc_info_view_display_data(disc);
+	cdw_main_window_volume_info_view_update(disc->capacity.sectors_used, disc->capacity.sectors_total, true);
 
 
 	cdw_task_t *task = cdw_task_new(task_id, disc);
@@ -152,7 +155,7 @@
 		return CDW_CANCEL;
 	}
 
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	cdw_assert (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE,
 		    "ERROR: task id has changed\n");
@@ -184,17 +187,20 @@
 	cdw_rv_t tool_status = cdw_task_check_tool_status(task);
 
 	if (command_return == CDW_OK && tool_status == CDW_OK) {
-		if (task->burn.verify) {
-			cdw_vdm ("INFO: \"verify burn\" is true, attempting verification\n");
+
+		/* Keep in mind that trying to verify a dummy write is
+		   a bad idea. */
+		if (task->burn.verify && !task->burn.dummy) {
+			cdw_vdm ("INFO: \"verify burn\" is true, \"dummy write\" is false, attempting verification\n");
 			cdw_drive_close_tray_with_ui_update(drive_fullpath);
 
-			cdw_rv_t verification = cdw_calculate_digest(CDW_CALCULATE_DIGEST_MODE_DISC_FILE, task->burn.iso9660_file_fullpath);
+			cdw_rv_t verification = cdw_calculate_digest(CDW_CALCULATE_DIGEST_MODE_DISC_FILE, task->image_file_fullpath);
 			if (verification != CDW_OK) {
 				cdw_vdm ("ERROR: verification function returns !CDW_OK\n");
 				command_return = CDW_ERROR;
 			}
 		} else {
-			cdw_vdm ("INFO: \"verify burn\" is false, not attempting to verify\n");
+			cdw_vdm ("INFO: \"verify burn\" is false or \"dummy write\" is true, not attempting verification\n");
 		}
 	} else {
 		/* incorrect situation, already covered by debug messages above */
@@ -213,7 +219,7 @@
 
 	cdw_rv_t retval = CDW_OK;
 	if (command_return == CDW_OK && tool_status == CDW_OK) {
-		cdw_task_save(task);
+		cdw_task_save_options(task);
 
 		/* 2TRANS: this is message in dialog window:
 		   operation finished with unknown result, probably success */
@@ -391,14 +397,14 @@
 						     /* 2TRANS: this is the message in the dialog window;
 						     "writing" means writing to optical disc */
 						     _("Please enter FULL path to an existing iso image file for writing:"),
-						     &(task->burn.iso9660_file_fullpath),
+						     &(task->image_file_fullpath),
 						     CDW_FS_FILE, R_OK, CDW_FS_EXISTING);
 
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		if (crv == CDW_OK) {
 			/* TODO: replace with call to generic
 			   cdw_fs_get_size_(const char *fullpath, int units); */
-			task->burn.data_size_mb = cdw_iso_image_get_size_mb(task->burn.iso9660_file_fullpath);
+			task->burn.data_size_mb = cdw_iso_image_get_size_mb(task->image_file_fullpath);
 			source_available = true;
 		}
 	} else if (task->id == CDW_TASK_BURN_FROM_FILES) {
@@ -517,3 +523,195 @@
 
 
 
+
+
+cdw_rv_t cdw_write_copy(cdw_write_t *target, cdw_write_t *source)
+{
+	target->tool.id    = source->tool.id;
+	/* 'label' is a pointer to const label in cdw_ext_tools. Don't
+	   use string copying functions. */
+	target->tool.label = source->tool.label;
+
+
+	for (int i = 0; i < CDW_SESSION_MODE_N_MAX; i++) {
+		target->session_modes[i] = source->session_modes[i];
+	}
+	target->session_modes_n_labels   = source->session_modes_n_labels;
+	target->session_mode             = source->session_mode;
+
+
+	for (int i = 0; i < CDW_DISC_MODE_N_MODES; i++) {
+		target->disc_modes[i] = source->disc_modes[i];
+	}
+	target->disc_modes_n_labels   = source->disc_modes_n_labels;
+	target->disc_mode             = source->disc_mode;
+
+
+	target->speed_id = source->speed_id;
+	target->verify   = source->verify;
+	target->dummy    = source->dummy;
+	target->eject    = source->eject;
+
+
+	target->data_size_mb = source->data_size_mb;
+
+
+	target->cdrecord_burnproof = source->cdrecord_burnproof;
+	target->cdrecord_pad       = source->cdrecord_pad;
+	target->cdrecord_pad_size  = source->cdrecord_pad_size;
+
+
+	cdw_rv_t crv = cdw_string_set(&(target->cdrecord_other_options), source->cdrecord_other_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set cdrecord_other_options from src = \"%s\"\n", source->cdrecord_other_options);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(target->xorriso_burn_other_options), source->xorriso_burn_other_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set xorriso_burn_other_options from src = \"%s\"\n", source->xorriso_burn_other_options);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(target->growisofs_other_options), source->growisofs_other_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set growisofs_other_options from src = \"%s\"\n", source->growisofs_other_options);
+		return CDW_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+void cdw_write_init(cdw_write_t *write)
+{
+	write->tool.id = CDW_TOOL_NONE;
+	write->tool.label = (char *) NULL;
+
+	write->cdrecord_other_options = (char *) NULL;
+	write->xorriso_burn_other_options = (char *) NULL;
+	write->growisofs_other_options = (char *) NULL;
+
+	return;
+}
+
+
+
+
+
+void cdw_write_clean(cdw_write_t *write)
+{
+	if (write->cdrecord_other_options) {
+		free(write->cdrecord_other_options);
+		write->cdrecord_other_options = (char *) NULL;
+	}
+	if (write->xorriso_burn_other_options) {
+		free(write->xorriso_burn_other_options);
+		write->xorriso_burn_other_options = (char *) NULL;
+	}
+	if (write->growisofs_other_options) {
+		free(write->growisofs_other_options);
+		write->growisofs_other_options = (char *) NULL;
+	}
+
+	return;
+}
+
+
+
+
+
+cdw_rv_t cdw_write_set_defaults(cdw_write_t *write)
+{
+	for (int i = 0; i < CDW_SESSION_MODE_N_MAX; i++) {
+		write->session_modes[i] = CDW_SESSION_MODE_INIT;
+	}
+	write->session_modes_n_labels   = 0;
+	write->session_mode             = CDW_SESSION_MODE_INIT;
+
+
+	for (int i = 0; i < CDW_DISC_MODE_N_MODES; i++) {
+		write->disc_modes[i] = CDW_DISC_MODE_INIT;
+	}
+	write->disc_modes_n_labels   = 0;
+	write->disc_mode             = CDW_DISC_MODE_INIT;
+
+
+	write->speed_id = 0;
+	write->verify   = true;
+	write->dummy    = false;
+	write->eject    = false;  /* Keep consistent with cdw_erase_t->eject. */
+
+
+	write->data_size_mb = 0.0;
+
+
+	write->cdrecord_burnproof = true;
+	write->cdrecord_pad = true;
+	/* the "150" value is selected after small tests with DVD; originally it was 63, which
+	   worked just fine for CDs, but for DVDs it was insufficient;
+	   TODO: the same value is used in code creating configuration forms,
+	   so it should be a constant defined in some header */
+	/* OLD COMMENT: value of 63 is taken from here:
+	   http://www.troubleshooters.com/linux/coasterless.htm */
+	write->cdrecord_pad_size = 150;
+
+
+	/* Can't set to (char *) NULL because these options are used
+	   as argument of concat() in some places. */
+	cdw_rv_t crv = cdw_string_set(&(write->cdrecord_other_options), "");
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set cdrecord_other_options\n");
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(write->xorriso_burn_other_options), "");
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set xorriso_burn_other_options\n");
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(write->growisofs_other_options), "");
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set growisofs_other_options\n");
+		return CDW_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+void cdw_write_debug_print_options(cdw_write_t *write)
+{
+	cdw_vdm ("INFO: Write options:\n");
+
+	cdw_vdm ("INFO:                    tool ID = %lld (%s)\n",  write->tool.id, cdw_ext_tools_get_tool_name(write->tool.id));
+	cdw_vdm ("INFO:                 tool label = %s\n",         write->tool.label);
+
+	cdw_vdm ("INFO:               session mode = %lld\n",       write->session_mode);
+	cdw_vdm ("INFO:                  disc mode = %lld\n",       write->disc_mode);
+
+	cdw_vdm ("INFO:                   speed ID = %lld\n",       write->speed_id);
+
+	cdw_vdm ("INFO:                     verify = %s\n",         write->verify ? "true" : "false");
+	cdw_vdm ("INFO:                      dummy = %s\n",         write->dummy ? "true" : "false");
+	cdw_vdm ("INFO:                      eject = %s\n",         write->eject ? "true" : "false");
+
+	cdw_vdm ("INFO:                  data size = %g MB\n",      write->data_size_mb);
+
+	cdw_vdm ("INFO:         cdrecord burnproof = %s\n",         write->cdrecord_burnproof ? "true" : "false");
+	cdw_vdm ("INFO:               cdrecord pad = %s\n",         write->cdrecord_pad ? "true" : "false");
+	cdw_vdm ("INFO:          cdrecord pad size = %d\n",         write->cdrecord_pad_size);
+
+	cdw_vdm ("INFO:     cdrecord other options = \"%s\"\n",     write->cdrecord_other_options);
+	cdw_vdm ("INFO: xorriso other burn options = \"%s\"\n\n",   write->xorriso_burn_other_options);
+	cdw_vdm ("INFO:    growisofs other options = \"%s\"\n",     write->growisofs_other_options);
+
+	return;
+}
diff -Naur orig/src/tasks/cdw_burn_disc.h patched/src/tasks/cdw_burn_disc.h
--- orig/src/tasks/cdw_burn_disc.h	2009-10-25 12:16:50.000000000 +0100
+++ patched/src/tasks/cdw_burn_disc.h	2014-03-10 20:12:03.000000000 +0100
@@ -1,10 +1,93 @@
 #ifndef H_CDW_BURN_DISC
 #define H_CDW_BURN_DISC
 
-
 #include "main.h"
 
+/* mode of writing files to a CD/DVD disc */
+enum {
+	CDW_SESSION_MODE_INIT = -1,
+	CDW_SESSION_MODE_START_MULTI = 0,  /**< \brief Start writing to disc in mode allowing further appending of data (don't close disc after writing) */
+	CDW_SESSION_MODE_CREATE_SINGLE,    /**< \brief Start writing to disc in mode NOT allowing further appending of data (close disc after writing)*/
+	CDW_SESSION_MODE_CONTINUE_MULTI,   /**< \brief Continue writing to disc in mode allowing further appending of data (don't close disc after writing) */
+	CDW_SESSION_MODE_WRITE_FINAL,      /**< \brief Write to disc in mode NOT allowing further appending of data (close disc after writing) */
+	CDW_SESSION_MODE_ERROR,
+	CDW_SESSION_MODE_N_MAX
+};
+
+
+/* mode of writing files to a CD/DVD disc */
+#define CDW_DISC_MODE_INIT        0x100000000000
+#define CDW_DISC_MODE_UNSPECIFIED 0x000000000000   /**< \brief Let a tool select its own mode */
+#define CDW_DISC_MODE_TAO         0x000000000001   /**< \brief Track at once */
+#define CDW_DISC_MODE_DAO         0x000000000010   /**< \brief Disc at once */
+#define CDW_DISC_MODE_SAO         0x000000000100   /**< \brief Session at once */
+#if 0 /* currently unsupported modes */
+#define CDW_DISC_MODE_RAW         0x000000001000   /**< \brief Raw */
+#define CDW_DISC_MODE_RAW96P      0x000000010000
+#define CDW_DISC_MODE_RAW96R      0x000000100000
+#define CDW_DISC_MODE_RAW16       0x000001000000
+#endif
+#define CDW_DISC_MODE_ERROR       0x010000000000
+
+#define CDW_DISC_MODE_N_MODES    5 /* includes "Error" */
+// #define CDW_DISC_MODE_MODES_TABLE_SIZE     CDW_DISC_MODE_SAO
+
+
+
+
+
+
+typedef struct {
+	cdw_id_label_t tool;
+
+	/* Single session, append, finalize, etc. */
+	cdw_id_t session_modes[CDW_SESSION_MODE_N_MAX];
+	int session_modes_n_labels;
+	cdw_id_t session_mode;
+
+	/* Allowed disc modes: tao, sao, etc.; I'm not using
+	   single int + ORing, because the order of modes is
+	   significant: first mode on the list is most
+	   appropriate/probable. */
+	cdw_id_t disc_modes[CDW_DISC_MODE_N_MODES];
+	int disc_modes_n_labels;
+	cdw_id_t disc_mode;
+
+	cdw_id_t speed_id; /* ID of write speed (ID, not the speed itself). */
+	bool verify;       /* Verify checksums after writing and image to disc. */
+	bool dummy;        /* Dummy write. */
+	bool eject;        /* Eject after write is completed. */
+
+	/* Size of data being burned to disc. This variable
+	   should not store _exact_ size of data, value stored
+	   in this variable should be used only when
+	   approximate data size needs to be known, e.g. in
+	   progress window when displaying approximate
+	   progress of task.  Depending on type of task this
+	   variable stores size of iso image file being burned
+	   to optical disc, or size of files selected for
+	   burning to optical disc. */
+	double data_size_mb;
+
+	/* cdrecord-specific. */
+	bool cdrecord_burnproof;
+	bool cdrecord_pad;
+	int  cdrecord_pad_size;
+
+	char *cdrecord_other_options;
+	char *xorriso_burn_other_options;
+	char *growisofs_other_options;
+} cdw_write_t;
+
+
+
 cdw_rv_t cdw_burn_disc(int task_id);
 
 
+cdw_rv_t cdw_write_copy(cdw_write_t *target, cdw_write_t *source);
+void     cdw_write_init(cdw_write_t *write);
+void     cdw_write_clean(cdw_write_t *write);
+cdw_rv_t cdw_write_set_defaults(cdw_write_t *write);
+void     cdw_write_debug_print_options(cdw_write_t *write);
+
 #endif /* H_CDW_BURN_DISC */
diff -Naur orig/src/tasks/cdw_calculate_digest.c patched/src/tasks/cdw_calculate_digest.c
--- orig/src/tasks/cdw_calculate_digest.c	2012-03-28 20:54:29.000000000 +0200
+++ patched/src/tasks/cdw_calculate_digest.c	2014-04-06 22:22:41.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdlib.h>
@@ -141,7 +141,7 @@
 		/* when cdw is run in login console and there are some
 		   disc read errors, OS prints some error messages to the
 		   console that overwrite cdw ui; this line fixes it */
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		cdw_processwin_wrefresh();
 
 		if (crv != CDW_OK) {
@@ -296,7 +296,7 @@
 				   CDW_BUTTONS_OK, CDW_COLORS_WARNING);
 		}
 
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 
 		/* Add some '\n' chars to keep strings grouped and aligned;
 		   especially important for digest strings - if they start in the
@@ -646,8 +646,8 @@
 	}
 
 	char *fullpath = (char *) NULL;
-	if (global_config.iso_image_full_path != (char *) NULL) {
-		fullpath = strdup(global_config.iso_image_full_path);
+	if (global_config.general.image_fullpath) {
+		fullpath = strdup(global_config.general.image_fullpath);
 	} else {
 		fullpath = cdw_fs_get_initial_dirpath();
 	}
@@ -663,11 +663,13 @@
 						     &fullpath, CDW_FS_FILE, R_OK, CDW_FS_EXISTING);
 
 		if (crv == CDW_CANCEL || crv == CDW_ERROR) {
+			free(fullpath);
+			fullpath = (char *) NULL;
 			return crv;
 		}
 	}
 
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	cdw_rv_t crv = cdw_calculate_digest(mode, fullpath);
 	free(fullpath);
@@ -675,4 +677,3 @@
 
 	return crv;
 }
-
diff -Naur orig/src/tasks/cdw_cdda2wav.c patched/src/tasks/cdw_cdda2wav.c
--- orig/src/tasks/cdw_cdda2wav.c	2012-03-28 21:14:07.000000000 +0200
+++ patched/src/tasks/cdw_cdda2wav.c	2014-01-19 16:07:16.000000000 +0100
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 // #include <stdlib.h>
 // #include <stdio.h>
diff -Naur orig/src/tasks/cdw_create_image.c patched/src/tasks/cdw_create_image.c
--- orig/src/tasks/cdw_create_image.c	2012-03-13 21:26:35.000000000 +0100
+++ patched/src/tasks/cdw_create_image.c	2014-04-12 20:16:49.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,9 +14,14 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
+#define _GNU_SOURCE /* asprintf() */
+
+#include <inttypes.h>
+#include <stdlib.h>
+
 #include "cdw_file_manager.h"
 #include "gettext.h"
 #include "cdw_create_image.h"
@@ -25,13 +30,41 @@
 #include "cdw_ext_tools.h"
 #include "cdw_mkisofs.h"
 #include "cdw_xorriso.h"
+#include "cdw_mkudffs.h"
+#include "cdw_mkudffs_helpers.h"
 #include "cdw_main_window.h"
 #include "cdw_processwin.h"
-#include "cdw_iso9660_wizard.h"
+#include "cdw_image_wizard.h"
+#include "cdw_logging.h"
+#include "cdw_config.h"
+#include "cdw_string.h"
+
+
+
+
+extern cdw_config_t global_config;
+
+
+
+
 
+/* Pause between each step of "make UDF" recipe, in microseconds. This
+   pause is for improved user experience, so that - for some steps -
+   messages in process window don't "flash" too quickly. */
+#define CDW_CREATE_IMAGE_PAUSE       1000000  /* [us] */
 
+/* Additional wait time after call of sync(1) utility returns, to give
+   a hard disc some more time to finalize syncing contents of mounted
+   UDF file system. Otherwise we may attempt to umount UDF filesystem
+   too early, when copied data is still flushed to the filesystem. */
+#define CDW_CREATE_IMAGE_SYNC_DELAY       5  /* [s] */
+
+static cdw_id_t cdw_create_image_get_initial_task_id(void);
 //static cdw_rv_t cdw_create_image_check_boot_image(void);
-//static cdw_rv_t cdw_create_image_get_target_data_image_path(void);
+static cdw_rv_t cdw_create_image_udf(cdw_task_t *task);
+
+
+
 
 
 /**
@@ -47,26 +80,75 @@
 */
 cdw_rv_t cdw_create_image(void)
 {
-	cdw_task_t *task = cdw_task_new(CDW_TASK_CREATE_IMAGE, (cdw_disc_t *) NULL);
-	if (task == (cdw_task_t *) NULL) {
+	if (!cdw_file_manager_number_of_selected_files()) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("No files selected"),
+				   /* 2TRANS: this is message in dialog window, user
+				      wants to write files or create image, but no
+				      files from hdd are selected yet */
+				   _("No files selected. Please use 'Add files'"),
+				   CDW_BUTTONS_OK, CDW_COLORS_DIALOG);
+		return CDW_NO;
+	}
+
+
+	cdw_id_t task_id = cdw_create_image_get_initial_task_id();
+	if (task_id == CDW_TASK_NONE) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("No tools available"),
+				   /* 2TRANS: this is message in dialog window, user
+				      wants to write files or create image, but no
+				      tools for this task are available. */
+				   _("Cannot create image file. No tools for this task are available. Check your configuration."),
+				   CDW_BUTTONS_OK, CDW_COLORS_DIALOG);
+		return CDW_NO;
+	}
+	cdw_vdm ("INFO: initial task id = %lld\n", task_id);
+
+
+	cdw_task_t *task = cdw_task_new(task_id, (cdw_disc_t *) NULL);
+	if (!task) {
 		cdw_vdm ("ERROR: failed to create a task\n");
 		return CDW_ERROR;
 	}
 
-	/* create graftpoints file for mkisofs; first checks if there
-	   are any files that will be used as source data */
-	cdw_rv_t crv = cdw_file_manager_create_graftpoints_file();
-	if (crv != CDW_OK) {
+
+	int rv = cdw_image_wizard(task);
+	if (rv == CDW_IMAGE_FORMAT_NONE) {
+		cdw_vdm ("INFO: cancelled in wizard\n");
 		cdw_task_delete(&task);
+		cdw_file_manager_delete_graftpoints_file();
 		return CDW_NO;
+	} else if (rv == CDW_IMAGE_FORMAT_ERROR) {
+		cdw_vdm ("ERROR: error in wizard\n");
+		cdw_task_delete(&task);
+		cdw_file_manager_delete_graftpoints_file();
+		return CDW_ERROR;
+	} else {
+		; /* Pass, CDW_IMAGE_FORMAT_ISO9660 || CDW_IMAGE_FORMAT_UDF. */
 	}
 
 
-	crv = cdw_iso9660_wizard(task);
+	if (rv == CDW_IMAGE_FORMAT_ISO9660) {
+		task->id = CDW_TASK_CREATE_IMAGE_ISO9660;
+		/* create graftpoints file for mkisofs; first checks if there
+		   are any files that will be used as source data */
+		cdw_rv_t crv = cdw_file_manager_create_graftpoints_file();
+		if (crv != CDW_OK) {
+			cdw_task_delete(&task);
+			return CDW_NO;
+		}
+	} else {
+		task->id = CDW_TASK_CREATE_IMAGE_UDF;
+	}
+
+	/* The function has been called in cdw_task_new(), but we need
+	   to call it again after user has selected image format in
+	   wizard. */
+	cdw_rv_t crv = cdw_task_select_tools_for_task(task, task->disc);
 	if (crv != CDW_OK) {
-		cdw_vdm ("INFO: cancelled in wizard\n");
+		cdw_vdm ("ERROR: failed to select tools for task\n");
 		cdw_task_delete(&task);
-		cdw_file_manager_delete_graftpoints_file();
 		return CDW_NO;
 	}
 
@@ -75,32 +157,52 @@
 	   if the boot image exists */
 	crv = cdw_create_image_check_boot_image();
 	if (crv != CDW_OK) {
+		cdw_task_delete(&task);
 		return CDW_NO;
 	}
 #endif
 
 	/* 2TRANS: this is title of dialog window */
 	cdw_processwin_create(_("Create image"),
+			      task->id == CDW_TASK_CREATE_IMAGE_ISO9660 ?
 			      /* 2TRANS: this is message in dialog
-				 window - creating iso image is in
+				 window - creating ISO9660 image is in
 				 progress */
-			      _("Creating iso image..."), true);
+			      _("Creating ISO9660 image...") :
+			      /* 2TRANS: this is message in dialog
+				 window - creating UDF image is in
+				 progress */
+			      _("Creating UDF image..."),
+			      true);
+
+	cdw_logging_write_separator();
 
 	/* go! */
 	if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-		cdw_vdm ("INFO: path at call to run task: %s\n", task->create_image.iso9660_file_fullpath);
+		cdw_vdm ("INFO: path at call to run task: %s\n", task->image_file_fullpath);
 		crv = cdw_mkisofs_run_task(task, (cdw_disc_t *) NULL);
 	} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
 		crv = cdw_xorriso_run_task(task, (cdw_disc_t *) NULL);
+	} else if (task->create_image.tool.id == CDW_TOOL_MKUDFFS) {
+		crv = cdw_create_image_udf(task);
 	} else {
 		cdw_vdm ("ERROR: tool id is invalid: %lld\n", task->create_image.tool.id);
+		crv = CDW_ERROR;
 	}
 
-	/* 2TRANS: this is message in dialog window:
-	   operation finished with unknown result */
-	cdw_processwin_destroy(_("Finished"), true);
+	if (crv == CDW_OK) {
+		/* 2TRANS: this is message in process window:
+		   operation finished with unknown result. */
+		cdw_processwin_destroy(_("Finished"), true);
+	} else {
+		/* 2TRANS: this is message in process window:
+		   operation finished with error. */
+		cdw_processwin_destroy(_("Error"), true);
+	}
 
-	cdw_file_manager_delete_graftpoints_file();
+	if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
+		cdw_file_manager_delete_graftpoints_file();
+	}
 
 	/* this function sets task.success according to task->tool_status,
 	   and resets task->tool_status; displays error messages in case
@@ -108,21 +210,21 @@
 	cdw_task_check_tool_status(task);
 
 	if (crv == CDW_OK) {
-		cdw_task_save(task);
+		cdw_task_save_options(task);
 		/* 2TRANS: this is title of dialog window, window shows
 		   messages from program writing selected files to iso
 		   image (creating iso image from selected files) */
 		after_event(_("\"Create image\" log"), 1);
 	} else {
-		cdw_vdm ("ERROR: failed to create image\n");
+		cdw_sdm ("ERROR: failed to create image\n");
 		/* 2TRANS: this is title of dialog window */
 		cdw_buttons_dialog(_("Error"),
 				   /* 2TRANS: this is message in dialog window:
 				      probably some malloc() call failed when
 				      program was preparing call of mkisofs;
 				      'command' is command-line command. 'Image'
-				      means iso image file. */
-				   _("System error occurred when preparing command. Image not created."),
+				      means ISO9660 or UDF image file. */
+				   _("Some error occurred when creating image. Image not created or the image is invalid. Please consult log file ('L' hotkey in main window)."),
 				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
 	}
 
@@ -134,6 +236,49 @@
 
 
 
+
+cdw_id_t cdw_create_image_get_initial_task_id(void)
+{
+	bool can_do_iso = cdw_ext_tools_iso9660_sa_tool_available();
+	bool can_do_udf = cdw_ext_tools_udf_sa_tools_tools_available();
+
+	if (can_do_iso && global_config.task_id == CDW_TASK_CREATE_IMAGE_ISO9660) {
+
+		/* Previously selected image format was ISO9660. Use
+		   (initially) the same format this time. */
+		return CDW_TASK_CREATE_IMAGE_ISO9660;
+	}
+
+	if (can_do_udf && global_config.task_id == CDW_TASK_CREATE_IMAGE_UDF) {
+
+		/* Previously selected image format was UDF. Use
+		   (initially) the same format this time. */
+		return CDW_TASK_CREATE_IMAGE_UDF;
+	}
+
+
+	/* Previous task was not "create image" task. Function is free
+	   to select any image format as default/initial one. Let's
+	   use ISO9660 (if there are tools for it). */
+
+	if (can_do_iso) {
+		cdw_vdm ("INFO: can do ISO9660\n");
+		return CDW_TASK_CREATE_IMAGE_ISO9660;
+	}
+
+	if (can_do_udf) {
+		cdw_vdm ("INFO: can do UDF\n");
+		return CDW_TASK_CREATE_IMAGE_UDF;
+	}
+
+	cdw_vdm ("INFO: cannot do neither ISO9660 nor UDF\n");
+	return CDW_TASK_NONE;
+}
+
+
+
+
+
 #if 0
 cdw_rv_t cdw_create_image_check_boot_image(void)
 {
@@ -150,34 +295,205 @@
 	}
 	return CDW_OK;
 }
+#endif
 
 
 
 
 
-cdw_rv_t cdw_create_image_get_target_data_image_path(void)
+cdw_rv_t cdw_create_image_udf(cdw_task_t *task)
 {
-	/* 2TRANS: this is title of dialog window */
-	cdw_rv_t crv = cdw_fs_ui_file_picker(_("Path to iso image"),
-					     /* 2TRANS: this is message in dialog window;
-					     below it there is an input field where user can
-					     enter path to ISO image file */
-					     _("Please enter FULL path to new iso image file:"),
-					     &(global_config.iso_image_full_path),
-					     CDW_FS_FILE, R_OK | W_OK, CDW_FS_NEW | CDW_FS_EXISTING);
+	cdw_processwin_display_main_info("Getting volume size");
 
-	cdw_vcrv ("cdw_fs_ui_file_picker", crv);
-	if (crv == CDW_OK) {
-		cdw_vdm ("INFO: file picker returns \"%s\"\n", global_config.iso_image_full_path);
-	} else if (crv == CDW_CANCEL) {
-		cdw_vdm ("INFO: pressed escape in file picker, fullpath is \"%s\"\n", global_config.iso_image_full_path);
+	usleep(2 * CDW_CREATE_IMAGE_PAUSE);
+
+	/* Ensure that we have some value of UDF file size before
+	   doing anything else. */
+	uint64_t volume_size = 0;
+	if (global_config.general.volume_size_id == CDW_CONFIG_VOLUME_SIZE_AUTO) {
+		volume_size = cdw_disc_get_total_capacity_bytes();
 	} else {
-		cdw_vdm ("INFO: file picker returns CDW_ERROR, fullpath is \"%s\"\n", global_config.iso_image_full_path);
+		/* TODO: use function that returns value in bytes. */
+		long int size = cdw_config_get_current_volume_size_value_megabytes();
+		cdw_vdm ("INFO: size = %ld\n", size);
+		if (size < 0) {
+			volume_size = 0;
+		} else {
+			volume_size = ((uint64_t) size) * 1024 * 1024;
+		}
 	}
-	cdw_main_ui_main_window_wrefresh();
 
-	return crv;
-}
+	if (volume_size == 0) {
+		if (global_config.general.volume_size_id == CDW_CONFIG_VOLUME_SIZE_AUTO) {
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window */
+					   _("To create UDF image, cdw needs to get size of UDF volume.\ncdw failed to get total capacity from optical disc. Enter disc into tray, or change settings in Configuration -> Log and misc -> Volume size."),
+					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		} else {
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window */
+					   _("To create UDF image, cdw needs to get size of UDF volume.\nVolume size configured in Configuration -> Log and misc -> Volume size is invalid."),
+					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		}
+		cdw_main_window_wrefresh();
+		cdw_processwin_wrefresh();
 
+		return CDW_ERROR;
+	}
 
-#endif
+	uint64_t selected_size = (uint64_t) cdw_selected_files_get_size();
+	cdw_vdm ("INFO: selected size: %"PRIu64"\n", selected_size);
+	cdw_vdm ("INFO: volume size:   %"PRIu64"\n", volume_size);
+	if (volume_size < selected_size) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_rv_t crv = cdw_buttons_dialog(_("Warning"),
+						  /* 2TRANS: this is message in dialog window */
+						  _("Current volume size is / may be too small for selected files. Expect problems with this UDF image. Press OK to continue, press Cancel to cancel."),
+						  CDW_BUTTONS_OK_CANCEL, CDW_COLORS_WARNING);
+		if (crv != CDW_OK) {
+			cdw_main_window_wrefresh();
+			cdw_processwin_wrefresh();
+			return CDW_NO;
+		}
+	}
+
+	task->create_image.udf.volume_size_bytes = volume_size;
+
+
+	cdw_main_window_wrefresh();
+
+	/* Clear messages that may have been used when getting volume
+	   size information from optical disc. */
+	cdw_processwin_display_main_info("");
+	cdw_processwin_display_sub_info("");
+	cdw_processwin_wrefresh();
+
+
+
+	/* No progress bar while calling truncate, mkudffs and mount. */
+	cdw_processwin_delete_progress_bar();
+
+	cdw_logging_write("\n\nCreating UDF file: 1/6: attempting to create initial empty file:");
+	cdw_processwin_display_main_info("Creating initial .udf file");
+	usleep(2 * CDW_CREATE_IMAGE_PAUSE);
+	cdw_rv_t crv = cdw_truncate_run_task(task);
+	if (crv != CDW_OK) {
+		cdw_logging_write("Creating UDF file: 1/6: attempting to create initial empty file FAILED\n");
+		cdw_logging_write("Creating UDF file: 1/6: \"truncate\" exit status is %d.\n", task->tool_status.child_exit_status);
+		return CDW_ERROR;
+	}
+
+
+	usleep(CDW_CREATE_IMAGE_PAUSE);
+
+
+	cdw_logging_write("\n\nCreating UDF file: 2/6: attempting to create initial UDF file system:\n");
+	cdw_processwin_display_main_info("Creating initial UDF file system");
+	crv = cdw_mkudffs_run_task(task);
+	if (crv != CDW_OK) {
+		cdw_logging_write("Creating UDF file: 2/6: attempting to create initial UDF file system FAILED\n");
+		cdw_logging_write("Creating UDF file: 2/6: \"mkudffs\" exit status is %d.\n", task->tool_status.child_exit_status);
+		return CDW_ERROR;
+	}
+
+
+	usleep(CDW_CREATE_IMAGE_PAUSE);
+
+
+	cdw_logging_write("\n\nCreating UDF file: 3/6: attempting to mount UDF file system:\n");
+	cdw_processwin_display_main_info("Mounting UDF file system");
+	crv = cdw_mount_run_task(task);
+	if (crv != CDW_OK) {
+		cdw_logging_write("Creating UDF file: 3/6: attempting to mount UDF file system FAILED.\n");
+		cdw_logging_write("Creating UDF file: 3/6: \"sudo mount\" exit status is %d.\n", task->tool_status.child_exit_status);
+		return CDW_ERROR;
+	} else {
+		;
+	}
+	/* A file system has been mounted. It will be unmounted at the
+	   end of this recipe, but it also has to be unmounted if -
+	   because of errors in one of next steps - the recipe will be
+	   terminated. From now on always attempt to unmount the file
+	   system in error handling code. */
+
+
+	usleep(CDW_CREATE_IMAGE_PAUSE);
+
+
+	cdw_logging_write("\n\nCreating UDF file: 4/6: attempting to copy (rsync) files into UDF file system:\n");
+	cdw_processwin_display_main_info("Copying files to UDF file system");
+	cdw_processwin_add_progress_bar();
+	crv = cdw_rsync_run_task(task);
+	if (crv != CDW_OK) {
+		cdw_logging_write("Creating UDF file: 4/6: attempting to copy (rsync) files into UDF file system FAILED.\n");
+		cdw_logging_write("Creating UDF file: 4/6: \"rsync\" exit status is %d.\n", task->tool_status.child_exit_status);
+
+		crv = cdw_umount_run_task(task);
+		if (crv != CDW_OK) {
+			cdw_logging_write("Creating UDF file: 4/6: failed to unmount mounted UDF file system.\n");
+		}
+
+		return CDW_ERROR;
+	}
+
+
+	usleep(CDW_CREATE_IMAGE_PAUSE);
+
+
+	cdw_logging_write("\n\nCreating UDF file: 5/6: syncing devices:\n");
+	cdw_processwin_display_main_info("Syncing...");
+	cdw_processwin_display_sub_info("This may take a while");
+	crv = cdw_sync_run_task(task);
+	if (crv != CDW_OK) {
+		cdw_logging_write("Creating UDF file: 5/6: syncing devices FAILED.\n");
+		cdw_logging_write("Creating UDF file: 5/6: \"sync\" exit status is %d.\n", task->tool_status.child_exit_status);
+
+		crv = cdw_umount_run_task(task);
+		if (crv != CDW_OK) {
+			cdw_logging_write("Creating UDF file: 5/6: failed to unmount mounted UDF file system.\n");
+		}
+		return CDW_ERROR;
+	}
+
+
+
+	/* Give "sync" command enough time to completely flush data
+	   into UDF file system. */
+	int sync_delay = CDW_CREATE_IMAGE_SYNC_DELAY;
+	/* Get number of digits in value of volume size. */
+	{
+		char *size_string = (char *) NULL;
+		int n = asprintf(&size_string, "%"PRIu64"", task->create_image.udf.volume_size_bytes);
+		if (n > 0) {
+			sync_delay += n;
+		} else {
+			/* A minimal effort to increase sync delay. */
+			sync_delay += 5;
+		}
+		cdw_string_delete(&size_string);
+	}
+	sleep((unsigned int) sync_delay);
+
+
+
+	cdw_processwin_delete_progress_bar();
+	cdw_processwin_wrefresh();
+
+	cdw_logging_write("\n\nCreating UDF file: 6/6: attempting to unmount UDF file system:\n");
+	cdw_processwin_display_main_info("Unmounting UDF filesystem");
+	cdw_processwin_display_sub_info("");
+	crv = cdw_umount_run_task(task);
+	if (crv != CDW_OK) {
+		cdw_logging_write("Creating UDF file: 6/6: attempting to unmount UDF file system FAILED.\n");
+		cdw_logging_write("Creating UDF file: 6/6: \"sudo umount\" exit status is %d.\n", task->tool_status.child_exit_status);
+		return CDW_ERROR;
+	}
+
+
+	usleep(CDW_CREATE_IMAGE_PAUSE);
+
+
+	return CDW_OK;
+}
diff -Naur orig/src/tasks/cdw_erase_disc.c patched/src/tasks/cdw_erase_disc.c
--- orig/src/tasks/cdw_erase_disc.c	2012-02-26 15:22:32.000000000 +0100
+++ patched/src/tasks/cdw_erase_disc.c	2014-03-22 17:58:19.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include "cdw_task.h"
@@ -72,10 +72,11 @@
 		return crv;
 	}
 
-	cdw_main_ui_disc_info_view_display_data(disc);
+	cdw_main_window_disc_info_view_display_data(disc);
 
 	/* check if the disc in drive is of proper type */
 	if (!cdw_erase_disc_is_proper(disc)) {
+		cdw_disc_delete(&disc);
 		return CDW_NO;
 	}
 
@@ -86,7 +87,7 @@
 		return CDW_ERROR;
 	}
 
-	/* the function will set task->blanking.format_mode for DVD-RW */
+	/* the function will set task->blanking.dvd_rw_format_mode for DVD-RW */
 	cdw_rv_t decision = cdw_erase_wizard(task, disc);
 
 	cdw_rv_t retval = CDW_OK;
@@ -104,7 +105,7 @@
 		retval = CDW_ERROR;
 	}
 	if (retval == CDW_OK) {
-		cdw_task_save(task);
+		cdw_task_save_options(task);
 	}
 	cdw_task_delete(&task);
 	cdw_disc_delete(&disc);
@@ -121,14 +122,14 @@
 
 cdw_rv_t cdw_erase_disc_perform_erase(cdw_task_t *task, cdw_disc_t *disc)
 {
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	if (task->erase.tool.id == CDW_TOOL_DVD_RW_FORMAT) {
 		if (disc->type == CDW_DVD_RW
 		    || disc->type == CDW_DVD_RW_SEQ
 		    || disc->type == CDW_DVD_RW_RES) {
 
-			cdw_assert (task->erase.format_mode != CDW_ERASE_DVD_RW_FORMAT_NONE,
+			cdw_assert (task->erase.dvd_rw_format_mode != CDW_ERASE_DVD_RW_FORMAT_NONE,
 				    "ERROR: correct format mode is not set!");
 		}
 	}
@@ -146,14 +147,14 @@
 	   and resets task->tool_status */
 	cdw_rv_t tool_status = cdw_task_check_tool_status(task);
 	const char *drive = cdw_drive_get_drive_fullpath();
-	cdw_drive_reload_tray_with_ui_update(drive, true);
+	cdw_drive_reload_tray_with_ui_update(drive, true, task->erase.eject);
 
 	/* after erasing disc kernel may print to console information
 	   about problems with reading data from empty disc, and this
 	   information will disrupt cdw ui (main window + processwin);
 	   reload_tray_with_ui_update() refreshes only disc info area,
 	   let's refresh main window + process window */
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 	cdw_processwin_force_refresh();
 
 	if (command_return == CDW_OK && tool_status == CDW_OK) {
@@ -285,3 +286,80 @@
 	}
 }
 
+
+
+
+
+void cdw_erase_init(cdw_erase_t *erase)
+{
+	erase->tool.id    = CDW_TOOL_NONE;
+	erase->tool.label = (char *) NULL;
+
+	return;
+}
+
+
+
+
+
+void cdw_erase_set_defaults(cdw_erase_t *erase)
+{
+	cdw_assert (erase, "ERROR: erase argument is NULL\n");
+
+	erase->erase_mode = CDW_ERASE_MODE_ALL;
+	erase->speed_id = 0;
+	erase->eject = false;  /* Keep consistent with cdw_write_t->eject. */
+	erase->dvd_rw_format_mode = CDW_ERASE_DVD_RW_FORMAT_NONE; /* it can stay as "NONE" when we use cdrecord for erasing */
+
+	erase->erase_time = 0;  /* Not a default value, more like an initialization. */
+
+	return;
+}
+
+
+
+
+void cdw_erase_copy(cdw_erase_t *dest, cdw_erase_t *src)
+{
+	cdw_assert (dest, "ERROR: dest argument is NULL\n");
+	cdw_assert (src, "ERROR: src argument is NULL\n");
+
+	dest->erase_mode         = src->erase_mode;
+	dest->speed_id           = src->speed_id;
+	dest->eject              = src->eject;
+	dest->dvd_rw_format_mode = src->dvd_rw_format_mode;
+
+	dest->tool.id    = src->tool.id;
+	dest->tool.label = src->tool.label;
+
+	dest->erase_time = src->erase_time;
+
+	return;
+
+}
+
+
+
+
+
+void cdw_erase_debug_print_options(cdw_erase_t *erase)
+{
+	cdw_assert (erase, "ERROR: erase argument is NULL\n");
+
+	cdw_vdm ("INFO: Erasing options:\n");
+
+	cdw_vdm ("INFO:                  erase mode = %s\n",   erase->erase_mode == CDW_ERASE_MODE_FAST ? "fast" : "all");
+	cdw_vdm ("INFO:                    speed id = %lld\n", erase->speed_id);
+	cdw_vdm ("INFO:                       eject = %s\n",   erase->eject ? "true" : "false");
+
+	cdw_vdm ("INFO:          DVD RW format mode = %s\n",
+		 erase->dvd_rw_format_mode == CDW_ERASE_DVD_RW_FORMAT_NONE ? "none" :
+		 erase->dvd_rw_format_mode == CDW_ERASE_DVD_RW_FORMAT_SEQ ? "seq" : "res");
+
+	cdw_vdm ("INFO:                     tool id = %lld / %s\n",  erase->tool.id, cdw_ext_tools_get_tool_name(erase->tool.id));
+	cdw_vdm ("INFO:                  tool label = %s\n",   erase->tool.label);
+
+	cdw_vdm ("INFO:                  erase time = %zd\n",  erase->erase_time);
+
+	return;
+}
diff -Naur orig/src/tasks/cdw_erase_disc.h patched/src/tasks/cdw_erase_disc.h
--- orig/src/tasks/cdw_erase_disc.h	2010-08-19 23:08:52.000000000 +0200
+++ patched/src/tasks/cdw_erase_disc.h	2014-03-15 13:29:58.000000000 +0100
@@ -14,7 +14,28 @@
 	CDW_ERASE_DVD_RW_FORMAT_RES
 };
 
+
+typedef struct {
+	/* "input" parameters of erasing */
+	cdw_id_t erase_mode;  /* Erasing disc: all or fast. */
+	cdw_id_t speed_id;
+	bool eject;
+	cdw_id_t dvd_rw_format_mode; /* Format of DVD-RW: Sequential or Restricted Overwrite. */
+
+	cdw_id_label_t tool;
+
+	/* "output" parameter of erasing (but only for CD-RW): if
+	   after attempting to perform erasing of CD-RW value of
+	   erase_time is still zero, then erasing failed */
+	size_t erase_time;
+} cdw_erase_t;
+
 cdw_rv_t cdw_erase_disc(void);
 
 
+void cdw_erase_init(cdw_erase_t *erase);
+void cdw_erase_copy(cdw_erase_t *dest, cdw_erase_t *src);
+void cdw_erase_set_defaults(cdw_erase_t *erase);
+void cdw_erase_debug_print_options(cdw_erase_t *erase);
+
 #endif /* H_CDW_ERASE_DISC */
diff -Naur orig/src/tasks/cdw_read_disc.c patched/src/tasks/cdw_read_disc.c
--- orig/src/tasks/cdw_read_disc.c	2012-03-25 13:26:43.000000000 +0200
+++ patched/src/tasks/cdw_read_disc.c	2014-03-16 22:27:08.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _GNU_SOURCE /* strndup */
@@ -117,7 +117,7 @@
 	cdw_disc_t *disc = cdw_disc_new();
 	cdw_rv_t crv = cdw_disc_get(disc);
 	if (crv != CDW_OK) {
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		cdw_disc_delete(&disc);
 		return crv;
 	}
@@ -142,7 +142,7 @@
 		crv = cdw_read_disc_read_data_disc_prepare(disc);
 	}
 	/* this refreshes UI after file picker and before processwin */
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	if (crv != CDW_OK) {
 		if (crv == CDW_ERROR) {
@@ -154,7 +154,7 @@
 					   _("Cannot open disc."),
 					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
 		}
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 
 		if (audio_file_name != (char *) NULL) {
 			free(audio_file_name);
@@ -176,27 +176,27 @@
 		free(audio_file_name);
 		audio_file_name = (char *) NULL;
 	} else {
-		crv = cdw_read_disc_read_data_track(disc, global_config.iso_image_full_path);
+		crv = cdw_read_disc_read_data_track(disc, global_config.general.image_fullpath);
 	}
 
 	cdw_disc_delete(&disc);
 
 	/* when cdw is run in login console and there are some disc read
 	   errors, OS prints some error messages to the console that
-	   overwrite cdw ui; call to cdw_main_ui_main_window_wrefresh()
+	   overwrite cdw ui; call to cdw_main_window_wrefresh()
 	   conveniently fixes it */
 	if (crv == CDW_OK) {
 		/* 2TRANS: this is message in dialog window: reading
 		   a disc is finished. I'm not adding "successfully",
 		   because this is not 100% sure. */
 		cdw_processwin_destroy(_("Finished."), true);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		return CDW_OK;
 	} else {
 		/* 2TRANS: this is message in dialog window: reading
 		   a disc is finished, but with errors */
 		cdw_processwin_destroy(_("Finished. Some errors occurred."), true);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		/* 2TRANS: this is title of dialog window */
 		cdw_buttons_dialog(_("Error"),
 				   /* 2TRANS: this is message in dialog window */
@@ -220,7 +220,7 @@
 					     _("Enter path to existing output directory"),
 					     &(global_config.audiodir),
 					     CDW_FS_DIR, R_OK|W_OK|X_OK, CDW_FS_EXISTING);
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 	if (crv != CDW_OK) {
 		/* user failed to provide correct path when
 		   asked X times, or pressed ESCAPE */
@@ -248,7 +248,7 @@
 						  /* 2TRANS: this is message in dialog window */
 						  _("You are attempting to read multi-track disc. cdw can't read second and following tracks, so only first track will be read. Continue?"),
 						  CDW_BUTTONS_OK_CANCEL, CDW_COLORS_WARNING);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		if (crv != CDW_OK) {
 			cdw_vdm ("INFO: returning after multi-track prompt\n");
 			return crv;
@@ -261,7 +261,7 @@
 					     /* 2TRANS: this is label in dialog
 						window below it is input field */
 					     _("Select new or existing image file"),
-					     &(global_config.iso_image_full_path),
+					     &(global_config.general.image_fullpath),
 					     CDW_FS_FILE, R_OK|W_OK,
 					     CDW_FS_NEW | CDW_FS_EXISTING);
 	if (crv != CDW_OK) {
@@ -322,7 +322,7 @@
 		   disrupt cdw UI; these lines refresh the UI; sleep time
 		   was selected by experimenting on my old 686 machine */
 		sleep(1);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		cdw_processwin_wrefresh();
 
 	} /* for */
@@ -358,7 +358,7 @@
 	   disrupt cdw UI; these lines refresh the UI; sleep time
 	   was selected by experimenting on my old 686 machine */
 	sleep(1);
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 	cdw_processwin_wrefresh();
 
 	if (retval != CDW_OK) {
@@ -490,7 +490,7 @@
 				   /* 2TRANS: this message in dialog window */
 				   _("Disc in drive is empty, can't read any data from the disc."),
 				   CDW_BUTTONS_OK, CDW_COLORS_DIALOG);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 
 		return false;
 	} else if (disc->state_empty == CDW_UNKNOWN) {
@@ -499,7 +499,7 @@
 						  /* 2TRANS: this message in dialog window */
 						  _("Disc in drive may be empty and reading from disc may fail. Continue?"),
 						  CDW_BUTTONS_OK_CANCEL, CDW_COLORS_DIALOG);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		if (crv != CDW_OK) {
 			return false;
 		}
@@ -513,7 +513,7 @@
 		cdw_buttons_dialog(_("Information"),
 				   message,
 				   CDW_BUTTONS_OK, CDW_COLORS_DIALOG);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		return false;
 	}
 
@@ -525,36 +525,25 @@
 
 char *cdw_read_disc_get_audio_file_name(void)
 {
+	char filename[CDW_READ_DICS_TRACK_CORE_NAME_LEN + 1];
 	/* 2TRANS: this is main part of name of audio tracks ripped from
-	   cd, no more than TRACK_CORE_NAME_LEN = 30 chars */
-	char *filename = strndup(_("track"), CDW_READ_DICS_TRACK_CORE_NAME_LEN);
-	if (filename == (char *) NULL) {
-		return (char *) NULL;
-	}
-
-	cdw_input_data_t data;
+	   CD, no more than TRACK_CORE_NAME_LEN = 30 chars */
+	strncpy(filename, _("track"), CDW_READ_DICS_TRACK_CORE_NAME_LEN);
+	filename[CDW_READ_DICS_TRACK_CORE_NAME_LEN] = '\0';
 
-	data.attempts_max = 3; /* how many attempts? */
 	/* 2TRANS: this is title of dialog window where user have to
-	   enter core of track file names */
-	data.window_title = _("File name");   /* title of input window and error dialogs */
-	/* 2TRANS: this is label in dialog window, below it is an input field */
-	data.prompt_message = _("Enter core of track file names (no more than 30 characters).");  /* message in input window */
-	data.input_type = CDW_NCURSES_INPUT_NONE;
-	data.chars_max = CDW_READ_DICS_TRACK_CORE_NAME_LEN;    /* maximal length of string */
-	data.buffer = &filename;
-	/* error message displayed at the end in case of failure */
-	/* 2TRANS: this is error message displayed in dialog window
-	   when getting a file name from user failed */
-	data.error_message = _("Can't get valid file name, aborting.");
-
-	cdw_rv_t crv = cdw_input_dialog(&data);
-	cdw_main_ui_main_window_wrefresh();
+	   enter core of track file names. */
+	cdw_rv_t crv = cdw_input_dialog(_("File name"),
+					/* 2TRANS: this is label in
+					   dialog window, below it is
+					   an input field */
+					_("Enter core of track file names (no more than 30 characters)."),
+					  CDW_READ_DICS_TRACK_CORE_NAME_LEN,
+					  filename);
+	cdw_main_window_wrefresh();
 	if (crv == CDW_OK) {
-		return filename;
+		return strdup(filename);
 	} else {
-		free(filename);
-		filename = (char *) NULL;
 		if (crv == CDW_CANCEL) {
 			;
 		} else {
diff -Naur orig/src/tasks/cdw_read_disc_info.c patched/src/tasks/cdw_read_disc_info.c
--- orig/src/tasks/cdw_read_disc_info.c	2012-02-19 22:18:18.000000000 +0100
+++ patched/src/tasks/cdw_read_disc_info.c	2014-03-13 22:17:39.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,214 +14,20 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <string.h>
 
-// #include "cdw_processwin.h"
 #include "cdw_read_disc_info.h"
 #include "cdw_disc.h"
 #include "cdw_window.h"
 #include "cdw_main_window.h"
 #include "cdw_widgets.h"
-// #include "cdw_drive.h"
-// #include "cdw_fs.h"
 #include "gettext.h"
 #include "cdw_debug.h"
 
 
-/* use to check if there is a disc in drive and if we can operate on it */
-//static bool cdw_disc_is_disc_ready(void);
-
-#if 0
-static bool using_local_processwin = false;
-
-
-
-/**
-   \brief Re-read and display optical disc information, show it in text window if required
-
-   Read meta-information form optical disc that is currently in drive
-   and display summary in 'Disc info' area of ui.
-
-   TODO: this function needs some review and improvement.
-
-   \return CDW_OK if media info was read properly
-   \return CDW_NO if media info was not read properly
-*/
-cdw_rv_t cdw_read_disc_info(void)
-{
-	const char *drive = cdw_drive_get_drive_fullpath();
-	if (drive == (char *) NULL) {
-		/* 2TRANS: this is title of dialog window */
-		cdw_buttons_dialog(_("Error"),
-				   /* 2TRANS: this is message in dialog window */
-				   _("Can't find any drives, please check your hardware."),
-				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-		return CDW_NO;
-	}
-
-	if (cdw_processwin_is_active()) {
-		using_local_processwin = false;
-	} else {
-		using_local_processwin = true;
-		/* 2TRANS: this is title of process window; reading
-		   disc meta information */
-		cdw_processwin_create(_("Read disc information"),
-				      /* 2TRANS: this is message in
-					 process window */
-				      _("Reading disc information"),
-				      false);
-	}
-
-	cdw_disc_t *disc = cdw_disc_get__();
-	cdw_main_ui_disc_info_view_display_data(disc);
-
-	cdw_rv_t retval = CDW_OK;
-	if (!cdw_drive_is_disc_in_drive()) {
-		cdw_vdm ("INFO: no disc in drive\n");
-		cdw_main_ui_disc_info_view_display_data(disc);
-		/* 2TRANS: this is title of dialog window */
-		cdw_buttons_dialog(_("Error"),
-				   /* 2TRANS: this is message in dialog window */
-				   _("Cannot show disc info. No disc in drive."),
-				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-		retval = CDW_NO;
-		goto cdw_read_disc_info_return;
-	}
-
-	drive = cdw_drive_get_drive_fullpath();
-	cdw_rv_t mounted = cdw_fs_check_device_mounted(drive);
-	if (mounted == CDW_ERROR) {
-		cdw_vdm ("WARNING: checking if disc is mounted ended with error\n");
-		/* let's try and proceed with further checks anyway */
-	} else if (mounted == CDW_OK) { /* device is mounted */
-		cdw_vdm ("INFO: optical disc is mounted\n");
-		/* 2TRANS: this is title of dialog window */
-		cdw_buttons_dialog(_("Error"),
-				   /* 2TRANS: this is message in dialog window */
-				   _("Cannot check media. Please unmount your drive."),
-				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-		retval = CDW_NO;
-		goto cdw_read_disc_info_return;
-	} else { /* mounted == CDW_NO, not mounted */
-		cdw_vdm ("INFO: disc is not mounted\n");
-	}
-
-
-	/* get_meta_info() may fail only partially; display what you can */
-	cdw_main_ui_disc_info_view_display_data(disc);
-	if (!disc->has_data) {
-		cdw_vdm ("ERROR: can't get disc meta info\n");
-		/* 2TRANS: this is title of dialog window */
-		cdw_buttons_dialog(_("Error"),
-				   /* 2TRANS: this is message in dialog window */
-				   _("Cannot get media info. Consult log file ('L' hotkey in main window)."),
-				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-		retval = CDW_NO;
-		goto cdw_read_disc_info_return;
-	} else { /* mediainfo == CDW_OK, we have proper media info */
-		cdw_vdm ("INFO: disc meta info read properly\n");
-	}
-
-
-	/* at this point everything ends well: disc is in drive, it
-	   is not mounted, we have read its meta information properly */
-	retval = CDW_OK;
-
-cdw_read_disc_info_return:
-	if (using_local_processwin) {
-		cdw_processwin_destroy("", false);
-	}
-	return retval;
-}
-
-#endif
-
-
-
-
-#if 0 /* unused */
-
-/**
-   \brief Check if disc is in drive and if it is unmounted
-
-   Check if disc is ready for further investigations and actions,
-   i.e. if it is in drive at all and if it is unmounted. This is
-   important when you want to read metadata from disc or when you
-   want to burn to disc or erase disc (perhaps read disc as well).
-
-   \return true when disc is ready, or when this is not certain, but user wants to continue
-   \return false when disc is not ready, or when disc is probably not ready, but user don't want to continue
-*/
-bool cdw_disc_is_disc_ready(void)
-{
-	/* this function only checks if there is media in drive */
-	if (!cdw_drive_is_disc_in_drive()) {
-		/* cdw_dialogbox() was called by the function to
-		   inform about problems */
-		// current_disc.disc_type = CDW_DISC_NONE;
-		// cdw_disc_resolve();
-		return false;
-	}
-
-	const char *drive = cdw_drive_get_drive_fullpath();
-	int tries = 5;
-	for (int i = 0; i < tries; i++) {
-		/* can't write to disc that is mounted */
-		cdw_rv_t crv = cdw_fs_check_device_mounted(drive);
-		if (crv == CDW_ERROR) {
-			/* 2TRANS: this is title of dialog window */
-			cdw_rv_t d = cdw_buttons_dialog(_("Error"),
-							/* 2TRANS: this is message in dialog
-							   window, user can select "OK" or
-							   "Cancel" button */
-							_("Cannot check if disc is unmounted. You should unmount your drive. Continue?"),
-							CDW_BUTTONS_OK_CANCEL, CDW_COLORS_ERROR);
-			if (d == CDW_OK) {
-				/* disc may be mounted, but user wants to try anyway */
-				return true;
-
-			} else {
-				/* disc may be mounted, and user don't want
-				   to try to continue */
-				return false;
-
-			}
-		} else if (crv == CDW_OK) { /* device is mounted */
-			if (i == tries - 1) {
-				/* 2TRANS: this is title of dialog window */
-				cdw_buttons_dialog(_("Error"),
-						   /* 2TRANS: this is message in dialog window: an
-						      operation cannot be executed, because optical
-						      disc is mounted in file system */
-						   _("Cannot continue with mounted drive."),
-						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-				return false;
-			}
-
-			/* 2TRANS: this is title of dialog window */
-			cdw_rv_t m = cdw_buttons_dialog(_("Error"),
-							/* 2TRANS: this is message in dialog window: an
-							   operation cannot be executed, because optical
-							   disc is mounted in file system */
-							_("Cannot continue. Please unmount your drive and press OK."),
-							CDW_BUTTONS_OK_CANCEL, CDW_COLORS_ERROR);
-			if (m == CDW_OK) {
-				; /* try again */
-			} else {
-				return false;
-			}
-		} else { /* crv == CDW_NO, not mounted */
-			return true;
-		}
-	}
-
-	return false;
-}
-#endif
-
 
 
 
@@ -236,7 +42,7 @@
 		crv = CDW_ERROR;
 	}
 
-	cdw_main_ui_disc_info_view_display_data(disc);
+	cdw_main_window_disc_info_view_display_data(disc);
 
 	int n_lines = 20;
 	int n_cols = 70;
@@ -250,7 +56,7 @@
 					_("Disc info"),
 					/* 2TRANS: this is message at the bottom of a window */
 					_("Press any key to close window"));
-	if (window == (WINDOW *) NULL) {
+	if (!window) {
 		cdw_vdm ("ERROR: can't create window\n");
 		return;
 	}
@@ -258,7 +64,7 @@
 					   n_lines - 2, n_cols - 2, 1, 1,
 					   CDW_COLORS_DIALOG,
 					   (char *) NULL, (char *) NULL);
-	if (subwindow == (WINDOW *) NULL) {
+	if (!subwindow) {
 		cdw_vdm ("ERROR: can't create window\n");
 		delwin(window);
 		window = (WINDOW *) NULL;
diff -Naur orig/src/tasks/cdw_task.c patched/src/tasks/cdw_task.c
--- orig/src/tasks/cdw_task.c	2012-03-30 19:05:15.000000000 +0200
+++ patched/src/tasks/cdw_task.c	2014-04-12 20:18:40.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdio.h>
@@ -31,10 +31,15 @@
 #include "cdw_utils.h"
 #include "cdw_main_window.h"
 #include "cdw_erase_disc.h"
+#include "cdw_iso9660.h"
+#include "cdw_udf.h"
+
 
 extern cdw_config_t global_config;
 
 
+
+
 static cdw_rv_t cdw_task_set_allowed_modes(cdw_task_t *task, cdw_disc_t *disc);
 static void     cdw_task_set_allowed_modes_message(cdw_id_t id);
 static void     cdw_task_set_allowed_disc_modes(cdw_task_t *task, cdw_disc_t *disc);
@@ -43,13 +48,12 @@
 static void     cdw_task_set_allowed_disc_modes_xorriso(cdw_task_t *task, cdw_disc_t *disc);
 
 static cdw_rv_t cdw_task_get_initial_options(cdw_task_t *task, cdw_disc_t *disc);
-static void     cdw_task_reset_state(cdw_task_t *task);
+static void     cdw_task_init(cdw_task_t *task);
+static void     cdw_task_set_defaults(cdw_task_t *task);
 static cdw_rv_t cdw_task_resolve_allowed_writing_modes(cdw_task_t *task, cdw_disc_t *disc);
-static cdw_rv_t cdw_task_select_tools_for_task(cdw_task_t *task, cdw_disc_t *disc);
 static bool     cdw_task_select_tool(cdw_task_t *task, cdw_disc_t *disc);
 
-//static cdw_id_t cdw_task_select_tool_family(cdw_task_t *task, cdw_disc_t *disc);
-//static bool cdw_task_select_tool_sub(cdw_task_t *task, cdw_id_t tool_family);
+static void cdw_task_init_tools(cdw_task_t *task);
 static void cdw_task_reset_tools(cdw_task_t *task);
 static const char *cdw_task_get_task_label(cdw_id_t taks_id);
 static void cdw_task_debug_print_tools(cdw_task_t *task);
@@ -62,59 +66,62 @@
 } session_mode_message_ids;
 
 
-/* can be called explicitly in some situations, but
-   when you create new task, you can use CDW_TASK_CREATE_TASK macro */
-void cdw_task_reset_state(cdw_task_t *task)
+
+
+/**
+   \brief Set pointers to default, initial values (NULL)
+
+   Call only for freshly malloc()ed cdw_task_t variable. This function
+   is used to ensure that no pointer in \p task points to garbage
+   memory area.
+
+   Call cdw_task_set_defaults() to set proper default values of
+   options.
+
+   \param task - task to initialize
+*/
+void cdw_task_init(cdw_task_t *task)
 {
-	task->id = CDW_TASK_NONE;
-	cdw_task_reset_tool_status(task);
+	task->image_file_fullpath = (char *) NULL;
 
-	task->burn.session_mode = CDW_SESSION_MODE_INIT;
-	task->burn.session_modes_n_labels = 0;
-	task->burn.disc_mode = CDW_DISC_MODE_INIT;
-	task->burn.disc_modes_n_labels = 0;
+	cdw_write_init(&task->burn);
 
-	task->burn.speed_id = 0;
-	task->burn.verify = false;
-	task->burn.dummy = false;
-	task->burn.eject = false;
+	cdw_erase_init(&task->erase);
 
-	task->burn.data_size_mb = 0.0;
+	cdw_iso9660_init(&task->create_image.iso9660);
+	cdw_udf_init(&task->create_image.udf);
+
+	task->calculate_digest.read_and_write = (void * (*)(void *)) NULL;
+
+	task->disc = (cdw_disc_t *) NULL;
+	cdw_task_init_tools(task);
+
+	return;
+}
 
-	task->burn.growisofs.other_growisofs_options = (char *) NULL;
 
-	task->burn.cdrecord.burnproof = true;
-	task->burn.cdrecord.pad = false;
-	task->burn.cdrecord.pad_size = 0;
-	task->burn.cdrecord.other_cdrecord_options = (char *) NULL;
 
-	task->burn.xorriso.other_xorriso_burn_options = (char *) NULL;
 
-	task->burn.iso9660_file_fullpath = (char *) NULL;
 
+/**
+   \brief Set values of options to default, hardwired values
+*/
+void cdw_task_set_defaults(cdw_task_t *task)
+{
+	task->id = CDW_TASK_NONE;
+	cdw_task_reset_tool_status(task);
+
+	cdw_write_set_defaults(&task->burn);
 
-	task->erase.speed_id = 0;
-	task->erase.erase_mode = CDW_ERASE_MODE_ALL;
-	task->erase.format_mode = CDW_ERASE_DVD_RW_FORMAT_NONE; /* it can stay as "NONE" when we use cdrecord for erasing */
-	task->erase.erase_time = 0;
-	task->erase.eject = false;
+	cdw_erase_set_defaults(&task->erase);
 
 	task->calculate_digest.file_size = 0;
 	task->calculate_digest.source_fd = -1;
 	task->calculate_digest.target_fd = -1;
-	task->calculate_digest.read_and_write = (void * (*)(void *)) NULL;
 
-	task->create_image.iso9660_file_fullpath = (char *) NULL;
-	task->create_image.volume_id[0] = '\0';
-	task->create_image.mkisofs.iso_level = 0;
-	task->create_image.mkisofs.root_dir = (char *) NULL;
-	task->create_image.mkisofs.other_mkisofs_options = (char *) NULL;
-	task->create_image.xorriso.other_xorriso_iso_options = (char *) NULL;
-	task->create_image.pad = true;
+	cdw_iso9660_set_defaults(&(task->create_image.iso9660));
 
-	task->disc = (cdw_disc_t *) NULL;
-
-	cdw_task_reset_tools(task);
+	cdw_udf_set_defaults(&(task->create_image.udf));
 
 	return;
 }
@@ -123,8 +130,11 @@
 
 
 
-
-void cdw_task_reset_tools(cdw_task_t *task)
+/*
+  Values assigned to the pointers are static strings defined in
+  cdw_ext_tools. Don't free() them.
+*/
+void cdw_task_init_tools(cdw_task_t *task)
 {
 	task->erase.tool.label = (char *) NULL;
 	task->erase.tool.id = CDW_TOOL_NONE;
@@ -141,16 +151,38 @@
 
 
 
+
+void cdw_task_reset_tools(cdw_task_t *task)
+{
+	cdw_task_init_tools(task);
+
+	return;
+}
+
+
+
+
+
 void cdw_task_reset_tool_status(cdw_task_t *task)
 {
 	task->tool_status.ok = true;
-	task->tool_status.mkisofs = CDW_TOOL_STATUS_OK;
-	task->tool_status.cdrecord = CDW_TOOL_STATUS_OK;
+
+	task->tool_status.mkisofs          = CDW_TOOL_STATUS_OK;
+	task->tool_status.cdrecord         = CDW_TOOL_STATUS_OK;
 	task->tool_status.calculate_digest = CDW_TOOL_STATUS_OK;
-	task->tool_status.growisofs = CDW_TOOL_STATUS_OK;
+	task->tool_status.growisofs        = CDW_TOOL_STATUS_OK;
 	task->tool_status.dvd_rw_mediainfo = CDW_TOOL_STATUS_OK;
-	task->tool_status.libcdio = CDW_TOOL_STATUS_OK;
-	task->tool_status.xorriso = CDW_TOOL_STATUS_OK;
+	task->tool_status.libcdio          = CDW_TOOL_STATUS_OK;
+	task->tool_status.xorriso          = CDW_TOOL_STATUS_OK;
+
+	task->tool_status.mkudffs_general  = CDW_TOOL_STATUS_OK;
+	task->tool_status.mkudffs          = CDW_TOOL_STATUS_OK;
+	task->tool_status.truncate         = CDW_TOOL_STATUS_OK;
+	task->tool_status.sudo             = CDW_TOOL_STATUS_OK;
+	task->tool_status.mount            = CDW_TOOL_STATUS_OK;
+	task->tool_status.umount           = CDW_TOOL_STATUS_OK;
+	task->tool_status.sync             = CDW_TOOL_STATUS_OK;
+	task->tool_status.rsync            = CDW_TOOL_STATUS_OK;
 
 	return;
 }
@@ -158,6 +190,7 @@
 
 
 
+
 /**
    \brief Check tool status field, display errors messages (if any)
 
@@ -176,13 +209,22 @@
 */
 cdw_rv_t cdw_task_check_tool_status(cdw_task_t *task)
 {
-	if (task->tool_status.mkisofs == CDW_TOOL_STATUS_OK
-	    && task->tool_status.cdrecord == CDW_TOOL_STATUS_OK
+	if (task->tool_status.mkisofs             == CDW_TOOL_STATUS_OK
+	    && task->tool_status.cdrecord         == CDW_TOOL_STATUS_OK
 	    && task->tool_status.calculate_digest == CDW_TOOL_STATUS_OK
-	    && task->tool_status.growisofs == CDW_TOOL_STATUS_OK
+	    && task->tool_status.growisofs        == CDW_TOOL_STATUS_OK
 	    && task->tool_status.dvd_rw_mediainfo == CDW_TOOL_STATUS_OK
-	    && task->tool_status.libcdio == CDW_TOOL_STATUS_OK
-	    && task->tool_status.xorriso == CDW_TOOL_STATUS_OK) {
+	    && task->tool_status.libcdio          == CDW_TOOL_STATUS_OK
+	    && task->tool_status.xorriso          == CDW_TOOL_STATUS_OK
+
+	    && task->tool_status.mkudffs_general == CDW_TOOL_STATUS_OK
+	    && task->tool_status.mkudffs  == CDW_TOOL_STATUS_OK
+	    && task->tool_status.truncate == CDW_TOOL_STATUS_OK
+	    && task->tool_status.sudo     == CDW_TOOL_STATUS_OK
+	    && task->tool_status.mount    == CDW_TOOL_STATUS_OK
+	    && task->tool_status.umount   == CDW_TOOL_STATUS_OK
+	    && task->tool_status.sync     == CDW_TOOL_STATUS_OK
+	    && task->tool_status.rsync    == CDW_TOOL_STATUS_OK) {
 
 		task->tool_status.ok = true;
 		cdw_sdm ("INFO: task->tool_status.ok = true\n");
@@ -355,7 +397,7 @@
 			   _("Can't create image: some file names are too long. Try toggling \"Long Joliet names\" checkbox in Configuration -> ISO filesystem."));
 	}
 
-	if ( (task->tool_status.mkisofs & CDW_TOOL_STATUS_MKISOFS_JOLIET_TREE_SORT)
+	if ((task->tool_status.mkisofs & CDW_TOOL_STATUS_MKISOFS_JOLIET_TREE_SORT)
 	     && (!(task->tool_status.mkisofs & CDW_TOOL_STATUS_MKISOFS_THE_SAME_JOLIET_NAME))) {
 		cdw_vdm ("ERROR: masked tool_status.mkisofs = 0x%08x / CDW_TOOL_STATUS_MKISOFS_JOLIET_TREE_SORT\n",
 			 (unsigned int) task->tool_status.mkisofs & CDW_TOOL_STATUS_MKISOFS_JOLIET_TREE_SORT);
@@ -408,7 +450,7 @@
 			 (unsigned int) task->tool_status.mkisofs & CDW_TOOL_STATUS_MKISOFS_INODE_NUMBER_OVERFLOW);
 		/* I'm not sure what this error means, probably some
 		   problems with links in filesystem */
-		if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_CREATE_IMAGE) {
+		if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
 			cdw_task_e((char *) NULL,
 				   /* 2TRANS: this is message in dialog window */
 				   _("mkisofs reports problems with selected files. Can't write these files. Try creating ISO image and then burn the image to optical disc."));
@@ -447,7 +489,7 @@
 			cdw_task_e((char *) NULL,
 				   /* 2TRANS: this is message in dialog window */
 				   _("mkisofs reported some problems when trying to append data to optical disc. Probably you can't append more data to the disc."));
-		} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		} else if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
 			cdw_task_e((char *) NULL,
 				   /* 2TRANS: this is message in dialog window */
 				   _("mkisofs reported some problems when trying to create ISO image, probably some files have very similar names or paths."));
@@ -462,7 +504,7 @@
 		cdw_vdm ("ERROR: masked tool_status.mkisofs = 0x%08x / CDW_TOOL_STATUS_MKISOFS_FILE_DID_GROW\n",
 			 (unsigned int) task->tool_status.mkisofs & CDW_TOOL_STATUS_MKISOFS_FILE_DID_GROW);
 
-		if (task->id == CDW_TASK_CREATE_IMAGE) {
+		if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
 			cdw_task_e((char *) NULL,
 				   /* 2TRANS: this is message in dialog window */
 				   _("mkisofs failed to create ISO image because one of selected files changed size. Check log file for details ('L' hotkey in main window).\n"));
@@ -517,6 +559,7 @@
 			   _("Action failed, you probably need to select \"xorriso\" in Configuration -> Tools to burn to this disc. Check log file for details ('L' hotkey in main window), search for \"Implementation botch\"."));
 	}
 
+
 	/* *** code working with md5sum *** */
 
 	if (task->tool_status.calculate_digest & CDW_TOOL_STATUS_CALCULATE_DIGEST_WRONG_TRACK) {
@@ -562,6 +605,61 @@
 			   _("Invalid option passed to xorriso. Check options in text fields in Configuration window, and under wizard's \"Other options\". See log file ('L' hotkey) for details."));
 	}
 
+
+
+	/* *** mkudffs and its helpers *** */
+
+	/* Segmentation fault of one of tools, probably mkduffs, but not 100% sure - it may have happened to any tool. */
+	if (task->tool_status.mkudffs_general & CDW_TOOL_STATUS_MKUDFFS_GENERAL_SEGMENTATION_FAULT) {
+		cdw_vdm ("ERROR: masked tool_status.mkudffs_general = 0x%08x / CDW_TOOL_STATUS_MKUDFFS_GENERAL_SEGMENTATION_FAULT\n",
+			 (unsigned int) task->tool_status.mkudffs_general & CDW_TOOL_STATUS_MKUDFFS_GENERAL_SEGMENTATION_FAULT);
+		cdw_task_e((char *) NULL,
+			   /* 2TRANS: this is message in dialog window */
+			   _("One of tools failed and reported segmentation fault when creating UDF image. See log file ('L' hotkey) for details."));
+	}
+
+	/* 'sudo mount' or 'sudo umount' asked for user password. */
+	if (task->tool_status.sudo & CDW_TOOL_STATUS_SUDO_PASSWORD_PROMPT) {
+		cdw_vdm ("ERROR: masked tool_status.sudo = 0x%08x / CDW_TOOL_STATUS_SUDO_PASSWORD_PROMPT\n",
+			 (unsigned int) task->tool_status.sudo & CDW_TOOL_STATUS_SUDO_PASSWORD_PROMPT);
+		cdw_task_e((char *) NULL,
+			   /* 2TRANS: this is message in dialog window */
+			   _("'sudo mount' or 'sudo umount' command has prompted me for user password. The command should be configured to work without asking for password. Consult Configuration -> UDF page for more information. See log file ('L' hotkey) for details."));
+	}
+
+	/* Failed to mount UDF file system under specified directory.
+	   Most probably problems with UDF file system in image
+	   file. */
+	if (task->tool_status.mount & CDW_TOOL_STATUS_MOUNT_FAILURE) {
+		cdw_vdm ("ERROR: masked tool_status.mount = 0x%08x / CDW_TOOL_STATUS_MOUNT_FAILURE\n",
+			 (unsigned int) task->tool_status.mount & CDW_TOOL_STATUS_MOUNT_FAILURE);
+		cdw_task_e((char *) NULL,
+			   /* 2TRANS: this is message in dialog window */
+			   _("It seems that UDF image file has not been mounted properly by cdw under mount directory specified in options. This most probably means that the UDF image has not been created correctly. See log file ('L' hotkey) for details."));
+	}
+
+	/* Trying to umount a directory that is not mounted. Most
+	   probably problems with creating UDF file system caused
+	   failure to mount, so there is nothing to umount. */
+	if (task->tool_status.umount & CDW_TOOL_STATUS_UMOUNT_NOT_MOUNTED) {
+		cdw_vdm ("ERROR: masked tool_status.umount = 0x%08x / CDW_TOOL_STATUS_UMOUNT_NOT_MOUNTED\n",
+			 (unsigned int) task->tool_status.umount & CDW_TOOL_STATUS_UMOUNT_NOT_MOUNTED);
+		cdw_task_e((char *) NULL,
+			   /* 2TRANS: this is message in dialog window */
+			   _("It seems that mount directory specified in options has not been mounted properly by cdw. This most probably means that the UDF image has not been created correctly. See log file ('L' hotkey) for details."));
+	}
+
+	/* rsync reports no space left on target device (file system).
+	   Size of selected file(s) is larger than size of target file
+	   system. */
+	if (task->tool_status.rsync & CDW_TOOL_STATUS_RSYNC_NO_SPACE_LEFT) {
+		cdw_vdm ("ERROR: masked tool_status.rsync = 0x%08x / CDW_TOOL_STATUS_RSYNC_NO_SPACE_LEFT\n",
+			 (unsigned int) task->tool_status.rsync & CDW_TOOL_STATUS_RSYNC_NO_SPACE_LEFT);
+		cdw_task_e((char *) NULL,
+			   /* 2TRANS: this is message in dialog window */
+			   _("Not enough space in UDF image, size of selected files is too large.\nVerify your options for creating UDF file, especially rsync options.\nVerify volume size specified in Configuration -> Log and misc -> Volume size.\nUDF image has not been created correctly. See log file ('L' hotkey) for details."));
+	}
+
 	return CDW_ERROR;
 }
 
@@ -615,9 +713,9 @@
 void cdw_task_e(const char *title, const char *message)
 {
 	/* 2TRANS: this is title of dialog window */
-	const char *local_title = (title == (char *) NULL) ? _("Error") : title;
+	const char *local_title = title ? title : _("Error");
 	cdw_buttons_dialog(local_title, message, CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	return;
 }
@@ -628,12 +726,11 @@
 
 cdw_rv_t cdw_task_resolve_allowed_writing_modes(cdw_task_t *task, cdw_disc_t *disc)
 {
-	int i = 0;
-	for (i = 0; i < CDW_SESSION_MODE_N_MAX; i++) {
+	for (int i = 0; i < CDW_SESSION_MODE_N_MAX; i++) {
 		task->burn.session_modes[i] = CDW_SESSION_MODE_INIT;
 	}
 	task->burn.session_modes_n_labels = 0;
-	for (i = 0; i < CDW_DISC_MODE_N_MODES; i++) {
+	for (int i = 0; i < CDW_DISC_MODE_N_MODES; i++) {
 		task->burn.disc_modes[i] = CDW_DISC_MODE_INIT;
 	}
 	task->burn.disc_modes_n_labels = 0;
@@ -641,11 +738,11 @@
 	cdw_rv_t crv = cdw_task_set_allowed_modes(task, disc);
 
 	if (crv == CDW_OK) {
-		for (i = 0; i < CDW_SESSION_MODE_N_MAX; i++) {
-			cdw_sdm ("resolved allowed_session_modes[%d] = %d\n", i, task->burn.allowed_session_modes[i]);
+		for (int i = 0; i < CDW_SESSION_MODE_N_MAX; i++) {
+			cdw_sdm ("INFO: resolved allowed_session_modes[%d] = %d\n", i, task->burn.allowed_session_modes[i]);
 		}
-		for (i = 0; i < CDW_DISC_MODE_N_MODES; i++) {
-			cdw_sdm ("resolved allowed_disc_modes[%d] = %d\n", i, task->burn.allowed_disc_modes[i]);
+		for (int i = 0; i < CDW_DISC_MODE_N_MODES; i++) {
+			cdw_sdm ("INFO: resolved allowed_disc_modes[%d] = %d\n", i, task->burn.allowed_disc_modes[i]);
 		}
 		return CDW_OK;
 
@@ -775,7 +872,7 @@
 				cdw_task_set_allowed_modes_message(IMAGE_TO_NONEMPTY);
 			}
 		} else if (disc->type == CDW_DVD_RP_DL
-			   && global_config.support_dvd_rp_dl) {
+			   && global_config.general.support_dvd_rp_dl) {
 
 			if (disc->state_empty == CDW_TRUE) {
 				task->burn.session_modes[0] = CDW_SESSION_MODE_CREATE_SINGLE;
@@ -1050,10 +1147,10 @@
 
 
 
+
+
 void cdw_task_set_allowed_modes_message(cdw_id_t id)
 {
-	/* 2TRANS: this is title of dialog window */
-	const char *title = _("Error");
 	char *message = (char *) NULL;
 
 	if (id == IMAGE_TO_NONEMPTY) {
@@ -1070,8 +1167,9 @@
 		return;
 	}
 
-	cdw_buttons_dialog(title, message, CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-	cdw_main_ui_main_window_wrefresh();
+	/* 2TRANS: this is title of dialog window */
+	cdw_buttons_dialog(_("Error"), message, CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	cdw_main_window_wrefresh();
 
 	return;
 }
@@ -1131,13 +1229,18 @@
 		}
 		return true;
 
-	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+	} else if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
+
 		success = cdw_ext_tools_set_iso9660_sa_tool(&(task->create_image.tool));
 		if (!success) {
 			return false;
 		}
 		return true;
 
+	} else if (task->id == CDW_TASK_CREATE_IMAGE_UDF) {
+		bool has_tool = cdw_ext_tools_set_udf_sa_tool(&(task->create_image.tool));
+		return has_tool;
+
 	} else if (task->id == CDW_TASK_MEDIA_INFO) {
 		success = cdw_ext_tools_set_media_info_tool(disc, &(task->media_info.tool));
 		if (!success) {
@@ -1208,10 +1311,11 @@
 	{ CDW_TASK_BURN_FROM_FILES,      "CDW_TASK_BURN_FROM_FILES" },
 	{ CDW_TASK_READ_DISC,            "CDW_TASK_READ_DISC" },
 	{ CDW_TASK_ERASE_DISC,           "CDW_TASK_ERASE_DISC" },
-	{ CDW_TASK_CLONE_DISC,           "CDW_TASK_CLONE_DISC" },
-	{ CDW_TASK_CREATE_IMAGE,         "CDW_TASK_CREATE_IMAGE" },
 	{ CDW_TASK_CALCULATE_DIGEST,     "CDW_TASK_CALCULATE_DIGEST" },
 	{ CDW_TASK_MEDIA_INFO,           "CDW_TASK_MEDIA_INFO" },
+	{ CDW_TASK_CREATE_IMAGE_ISO9660, "CDW_TASK_CREATE_IMAGE_ISO9660" },
+	{ CDW_TASK_CREATE_IMAGE_UDF,     "CDW_TASK_CREATE_IMAGE_UDF" },
+
 	{ 0,                             (char *) NULL }};
 
 
@@ -1226,25 +1330,26 @@
 	cdw_assert (task->id != CDW_TASK_NONE, "ERROR: selecting tool: task id == NONE\n");
 	if (task->id == CDW_TASK_BURN_FROM_IMAGE) {
 		cdw_vdm ("INFO: selecting tool: %s, burning tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->burn.tool.label);
-		cdw_vdm ("INFO: selecting tool: %s, md5sum tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->calculate_digest.tool.label);
+		cdw_vdm ("INFO: selecting tool: %s, digest tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->calculate_digest.tool.label);
 	} else if (task->id == CDW_TASK_BURN_FROM_FILES) {
 		cdw_vdm ("INFO: selecting tool: %s, burning tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->burn.tool.label);
-		cdw_vdm ("INFO: selecting tool: %s, iso fs tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->create_image.tool.label);
+		cdw_vdm ("INFO: selecting tool: %s, \"create image\" tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->create_image.tool.label);
 	} else if (task->id == CDW_TASK_READ_DISC) {
 		cdw_vdm ("INFO: selecting tool: %s, no info about read tool\n", cdw_task_get_task_label(task->id));
 	} else if (task->id == CDW_TASK_ERASE_DISC) {
 		cdw_vdm ("INFO: selecting tool: %s, erase tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->erase.tool.label);
-	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
-		cdw_vdm ("INFO: selecting tool: %s, iso fs tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->create_image.tool.label);
+	} else if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
+		cdw_vdm ("INFO: selecting tool: %s, \"create image\" tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->create_image.tool.label);
+	} else if (task->id == CDW_TASK_CREATE_IMAGE_UDF) {
+		cdw_vdm ("INFO: selecting tool: %s, \"create image\" tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->create_image.tool.label);
 	} else if (task->id == CDW_TASK_CALCULATE_DIGEST) {
 		cdw_vdm ("INFO: selecting tool: %s, digest tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->calculate_digest.tool.label);
 	} else if (task->id == CDW_TASK_MEDIA_INFO) {
-		cdw_vdm ("INFO: selecting tool: %s, mediainfo tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->media_info.tool.label);
+		cdw_vdm ("INFO: selecting tool: %s, \"media info\" tool is \"%s\"\n", cdw_task_get_task_label(task->id), task->media_info.tool.label);
 	} else {
 		/* it may be "clone" task, but it is not supported for now */
 		cdw_assert (0, "ERROR: unknown task id %lld\n", task->id);
 	}
-	cdw_vdm ("INFO: selecting tool: ----------------------------------\n");
 
 	return;
 }
@@ -1252,84 +1357,78 @@
 
 
 
+/**
+   Get initial values of fields in \p task from global configuration variable
 
+   \param task
+   \param disc
+
+   \return CDW_OK
+*/
 cdw_rv_t cdw_task_get_initial_options(cdw_task_t *task, cdw_disc_t *disc)
 {
-	if (task->id == CDW_TASK_CREATE_IMAGE
-	    || task->id == CDW_TASK_BURN_FROM_FILES) {
+	/* General. */
+	/* NOPE. Task type may be selected in main window, but it's
+	   not an option configurable in any options/configuration
+	   window.
+	task->id = global_config.task_id;
+	*/
+	cdw_string_set(&(task->image_file_fullpath), global_config.general.image_fullpath);
 
-		task->create_image.joliet_information = global_config.joliet;
-		task->create_image.follow_symlinks = global_config.follow_symlinks;
-		task->create_image.rock_ridge = global_config.rock_ridge;
-		task->create_image.pad = true;
-
-		strncpy(task->create_image.volume_id, global_config.volume_id, CDW_ISO9660_VOLI_LEN);
-		task->create_image.volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
-		strncpy(task->create_image.volume_set_id, global_config.volume_set_id, CDW_ISO9660_VOLS_LEN);
-		task->create_image.volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
-		strncpy(task->create_image.preparer, global_config.preparer, CDW_ISO9660_PREP_LEN);
-		task->create_image.preparer[CDW_ISO9660_PREP_LEN] = '\0';
-		strncpy(task->create_image.publisher, global_config.publisher, CDW_ISO9660_PUBL_LEN);
-		task->create_image.publisher[CDW_ISO9660_PUBL_LEN] = '\0';
-		strncpy(task->create_image.system_id, global_config.system_id, CDW_ISO9660_SYSI_LEN);
-		task->create_image.system_id[CDW_ISO9660_SYSI_LEN] = '\0';
-		strncpy(task->create_image.copyright, global_config.copyright, CDW_ISO9660_COPY_LEN);
-		task->create_image.copyright[CDW_ISO9660_COPY_LEN] = '\0';
-		strncpy(task->create_image.abstract, global_config.abstract, CDW_ISO9660_ABST_LEN);
-		task->create_image.abstract[CDW_ISO9660_ABST_LEN] = '\0';
-
-		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-			task->create_image.mkisofs.joliet_long = global_config.joliet_long;
-			task->create_image.mkisofs.iso_level = global_config.iso_level;
-			cdw_string_set(&(task->create_image.mkisofs.root_dir), global_config.mkisofs_root_dir);
-			cdw_string_set(&(task->create_image.mkisofs.other_mkisofs_options), global_config.other_mkisofs_options);
-		} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
-			cdw_string_set(&(task->create_image.xorriso.other_xorriso_iso_options), global_config.other_xorriso_iso_options);
-		} else {
-			cdw_assert(0, "ERROR: unknown tool %lld for task \"create image\"\n", task->create_image.tool.id);
-		}
-	}
-
-	if (task->id == CDW_TASK_BURN_FROM_IMAGE) {
-		cdw_string_set(&(task->burn.iso9660_file_fullpath), global_config.iso_image_full_path);
-	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
-		cdw_string_set(&(task->create_image.iso9660_file_fullpath), global_config.iso_image_full_path);
-	} else {
-		;
-	}
 
+	/* Write. */
 	if (task->id == CDW_TASK_BURN_FROM_FILES
 	    || task->id == CDW_TASK_BURN_FROM_IMAGE) {
 
-		task->burn.eject = global_config.eject;
-		task->burn.verify = true;
-		task->burn.dummy = false;
+		/* This 'if ()' is only because of call to cdw_disc
+		   function. We don't want to attempt the call for any
+		   other task. */
+
+		cdw_write_copy(&task->burn, &global_config.burn);
+
+		/* This one field depends on 'disc' because the latest
+		   value of disc data is in 'disc', not in global
+		   config. The disc should be valid at this point,
+		   otherwise the cdw_task_get_initial_options()
+		   wouldn't have been called. */
 		task->burn.speed_id = cdw_disc_get_initial_write_speed_id(disc);
-
-		if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
-			cdw_string_set(&(task->burn.growisofs.other_growisofs_options), global_config.other_growisofs_options);
-		} else if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
-			task->burn.cdrecord.burnproof = global_config.burnproof;
-			task->burn.cdrecord.pad = global_config.write_pad;
-			task->burn.cdrecord.pad_size = global_config.write_pad_size;
-			cdw_string_set(&(task->burn.cdrecord.other_cdrecord_options), global_config.other_cdrecord_options);
-		} else if (task->burn.tool.id == CDW_TOOL_XORRISO) {
-			cdw_string_set(&(task->burn.xorriso.other_xorriso_burn_options), global_config.other_xorriso_burn_options);
-		} else {
-			;
-		}
 	}
 
+
+	/* Erase. */
 	if (task->id == CDW_TASK_ERASE_DISC) {
-		task->erase.eject = global_config.eject;
-		task->erase.erase_mode = global_config.erase_mode;
-		task->erase.format_mode = CDW_ERASE_DVD_RW_FORMAT_NONE;
+
+		/* This 'if ()' is only because of call to cdw_disc
+		   function. We don't want to attempt the call for any
+		   other task. */
+
+		cdw_erase_copy(&task->erase, &global_config.erase);
+		/* get_initial_write_speed_id() === get_initial_erase_speed_id() */
 		task->erase.speed_id = cdw_disc_get_initial_write_speed_id(disc);
-	} else {
-		;
 	}
 
 
+	/* Create image. */
+	/* Execute these two functions unconditionally. In
+	   cdw_create_image before creating wizard (which uses task)
+	   we don't know which format will be selected in the wizard,
+	   so we need options for both formats copied into task. */
+	cdw_udf_copy(&(task->create_image.udf), &(global_config.udf));
+	cdw_iso9660_copy(&(task->create_image.iso9660), &(global_config.iso9660));
+
+
+	/* Media info. */
+	/* Not yet (Never?). */
+
+
+	/* Calculate digest. */
+	/* Not yet. */
+
+
+	/* Disc. */
+	/* NOPE. Disc meta-data is not a part of user-configurable options set. */
+
+
 	return CDW_OK;
 }
 
@@ -1340,28 +1439,37 @@
 cdw_task_t *cdw_task_new(cdw_id_t id, cdw_disc_t *disc)
 {
 	cdw_task_t *task = (cdw_task_t *) malloc(sizeof (cdw_task_t));
-	if (task == (cdw_task_t *) NULL) {
+	if (!task) {
 		cdw_vdm ("ERROR: failed to malloc memory for task\n");
 		return (cdw_task_t *) NULL;
 	}
 
-	cdw_task_reset_state(task);
+	cdw_task_init(task);
+	cdw_task_set_defaults(task);
+
+	/* Be careful where you put this assignment. set_defaults()
+	   overwrites id value it with NONE. */
 	task->id = id;
 
-	cdw_rv_t crv = cdw_task_select_tools_for_task(task, disc);
+	cdw_rv_t crv = cdw_task_get_initial_options(task, disc);
 	if (crv != CDW_OK) {
-		cdw_vdm ("ERROR: failed to select tools for task\n");
+		cdw_vdm ("ERROR: failed to get options for task\n");
 		cdw_task_delete(&task);
 		return (cdw_task_t *) NULL;
 	}
 
-	crv = cdw_task_get_initial_options(task, disc);
+	/* Task ID may be reset when reading value from
+	   global_config in cdw_task_get_initial_options(). */
+	task->id = id;
+
+	crv = cdw_task_select_tools_for_task(task, disc);
 	if (crv != CDW_OK) {
-		cdw_vdm ("ERROR: failed to get options for task\n");
+		cdw_vdm ("ERROR: failed to select tools for task\n");
 		cdw_task_delete(&task);
 		return (cdw_task_t *) NULL;
 	}
 
+
 	if (task->id == CDW_TASK_BURN_FROM_FILES
 	    || task->id == CDW_TASK_BURN_FROM_IMAGE) {
 
@@ -1392,55 +1500,18 @@
 {
 	cdw_assert (task, "ERROR: passing pointer to NULL task to the function\n");
 
-	if (*task == (cdw_task_t *) NULL) {
+	if (!(*task)) {
 		cdw_vdm ("WARNING passing NULL pointer to task\n");
 		return;
 	}
 
-	if ((*task)->id == CDW_TASK_BURN_FROM_FILES
-	    || (*task)->id == CDW_TASK_BURN_FROM_IMAGE) {
 
-		if ((*task)->burn.tool.id == CDW_TOOL_CDRECORD) {
+	cdw_string_delete(&(*task)->image_file_fullpath);
 
-		} else if ((*task)->burn.tool.id == CDW_TOOL_GROWISOFS) {
-			if ((*task)->burn.growisofs.other_growisofs_options != (char *) NULL) {
-				free((*task)->burn.growisofs.other_growisofs_options);
-				(*task)->burn.growisofs.other_growisofs_options = (char *) NULL;
-			}
-		} else {
-			;
-		}
-		if ((*task)->id == CDW_TASK_BURN_FROM_IMAGE) {
-			if ((*task)->burn.iso9660_file_fullpath != (char *) NULL) {
-				free((*task)->burn.iso9660_file_fullpath);
-				(*task)->burn.iso9660_file_fullpath = (char *) NULL;
-			}
-		}
-	} else if ((*task)->id == CDW_TASK_CREATE_IMAGE) {
-		if ((*task)->create_image.tool.id == CDW_TOOL_MKISOFS) {
-			if ((*task)->create_image.mkisofs.root_dir != (char *) NULL) {
-				free((*task)->create_image.mkisofs.root_dir);
-				(*task)->create_image.mkisofs.root_dir = (char *) NULL;
-			}
-			if ((*task)->create_image.mkisofs.other_mkisofs_options != (char *) NULL) {
-				free((*task)->create_image.mkisofs.other_mkisofs_options);
-				(*task)->create_image.mkisofs.other_mkisofs_options = (char *) NULL;
-			}
-		} else if ((*task)->create_image.tool.id == CDW_TOOL_XORRISO) {
-			if ((*task)->create_image.xorriso.other_xorriso_iso_options != (char *) NULL) {
-				free((*task)->create_image.xorriso.other_xorriso_iso_options);
-				(*task)->create_image.xorriso.other_xorriso_iso_options = (char *) NULL;
-			}
-		} else {
-			;
-		}
-		if ((*task)->create_image.iso9660_file_fullpath != (char *) NULL) {
-			free((*task)->create_image.iso9660_file_fullpath);
-			(*task)->create_image.iso9660_file_fullpath = (char *) NULL;
-		}
-	} else {
-		;
-	}
+	cdw_write_clean(&((*task)->burn));
+
+	cdw_iso9660_clean(&((*task)->create_image.iso9660));
+	cdw_udf_clean(&((*task)->create_image.udf));
 
 	free(*task);
 	*task = (cdw_task_t *) NULL;
@@ -1452,330 +1523,133 @@
 
 
 
-void cdw_task_save(cdw_task_t *task)
+cdw_rv_t cdw_task_copy(cdw_task_t *target, cdw_task_t *source)
 {
-	if (task == (cdw_task_t *) NULL) {
-		cdw_vdm ("ERROR: task is NULL\n");
-		return;
-	}
+	cdw_assert (source->id == CDW_TASK_CREATE_IMAGE_ISO9660
+		    || source->id == CDW_TASK_CREATE_IMAGE_UDF
+		    || source->id == CDW_TASK_BURN_FROM_FILES
+		    || source->id == CDW_TASK_BURN_FROM_IMAGE,
 
+		    "ERROR: the function does not support task %s / %lld yet\n",
+		    cdw_task_get_task_label(source->id), source->id);
 
 
-	if (task->id == CDW_TASK_ERASE_DISC) {
-		global_config.eject = task->erase.eject;
-		global_config.erase_mode = task->erase.erase_mode;
+	target->id = source->id;
 
-	} else if (task->id == CDW_TASK_BURN_FROM_FILES
-		   || task->id == CDW_TASK_BURN_FROM_IMAGE) {
-		global_config.eject = task->burn.eject;
-	} else {
-		;
-	}
-
-	if (task->id == CDW_TASK_BURN_FROM_IMAGE) {
-		cdw_string_set(&(global_config.iso_image_full_path), task->burn.iso9660_file_fullpath);
-	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
-		cdw_string_set(&(global_config.iso_image_full_path), task->create_image.iso9660_file_fullpath);
-	} else {
-		;
-	}
-
-	if (task->id == CDW_TASK_CREATE_IMAGE
-	    || task->id == CDW_TASK_BURN_FROM_FILES) {
+	cdw_string_set(&(target->image_file_fullpath), source->image_file_fullpath);
 
+	/* Tool status. */
+	{
 
-		global_config.follow_symlinks = task->create_image.follow_symlinks;
+	}
 
-		strncpy(global_config.volume_id, task->create_image.volume_id, CDW_ISO9660_VOLI_LEN);
-		global_config.volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
-		strncpy(global_config.volume_set_id, task->create_image.volume_set_id, CDW_ISO9660_VOLS_LEN);
-		global_config.volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
-		strncpy(global_config.preparer, task->create_image.preparer, CDW_ISO9660_PREP_LEN);
-		global_config.preparer[CDW_ISO9660_PREP_LEN] = '\0';
-		strncpy(global_config.publisher, task->create_image.publisher, CDW_ISO9660_PUBL_LEN);
-		global_config.publisher[CDW_ISO9660_PUBL_LEN] = '\0';
-		strncpy(global_config.system_id, task->create_image.system_id, CDW_ISO9660_SYSI_LEN);
-		global_config.system_id[CDW_ISO9660_SYSI_LEN] = '\0';
-		strncpy(global_config.copyright, task->create_image.copyright, CDW_ISO9660_COPY_LEN);
-		global_config.copyright[CDW_ISO9660_COPY_LEN] = '\0';
-		strncpy(global_config.abstract, task->create_image.abstract, CDW_ISO9660_ABST_LEN);
-		global_config.abstract[CDW_ISO9660_ABST_LEN] = '\0';
-
-		global_config.rock_ridge = task->create_image.rock_ridge;
-
-		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-			global_config.joliet_long = task->create_image.mkisofs.joliet_long;
-			global_config.iso_level = task->create_image.mkisofs.iso_level;
-			cdw_string_set(&(global_config.mkisofs_root_dir), task->create_image.mkisofs.root_dir);
-
-			cdw_string_set(&(global_config.other_mkisofs_options), task->create_image.mkisofs.other_mkisofs_options);
-		} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
-			cdw_string_set(&(global_config.other_xorriso_iso_options), task->create_image.xorriso.other_xorriso_iso_options);
-		} else {
-			;
-		}
+	/* Write. */
+	{
+		cdw_write_copy(&target->burn, &source->burn);
 	}
 
-	if (task->id == CDW_TASK_BURN_FROM_FILES
-	    || task->id == CDW_TASK_BURN_FROM_IMAGE) {
-
-		if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
-			global_config.write_pad = task->burn.cdrecord.pad;
-			global_config.write_pad_size = task->burn.cdrecord.pad_size;
-			global_config.burnproof = task->burn.cdrecord.burnproof;
-			cdw_string_set(&(global_config.other_cdrecord_options), task->burn.cdrecord.other_cdrecord_options);
-		} else if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
-			cdw_string_set(&(global_config.other_growisofs_options), task->burn.growisofs.other_growisofs_options);
-		} else if (task->burn.tool.id == CDW_TOOL_XORRISO) {
-			cdw_string_set(&(global_config.other_xorriso_burn_options), task->burn.xorriso.other_xorriso_burn_options);
-		} else {
-			;
-		}
+	/* Erase. */
+	{
+		cdw_erase_copy(&target->erase, &source->erase);
 
 	}
 
-	return;
-}
+	/* Create image. */
+	{
+		target->create_image.tool.id = source->create_image.tool.id;
+		/* DON'T COPY STRINGS, copy pointers. These pointers
+		   refer to permanent (but not static) strings in
+		   cdw_ext_tools module. Using strdup() or
+		   cw_string_set() will overwrite the strings in
+		   cdw_ext_tools module, and will cause a big mess. */
+		target->create_image.tool.label = source->create_image.tool.label;
 
 
+		cdw_iso9660_copy(&(target->create_image.iso9660), &(source->create_image.iso9660));
 
+		cdw_udf_copy(&(target->create_image.udf), &(source->create_image.udf));
+	}
 
+	/* Media info. */
+	{
 
-void cdw_task_debug_print_burn_options(cdw_task_t *task)
-{
-	cdw_vdm ("INFO:            session mode = \"%s\"\n", cdw_task_get_session_mode_label(task->burn.session_mode));
-	cdw_vdm ("INFO:               disc mode = \"%s\"\n", cdw_task_get_disc_mode_label(task->burn.disc_mode));
-	cdw_vdm ("INFO:                   speed = \"%lld\"\n", task->burn.speed_id);
-	cdw_vdm ("INFO:          verify burning = \"%s\"\n", task->burn.verify ? "true" : "false");
-	cdw_vdm ("INFO:              dummy burn = \"%s\"\n", task->burn.dummy ? "true" : "false");
-	cdw_vdm ("INFO:       eject after write = \"%s\"\n", task->burn.eject ? "true" : "false");
+	}
+
+	/* Calculate digest. */
+	{
 
-	if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
-		cdw_vdm ("INFO: other growisofs options = \"%s\"\n", task->burn.growisofs.other_growisofs_options);
-	} else if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
-		cdw_vdm ("INFO:               burnproof = \"%s\"\n", task->burn.cdrecord.burnproof ? "true" : "false");
-		cdw_vdm ("INFO:                     pad = \"%s\"\n", task->burn.cdrecord.pad ? "true" : "false");
-		cdw_vdm ("INFO:                pad size = \"%d\"\n", task->burn.cdrecord.pad_size);
-		cdw_vdm ("INFO:  other cdrecord options = \"%s\"\n", task->burn.cdrecord.other_cdrecord_options);
-	} else if (task->burn.tool.id == CDW_TOOL_XORRISO) {
-		cdw_vdm ("INFO:   other xorriso options = \"%s\"\n", task->burn.xorriso.other_xorriso_burn_options);
-	} else {
-		cdw_vdm ("ERROR: unknown burn tool %lld\n", task->burn.tool.id);
 	}
 
-	if (task->id == CDW_TASK_BURN_FROM_IMAGE) {
-		cdw_vdm ("INFO:             ISO9660 file = \"%s\"\n", task->burn.iso9660_file_fullpath);
+	/* Disc data structure. */
+	{
+
 	}
 
-	return;
+	return CDW_OK;
 }
 
 
 
 
 
-void cdw_task_debug_print_iso9660_options(cdw_task_t *task)
-{
-	if (task->id == CDW_TASK_BURN_FROM_FILES
-	    || task->id == CDW_TASK_CREATE_IMAGE) {
-		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-			cdw_vdm ("INFO:               joliet long = \"%s\"\n", task->create_image.mkisofs.joliet_long ? "true" : "false");
-			cdw_vdm ("INFO:                 iso level = \"%lld\"\n", task->create_image.mkisofs.iso_level);
-			cdw_vdm ("INFO:                  root dir = \"%s\"\n", task->create_image.mkisofs.root_dir);
-			cdw_vdm ("INFO:     other mkisofs options = \"%s\"\n", task->create_image.mkisofs.other_mkisofs_options);
-		} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
-			cdw_vdm ("INFO: other xorriso ISO options = \"%s\"\n", task->create_image.xorriso.other_xorriso_iso_options);
-		} else {
-			cdw_vdm ("ERROR: unknown ISO9660 tool %lld\n", task->create_image.tool.id);
-		}
+/**
+   \brief Save user-modifiable options
 
-		cdw_vdm ("INFO:                    joliet = \"%s\"\n", task->create_image.joliet_information ? "true" : "false");
-		cdw_vdm ("INFO:           follow symlinks = \"%s\"\n", task->create_image.follow_symlinks ? "true" : "false");
-		cdw_vdm ("INFO:                       pad = \"%s\"\n", task->create_image.pad ? "true" : "false");
-		cdw_vdm ("INFO:                rock ridge = %lld\n", task->create_image.rock_ridge);
-
-		cdw_vdm ("INFO:                 volume ID = \"%s\"\n", task->create_image.volume_id);
-		cdw_vdm ("INFO:             volume set ID = \"%s\"\n", task->create_image.volume_set_id);
-		cdw_vdm ("INFO:                  preparer = \"%s\"\n", task->create_image.preparer);
-		cdw_vdm ("INFO:                 publisher = \"%s\"\n", task->create_image.publisher);
-		cdw_vdm ("INFO:                 system id = \"%s\"\n", task->create_image.system_id);
-		cdw_vdm ("INFO:                 copyright = \"%s\"\n", task->create_image.copyright);
-		cdw_vdm ("INFO:                  abstract = \"%s\"\n", task->create_image.abstract);
+   Save task options into global config variable.
+   Options set exclusively by code, like disc meta-data, are not saved.
 
-		if (task->id == CDW_TASK_CREATE_IMAGE) {
-			cdw_vdm ("INFO:              ISO9660 file = \"%s\"\n", task->create_image.iso9660_file_fullpath);
-		}
-	} else if (task->id == CDW_TASK_BURN_FROM_IMAGE) {
-		;
-	} else {
-		cdw_vdm ("ERROR: incorrect task id %lld\n", task->id);
+   \p task - variable holding options that should be saved
+*/
+void cdw_task_save_options(cdw_task_t *task)
+{
+	if (!task) {
+		cdw_vdm ("ERROR: task is NULL\n");
+		return;
 	}
 
-	return;
-}
 
+	/* General. */
+	global_config.task_id = task->id;
+	cdw_string_set(&(global_config.general.image_fullpath), task->image_file_fullpath);
 
 
+	/* Write */
+	cdw_write_copy(&global_config.burn, &task->burn);
 
-/* unused code below */
 
-#if 0
+	/* Erase. */
+	cdw_erase_copy(&global_config.erase, &task->erase);
 
 
-cdw_id_t cdw_task_select_tool_family(cdw_task_t *task, cdw_disc_t *disc)
-{
-	cdw_id_t tool_family = CDW_TOOL_NONE;
-	if (task->id == CDW_TASK_MEDIA_INFO
-	    || task->id == CDW_TASK_BURN_FROM_IMAGE
-	    || task->id == CDW_TASK_BURN_FROM_FILES
-	    || task->id == CDW_TASK_ERASE_DISC) {
-
-		/* note on cdw_ext_tools_config_get_X_family(): if manual
-		   selection is in effect, these two functions simply take
-		   value selected in "tool family" menu in configuration panel;
-		   if "intelligent" selection is in effect, returned values
-		   are selected with some intelligent method */
-		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
-			tool_family = cdw_ext_tools_config_get_cd_handler_id();
-			if (tool_family == CDW_TOOL_NONE) {
-				cdw_task_e((char *) NULL,
-					   /* 2TRANS: this is message in dialog window;
-					      "tools" means "cdrecord", "growisofs" etc. */
-					   _("cdw can't find in your system any tools for handling CD discs. Current action can't be performed."));
-			}
-			cdw_assert (tool_family == CDW_TOOL_CDRECORD, "ERROR: tool family for CD is not cdrecord\n");
+	/* Create image. */
+	cdw_udf_copy(&(global_config.udf), &(task->create_image.udf));
+	cdw_iso9660_copy(&(global_config.iso9660), &(task->create_image.iso9660));
 
-		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
-			tool_family = cdw_ext_tools_config_get_dvd_handler_id();
-			if (tool_family == CDW_TOOL_NONE) {
-				cdw_task_e((char *) NULL,
-					   /* 2TRANS: this is message in dialog window;
-					      "tools" means "cdrecord", "growisofs" etc. */
-					   _("cdw can't find in your system any tools for handling DVD discs. Current action can't be performed."));
-			}
-			cdw_assert (tool_family == CDW_TOOL_CDRECORD || tool_family == CDW_TOOL_GROWISOFS,
-				    "ERROR: tool family for DVD is neither cdrecord nor growisofs\n");
-		} else {
-			cdw_assert (0, "ERROR: incorrect disc simple type %d\n", disc->simple_type);
-		}
-	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
-		tool_family = cdw_ext_tools_config_get_iso9660_id();
-		if (tool_family == CDW_TOOL_NONE) {
-			cdw_task_e((char *) NULL,
-				   /* 2TRANS: this is message in dialog window;
-				      "tools" means "mkisofs", "xorriso" etc. */
-				   _("cdw can't find in your system any tools for creating ISO9660 files. Current action can't be performed."));
-		}
-		cdw_assert (tool_family == CDW_TOOL_MKISOFS || tool_family == CDW_TOOL_XORRISO,
-			    "ERROR: too family for creating ISO9660 is invalid: %ld\n", tool_family);
-	} else {
-		;
-	}
-	return tool_family;
+	return;
 }
 
 
 
 
 
-bool cdw_task_select_tool_sub(cdw_task_t *task, cdw_id_t tool_family)
+void cdw_task_debug_print_options(cdw_task_t *task, const char *point)
 {
-	bool success = true;
-	if (task->id == CDW_TASK_MEDIA_INFO) {
-		if (tool_family == CDW_TOOL_GROWISOFS) {
-			task->media_info.tool.id = CDW_TOOL_DVD_RW_MEDIAINFO;
-		} else if (tool_family == CDW_TOOL_CDRECORD) {
-			task->media_info.tool.id = CDW_TOOL_CDRECORD;
-		/* } else if (tool_family == CDW_TOOL_XORRISO) {
-		        task->media_info.tool.id = CDW_TOOL_XORRISO; */
-		} else {
-			success = false;
-			cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
-		}
-		if (success) {
-			task->media_info.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->media_info.tool.id);
-		}
+	if (point) {
+		cdw_vdm ("INFO: task parameters at %s (%d):\n", point, (int) task->id);
+	}
 
-	} else if (task->id == CDW_TASK_ERASE_DISC) {
-		if (tool_family == CDW_TOOL_GROWISOFS) {
-			task->erase.tool.id = CDW_TOOL_DVD_RW_FORMAT;
-		} else if (tool_family == CDW_TOOL_CDRECORD) {
-			task->erase.tool.id = CDW_TOOL_CDRECORD;
-		/* } else if (tool_family == CDW_TOOL_XORRISO) {
-		        task->erase.tool.id = CDW_TOOL_XORRISO; */
-		} else {
-			success = false;
-			cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
-		}
-		if (success) {
-			task->erase.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->erase.tool.id);
-		}
-	} else if (task->id == CDW_TASK_BURN_FROM_FILES) {
-		   if (tool_family == CDW_TOOL_GROWISOFS
-		       || tool_family == CDW_TOOL_CDRECORD) {
+	if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660
+	    || task->id == CDW_TASK_CREATE_IMAGE_UDF) {
+		cdw_vdm ("INFO:                image file = \"%s\"\n", task->image_file_fullpath);
+	}
 
-			   if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)) {
-				   task->create_image.tool.id = CDW_TOOL_MKISOFS;
-				   task->create_image.tool.fullpath = cdw_ext_tools_get_tool_fullpath(CDW_TOOL_MKISOFS);
-
-				   if (tool_family == CDW_TOOL_GROWISOFS) {
-					   task->burn.tool.id = CDW_TOOL_GROWISOFS;
-				   } else {
-					   task->burn.tool.id = CDW_TOOL_CDRECORD;
-				   }
-			   } else {
-				   success = false;
-			   }
-		   /* } else if (tool_family == CDW_TOOL_XORRISO) {
-		              task->burn.tool.id = CDW_TOOL_XORRISO; */
-		   } else {
-			   success = false;
-			   cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
-		   }
-		   if (success) {
-			   task->burn.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->burn.tool.id);
-		   }
-	} else if (task->id == CDW_TASK_BURN_FROM_IMAGE) {
-		if (tool_family == CDW_TOOL_GROWISOFS) {
-			task->burn.tool.id = CDW_TOOL_GROWISOFS;
-		} else if (tool_family == CDW_TOOL_CDRECORD) {
-			task->burn.tool.id = CDW_TOOL_CDRECORD;
-		/* } else if (tool_family == CDW_TOOL_XORRISO) {
-		        task->burn.tool.id = CDW_TOOL_XORRISO;*/
-		} else {
-			success = false;
-			cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
-		}
-		if (success) {
-			task->burn.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->burn.tool.id);
-		}
+	if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
+		cdw_iso9660_debug_print_options(&(task->create_image.iso9660));
+	}
 
-	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
-		if (tool_family == CDW_TOOL_MKISOFS) {
-			task->create_image.tool.id = CDW_TOOL_MKISOFS;
-		} else if (tool_family == CDW_TOOL_XORRISO) {
-			task->create_image.tool.id = CDW_TOOL_XORRISO;
-		} else {
-			success = false;
-			cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
-		}
-		if (success) {
-			task->create_image.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->create_image.tool.id);
-		}
-	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
-		if (cdw_ext_tools_is_tool_available(CDW_TOOL_MD5SUM)) {
-			task->calculate_digest.tool.id = CDW_TOOL_MD5SUM;
-			task->calculate_digest.tool.fullpath = cdw_ext_tools_get_tool_fullpath(CDW_TOOL_MD5SUM);
-		} else {
-			success = false;
-		}
-	} else {
-		cdw_assert (0, "ERROR: incorrect task id = %d\n", task->id);
+	if (task->id == CDW_TASK_CREATE_IMAGE_UDF) {
+		cdw_udf_debug_print_options(&(task->create_image.udf));
 	}
 
-	return success;
+	return;
 }
-
-
-#endif
-
diff -Naur orig/src/tasks/cdw_task.h patched/src/tasks/cdw_task.h
--- orig/src/tasks/cdw_task.h	2012-03-25 12:13:39.000000000 +0200
+++ patched/src/tasks/cdw_task.h	2014-03-15 13:29:25.000000000 +0100
@@ -2,28 +2,33 @@
 #define H_CDW_TASK
 
 #include <stdbool.h>
+#include <signal.h> /* sig_atomic_t */
 
 #include "main.h"
 #include "cdw_disc.h"
 #include "cdw_config.h"
 #include "cdw_iso9660.h"
+#include "cdw_udf.h"
 #include "cdw_ext_tools.h"
 
 /* forward declaration */
 typedef struct cdw_task cdw_task_t;
 
 cdw_task_t *cdw_task_new(cdw_id_t id, cdw_disc_t *disc);
-void        cdw_task_save(cdw_task_t *task);
+void        cdw_task_save_options(cdw_task_t *task);
 void        cdw_task_delete(cdw_task_t **task);
+cdw_rv_t    cdw_task_copy(cdw_task_t *target, cdw_task_t *source);
+
 
 cdw_rv_t cdw_task_check_tool_status(cdw_task_t *task);
 void     cdw_task_reset_tool_status(cdw_task_t *task);
+cdw_rv_t cdw_task_select_tools_for_task(cdw_task_t *task, cdw_disc_t *disc);
 
 const char *cdw_task_get_session_mode_label(cdw_id_t mode);
 const char *cdw_task_get_disc_mode_label(cdw_id_t mode);
 
-void cdw_task_debug_print_iso9660_options(cdw_task_t *task);
 void cdw_task_debug_print_burn_options(cdw_task_t *task);
+void cdw_task_debug_print_options(cdw_task_t *task, const char *point);
 
 
 
@@ -83,42 +88,21 @@
 #define CDW_TOOL_STATUS_LIBCDIO_SETUP_FAIL                       0x00080001
 #define CDW_TOOL_STATUS_LIBCDIO_READ_FAIL                        0x00080002
 
-
 /* xorriso */
 #define CDW_TOOL_STATUS_XORRISO_SIMULATION_NOT_SUPPORTED         0x00000001
 #define CDW_TOOL_STATUS_XORRISO_NOT_ENOUGH_SPACE                 0x00000002
 #define CDW_TOOL_STATUS_XORRISO_CANNOT_READ_ISO_IMAGE_TREE       0x00000004
 #define CDW_TOOL_STATUS_XORRISO_NOT_A_KNOWN_OPTION               0x00000008
 
+/* mkudffs and its helpers. */
 
-/* mode of writing files to a CD/DVD disc */
-typedef enum {
-	CDW_SESSION_MODE_INIT = -1,
-	CDW_SESSION_MODE_START_MULTI = 0,  /**< \brief Start writing to disc in mode allowing further appending of data (don't close disc after writing) */
-	CDW_SESSION_MODE_CREATE_SINGLE,    /**< \brief Start writing to disc in mode NOT allowing further appending of data (close disc after writing)*/
-	CDW_SESSION_MODE_CONTINUE_MULTI,   /**< \brief Continue writing to disc in mode allowing further appending of data (don't close disc after writing) */
-	CDW_SESSION_MODE_WRITE_FINAL,      /**< \brief Write to disc in mode NOT allowing further appending of data (close disc after writing) */
-	CDW_SESSION_MODE_ERROR,
-	CDW_SESSION_MODE_N_MAX
-} cdw_session_mode_t;
-
-
-/* mode of writing files to a CD/DVD disc */
-#define CDW_DISC_MODE_INIT        0x100000000000
-#define CDW_DISC_MODE_UNSPECIFIED 0x000000000000   /**< \brief Let a tool select its own mode */
-#define CDW_DISC_MODE_TAO         0x000000000001   /**< \brief Track at once */
-#define CDW_DISC_MODE_DAO         0x000000000010   /**< \brief Disc at once */
-#define CDW_DISC_MODE_SAO         0x000000000100   /**< \brief Session at once */
-#if 0 /* currently unsupported modes */
-#define CDW_DISC_MODE_RAW         0x000000001000   /**< \brief Raw */
-#define CDW_DISC_MODE_RAW96P      0x000000010000
-#define CDW_DISC_MODE_RAW96R      0x000000100000
-#define CDW_DISC_MODE_RAW16       0x000001000000
-#endif
-#define CDW_DISC_MODE_ERROR       0x010000000000
+/* Segmentation fault may happen to any tool, but it's most likely to happen to mkudffs. */
+#define CDW_TOOL_STATUS_MKUDFFS_GENERAL_SEGMENTATION_FAULT       0x00000001
+#define CDW_TOOL_STATUS_SUDO_PASSWORD_PROMPT                     0x00000001
+#define CDW_TOOL_STATUS_MOUNT_FAILURE                            0x00000001
+#define CDW_TOOL_STATUS_UMOUNT_NOT_MOUNTED                       0x00000001
+#define CDW_TOOL_STATUS_RSYNC_NO_SPACE_LEFT                      0x00000001
 
-#define CDW_DISC_MODE_N_MODES    5 /* includes "Error" */
-// #define CDW_DISC_MODE_MODES_TABLE_SIZE     CDW_DISC_MODE_SAO
 
 
 enum task_id {
@@ -128,22 +112,40 @@
 	CDW_TASK_BURN_FROM_FILES,    /**< burn files to optical disc */
 	CDW_TASK_READ_DISC,          /**< read content of optical disc */
 	CDW_TASK_ERASE_DISC,         /**< erase optical disc - this includes formatting */
-	CDW_TASK_CLONE_DISC,         /**< clone one optical disc to another optical disc */
-
-	CDW_TASK_CREATE_IMAGE,       /**< create iso image on hdd, using files */
+	//CDW_TASK_CLONE_DISC,         /**< clone one optical disc to another optical disc */
 
 	CDW_TASK_CALCULATE_DIGEST,   /**< calculate digest of specified object */
 
-	CDW_TASK_MEDIA_INFO          /**< get check media information */
+	CDW_TASK_MEDIA_INFO,         /**< get check media information */
+
+	CDW_TASK_CREATE_IMAGE_ISO9660,
+	CDW_TASK_CREATE_IMAGE_UDF
 };
 
 
+
+
+
 struct cdw_task {
 
 	cdw_id_t id;
 
+	/* Full path to ISO9660 or UDF image file. Used when creating
+	   new image from files, or when writing image to optical
+	   disc. */
+	char *image_file_fullpath;
+
 	struct {
 		bool ok;
+
+		/* Most of actions are performed by external tools,
+		   which are executed as child processes.
+		   child_exit_status is set with wait(). This is a raw
+		   value. Different tools may return different values
+		   on success/failure. */
+		sig_atomic_t child_exit_status_raw;
+		int child_exit_status;
+
 		size_t mkisofs;
 		size_t cdrecord;
 		size_t calculate_digest;
@@ -151,121 +153,39 @@
 		size_t dvd_rw_mediainfo;
 		size_t libcdio;
 		size_t xorriso;
-	} tool_status;
-
 
-	struct {
-		/* "input" parameters of erasing */
-		cdw_id_t format_mode; /* format of DVD-RW: Sequential or Restricted Overwrite */
-		cdw_id_t speed_id;
-		cdw_id_t erase_mode;  /* erasing disc: all or fast */
-		cdw_id_label_t tool;
+		/* UDF tools: mkudffs and its helpers. */
+		size_t mkudffs_general;
+		size_t mkudffs;
+		size_t truncate;
+		size_t sudo;
+		size_t mount;
+		size_t umount;
+		size_t sync;
+		size_t rsync;
+	} tool_status;
 
-		bool eject;
 
-		/* "output" parameter of erasing (but only for CD-RW): if
-		   after attempting to perform erasing of CD-RW value of
-		   erase_time is still zero, then erasing failed */
-		size_t erase_time;
-	} erase;
+	/* On some day I will rename this variable to "write". */
+	cdw_write_t burn;
 
-	struct {
-		/* single sesion, append, finalize, etc. */
-		int session_modes[CDW_SESSION_MODE_N_MAX];
-		int session_modes_n_labels;
-		cdw_session_mode_t session_mode;
-
-		/* allowed disc modes: tao, sao, etc.; I'm not using
-		   single int + ORing, because the order of modes
-		   is significant: first mode on the list is most
-		   appropriate/probable */
-		long long int disc_modes[CDW_DISC_MODE_N_MODES];
-		int disc_modes_n_labels;
-		long long int disc_mode;
-
-		cdw_id_t speed_id;
-		bool verify;
-		bool dummy;
-		bool eject;
 
-		cdw_id_label_t tool;
+	cdw_erase_t erase;
 
-		/* size of data being burned to disc; this variable should not store
-		   _exact_ size of data, value stored in this variable should be
-		   used only when approximate data size needs to be known, e.g. in
-		   progress window when displaying approximate progress of task;
-		   depending on type of task this variable stores size of iso image
-		   file being burned to optical disc, or size of files selected for
-		   burning to optical disc */
-		double data_size_mb;
-		struct {
-			char *other_growisofs_options;
-		} growisofs;
-
-		struct {
-			bool burnproof;
-			bool pad;
-			int pad_size;
-			char *other_cdrecord_options;
-		} cdrecord;
-
-		struct {
-			char *other_xorriso_burn_options;
-		} xorriso;
-
-		/* path to source ISO9660 file */
-		char *iso9660_file_fullpath;
-	} burn;
 
 	struct {
 		cdw_id_label_t tool;
 
-		/* mkisofs: -J
-		   xorriso: -joliet on|off */
-		bool joliet_information;
-
-		/* mkisofs:
-		   xorriso: -follow link */
-		bool follow_symlinks;
-
-		/* mkisofs:
-		   xorriso: -volid text */
-		char volume_id[CDW_ISO9660_VOLI_LEN + 1]; /* 1 for ending '\0' */
-		char volume_set_id[CDW_ISO9660_VOLS_LEN + 1];
-		char preparer[CDW_ISO9660_PREP_LEN + 1];
-		char publisher[CDW_ISO9660_PUBL_LEN + 1];
-		char system_id[CDW_ISO9660_SYSI_LEN + 1];
-		char copyright[CDW_ISO9660_COPY_LEN + 1];
-		char abstract[CDW_ISO9660_ABST_LEN + 1];
-
-		/* mkisofs: -pad (hardwired value 300k);
-		   xorriso: -padding Xk|m */
-		bool pad;
-
-		/* none/useful/full
-		   mkisofs: -r for "useful", -R for "full"
-		   xorriso: full is always on, "none is not allowed", and for "useful":
-		   "-find / -true -exec mkisofs_r --" */
-		cdw_id_t rock_ridge;
-
-		/* path to resulting ISO9660 file */
-		char *iso9660_file_fullpath;
-
-		/* mkisofs-specific options */
-		struct {
-			bool joliet_long;
-			cdw_id_t iso_level;
-			char *root_dir;
-			char *other_mkisofs_options;
-		} mkisofs;
-
-		/* xorriso-specific options */
-		struct {
-			char *other_xorriso_iso_options;
-		} xorriso;
+		/* Options related to creating ISO9660 file system. */
+		cdw_iso9660_t iso9660;
+
+		/* Options related to creating UDF file system. */
+		cdw_udf_t udf;
 
 	} create_image;
 
+
+
 	struct {
 		cdw_id_label_t tool;
 	} media_info;
diff -Naur orig/src/tasks/Makefile.in patched/src/tasks/Makefile.in
--- orig/src/tasks/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/tasks/Makefile.in	2014-01-19 20:51:29.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,20 +76,24 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/tasks
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwtasks_a_AR = $(AR) $(ARFLAGS)
 libcdwtasks_a_LIBADD =
 am__objects_1 = cdw_read_disc_info.$(OBJEXT) cdw_burn_disc.$(OBJEXT) \
@@ -66,22 +114,69 @@
 	libcdwtasks_check_a-cdw_cdda2wav.$(OBJEXT)
 am_libcdwtasks_check_a_OBJECTS = $(am__objects_2)
 libcdwtasks_check_a_OBJECTS = $(am_libcdwtasks_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwtasks_a_SOURCES) $(libcdwtasks_check_a_SOURCES)
 DIST_SOURCES = $(libcdwtasks_a_SOURCES) $(libcdwtasks_check_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -297,14 +392,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwtasks.a: $(libcdwtasks_a_OBJECTS) $(libcdwtasks_a_DEPENDENCIES) $(EXTRA_libcdwtasks_a_DEPENDENCIES) 
-	-rm -f libcdwtasks.a
-	$(libcdwtasks_a_AR) libcdwtasks.a $(libcdwtasks_a_OBJECTS) $(libcdwtasks_a_LIBADD)
-	$(RANLIB) libcdwtasks.a
+	$(AM_V_at)-rm -f libcdwtasks.a
+	$(AM_V_AR)$(libcdwtasks_a_AR) libcdwtasks.a $(libcdwtasks_a_OBJECTS) $(libcdwtasks_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwtasks.a
+
 libcdwtasks_check.a: $(libcdwtasks_check_a_OBJECTS) $(libcdwtasks_check_a_DEPENDENCIES) $(EXTRA_libcdwtasks_check_a_DEPENDENCIES) 
-	-rm -f libcdwtasks_check.a
-	$(libcdwtasks_check_a_AR) libcdwtasks_check.a $(libcdwtasks_check_a_OBJECTS) $(libcdwtasks_check_a_LIBADD)
-	$(RANLIB) libcdwtasks_check.a
+	$(AM_V_at)-rm -f libcdwtasks_check.a
+	$(AM_V_AR)$(libcdwtasks_check_a_AR) libcdwtasks_check.a $(libcdwtasks_check_a_OBJECTS) $(libcdwtasks_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwtasks_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -330,151 +427,140 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwtasks_check_a-cdw_task.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwtasks_check_a-cdw_read_disc_info.o: cdw_read_disc_info.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_read_disc_info.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Tpo -c -o libcdwtasks_check_a-cdw_read_disc_info.o `test -f 'cdw_read_disc_info.c' || echo '$(srcdir)/'`cdw_read_disc_info.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_read_disc_info.c' object='libcdwtasks_check_a-cdw_read_disc_info.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_read_disc_info.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Tpo -c -o libcdwtasks_check_a-cdw_read_disc_info.o `test -f 'cdw_read_disc_info.c' || echo '$(srcdir)/'`cdw_read_disc_info.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_read_disc_info.c' object='libcdwtasks_check_a-cdw_read_disc_info.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_read_disc_info.o `test -f 'cdw_read_disc_info.c' || echo '$(srcdir)/'`cdw_read_disc_info.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_read_disc_info.o `test -f 'cdw_read_disc_info.c' || echo '$(srcdir)/'`cdw_read_disc_info.c
 
 libcdwtasks_check_a-cdw_read_disc_info.obj: cdw_read_disc_info.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_read_disc_info.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Tpo -c -o libcdwtasks_check_a-cdw_read_disc_info.obj `if test -f 'cdw_read_disc_info.c'; then $(CYGPATH_W) 'cdw_read_disc_info.c'; else $(CYGPATH_W) '$(srcdir)/cdw_read_disc_info.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_read_disc_info.c' object='libcdwtasks_check_a-cdw_read_disc_info.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_read_disc_info.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Tpo -c -o libcdwtasks_check_a-cdw_read_disc_info.obj `if test -f 'cdw_read_disc_info.c'; then $(CYGPATH_W) 'cdw_read_disc_info.c'; else $(CYGPATH_W) '$(srcdir)/cdw_read_disc_info.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc_info.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_read_disc_info.c' object='libcdwtasks_check_a-cdw_read_disc_info.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_read_disc_info.obj `if test -f 'cdw_read_disc_info.c'; then $(CYGPATH_W) 'cdw_read_disc_info.c'; else $(CYGPATH_W) '$(srcdir)/cdw_read_disc_info.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_read_disc_info.obj `if test -f 'cdw_read_disc_info.c'; then $(CYGPATH_W) 'cdw_read_disc_info.c'; else $(CYGPATH_W) '$(srcdir)/cdw_read_disc_info.c'; fi`
 
 libcdwtasks_check_a-cdw_burn_disc.o: cdw_burn_disc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_burn_disc.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Tpo -c -o libcdwtasks_check_a-cdw_burn_disc.o `test -f 'cdw_burn_disc.c' || echo '$(srcdir)/'`cdw_burn_disc.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_burn_disc.c' object='libcdwtasks_check_a-cdw_burn_disc.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_burn_disc.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Tpo -c -o libcdwtasks_check_a-cdw_burn_disc.o `test -f 'cdw_burn_disc.c' || echo '$(srcdir)/'`cdw_burn_disc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_burn_disc.c' object='libcdwtasks_check_a-cdw_burn_disc.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_burn_disc.o `test -f 'cdw_burn_disc.c' || echo '$(srcdir)/'`cdw_burn_disc.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_burn_disc.o `test -f 'cdw_burn_disc.c' || echo '$(srcdir)/'`cdw_burn_disc.c
 
 libcdwtasks_check_a-cdw_burn_disc.obj: cdw_burn_disc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_burn_disc.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Tpo -c -o libcdwtasks_check_a-cdw_burn_disc.obj `if test -f 'cdw_burn_disc.c'; then $(CYGPATH_W) 'cdw_burn_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_burn_disc.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_burn_disc.c' object='libcdwtasks_check_a-cdw_burn_disc.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_burn_disc.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Tpo -c -o libcdwtasks_check_a-cdw_burn_disc.obj `if test -f 'cdw_burn_disc.c'; then $(CYGPATH_W) 'cdw_burn_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_burn_disc.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_burn_disc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_burn_disc.c' object='libcdwtasks_check_a-cdw_burn_disc.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_burn_disc.obj `if test -f 'cdw_burn_disc.c'; then $(CYGPATH_W) 'cdw_burn_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_burn_disc.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_burn_disc.obj `if test -f 'cdw_burn_disc.c'; then $(CYGPATH_W) 'cdw_burn_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_burn_disc.c'; fi`
 
 libcdwtasks_check_a-cdw_create_image.o: cdw_create_image.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_create_image.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Tpo -c -o libcdwtasks_check_a-cdw_create_image.o `test -f 'cdw_create_image.c' || echo '$(srcdir)/'`cdw_create_image.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_create_image.c' object='libcdwtasks_check_a-cdw_create_image.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_create_image.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Tpo -c -o libcdwtasks_check_a-cdw_create_image.o `test -f 'cdw_create_image.c' || echo '$(srcdir)/'`cdw_create_image.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_create_image.c' object='libcdwtasks_check_a-cdw_create_image.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_create_image.o `test -f 'cdw_create_image.c' || echo '$(srcdir)/'`cdw_create_image.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_create_image.o `test -f 'cdw_create_image.c' || echo '$(srcdir)/'`cdw_create_image.c
 
 libcdwtasks_check_a-cdw_create_image.obj: cdw_create_image.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_create_image.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Tpo -c -o libcdwtasks_check_a-cdw_create_image.obj `if test -f 'cdw_create_image.c'; then $(CYGPATH_W) 'cdw_create_image.c'; else $(CYGPATH_W) '$(srcdir)/cdw_create_image.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_create_image.c' object='libcdwtasks_check_a-cdw_create_image.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_create_image.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Tpo -c -o libcdwtasks_check_a-cdw_create_image.obj `if test -f 'cdw_create_image.c'; then $(CYGPATH_W) 'cdw_create_image.c'; else $(CYGPATH_W) '$(srcdir)/cdw_create_image.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_create_image.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_create_image.c' object='libcdwtasks_check_a-cdw_create_image.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_create_image.obj `if test -f 'cdw_create_image.c'; then $(CYGPATH_W) 'cdw_create_image.c'; else $(CYGPATH_W) '$(srcdir)/cdw_create_image.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_create_image.obj `if test -f 'cdw_create_image.c'; then $(CYGPATH_W) 'cdw_create_image.c'; else $(CYGPATH_W) '$(srcdir)/cdw_create_image.c'; fi`
 
 libcdwtasks_check_a-cdw_read_disc.o: cdw_read_disc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_read_disc.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Tpo -c -o libcdwtasks_check_a-cdw_read_disc.o `test -f 'cdw_read_disc.c' || echo '$(srcdir)/'`cdw_read_disc.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_read_disc.c' object='libcdwtasks_check_a-cdw_read_disc.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_read_disc.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Tpo -c -o libcdwtasks_check_a-cdw_read_disc.o `test -f 'cdw_read_disc.c' || echo '$(srcdir)/'`cdw_read_disc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_read_disc.c' object='libcdwtasks_check_a-cdw_read_disc.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_read_disc.o `test -f 'cdw_read_disc.c' || echo '$(srcdir)/'`cdw_read_disc.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_read_disc.o `test -f 'cdw_read_disc.c' || echo '$(srcdir)/'`cdw_read_disc.c
 
 libcdwtasks_check_a-cdw_read_disc.obj: cdw_read_disc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_read_disc.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Tpo -c -o libcdwtasks_check_a-cdw_read_disc.obj `if test -f 'cdw_read_disc.c'; then $(CYGPATH_W) 'cdw_read_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_read_disc.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_read_disc.c' object='libcdwtasks_check_a-cdw_read_disc.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_read_disc.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Tpo -c -o libcdwtasks_check_a-cdw_read_disc.obj `if test -f 'cdw_read_disc.c'; then $(CYGPATH_W) 'cdw_read_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_read_disc.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_read_disc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_read_disc.c' object='libcdwtasks_check_a-cdw_read_disc.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_read_disc.obj `if test -f 'cdw_read_disc.c'; then $(CYGPATH_W) 'cdw_read_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_read_disc.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_read_disc.obj `if test -f 'cdw_read_disc.c'; then $(CYGPATH_W) 'cdw_read_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_read_disc.c'; fi`
 
 libcdwtasks_check_a-cdw_erase_disc.o: cdw_erase_disc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_erase_disc.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Tpo -c -o libcdwtasks_check_a-cdw_erase_disc.o `test -f 'cdw_erase_disc.c' || echo '$(srcdir)/'`cdw_erase_disc.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_erase_disc.c' object='libcdwtasks_check_a-cdw_erase_disc.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_erase_disc.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Tpo -c -o libcdwtasks_check_a-cdw_erase_disc.o `test -f 'cdw_erase_disc.c' || echo '$(srcdir)/'`cdw_erase_disc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_erase_disc.c' object='libcdwtasks_check_a-cdw_erase_disc.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_erase_disc.o `test -f 'cdw_erase_disc.c' || echo '$(srcdir)/'`cdw_erase_disc.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_erase_disc.o `test -f 'cdw_erase_disc.c' || echo '$(srcdir)/'`cdw_erase_disc.c
 
 libcdwtasks_check_a-cdw_erase_disc.obj: cdw_erase_disc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_erase_disc.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Tpo -c -o libcdwtasks_check_a-cdw_erase_disc.obj `if test -f 'cdw_erase_disc.c'; then $(CYGPATH_W) 'cdw_erase_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_erase_disc.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_erase_disc.c' object='libcdwtasks_check_a-cdw_erase_disc.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_erase_disc.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Tpo -c -o libcdwtasks_check_a-cdw_erase_disc.obj `if test -f 'cdw_erase_disc.c'; then $(CYGPATH_W) 'cdw_erase_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_erase_disc.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_erase_disc.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_erase_disc.c' object='libcdwtasks_check_a-cdw_erase_disc.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_erase_disc.obj `if test -f 'cdw_erase_disc.c'; then $(CYGPATH_W) 'cdw_erase_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_erase_disc.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_erase_disc.obj `if test -f 'cdw_erase_disc.c'; then $(CYGPATH_W) 'cdw_erase_disc.c'; else $(CYGPATH_W) '$(srcdir)/cdw_erase_disc.c'; fi`
 
 libcdwtasks_check_a-cdw_calculate_digest.o: cdw_calculate_digest.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_calculate_digest.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Tpo -c -o libcdwtasks_check_a-cdw_calculate_digest.o `test -f 'cdw_calculate_digest.c' || echo '$(srcdir)/'`cdw_calculate_digest.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_calculate_digest.c' object='libcdwtasks_check_a-cdw_calculate_digest.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_calculate_digest.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Tpo -c -o libcdwtasks_check_a-cdw_calculate_digest.o `test -f 'cdw_calculate_digest.c' || echo '$(srcdir)/'`cdw_calculate_digest.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_calculate_digest.c' object='libcdwtasks_check_a-cdw_calculate_digest.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_calculate_digest.o `test -f 'cdw_calculate_digest.c' || echo '$(srcdir)/'`cdw_calculate_digest.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_calculate_digest.o `test -f 'cdw_calculate_digest.c' || echo '$(srcdir)/'`cdw_calculate_digest.c
 
 libcdwtasks_check_a-cdw_calculate_digest.obj: cdw_calculate_digest.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_calculate_digest.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Tpo -c -o libcdwtasks_check_a-cdw_calculate_digest.obj `if test -f 'cdw_calculate_digest.c'; then $(CYGPATH_W) 'cdw_calculate_digest.c'; else $(CYGPATH_W) '$(srcdir)/cdw_calculate_digest.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_calculate_digest.c' object='libcdwtasks_check_a-cdw_calculate_digest.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_calculate_digest.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Tpo -c -o libcdwtasks_check_a-cdw_calculate_digest.obj `if test -f 'cdw_calculate_digest.c'; then $(CYGPATH_W) 'cdw_calculate_digest.c'; else $(CYGPATH_W) '$(srcdir)/cdw_calculate_digest.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_calculate_digest.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_calculate_digest.c' object='libcdwtasks_check_a-cdw_calculate_digest.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_calculate_digest.obj `if test -f 'cdw_calculate_digest.c'; then $(CYGPATH_W) 'cdw_calculate_digest.c'; else $(CYGPATH_W) '$(srcdir)/cdw_calculate_digest.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_calculate_digest.obj `if test -f 'cdw_calculate_digest.c'; then $(CYGPATH_W) 'cdw_calculate_digest.c'; else $(CYGPATH_W) '$(srcdir)/cdw_calculate_digest.c'; fi`
 
 libcdwtasks_check_a-cdw_task.o: cdw_task.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_task.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_task.Tpo -c -o libcdwtasks_check_a-cdw_task.o `test -f 'cdw_task.c' || echo '$(srcdir)/'`cdw_task.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_task.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_task.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_task.c' object='libcdwtasks_check_a-cdw_task.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_task.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_task.Tpo -c -o libcdwtasks_check_a-cdw_task.o `test -f 'cdw_task.c' || echo '$(srcdir)/'`cdw_task.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_task.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_task.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_task.c' object='libcdwtasks_check_a-cdw_task.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_task.o `test -f 'cdw_task.c' || echo '$(srcdir)/'`cdw_task.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_task.o `test -f 'cdw_task.c' || echo '$(srcdir)/'`cdw_task.c
 
 libcdwtasks_check_a-cdw_task.obj: cdw_task.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_task.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_task.Tpo -c -o libcdwtasks_check_a-cdw_task.obj `if test -f 'cdw_task.c'; then $(CYGPATH_W) 'cdw_task.c'; else $(CYGPATH_W) '$(srcdir)/cdw_task.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_task.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_task.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_task.c' object='libcdwtasks_check_a-cdw_task.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_task.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_task.Tpo -c -o libcdwtasks_check_a-cdw_task.obj `if test -f 'cdw_task.c'; then $(CYGPATH_W) 'cdw_task.c'; else $(CYGPATH_W) '$(srcdir)/cdw_task.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_task.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_task.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_task.c' object='libcdwtasks_check_a-cdw_task.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_task.obj `if test -f 'cdw_task.c'; then $(CYGPATH_W) 'cdw_task.c'; else $(CYGPATH_W) '$(srcdir)/cdw_task.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_task.obj `if test -f 'cdw_task.c'; then $(CYGPATH_W) 'cdw_task.c'; else $(CYGPATH_W) '$(srcdir)/cdw_task.c'; fi`
 
 libcdwtasks_check_a-cdw_cdda2wav.o: cdw_cdda2wav.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_cdda2wav.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Tpo -c -o libcdwtasks_check_a-cdw_cdda2wav.o `test -f 'cdw_cdda2wav.c' || echo '$(srcdir)/'`cdw_cdda2wav.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdda2wav.c' object='libcdwtasks_check_a-cdw_cdda2wav.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_cdda2wav.o -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Tpo -c -o libcdwtasks_check_a-cdw_cdda2wav.o `test -f 'cdw_cdda2wav.c' || echo '$(srcdir)/'`cdw_cdda2wav.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdda2wav.c' object='libcdwtasks_check_a-cdw_cdda2wav.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_cdda2wav.o `test -f 'cdw_cdda2wav.c' || echo '$(srcdir)/'`cdw_cdda2wav.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_cdda2wav.o `test -f 'cdw_cdda2wav.c' || echo '$(srcdir)/'`cdw_cdda2wav.c
 
 libcdwtasks_check_a-cdw_cdda2wav.obj: cdw_cdda2wav.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_cdda2wav.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Tpo -c -o libcdwtasks_check_a-cdw_cdda2wav.obj `if test -f 'cdw_cdda2wav.c'; then $(CYGPATH_W) 'cdw_cdda2wav.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdda2wav.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdda2wav.c' object='libcdwtasks_check_a-cdw_cdda2wav.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_cdda2wav.obj `if test -f 'cdw_cdda2wav.c'; then $(CYGPATH_W) 'cdw_cdda2wav.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdda2wav.c'; fi`
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwtasks_check_a-cdw_cdda2wav.obj -MD -MP -MF $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Tpo -c -o libcdwtasks_check_a-cdw_cdda2wav.obj `if test -f 'cdw_cdda2wav.c'; then $(CYGPATH_W) 'cdw_cdda2wav.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdda2wav.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Tpo $(DEPDIR)/libcdwtasks_check_a-cdw_cdda2wav.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdda2wav.c' object='libcdwtasks_check_a-cdw_cdda2wav.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwtasks_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwtasks_check_a-cdw_cdda2wav.obj `if test -f 'cdw_cdda2wav.c'; then $(CYGPATH_W) 'cdw_cdda2wav.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdda2wav.c'; fi`
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -486,15 +572,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -503,6 +585,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -644,18 +741,19 @@
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean \
-	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES ctags \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # used by flymake
diff -Naur orig/src/unused_code.see patched/src/unused_code.see
--- orig/src/unused_code.see	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/unused_code.see	2014-03-13 22:17:39.000000000 +0100
@@ -0,0 +1,13324 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007, 2008 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Kamil Ignacak 2008-01-22: code that is currently unused in cdw */
+
+
+/* code from cdw_cdio.c */
+
+/* ******************************* */
+/* ****** unused code below ****** */
+/* ******************************* */
+
+
+
+
+
+
+/*
+long int cdw_cdio_get_total_disc_sectors(void)
+{
+	return (int) disc.total_sectors;
+}
+*/
+
+
+
+
+
+#if 0 /* not used because now we have per-track method */
+
+/*
+ * Return useful data size in sector based on disc type
+*/
+int cdw_cdio_sector_size(void)
+{
+	switch (disc.mode) {
+		case CDIO_DISC_MODE_CD_DA:     /**< CD-DA */
+			return 2352;
+		case CDIO_DISC_MODE_CD_DATA:   /**< CD-ROM mode 1 form 1 */
+			return 2048;
+		case CDIO_DISC_MODE_CD_XA:     /**< CD-ROM XA mode 2 form 2 */
+			return 2324;
+		case CDIO_DISC_MODE_CD_MIXED:  /**< Some combo of above. */
+			return -1; /* FIXME - handle data and audio frames separately */
+		case CDIO_DISC_MODE_DVD_ROM:   // DVD ROM (e.g. movies)
+		case CDIO_DISC_MODE_DVD_RAM:   // DVD-RAM
+		case CDIO_DISC_MODE_DVD_R:     // DVD-R
+		case CDIO_DISC_MODE_DVD_RW:    // DVD-RW
+		case CDIO_DISC_MODE_DVD_PR:    // DVD+R
+		case CDIO_DISC_MODE_DVD_PRW:   // DVD+RW
+		case CDIO_DISC_MODE_DVD_OTHER: // Unknown/unclassified DVD type
+			return 2048;
+		/* FIXME - figure out what are correct values for these cases */
+	case CDIO_DISC_MODE_NO_INFO:
+	case CDIO_DISC_MODE_ERROR:
+		case CDIO_DISC_MODE_CD_I:      // CD-i
+			return -1;
+	default:
+			return -1;
+}
+}
+#endif
+
+
+
+
+
+
+#if 0
+sector_reader_fun cdw_cdio_sector_reader(void)
+{
+	switch (disc.mode) {
+		case CDIO_DISC_MODE_CD_DA:     /**< CD-DA */
+			return &cdio_read_audio_sector;
+		case CDIO_DISC_MODE_CD_DATA:   /**< CD-ROM form 1 */
+			return NULL;
+		case CDIO_DISC_MODE_CD_XA:     /**< CD-ROM XA form2 */
+			return NULL;
+		case CDIO_DISC_MODE_CD_MIXED:  /**< Some combo of above. */
+			return NULL; /* FIXME - handle data and audio frames separately */
+
+}
+}
+
+#endif
+#if 0
+
+int main(void)
+{
+	char buf[2048];
+
+	disc.p_cdio = cdio_open("/dev/hdd", DRIVER_DEVICE);
+	if (disc.p_cdio == NULL) {
+		fprintf(stderr, "error: cannot open cd drive\n");
+		return -1;
+}
+
+	track_t track_num = cdio_get_first_track_num(disc.p_cdio);
+	disc.total_tracks = cdio_get_num_tracks(disc.p_cdio);
+	printf("disc contains %d track(s)\n", disc.total_tracks);
+
+	int i = 0;
+
+	lsn_t sector_number;
+	for (i = 0; i < disc.total_tracks; i++, track_num++) {
+		sector_number = cdio_get_track_lsn(disc.p_cdio, track_num);
+		if (sector_number != CDIO_INVALID_LSN) {
+			printf("track number %d starts at sector %d\n", (int) track_num, (int) sector_number);
+}
+
+}
+
+	sector_number = cdio_get_track_lsn(disc.p_cdio, CDIO_CDROM_LEADOUT_TRACK);
+	printf("leadout starts at sector %d\n", sector_number);
+
+	lsn_t sectors_to_read = cdio_get_track_last_lsn(disc.p_cdio, disc.total_tracks);
+	sectors_to_read = cdio_get_track_last_lsn(disc.p_cdio, 1);
+	printf("sectors to read: %d\n", sectors_to_read);
+
+	for (sector_number = sectors_to_read; sector_number >= 0; sector_number--) {
+		driver_return_code_t rv = cdio_read_mode1_sector(disc.p_cdio, &buf, sector_number, false);
+		if (rv != 0){
+			printf("return value for sector %d is %d\n", (int) sector_number, (int) rv);
+}
+}
+
+	cdio_destroy(disc.p_cdio);
+
+	return 0;
+}
+
+#endif
+
+
+
+
+
+
+
+
+
+
+/* code from utils.c */
+/* unused code below */
+#if 0 // this function probably will be no longer used, since we use wide characters ncurses libraries
+/**
+ * Remove non-printable characters from path
+ *
+ * Replace non-printable characters (like '') from file's path.
+ * Such characters may be visible in files selector window, but
+ * path containig such characters is not displayed by 'Selected files'
+ * list, because it is implemented using ncurses MENU (and I don't know
+ * how to fix it yet). Non-printable characters are replaced by '?'.
+ *
+ * It may be possible to replace thiese characters only in strings
+ * displayed in 'Selected files' window and print them unaltered to
+ * cdrecord-source-files-paths tmp file.
+ *
+ * \param char **string - pointer to path - this parameter may be modified by function
+ *
+ */
+void make_ncurses_printable_string(char **string)
+{
+
+	return;
+
+	int len = strlen(*string);
+
+	int i = 0;
+	for (i = 0; i < len; i++) {
+		if (! isprint(*((*string) + i))) {
+			(*((*string) + i)) = '?';
+			if (! isprint(*((*string) + i + 1))) {
+				i++;
+}
+}
+}
+
+	return;
+}
+
+
+
+
+
+
+
+
+/* this is part of cdw_rv_t is_valid_path(char *fullpath, mode_t permissions, int filetype, struct stat *finfo),
+it should have checked for permission to access a file based on permissions of user OR group, but it does not work somehow for directories:
+user can't write to dir if it is in dir's group and permissions are d---rwx--- */
+if (permissions == -1) { /* don't ask for permissions */
+		if (internal_finfo) {
+			free(finfo);
+			finfo = NULL;
+}
+		return CDW_OK;
+} else {
+		uid_t uid = geteuid();
+		uid_t gid = getegid();
+		bool user_perm = ((finfo->st_uid == uid) && ((finfo->st_mode & S_IRWXU) == permissions));
+		/* shifting by one converts user permissions into group
+		 * permissions, additinal mask with S_IRWXG ensures that
+		* we check only group byte */
+		bool group_perm = ((finfo->st_gid == gid) && ((finfo->st_mode & S_IRWXG) == ((permissions >> 3) & S_IRWXG)));
+		fprintf(stderr, "\n\n");
+						if (group_perm) {
+						fprintf(stderr, "group perm = true\n");
+}
+						if (user_perm) {
+						fprintf(stderr, "user perm = true\n");
+}
+						fprintf(stderr, "stat group perm: %d, user perm: %d\n", (finfo->st_mode & S_IRWXG) >> 3, (finfo->st_mode & S_IRWXU) >> 6);
+						fprintf(stderr, "permissions variable, group: %d, user: %d\n", ((permissions >> 3) & S_IRWXG) >> 3, permissions >> 6);
+
+						if (user_perm || group_perm) {
+						if (internal_finfo) {
+						free(finfo);
+						finfo = NULL;
+}
+						fprintf(stderr, "Correct permissions for selected file %s\n", fullpath);
+						return CDW_OK;
+} else {
+						if (internal_finfo) {
+						free(finfo);
+						finfo = NULL;
+}
+						fprintf(stderr, "Wrong permissions for selected file %s\n", fullpath);
+						return CDW_PERM_ERROR; /* wrong permissions */
+}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif // if 0
+
+
+
+
+
+
+/* code from options.c */
+/* UNUSED CODE BELOW */
+
+
+
+#if 0
+/**
+ * Set error flag for preferences module
+ *
+ * Call this function when something went wrong during preferences setup.
+ * It will set internal error flag on, which will cause preferences module to work
+ * without reading or writing disc config file.
+ *
+ * \returns CDW_FAILSAFE_MODE
+ */
+int preferences_failsafe_mode(void)
+{
+	failsafe_mode = true;
+
+	return CDW_FAILSAFE_MODE;
+}
+#endif
+
+
+
+
+#if 0  /* old version */
+static int page_two()
+{
+	int ch, i;
+	FIELD *fields[PREF_FIELDS_P2]; /* last field == NULL included */
+	FORM *form_page[1];
+
+
+	preferences_win_erase();
+
+	/* 1st row */
+	field[0] = new_field(1, FIRST_COL_W, 0, FIRST_COL, 0, 0);
+	set_field_buffer(field[0], 0, _("SCSI device"));
+	field[1]=new_field(1, 12, 0, FIRST_COL_W + 2, 0, 0);
+	set_field_buffer(field[1], 0, config.scsi);
+
+
+	/* 2nd row */
+	field[2]=new_field(1, FIRST_COL_W, 1, FIRST_COL, 0, 0);
+	set_field_buffer(field[2], 0, _("CD Reader/Wirter"));
+	field[3]=new_field(1, 35, 1, FIRST_COL_W + 2, 0, 0);
+	set_field_buffer(field[3], 0, config.cdrwdevice);
+
+
+	/* 3rd row */
+	field[4]=new_field(1, FIRST_COL_W, 2, FIRST_COL, 0, 0);
+	set_field_buffer(field[4], 0, _("CD mountpoint"));
+	field[5]=new_field(1, 35, 2, FIRST_COL_W + 2, 0, 0);
+	set_field_buffer(field[5], 0, config.mountpoint);
+
+
+	/* 4th row */
+	field[6]=new_field(1, FIRST_COL_W, 3, FIRST_COL, 0, 0);
+	set_field_buffer(field[6], 0, _("CD Reader"));
+	field[7]=new_field(1, 35, 3, FIRST_COL_W + 2, 0, 0);
+	set_field_buffer(field[7], 0, config.cdrom);
+
+	field[8] = NULL;
+
+	/* scsi device
+	set_field_type(field[i], TYPE_REGEXP, "^(ATAPI:|REMOTE:){0,1}[0-9],[0-9],[0-9]");
+	*/
+
+
+	/* Input fields */
+	for (i=1; i<=13; i++) {
+	switch (i){
+#ifndef HAVE_LIBMYSQLCLIENT
+	case 2:
+	case 3:
+		field_opts_off(field[(i*2)-1], O_ACTIVE);
+		set_field_back(field[(i*2)-1], COLOR_PAIR(9) | A_BOLD);
+		set_field_fore(field[(i*2)-1], COLOR_PAIR(9) | A_BOLD);
+		break;
+#endif
+#ifndef HAVE_LIBSQLITE
+	case 5:
+		field_opts_off(field[(i*2)-1], O_ACTIVE);
+		set_field_back(field[(i*2)-1], COLOR_PAIR(9) | A_BOLD);
+		set_field_fore(field[(i*2)-1], COLOR_PAIR(9) | A_BOLD);
+		break;
+#endif
+#ifndef OGGENC
+	case 10:
+		field_opts_off(field[(i*2)-1], O_ACTIVE);
+		set_field_back(field[(i*2)-1], COLOR_PAIR(9) | A_BOLD);
+		set_field_fore(field[(i*2)-1], COLOR_PAIR(9) | A_BOLD);
+		break;
+#endif
+#ifndef LAME
+	case 12:
+		field_opts_off(field[(i*2)-1], O_ACTIVE);
+		set_field_back(field[(i*2)-1], COLOR_PAIR(9) | A_BOLD);
+		set_field_fore(field[(i*2)-1], COLOR_PAIR(9) | A_BOLD);
+		break;
+#endif
+	case 1:
+#ifdef HAVE_LIBMYSQLCLIENT
+	case 2:
+	case 3:
+#endif
+#ifdef HAVE_LIBSQLITE
+	case 5:
+#endif
+	case 6:
+	case 8:
+	case 13:
+		switch(i) {
+	case 8:
+				set_field_type(field[(i*2)-1], TYPE_REGEXP, "(8|12|16)+");
+				break;
+	case 13:
+				set_field_type(field[(i*2)-1], TYPE_REGEXP, "(32|56|64|96|128|192|320)+");
+				break;
+}
+		set_field_back(field[(i*2)-1], COLOR_PAIR(6));
+		set_field_fore(field[(i*2)-1], COLOR_PAIR(6));
+		break;
+	default:
+		set_field_type(field[(i*2)-1], TYPE_REGEXP, "^(X|_)$");
+		set_field_back(field[(i*2)-1], COLOR_PAIR(2));
+		set_field_fore(field[(i*2)-1], COLOR_PAIR(2));
+		break;
+}
+}
+		/* Lables */
+		for (i=1; i<=13; i++) {
+		set_field_just(field[(i*2)-2], JUSTIFY_RIGHT);
+		field_opts_off(field[(i*2)-2], O_ACTIVE);
+		switch (i){
+#ifndef HAVE_LIBMYSQLCLIENT
+	case 2:
+	case 3:
+				set_field_back(field[(i*2)-2], COLOR_PAIR(9) | A_BOLD);
+				set_field_fore(field[(i*2)-2], COLOR_PAIR(9) | A_BOLD);
+				break;
+#endif
+#ifndef HAVE_LIBSQLITE
+	case 5:
+				set_field_back(field[(i*2)-2], COLOR_PAIR(9) | A_BOLD);
+				set_field_fore(field[(i*2)-2], COLOR_PAIR(9) | A_BOLD);
+				break;
+#endif
+#ifndef OGGENC
+	case 10:
+				set_field_back(field[(i*2)-2], COLOR_PAIR(9) | A_BOLD);
+				set_field_fore(field[(i*2)-2], COLOR_PAIR(9) | A_BOLD);
+				break;
+#endif
+#ifndef LAME
+	case 12:
+				set_field_back(field[(i*2)-2], COLOR_PAIR(9) | A_BOLD);
+				set_field_fore(field[(i*2)-2], COLOR_PAIR(9) | A_BOLD);
+				break;
+#endif
+	default:
+				set_field_back(field[(i*2)-2], COLOR_PAIR(2));
+				set_field_fore(field[(i*2)-2], COLOR_PAIR(2));
+				break;
+}
+}
+
+	form_page[0]=new_form(field);
+	set_form_win(form_page[0], optwin.main);
+	set_form_sub(form_page[0], derwin(optwin.main, 18, 58, 1, 1));
+
+	post_form(form_page[0]);
+	put_ckbox(optwin.main, 4, 55);
+	put_ckbox(optwin.main, 7, 23);
+	put_ckbox(optwin.main, 8, 23);
+#ifdef OGGENC
+	put_ckbox(optwin.main, 9, 23);
+#endif
+	put_ckbox(optwin.main, 9, 55);
+#ifdef LAME
+	put_ckbox(optwin.main, 10, 23);
+#endif
+	mvwaddch(optwin.main, 17, 0, ACS_LTEE);
+	mvwhline(optwin.main, 17, 1, ACS_HLINE, 15);
+	mvwaddch(optwin.main, 17, 15, ACS_URCORNER);
+	mvwaddch(optwin.main, 18, 15, ACS_VLINE);
+	mvwprintw(optwin.main, 18, 1, _("<F1> General"));
+	mvwaddch(optwin.main, 17, 30, ACS_ULCORNER);
+	mvwhline(optwin.main, 17, 31, ACS_HLINE, 28);
+	mvwaddch(optwin.main, 17, 59, ACS_RTEE);
+	mvwprintw(optwin.main, 18, 18, _("<F2> Other"));
+	mvwaddch(optwin.main, 18, 30, ACS_VLINE);
+
+	form_driver(form_page[0], REQ_END_LINE);
+	wrefresh(optwin.main);
+	ch=0;
+	while ( (ch=wgetch(optwin.main)) != 27 ){
+		switch(ch){
+	case KEY_HOME:
+				form_driver(form_page[0], REQ_BEG_LINE);
+				break;
+	case KEY_END:
+				form_driver(form_page[0], REQ_END_LINE);
+				break;
+	case KEY_LEFT:
+				form_driver(form_page[0], REQ_PREV_CHAR);
+				break;
+	case KEY_RIGHT:
+				form_driver(form_page[0], REQ_NEXT_CHAR);
+				break;
+	case KEY_DOWN:
+				form_driver(form_page[0], REQ_NEXT_FIELD);
+				form_driver(form_page[0], REQ_END_LINE);
+				break;
+	case KEY_UP:
+				form_driver(form_page[0], REQ_PREV_FIELD);
+				form_driver(form_page[0], REQ_END_LINE);
+				break;
+	case KEY_BACKSPACE:
+				form_driver(form_page[0], REQ_DEL_PREV);
+				break;
+	case KEY_DC:
+				form_driver(form_page[0], REQ_DEL_CHAR);
+				break;
+	case KEY_F(1):
+	case KEY_F(10):
+				form_driver(form_page[0], REQ_VALIDATION);
+				sprintf(config.mountpoint, rtrim(field_buffer(field[1], 0)));
+				sprintf(config.cdbhost, rtrim(field_buffer(field[3], 0)));
+				sprintf(config.cdbuser, rtrim(field_buffer(field[5], 0)));
+				sprintf(config.autodic, (!strncmp(field_buffer(field[7], 0), "X", 1)?"1":"0"));
+				sprintf(config.audiodir, rtrim(field_buffer(field[11], 0)));
+				sprintf(config.stereo, (!strncmp(field_buffer(field[13], 0), "X", 1)?"1":"0"));
+				sprintf(config.bitsperchn, rtrim(field_buffer(field[15], 0)));
+				sprintf(config.echosound, (!strncmp(field_buffer(field[17], 0), "X", 1)?"1":"0"));
+				sprintf(config.encode, (!strncmp(field_buffer(field[19], 0), "X", 1)?"1":"0"));
+				sprintf(config.highq, (!strncmp(field_buffer(field[21], 0), "X", 1)?"1":"0"));
+				sprintf(config.lame, (!strncmp(field_buffer(field[23], 0), "X", 1)?"1":"0"));
+				sprintf(config.bitrate, rtrim(field_buffer(field[25], 0)));
+				sprintf(config.sqlite_file, rtrim(field_buffer(field[9], 0)));
+				return ch;
+				break;
+	default:
+				if (ch==' ') {
+					FIELD *cur;
+					int fld_index;
+
+				cur=current_field(form_page[0]);
+				fld_index=field_index(cur);
+				switch (fld_index) {
+	case 7:
+	case 13:
+	case 17:
+	case 19:
+	case 21:
+	case 23:
+					ch=(!strncmp(field_buffer(cur, 0), "X", 1)?'_':'X');
+					if ((fld_index==19) && (!strcmp(field_buffer(field[19], 0), "_"))){
+						set_field_buffer(field[23], 0, "_");
+}
+					if ((fld_index==23) && (!strcmp(field_buffer(field[23], 0), "_"))){
+						set_field_buffer(field[19], 0, "_");
+}
+					break;
+}
+}
+			form_driver(form_page[0], ch);
+			break;
+			wrefresh(optwin.main);
+}
+}
+	ch=KEY_F(10);
+	unpost_form(form_page[0]);
+	free_form(form_page[0]);
+	for (i=0; i<14; i++) free_field(field[i]);
+	return ch;
+}
+
+#endif
+
+
+
+
+/*
+
+	field[2]=new_field(1, 20, 2, 1, 0, 0);
+	set_field_buffer(field[2], 0, _("MySQL host"));
+	field[3]=new_field(1, 35, 2, 22, 0, 0);
+	set_field_buffer(field[3], 0, config.cdbhost);
+
+	field[4]=new_field(1, 20, 3, 1, 0, 0);
+	set_field_buffer(field[4], 0, _("MySQL user"));
+	field[5]=new_field(1, 6, 3, 22, 0, 0);
+	set_field_buffer(field[5], 0, config.cdbuser);
+
+	field[6]=new_field(1, 24, 3, 29, 0, 0);
+	set_field_buffer(field[6], 0, _("Auto Disk Catalog"));
+	field[7]=new_field(1, 1, 3, 55, 0, 0);
+	set_field_buffer(field[7], 0, (!strncmp(config.autodic, "1", 1)?"X":"_"));
+
+	field[8]=new_field(1, 20, 4, 1, 0, 0);
+	set_field_buffer(field[8], 0, _("SQLite DB file"));
+	field[9]=new_field(1, 35, 4, 22, 0, 0);
+	set_field_buffer(field[9], 0, config.sqlite_file);
+
+	field[10]=new_field(1, 20, 5, 1, 0, 0);
+	set_field_buffer(field[10], 0, _("Audio directory"));
+	field[11]=new_field(1, 35, 5, 22, 0, 0);
+	set_field_buffer(field[11], 0, config.audiodir);
+
+	field[12]=new_field(1, 20, 6, 1, 0, 0);
+	set_field_buffer(field[12], 0, _("Grab stereo mode"));
+	field[13]=new_field(1, 1, 6, 23, 0, 0);
+	set_field_buffer(field[13], 0, (!strncmp(config.stereo, "1", 1)?"X":"_"));
+
+	field[14]=new_field(1, 24, 6, 29, 0, 0);
+	set_field_buffer(field[14], 0, _("Bits per channel"));
+	field[15]=new_field(1, 3, 6, 54, 0, 0);
+	set_field_buffer(field[15], 0, config.bitsperchn);
+
+	field[16]=new_field(1, 20, 7, 1, 0, 0);
+	set_field_buffer(field[16], 0, _("Echo to sound dev."));
+	field[17]=new_field(1, 1, 7, 23, 0, 0);
+	set_field_buffer(field[17], 0, (!strncmp(config.echosound, "1", 1)?"X":"_"));
+
+	field[18]=new_field(1, 20, 8, 1, 0, 0);
+	set_field_buffer(field[18], 0, _("Encode to Ogg Vorbis"));
+	field[19]=new_field(1, 1, 8, 23, 0, 0);
+	set_field_buffer(field[19], 0, (!strncmp(config.encode, "1", 1)?"X":"_"));
+
+	field[20]=new_field(1, 24, 8, 29, 0, 0);
+	set_field_buffer(field[20], 0, _("High Quality"));
+	field[21]=new_field(1, 1, 8, 55, 0, 0);
+	set_field_buffer(field[21], 0, (!strncmp(config.highq, "1", 1)?"X":"_"));
+
+	field[22]=new_field(1, 20, 9, 1, 0, 0);
+	set_field_buffer(field[22], 0, _("Encode to Mp3"));
+	field[23]=new_field(1, 1, 9, 23, 0, 0);
+	set_field_buffer(field[23], 0, (!strncmp(config.lame, "1", 1)?"X":"_"));
+
+	field[24]=new_field(1, 24, 9, 29, 0, 0);
+	set_field_buffer(field[24], 0, _("Bitrate"));
+	field[25]=new_field(1, 4, 9, 54, 0, 0);
+	set_field_buffer(field[25], 0, config.bitrate);
+
+*/
+
+
+
+
+#if 0 /* obsolete, replaced by void write_config_file(FILE *conf_file, struct conf _config) */
+/*
+							* Write content of config variable to text file
+							*
+							* Write content of config variable to text file. This is low level
+							* function that does actual writing to file. The file should be opened for
+							* writing before calling this function. This function will not check for
+							* validity of file nor configuration variable.
+							*
+							* \param FILE *conf_file - opened configuration file
+ */
+							void write_current_configuration(FILE *conf_file)
+{
+							fprintf(conf_file,"################################\n");
+							fprintf(conf_file,"#    cdw configuration file    #\n");
+							fprintf(conf_file,"################################\n");
+							fprintf(conf_file, "\n");
+
+
+	// Settings visible to the user - page one
+							fprintf(conf_file, "\n#   \"Current session\" settings\n");
+	// most basic preferences
+							fprintf(conf_file,"volumeid=%s\n",config.volumeid);
+							fprintf(conf_file,"speed=%s\n",config.speed);
+							fprintf(conf_file,"multi=%s\n",config.multi);
+							fprintf(conf_file,"WriteFromImage=%s\n",config.fromimage);
+							fprintf(conf_file,"eject=%s\n",config.eject);
+							fprintf(conf_file,"burnproof=%s\n",config.burnproof);
+	// most basic preferences - 2
+							fprintf(conf_file,"dao=%s\n",config.dao);
+							fprintf(conf_file,"joliet=%s\n",config.joliet);
+							fprintf(conf_file,"rockridge=%s\n",config.rockridge);
+							fprintf(conf_file,"usefulRR=%s\n",config.usefulRR);
+	// basic preferences - other
+							fprintf(conf_file,"showvol=%s\n",config.showvol);
+							fprintf(conf_file,"dummy=%s\n",config.dummy);
+							fprintf(conf_file,"tempdir=%s\n",config.tempdir);
+							fprintf(conf_file,"other=%s\n",config.other);
+							fprintf(conf_file,"blank=%s\n",config.blank);
+							fprintf(conf_file,"showlog=%s\n",config.showlog);
+							fprintf(conf_file,"bootimg=%s\n",config.bootimg);
+							fprintf(conf_file,"pad=%s\n",config.pad);
+
+							fprintf(conf_file, "\n#   \"Hardware/CD\" settings\n");
+	// cd drive setting
+							fprintf(conf_file,"scsi-dev=%s\n",config.scsi);
+							fprintf(conf_file,"cdrwdevice=%s\n",config.cdrwdevice);
+							fprintf(conf_file,"cdrom=%s\n",config.cdrom);
+							fprintf(conf_file,"mountpoint=%s\n",config.mountpoint);
+	// disc settings
+							fprintf(conf_file,"user_cdsize=%d\n",config.user_cdsize);
+							fprintf(conf_file,"cdsize=%d\n",config.cdsize);
+
+							fprintf(conf_file, "\n#   \"CDDB\" settings\n");
+							fprintf(conf_file,"cdbhost=%s\n",config.cdbhost);
+							fprintf(conf_file,"cdbuser=%s\n",config.cdbuser);
+							fprintf(conf_file,"sqlite_file=%s\n",config.sqlite_file);
+
+							fprintf(conf_file, "\n#   \"Audio\" settings\n");
+							fprintf(conf_file,"audiodir=%s\n",config.audiodir);
+							fprintf(conf_file,"stereo=%s\n",config.stereo);
+							fprintf(conf_file,"bitsperchn=%s\n",config.bitsperchn);
+							fprintf(conf_file,"echosound=%s\n",config.echosound);
+							fprintf(conf_file,"encode=%s\n",config.encode);
+							fprintf(conf_file,"lame=%s\n",config.lame);
+							fprintf(conf_file,"highq=%s\n",config.highq);
+							fprintf(conf_file,"bitrate=%s\n",config.bitrate);
+
+
+	// haven't decided yet :)
+							fprintf(conf_file,"logfile=%s\n",config.logfile);
+							fprintf(conf_file,"autodic=%s\n",config.autodic);
+
+							return;
+}
+
+#endif
+
+
+
+
+
+
+
+/* code from cdw_widgets.c */
+/* unused code below */
+
+
+#if 0 /* replaced by int inbox(WINDOW *window, char *init, bool hash) */
+int inpass(WINDOW *input, char *init)
+{
+	int in_x, ch=0, i, pos;
+	char instr[256], instr2[256];
+
+	keypad(input, TRUE);
+	werase(input);
+	strcpy(instr, init);
+	if ( strlen(init)==0 )
+		instr[0]='\0';
+	else
+		strcpy(instr, init);
+	if (strlen(init)<getmaxx(input)-1) {
+		mvwprintw(input, 0, 0, init);
+		pos=strlen(instr);
+} else {
+		for (i=strlen(init)-(getmaxx(input)/2)-1; i<strlen(init); i++) {
+			waddch(input, '*');
+}
+		pos=(getmaxx(input)/2)+1;
+}
+	in_x=strlen(instr);
+	while ( (ch!=10) && (ch!=27) ) {
+		ch=wgetch(input);
+		if (( ch==27 )) {
+			strcpy(instr, init);
+}
+		if ( ch==KEY_BACKSPACE && in_x>0) {
+			instr[in_x-1]='\0';
+			in_x--;
+			pos--;
+			mvwaddch(input, 0, pos, ' ');
+			wmove(input, 0, pos);
+			if ((pos==(getmaxx(input)/2)-1) && (in_x>(getmaxx(input)/2)+1)) {
+				werase(input);
+				if (in_x-(getmaxx(input)-1)>=0) {
+					for (i=in_x-(getmaxx(input)-1); i<in_x; i++) {
+						waddch(input, '*');
+}
+					pos=getmaxx(input)-1;
+} else {
+					for (i=0; i<in_x; i++) {
+						waddch(input, '*');
+}
+					pos=in_x;
+}
+}
+}
+		if ( isprint(ch) ) {
+			if (pos<getmaxx(input)-1) {
+				waddch(input, '*');
+				instr[in_x]=ch;
+				instr[in_x+1]='\0';
+				in_x++;
+				pos++;
+}
+			if (pos==getmaxx(input)-1) {
+				werase(input);
+                /*	instr[in_x]=ch; */
+                /*	instr[in_x+1]='\0'; */
+				for (i=in_x-(getmaxx(input)/2); i<in_x; i++) {
+					waddch(input, '*');
+}
+                /*	in_x++; */
+				pos=(getmaxx(input)/2);
+}
+}
+		wrefresh(input);
+}
+
+	strcpy(init, instr);
+	if (ch==27)
+		return 0;
+	else
+		return 1;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/* this version of inbox() is replaced by wrapper for
+ * dynamically-growing form field */
+/**
+ * Small, one-line editable text area
+ *
+ * This function/widget simulates behaviour of FORM field and probably
+ * should be replaced by it. One advantage of this function is that
+ * it does not require building/initializing FORM and its fields.
+ * Second advaitage (I think) is that it can be used to enter passwords
+ * (visible input is hashed).
+ *
+ * Entered text can be longer than area width - part of
+ * text will be shifted left.
+ *
+ * \param WINDOW *window - parent ncurses window to be used as widget area; the window must be created by caller
+ * \param char *init - initial value to be displayed in text area, set to "" (empty string) for blank value
+ * \param bool hash - show astersks in input field instead of real user input
+ *
+ * \returns CDW_OK if user pressed CDW_ENTER,
+ *          CDW_CANCEL if user pressed CDW_ESCAPE
+ */
+cdw_rv_t inbox(WINDOW *window, char *init, bool hash)
+{
+	int rel_curs_pos; /* position of cursor in input window */
+
+	char input[256]; /* string entered in text field */ /* FIXME: arbitrary size */
+	int input_len; /* current length of string entered in text filed */
+
+	keypad(window, TRUE);
+	werase (window);
+
+	/* put initial text in text area */
+	if ((init == NULL) || (strlen(init) == 0)) {
+		input[0] = '\0';
+		rel_curs_pos = 0;
+} else { /* put initial text into buffer */
+		strcpy(input, init);
+
+		/* now print buffer content in the window */
+		if (strlen(init) < getmaxx(window) - 1) { /* print whole string */
+			mvwprintw(window, 0, 0, init);
+			rel_curs_pos = strlen(input);
+} else { /* print end of string, no longer than half of window width */
+			int i = strlen(init) - (getmaxx(window) / 2) - 1;
+			for (; i < strlen(init); i++) {
+				if (hash) {
+					waddch(window, '*');
+} else {
+					waddch(window, input[i]);
+}
+}
+			rel_curs_pos = (getmaxx(window) / 2) + 1; /* cursor at the end of string */
+}
+}
+
+	input_len = strlen(input);
+
+	/* now user can enter/append text */
+	curs_set(1); /* turn cursor on */
+
+	int window_width = getmaxx(window);
+	int ch = 0;
+	do {
+		ch = wgetch(window);
+		if ((ch == KEY_BACKSPACE || ch == KEY_DC) && input_len > 0) {
+			input[input_len - 1] = '\0';
+			input_len--;
+			rel_curs_pos--;
+
+			/* if cursor has moved to first half of window, but
+			whole string is still longer than half of window, then
+			redraw string; there can be two cases then:
+			 - string is longer than window_width, or
+			 - string is shorter than window_width (but longer than window_width /2)
+			inner 'if' covers those cases respectively */
+			if ((rel_curs_pos == (window_width / 2) - 1) &&
+						  (input_len > (window_width / 2) + 1)) {
+				werase(window);
+				int i = 0;
+				if (input_len  >= (window_width - 1)) {
+					/* if can't fit whole string in window */
+					for (i = input_len - (window_width - 1); i < input_len; i++) {
+						if (hash) {
+							waddch(window, '*');
+} else {
+							waddch(window, input[i]);
+}
+}
+					rel_curs_pos = window_width - 1;
+} else {
+					/* can display whole string in window */
+					for (i = 0; i < input_len; i++) {
+						if (hash) {
+							waddch(window, '*');
+} else {
+							waddch(window, input[i]);
+}
+}
+					rel_curs_pos = input_len;
+}
+} else {
+				/* no need to redraw whole string, just
+				update it's end */
+				mvwaddch(window, 0, rel_curs_pos, ' ');
+				wmove(window, 0, rel_curs_pos);
+}
+} else if (isprint(ch)) {
+			if (rel_curs_pos < window_width - 1) {
+				if (hash) {
+					waddch(window, '*');
+} else {
+					waddch(window, ch);
+}
+				input[input_len] = ch;
+				input[input_len + 1] = '\0';
+				input_len++;
+				rel_curs_pos++;
+}
+			if (rel_curs_pos == window_width - 1) {
+				werase(window);
+				/* input[input_len] = ch; */
+				/* input[input_len + 1] = '\0'; */
+				int i = 0;
+				for (i = input_len - (window_width / 2); i < input_len; i++) {
+					if (hash) {
+						waddch(window, '*');
+} else {
+						waddch(window, input[i]);
+}
+}
+				/* input_len++; */
+				rel_curs_pos = (window_width / 2);
+}
+} else {
+			; /* skip other, unclassified chars */
+}
+
+		wrefresh(window);
+} while ( (ch != CDW_ENTER) && (ch != CDW_ESCAPE) );
+
+	strcpy(init, input);
+
+	curs_set(0); /* turn cursor off */
+
+	if (ch == CDW_ENTER) {
+		return CDW_OK;
+} else { /* CDW_ESCAPE */
+		return CDW_CANCEL;
+}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/**
+ * Display widget allowing to enter simple string value
+ *
+ * Display widget with title and label, allowing user to enter simple
+ * value, like label, path or number. Parameter "mode" puts restrictions
+ * on entered value.
+ *
+ * \param char *title - window title
+ * \param char *label - label put into window
+ * \param char *prop - string containing entered value - it has to be initialized/allocated by caller
+ * \param int mode - widget mode, puts some restrictions on entered value
+ *
+ * \returns - CDW_OK or CDW_CANCEL
+ */
+cdw_rv_t input_box(char *title, char *label, char *prop, int mode)
+{
+	WINDOW *volwin;
+	FIELD *field[1];
+	FORM *form1;
+
+	int ch;
+	int nlines = 10, ncols = 50, begin_y = (LINES - 10) / 2, begin_x = (COLS - 50) / 2;
+
+	/* dialog window */
+	volwin = newwin(nlines, ncols, begin_y, begin_x);
+	keypad(volwin, TRUE);
+	wbkgd(volwin, COLOR_PAIR(2));
+	werase(volwin);
+	mvwprintw(volwin, 3, 3, _(label)); /* print descripion first, then border, because description can erase barts of border */
+	nice_box(volwin, _(title), "");
+
+
+	/* input field
+						   * new_field params: height, width, starty, startx, number of
+	* offscreen rows and number of additional working buffers */
+						   field[0] = new_field(1, 44, 0, 0, 0, 0);
+						   set_field_buffer(field[0], 0, prop);
+						   set_field_back(field[0], COLOR_PAIR(6));
+						   set_field_fore(field[0], COLOR_PAIR(6));
+						   field_opts_off(field[0], O_STATIC); /* stretch to fit entered data */
+						   set_max_field(field[0], 200); /* limit stretching of the field; FIXME - arbitrary magic number */
+						   field[1] = NULL;
+
+						   /* form containing field. placed in window */
+						   form1 = new_form(field);
+						   set_form_win(form1, volwin);
+						   set_form_sub(form1, derwin(volwin, 1, 44, 5, 2));
+						   post_form(form1);
+
+						   set_current_field(form1, field[0]);
+						   form_driver(form1, REQ_END_LINE);
+						   wrefresh(volwin);
+
+						   ch = 0;
+
+						   /* now user can enter data */
+						   curs_set(1); /* turn cursor on */
+						   while ((ch != CDW_ESCAPE) && (ch != CDW_ENTER)) {
+						   ch = wgetch(volwin);
+						   switch (ch) {
+	case KEY_LEFT:
+						   form_driver(form1, REQ_PREV_CHAR);
+						   break;
+	case KEY_RIGHT:
+						   form_driver(form1, REQ_NEXT_CHAR);
+						   break;
+	case KEY_BACKSPACE:
+						   form_driver(form1, REQ_DEL_PREV);
+						   break;
+	case KEY_DC:
+						   form_driver(form1, REQ_DEL_CHAR);
+						   break;
+	case KEY_F(10):
+	case CDW_ENTER:
+						   /* return main loop */
+						   /* exFIXME: what does it do?? */
+						   form_driver(form1, REQ_VALIDATION);
+						   sprintf(prop, (char *)rtrim(field_buffer(field[0], 0)));
+						   /* write_conf(); */
+						   /* return ch; */
+						   break;
+	default:
+						   /* push char ch to form */
+						   form_driver(form1, ch);
+						   break;
+}
+}
+
+						   curs_set(0); /* turn cursor off */
+
+/*    edit=derwin(volwin, 1, 24, 5, 3);
+						   wbkgd(edit, COLOR_PAIR(6));
+						   werase(edit);
+						   wrefresh(edit);
+						   ret=inbox(edit, prop, false);*/
+
+						   /* clean up */
+						   /* IMPORTANT: for some reason you have first free fields and then unpost and free form */
+						   free_field(field[0]);
+						   unpost_form(form1);
+						   free_form(form1);
+
+						   delwin(volwin);
+
+						   main_win_refresh_part(nlines, ncols, begin_y, begin_x);
+
+						   if (ch == CDW_ENTER) {
+						   return CDW_OK;
+} else {
+						   return CDW_CANCEL;
+}
+}
+
+
+
+
+
+
+
+
+
+/* exFIXME: redefine input_passwd using new input() or new inputbox() */
+int input_passwd(char *title, char *label, char *prop)
+{
+	WINDOW *volwin = newwin(10, 30, (LINES - 10) / 2, (COLS - 30) / 2);
+	wbkgd(volwin, COLOR_PAIR(2));
+	werase(volwin);
+
+	nice_box(volwin, title, "");
+
+	mvwprintw(volwin, 3, 3, label);
+	wrefresh(volwin);
+
+
+	WINDOW *edit = derwin(volwin, 1, 24, 5, 3);
+	wbkgd(edit, COLOR_PAIR(6));
+	werase(edit);
+	wrefresh(edit);
+
+	int rv; /* = one_line_input(WINDOW *window, char *init, char **result, int mode, int limit) */
+
+	delwin(edit);
+	edit = NULL;
+
+	delwin(volwin);
+	volwin = NULL;
+
+	return rv;
+}
+
+
+
+#endif /* if 0 */
+
+
+/* unused code below */
+
+#if 0
+
+
+void my_itoa(int i, char *string)
+{
+	int r;
+	char *s = string + 10;
+
+	*(s) = '\0';
+	s--;
+
+	do {
+		r = i % 10;
+		i = i/10;
+		*s = (char) (r + '0');
+		s--;
+} while (i >= 10);
+	*(s) = (char)(i + '0');
+
+
+
+	return;
+}
+
+
+
+
+
+/* shamelesly stolen from libc documentation - LGPL code */
+/* last argument must be NULL */
+char *concat2(const char *str, ...)
+{
+	va_list ap;
+	char *s;
+	size_t allocated = 100;
+	char *result = (char *) malloc(allocated);
+
+	if (result != NULL) {
+		char *newp;
+		char *wp;
+
+		va_start(ap, str);
+
+		wp = result;
+		for (s = str; s != NULL; s = va_arg(ap, const char *)) {
+			size_t len = strlen(s);
+
+			/* Resize the allocated memory if necessary.  */
+			if (wp + len + 1 > result + allocated) {
+				allocated = (allocated + len) * 2;
+				newp = (char *) realloc(result, allocated);
+				if (newp == NULL) {
+					free(result);
+					return NULL;
+}
+				wp = newp + (wp - result);
+				result = newp;
+}
+
+			wp = mempcpy(wp, s, len);
+}
+
+		/* Terminate the result string.  */
+		*wp++ = '\0';
+
+		/* Resize memory to the optimal size.  */
+		newp = realloc(result, wp - result);
+		if (newp != NULL)
+			result = newp;
+
+		va_end(ap);
+}
+
+	return result;
+}
+
+
+#endif
+
+
+
+
+
+/* from blank_wizard */
+/* unused code below */
+
+
+#if 0
+/**
+ * Widget allowing user to select blanking method
+ *
+ * Widget allowing user to select blanking method: "fast" or "all".
+ * User can select one of them using UP/DOWN arrow keys or numerical
+ * values assigned to labels "fast" and "all", visible in the
+ * widget.
+ *
+ * \returns CDW_OK if user accepted blanking method using ENTER key,
+ *          CDW_CANCEL if user pressed 'q', 'Q' or ESCAPE
+ */
+cdw_rv_t blank_wizard_cdrecord(void)
+{
+	/* dialog window */
+	WINDOW *window = newwin(10, 30, (LINES - 10) / 2, (COLS - 30) / 2);
+	wbkgd(window, COLOR_PAIR(2));
+	werase(window);
+	keypad(window, true); /* enable arrow keys and other keys for this window */
+	/* 2TRANS: this is title of dialog window, the window allows
+	user to select blanking method */
+	nice_box(window, _("Blanking method"), "");
+
+
+	/* label and kind-of radio buttons in dialog windows */
+	/* 2TRANS: this is label in dialog window, the window allows
+	user to select blanking method */
+	mvwprintw(window, 2, 3, _("Select CD blanking method"));
+	/* 2TRANS: this is radio button label: 'erase fast' method,
+	only table of content is erased */
+	mvwprintw(window, 4, 5, _("1 - fast"));
+	/* 2TRANS: this is radio button label:  'erase all' method,
+	whole content is erased */
+	mvwprintw(window, 5, 5, _("2 - all"));
+
+
+	/* both radiobuttons are blank, preselect one of them based on
+	current configuration */
+	if ( !strcmp(config.blank, "fast") ) {
+		mvwaddch(window, 4, 3, '*');
+} else if ( !strcmp(config.blank, "all") ) {
+		mvwaddch(window, 5, 3, '*');
+} else { /* default will be "fast" */
+		mvwaddch(window, 4, 3, '*');
+}
+
+	/* the table should be large enough to hold "fast" or "all" strings
+	- these are not translatable in this place, they are just labels.
+	I could use some numerical value, but this way	is more readable. */
+	char tmp_blank[5];
+
+	strcpy(tmp_blank, config.blank); /* work on copy of config value */
+
+	int ch = 0;
+	do {
+		ch = wgetch(window);
+
+		if ( ch == '1' ) {
+			strcpy(tmp_blank, "fast");
+} else if ( ch == '2' ) {
+			strcpy(tmp_blank, "all");
+} else if ( ch == KEY_UP || ch == KEY_DOWN) {
+			if ( !strcmp(tmp_blank, "fast") ) {
+				/* "fast" is currently selected, but user
+				moves selection to "all" */
+				strcpy(tmp_blank, "all");
+} else {
+				/* "all" is currently selected, but user
+				moves selection to "fast" */
+				strcpy(tmp_blank, "fast");
+}
+} else {
+			; /* no other way to change selection */
+}
+
+		/* user changed selection (using numerical keys or arrow
+		keys - this is now irrelevant), it was written to
+		config.blank, now update radio button accordingly */
+		if ( !strcmp(tmp_blank, "fast") ) {
+			mvwaddch(window, 4, 3, '*');
+			mvwaddch(window, 5, 3, ' ');
+} else if ( !strcmp(tmp_blank, "all") ) {
+			mvwaddch(window, 4, 3, ' ');
+			mvwaddch(window, 5, 3, '*');
+} else { /* some error occurred, don't change anything */
+			;
+}
+		wrefresh(window);
+} while ((ch != CDW_ESCAPE) && (ch != CDW_ENTER) && (ch != 'q') && (ch != 'Q'));
+
+
+	delwin(window);
+	window = NULL;
+
+	main_win_refresh_part(10, 30, (LINES - 10) / 2, (COLS - 30) / 2);
+
+	if ((ch == CDW_ESCAPE) || (ch == 'q') || (ch == 'Q')) {
+		return CDW_CANCEL;
+} else {
+		/* save current setting to real config variable */
+		strcpy(config.blank, tmp_blank);
+		write_conf();
+		return CDW_OK;
+}
+}
+
+#endif
+
+
+
+
+/* from cdrecord_interface.c */
+
+
+/* unused code below */
+
+
+#if 0
+
+/**
+ * Check if optical disc in drive is erasable
+ *
+ * Check if optical disc in drive is erasable - this can be done with
+ * 'wodim -atip dev=/dev/hdx' command retrieving ATIP info.
+ *
+ * Some drives may not support this.
+ *
+ * \returns CDW_OK if media is erasable or this information is unavailable
+ *          CDW_NO if disc is for sure not erasable
+ */
+cdw_rv_t run_command_cdrecord_check_erasable(void)
+{
+	char command[500];
+
+
+
+	sprintf(command, "%s -atip dev=%s", CDRECORD, config.cdrw_device);
+	/* 2TRANS: this is title of dialog window - program is reading metadata from CD */
+	processwin_create(_("Checking media"), "", false);
+
+	current_command = COMMAND_CDRECORD_CHECK_ERASABLE;
+	run_command(command);
+	current_command = COMMAND_NONE;
+
+	processwin_destroy("", false);
+
+	if (current_disc.disc_erase_status == CDW_DISC_E_YES
+		   || current_disc.disc_erase_status == CDW_DISC_E_UNKNOWN) {
+		return CDW_OK;
+} else {
+			   return CDW_NO;
+}
+}
+
+
+
+
+
+int run_command_cdrecord_write_from_image2(void)
+{
+	current_command = COMMAND_CDRECORD_WRITE_FROM_IMAGE;
+
+	char *command = concat(CDRECORD, " -v speed=", current_disc.speed,
+			       " dev=",   config.scsi,
+	  " ", config.other_cdrecord_options, " ",/* the spaces are important */
+   NULL);
+	if (command == NULL) {
+		current_command = COMMAND_NONE;
+		return CDW_MEM_ERROR;
+}
+
+	if (strcmp(config.dao, "1") == 0) {
+		append(&command, " -dao ");
+}
+	if (strcmp(config.dummy, "1") == 0) {
+		append(&command, " -dummy ");
+}
+	if (strcmp(config.burnproof, "1") == 0) {
+		append(&command, " -driveropts=burnproof ");
+}
+	append(&command, " -data ");
+	append(&command, config.tempdir);
+	append(&command, " ");
+
+	/* debug string */
+	fprintf(stderr, "command for writing to image: >>%s<<\n", command);
+
+	/* 2TRANS: this is title of dialog window */
+	processwin_create(_("Write image to CD"),
+			  /* 2TRANS: this is message in dialog window - writing iso image to CD is in progress */
+			  _("Writing image to CD..."), true);
+	run_command(command);
+	/* 2TRANS: this is message in dialog window */
+	processwin_destroy(_("Writing finished"), true);
+
+	current_command = COMMAND_NONE;
+
+	return 0;
+}
+
+
+
+
+
+
+
+/**
+ * Create 'char *' string containing program name and program's argument
+ * for writing some input to optical disc
+ *
+ * This function creates string with program name and all options that
+ * are set somewhere in config.* global variable. This function does not
+ * append parameter pointing to file (or files) that has to be
+ * written - caller must do that himself. It means that this function can
+ * be used in two situations: when writing (created previously) image to
+ * CD and when writing files directly from filesystem.
+ *
+ * \param char *command - allocated space for string
+ */
+void prep_command_cdrecord_write_direct(char *command)
+{
+	if (strlen(config.volumeid) == 0) {
+		strcpy(config.volumeid, DEFAULT_VOLUMEID); /* defined in main.h */
+}
+
+	/* all parameters values are now known, let's build command */
+	/* first - program name, write speed and writing device */
+	sprintf(command, " %s -v speed=%s dev=%s ", CDRECORD, current_disc.speed, config.scsi);
+
+	/* a few obvious options */
+	if (strcmp(config.dao, "1") == 0) {
+		strcat(command, " -dao ");
+} else {
+		strcat(command, " -tao ");
+}
+
+	if (strcmp(config.dummy, "1") == 0) {
+		strcat(command, " -dummy ");
+}
+
+	if (strcmp(config.multi, "1") == 0) {
+		strcat(command, " -multi ");
+}
+
+	if (strcmp(config.burnproof, "1") == 0) {
+		strcat(command, " -driveropts=burnproof ");
+}
+
+	/* tsize parameter - some drives need to know track size before writing to disk;
+	* let's hope that $tsize exists - it should be created by running
+	* MKISOFS --print-size (...) */
+	sprintf(command, "%s %s%c ", command, "-tsize=${tsize}s ", '\0');
+
+	/* almost ready - caller must (may?) append path to iso image */
+
+	return;
+}
+
+#endif
+
+
+
+/* from cdrecord_pipe_regexp.c */
+
+
+/* unused code */
+
+#if 0
+
+
+
+/**
+ * \brief Read current disc type (vesion capturing short format of information)
+ *
+ * 'cdrecord -atip -v' prints following info: 'Current: CD-RW' where
+ * 'CD-RW' can be replaced by other disc types. List of disc types recognized
+ * by cdw is on top of this file. Some of the types are supported by cdw
+ * as well. Some types of CDs are processed by this function. This function
+ * might capture types of disc that are unsupported, but appropriate fields
+ * of current_disc are then set to 'unknown' anyway.
+ *
+ * The function processes short format of the information
+ * ('Current: CD-RW') as opposed to long format printed by some
+ * other versions of the tool: 'Current: 0x000A (CD-RW)'. See also
+ * handle_current_disc_type_long().
+ */
+void handle_current_disc_type_short(regex_t *regex, regmatch_t *matches)
+{
+	/*            1         2          */
+	/* "Current:([ ]*)([CDVRWOM+\-]+)" */
+	/* "Current: CD-RW" */
+
+	/* 12 chars is more than needed to store supported disc type
+	without additional qualifiers like 'sequential recording' */
+	char disc_type[12 + 1];
+
+	/* collect data */
+	unsigned int i;
+	for (i = 0; i < (regex->re_nsub + 1); i++) {
+		size_t len = matches[i].rm_eo - matches[i].rm_so;
+		char submatch[PIPE_BUFFER_SIZE];
+		strncpy(submatch, (char *) &stdout_pipe_buffer[matches[i].rm_so], len);
+		submatch[len] = '\0';
+
+		/* debug message */
+		/* fprintf(stderr, "----%s(): matching submatch: \"%s\"\n", __func__, submatch); */
+
+		if (i == 2) {
+			/* debug message */
+			/* fprintf(stderr, "%s(): submatch%d: \"%s\"\n", __func__, i, submatch); */
+			strncpy(disc_type, submatch, 12);
+			disc_type[12] = '\0';
+} else {
+			/* debug message */
+			/* fprintf(stderr, "%s(): submatch%d: \"%s\"\n", __func__, i, submatch); */
+}
+}
+
+	/* debug message */
+	fprintf(stderr, "%s(): disc_type: \"%s\"\n", __func__, disc_type);
+
+	if (!strcmp(disc_type, "CD-RW")) {
+		current_disc.disc_type = CDW_CD_RW;
+		strcpy(current_disc.disc_type_label, disc_type);
+} else if (!strcmp(disc_type, "CD-R")) {
+		current_disc.disc_type = CDW_CD_R;
+		strcpy(current_disc.disc_type_label, disc_type);
+} else if (!strcmp(disc_type, "CD-ROM")) {
+		if (current_disc.cdio_disc.mode == CDIO_DISC_MODE_CD_DA) {
+			current_disc.disc_type = CDW_CD_AUDIO;
+			strcpy(current_disc.disc_type_label, _("Audio CD"));
+} else {
+			current_disc.disc_type = CDW_CD_ROM;
+			strcpy(current_disc.disc_type_label, disc_type);
+}
+} else {
+		current_disc.disc_type = CDW_DISC_UNKNOWN;
+		/* 2TRANS: "Unknown" as in "Unknown disc type". Keep short! */
+		strcpy(current_disc.disc_type_label, _("Unknown"));
+}
+
+	/* this is a good place to check 'erasability' of disc */
+	if (current_disc.disc_type == CDW_CD_RW) {
+		current_disc.disc_erase_status = CDW_DISC_E_YES;
+} else {
+		current_disc.disc_erase_status = CDW_DISC_E_NO;
+}
+
+	/* let's check 'writability' too */
+	if (current_disc.disc_type == CDW_CD_ROM
+		   || current_disc.disc_type == CDW_CD_AUDIO) {
+
+		current_disc.disc_write_status = CDW_DISC_W_READ_ONLY;
+}
+
+		   return;
+}
+
+#endif
+
+
+/* from cdw_file_manager.c */
+
+
+
+
+/* unused code */
+
+#if 0
+
+/* code in this function was part of addwin_driver_loop(), then it was extracted
+   to addwin_driver_loop_change_dir(), then it was copied to new version of
+   addwin_driver_loop_change_dir() which was rewritten almost from scratch;
+   so basically this is piece of code from addwin_driver_loop() that got
+   replaced by current version of addwin_driver_loop_change_dir() */
+void addwin_driver_loop_change_dir(char **dirpath, int n_direntries, int menupos)
+{
+	/* prepare full path to new dir - the buffer will be long enough to
+	store whole extended path (browsing to subdirectories) but also
+	shortened path (browsing to parent directory); even if we always
+	keep going up in dir hierarchy, we waste no more than (maxlen(dirname))
+	per dir level. What we gain is only one malloc() (hidden in concat) per level */
+	char *new_dirpath = concat(*dirpath, "/", dir_listing[menupos].name, NULL);
+	if (new_dirpath == NULL) {
+		return; /* let's hope that user will press ENTER once more and then it will work */
+}
+	struct stat stbuf;
+	if (stat(new_dirpath, &stbuf) == -1) {
+		/* 2TRANS: this is title of dialog window */
+		dialogbox(_("Error"),
+						/* 2TRANS: this is message in dialog window:
+			  user highlighted a file and pressed enter,
+			  but the file does not exit */
+			  _("File does not exists or cannot change directory."),
+			    DIALOG_OK, CDW_COLORS_ERROR);
+		free(new_dirpath);
+		new_dirpath = NULL;
+		return;
+}
+
+	/* first check what the item is: file or dir? */
+	if ((stbuf.st_mode & S_IFMT) != S_IFDIR) {
+		return;
+}
+
+				/* highlighted item is a directory;
+	one more check: is it parent dir? */
+	if (strcmp(dir_listing[menupos].name, "..") == 0) {
+		size_t len = strlen(*dirpath);
+		/* erase '..' from end of new_dirpath; it is safe, because
+		new_dirpath after concat() above is 'dirpath/..' */
+					// *(new_dirpath + len) = '\0';
+		*(new_dirpath + len + 1) = '\0';
+		*(new_dirpath + len + 2) = '\0';
+
+		/* returns pointer to last occurrence of '/'; this will
+		work only because we don't append '/' to end of dir names */
+		char *pos = strrchr((char *) new_dirpath, '/');
+		if (pos != NULL) {
+						/* move ending of dir path to the left
+			so that it ends one dirlevel earlier */
+			memset(pos, '\0', 1);
+}
+
+		if (strlen(new_dirpath) == 0) {
+			/* We have reached root directory, but
+			path in dirpath is now shortened to 0. Fix it. */
+			new_dirpath[0] = '/';
+			new_dirpath[1] = '\0';
+}
+} else {
+		/* do nothing more: path created for purposes of stat() is ok */
+}
+
+	/* new dir (only dir) path is ready - use it */
+	if (access(new_dirpath, R_OK | X_OK) == -1) {
+		/* cannot change directory, get rid of new_path, old dirpath remains without changes */
+		free(new_dirpath);
+		new_dirpath = NULL;
+		/* 2TRANS: this is title of dialog window */
+		dialogbox(_("Error"),
+			  /* 2TRANS: this is message in dialog window */
+			  _("Cannot change directory: wrong permissions."),
+			    DIALOG_OK, CDW_COLORS_ERROR);
+} else {
+		menupos = 0;
+		n_direntries = addwin_load_dir(new_dirpath);
+		addwin_update_border(new_dirpath);
+		addwin_display_item(0, dir_listing + menupos, true);
+
+		/* save current dir path - update value of function's argument */
+		free(*dirpath);
+		(*dirpath) = new_dirpath;
+}
+
+	return;
+}
+
+#endif
+
+
+
+/* from cdw_tmp_files.c */
+
+/**
+ * This file implements following data structures:
+ * filelist: a data structure holding paths to all selected files that user
+ * wants to write to cd or to image file. filelist items can be added or
+ * removed using functions provided in this file.
+ * filetable: data structure also holding paths to all files selected by user
+ *
+ * The reason for keeping duplication list of files was that code creating
+ * cditems menu items required a continuous (and of fixed size) table of
+ * elements. Filelist (although it is a table too) did not guaranteed this.
+ * Now when we have filetable_ith_element, perhaps there is a chance to
+ * remove this duplication. ex_TO_DO: check if unifying filetable and filelist
+ * is possible and if this will be necessary if file_manager (see comment
+ * at the top of cdw_file_manager.c) will be implemented. Code below works
+ * fine, so priority of this ex_to_do is low.
+ *
+ * Currently filelist has limited size. Filetable is allocated dynamically,
+ * but it's size (in terms of number of elements) cannot exceed the size of
+ * filelist.
+ *
+ * Probably code for filetable and filelist should be moved to separate file,
+ * as it is not related directly to tmp files.
+ */
+
+
+
+
+/* size of list of files to be put on CD */
+#define FILELIST_SIZE 1000
+
+
+static char *filelist[FILELIST_SIZE]; /* list of file paths */
+static char **filetable = NULL;  /* table of pointers to paths */
+
+
+
+/**
+ * Initialize filelist data structure
+ *
+ * Set all values of this list to NULL - NULL means that entry
+ * is empty and may be used for new path.
+ */
+void filelist_init(void)
+{
+	int i;
+	for (i = 1; i < FILELIST_SIZE; i++) {
+		filelist[i] = NULL;
+}
+
+	return;
+}
+
+
+
+
+/**
+ * Remove all elements from filelist
+ *
+ * Remove all elements (file paths) from filelist. All elements
+ * of list will be set to NULL;
+ */
+void filelist_clean(void)
+{
+	int i;
+	for (i = 1; i < FILELIST_SIZE; i++) {
+		if (filelist[i] != NULL) {
+			free(filelist[i]);
+			filelist[i] = NULL;
+}
+}
+
+	return;
+}
+
+
+
+
+
+/**
+ * Add given path to set of file paths
+ *
+ * Add file path to list of unique file paths. If path provided as an
+ * argument already exists on the list, it is not added again and nothing
+ * happens. Currently list has limited size. If there is no place on the
+ * list, then an error value is returned.
+ *
+ * \param char *path - path to file or directory that will be added to list
+ *
+ * \returns 0 - if file was not added (already on list);
+ *         -1 - on memory allocation error;
+ *         -2 - if no place left on list;
+ *          value > 0 - when path successfully added
+ */
+int filelist_add(char *path)
+{
+	int i;
+
+	/* search for argument on the list */
+	for (i = 1; i < FILELIST_SIZE; i++) {
+		if ( filelist[i] != NULL ) { /* empty places on list are initialized as NULL */
+			if ( ! (strcmp(path, filelist[i])) ) { /* file is already on the list */
+				return 0; /* file not added, already exists, no error */
+}
+}
+}
+
+	/* search for empty place on list */
+	for (i = 1; i < FILELIST_SIZE; i++) {
+		if (filelist[i] == NULL) { /* empty place - add here */
+			int len = strlen(path);
+			filelist[i] = (char *) malloc(len + 1);
+			if (filelist[i] == NULL) {
+				return -1; /* file not added - memory alloc error */
+}
+			strncpy(filelist[i], path, len + 1);
+			return i; /* success */
+
+}
+}
+
+	return -2; /* error - no place on list */
+}
+
+
+
+
+/**
+ * Remove given path from list of files
+ *
+ * Remove given path from list of files that are going to be put on CD.
+ *
+ * \param const char *path - path to file/dir that has to be removed from list
+ *
+ * \returns 0 on success
+ *         -1 when no path found on list
+ *         -2 when other error
+ */
+int filelist_remove(const char *path)
+{
+	int i;
+
+	/* we are starting from 1 because adding to list was started from 1 too */
+	for (i = 1; i < FILELIST_SIZE; i++) {
+		if ( filelist[i] != NULL ) {
+			if ( !(strcmp(path, filelist[i])) ) { /* path matched */
+				free(filelist[i]);  /* remove path */
+				filelist[i] = NULL;  /* mark position as free for use */
+				return 0;
+}
+}
+}
+
+	return -1; /* no such path */
+}
+
+
+
+
+/**
+ * Copy elements from filelist to filetable
+ *
+ * \returns CDW_OK on success (even if there are no elements)
+ *          CDW_MEM_ERROR on malloc error
+ */
+cdw_rv_t filelist_items_to_filetable(void)
+{
+	int n = 0;     /* number of items on list */
+	int fli = 0;   /* file list index */
+
+	/* first - get number of non-empty elements */
+	for (fli = 1; fli < FILELIST_SIZE; fli++) {
+		if (filelist[fli] != NULL) {
+			n++;
+}
+}
+
+	/* copy n non-empty elements to freshly allocated table */
+	if (n != 0) {
+		/* +1 for ending NULL element */
+		filetable = (char **) malloc((n + 1) * sizeof(char *));
+		if (filetable == NULL ) {
+			return CDW_MEM_ERROR;
+}
+
+		/* <low-level>table for pointers to path strings is
+		 * allocated, paths themselves also exist (and so
+		 * do pointers to them)</low-level>
+		 *
+		 * <high-level>let's copy all strings from list to
+		* table</high-level> */
+
+		int fti = 0;   /* file table index */
+		for (fli = 1; fli < FILELIST_SIZE; fli++) {
+			if (filelist[fli] != NULL) {
+				/* this line assumes that filelist outlives
+				 * filetable and pointers from filelist always
+				 * belong to filelist, e.g. you cannot free
+				* them when cleaning filetable */
+				*(filetable + fti) = filelist[fli];
+				fti++;
+}
+}
+					   *(filetable + fti) = NULL; /* NULL marks end of filetable */
+} else {
+		filetable = NULL;
+}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+ * Check whether list of files to write to CD is empty
+ *
+ * \returns false if filelist not empty, true otherwise
+ */
+bool filelist_empty(void)
+{
+	int i;
+	for (i = 1; i < FILELIST_SIZE; i++) {
+		if (filelist[i] != NULL) { /* empty elements are set to NULL */
+			return false; /* filelist not empty */
+}
+}
+
+	return true; /* filelist empty */
+}
+
+
+
+
+
+/**
+ * Return i-th element of filetable
+ *
+ * Maybe in future this function will allow to hide implementation
+ * of filetable, but now it just helps to keep all filetable-related
+ * code in one file.
+ *
+ * \returns it-h element of filetable
+ */
+char *filetable_ith_item(int i)
+{
+	return *(filetable + i);
+}
+
+
+
+
+
+/**
+ * Deallocate all elements on filetable
+ */
+void filetable_clean(void)
+{
+
+	if (filetable != NULL) {
+		/* for some reason this should not be freed.
+		FIXME: explain why
+		int n = 0;
+		while (*(filetable + n) != NULL) {
+			free(*(filetable + n));
+}
+		*/
+		free(filetable);
+		filetable = NULL;
+}
+}
+
+
+
+
+/**
+ * Count size (in terms of bytes used on hard drive) of all items pointed by paths stored in filetable
+ *
+ * \returns number of bytes used by files on hard drive
+ */
+long long filetable_dirsize(int num)
+{
+	return dirsize(filetable, num);
+}
+
+
+
+
+/**
+ * Count elements in filetable
+ *
+ * \returns number of elements in filetable
+ */
+int filetable_number(void)
+{
+	int n = 0;
+
+	if (filetable != NULL) { /* if filetable was created at all */
+		/* debug message */
+		/* fprintf(stderr, "filetable is not null\n"); */
+		while (*(filetable + n) != NULL) {
+			/* debug message */
+			/* fprintf(stderr, "   n = %d\n", n); */
+
+			n++;
+}
+}
+
+	return n;
+}
+
+
+
+
+
+/* from cdw_ui_main.c */
+
+
+/* ******* unused code below ******* */
+
+#if 0
+
+cdw_rv_t cdw_title_create(void)
+{
+	int title_len = strlen(PACKAGE) + 2 + strlen(VERSION) + 9;
+	cdw_title = (char *) malloc(title_len);
+	if (cdw_title == NULL) {
+		return CDW_MEM_ERROR;
+}
+
+	sprintf(cdw_title,
+		/* 2TRANS: fancy application title in main cdw window:
+		first %s is app name, second %s is app version */
+		_("::: %s-%s :::"), PACKAGE, VERSION);
+
+	return CDW_OK;
+}
+
+
+
+
+
+void cdw_title_clean(void)
+{
+	if (cdw_title != NULL) {
+		free(cdw_title);
+		cdw_title = NULL;
+}
+
+	return;
+}
+
+
+
+
+
+/**
+ * Remove menu containing cdw commands
+ *
+ * Remove menu in left part of cdw window. This function is
+ * called at the end of the program.
+ */
+void main_menu_clean(void)
+{
+	int i;
+	if (main_menu != NULL) {
+		unpost_menu(main_menu);
+		free_menu(main_menu);
+		main_menu = NULL;
+
+		for (i = 0; main_menu_items[i] != (ITEM *)NULL; i++){
+			free_item(main_menu_items[i]);
+			main_menu_items[i] = (ITEM *)NULL;
+}
+
+		free(main_menu_items);
+		main_menu_items = (ITEM **)NULL;
+
+		/* we don't free cdw menu labels since they are static char strings */
+}
+	return;
+}
+
+
+
+
+
+/**
+ * Remove menu containing paths selected for recording to CD
+ *
+ * Remove menu in central part of cdw window. This function is
+ * called either when user adds/removes files to list (every time
+ * new list (in fact: ncurses menu) is allocated, so previous
+ * version must be cleaned up) or at the end of the program.
+ */
+void selected_view_menu_clean(void)
+{
+	int i;
+	if (selected_files_menu != NULL) {
+		unpost_menu(selected_files_menu);
+		free_menu(selected_files_menu);
+		selected_files_menu = NULL;
+
+		for (i = 0; i < num; i++) {
+			free_item(selected_files_items[i]);
+			selected_files_items[i] = NULL;
+}
+
+		if (selected_files_items != NULL ){
+			free(selected_files_items);
+			selected_files_items = NULL;
+}
+}
+
+	return;
+}
+
+
+
+
+
+/**
+ * Refresh content of main app window
+ *
+ * Refresh content of main app window - the one containing menu
+ * on the left and selected files/dirs list on the right + some
+ * statistics at the bottom. This may need reading (possibly)
+ * changed content of files-to-cd listing.
+ *
+ * \param bool real - do you want to refresh content of main
+ *        window by re-reading it from listing on hard-disk
+ *        (may be time-consuming)?
+ *
+ * \returns CDW_GEN_ERROR when some errors occurred (in this situation
+ *                 if function was called with real==true continuing
+ *                 may lead to serious errors)
+ *          CDW_OK otherwise
+ */
+int select_window(bool real)
+{
+	/* Do time-consuming refresh of file list?
+	* It is time consuming, because this is not ordinary curses
+	* wrefresh(), this code has to allocate some memory and move data from
+	* one place to another and print this data to screen. */
+	if (real) {
+		selected_files_menu_regenerate();
+		files_info_view_recalculate_data();
+}
+
+	/* redraws frames and it's content at the bottom of window
+	(below selected files list) */
+	files_info_view_show_data();
+
+	wrefresh(main_cdw_win);
+
+	return CDW_OK;
+}
+
+#endif
+
+
+
+/* from cdw_widgets.c */
+
+
+/* *** unused code below *** */
+
+#if 0
+
+
+
+
+
+/**
+ * \brief Show dialog window with title, message and buttons
+ *
+ * Show dialog window with title and message. Depending on type of dialog
+ * user is presented with one, two or three buttons: value of
+ * parameter 'dialog_type' describes them.
+ *
+ * Function returns value of selected button. If user pressed Enter then it is:
+ * CDW_OK for 'Yes' or 'OK', CDW_CANCEL for 'Cancel', CDW_NO for 'No'.
+ *
+ * If user pressed Escape then function returns CDW_CANCEL.
+ *
+ * Background color depends on 'cdw_colors' value.
+ *
+ * \param title - dialog window title
+ * \param message - message displayed in dialog window
+ * \param dialog_type - type of dialog - values defined in header
+ * \param cdw_colors - color scheme of dialog
+ *
+ * \return value of type cdw_rv_t, corresponding to selected button
+ * \return CDW_MEM_ERROR on malloc error
+ */
+cdw_rv_t dialogbox(const char *title, const char *message, int dialog_type, int cdw_colors)
+{
+	/* 2TRANS: this is 'OK' button label:
+	please keep as short as possible */
+	ok_string = make_string(_("OK"));
+	/* 2TRANS: this is 'Yes' button label:
+	please keep as short as possible */
+	yes_string = make_string(_("Yes"));
+	/* 2TRANS: this is 'No' button label:
+	please keep as short as possible */
+	no_string = make_string(_("No"));
+	/* 2TRANS: this is 'Cancel' button label:
+	please keep as short as possible */
+	cancel_string = make_string(_("Cancel"));
+
+	if (ok_string == (char *) NULL || yes_string == (char *) NULL ||
+		   no_string == (char *) NULL || cancel_string == (char *) NULL) {
+
+		dialogbox_dealloc();
+		return CDW_MEM_ERROR;
+}
+
+		   /* initial dialog WINDOW size: maxwidth and maxline */
+		   size_t maxline = 0, maxwidth = 30;
+
+	/* change values of maxline and maxwidth so that window
+		   will be big enough to display whole message */
+		   dialogbox_calculate_sizes(&maxline, &maxwidth, message);
+
+	/* note two numerical values - 6 and 4; maxline and maxwidth describe
+		   * number of columns and lines used to display message; we need
+	* additional space for borders, spacing and buttons */
+		   WINDOW *window = newwin(maxline + 6, maxwidth + 6, (LINES - (maxline + 6)) / 2, (COLS - maxwidth + 6) / 2);
+		   wbkgd(window, COLOR_PAIR(cdw_colors));
+		   werase(window);
+		   nice_box(window, title, "");
+		   keypad(window, TRUE);
+
+
+		   dialogbox_display_message(window, message);
+
+	/* currently selected button, set by dialogbox_display_buttons(),
+		   based on dialog_type */
+		   int current_button;
+
+		   dialogbox_display_buttons(window, &current_button, dialog_type, cdw_colors);
+
+		   wrefresh(window);
+
+		   cdw_rv_t dialogbox_crv = dialogbox_driver(window, current_button, dialog_type);
+
+		   int begx, begy, maxx, maxy;
+		   getbegyx(window, begy, begx);
+		   getmaxyx(window, maxy, maxx);
+		   delwin(window);
+		   main_win_refresh_part(maxy, maxx, begy, begx);
+
+
+		   dialogbox_dealloc();
+
+
+		   return dialogbox_crv;
+}
+
+
+
+
+
+/**
+ * \brief Recalculate window size based on message length
+ *
+ * Change values of window height and width (maxline and maxwidth)
+ * so that window will be big enough to display whole message.
+ *
+ * \param maxline - height of dialog window
+ * \param maxwidth - width of dialog window
+ * \param message - message that will be displayed in the dialog window
+ */
+void dialogbox_calculate_sizes(size_t *maxline, size_t *maxwidth, const char *message)
+{
+	assert(message != (char *) NULL);
+
+	char temp[100];
+
+	temp[0] = '\0';
+	size_t i = 0;
+	size_t n = 0;
+	for (i = 0; i < strlen(message); i++){
+		if (message[i] != '\n')
+			temp[n++] = message[i];
+		if (( message[i] == '\n') || (i == strlen(message) - 1) || ((n > *maxwidth) && message[i] == ' ')) {
+			temp[n] = '\0';
+			/* it seems that without this the code works better,
+			FIXME: improve this code, so that wrapping always work
+			correctly */
+			if (*maxwidth < strlen(temp) + 8) {
+				*maxwidth = strlen(temp) + 8;
+				i += 8;
+}
+
+			temp[0] = '\0';
+			n = 0;
+			(*maxline)++;
+}
+}
+
+	return;
+}
+
+
+
+
+
+/**
+ * \brief Display message in given window
+ *
+ * This is a separate function because proper wrapping message (so that
+ * line breaks occur between words, not inside them) is not a trivial task.
+ *
+ * \param window - window in which you want to display message
+ * \param message - message to be displayed
+ */
+void dialogbox_display_message(WINDOW *window, const char *message)
+{
+	assert(window != (WINDOW *) NULL);
+	assert(message != (char *) NULL);
+
+	size_t width = getmaxx(window);
+
+	char tmp[100];
+	tmp[0] = '\0';
+	int line = 2; /* line number in dialog window, in which we write message */
+	size_t offset = 0;
+	bool linebreak = false;
+	for (offset = 0; offset < strlen(message);) {
+
+		strncpy(tmp, message + offset, width);
+
+		/* first search for line breaks in message, this works only
+		for one line break per maxwidth chars */
+		size_t j = 0;
+		for (j = 0; j < width; j++) {
+			if (tmp[j] == '\n') {
+				tmp[j] = '\0';
+				mvwprintw(window, line++,
+					  (width - strlen(tmp)) / 2, tmp);
+				/* debug message */
+				/* fprintf(stderr, "MESSAGE1 = \"%s\"\n", tmp); */
+
+				linebreak = true;
+				break;
+}
+}
+
+		if (linebreak) {
+			/* if there was one line break, there may be next one;
+			skip to 'for' loop above to once again search for
+			line break in next chunk of chars ("next" means
+			"maxwidth chars of text after current '\n'") */
+
+			/* prepare to get chunk of data that was AFTER '\n' char */
+			offset = offset + j + 1;
+
+			linebreak = false;
+			continue;
+}
+
+		/* print current chunk of strings - in whole or, if needed,
+		without last word, which is too long to display in current
+		line and would be truncated; in this case it will be displayed
+		in next line (in next cycle of top-level 'for' loop */
+		int k = 0;
+		for (k = width - 1; k >= 0; k--) {
+			if (tmp[k] == ' ' || tmp[k] == '\0') {
+				tmp[k] = '\0';
+				mvwprintw(window, line++,
+					  (width - strlen(tmp)) / 2, tmp);
+				/* debug message */
+				/* fprintf(stderr, "MESSAGE2 = \"%s\"\n", temp); */
+				break;
+}
+}
+		offset = offset + k + 1;
+}
+
+	return;
+}
+
+
+
+#endif
+
+
+
+/* from commands.c */
+
+
+/* unused code below */
+
+#if 0
+void write_files_wrapper(void)
+{
+	if (!disc_ready_for_write(0)) {
+		return;
+}
+
+	if (strcmp(config.fromimage, "1") == 0) {
+		if (access(config.tempdir, R_OK) == 0) {
+			/* Write from image */
+			run_command_cdrecord_write_from_image2();
+			conditional_eject_after_write();
+			/* 2TRANS: this is title of dialog window, displaying messages from program writing iso image to CD disc */
+			after_event("\"Write image\" log", 1);
+} else {
+			/* 2TRANS: this is title of dialog window */
+			dialogbox(_("No image file"),
+				  /* 2TRANS: this is message in dialog window, user wants to write image file to cd, but there is no such file selected, it can be selected in cdw options window */
+				  _("No image file. Please check your preferences."), DIALOG_OK);
+}
+} else if ((strcmp(config.fromimage, "0") == 0)) {
+		cdw_rv_t crv = conditional_volume_label_dialog();
+		if (crv == CDW_CANCEL) {
+			/* 2TRANS: this is title of dialog window */
+			dialogbox(_("Operation canceled"),
+				  /* 2TRANS: this is message in dialog window, writing to CD cancelled by user before it even started */
+				  _("You pressed escape - writing cancelled."), DIALOG_OK);
+			return;
+}
+		if ( ! filelist_empty() ){
+			/* Write directly from filesystem, based on list of selected files */
+			run_command_cdrecord_write_direct();
+			conditional_eject_after_write();
+			/* 2TRANS: this is title of dialog window showing output messages from program writing to CD*/
+			after_event("\"Write direct\" log", 1);
+} else {
+			/* 2TRANS: this is title of dialog window */
+			dialogbox(_("No files to write"),
+				  /* 2TRANS: this is message in dialog window, user wants to write files, but no files from hdd are selected yet */
+				  _("No files selected. Please use 'Add files'"), DIALOG_OK);
+}
+} else { /* is it really necessary? */
+		;
+}
+
+	return;
+}
+
+#endif
+
+
+
+/* from growisofs_pipe_regexp.c */
+
+
+/* unused code below */
+
+#if 0
+
+/* unused version with reading sectors written by growisofs and using this
+   information to show amount of task done */
+/**
+ * Parse output of growisofs writing data to DVD
+ *
+ * The function will be called when writing actual data (not lead-out or
+ * lead-in or session info), that is when:
+ *  - writing files directly from hdd to dvd
+ *  - when writing iso image file to dvd
+ *  - when blanking DVD (by writing from /dev/zero device)
+ *
+ * growisofs behaves similarly in these cases, but the function shows less
+ * information in processwin when blanking is performed.
+ *
+ * You should also read comment at top of the file (growisofs_writing).
+ */
+void handle_growisofs_writing_data(regex_t *regex, regmatch_t *matches)
+{
+	/* debug message */
+	fprintf(stderr, "%s() called\n", __func__);
+
+	/* data to collect */
+	/* unused in current method of calculation amount of data written */
+	/*
+	long captured_total = 0;
+	long captured_done = 0;
+	*/
+	int perc_a = 0, perc_b = 0;
+	int rem_a = 0, rem_b = 0;
+
+	/* data to calculate */
+	/* char text_info2_string[PROCESSWIN_MAX_TEXT_LEN]; */
+	char current_value_string[PROCESSWIN_MAX_TEXT_LEN];
+	char eta_string[PROCESSWIN_MAX_TEXT_LEN];
+
+	/* collect data */
+	unsigned int i;
+	for (i = 0; i < (regex->re_nsub + 1); ++i) {
+		int len = matches[i].rm_eo - matches[i].rm_so;
+		char submatch[PIPE_BUFFER_SIZE];
+		strncpy(submatch, (char *) &stdout_pipe_buffer[matches[i].rm_so], len);
+		submatch[len] = '\0';
+		if (i == 0) { /* whole string, do nothing */
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 1) { /* current amount */
+			/* unused in current method of calculation amount of data written */
+			/* captured_done = atol((char *) &submatch); */
+
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 2) { /* total amount */
+			/* unused in current method of calculation amount of data written */
+			/* captured_total = atol((char *) &submatch); */
+
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 3) { /* space */
+			/* debug message */
+			/* fprintf(stderr, "i = %d, submatch = %s\n", i, submatch); */
+} else if (i == 4) { /* paren - do nothing */
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 5) { /* space */
+			/* debug message */
+			/* fprintf(stderr, "i = %d, submatch = %s\n", i, submatch); */
+} else if (i == 6) { /* percentage - main part */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+			if (!strcmp(submatch, "??")) {
+				perc_a = 0;
+} else {
+				perc_a = atoi((char *) &submatch);
+}
+} else if (i == 7) { /* percentage - decimal part */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+			if (!strcmp(submatch, "??")) {
+				perc_b = 0;
+} else {
+				perc_b = atoi((char *) &submatch);
+}
+} else if (i == 8) { /* paren, do nothing */
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 9) { /* space */
+			/* debug message */
+			/* fprintf(stderr, "i = %d, submatch = %s\n", i, submatch); */
+} else if (i == 10) { /* speed, main part */
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 11) { /* speed, decimal point */
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 12) { /* speed, decimal part (can be empty) */
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 13) { /* space */
+			/* debug message */
+			/* fprintf(stderr, "i = %d, submatch = %s\n", i, submatch); */
+} else if (i == 14) { /* space */
+			/* debug message */
+			/* fprintf(stderr, "i = %d, submatch = %s\n", i, submatch); */
+} else if (i == 15) { /* minutes remaining */
+			if (!strcmp(submatch, "??")) {
+				rem_a = 99;
+} else {
+				rem_a = atoi(submatch);
+}
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else if (i == 16) { /* seconds remaining */
+			if (!strcmp(submatch, "??")) {
+				rem_b = 99;
+} else {
+				rem_b = atoi(submatch);
+}
+			/* debug message */
+			fprintf(stderr, "i = %d, submatch = %s\n", i, submatch);
+} else {
+			;
+}
+}
+#if 0 /* this code doesn't work in all cases; see below */
+	if (!growisofs_writing_performed) {
+		/* first run of handle_growisofs_writing_data() when
+	growisofs hasn't written any data yet, and prints to
+	stdout initial values of captured_current/captured_total */
+
+	/* calculate size of data to be written in this session */
+	calculated_total = captured_total - captured_done;
+}
+#endif
+	growisofs_writing_performed = true;
+
+#if 0
+	long calculated_done = 0;
+	/* this code doesn't work in all cases; in some cases growisofs does
+	not print size_already_on_disc_before_start_writing/target_size_on_disc
+	before starting to write to optical disc - sometimes it displays
+	first X/Y information when writing has already started - in this case
+	we cannot calculate correct value of calculated total nor
+	calculated_done */
+	if (current_command == COMMAND_GROWISOFS_WRITE_ISO_IMAGE
+	|| current_command == COMMAND_GROWISOFS_WRITE_DIRECT) {
+	/* FIX_ME: why exclude COMMAND_GROWISOFS_BLANK? */
+
+	calculated_done = calculated_total - (captured_total - captured_done);
+
+	/* compute data */
+		/* 2TRANS: this is string displayed in process progress window;
+	first %d is amount of data already written, second %d is
+	total amount of data to be written */
+	sprintf(current_value_string, _("%d/%d MB"),
+							(int) (calculated_done/(1024 * 1024)),
+							(int) (calculated_total/(1024 * 1024)));
+
+
+							/* display data */
+							conditional_processwin_display_progress((int) (calculated_done/(1024 * 1024)),
+							(int) (calculated_total/(1024 * 1024)),
+							current_value_string);
+}
+#endif
+
+							float percent = perc_a + 0.1 * perc_b;
+					float total_mb = 0.0;
+					float done_mb = 0.0;
+					if (current_command == COMMAND_GROWISOFS_WRITE_ISO_IMAGE) {
+						total_mb = iso_file_size_mb;
+						done_mb = (float) ((total_mb * percent) / 100.0);
+} else if (current_command == COMMAND_GROWISOFS_WRITE_DIRECT) {
+						total_mb = selected_files_size_mb;
+						done_mb = (float) ((total_mb * percent) / 100.0);
+}
+
+	/* 2TRANS: this is string displayed in process progress window;
+					first %d is amount of data already written, second %d is
+					total amount of data to be written */
+					sprintf(current_value_string, _("%.1f/%.1f MB"), done_mb, total_mb);
+
+					if (current_command == COMMAND_GROWISOFS_BLANK) {
+						total_mb = ;
+						done_mb = percent;
+						current_value_string[0] = '\0';
+}
+
+					conditional_processwin_display_progress((int) (done_mb), (int) (total_mb),
+							current_value_string);
+
+
+					/* debug messages */
+					fprintf(stderr, "%s(): iso_file_size_mb = %f, selected_files_size_mb = %f, total_mb = %f\n", __func__, iso_file_size_mb, selected_files_size_mb, total_mb);
+					fprintf(stderr, "%s(): total_mb = %f, percent = %f, done_mb = %f, (percent * total_mb) / 100.0 = %f\n", __func__, total_mb, percent, done_mb, (percent * total_mb) / 100.0);
+					fprintf(stderr, "%s(): current_value_string = %s, \n", __func__, current_value_string);
+
+
+					if (current_command == COMMAND_GROWISOFS_WRITE_ISO_IMAGE) {
+		/* 2TRANS: this is string displayed in process progress window;
+						writing iso image to DVD disc is in progress */
+						processwin_display_text_info(NULL, _("Writing image in progress..."));
+} else if (current_command == COMMAND_GROWISOFS_WRITE_DIRECT) {
+		/* 2TRANS: this is string displayed in process progress window;
+						writing selected files to DVD disc is in progress */
+						processwin_display_text_info(NULL, _("Writing files in progress..."));
+} else if (current_command == COMMAND_GROWISOFS_BLANK) {
+		/* 2TRANS: this is string displayed in process progress window;
+						blanking DVD disc is in progress */
+						processwin_display_text_info(NULL, _("Blanking of DVD in progress..."));
+} else {
+						processwin_display_text_info(NULL, "");
+}
+
+	/* 2TRANS: this is message displayed in process progress window:
+					ETA stands for time left to end of process, first %d is amount of
+					minutes left, second %d is amount of seconds left */
+					sprintf(eta_string, _("ETA: %2d:%02d"), rem_a, rem_b);
+					processwin_display_eta(eta_string);
+					wrefresh(processwin);
+
+					/* debug message */
+					fprintf(stderr, "%s(): eta_string = %s, rem_a = %d, rem_b = %d\n", __func__, eta_string, rem_a, rem_b);
+					fprintf(stderr, "\n\n");
+
+					return;
+}
+
+
+#endif
+
+
+
+
+/* from mkisofs_interface.c */
+
+/* UNUSED CODE BELOW */
+
+
+#if 0
+/**
+ * Create 'char *' string containing program name and program's argument
+ * for creating iso image
+ *
+ * iso image is created in two different situations:
+ * - when user only creates iso image (this is explicit creation,
+ *   image file is written to disk)
+ * - when user writes directly to CD disk - iso image is piped to
+ *   program writing it to cd
+ * .
+ * Both cases are very similar, only in second case there is no output file,
+ * since CD writing program reads from pipe (from its stdin).
+ * This function appends output image file name to command (it takes it from
+ * config.tempdir).
+ *
+ * \param char *command - string for program name and it's parameters
+ * \param char *iso_file - path (full or relative) to output iso file + file
+ *                         name with extension; set parameter to empty string
+ *                         it you don't want to write image to file
+ *
+ * \returns -1 on malloc error, 0 on success
+ */
+int prepare_createiso_command(char *command, char *iso_file)
+{
+	int last_sess_start = 0, next_sess_start = 0;
+	/* does current disc have any session already? */
+	bool ismulti = false;
+
+	/* 'graft points' means text file with list of files to burn AND root
+	* directories on CD that the files will be put into;
+	* see also -path-list argument below */
+	sprintf(command, "%s  -graft-points -iso-level 2", MKISOFS);
+
+	/* get some information about possible previous session(s) on disc
+	* currently in drive, but only if we are writing files directly
+	* to cd, otherwise multisession information in image file is wrong;
+	* do this check so early, this way we may avoid running external
+	* process */
+	if (strlen(iso_file) == 0) {
+		if (strcmp(config.multi, "1") == 0) {
+			/* fprintf(stderr, "config.multi = 1\n"); */
+			int ism = get_multisession_tracks(&last_sess_start, &next_sess_start);
+
+			/* debug code */
+			/* fprintf(stderr, "%s(): ism = %d\n", __func__, ism); */
+
+			if (ism == 0) {
+				ismulti = false;
+} else if (ism == 1) {
+				/* debug code */
+				/* fprintf(stderr, "%s(): last_sess_start=%d, next_sess_start=%d\n", __func__, last_sess_start, next_sess_start); */
+
+				ismulti = true;
+} else {
+				return -1;
+}
+} else {
+			/* fprintf(stderr, "config.multi = 0\n"); */
+			ismulti = false;
+}
+} else { /* name of output image file is empty string */
+		ismulti = false; /* just to be sure */
+}
+
+	/* debug code
+	if (ismulti) {
+		fprintf(stderr, "tested: ismulti\n");
+} else {
+		fprintf(stderr, "tested: is not ismulti\n");
+} */
+
+	/* append multisession track info, but only if we are writing image to
+	* stdout and disk is multisession (already has at least one session);
+	* '-M' points to file with last session that we want to merge
+	* currently created image */
+	if (ismulti)  {
+		/* fprintf(stderr, "appending multisession info\n"); */
+		sprintf(command, "%s -C %d,%d -M %s ", command, last_sess_start, next_sess_start, config.cdrw_device);
+}
+
+	if (strcmp(config.joliet, "1") == 0) {
+		strcat(command, " -J");
+}
+	if (strcmp(config.rockridge, "1") == 0) {
+		strcat(command, " -r");
+}
+
+	if (strlen(config.bootimg)) {
+		sprintf(command, "%s -b %s -c boot.catalog -no-emul-boot ", command, config.bootimg);
+}
+
+	if (strlen(config.volumeid) == 0) {
+		strcpy(config.volumeid, DEFAULT_VOLUMEID);
+}
+
+	if (strlen(iso_file)) { /* write iso file to disk (to iso_file) */
+		sprintf(command, "%s -V\"%s\" -o %s -path-list %s ", command, config.volumeid, iso_file, graftpoints_fullpath);
+} else { /* no output iso file - write to stdout, someone will read it */
+		sprintf(command, "%s -V\"%s\" -path-list %s ", command, config.volumeid, graftpoints_fullpath);
+}
+
+	sprintf(command, "%s%c", command, '\0');
+
+	return 0;
+}
+
+
+
+
+
+/**
+ * Get information from multisession disc about sessions track numbers
+ *
+ * Correct values will be retrieved by calling "wodim -msinfo"
+ *
+ * \param int *last_sess_start - first sector in the last session of the disc
+ * \param int *next_sess_start - the starting sector number of the new session
+ *
+ * \returns 0 if disc is not multisession, 1 if the disc is multisession, -1 if error occurred
+ */
+int get_multisession_tracks(int *last_sess_start, int *next_sess_start)
+{
+	/*
+	int cddev;
+
+	if ( (cddev=open(config.cdrw_device, O_RDONLY | O_NONBLOCK)) != -1 ){
+		int rv = ioctl(cddev, CDROM_DRIVE_STATUS, 0);
+		close(cddev);
+		if (rv == CDS_NO_DISC) {
+			fprintf(stderr, "NOCD\n");
+}
+}
+	*/
+
+	int cdr_len = strlen(CDRECORD);
+	int scsi_len = strlen(config.scsi);
+	/* 13 to fit chars in quotes, 1 for ending null */
+	char *msinfo = (char *) malloc(13 + cdr_len + scsi_len + 1);
+	if (msinfo == NULL) {
+		return -1;
+}
+
+	sprintf(msinfo, "%s dev=%s -msinfo", CDRECORD, config.scsi);
+
+	/* debug code */
+	/* fprintf(stderr, "get_multisession_tracks(): msinfo = \"%s\"\n", msinfo); */
+
+	/* 2TRANS: this is message in dialog window, displayed when
+	program reads some meta-data from cd */
+	processwin_create(_("Load CD info..."), "", false);
+	run_command(msinfo);
+	processwin_destroy("", false);
+	free(msinfo);
+	msinfo = NULL;
+
+	FILE *fp = fopen(config.log_full_path, "r");
+	if (fp == NULL) {
+		clean_before_cdw_exit();
+		/* 2TRANS: this is message in dialog window, displayed when
+		program cannot find log file and exits */
+		fprintf(stderr, _("Cannot open log file..."));
+		exit(-1);
+}
+	char *line = (char *) malloc(1024);
+	if (line == NULL) {
+		return -1;
+}
+	*last_sess_start = 0;
+	*next_sess_start = 0;
+	bool ismulti = false;
+	while ((line = fgets(line, 256, fp)) != NULL) {
+		/* debug code */
+		/* fprintf(stderr, "line to scan for session information: %s\n", line); */
+
+		int rv = sscanf(line, "%d,%d", last_sess_start, next_sess_start);
+
+		if (rv == 2) {
+			/* debug code */
+			/* fprintf(stderr, "%d,%d", *last_sess_start, *next_sess_start); */
+			/* fprintf(stderr, " - last session information available\n"); */
+
+			ismulti = true;
+			break; /* don't check any other lines! */
+} else {
+			/* debug code */
+			/* fprintf(stderr, "%d,%d", *last_sess_start, *next_sess_start); */
+			/* fprintf(stderr, " - no session info in this line, sscanf return value = %d\n\n\n", rv); */
+
+			ismulti = false;
+}
+}
+
+	fclose(fp);
+	free(line);
+	line = NULL;
+
+	if (ismulti) {
+		return 1;
+} else {
+		return 0;
+}
+}
+
+
+
+
+
+
+
+
+#endif
+
+
+
+
+/* from options_logic.c */
+
+
+#if 0 /* unused code */
+
+
+/**
+ * \brief Read config file, store configuration in data structure
+ *
+ * Read config file line by line and store values found in that file into data
+ * structure. This is low level function that deals with disk file. It should
+ * be called by other function that will open file with correct permissions
+ * before passing it to this function.
+ * Config data structure is global.
+ *
+ * \param FILE *conf_file - config file opened for reading
+ */
+void read_config_file_old(FILE *conf_file)
+{
+	/* ex_FIX_ME: lengths of these buffers limit length of some options, e.g. 'other' */
+	char option_buffer[OPTION_FIELD_LEN_MAX + 10 + 40];
+	char opt[40], prop[OPTION_FIELD_LEN_MAX];
+
+	while (NULL != fgets(option_buffer, 1000, conf_file)) { /* read config file line by line */
+		if ( sscanf(option_buffer, "%40[^=]=%[^\n]", opt, prop) == 2 ) {
+			if ( (strcmp(opt,"scsi-dev")) == 0 )
+				strcpy(config.scsi, prop);
+			if ( (strcmp(opt,"scsi")) == 0 )
+				strcpy(config.scsi, prop); /* repeated because of "option name - option variable name" inconsistency */
+			if ( (strcmp(opt,"cdrwdevice")) == 0 )
+				strcpy(config.cdrw_device, prop);
+			if ( (strcmp(opt,"cdrw_device")) == 0 )
+				strcpy(config.cdrw_device, prop);
+			if ( (strcmp(opt,"tempdir")) == 0 )
+				/* WARNING: tempdir is now a pointer, rewrite this line in if reusing this code */
+				strcpy(config.tempdir, prop);
+#if 0 /* cdw since 0.4.0 no longer reads speed from config file - it reads speed range now */
+			if ( (strcmp(opt,"speed")) == 0 ) /* kept for backward compatibility */
+							 strcpy(config.speed, prop);
+#endif
+			if ( (strcmp(opt,"speed_range")) == 0 )
+				 config.speed_range = atoi(prop);
+			if ( (strcmp(opt,"other")) == 0 ) /* kept for backward compatibility */
+				strcpy(config.other, prop);
+			if ( (strcmp(opt,"other_cdrecord_options")) == 0 )
+				strcpy(config.other_cdrecord_options, prop);
+			if ( (strcmp(opt,"other_mkisofs_options")) == 0 )
+				strcpy(config.other_mkisofs_options, prop);
+			if ( (strcmp(opt,"other_growisofs_options")) == 0 )
+				strcpy(config.other_growisofs_options, prop);
+			if ( (strcmp(opt,"blank")) == 0 )
+				strcpy(config.blank, prop);
+			if ( (strcmp(opt,"logfile")) == 0 )
+				strcpy(config.log_full_path, prop);
+			if ( (strcmp(opt,"eject")) == 0 )
+				strcpy(config.eject, prop);
+			if ( (strcmp(opt,"dao")) == 0 )
+				strcpy(config.dao, prop);
+			if ( (strcmp(opt,"joliet")) == 0 )
+				strcpy(config.joliet, prop);
+			if ( (strcmp(opt,"rockridge")) == 0 )
+				strcpy(config.rockridge, prop);
+			if ( (strcmp(opt,"dummy")) == 0 )
+				strcpy(config.dummy, prop);
+			if ( (strcmp(opt,"volumeid")) == 0 )
+				strcpy(config.volumeid, prop);
+			if ( (strcmp(opt,"cdrom")) == 0 )
+				strcpy(config.cdrom, prop);
+			if ( (strcmp(opt,"usefulRR")) == 0 )
+				strcpy(config.usefulRR, prop);
+			if ( (strcmp(opt,"showlog")) == 0 )
+				strcpy(config.showlog, prop);
+			if ( (strcmp(opt,"showvol")) == 0 )
+				strcpy(config.showvol, prop);
+			if ( (strcmp(opt,"iso_level")) == 0 )
+				strcpy(config.iso_level, prop);
+			if ( (strcmp(opt,"cdsize")) == 0 )
+				config.cdsize=atoi(prop);
+			if ( (strcmp(opt,"pad")) == 0 )
+				strcpy(config.pad, prop);
+			if ( (strcmp(opt,"WriteFromImage")) == 0 )
+				strcpy(config.fromimage, prop);
+			if ( (strcmp(opt,"fromimage")) == 0 ) /* repeated because of "option name - option variable name" inconsistency */
+				strcpy(config.fromimage, prop);
+			if ( (strcmp(opt,"multi")) == 0 )
+				strcpy(config.multi, prop);
+			if ( (strcmp(opt,"burnproof")) == 0 )
+				strcpy(config.burnproof, prop);
+			if ( (strcmp(opt,"mountpoint")) == 0 )
+				strcpy(config.mountpoint, prop);
+			if ( (strcmp(opt,"autodic")) == 0 )
+				strcpy(config.autodic, prop);
+			if ( (strcmp(opt,"audiodir")) == 0 )
+				strcpy(config.audiodir, prop);
+			if ( (strcmp(opt,"stereo")) == 0 )
+				strcpy(config.stereo, prop);
+			if ( (strcmp(opt,"bitsperchn")) == 0 )
+				strcpy(config.bitsperchn, prop);
+			if ( (strcmp(opt,"echosound")) == 0 )
+				strcpy(config.echosound, prop);
+			if ( (strcmp(opt,"encode")) == 0 )
+				strcpy(config.encode, prop);
+			if ( (strcmp(opt,"lame")) == 0 )
+				strcpy(config.lame, prop);
+			if ( (strcmp(opt,"highq")) == 0 )
+				strcpy(config.highq, prop);
+			if ( (strcmp(opt,"bitrate")) == 0 )
+				strcpy(config.bitrate, prop);
+			if ( (strcmp(opt,"cdbhost")) == 0 )
+				strcpy(config.cdbhost, prop);
+			if ( (strcmp(opt,"cdbuser")) == 0 )
+				strcpy(config.cdbuser, prop);
+			if ( (strcmp(opt,"sqlite_file")) == 0 )
+				strcpy(config.sqlite_file, prop);
+			if ( (strcmp(opt,"bootimg")) == 0 )
+				strcpy(config.bootimg, prop);
+			if ( (strcmp(opt,"user_cdsize")) == 0 )
+				config.user_cdsize=atoi(prop);
+} /* if */
+} /* while */
+
+	/* resolving backward compatibility issues */
+	int len_old = strlen(config.other);
+	int len_new = strlen(config.other_cdrecord_options);
+	if ( ((len_old > 0) && (len_new == 0)) || (len_old > len_new)) {
+		/* if older version of variable contains more than
+		new version of variable... */
+		if (len_old > OPTION_FIELD_LEN_MAX) {
+			len_old = OPTION_FIELD_LEN_MAX; /* UGLY! */
+}
+		strncpy(config.other_cdrecord_options, config.other, len_old);
+}
+
+	return;
+}
+
+
+#endif
+
+
+
+
+
+#if 0 /* duplicate code, the functions are defined in options_ui.c */
+
+
+/**
+ * Handle keys while second page of preferences window is displayed
+ *
+ * Handle keys while second page of preferences window is displayed. Function
+ * redraws preferences window to show updated values of options.
+ * Function returns after user hits F_1, F_10 or ESCAPE.
+ *
+ * \param FORM **form_page - current page of multi-page form
+ * \param FIELD **fields - fields available on current page
+ *
+ * \return CDW_ESCAPE - exit preferences window, no changes should be saved,
+ *         KEY_F(10) - exit preferences window, changes should be permanently saved
+ *         KEY_F(1) - change preferences tab, changes should be temporarily saved
+ */
+int second_page_driver(FORM *cur_form_page, FIELD **fields)
+{
+	int ch = 0;
+
+	curs_set(1); /* turn cursor on */
+	form_driver(cur_form_page, REQ_END_LINE);
+
+	while ( (ch = wgetch(optwin)) != CDW_ESCAPE ){
+		switch(ch){
+	case KEY_HOME:
+				form_driver(cur_form_page, REQ_BEG_LINE);
+				break;
+	case KEY_END:
+				form_driver(cur_form_page, REQ_END_LINE);
+				break;
+	case KEY_LEFT:
+				form_driver(cur_form_page, REQ_PREV_CHAR);
+				break;
+	case KEY_RIGHT:
+				form_driver(cur_form_page, REQ_NEXT_CHAR);
+				break;
+	case KEY_DOWN:
+	case '\t':
+				form_driver(cur_form_page, REQ_NEXT_FIELD);
+				form_driver(cur_form_page, REQ_END_LINE);
+				break;
+	case KEY_UP:
+	case KEY_BTAB:
+				form_driver(cur_form_page, REQ_PREV_FIELD);
+				form_driver(cur_form_page, REQ_END_LINE);
+				break;
+	case KEY_BACKSPACE:
+				form_driver(cur_form_page, REQ_DEL_PREV);
+				break;
+	case KEY_DC:
+				form_driver(cur_form_page, REQ_DEL_CHAR);
+				break;
+	case KEY_F(1):
+	case KEY_F(3):
+	case KEY_F(10):
+				form_driver(cur_form_page, REQ_VALIDATION);
+				curs_set(0); /* turn cursor off */
+				return ch;
+	default:
+				form_driver(cur_form_page, ch);
+				break;
+
+} /* switch */
+		wrefresh(optwin);
+}
+
+	curs_set(0); /* turn cursor off */
+
+	return ch;
+}
+
+
+
+
+
+/**
+ * Handle keys while third page of preferences window is displayed
+ *
+ * Handle keys while third page of preferences window is displayed. Function
+ * redraws preferences window to show updated values of options.
+ * Function returns after user hits F_1, F_2, F_10 or ESCAPE.
+ *
+ * \param FORM **form_page - current page of multi-page form
+ * \param FIELD **fields - fields available on current page
+ *
+ * \return CDW_ESCAPE - exit preferences window, no changes should be saved,
+ *         KEY_F(10) - exit preferences window, changes should be permanently saved
+ *         KEY_F(1), KEY_F(2) - change preferences tab, changes should be temporarily saved
+ */
+int third_page_driver(FORM *cur_form_page, FIELD **fields)
+{
+	int ch = 0;
+
+	curs_set(1); /* turn cursor on */
+
+	while ( (ch = wgetch(optwin)) != CDW_ESCAPE ){
+		switch(ch){
+	case KEY_HOME:
+				form_driver(cur_form_page, REQ_BEG_LINE);
+				break;
+	case KEY_END:
+				form_driver(cur_form_page, REQ_END_LINE);
+				break;
+	case KEY_LEFT:
+				form_driver(cur_form_page, REQ_PREV_CHAR);
+				break;
+	case KEY_RIGHT:
+				form_driver(cur_form_page, REQ_NEXT_CHAR);
+				break;
+	case KEY_DOWN:
+	case '\t':
+				form_driver(cur_form_page, REQ_NEXT_FIELD);
+				form_driver(cur_form_page, REQ_END_LINE);
+				break;
+	case KEY_UP:
+	case KEY_BTAB:
+				form_driver(cur_form_page, REQ_PREV_FIELD);
+				form_driver(cur_form_page, REQ_END_LINE);
+				break;
+	case KEY_BACKSPACE:
+				form_driver(cur_form_page, REQ_DEL_PREV);
+				break;
+	case KEY_DC:
+				form_driver(cur_form_page, REQ_DEL_CHAR);
+				break;
+	case KEY_F(1):
+	case KEY_F(2):
+	case KEY_F(10):
+				form_driver(cur_form_page, REQ_VALIDATION);
+
+				curs_set(0); /* turn cursor off */
+				return ch;
+	default:
+				form_driver(cur_form_page, ch);
+				break;
+
+} /* switch */
+		wrefresh(optwin);
+}
+
+	curs_set(0); /* turn cursor off */
+	return CDW_ESCAPE; /* user pressed ESCAPE */
+}
+
+
+#endif
+
+
+
+/* from options_ui.c */
+
+
+/* **** unused code below **** */
+
+#if 0
+cdw_rv_t option_tab_names_create(void)
+{
+
+	/* 2TRANS: this is name of tab of notepad-style widget:
+	Session refers to set of tasks performed on cd */
+	prefs_tab_labels_len[0] = strlen(_("<F1>Session"));
+	/* 2TRANS: this is name of tab of notepad-style widget:
+	Session refers to set of tasks performed on cd */
+	strncpy(prefs_tab_labels[0], _("<F1>Session"), prefs_tab_labels_len[0]);
+	/* 2TRANS: this is name of tab of notepad-style widget:
+	hardware is optical disc drive */
+	prefs_tab_labels_len[1] = strlen(_("<F2>Hardware"));
+	/* 2TRANS: this is name of tab of notepad-style widget:
+	hardware is optical disc drive */
+	strncpy(prefs_tab_labels[1], _("<F2>Hardware"), prefs_tab_labels_len[1]);
+	/* 2TRANS: this is name of tab of notepad-style widget:
+	'Audio' means 'audio cd ripping preferences' */
+	prefs_tab_labels_len[2] = strlen(_("<F3>Audio"));
+	/* 2TRANS: this is name of tab of notepad-style widget:
+	'Audio' means 'audio cd ripping preferences' */
+	strncpy(prefs_tab_labels[2], _("<F3>Audio"), prefs_tab_labels_len[2]);
+
+	return CDW_OK;
+}
+
+
+#endif
+
+
+
+/* from write_wizard.c */
+
+
+/* *** unused code below *** */
+
+#if 0
+
+
+
+
+
+/** FIX_ME: this function is useful for CD only: consider changes
+ *
+ * Basing on some information calculate minimal and maximal write speed
+ *
+ * Calculate minimal and maximal write speed for disc currently in drive
+ * (of type disc_type) basing on values obtained before calling this function
+ * by running run_command_cdrecord_get_cd_info() or
+ * run_command_dvd_rw_mediainfo(). Input and output values are stored in
+ * current_disc variable.
+ *
+ * The function accepts values of config.drive_max_speed and
+ * config.drive_default_speed in range 0-99.
+ *
+ * \param cdw_simple_disc_type_t simple_type - type of disc currently in drive (CD or DVD)
+ *
+ * \returns CDW_OK on success, CDW_GEN_ERROR on error
+ */
+cdw_rv_t speed_dropdown_calculate_speed_limits(cdw_simple_disc_type_t simple_type)
+{
+	if (simple_type == CD) {
+		/* check for a few obvious error values */
+		if (current_disc.drive.max_speed < 0
+				  || current_disc.drive.default_speed < 0
+				  || current_disc.drive.max_speed > 99
+				  || current_disc.drive.default_speed > 99
+				  || current_disc.drive.default_speed > current_disc.drive.max_speed ) {
+
+			current_disc.lower_write_speed_limit = 0;
+			current_disc.upper_write_speed_limit = 0;
+
+			return CDW_GEN_ERROR;
+}
+
+				  /* do some more checking - 1T and 2T speeds */
+				  if (current_disc.cdrecord.atip_t1_low_speed < 0
+								  || current_disc.cdrecord.atip_t1_high_speed > 99
+								  || current_disc.cdrecord.atip_t2_low_speed < 0
+								  || current_disc.cdrecord.atip_t2_high_speed > 99) {
+
+					  current_disc.lower_write_speed_limit = 0;
+					  current_disc.upper_write_speed_limit = 0;
+
+					  return CDW_GEN_ERROR;
+}
+
+								  if (current_disc.cdrecord.atip_t1_low_speed == 0) {
+			/* i think that atip_t1_low_speed is always set
+									  by cdrecord to non-zero value, but just in case */
+									  current_disc.lower_write_speed_limit = 1;
+} else {
+									  current_disc.lower_write_speed_limit = current_disc.cdrecord.atip_t1_low_speed;
+}
+
+								  if (current_disc.cdrecord.atip_t1_high_speed == 0) {
+									  if (current_disc.drive.max_speed != 0) {
+										current_disc.upper_write_speed_limit = current_disc.drive.max_speed;
+} else {
+				/* if cd_drive_t1_high_speed is not set (but
+										it should) then use safe (?) default value */
+										current_disc.upper_write_speed_limit = 4;
+}
+} else {
+									  current_disc.upper_write_speed_limit = current_disc.cdrecord.atip_t1_high_speed;
+}
+} else if (simple_type == DVD) { /* this is a lot simpler */
+			/* allowed speed values are reported by
+		dvd+rw-mediainfo and are stored in
+		current_disc.dvd_rw_mediainfo.write_speed[] */
+		return CDW_OK;
+} else { /* wrong current_disc.disc_type value */
+		return CDW_GEN_ERROR;
+}
+
+	return CDW_OK;
+}
+
+
+
+
+
+
+
+
+/**
+ * Generate list of strings representing valid writing speeds
+ *
+ * Based on values of some fields of current_disc generate list of
+ * (char *) strings representing valid writing speeds for given disc.
+ * Last element of the list should be (char *)NULL.
+ *
+ * We need (char *) strings, because the list will be passed to
+ * cdw_dropdown_new(), which accepts list of strings and not list of ints.
+ *
+ * The function works for both CD and DVD.
+ *
+ * The list should be freed using x_dropdown_labels_destroy().
+ *
+ * \returns CDW_OK on success
+ *          CDW_MEM_ERROR on malloc() error
+ *          CDW_GEN_ERROR on other errors
+ */
+cdw_rv_t speed_dropdown_labels_build(cdw_simple_disc_type_t simple_type)
+{
+	/* place for int values of allowed speeds,
+	before they will be converted to char strings */
+	int speed_table[20];
+
+	cdw_rv_t crv = speed_dropdown_calculate_speed_limits(simple_type);
+	if (crv != CDW_OK) {
+		return crv;
+}
+
+	int n_speeds = 0;
+	if (simple_type == CD) {
+		/* speeds that can possibly be accepted by a drive;
+		* last value is a guard */
+		int generic_cd_speed_table[SPEED_TABLE_SIZE + 1] = { 1, 2, 4, 6, 8, 10, 12, 16, 20, 32, 36, 40, 48, 52, -1};
+
+		/* current_disc fields store boundary values of speeds
+		* accepted by current CD/drive, let's check which speeds from
+		* generic_cd_speed_table[] fit into these boundaries */
+		int i = 0;
+		int j = 0;
+		for (i = 0; generic_cd_speed_table[i] != -1; i++) {
+			/* select only those values, which fit into range accepted by drive */
+			if ((generic_cd_speed_table[i] >= current_disc.lower_write_speed_limit)
+						  && (generic_cd_speed_table[i] <= current_disc.upper_write_speed_limit)) {
+
+				speed_table[j] = generic_cd_speed_table[i];
+				j++;
+}
+}
+		n_speeds = j;
+} else if (simple_type == DVD) {
+		/* in case of dvd we already have list of speeds acceptable by
+		disc (it is extracted from disc itself */
+		/* TO_DO: check if list of values extracted from dvd always
+		fit into range of speeds accepted by DRIVE */
+		int i = 0;
+		for (i = 0; i < 20; i++) {
+			if (current_disc.dvd_rw_mediainfo.write_speed[i] == 0) {
+				break;
+} else {
+				speed_table[i] = current_disc.dvd_rw_mediainfo.write_speed[i];
+
+				/* debug message */
+				/* fprintf(stderr, "DVD: speed_table[i] = %d, current_disc.dvd_rw_mediainfo.write_speed[i] = %d\n", speed_table[i], current_disc.dvd_rw_mediainfo.write_speed[i]); */
+}
+}
+		/* speed_table[j] = -1; */ /* guard is not required, we have n_speeds */
+		n_speeds = i;
+} else {
+		return CDW_GEN_ERROR;
+}
+
+
+	/* debug messages */
+	/*
+	if (disc_type == CD) {
+	fprintf(stderr, "  >> %s(): current_disc.cd_drive_max_speed = %d\n", __func__, current_disc.cd_drive_max_speed);
+	fprintf(stderr, "  >> %s(): current_disc.cd_drive_default_speed = %d\n", __func__, current_disc.cd_drive_default_speed);
+	fprintf(stderr, "  >> %s(): current_disc.cd_drive_t1_low_speed = %d\n", __func__, current_disc.cd_drive_t1_low_speed);
+	fprintf(stderr, "  >> %s(): current_disc.cd_drive_t1_high_speed = %d\n", __func__, current_disc.cd_drive_t1_high_speed);
+	fprintf(stderr, "  >> %s(): current_disc.cd_drive_t2_low_speed = %d\n", __func__, current_disc.cd_drive_t2_low_speed);
+	fprintf(stderr, "  >> %s(): current_disc.cd_drive_t2_high_speed = %d\n", __func__, current_disc.cd_drive_t2_high_speed);
+	fprintf(stderr, "  >> %s(): current_disc.lower_limit_speed = %d\n", __func__, current_disc.lower_limit_speed);
+	fprintf(stderr, "  >> %s(): current_disc.upper_limit_speed = %d\n", __func__, current_disc.upper_limit_speed);
+	fprintf(stderr, "  >> %s(): i_lower = %d, speed_table[i_lower] = %d\n", __func__, i_lower, speed_table[i_lower]);
+	fprintf(stderr, "  >> %s(): i_upper = %d, speed_table[i_upper] = %d\n", __func__, i_upper, speed_table[i_upper]);
+	fprintf(stderr, "  >> %s() SPEED INDEXES: i_lower = %d, i_upper = %d, i_upper - i_lower = %d, n_speeds = %d\n", __func__, i_lower, i_upper, i_upper - i_lower, n_speeds);
+} else { // disc_type == DVD
+	fprintf(stderr, "  >> %s(): current_disc.dvd_write_speed_0 = %d\n", __func__, current_disc.dvd_write_speed_0);
+	fprintf(stderr, "  >> %s(): current_disc.dvd_write_speed_1 = %d\n", __func__, current_disc.dvd_write_speed_1);
+	fprintf(stderr, "  >> %s(): current_disc.lower_limit_speed = %d\n", __func__, current_disc.lower_limit_speed);
+	fprintf(stderr, "  >> %s(): current_disc.upper_limit_speed = %d\n", __func__, current_disc.upper_limit_speed);
+	fprintf(stderr, "  >> %s(): i_lower = %d, speed_table[i_lower] = %d\n", __func__, i_lower, speed_table[i_lower]);
+	fprintf(stderr, "  >> %s(): i_upper = %d, speed_table[i_upper] = %d\n", __func__, i_upper, speed_table[i_upper]);
+	fprintf(stderr, "  >> %s() SPEED INDEXES: i_lower = %d, i_upper = %d, i_upper - i_lower = %d, n_speeds = %d\n", __func__, i_lower, i_upper, i_upper - i_lower, n_speeds);
+}
+	*/
+
+	/* table of speeds as int values is ready, convert the values to (char *) strings */
+
+	char speed_string[3]; /* 3 = 2 digits + 1 ending null */
+	int i = 0;
+	for (i = 0; i < n_speeds; i++) {
+		current_disc.speed_dropdown_labels[i] = (char *) malloc(3); /* 2 chars + 1 ending '\0' */
+		if (current_disc.speed_dropdown_labels[i] == NULL) {
+			return CDW_MEM_ERROR;
+}
+
+		my_itoa2(speed_table[i], speed_string);
+		strncpy(current_disc.speed_dropdown_labels[i], speed_string, 3);
+
+		/* debug message */
+		/* fprintf(stderr, "%s(): constructed speed label: i = \"%d\", speed_dropdown_labels[i] = \"%s\", speed_string = \"%s\"\n", __func__, i, speed_dropdown_labels[i], speed_string); */
+}
+	/* obligatory ending element (guard) */
+	current_disc.speed_dropdown_labels[n_speeds] = (char *)NULL;
+
+	return CDW_OK;
+}
+
+
+/**
+ * Simple function controlling input from keyboard when focus is on dropdown.
+ *
+ * The function controls input only when dropdown is not expanded, it calls
+ * cdw_dropdown_driver() to handle keys in expanded dropdown.
+ *
+ * Function that reacts to keys and controls behavior and movement of
+ * cursor in dropdown. Tab key is recognized as key moving focus out of
+ * field (but only if dropdown is not expanded) - function returns with CDW_OK.
+ * Function returns with CDW_CANCEL on CDW_ESCAPE key (but only if dropdown
+ * is not expanded).
+ *
+ * The function saves selected value(s) in current_disc.write_mode or in
+ * config.speed when user selects the value in expanded dropdown. NOTE: the
+ * value is saved even if user escapes from wizard. This doesn't cause problems
+ * with creating process in future, it is just poor design decision. Value
+ * should be saved when user selects 'Write' in wizard.
+ *
+ * \param int *id - unused variable
+ * \param int findex - field index, identifies which dropdown has currently focus
+ *
+ * \returns CDW_OK on tab key, CDW_CANCEL on ESCAPE key
+ */
+cdw_rv_t write_wizard_dropdown_driver(int findex, int *id)
+{
+	curs_set(1); /* show cursor */
+	int c = 'z'; /* safe init value */
+	while ( (c = wgetch(wizard_win)) != CDW_ESCAPE ) {
+		switch (c) {
+	case KEY_DOWN:
+	case CDW_ENTER:
+	case ' ':
+				/* it may happen that given input field has dropdown attached */
+				if (findex == INPUT_MODE) {
+					int di = cdw_dropdown_current_item_ind(mode_dropdown);
+					cdw_dropdown_show(mode_dropdown);
+					cdw_rv_t crv = cdw_dropdown_expanded_driver(mode_dropdown, &di);
+
+					cdw_dropdown_hide(mode_dropdown);
+					redrawwin(wizard_win);
+					wrefresh(wizard_win);
+
+					if (crv == CDW_OK) {
+						cdw_dropdown_display_current_item(mode_dropdown);
+						current_disc.write_mode = mode_dropdown_ids[di];
+
+						/* debug message */
+						/* fprintf(stderr, "%s(): write mode changed to current_disc.write_mode = %d\n", __func__, current_disc.write_mode); */
+
+						/* debug code */
+						/*
+						fprintf(stderr, "%s(): Selected writing mode is ", __func__);
+						if (current_disc.write_mode == CDW_WRITE_NONE) {
+						fprintf(stderr, "CDW_WRITE_NONE\n");
+} if (current_disc.write_mode == CDW_WRITE_START_MULTI) {
+						fprintf(stderr, "CDW_WRITE_START_MULTI\n");
+} else if (current_disc.write_mode == CDW_WRITE_CREATE_SINGLE) {
+						fprintf(stderr, "CDW_WRITE_CREATE_SINGLE\n");
+} else if (current_disc.write_mode == CDW_WRITE_START_MULTI) {
+						fprintf(stderr, "CDW_WRITE_START_MULTI\n");
+} else if (current_disc.write_mode == CDW_WRITE_CONTINUE_MULTI) {
+						fprintf(stderr, "CDW_WRITE_CONTINUE_MULTI\n");
+} else if (current_disc.write_mode == CDW_WRITE_WRITE_FINAL) {
+						fprintf(stderr, "CDW_WRITE_WRITE_FINAL\n");
+} else if (current_disc.write_mode == CDW_WRITE_IMAGE) {
+						fprintf(stderr, "CDW_WRITE_IMAGE\n");
+} else {
+						fprintf(stderr, "CDW_WRITE_ERROR\n");
+}
+						*/
+
+} /* else field buffer is not updated and nothing changes */
+} else if (findex == INPUT_SPEED) {
+					int di = cdw_dropdown_current_item_ind(speed_dropdown);
+					cdw_dropdown_show(speed_dropdown);
+					cdw_rv_t crv = cdw_dropdown_expanded_driver(speed_dropdown, &di);
+
+					cdw_dropdown_hide(speed_dropdown);
+					redrawwin(wizard_win);
+					wrefresh(wizard_win);
+
+					if (crv == CDW_OK) {
+						strcpy(config.speed, current_disc.speed_dropdown_labels[di]);
+						cdw_dropdown_display_current_item(speed_dropdown);
+
+						/* debug message */
+						/* fprintf(stderr, "%s(): speed changed to config.speed = %s\n", __func__, config.speed); */
+} /* else field buffer is not updated and nothing changes */
+} else {
+					;
+}
+				c = 0;
+				break;
+	case '\t':
+{
+				/* we are leaving this field and passing
+				control to wizard window driver;
+				we don't have to save values from
+				dropdowns - it is already done; if user
+				cancels writing, these values simply
+				won't be used, and will be replaced when
+				user will run wizard next time */
+
+				curs_set(0); /* hide cursor */
+
+				redrawwin(wizard_win);
+				wrefresh(wizard_win);
+
+				return CDW_OK;
+}
+	default:
+				break;
+} /* switch (c) */
+		wrefresh(wizard_win);
+} /* while (c != CDW_ESCAPE ) */
+
+	redrawwin(wizard_win);
+	wrefresh(wizard_win);
+
+	curs_set(0); /* hide cursor */
+
+	/* we get here only when user presses escape */
+	return CDW_CANCEL;
+}
+
+
+
+
+
+
+
+
+#if 0
+
+/* unused, but with some information in Polish :) */
+cdw_rv_t mode_dropdown_get_disc_status(cdw_simple_disc_type_t simple_type)
+{
+	if (simple_type == CD) {
+		/*
+		ZAMKNIETA:
+			msinfo dla zamknitej pyty:
+
+		ATIP start of lead in:  -11745 (97:25/30)
+		ATIP start of lead out: 359848 (79:59/73)
+
+				PRZEADOWUJE i daje:
+
+		wodim: Cannot get next writable address for 'invisible' track.
+		wodim: This means that we are checking recorded media.
+		wodim: This media cannot be written in streaming mode anymore.
+		wodim: If you like to write to 'preformatted' RW media, try to blank the media first.
+		wodim: Cannot read first writable address
+
+			atip:
+		ATIP start of lead in:  -11745 (97:25/30)
+		ATIP start of lead out: 359848 (79:59/73)
+
+			toc:
+		ATIP start of lead in:  -11745 (97:25/30)
+		ATIP start of lead out: 359848 (79:59/73)
+
+		first: 1 last 2
+		track:   1 lba:         0 (        0) 00:02:00 adr: 1 control: 4 mode: 1
+		track:   2 lba:     16500 (    66000) 03:42:00 adr: 1 control: 4 mode: 1
+		track:lout lba:     18573 (    74292) 04:09:48 adr: 1 control: 4 mode: -1
+
+		BLANK:
+			toc dla pyty blank daje:
+		wodim: Cannot read TOC header
+		wodim: Cannot read TOC/PMA
+
+
+		atip - nic
+
+
+		msinfo: wodim: Cannot read session offset
+
+		APPENDABLE:
+			toc:
+		first: 1 last 1
+		track:   1 lba:         0 (        0) 00:02:00 adr: 1 control: 4 mode: 1
+		track:lout lba:      5100 (    20400) 01:10:00 adr: 1 control: 4 mode: -1
+		wodim: No CD-Text or CD-Text unaware drive.
+
+
+			atip:
+		ATIP start of lead in:  -11745 (97:25/30)
+		ATIP start of lead out: 359848 (79:59/73)
+
+
+			msinfo:
+		session offset: 0
+		0,16500
+
+		*/
+
+		/* value of disc_status is set when parsing output of
+		'cdrecord -msinfo' command; consider re-unig results of
+		run_command_cdrecord_atip() called in
+		command_write_to_opt_disc() */
+
+		fprintf(stderr, "%s(): run_command_cdrecord_msinfo() gives current_disc.disc_write_status=\"%d\"\n", __func__, current_disc.disc_write_status);
+} else { /* simple_type == DVD */
+		/* value of disc_status is in function
+		run_command_dvd_rw_mediainfo() called in
+		command_write_to_opt_disc() before calling write_wizard()
+		*/
+}
+
+	return CDW_OK;
+}
+
+
+#endif
+
+
+
+
+
+
+/* *** from cdw_disc.c *** */
+
+
+
+#if 0
+
+
+
+/**
+ * \brief Calculate upper and lower boundary of allowed writing speeds
+ *
+ * The function calculates highest and lowest value of speeds allowed for
+ * writing to a disc. It is used because this information may not be already
+ * available in disc metainfo. This function encapsulates process of
+ * calculating the values.
+ *
+ * \return CDW_GEN_ERROR if input values are invalid and function cannot calculate results or current_disc.simple_type is invalid
+ * \return CDW_OK on success
+ */
+cdw_rv_t cdw_disc_calculate_write_speeds_limits(void)
+{
+	if (current_disc.simple_type == CD) {
+		/* check for a few obvious error values */
+		if (current_disc.drive.max_speed < 0
+			|| current_disc.drive.default_speed < 0
+			|| current_disc.drive.max_speed > 99
+			|| current_disc.drive.default_speed > 99
+			|| current_disc.drive.default_speed > current_disc.drive.max_speed ) {
+
+			current_disc.lower_write_speed_limit = 0;
+			current_disc.upper_write_speed_limit = 0;
+
+			// return CDW_GEN_ERROR;
+		}
+
+		/* do some more checking - 1T and 2T speeds */
+		if (current_disc.cdrecord.atip_t1_low_speed < 0
+			|| current_disc.cdrecord.atip_t1_high_speed > 99
+			|| current_disc.cdrecord.atip_t2_low_speed < 0
+			|| current_disc.cdrecord.atip_t2_high_speed > 99) {
+
+			current_disc.lower_write_speed_limit = 0;
+			current_disc.upper_write_speed_limit = 0;
+
+			// return CDW_GEN_ERROR;
+		}
+
+		if (current_disc.cdrecord.atip_t1_low_speed == 0) {
+			/* I think that atip_t1_low_speed is always set
+			   by cdrecord to non-zero value, but just in case */
+			current_disc.lower_write_speed_limit = 1;
+		} else {
+			current_disc.lower_write_speed_limit = current_disc.cdrecord.atip_t1_low_speed;
+		}
+
+		if (current_disc.cdrecord.atip_t1_high_speed == 0) {
+			if (current_disc.drive.max_speed != 0) {
+				current_disc.upper_write_speed_limit = current_disc.drive.max_speed;
+			} else {
+				/* if cd_drive_t1_high_speed is not set (but
+				   it should) then use safe (?) default value */
+				current_disc.upper_write_speed_limit = 4;
+			}
+		} else {
+			current_disc.upper_write_speed_limit = current_disc.cdrecord.atip_t1_high_speed;
+		}
+		cdw_sdm ("upper_write_speed_limit = %d, lower_write_speed_limit = %d\n", current_disc.upper_write_speed_limit, current_disc.lower_write_speed_limit);
+		return CDW_OK;
+	} else if (current_disc.simple_type == DVD) { /* this is a lot simpler */
+		/* allowed speed values are reported by
+		   dvd+rw-mediainfo and are stored in
+		   current_disc.dvd_rw_mediainfo.write_speed[] */
+		return CDW_OK;
+	} else { /* wrong current_disc.disc_type value */
+		return CDW_GEN_ERROR;
+	}
+}
+
+
+
+
+
+#endif
+
+
+
+
+
+/* *** code from cdw_string.h *** */
+
+
+
+
+#if 0 /* unused, replaced by standard strdup() */
+
+/**
+ * \brief Allocate space for given string, copy input string to allocated space
+ *
+ * You have to remember to free() the string when no longer used.
+ * I created this function because pattern:
+ * strlen() + malloc() + check results of malloc + strncpy()
+ * was used in few places, so I wrapped it in this utility function. Note
+ * that in some places this combination/pattern will have to be used explicitly,
+ * so the function has limited use.
+ *
+ * The function also works for string of length = 0.
+ *
+ * \param in_string - valid string that has to be put in new space
+ *
+ * \return pointer to fresh string
+ * \return NULL if problems occurred or invalid argument
+ */
+char *make_string(const char *in_string)
+{
+	if (in_string == NULL) {
+		return NULL;
+	}
+
+	size_t len = strlen(in_string);
+
+	char *out_string = (char *) malloc(len + 1);
+	if (out_string == NULL) {
+		return NULL;
+	}
+
+	strncpy(out_string, in_string, len + 1);
+
+	return out_string;
+}
+
+
+
+/* replaced by strndup */
+/**
+ * \brief Allocate space for n chars, initialize it with given string
+ *
+ * This is modification of make_string() that allocates buffer of
+ * given size. Length of initialization string must be no greater
+ * than required size. If strlen(in_string) > len, copy of in_string
+ * in allocated buffer will be truncated to fit into buffer.
+ *
+ * You have to remember to free() the string when it is no longer used.
+ *
+ * I created this function because pattern:
+ * strlen() + malloc() + check results of malloc + strncpy()
+ * was used in few places, so I wrapped it in this utility function. Note
+ * that in some places this combination/pattern will have to be used explicitly,
+ * so the function has limited use.
+ *
+ * Argument \p in_string must be non-NULL string ended with '\0'. If this
+ * argument is NULL, function will return NULL. Empty string ("") is allowed.
+ *
+ * Argument \p n must be non-negative value. In case of \p n == 0 the
+ * function creates empty result string. Value of \p n does not include
+ * space for char '\0' ending result string.
+ *
+ * If length of \p input string is less than length of result string,
+ * content of remainder of result string is unspecified by this comment,
+ * although since this function currently uses strncpy(), you can assume
+ * that the remainder is padded with null bytes.
+ *
+ * \param in_string - string that has to be copied in result string
+ * \param n - size of buffer that you want to allocate
+ *
+ * \return pointer to fresh string
+ * \return NULL if problems occurred or if in_string == NULL
+ */
+char *make_n_string(const char *in_string, size_t n)
+{
+	if (in_string == NULL) {
+		return NULL;
+	}
+
+	char *out_string = (char *) malloc(n + 1);
+	if (out_string == NULL) {
+		return NULL;
+	}
+
+	strncpy(out_string, in_string, n);
+	out_string[n] = '\0';
+
+	return out_string;
+}
+
+
+#endif
+
+
+
+
+
+/* *** unused code below *** */
+
+#if 0
+
+
+/**
+ * \brief Convert decimal value into (char *) string
+ *
+ * Convert non-negative decimal value 'i' into (char *) string, put result
+ * in 'string'. Resulting string is ended with '\0' char;
+ *
+ * \param int i - input value to be converted, it has to be non-negative
+ * \param char *string - string for result, it has to be already allocated space large enough to store whole result
+ *
+ * \return CDW_GEN_ERROR if first argument is negative
+ */
+cdw_rv_t my_itoa2(int i, char *string)
+{
+	if (i < 0) {
+		/* range of values currently unsupported */
+		return CDW_GEN_ERROR;
+	} else if (i == 0) {
+		*string = '0';
+		*(string + 1) = '\0';
+		return CDW_OK;
+	}
+
+	/* number of digits required to store whole result string */
+	int digits = (int) floor(log10((float) i)) + 1;
+
+	/* we start building result with least significant digit */
+	char *cur_pos = string + digits;
+	*cur_pos = '\0';
+	cur_pos--;
+
+	int rem = 0;
+
+	while (i >= 10) {
+		rem = i % 10;
+		i = i / 10;
+		*cur_pos = (rem + '0');
+		cur_pos--;
+	}
+	*cur_pos = i + '0';
+
+	return CDW_OK;
+}
+
+
+
+#endif
+
+
+
+
+/* from cdw_ui.c */
+
+
+
+
+/**
+ * \brief Wrapper for open() that adds error checking and some user dialogs
+ *
+ * Open given file with path = fullpath, flags = flags and
+ * mode (permissions) = mode. See 'man 2 open' for details on 'flags' and
+ * 'mode'. Accepted permissions are 'S_IRUSR | S_IWUSR | S_IXUSR'.
+ *
+ * Function asks for new path when file with given path cannot be (for some
+ * reason) created. In this situation user will be presented with input
+ * dialog box with title 'title' and label 'label', where he can enter new
+ * path.
+ *
+ * Check "man 2 open" page for list of handled open() errors (all open()
+ * errors are handled).
+ *
+ * Make sure that fullpath is a pointer to location that can be reallocated
+ * to fit path of arbitrary length;
+ *
+ * If open() will succeed, then resulting file descriptor is returned in
+ * '*filedes' argument.
+ *
+ * \param filedes - result of open() (if open() succeeds); if open() fails then value of *filedes is unspecified
+ * \param fullpath - full path to file that has to be open
+ * \param flags - open() flags, as specified in description of second parameter of open()
+ * \param mode - access mode of file: 'S_IRUSR | S_IWUSR | S_IXUSR'
+ * \param title - title of dialog window asking user for new path
+ * \param label - label in dialog window asking user for new path
+ *
+ * \return CDW_OK if file with path set in fullpath can be used as path to valid file,
+ * \return CDW_CANCEL if user cancels writing image or tries too many times without success.
+ */
+cdw_rv_t cdw_open_file(int *filedes, char **fullpath, int flags, mode_t mode, char *title, char *label)
+{
+	assert((flags & O_RDONLY) || (flags & O_WRONLY) || (flags & O_RDWR));
+
+	cdw_rv_t handling_res = CDW_OK; /* result of open() errno handling */
+
+	int attempt = 0;
+	int total_attempts = 6; /* only 6 tries, an arbitrary value */
+	for (attempt = 0; attempt < total_attempts; attempt++) {
+		*filedes = open(*fullpath, flags, mode);
+		int e = errno;
+		/* debug message */
+		/* fprintf(stderr, "%s(): fullpath is \"%s\"\n", __func__, *fullpath); */
+		if (*filedes > 0) { /* the file previously did not existed, path is ok */
+			return CDW_OK;
+		} else { /* *filedes == -1, errno is set */
+			if (attempt == (total_attempts - 1)) {
+				break; /* because even if user agrees to enter
+				new path and provides it, loop condition turns
+				false before new path can be tested */
+			} else {
+				handling_res = cdw_sys_errno_handler(e);
+			}
+		}
+
+		if (handling_res == CDW_NO) { /* path is invalid, user wants to enter new path */
+			; /* do nothing here, but user will be asked
+			for new path right after this if-else tree */
+		} else if (handling_res == CDW_OK) { /* path is valid and user agreed to overwrite file;
+			can we write to file? does it have correct permissions? */
+			int rv = cdw_fs_check_existing_path(*fullpath, mode, CDW_FS_FILE);
+			if (rv == 0) {
+				return CDW_OK;
+			} else {
+				cdw_sys_errno_handler(rv);
+				/* do nothing more, user will be asked for
+				path right after this if-else tree */
+			}
+		} else { /* (handling_res == CDW_CANCEL || CDW_SYS_ERROR ):
+			path is invalid, user don't want to enter new path
+			or system error occurred */
+			return CDW_CANCEL;
+		}
+
+		/* User was warned and informed. Now he has a chance to
+		   enter new path. It will be checked at the top of this 'for()' */
+
+		 /* mode = 0, size limit = 0 (none) */
+		cdw_rv_t input = cdw_inputbox(title, label, fullpath, 0, 0);
+		if (input == CDW_CANCEL) {
+			return CDW_CANCEL;
+		} else {
+			/* user entered new path - check (again) if the file
+			   exists; 'continue' is unnecessary, but I will leave
+			   it as it is */
+			continue;
+		}
+	}
+
+	/* If user gets here, it means that he tried to enter path for
+	(total_attempts - 1) times. Either he is undecided or he has some
+	problems with file system. */
+
+	/* 2TRANS: this is title of dialog window */
+	cdw_dialogbox(_("Error"),
+		      /* 2TRANS: this is message in dialog window, user can press OK */
+		      _("Operation of file selection failed after several attempts. Please check your filesystem."),
+		      DIALOG_OK, CDW_COLORS_ERROR);
+
+	return CDW_CANCEL;
+}
+
+
+
+
+
+/* from cdw_fs_ui.c */
+
+
+#if 0
+
+
+/**
+ * \brief UI wrapper for cdw_fs_check_existing_path() that asks user for valid path n times
+ *
+ * On success function puts result in \p path. Additionally if
+ * filetype == CDW_DIR, function makes sure that the path ends with '/'.
+ *
+ * Function does not modify \p path if user pressed ESCAPE. Function does
+ * not modify \p path when user entered incorrect value into input field.
+ * \p path is modified only if selected path is valid (points to a valid
+ * file).
+ *
+ * \p path must be pointer to existing, initialized, reallocable buffer or
+ * must be pointer to NULL;
+ *
+ * \param title - title of dialog window
+ * \param prompt - message displayed in dialog window
+ * \param path - initial path, allocated string that can be modified by function
+ * \param mode - file permissions: S_IRUSR, S_IWUSR, S_IXUSR or logical sum; set to 0 if you don't want to check permissions
+ * \param filetype - type of file: CDW_DIR or CDW_FILE
+ * \param n - how many times user can enter invalid path?
+ *
+ * \return CDW_OK if user entered valid path,
+ * \return CDW_CANCEL if user canceled entering the path, or the path was invalid in n tries
+ * \return CDW_MEM_ERROR on malloc() errors
+ */
+cdw_rv_t cdw_fs_ui_get_existing_path(char *title, char *prompt, char **path, mode_t mode, int filetype, int n)
+{
+	/* to avoid overwritting function's argument by incorrect path */
+	char *local_buffer = NULL;
+	if (*path == (char *) NULL) {
+		;
+	} else {
+		local_buffer = strdup(*path);
+		if (local_buffer == (char *) NULL) {
+			return CDW_GEN_ERROR;
+		}
+	}
+
+	int i = 0;
+	for (i = 0; i < n; i++) {
+		/* mode = 0, size limit = 0 */
+		cdw_rv_t crv = cdw_inputbox(title, prompt, &local_buffer, 0, 0);
+
+		if (crv != CDW_OK) {
+			break; /* user abandoned action */
+		}
+
+		cdw_string_rtrim(local_buffer);
+		int rv = cdw_fs_check_existing_path(local_buffer, mode, filetype);
+
+		if (rv == 0) {
+			if (filetype == CDW_DIR) {
+				cdw_rv_t dpe = correct_dir_path_ending(&local_buffer);
+				/* path can't be invalid, since
+				   cdw_fs_check_existing_path() returns 0 */
+				assert(dpe != CDW_ARG_ERROR);
+
+				if (dpe != CDW_OK) {
+					return dpe;
+				}
+			}
+			cdw_string_set(path, local_buffer);
+			free(local_buffer);
+			local_buffer = (char *) NULL;
+
+			return CDW_OK;
+		} else if (rv == EACCES || rv == ENOENT || rv == EBADF) {
+			cdw_sys_errno_handler(rv);
+			/* retry */
+		} else {
+			/* 2TRANS: this is dialog window title */
+			cdw_dialogbox(_("Error"),
+				      /* 2TRANS: this is error message in dialog window - unknown error */
+				      _("Some error occurred. Please retry."),
+				      DIALOG_OK, CDW_COLORS_ERROR);
+			/* retry */
+		}
+	}
+
+	return CDW_CANCEL;
+}
+
+
+
+
+
+
+
+/**
+ * \brief UI for asking user for new path to file
+ *
+ * Function asks user for new path to a file. The function does not work
+ * for dirs.
+ *
+ * If user enters path to file that already exists, function returns
+ * EEXIST, and caller has to decide what to do next.
+ *
+ * If user enters path to file that doesn't exist, function checks
+ * for (user or group) write permissions for parent directory.
+ *
+ * User should not enter path with directories that don't exist yet,
+ * otherwise function will return ENOENT - this doesn't mean that
+ * entered path points to non-existing file, it means that parent dir
+ * doesn't exist.
+ *
+ * User can cancel process of entering new path by pressing ESCAPE key.
+ * Function returns ECANCELED in this case. Properly entered function
+ * must be accepted by pressing ENTER key.
+ *
+ * On success function puts result in \p path and returns 0.
+ *
+ * Function does not modify \p path if user pressed ESCAPE. Function does
+ * not modify \p path when user entered incorrect value into input field.
+ * \p path is modified only if selected path is valid (points to a valid
+ * file).
+ *
+ * \p path must be pointer to existing, initialized, reallocable buffer or
+ * must be pointer to NULL;
+ *
+ * \param title - title of dialog window
+ * \param prompt - message displayed in dialog window
+ * \param path - initial path, allocated string that can be modified by function
+ * \param mode - file permissions: S_IRUSR, S_IWUSR, S_IXUSR or logical sum; set to 0 if you don't want to check permissions
+ * \param n - how many times user can enter invalid path?
+ *
+ * \return CDW_OK if user entered valid path,
+ * \return CDW_CANCEL if user canceled entering the path, or the path was invalid in n tries
+ * \return CDW_MEM_ERROR on malloc() errors
+ */
+int cdw_fs_ui_get_new_file_path(char *title, char *prompt, char **path, mode_t mode, int n)
+{
+	/* to avoid overwritting function's argument by incorrect path */
+	char *local_buffer = NULL;
+	if (*path == (char *) NULL) {
+		;
+	} else {
+		local_buffer = strdup(*path);
+		if (local_buffer == (char *) NULL) {
+			return ENOMEM;
+		}
+	}
+
+	int i = 0;
+	for (i = 0; i < n; i++) {
+		/* mode = 0, size limit = 0 */
+		cdw_rv_t crv = cdw_inputbox(title, prompt, &local_buffer, 0, 0);
+
+		if (crv != CDW_OK) {
+			break; /* user abandoned action */
+		}
+
+		cdw_string_rtrim(local_buffer);
+
+		bool parent_dir = false;
+
+		int rv = cdw_fs_check_existing_path(local_buffer, mode, CDW_FILE);
+
+		if (rv == ENOENT) { /* file doesn't exist (yet) */
+			char *last_dir = strrchr(local_buffer, '/');
+			if (last_dir == (char *) NULL) {
+				return ENOENT;
+			} else { /* there seems to be *some* dir path */
+				*last_dir = '\0';
+				cdw_vdm ("zero: local_buffer = \"%s\"\n", local_buffer);
+				int rv2 = cdw_fs_check_existing_path(local_buffer, S_IWUSR | S_IWGRP, CDW_DIR);
+				if (rv2 == ENOENT) {
+					return ENOENT;
+				} else {
+					/* dir for new file exists, but
+					   cdw_fs_check_existing_path()
+					   may have returned other errors,
+					   let rest of code check it */
+					rv = rv2;
+					parent_dir = true;
+					/* restore full path */
+					*last_dir = '/';
+					/* fall through to checking new value of rv */
+					cdw_vdm ("one: local_buffer = \"%s\"\n", local_buffer);
+				}
+			}
+		}
+
+		if (rv == 0) {
+			cdw_vdm ("two: local_buffer = \"%s\"\n", local_buffer);
+
+			cdw_string_set(path, local_buffer);
+			free(local_buffer);
+			local_buffer = (char *) NULL;
+
+			if (parent_dir) {
+				/* file doesn't exist, but user has perms
+				   for writing to parent dir */
+				return 0;
+			} else { /* file exists and has correct perms */
+				return EEXIST;
+			}
+
+		} else if (rv == EACCES || rv == ENOENT || rv == EBADF) {
+			cdw_vdm ("three: local_buffer = \"%s\"\n", local_buffer);
+			cdw_sys_errno_handler(rv);
+			cdw_vdm ("four: local_buffer = \"%s\"\n", local_buffer);
+			/* retry */
+		} else {
+			/* 2TRANS: this is dialog window title */
+			cdw_dialogbox(_("Error"),
+				      /* 2TRANS: this is error message in
+					 dialog window - unknown error */
+				      _("Some error occurred. Please retry."),
+				      DIALOG_OK, CDW_COLORS_ERROR);
+			/* retry */
+		}
+	}
+
+	return ECANCELED;
+}
+
+#endif
+
+
+
+
+
+/* from options_ui.c */
+
+
+
+#if 0
+
+
+/**
+ * \brief Handle keys while fourth page of configuration window is displayed
+ *
+ * Handle keys while fourth page of configuration window is displayed.
+ * Function returns after user has hit F1, F2, F3, F10 or ESCAPE.
+ *
+ * You can tell the driver to bring focus to specific field in page by
+ * calling the function with index of the field as an argument.
+ * Pass -1 if you don't want to swith to any particular field (first field
+ * will be selected by default).
+ *
+ * \param initial_field_ind - index of field to which driver should switch at the beginning
+ *
+ * \return CDW_ESCAPE - exit configuration window, no changes should be saved,
+ * \return KEY_F(10) - exit configuration window, changes should be permanently saved
+ * \return KEY_F(2) - change configuration page to page 1
+ * \return KEY_F(2) - change configuration page to page 2
+ * \return KEY_F(3) - change configuration page to page 3
+ */
+int page_d_driver(int initial_field_ind)
+{
+	form_driver(forms[PAGE_D_INDEX], REQ_FIRST_FIELD);
+	if (initial_field_ind <= 0) {
+		initial_field_ind = 0;
+	} else if (initial_field_ind >= N_FIELDS_D) {
+		initial_field_ind = 0;
+	} else {
+		;
+	}
+
+	/* initial field may not be first when driver needs to switch
+	to field in which there is an error */
+	/* TODO: check why using simple for() loop fails: iterating stops
+	before correct field */
+	FIELD *ff = current_field(forms[PAGE_D_INDEX]);
+	int ii = fld_index(ff);
+	while (ii < initial_field_ind) {
+		form_driver(forms[PAGE_D_INDEX], REQ_NEXT_FIELD);
+		ff = current_field(forms[PAGE_D_INDEX]);
+		ii = fld_index(ff);
+	}
+
+	form_driver(forms[PAGE_D_INDEX], REQ_END_LINE);
+
+	int ch = KEY_END; /* safe init value */
+	do {
+		/* since there are checkboxes/input fields and
+		dropdowns in this page, marking them as having focus
+		must be handled in two different ways, depending
+		on if this is dropdown (and which one) or not */
+
+		FIELD *cur = current_field(forms[PAGE_D_INDEX]);
+		int fld_index = fld_index(cur);
+
+		wrefresh(subwindows[PAGE_D_INDEX]);
+
+		if (fld_index == f_iso_level) {
+			curs_set(0);
+			cdw_dropdown_focus(iso_level_dropdown);
+		} else if (fld_index == f_volumeid || fld_index == f_showvol) {
+			/* these are fields to which you can
+			move _from_ dropdown field */
+
+			/* this is really to un-focus dropdown */
+			cdw_dropdown_unfocus(iso_level_dropdown);
+
+			curs_set(1);
+
+			/* this is only to move cursor to current field */
+			form_driver(forms[PAGE_D_INDEX], REQ_INS_MODE);
+		} else { /* any other checkbox/input field, but we don't
+			need unfocus dropdowns for them */
+
+			/* this is only to redraw dropdown in its
+			'unfocused' state */
+			cdw_dropdown_unfocus(iso_level_dropdown);
+
+			curs_set(1);
+
+			/* this is only to move cursor to current field */
+			form_driver(forms[PAGE_D_INDEX], REQ_INS_MODE);
+		}
+
+		wrefresh(subwindows[PAGE_D_INDEX]);
+
+		ch = wgetch(subwindows[PAGE_D_INDEX]);
+
+		switch (ch) {
+			case KEY_HOME:
+				if (fld_index != f_iso_level) {
+					form_driver(forms[PAGE_D_INDEX], REQ_BEG_LINE);
+				}
+				break;
+			case KEY_END:
+				if (fld_index != f_iso_level) {
+					form_driver(forms[PAGE_D_INDEX], REQ_END_LINE);
+				}
+				break;
+			case KEY_LEFT:
+				if (fld_index != f_iso_level) {
+					form_driver(forms[PAGE_D_INDEX], REQ_PREV_CHAR);
+				}
+				break;
+			case KEY_RIGHT:
+				if (fld_index != f_iso_level) {
+					form_driver(forms[PAGE_D_INDEX], REQ_NEXT_CHAR);
+				}
+				break;
+			case KEY_DOWN:
+			case '\t':
+				form_driver(forms[PAGE_D_INDEX], REQ_NEXT_FIELD);
+				form_driver(forms[PAGE_D_INDEX], REQ_END_LINE);
+				break;
+			case KEY_UP:
+			case KEY_BTAB:
+				form_driver(forms[PAGE_D_INDEX], REQ_PREV_FIELD);
+				form_driver(forms[PAGE_D_INDEX], REQ_END_LINE);
+				break;
+			case KEY_BACKSPACE:
+				if (fld_index != f_iso_level) {
+					form_driver(forms[PAGE_D_INDEX], REQ_DEL_PREV);
+				}
+				break;
+			case KEY_DC:
+				if (fld_index != f_iso_level) {
+					form_driver(forms[PAGE_D_INDEX], REQ_DEL_CHAR);
+				}
+				break;
+			case KEY_F(PAGE_A_INDEX + 1):
+			case KEY_F(PAGE_B_INDEX + 1):
+			case KEY_F(PAGE_C_INDEX + 1):
+			case KEY_F(PAGE_E_INDEX + 1):
+			case KEY_F(10):
+				/* leave keys handling loop */
+				form_driver(forms[PAGE_D_INDEX], REQ_VALIDATION); /* we DO check return value :) */
+				curs_set(0); /* turn cursor off */
+				return ch;
+			case CDW_ENTER:
+				if (fld_index == f_iso_level) {
+
+					size_t id = cdw_dropdown_current_item_ind(iso_level_dropdown);
+					cdw_rv_t crv = cdw_dropdown_driver(iso_level_dropdown, &id);
+					if (crv == CDW_OK) {
+
+					/* setting buffer makes field to display
+						string, but slightly moved to left */
+						set_field_buffer(fields_form_d[fld_index], 0, iso_level_labels[id]);
+
+						/* call to cdw_dropdown_focus() fixes it */
+						cdw_dropdown_focus(iso_level_dropdown);
+
+						form_driver(forms[PAGE_D_INDEX], REQ_VALIDATION);
+					} /* else field buffer is not updated and nothing changes */
+				}
+				break;
+			default:
+				if (fld_index == f_iso_level) {
+					; /* iso level dropdown - ENTER key was dealt with a bit earlier */
+				} else if (is_checkbox_fld_index(PAGE_D_INDEX, fld_index)) {
+					if (ch == ' ' || ch == 'x' || ch == 'X') {
+						/* toggle checkbox state */
+						if (get_field_bit(cur)) {
+							set_field_buffer(*(fields_form_d + fld_index), 0, " ");
+						} else {
+							set_field_buffer(*(fields_form_d + fld_index), 0, "X");
+						}
+						/* unused operation: chkbx = 1; */
+					}
+				} else {
+					/* normal text/input field, pass char from keyboard to field */
+					form_driver(forms[PAGE_D_INDEX], ch);
+				}
+				break;
+		} /* switch (ch) */
+	} while ( ch != CDW_ESCAPE );
+
+	curs_set(0);
+
+	/* we get here only when user pressed ESCAPE;
+	F2, F3 and F10 keys are handled above, their handling is
+	simply returning */
+	return CDW_ESCAPE;
+}
+
+
+
+
+
+
+
+/**
+ * \brief Handle keys while first page of configuration window is displayed
+ *
+ * Handle keys while first page of configuration window is displayed.
+ * Function returns after user has hit F2, F3, F10 or ESCAPE.
+ *
+ * You can tell the driver to bring focus to specific field in page by
+ * calling the function with index of the field as an argument.
+ * Pass -1 if you don't want to swith to any particular field (first field
+ * will be selected by default).
+ *
+ * \param initial_field_ind - index of field to which driver should switch at the beginning
+ *
+ * \return CDW_ESCAPE - exit configuration window, no changes should be saved,
+ * \return KEY_F(10) - exit configuration window, changes should be permanently saved
+ * \return KEY_F(2) - change configuration page to page 2
+ * \return KEY_F(3) - change configuration page to page 3
+ */
+int page_a_driver(int initial_field_ind)
+{
+	form_driver(forms[PAGE_A_INDEX], REQ_FIRST_FIELD);
+	if (initial_field_ind <= 0) {
+		initial_field_ind = 0;
+	} else if (initial_field_ind >= N_FIELDS_A) {
+		initial_field_ind = 0;
+	} else {
+		;
+	}
+
+	/* initial field may not be first when driver needs to switch
+	to field in which there is an error */
+	/* TODO: check why using simple for() loop fails: iterating stops
+	before correct field */
+	FIELD *ff = current_field(forms[PAGE_A_INDEX]);
+	int ii = fld_index(ff);
+	while (ii < initial_field_ind) {
+		form_driver(forms[PAGE_A_INDEX], REQ_NEXT_FIELD);
+		ff = current_field(forms[PAGE_A_INDEX]);
+		ii = fld_index(ff);
+	}
+
+	form_driver(forms[PAGE_A_INDEX], REQ_END_LINE);
+	wrefresh(subwindows[PAGE_A_INDEX]);
+
+	int ch = KEY_END; /* safe init value */
+	curs_set(1);
+	do {
+		/* since there are checkboxes/input fields and
+		dropdowns in this page, marking them as having focus
+		must be handled in two different ways, depending
+		on if this is dropdown (and which one) or not */
+
+		FIELD *cur = current_field(forms[PAGE_A_INDEX]);
+		int fld_index = fld_index(cur);
+
+		wrefresh(subwindows[PAGE_A_INDEX]);
+
+		if (fld_index == f_speed) {
+			curs_set(0);
+			cdw_dropdown_focus(speed_dropdown);
+		} else { /* any other checkbox/input field, but we don't
+			need unfocus dropdowns for them */
+
+			/* this is only to redraw dropdown in its
+			'unfocused' state */
+			cdw_dropdown_unfocus(speed_dropdown);
+
+			curs_set(1);
+
+			/* this is only to move cursor to current field */
+			form_driver(forms[PAGE_A_INDEX], REQ_INS_MODE);
+		}
+
+		wrefresh(subwindows[PAGE_A_INDEX]);
+
+		ch = wgetch(subwindows[PAGE_A_INDEX]);
+
+		switch (ch) {
+			case KEY_HOME:
+				if (fld_index != f_speed) {
+					form_driver(forms[PAGE_A_INDEX], REQ_BEG_LINE);
+				}
+				break;
+			case KEY_END:
+				if (fld_index != f_speed) {
+					form_driver(forms[PAGE_A_INDEX], REQ_END_LINE);
+				}
+				break;
+			case KEY_LEFT:
+				if (fld_index != f_speed) {
+					form_driver(forms[PAGE_A_INDEX], REQ_PREV_CHAR);
+				}
+				break;
+			case KEY_RIGHT:
+				if (fld_index != f_speed) {
+					form_driver(forms[PAGE_A_INDEX], REQ_NEXT_CHAR);
+				}
+				break;
+			case KEY_DOWN:
+			case '\t':
+				form_driver(forms[PAGE_A_INDEX], REQ_NEXT_FIELD);
+				form_driver(forms[PAGE_A_INDEX], REQ_END_LINE);
+				break;
+			case KEY_UP:
+			case KEY_BTAB:
+				form_driver(forms[PAGE_A_INDEX], REQ_PREV_FIELD);
+				form_driver(forms[PAGE_A_INDEX], REQ_END_LINE);
+				break;
+			case KEY_BACKSPACE:
+				if (fld_index != f_speed) {
+					form_driver(forms[PAGE_A_INDEX], REQ_DEL_PREV);
+				}
+				break;
+			case KEY_DC:
+				if (fld_index != f_speed) {
+					form_driver(forms[PAGE_A_INDEX], REQ_DEL_CHAR);
+				}
+				break;
+			case KEY_F(PAGE_B_INDEX + 1):
+			case KEY_F(PAGE_C_INDEX + 1):
+			case KEY_F(PAGE_D_INDEX + 1):
+			case KEY_F(PAGE_E_INDEX + 1):
+			case KEY_F(10):
+				/* leave keys handling loop */
+				form_driver(forms[PAGE_A_INDEX], REQ_VALIDATION); /* we DO check return value :) */
+				curs_set(0); /* turn cursor off */
+				return ch;
+			case CDW_ENTER:
+				if (fld_index == f_speed) {
+
+					size_t id = cdw_dropdown_current_item_ind(speed_dropdown);
+					cdw_rv_t crv = cdw_dropdown_driver(speed_dropdown, &id);
+					if (crv == CDW_OK) {
+
+						/* setting buffer makes field to display
+						string, but slightly moved to left */
+						set_field_buffer(fields_form_a[fld_index], 0, speed_range_labels[id]);
+
+						/* call to cdw_dropdown_focus() fixes it */
+						cdw_dropdown_focus(speed_dropdown);
+
+						form_driver(forms[PAGE_A_INDEX], REQ_VALIDATION);
+
+						char *r_buf = cdw_string_rtrim(field_buffer(*(fields + fld_index), 0));
+						int r = atoi(r_buf);
+						cdw_sdm ("speed_range = %d, %s\n", r, r_buf)
+					} /* else field buffer is not updated and nothing changes */
+				}
+				break;
+			default:
+				if (fld_index == f_speed) {
+					; /* speed dropdown - ENTER key was dealt with a bit earlier */
+				} else if (is_checkbox_fld_index(PAGE_A_INDEX, fld_index)) {
+					if (ch == ' ' || ch == 'x' || ch == 'X') {
+						/* toggle checkbox state */
+						if (get_field_bit(cur)) {
+							set_field_buffer(*(fields_form_a + fld_index), 0, " ");
+						} else {
+							set_field_buffer(*(fields_form_a + fld_index), 0, "X");
+						}
+						/* unused operation: chkbx = 1; */
+					}
+				} else {
+					/* normal text/input field, pass char from keyboard to field */
+					form_driver(forms[PAGE_A_INDEX], ch);
+				}
+				break;
+		} /* switch (ch) */
+	} while ( ch != CDW_ESCAPE );
+
+	curs_set(0);
+
+	/* we get here only when user pressed ESCAPE;
+	F2, F3 and F10 keys are handled above, their handling is
+	simply returning */
+	return CDW_ESCAPE;
+}
+
+
+
+
+
+/* *** unused code below *** */
+
+/**
+ * Show cdw preferences window
+ *
+ * Show preferences window with multiple tabs that group cdw options.
+ * User can switch between them using F_(X) keys and save changed options
+ * to config file or leave preferences window without saving changes. Current
+ * preferences are read form disk file before being shown to the user,
+ * and then are saved (if user demands it by pressing F_(10)) to disk file and
+ * to global variable 'cdw_config_t config' after closing preferences window.
+ * Any changes made in preferences window will be discarded if user presses ESCAPE.
+ *
+ * Preferences module should be initialized (using int preferences_init(void)) before
+ * calling preferences_window(), because it depends on default values being set.
+ */
+void preferences_window2(void)
+{
+	int ch = 0;   /* key pressed */
+	int page = 0; /* number of current preferences tab (form) */
+
+	/* this variable will store changes made _before_ pressing F_(10);
+	 * these changes will be discarded if user pressed ESCAPE,
+	 * or will be saved if user pressed F_(10) */
+	 * struct conf tmp_config;
+	initialize_config_variable(&tmp_config);
+
+	/* create preferences window */
+	optwin = newwin(CONF_HEIGHT, CONF_WIDTH,
+			(LINES - CONF_HEIGHT) / 2, (COLS - CONF_WIDTH) / 2);
+	wbkgd(optwin, COLOR_PAIR(CDW_COLORS_DIALOG));
+	werase(optwin);
+	keypad(optwin, TRUE);
+	/* 2TRANS: this is title of cdw preferences main window */
+	nice_box(optwin, _("CDW preferences"),
+		 /* 2TRANS: this is message at the bottom of preferences window;
+		 cancel means: quit without saving */
+		 _("Press F10 to save config or ESC to cancel"));
+
+	/* DON'T read configuration from disk file to config variable:
+	this is done already in preferences_init(); and between calling
+	preferences_init() and opening preferences window user could modify
+	configuration variable in other places; reading config from file again
+	could overwrite user's changes  */
+	/* read_conf(); */
+
+	/* copy current option values from main config variable to temporary
+	* config variable and use the temporary variable to fill preferences
+	* window forms and temporarily store changed values; temporarily means
+	* until user won't demand explicitly to save changes by pressing F10 */
+	copy_config(&tmp_config, &config);
+
+	/* initial state - show first page of preferences */
+	ch = page_one(&tmp_config);
+	page = 1;
+
+	/* switch between preferences pages or close preferences window
+	* (with or without saving changed preferences) */
+	while (ch != CDW_ESCAPE) {
+
+		if (ch == KEY_F(1)) {
+			if (page != 1) {
+				page = 1;
+				ch = page_one(&tmp_config);
+			}
+		} else if (ch == KEY_F(2)) {
+			if (page != 2) {
+				page = 2;
+				ch = page_two(&tmp_config);
+			}
+		} else if (ch == KEY_F(3)) {
+			if (page != 3) {
+				page = 3;
+				ch = page_three(&tmp_config);
+			}
+
+		} else if (ch == KEY_F(10)) { /* save modified configuration and exit */
+			int epage = 0; /* validate_config() will put here number of page with erroneous field */
+			cdw_rv_t valid = validate_config(tmp_config, &epage);
+
+			if (valid == CDW_NO) { /* some option field is invalid */
+				/* 2TRANS: this is title of dialog window */
+				cdw_dialogbox(_("Error"),
+					      /* 2TRANS: this is message in dialog window */
+					      _("One of preferences fields contains error. Please fix it."),
+					      DIALOG_OK, CDW_COLORS_ERROR);
+				wrefresh(optwin);
+
+				/* this will return control to specific page */
+				ch = KEY_F(epage);
+				if (epage == 1) {
+					page = 2;
+				} else {
+					page = 1;
+				}
+				continue;
+
+			} else if (valid == CDW_GEN_ERROR) {
+				/* 2TRANS: this is title of dialog window */
+				cdw_rv_t crv = cdw_dialogbox(_("Warning"),
+							     /* 2TRANS: this is message in dialog window */
+							     _("One of option fields may contain error. You may want to fix it. Close window?"),
+							     DIALOG_OK_CANCEL, CDW_COLORS_WARNING);
+				if (crv == CDW_OK) {
+					;
+				} else {
+					/* this will return control to specific page */
+					ch = KEY_F(epage);
+					if (epage == 1) {
+						page = 2;
+					} else {
+						page = 1;
+					}
+					continue;
+				}
+			} else { /* valid == CDW_OK */
+				/* copy options values saved in tmp_config during work with
+				* preferences tabs to primary configuration variable - config */
+				copy_config(&config, &tmp_config);
+				break;
+			}
+		} else {
+			/* do nothing - keys with any meaning will be
+			captured by preferences pages */
+			;
+		}
+	}
+
+	wrefresh(optwin);
+
+	if (failsafe_mode) { /* cannot work with file system because of previous errors */
+		/* 2TRANS: this is title of dialog window */
+		cdw_dialogbox(_("Config file error"),
+			      /* 2TRANS: this is message in dialog window */
+			      _("Cannot write to config file. Configuration will not be saved to file."),
+			      DIALOG_OK, CDW_COLORS_ERROR);
+		/* cannot save changed values to file, but they are saved to
+		* config variable and will be used only in this session. */
+	} else {
+		/* write current configuration to disk file */
+		write_conf();
+	}
+	delwin(optwin);
+	optwin = NULL;
+	main_win_refresh(false);
+
+	free_config_variable(&tmp_config);
+
+	return;
+}
+
+
+
+
+
+/* ***************************** */
+/* ****** simple wrappers ****** */
+/* ***************************** */
+
+
+
+
+
+/**
+ * Erase preferences window area
+ */
+void preferences_win_erase(void)
+{
+	WINDOW *optwin_sub = derwin(optwin, CONF_HEIGHT - 2, CONF_WIDTH - 2, 1, 1);
+	werase(optwin_sub);
+	wrefresh(optwin_sub);
+
+	/* always delwin() results of derwin() calls */
+	delwin(optwin_sub);
+
+	return;
+}
+
+
+#endif
+
+
+
+
+
+/* from cdw_fs.c */
+#if 0
+
+/**
+   \brief Get value of $HOME = 'home directory' shell variable directory
+
+   Function puts into it's argument path to user home directory (with
+   '/' at the end and with ending '\0'), or returns error. Error may occur
+   when there is no HOME env. variable, when HOME dir does not exists or
+   HOME dir does not have 'r' and 'w' permissions set.
+
+   'path' argument must be NULL, and it will be initialized by function;
+   value will be set to NULL on error.
+
+   \param path - buffer for path to user home directory
+
+   \return path length (not including trailing '\0') if no error,
+   \return CDW_SYS_ERROR if no such env. variable,
+   \return CDW_FILE_INVALID when dir does not exist,
+   \return CDW_MEM_ERROR when memory allocation error occurred,
+   \return CDW_PERM_ERROR when r/w permissions are wrong,
+   \return CDW_GEN_ERROR - other error
+*/
+int cdw_fs_get_home_dir(char **path)
+{
+	assert (*path == (char *) NULL);
+
+	/* paranoid mode = on */
+
+	if (getenv("HOME") == NULL) { /* getenv error - no such variable */
+		*path = NULL;
+		return CDW_SYS_ERROR;
+	} else {
+		int rv = 0;
+		/* getenv() returns NUL-terminated string or NULL */
+		*path = strdup(getenv("HOME"));
+		if (*path == NULL) {
+			return CDW_MEM_ERROR;
+		} else {
+			cdw_rv_t crv = cdw_fs_correct_dir_path_ending(path);
+			if (crv != CDW_OK) {
+				return crv;
+			}
+		}
+
+		/* debug code
+		int dd = 0;
+		fprintf(stderr, "debug code, path to home dir is ");
+		for (dd = 0; dd < len + 1; dd++) {
+			if (strcmp(*path + dd, "\0")) {
+				fprintf(stderr, "%s ", (*path + dd));
+			} else {
+				fprintf(stderr, "NUL\n");
+			}
+		}
+		*/
+
+		rv = cdw_fs_check_existing_path(*path, S_IWUSR|S_IRUSR|S_IXUSR, CDW_FS_DIR);
+
+		if (rv == 0) { /* lstat OK */
+			return (signed int) strlen(*path); /* everything is OK */
+		} else {
+			free(*path);
+			*path = NULL;
+			return rv; /* wrong permissions? */
+		}
+	}
+}
+#endif
+
+
+
+
+
+#if 0
+
+/**
+   \brief Get temporary directory
+
+   Function puts into it's argument some directory (with ending '\0'),
+   or returns error. Error may occur when there is no path selected by user
+   or dir does not have 'rwx' permissions set - it means that this function
+   checks for validity of folder.
+
+   Path returned in path argument is ended with forward slash and null character.
+
+   'path' argument must be NULL, and it will be initialized by function;
+   value will be set to NULL on error.
+
+   \param path - buffer for path to directory -
+
+   \return path length (not including trailing '\0') if no error,
+   \return CDW_FILE_INVALID when dir does not exist,
+   \return CDW_PERM_ERROR when r/w permissions are wrong,
+   \return CDW_MEM_ERROR when memory allocation error occurred,
+   \return CDW_GEN_ERROR - other error,
+   \return CDW_CANCEL when user hits ESCAPE key.
+*/
+int cdw_fs_get_tmp_dir(char **path)
+{
+	assert (*path == (char *) NULL);
+
+	/* some sane initial value */
+	*path = strdup("/tmp/");
+	if (*path == NULL) {
+		return CDW_MEM_ERROR;
+	}
+
+	/* 2TRANS: this is title of dialog window */
+	cdw_rv_t rv = cdw_inputbox(_("Select directory"),
+				   /* 2TRANS: this is message in dialog window. Please keep '\n'. */
+				   _("Please select temporary directory.\n   Press ESC to skip."),
+				   path, 0, 0); /* mode = 0, size limit = 0 */
+
+	if (rv == CDW_CANCEL) {
+		*path = NULL;
+		return CDW_CANCEL;
+	}
+
+	if (*path == NULL) {
+		return CDW_MEM_ERROR;
+	}
+
+	cdw_string_rtrim(*path);
+
+	size_t len = strlen(*path);
+
+	while ( ((*(*path + len - 1) == '\\') || (*(*path + len - 1) == '/'))
+		&& (len > 0)) {
+			len--;
+	}
+
+	char *tmp = (char *) realloc(*path, len + 2); /* make place for ending slash */
+	if (tmp == NULL) {
+		free(*path);
+		*path = NULL;
+		return CDW_MEM_ERROR;
+	} else {
+		*path = tmp;
+	}
+
+	*(*path + len) = '/';
+	*(*path + len + 1) = '\0';
+
+	/* since we are looking for /tmp dir, we should use group
+	   permissions, and only to writing */
+
+	rv = cdw_fs_check_existing_path(*path, S_IWGRP, CDW_FS_DIR);
+
+	if (rv == 0) { /* lstat OK */
+		return (signed int) len; /* everything is OK */
+	} else {
+		free(*path); /* we set result to NULL on error */
+		*path = NULL;
+
+		return CDW_FILE_INVALID; /* wrong permissions? */
+	}
+}
+#endif
+
+
+
+
+/* *** cdw_cdio.c *** */
+
+
+
+
+/* *** unused code below *** */
+
+#if 0
+/**
+ * Returns true if disc can be read sector by sector using internal cdw code
+ */
+bool cdw_cdio_disc_supported_for_cdw_ripping(void)
+{
+	cdw_cdio_disc_t *disc = g_disc;
+	cdw_assert (disc->open, "trying to get information about disc that is not open\n");
+
+	cdw_vdm ("\ndisc->mode is %d\n", disc->mode);
+
+	if ((disc->mode == CDIO_DISC_MODE_CD_DATA) /* Mode1/Mode2 Formless? */
+	    || (disc->mode == CDIO_DISC_MODE_CD_XA) /* Mode2 Form1 / Mode2 Form2 ? */
+	    || (disc->mode == CDIO_DISC_MODE_CD_DA)) {
+		/* || (disc->mode == CDIO_DISC_MODE_CD_MIXED)
+		   || (disc->mode == CDIO_DISC_MODE_DVD_ROM)         // DVD ROM (e.g. movies)
+		   || (disc->mode == CDIO_DISC_MODE_DVD_RAM)         // DVD-RAM
+		   || (disc->mode == CDIO_DISC_MODE_DVD_R)           // DVD-R
+		   || (disc->mode == CDIO_DISC_MODE_DVD_RW)          // DVD-RW
+		   || (disc->mode == CDIO_DISC_MODE_DVD_PR)          // DVD+R
+		   || (disc->mode == CDIO_DISC_MODE_DVD_PRW)         // DVD+RW
+		   || (disc->mode == CDIO_DISC_MODE_DVD_OTHER) 	// Unknown/unclassified DVD type
+		*/
+
+		return true;
+	} else {
+		return false;
+	}
+}
+
+#endif
+
+
+#if 0
+/**
+ * \brief Use libcdio calls to get information about given track
+ *
+ * Check value of disc->tracks[t].cdio_format for given track.
+ *
+ * If this is track of format TRACK_FORMAT_AUDIO, then assign correct value to
+ * disc->tracks[t].cdw_format, disc->tracks[t].sector_size and
+ * disc->tracks[t].n_sectors_to_read. Return CDW_OK because all important
+ * information is now correctly set and no other testing of track is needed.
+ *
+ * If this is track of format TRACK_FORMAT_DATA or TRACK_FORMAT_XA then
+ * assign best-guess value to disc->tracks[t].sector_size and
+ * disc->tracks[t].n_sectors_to_read and return CDW_NO.
+ * Caller will have to do some more checks of track type to assign correct
+ * values to disc->tracks[t].cdw_format and to disc->tracks[t].sector_size.
+ *
+ * If this track of other format, then assign CDW_BLACK_BOOK_UNKNOWN to
+ * disc->tracks[t].cdw_format, zero to disc->tracks[t].sector_size and
+ * return CDW_GEN_ERROR.
+ *
+ * \param t - track number
+ *
+ * \return CDW_OK if track is of type TRACK_FORMAT_AUDIO
+ * \return CDW_NO if track is of type TRACK_FORMAT_DATA or TRACK_FORMAT_XA
+ * \return CDW_GEN_ERROR if track is of other (thus unsupported) type
+ */
+cdw_rv_t cdw_cdio_get_track_cdio_format_old(cdw_cdio_disc_t *disc, track_t t)
+{
+	/* setting cdio_format will allow cdw_cdio_resolve_track_cdw_format()
+	   to quickly recognize if given track is of following type:
+	   - CD-DA
+	   - supported data CD (CD-ROM Mode1/2-Formless, CD-ROM/XA Mode2 Form 1/2)
+	   - unsupported CD type or DVD of any type
+	*/
+	disc->tracks[t].cdio_format = cdio_get_track_format(disc->p_cdio, t);
+	cdw_vdm ("disc->tracks[%d].cdio_format = %d\n", (int) t, disc->tracks[t].cdio_format);
+
+	if (disc->tracks[t].cdio_format == TRACK_FORMAT_AUDIO) {
+		disc->tracks[t].cdw_format = CDW_RED_BOOK_AUDIO;
+		disc->tracks[t].sector_size = 2352;
+		/* I don't think that there is any padding on audio CDs,
+		   so this is correct */
+		disc->tracks[t].n_sectors_to_read = disc->tracks[t].n_sectors;
+
+		/* no more investigation needed for audio tracks */
+		return CDW_OK;
+	} else {
+		/* here we only _guess_ sector size for non-black tracks */
+		if (disc->tracks[t].cdio_format == TRACK_FORMAT_DATA) {
+			/* TRACK_FORMAT_DATA doesn't say to me a lot, I'm guessing
+			Mode1, but that is only a guess, therefore returing CDW_NO */
+			disc->tracks[t].sector_size = 2048;
+			/* more investigation needed */
+
+		} else if (disc->tracks[t].cdio_format == TRACK_FORMAT_XA) {
+			/* mode 2 form one or two, but it is safer to take larger size */
+			disc->tracks[t].sector_size = 2324;
+			/* more investigation needed */
+
+		} else if (disc->tracks[t].cdio_format == TRACK_FORMAT_CDI) {
+			/* mode 2 form 2: 2324 bytes in data (audio/video) tracks
+			(note that tracks with text and 'program data' require
+			error correction, thus payload size is 2048 bytes
+			(mode 2 form 1) in case of such tracks) */
+
+			/* unsupported track format will be treated as unknown */
+			disc->tracks[t].cdw_format = CDW_BLACK_BOOK_UNKNOWN;
+			disc->tracks[t].sector_size = 0;
+			disc->tracks[t].n_sectors_to_read = 0;
+
+			return CDW_GEN_ERROR;
+
+		} else if (disc->tracks[t].cdio_format == TRACK_FORMAT_PSX) {
+			/* unsupported track format will be treated as unknown */
+			disc->tracks[t].cdw_format = CDW_BLACK_BOOK_UNKNOWN;
+			disc->tracks[t].sector_size = 0;
+			disc->tracks[t].n_sectors_to_read = 0;
+
+			return CDW_GEN_ERROR;
+		} else {
+			/* unsupported track format will be treated as unknown */
+			disc->tracks[t].cdw_format = CDW_BLACK_BOOK_UNKNOWN;
+			disc->tracks[t].sector_size = 0;
+			disc->tracks[t].n_sectors_to_read = 0;
+
+			return CDW_GEN_ERROR;
+		}
+
+		cdio_iso_analysis_t iso_analysis;
+		memset(&iso_analysis, 0, sizeof(cdio_iso_analysis_t));
+
+		cdio_fs_anal_t fs = cdio_guess_cd_type(disc->p_cdio, disc->tracks[t].first_sector, t, &iso_analysis);
+		if ( (CDIO_FSTYPE(fs) == CDIO_FS_ISO_9660 ||
+			CDIO_FSTYPE(fs) == CDIO_FS_ISO_HFS  ||
+			CDIO_FSTYPE(fs) == CDIO_FS_ISO_9660_INTERACTIVE) ) {
+
+			/* debug messages */
+			cdw_vdm ("ISO 9660: isofs_size = %d, label `%.32s'\n", iso_analysis.isofs_size, iso_analysis.iso_label);
+			cdw_vdm ("ISO 9660: disc->tracks[%d].n_sectors = %d\n", t, disc->tracks[t].n_sectors);
+
+			disc->tracks[t].n_sectors_to_read = (lsn_t) iso_analysis.isofs_size;
+
+		} else {
+			/* may not be the best option, but may be the
+			   only option TODO: to be checked */
+			disc->tracks[t].n_sectors_to_read = disc->tracks[t].n_sectors;
+		}
+
+		/* still more investigation needed on sector size and sector format */
+		return CDW_NO;
+	}
+}
+#endif
+
+
+
+#if 0
+cdw_rv_t cdw_cdio_get_meta_info(char *const device_fullpath)
+{
+	bool was_already_open = false;
+	if (disc->open) {
+		was_already_open = true;
+	} else {
+		cdw_cdio_disc_t *cdio_disc = cdw_cdio_disc_open(device_fullpath);
+		if (cdio_disc == (cdw_cdio_disc_t *) NULL) {
+			cdw_vdm ("ERROR: cannot open disc\n");
+			return CDW_GEN_ERROR;
+		}
+	}
+
+	cdw_rv_t m = cdw_cdio_get_meta_info_from_open_disc();
+
+	if (!was_already_open) {
+		/* we are closing disc, but some information stored in
+		   cdw_cdio_disc_t *disc will still be valid */
+		cdw_cdio_disc_close();
+	}
+
+	if (m == CDW_GEN_ERROR) {
+		cdw_vdm ("ERROR: failed to get meta info\n");
+
+		/* it is safe to remove information collected by cdio calls
+		   (if there is any anyway), because if
+		   cdw_cdio_get_disc_meta_information() fails at some point,
+		   then part of information may be correct and other part
+		   incorrect, so better lets reset all */
+		cdw_cdio_disc_reset();
+		g_disc = false;
+
+
+
+	}
+
+	return m;
+}
+#endif
+
+
+
+
+
+/* *** md5sum_interface.c *** */
+
+
+
+
+/* *** unused code below *** */
+
+#if 0
+
+
+/**
+ * \brief Prepare and run commands for checking md5 sums of cd track and iso image
+ *
+ * Function checks if it is possible to read data from CD, and
+ * calls md5sum tool (using run_command()) to check md5sum of first track
+ * on CD. Then it calls md5sum again to calculate md5 sum of iso image
+ * used to write track. Both sums are then compared and appropriate message
+ * is displayed.
+ *
+ * Function sets task->tool_status.
+ *
+ * \param image_fullpath - full path to iso image for which you wan to calculate md5 sum
+ * \param task - this task iformation (task id and tool are required)
+ *
+ * \return CDW_OK on success
+ * \return CDW_MEM_ERROR on malloc errors
+ */
+cdw_rv_t run_command_md5sum_check(const char *image_fullpath, cdw_task_t *task)
+{
+	md5sum_digest_cd[0] = '\0';
+	md5sum_digest_image[0] = '\0';
+
+	/* phase one - get md5sum of first track on CD */
+	task->verify.from_cd = true;
+	cdw_rv_t crv_phase1 = cdw_md5sum_check_cd(task);
+
+	if (task->tool_status == CDW_TOOL_STATUS_OK && crv_phase1 == CDW_OK) {
+
+		/* phase two - get md5 sum of iso file */
+		task->verify.from_cd = false;
+		cdw_rv_t crv_phase2 = run_command_md5sum_check_phase_2(image_fullpath, task);
+
+		if (task->tool_status == CDW_TOOL_STATUS_OK && crv_phase2 == CDW_OK) {
+			;
+		} else {
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window */
+					   _("Failed to check md5sum of iso file."),
+					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+			return crv_phase2;
+		}
+	} else {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window;
+				      'track' refers to track on CD */
+				   _("Failed to check md5sum of track."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return crv_phase1;
+	}
+
+	size_t n_lines = 10;
+	size_t n_cols = 50;
+	size_t begin_y = ((size_t) LINES - n_lines) / 2;
+	size_t begin_x = ((size_t) COLS - n_cols) / 2;
+	WINDOW *window = newwin((int) n_lines, (int) n_cols, (int) begin_y, (int) begin_x);
+
+	if (window == (WINDOW *) NULL) {
+		if (!strcmp(md5sum_digest_cd, md5sum_digest_image)) {
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Message"),
+					   /* 2TRANS: this is message in dialog window:
+					      it describes result of verification */
+					   _("ISO image and burned track are the same."),
+					   CDW_BUTTONS_OK, CDW_COLORS_DIALOG);
+		} else {
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window:
+					      it describes result of verification */
+					   _("ISO image and burned track are different."),
+					   CDW_BUTTONS_OK, CDW_COLORS_WARNING);
+		}
+	} else {
+		werase(window);
+		keypad(window, TRUE);
+		/* 2TRANS: this is title of dialog window, 'verification'
+		   refers to verifying correctness of burning */
+		cdw_ncurses_nice_box(window, _("Verification results"),
+				     /* 2TRANS: this is string at the bottom of dialog
+					window: a hint for user */
+				     _("Press ENTER to close"));
+
+		if (!strcmp(md5sum_digest_cd, md5sum_digest_image)) {
+			wbkgd(window, COLOR_PAIR(CDW_COLORS_DIALOG));
+			mvwprintw(window, 2, 3,
+				  /* 2TRANS: this is message in dialog window:
+				     it describes result of verification */
+				  _("ISO image and burned track are the same."));
+		} else {
+			wbkgd(window, COLOR_PAIR(CDW_COLORS_WARNING));
+			mvwprintw(window, 2, 3,
+				  /* 2TRANS: this is message in dialog window:
+				     it describes result of verification */
+				  _("ISO image and burned track are different."));
+		}
+
+		/* 2TRANS: this is message in dialog window:
+		   'track' refers to data track on CD  */
+		mvwprintw(window, 4, 3, _("md5sum of track:"));
+		/* 2TRANS: this is part of message in dialog window:
+		   %s will be replaced with md5 digest; keep leading spaces */
+		mvwprintw(window, 5, 3, _("   \"%s\""), md5sum_digest_cd);
+		/* 2TRANS: this is message in dialog window */
+		mvwprintw(window, 6, 3, _("md5sum of iso image:"));
+		/* 2TRANS: this is part of message in dialog window:
+		   %s will be replaced with md5 digest; keep leading spaces */
+		mvwprintw(window, 7, 3, _("   \"%s\""), md5sum_digest_image);
+		wrefresh(window);
+
+		int c = 'a';
+		while (c != CDW_ENTER) {
+			c = wgetch(window);
+		}
+
+		delwin(window);
+		window = (WINDOW *) NULL;
+
+		cdw_main_ui_main_window_wrefresh_part(n_lines, n_cols, begin_y, begin_x);
+	}
+
+	/* 2TRANS: this is text written to log file: a header printed before
+	   two md5 sums for track and for ISO image are printed */
+	cdw_logging_write(_("\n\nmd5 sums:\n"));
+	/* 2TRANS: this is text written to log file: %s is a md5 digest of
+	   data written to first track of CD */
+	cdw_logging_write(_("md5 sum of written data: %s\n"), md5sum_digest_cd);
+	/* 2TRANS: this is text written to log file: %s is md5 digest of
+	   data from iso image */
+	cdw_logging_write(_("md5 sum of iso image:    %s\n"), md5sum_digest_image);
+	cdw_logging_write("\n\n");
+
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_md5sum_check_cd(cdw_task_t *task)
+{
+	cdw_rv_t crp = cdw_read_disc_check_preconditions(task);
+	if (crp != CDW_OK) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window:
+				      some preconditions of reading a CD were not met */
+				   _("Read preconditions not met"),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return crp;
+	}
+
+	/* 2TRANS: this is title of progress window */
+	cdw_processwin_create(_("Verification of md5 sums"),
+			      /* 2TRANS: this is message in progress window:
+				 description of task currently performed */
+			      _("Calculating md5sum of written track"), true);
+
+	cdw_assert (task->verify.tool.fullpath != (char *) NULL, "ERROR: tool fullpath is NULL\n");
+	/* yes, just a path to executable */
+	run_command(task->verify.tool.fullpath, task);
+
+	/* 2TRANS: this is message in progress window: 'calculation'
+	   refers to calculating md5sum */
+	cdw_processwin_destroy(_("Calculation done"), false);
+
+	return CDW_OK;
+}
+
+
+
+
+/* phase 2 is calculating md5sum for source iso image - the one used for burning to disc */
+cdw_rv_t run_command_md5sum_check_phase_2(const char *image_fullpath, cdw_task_t *task)
+{
+	cdw_assert (task->verify.tool.fullpath != (char *) NULL, "ERROR: tool fullpath is NULL\n");
+	char *command = cdw_string_concat(task->verify.tool.fullpath, " < /bin/cat ", image_fullpath, (char *) NULL);
+
+	if (command == (char *) NULL) {
+		return CDW_MEM_ERROR;
+	}
+
+	/* 2TRANS: this is title of progress window */
+	cdw_processwin_create(_("Verification of md5 sums"),
+			      /* 2TRANS: this is message in progress window:
+				 description of task currently performed */
+			      _("Calculating md5sum of iso image"), false);
+
+	CDW_TASK_CREATE_TASK(iso_md5sum_task, CDW_TASK_CHECK_MD5SUM);
+	iso_md5sum_task.verify.from_cd = false;
+	run_command(command, &iso_md5sum_task);
+
+	/* 2TRANS: this is message in progress window: 'verification'
+	   refers to verifying correctness of burning; no reference to
+	   success/failure of verification */
+	cdw_processwin_destroy(_("Verification finished"), true);
+
+	free(command);
+	command = (char *) NULL;
+
+	task->tool_status |= iso_md5sum_task.tool_status;
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+ * \brief Initialize cdio disc for reading of data track
+ *
+ * Open cdio disc and get its metadata needed for further reading of
+ * sectors from first track. Function will return CDW_GEN_ERROR if
+ * disc cannot be open, if function cannot read metainformation from that
+ * disc, if there is more than one track or if the track is of wrong kind.
+ *
+ * \return CDW_OK on success
+ * \return CDW_NO if disc has more than one track or the track is of wrong kind
+ * \return CDW_GEN_ERROR on other problems
+ */
+cdw_rv_t md5sum_set_up_reading_track(void)
+{
+	cdw_rv_t crv = cdw_cdio_open_disc(config.cdrw_device);
+
+	if (crv != CDW_OK) {
+		cdw_sdm ("failed to open disc\n");
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window: disc
+				      is in drive, but cdw cannot open it using a
+				      library API */
+				   _("Cannot open disc."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return CDW_GEN_ERROR;
+	} else {
+		cdw_rv_t mi = cdw_cdio_get_disc_meta_info();
+		if (mi != CDW_OK) {
+			cdw_sdm ("failed to read meta info (%d)\n", (int) mi);
+			return CDW_GEN_ERROR;
+		} else {
+			cdw_sdm ("meta info read properly\n");
+		}
+	}
+
+	/* we can verify only first track of type supported by cdw */
+	track_t n_tracks = cdw_cdio_get_number_of_tracks();
+	track_t first_track = cdw_cdio_get_first_track();
+
+	if (n_tracks == 1
+	    && cdw_cdio_is_data_track(first_track)) {
+
+		return CDW_OK;
+	} else {
+		return CDW_NO;
+	}
+}
+
+
+
+
+
+/**
+ * \brief Read first track of CD disc
+ *
+ * Read first track from disc opened with md5sum_set_up_reading_track(),
+ * write sectors that you read to given file descriptor. The file
+ * descriptor must be associated with file that is already open for
+ * writing.
+ *
+ * Function sets reading_success flag according to result of reading.
+ *
+ * \param file - target file descriptor
+ *
+ * \return CDW_OK on read success
+ * \return CDW_GEN_ERROR on read failure
+ */
+cdw_rv_t md5sum_read_track_write_to_fd(int file)
+{
+	track_t i = cdw_cdio_get_first_track_number();
+	cdw_sdm ("reading track %d\n", (int) i);
+	cdw_rv_t rv = cdw_cdio_copy_sectors_to_file(i, file);
+	if (rv != CDW_OK) {
+		/* if any error will occur for any track, then
+		   mark whole operation as unsuccessful */
+		reading_success = false;
+
+		cdw_sdm ("reading track %d failed (%d)\n", (int) i, (int) rv);
+		return CDW_GEN_ERROR;
+	} else {
+		reading_success = true;
+
+		cdw_vdm ("reading track %d succeeded\n", (int) i);
+		return CDW_OK;
+	}
+}
+
+
+
+
+
+/**
+ * \brief Close disc that you have opened with md5sum_set_up_reading_track()
+ *
+ * Function closes disc using proper cdio call.
+ */
+void md5sum_clean_up_reading_track(void)
+{
+	cdw_cdio_close_disc();
+}
+
+#endif
+
+
+
+
+/* *** thread.c *** */
+
+
+#if 0
+void *write_to_md5sum_stdin(__attribute__((unused)) void *dummy)
+{
+	cdw_sdm ("thread awaits for data\n");
+
+	cdw_rv_t crv = md5sum_set_up_reading_track();
+	if (crv == CDW_GEN_ERROR) { /* libcdio failed to open disc ? */
+		thread_task->tool_status |= CDW_TOOL_STATUS_LIBCDIO_SETUP_FAIL;
+		cdw_vdm ("ERROR: tool_status |= CDW_TOOL_STATUS_LIBCDIO_SETUP_FAIL\n");
+	} else if (crv == CDW_NO) {
+		/* called md5 code for disc with more than one track or for
+		   track of wrong type; will be handled by higher level code;
+		   either way this is more like programing error, but let's
+		   handle this nicely, not by assert() */
+
+		thread_task->tool_status |= CDW_TOOL_STATUS_VERIFY_WRONG_TRACK;
+		cdw_vdm ("ERROR: tool_status |= CDW_TOOL_STATUS_VERIFY_WRONG_TRACK\n");
+	} else {
+		/* read track from CD to our end of stdin pipe -> to child process */
+		crv = md5sum_read_track_write_to_fd(stdin_pipe[PARENTS_END]);
+		if (crv != CDW_OK) {
+			thread_task->tool_status |= CDW_TOOL_STATUS_LIBCDIO_READ_FAIL;
+			cdw_vdm ("ERROR: tool_status |= CDW_TOOL_STATUS_LIBCDIO_READ_FAIL\n");
+			/* don't return, disc should be closed */
+		}
+	}
+
+	/* closing file equals marking end of input for md5sum */
+	close(stdin_pipe[PARENTS_END]);
+
+	md5sum_clean_up_reading_track();
+
+	return NULL;
+}
+
+#endif
+
+
+
+/* *** from growisofs_pipe_regexp.c *** */
+
+
+/**
+ * growisofs, when writing files directly, uses mkisofs to create iso image
+ * file. mkisofs messages are put to growisofs output. They are captured
+ * by growisofs pipe regexp code and handled by this function.
+ * mkisofs messages for creating image file look like this:
+ *
+ * "89.37% done, estimate finish Fri Apr 25 22:03:43 2008"
+ *
+ * This information can be used as indication of progress of writing files to
+ * dvd. Currently handle_growisofs_mkisofs_image() processes only percentage
+ * information. Note that mkisofs does not inform about finish of creating
+ * image - no '100% done' information is displayed.
+ */
+void handle_growisofs_mkisofs_image(regex_t *regex, regmatch_t *matches)
+{
+	cdw_sdm ("called\n");
+
+	growisofs_writing_performed = true;
+
+	int perc_a = 0, perc_b = 0;
+
+	unsigned int i;
+	for (i = 0; i < (regex->re_nsub + 1); ++i) {
+		size_t len = (size_t) (matches[i].rm_eo - matches[i].rm_so);
+		char submatch[PIPE_BUFFER_SIZE];
+		strncpy(submatch, (char *) &stderr_pipe_buffer[matches[i].rm_so], len);
+		submatch[len] = '\0';
+		if (i == 1) {
+			;
+		} else if (i == 2) {
+			perc_a = atoi(submatch);
+			cdw_sdm ("i = %d, submatch = %s\n", i, submatch);
+		} else if (i == 3) {
+			perc_b = atoi(submatch);
+			cdw_sdm ("i = %d, submatch = %s\n", i, submatch);
+		} else {
+			;
+		}
+	}
+
+	if (thread_task->id == CDW_TASK_BURN_FROM_FILES) {
+		/* TODO: is this condition really needed? Dispatching in
+		   pipe_regexp.c should be enough to avoid any mistakes
+		   with capturing printed info */
+
+		double current_done = perc_a + 0.01 * perc_b;
+		char progress_string[PROCESSWIN_MAX_RTEXT_LEN + 1];
+		/* 2TRANS: this is message displayed in process progress window:
+		   %f%% is percentage of task already done */
+		snprintf(progress_string, PROCESSWIN_MAX_RTEXT_LEN + 1, _("%.2f%% done"), current_done);
+
+		cdw_processwin_display_progress_conditional(perc_a, 100, progress_string);
+		/* 2TRANS: this is message displayed in process progress window:
+		   writing date to DVD is in progress */
+		cdw_processwin_display_text_info(2, _("Writing data in progress..."));
+
+		cdw_sdm ("perc_a = %d, perc_b = %d, done = %f\n", perc_a, perc_b, current_done);
+	}
+
+	cdw_processwin_wrefresh();
+
+	return;
+}
+
+
+
+
+
+
+/* from cdw_config_ui_internals.c */
+
+
+
+
+
+#if 0
+
+/**
+   \brief Create fields that are shown on page D of configuration window
+
+   Create fields that are shown on page D of configuration window,
+   including initialization of size and position (all N_FIELDS_D
+   of them, not including last one which is of course NULL), set their
+   types, options and appearance.
+
+   Fields will be initialized with values from \p tmp_config.
+   Basic check for correcness of creating fields is performed, but it may
+   not be perfect.
+
+   \param tmp_config - variable holding current configuration
+
+   \return CDW_OK when all fields were created (probably) without problems
+   \return CDW_GEN_ERROR if one of fields was created incorrectly
+*/
+cdw_rv_t page_d_build_fields_old(cdw_config_t *tmp_config)
+{
+	int i = 0;
+	for (i = 0; i < N_FIELDS_D; i++) {
+		fields_form_d[i] = (FIELD *) NULL;
+	}
+
+	/* put fields_form_d in pairs: label field :: entry field */
+
+	size_t r = 0; /* row number */
+
+	/* 2TRANS: this is input field label: keep no longer than original;
+	   volume id is name of cd visible e.g. in file manager */
+	fields_form_d[f_volumeid_l] = cdw_label_field_new(LABEL_WIDTH, r, FIRST_COL, _("Default volume ID"));
+	fields_form_d[f_volumeid_i] = cdw_input_field_new(1, 19, r, SECOND_COL,
+							  tmp_config->volumeid,
+							  VOLUME_ID_LEN_MAX);
+
+	r++;
+
+	/* 2TRANS: this is checkbox label: keep no longer than original;
+	   volume id is name of cd visible e.g. in file manager */
+	fields_form_d[f_showvol_l] = cdw_label_field_new(LABEL_WIDTH, r, FIRST_COL, _("Ask for volume ID"));
+	fields_form_d[f_showvol_i] = cdw_checkbox_field_new(r, SECOND_COL, tmp_config->showvol ? "X" : " ");
+
+	r++;
+
+	/* 2TRANS: this is dropdown label: keep no longer than original */
+	fields_form_d[f_iso_level_l] = cdw_label_field_new(LABEL_WIDTH, r, FIRST_COL, _("ISO level"));
+
+
+	size_t ild_width = 5;
+	/* NOTE: dropdown must be wider than underlying field and no
+	   printed part of dropdown can be placed in input field area */
+	cdw_assert (0 < tmp_config->iso_level && tmp_config->iso_level < 5,
+		    "iso level value out of range: %zd\n", tmp_config->iso_level);
+	iso_level_dropdown = cdw_dropdown_new(subwindows[PAGE_D_INDEX],
+					      r, SECOND_COL - 1, ild_width + 3,
+					      iso_level_labels,
+					      /* -1 because iso_level_labels[] is indexed from 0 */
+					      tmp_config->iso_level - 1,
+					      CDW_COLORS_DIALOG);
+	fields_form_d[f_iso_level_i] = cdw_input_field_new(1, ild_width, r, SECOND_COL,
+							   iso_level_labels[tmp_config->iso_level - 1], 0);
+
+	r++;
+
+	/* 2TRANS: this is checkbox label: keep no longer than original */
+	fields_form_d[f_joliet_l] = cdw_label_field_new(LABEL_WIDTH, r, FIRST_COL, _("Joliet information"));
+	fields_form_d[f_joliet_i] = cdw_checkbox_field_new(r, SECOND_COL, tmp_config->joliet ? "X" : " ");
+
+	r++;
+
+	/* 2TRANS: this is checkbox label: keep no longer than original;
+	   you probably want to keep it untranslated */
+	fields_form_d[f_rockridge_l] = cdw_label_field_new(LABEL_WIDTH, r, FIRST_COL, _("Rock Ridge"));
+	fields_form_d[f_rockridge_i] = cdw_checkbox_field_new(r, SECOND_COL, tmp_config->rockridge ? "X" : " ");
+
+	r++;
+
+	/* 2TRANS: this is checkbox label: keep no longer than original */
+	fields_form_d[f_useful_rr_l] = cdw_label_field_new(LABEL_WIDTH, r, FIRST_COL, _("Useful RR attributes"));
+	fields_form_d[f_useful_rr_i] = cdw_checkbox_field_new(r, SECOND_COL, tmp_config->usefulRR ? "X" : " ");
+
+	r++;
+
+	/* 2TRANS: this is checkbox label: keep no longer than original */
+	fields_form_d[f_follow_symlinks_l] = cdw_label_field_new(LABEL_WIDTH, r, FIRST_COL, _("Follow symbolic links"));
+	fields_form_d[f_follow_symlinks_i] = cdw_checkbox_field_new(r, SECOND_COL, tmp_config->follow_symlinks ? "X" : " ");
+
+	r += 2;
+
+	/* 2TRANS: this is input field label:
+	   keep no longer than original; image = iso image */
+	fields_form_d[f_tempdir_l] = cdw_label_field_new(WIDE_FIELD_WIDTH, r, FIRST_COL, _("Path to default data image file:"));
+
+	r++;
+
+	fields_form_d[f_tempdir_i] = cdw_input_field_new(1, WIDE_FIELD_WIDTH, r, FIRST_COL, tmp_config->tempdir, 0);
+
+	r += 2;
+
+	/* 2TRANS: this is input field label: keep no longer than original;
+	   input field holds full path to image file */
+	fields_form_d[f_bootimg_l] = cdw_label_field_new(WIDE_FIELD_WIDTH, r, FIRST_COL, _("Path to boot image file (not tested):"));
+
+	r++;
+
+	fields_form_d[f_bootimg_i] = cdw_input_field_new(1, WIDE_FIELD_WIDTH, r, FIRST_COL, tmp_config->bootimg, 0);
+
+	r += 2;
+
+	/* 2TRANS: this is input field label: keep no longer than original;
+	   other options passed to program creating iso image */
+	fields_form_d[f_omo_l] = cdw_label_field_new(WIDE_FIELD_WIDTH, r, FIRST_COL, _("Other \"mkisofs\" options:"));
+
+	r++; /* ************ 14th row ************ */
+
+	fields_form_d[f_omo_i] = cdw_input_field_new(1, WIDE_FIELD_WIDTH, r, FIRST_COL,  tmp_config->other_mkisofs_options, 0);
+
+	fields_form_d[N_FIELDS_D] = (FIELD *) NULL;
+
+	for (i = 0; i < N_FIELDS_D; i++) {
+		if (fields_form_d[i] == (FIELD *) NULL) {
+			cdw_vdm ("ERROR: failed to initialize fields_form_d[%d]\n", i);
+			return CDW_GEN_ERROR;
+		}
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+ * \brief Highlight a dropdown that is on given page and has given index
+ *
+ * Function calls cdw_dropdown_focus() function to bring focus to the
+ * dropdown that is used on page \p pi and has index \p fi.
+ *
+ * \param pi - page index, index of page that is currently visible
+ * \param fi - field index, index of field that has keyboard focus
+ */
+void page_u_driver_dropdown_focus(int pi, int fi)
+{
+	if (pi == PAGE_A_INDEX && fi == f_speed_i) {
+		cdw_dropdown_focus(speed_dropdown);
+	} else if (pi == PAGE_D_INDEX && fi == f_iso_level_i) {
+		cdw_dropdown_focus(iso_level_dropdown);
+
+	} else if (pi == PAGE_E_INDEX) {
+		cdw_dropdown_unfocus(mkisofs_dropdown);
+		cdw_dropdown_unfocus(cdrecord_dropdown);
+		cdw_dropdown_unfocus(growisofs_dropdown);
+		cdw_dropdown_unfocus(dvd_rw_mediainfo_dropdown);
+		cdw_dropdown_unfocus(dvd_rw_format_dropdown);
+		cdw_dropdown_unfocus(tools_for_burning_dvd_dropdown);
+
+		if (fi == f_mkisofs_path_i) {
+			cdw_dropdown_focus(mkisofs_dropdown);
+		} else if (fi == f_cdrecord_path_i) {
+			cdw_dropdown_focus(cdrecord_dropdown);
+		} else if (fi == f_growisofs_path_i) {
+			cdw_dropdown_focus(growisofs_dropdown);
+		} else if (fi == f_dvd_rw_mediainfo_path_i) {
+			cdw_dropdown_focus(dvd_rw_mediainfo_dropdown);
+		} else if (fi == f_dvd_rw_format_path_i) {
+			cdw_dropdown_focus(dvd_rw_format_dropdown);
+		} else if (fi == f_tools_for_burning_dvd_i) {
+			cdw_dropdown_focus(tools_for_burning_dvd_dropdown);
+		} else {
+			;
+		}
+	} else {
+		;
+	}
+
+	form_driver(forms[pi], REQ_INS_MODE);
+
+	curs_set(0);
+	wrefresh(subwindows[pi]);
+	return;
+}
+
+
+
+
+
+/**
+   \brief Unhighlight a dropdown that is on given page and has given index
+
+   Function calls cdw_dropdown_unfocus() function to remove focus from all
+   dropdowns used on page \p pi.
+
+  \param pi - page index, index of page that is currently visible
+*/
+void page_u_driver_dropdown_unfocus(int pi)
+{
+	if (pi == PAGE_A_INDEX) {
+		cdw_dropdown_unfocus(speed_dropdown);
+	} else if (pi == PAGE_E_INDEX) {
+		cdw_dropdown_unfocus(mkisofs_dropdown);
+		cdw_dropdown_unfocus(cdrecord_dropdown);
+		cdw_dropdown_unfocus(growisofs_dropdown);
+		cdw_dropdown_unfocus(dvd_rw_mediainfo_dropdown);
+		cdw_dropdown_unfocus(dvd_rw_format_dropdown);
+		cdw_dropdown_unfocus(tools_for_burning_dvd_dropdown);
+	} else if (pi == PAGE_D_INDEX) {
+		cdw_dropdown_unfocus(iso_level_dropdown);
+	} else {
+		;
+	}
+
+	curs_set(1);
+
+	/* this is only to move cursor to current field */
+	form_driver(forms[pi], REQ_INS_MODE);
+
+	wrefresh(subwindows[pi]);
+
+	return;
+}
+
+
+
+
+
+/**
+ * \brief Create elements of page A of configuration panel
+ *
+ * Draw page A of configuration panel: create ncurses fields, ncurses
+ * form, post the form. Call cdw_config_ui_draw_non_widgets() to create non-widget
+ * elements. Initialize widgets in this page.
+ *
+ * This page contains basic and most often changed options related to
+ * writing.
+ *
+ * Option fields will be initialized using values from \p tmp_config.
+ * Window and subwindow for this page must be already created.
+ *
+ * \param tmp_config - temporary config variable with current configuration
+ *
+ * \return CDW_OK on success
+ * \return CDW_GEN_ERROR on problems with creating/posting ncurses form
+ */
+cdw_rv_t page_a_create(const cdw_config_t *tmp_config)
+{
+	/* build form fields (fields_form_a) with options and get their
+	   values from tmp_config */
+	cdw_rv_t crv = page_a_build_fields(fields_table[PAGE_A_INDEX], tmp_config);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build fields for page A\n");
+		return CDW_GEN_ERROR;
+	}
+
+	forms[PAGE_A_INDEX] = cdw_ncurses_new_form(windows[PAGE_A_INDEX],
+						   subwindows[PAGE_A_INDEX],
+						   fields_form_a);
+	if (!forms[PAGE_A_INDEX]) {
+		cdw_vdm ("ERROR: failed to create form on page A\n");
+		return CDW_GEN_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+ * \brief Create elements of page B of configuration panel
+ *
+ * Draw page B of configuration panel: create ncurses fields, ncurses
+ * form, post the form. Call page_u_draw_non_widgets() to create non-widget
+ * elements. Initialize widgets in this page.
+ *
+ * This page contains options related to hardware (disc drives) used
+ * by cdw.
+ *
+ * Option fields will be initialized using values from \p tmp_config.
+ * Window and subwindow for this page must be already created.
+ *
+ * \param tmp_config - temporary config variable with current configuration
+ *
+ * \return CDW_OK on success
+ * \return CDW_GEN_ERROR on failure
+ */
+cdw_rv_t page_b_create(const cdw_config_t *tmp_config)
+{
+	/* build form fields (fields_form_b) with options and get their
+	   values from tmp_config */
+	cdw_rv_t crv = page_b_build_fields(tmp_config);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build fields for page B\n");
+		return CDW_GEN_ERROR;
+	}
+
+	forms[PAGE_B_INDEX] = cdw_ncurses_new_form(windows[PAGE_B_INDEX],
+						   subwindows[PAGE_B_INDEX],
+						   fields_form_b);
+	if (!forms[PAGE_B_INDEX]) {
+		cdw_vdm ("ERROR: failed to create form on page B\n");
+		return CDW_GEN_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+ * \brief Create elements on page C of configuration panel
+ *
+ * Draw page C of configuration panel: create ncurses fields, ncurses
+ * form, post the form. Call page_u_draw_non_widgets() to create non-widget
+ * elements. Initialize widgets in this page.
+ *
+ * This page contains options related to ripping audio CD.
+ *
+ * Option fields will be initialized using values from \p tmp_config.
+ * Window and subwindow for this page must be already created.
+ *
+ * \param tmp_config - temporary config variable with current configuration
+ *
+ * \return CDW_OK on success
+ * \return CDW_GEN_ERROR on failure
+ */
+cdw_rv_t page_c_create(const cdw_config_t *tmp_config)
+{
+	/* build form fields (fields_form_c) with options and get their
+	   values from tmp_config */
+	cdw_rv_t crv = page_c_build_fields(tmp_config);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build fields for page C\n");
+		return CDW_GEN_ERROR;
+	}
+
+	forms[PAGE_C_INDEX] = cdw_ncurses_new_form(windows[PAGE_C_INDEX],
+						   subwindows[PAGE_C_INDEX],
+						   fields_form_c);
+	if (!forms[PAGE_C_INDEX]) {
+		cdw_vdm ("ERROR: failed to create form on page C\n");
+		return CDW_GEN_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+ * \brief Create elements on page D of configuration panel
+ *
+ * Draw page D of configuration panel: create ncurses fields, ncurses
+ * form, post the form. Call page_u_draw_non_widgets() to create non-widget
+ * elements. Initialize widgets in this page.
+ *
+ * This page contains options related to ISO file system.
+ *
+ * Option fields will be initialized using values from \p tmp_config.
+ * Window and subwindow for this page must be already created.
+ *
+ * \param tmp_config - temporary config variable with current configuration
+ *
+ * \return CDW_OK on success
+ * \return CDW_GEN_ERROR on failure
+ */
+cdw_rv_t page_d_create(const cdw_config_t *tmp_config)
+{
+	/* build form fields (fields_form_d) with options and get their
+	   values from tmp_config */
+	cdw_rv_t crv = page_d_build_fields(fields_table[PAGE_D_INDEX], tmp_config);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build fields for page D\n");
+		return CDW_GEN_ERROR;
+	}
+
+	forms[PAGE_D_INDEX] = cdw_ncurses_new_form(windows[PAGE_D_INDEX],
+						   subwindows[PAGE_D_INDEX],
+						   fields_form_d);
+	if (!forms[PAGE_D_INDEX]) {
+		cdw_vdm ("ERROR: failed to create form on page D\n");
+		return CDW_GEN_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+ * \brief Create elements on page E of configuration panel
+ *
+ * Draw page E of configuration panel: create ncurses fields, ncurses
+ * form, post the form. Call page_u_draw_non_widgets() to create non-widget
+ * elements. Initialize widgets in this page.
+ *
+ * This page contains paths to tools used by cdw.
+ *
+ * Option fields will be initialized using values from \p tmp_config.
+ * Window and subwindow for this page must be already created.
+ *
+ * \param tmp_config - temporary config variable with current configuration
+ *
+ * \return CDW_OK on success
+ * \return CDW_GEN_ERROR on failure
+ */
+cdw_rv_t page_e_create(const cdw_config_t *tmp_config)
+{
+	/* build form fields (fields_form_e) with options and get their
+	   values from tmp_config */
+	cdw_rv_t crv = page_e_build_fields(tmp_config);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build fields for page E\n");
+		return CDW_GEN_ERROR;
+	}
+
+	forms[PAGE_E_INDEX] = cdw_ncurses_new_form(windows[PAGE_E_INDEX],
+						   subwindows[PAGE_E_INDEX],
+						   fields_form_e);
+	if (!forms[PAGE_E_INDEX]) {
+		cdw_vdm ("ERROR: failed to create form on page E\n");
+		return CDW_GEN_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+ * \brief Create elements on page F of configuration panel
+ *
+ * Draw page F of configuration panel: create ncurses fields, ncurses
+ * form, post the form. Call page_u_draw_non_widgets() to create non-widget
+ * elements. Initialize widgets in this page.
+ *
+ * This page contains paths to tools used by cdw.
+ *
+ * Option fields will be initialized using values from \p tmp_config.
+ * Window and subwindow for this page must be already created.
+ *
+ * \param tmp_config - temporary config variable with current configuration
+ *
+ * \return CDW_OK on success
+ * \return CDW_GEN_ERROR on failure
+ */
+cdw_rv_t page_f_create(const cdw_config_t *tmp_config)
+{
+	/* build form fields (fields_form_f) with options and get their
+	   values from tmp_config */
+	cdw_rv_t crv = page_f_build_fields(tmp_config);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build fields for page F\n");
+		return CDW_GEN_ERROR;
+	}
+
+	forms[PAGE_F_INDEX] = cdw_ncurses_new_form(windows[PAGE_F_INDEX],
+						   subwindows[PAGE_F_INDEX],
+						   fields_form_f);
+	if (!forms[PAGE_F_INDEX]) {
+		cdw_vdm ("ERROR: failed to create form on page F\n");
+		return CDW_GEN_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+/* ***** write wizard ***** */
+
+
+
+
+/* *** unused code below *** */
+
+#if 0
+
+/**
+   \brief Generate list of strings representing writing modes valid for given disc
+
+   Generate list of (char *) strings representing valid writing modes. Last
+   element of the list should be (char *) NULL. The strings are stored in
+   session_mode_dropdown_labels[]; int values of type cdw_write_session_mode_t, correlated to
+   values of these strings and used as IDs, will be placed in
+   session_mode_dropdown_indexes[].
+
+   The strings are built based on disc type and value of
+   current_disc.disc_write_status. Their values will be sth like this:
+   \li "Start multisession disc";
+   \li "Create single session disc";
+   \li "Continue multi-session disc";
+   \li "Write final session (close disc)";
+
+   The strings stored in session_mode_dropdown_labels[] should be freed using
+   x_dropdown_labels_destroy().
+
+   \param dropdown_labels - list of dropdown label strings, to be initialized
+   \param session_modes - list of session modes allowed for current writing
+
+   \return CDW_OK if list is generated successfully
+   \return CDW_MEM_ERROR on malloc() error
+   \return CDW_GEN_ERROR if other error occurs
+*/
+cdw_rv_t session_mode_dropdown_labels_build(char ***dropdown_labels, int *session_modes)
+{
+	/* labels for _all_ possible session modes allowed for any optical disc */
+	char *mode_labels[CDW_SESSION_MODE_N_MAX];
+
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_SESSION_MODE_START_MULTI] = strdup(_("Start new, appendable disc"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_SESSION_MODE_CREATE_SINGLE] = strdup(_("Create non-appendable disc"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_SESSION_MODE_CONTINUE_MULTI] = strdup(_("Append data, don\'t close disc"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_SESSION_MODE_WRITE_FINAL] = strdup(_("Append data and close disc"));
+	/* 2TRANS: label visible in dropdown menu - some error occurred */
+	mode_labels[CDW_SESSION_MODE_ERROR] = strdup(_("(ERROR)"));
+
+	size_t i = 0;
+	for (i = 0; i < CDW_SESSION_MODE_N_MAX; i++) {
+		if (! mode_labels[i]) {
+			int j = 0;
+			for (j = 0; j < CDW_SESSION_MODE_N_MAX; j++) {
+				free(mode_labels[j]);
+				mode_labels[j] = (char *) NULL;
+			}
+			cdw_vdm ("ERROR: strdup() failed for mode_labels[%zd]\n", i);
+			return CDW_MEM_ERROR;
+		} else {
+			cdw_vdm ("  session mode label[%zd] = \"%s\"\n", i, mode_labels[i]);
+		}
+
+	}
+
+	size_t n_labels = 0;
+	for (n_labels = 0; n_labels < CDW_SESSION_MODE_N_MAX; n_labels++) {
+		/* session_mode_ids is non-sparse up until
+		   element of value CDW_SESSION_MODE_INIT */
+		if (session_modes[n_labels] == CDW_SESSION_MODE_INIT) {
+			break;
+		}
+	}
+
+	/* +1 is for guard */
+	*dropdown_labels = (char **) malloc ((n_labels + 1) * sizeof (char *));
+	if (! (*dropdown_labels)) {
+		cdw_vdm ("ERROR: malloc() failed to allocate %zd bytes for dropdown_labels\n", n_labels + 1);
+		return CDW_MEM_ERROR;
+	}
+
+	for (i = 0; i < n_labels; i++) {
+		int id = session_modes[i];
+		cdw_assert (id != CDW_SESSION_MODE_INIT, "found INIT in allowed session modes for i = %d\n", (int) i);
+		(*dropdown_labels)[i] = strdup(mode_labels[id]);
+		if (! (*dropdown_labels)[i]) {
+			cdw_vdm ("ERROR: failed to strdup() mode label \"%s\" (id = %d)\n", mode_labels[id], id);
+			return CDW_MEM_ERROR;
+		}
+
+	}
+	/* guard */
+	(*dropdown_labels)[n_labels] = (char *) NULL;
+
+	/* debug code */
+	for (i = 0; i < n_labels; i++) {
+		cdw_vdm ("session mode dropdown labels[%d] = \"%s\"\n", (int) i, (*dropdown_labels)[i]);
+	}
+
+	int j = 0;
+	for (j = 0; j < CDW_SESSION_MODE_N_MAX; j++) {
+		free(mode_labels[j]);
+		mode_labels[j] = (char *) NULL;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+   \brief Create labels used in disc mode writing dropdown
+
+   Create char strings such as "tao" and "dao" that will be used as
+   labels in dropdown that allows to select mode of writing to disc.
+
+   Set of labels is selected based on value of current_disc->simple_type.
+
+   \param current_disc - variable describing disc currently in drive
+
+   \return CDW_GEN_ERROR when some values in current_disc or \p task are incorrect
+   \return CDW_MEM_ERROR when some malloc() call fails
+   \return CDW_OK on success
+*/
+cdw_rv_t disc_mode_dropdown_labels_build(char ***dropdown_labels, int *disc_modes)
+{
+	/* _all_ possible types of writing mode allowed for optical disc */
+	char *mode_labels[CDW_DISC_MODE_N_MAX];
+
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_DISC_MODE_UNSPECIFIED] = strdup(_("Unspecified"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_DISC_MODE_TAO] = strdup(_("TAO"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_DISC_MODE_DAO] = strdup(_("DAO"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_DISC_MODE_SAO] = strdup(_("SAO"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_DISC_MODE_RAW] = strdup(_("RAW"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_DISC_MODE_RAW96P] = strdup(_("RAW96R"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_DISC_MODE_RAW96R] = strdup(_("RAW96P"));
+	/* 2TRANS: label visible in dropdown menu - mode of writing data to optical disc */
+	mode_labels[CDW_DISC_MODE_RAW16] = strdup(_("RAW16"));
+	/* 2TRANS: label visible in dropdown menu - some error occurred */
+	mode_labels[CDW_DISC_MODE_ERROR] = strdup(_("(ERROR)"));
+
+	size_t i = 0;
+	for (i = 0; i < CDW_DISC_MODE_N_MAX; i++) {
+		if (! mode_labels[i]) {
+			int j = 0;
+			for (j = 0; j < CDW_DISC_MODE_N_MAX; j++) {
+				free(mode_labels[j]);
+				mode_labels[j] = (char *) NULL;
+			}
+			cdw_vdm ("ERROR: strdup() failed for mode_labels[%zd]\n", i);
+			return CDW_MEM_ERROR;
+		} else {
+			cdw_vdm ("INFO: disc mode label[%d] = \"%s\"\n", (int) i, mode_labels[i]);
+		}
+
+	}
+
+	size_t n_labels = 0;
+	for (n_labels = 0; n_labels < CDW_DISC_MODE_N_MAX; n_labels++) {
+		/* session_mode_ids is non-sparse up until
+		   element of value CDW_SESSION_MODE_INIT */
+		if (disc_modes[n_labels] == CDW_DISC_MODE_INIT) {
+			break;
+		}
+	}
+
+	/* +1 is for guard */
+	*dropdown_labels = (char **) malloc ((n_labels + 1) * sizeof (char *));
+	if (! (*dropdown_labels)) {
+		cdw_vdm ("ERROR: malloc() failed to allocate %zd bytes for dropdown_labels\n", n_labels + 1);
+		return CDW_MEM_ERROR;
+	}
+
+	for (i = 0; i < n_labels; i++) {
+		int id = disc_modes[i];
+		cdw_assert (id != CDW_DISC_MODE_INIT, "found INIT in allowed disc modes for i = %d\n", (int) i);
+		(*dropdown_labels)[i] = strdup(mode_labels[id]);
+		if (! (*dropdown_labels)[i]) {
+			cdw_vdm ("ERROR: failed to strdup() mode label \"%s\" (id = %d)\n", mode_labels[id], id);
+			return CDW_MEM_ERROR;
+		}
+	}
+
+	/* this will put guard in both cases: when we met guard in loop
+	   or when we lost control over loop */
+	(*dropdown_labels)[n_labels] = (char *) NULL;
+
+	/* debug code */
+	for (i = 0; i < n_labels; i++) {
+		cdw_sdm ("disc mode dropdown labels[%d] = \"%s\"\n", i, (*dropdown_labels)[i]);
+	}
+
+	for (i = 0; i < CDW_DISC_MODE_N_MAX; i++) {
+		free(mode_labels[i]);
+		mode_labels[i] = (char *) NULL;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+#if 0
+
+/**
+   \brief Create all UI elements in wizard window
+
+   \param task - variable describing current task
+   \param disc - variable describing disc currently in drive
+
+   \return CDW_OK on success
+   \return CDW_GEN_ERROR on failure
+*/
+cdw_rv_t cdw_write_wizard_build(cdw_task_t *task, cdw_disc_t *disc)
+{
+	/* *** window *** */
+	int begin_y = ((LINES - window_n_lines) / 2) - 2;
+	int begin_x = (COLS - window_n_cols) / 2;
+	wizard.cdw_form->window = newwin(window_n_lines, window_n_cols,
+					begin_y, begin_x);
+	keypad(wizard.cdw_form->window, true);
+	wbkgd(wizard.cdw_form->window, A_NORMAL | COLOR_PAIR(CDW_COLORS_DIALOG));
+	/* 2TRANS: this is title of wizard window; 'write' as in
+	   'writing to optical disc */
+	cdw_ncurses_nice_box(wizard.cdw_form->window, _("Write wizard"),
+			     /* 2TRANS: this is tip at the bottom of window - user can
+				switch between window elements using tab key */
+			     _("Use 'Tab' key to move"));
+
+
+	/* *** main message in wizard window *** */
+	mvwprintw(wizard.cdw_form->window, top_label_row, first_col,
+		  /* 2TRANS: this is message to user: current action will
+		     be writing to %s, where %s is DVD or CD */
+		  _("You are writing to %s disc"), (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) ?
+		  /* 2TRANS: this is short name (symbol) of Compact Disc */
+		  _("CD") :
+		  /* 2TRANS: this is short name (symbol) of Digital Versatile Disc */
+		  _("DVD"));
+
+
+	/* *** configuration line *** */
+	/* 2TRANS: other options/preferences - it refers to button on
+	   which user can click to open configuration window */
+	mvwprintw(wizard.cdw_form->window, wizard.config_label_row, first_col, _("Other options:"));
+	wizard.config_button = cdw_button_new(wizard.cdw_form->window, (size_t) wizard.config_label_row + 1,
+					      (size_t) first_col + 2,
+					      /* 2TRANS: button label; this is the
+						 same string as label of button in
+						 menu of main ui window */
+					      _("Configuration"), CDW_COLORS_DIALOG);
+
+
+	/* *** buttons at the bottom *** */
+	wizard.write_button = cdw_button_new(wizard.cdw_form->window, buttons_row, 3,
+					     /* 2TRANS: button label, it refers to writing to optical disc */
+					     _("Write"), CDW_COLORS_DIALOG);
+	wizard.cancel_button = cdw_button_new(wizard.cdw_form->window, buttons_row, 15,
+					      /* 2TRANS: button label */
+					      _("Cancel"), CDW_COLORS_DIALOG);
+#if 0 /* not in this release */
+	wizard.help_button = cdw_button_new(wizard.cdw_form->window, buttons_row, 28,
+					    /* 2TRANS: button label */
+					    _("Help"), CDW_COLORS_DIALOG);
+#endif
+
+	/* *** speed dropdown *** */
+
+	/* 2TRANS: this is a label in write wizard, after which
+	   a writing speed selection list will be displayed */
+	mvwprintw(wizard.cdw_form->window, (int) wizard.speed.label_row, first_col, _("Writing speed:"));
+	/* this function also sets which dropdown item is selected at the beginning */
+	wizard.speed.dropdown = cdw_write_wizard_make_speed_dropdown(disc);
+	if (wizard.speed.dropdown == (CDW_DROPDOWN *) NULL) {
+		cdw_vdm ("ERROR: failed to create speed dropdown\n");
+		return CDW_GEN_ERROR;
+	}
+	cdw_dropdown_display_current_item(wizard.speed.dropdown);
+
+
+	/* *** session mode dropdown *** */
+
+	/* 2TRANS: this is a label in write wizard, after which
+	   a session writing mode selection list will be displayed */
+	mvwprintw(wizard.cdw_form->window, (int) wizard.session_mode.label_row, first_col, _("Session writing mode:"));
+	/* this function also sets which dropdown item is selected at the beginning */
+	wizard.session_mode.dropdown = cdw_write_wizard_make_session_mode_dropdown(task);
+	if (wizard.session_mode.dropdown == (CDW_DROPDOWN *) NULL) {
+		cdw_vdm ("ERROR: failed to create session mode dropdown\n");
+		return CDW_GEN_ERROR;
+	}
+	cdw_dropdown_display_current_item(wizard.session_mode.dropdown);
+
+
+	/* *** disc mode dropdown *** */
+
+	/* 2TRANS: this is a label in write wizard, after which
+	   a disc writing mode selection list will be displayed */
+	mvwprintw(wizard.cdw_form->window, (int) wizard.disc_mode.label_row, first_col, _("Disc writing mode:"));
+	/* this function also sets which dropdown item is selected at the beginning */
+	wizard.disc_mode.dropdown = cdw_write_wizard_make_disc_mode_dropdown(task);
+	if (wizard.disc_mode.dropdown == (CDW_DROPDOWN *) NULL) {
+		cdw_vdm ("ERROR: failed to create session mode dropdown\n");
+		return CDW_GEN_ERROR;
+	}
+	cdw_dropdown_display_current_item(wizard.disc_mode.dropdown);
+
+
+	/* *** verify checkbox *** */
+
+	task->burn.verify = false;
+
+	if (disc->cdio_blank
+	    && (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD)
+	    && (task->id == CDW_TASK_BURN_FROM_IMAGE)
+	    && cdw_ext_tools_is_tool_available(CDW_TOOL_MD5SUM)
+	    && task->verify.tool.id == CDW_TOOL_MD5SUM) { /* this last one is added just in case */
+
+		wizard.verify_checkbox.visible = true;
+
+		/* checkbox should be unchecked by default */
+		wizard.verify_checkbox.checked = false;
+		cdw_put_ckbox(wizard.cdw_form->window, (int) wizard.verify_checkbox.label_row, first_col + 1);
+		mvwprintw(wizard.cdw_form->window, (int) wizard.verify_checkbox.label_row, first_col + 4,
+			  /* 2TRANS: this is label next to checkbox; marked
+			     checkbox enables verification of correctness of
+			     writing to CD; this feature is experimental */
+			  _("Verify write (experimental)"));
+	} else {
+		wizard.verify_checkbox.visible = false;
+#ifndef NDEBUG
+		cdw_write_wizard_debug_verify_invisibe(task, disc);
+#endif
+	}
+
+	return CDW_OK;
+}
+#endif
+
+
+
+
+
+#if 0
+
+/* this function is called when a movement key has been detected;
+   this function checks if current focus is on a widget that
+   implements highlighted/non-highlighted states, and if it is,
+   then highlight of current widget is turned off */
+void cdw_write_wizard_driver_focus_toggle(int pi, int fi, bool off)
+{
+	/* by default show cursor; if we are moving into button or
+	   dropdown, it will be turned off; otherwise (for input
+	   fields and checkboxes) it will stay enabled */
+	curs_set(1);
+
+	if (is_button_field_index(pi, fi)) {
+		CDW_BUTTON *button = cdw_write_wizard_get_button_from_form(pi, fi);
+		if (button != (CDW_BUTTON *) NULL) {
+			void (*function)(CDW_BUTTON *) = (void (*)(CDW_BUTTON *)) NULL;
+			if (off) {
+				function = cdw_button_unfocus;
+				/* moving away from button, display blinking cursor */
+				curs_set(1);
+			} else {
+				function = cdw_button_focus;
+				/* moving into button, don't display blinking cursor */
+				curs_set(0);
+			}
+			function(button);
+		}
+	} else if (is_dropdown_field_index(pi, fi)) {
+		CDW_DROPDOWN *dropdown = cdw_write_wizard_get_dropdown_from_form(pi, fi);
+		if (dropdown != (CDW_DROPDOWN *) NULL) {
+			void (*function)(CDW_DROPDOWN *) = (void (*)(CDW_DROPDOWN *)) NULL;
+			if (off) {
+				function = cdw_dropdown_unfocus;
+				/* moving away from dropdown, display blinking cursor */
+				curs_set(1);
+			} else {
+				function = cdw_dropdown_focus;
+				/* moving into dropdown, don't display blinking cursor */
+				curs_set(0);
+			}
+			function(dropdown);
+		}
+	} else {
+		;
+	}
+
+	form_driver(wizard.cdw_form->form, REQ_INS_MODE);
+	wrefresh(wizard.cdw_form->subwindow);
+
+	return;
+}
+
+
+#endif
+
+
+
+
+
+CDW_DROPDOWN *cdw_write_wizard_get_dropdown_from_form(int pi, int fi)
+{
+	CDW_DROPDOWN *dropdown = (CDW_DROPDOWN *) NULL;
+	FIELD *field = wizard.cdw_form->fields[fi];
+	cdw_assert (field != (FIELD *) NULL, "ERROR field %d in page %d is NULL\n", fi, pi);
+	FIELDTYPE *ft = field_type(field);
+	/* note: some fields may have ft == NULL */
+	// cdw_assert (ft != (FIELDTYPE *) NULL, "ERROR: field type of field %d in page %d is NULL\n", fi, pi);
+	if (ft == CDW_FIELD_TYPE_DROPDOWN) {
+		dropdown = (CDW_DROPDOWN *) field_userptr(field);
+		cdw_assert (dropdown != (CDW_DROPDOWN *) NULL, "ERROR: field user pointer is NULL dropdown (pi = %d, fi = %d)\n", pi, fi);
+	}
+
+	return dropdown;
+}
+
+
+
+
+CDW_BUTTON *cdw_write_wizard_get_button_from_form(__attribute__((unused)) int pi, int fi)
+{
+	CDW_BUTTON *button = (CDW_BUTTON *) NULL;
+	if (fi == f_write_i) {
+		button = wizard.write_button;
+	} else if (fi == f_cancel_i) {
+		button = wizard.cancel_button;
+	} else if (fi == f_config_i) {
+		button = wizard.config_button;
+	} else {
+		;
+	}
+
+	return button;
+}
+
+
+
+
+bool is_button_field_index(__attribute__((unused)) int pi, int fi)
+{
+	if (fi == f_write_i || fi == f_cancel_i || fi == f_config_i) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+
+
+bool is_dropdown_field_index(__attribute__((unused)) int pi, int fi)
+{
+	if (fi == f_speed_i || fi == f_disc_i || fi == f_session_i) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+
+bool is_checkbox_field_index(__attribute__((unused)) int pi, int fi)
+{
+	if (fi == f_verify_i) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+
+
+
+
+#endif
+
+
+
+
+
+/* cdw_config_ui.c */
+
+
+
+
+/**
+   \brief Display dialog window in which user can enter and edit string
+
+   The string is validated with cdw_string_input_string_security_parser()
+   function, and if the validation fails then user is prompted with error
+   message and asked to enter data again.
+
+   If operation of entering string fails then original string (data->buffer)
+   is not modified.
+
+   \param data - structure with all data necessary to display and edit a string;
+
+   \return CDW_OK on success
+   \return CDW_CANCEL if user pressed escape in editing window
+   \return CDW_GEN_ERROR on errors
+*/
+cdw_rv_t cdw_config_ui_get_safe_string(cdw_safe_input_data_t *data)
+{
+	char *tmp = strdup(*(data->buffer)); /* set initial value printed in dialog */
+	cdw_assert (tmp != (char *) NULL, "ERROR: failed to strdup() data\n");
+
+	cdw_rv_t crv = CDW_CANCEL;
+	for (int i = 0; i < data->attempts_max; i++) {
+		crv = cdw_input_dialog(data->input_title,
+				       data->input_message, &tmp,
+				       data->input_type, data->chars_max);
+		if (crv != CDW_OK) {
+			free(tmp);
+			tmp = (char *) NULL;
+			return crv;
+		}
+
+		cdw_rv_t sec = cdw_string_input_string_security_parser(tmp);
+		if (sec == CDW_OK) {
+			cdw_vdm ("INFO: %s: \"%s\" is secure\n", data->debug_id, tmp);
+			crv = cdw_string_set(data->buffer, tmp);
+			cdw_assert (crv == CDW_OK, "ERROR: failed to save final %s string\n", data->debug_id);
+			free(tmp);
+			tmp = (char *) NULL;
+			return CDW_OK;
+		} else {
+			cdw_vdm ("ERROR: insecure string in %s\n", data->debug_id);
+			if (i == data->attempts_max - 1) {
+				/* too many attempts to enter correct string;
+				   break loop to avoid printing "try again"
+				   error message and to go straight to final
+				   error message */
+				break;
+			}
+		}
+		cdw_rv_t conf = cdw_buttons_dialog(data->loop_error_title,
+						   data->loop_error_message,
+						   CDW_BUTTONS_OK_CANCEL, CDW_COLORS_ERROR);
+		if (conf == CDW_CANCEL) {
+			free(tmp);
+			tmp = (char *) NULL;
+			return CDW_CANCEL;
+		} else {
+			; /* loop, ask again */
+		}
+	}
+
+	cdw_buttons_dialog(data->final_error_title,
+			   data->final_error_message,
+			   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	free(tmp);
+	tmp = (char *) NULL;
+	return CDW_CANCEL;
+}
+
+
+
+
+/**
+ * \brief Display dialog window in which user can edit additional 'cdrecord' call arguments
+ */
+void cdw_config_ui_edit_cdrecord_parameters(void)
+{
+	cdw_safe_input_data_t data;
+
+	/* how many attempts? */
+	data.attempts_max = 3;
+	/* title of input window */
+	/* 2TRANS: this is title of dialog window */
+	data.window_title = _("cdrecord parameters");
+	/* message in input window */
+	/* 2TRANS: this is message in dialog window, user can
+	   enter (in input field below) some parameters that
+	   will be passed to cdrecord in command line */
+	data.prompt_message = _("Enter additional cdrecord parameters:");
+	data.input_type = CDW_NCURSES_INPUT_NONE;
+	/* maximal length of string */
+        data.chars_max = 0; /* no limit */
+	data.buffer = &(global_config.other_cdrecord_options);
+	/* error message window displayed at the end in case of failure */
+	/* 2TRANS: this is message in dialog window
+	   "parameters" are command line parameters passed to cdrecord */
+	data.error_message = _("Could not get correct cdrecord parameters.");
+
+	cdw_rv_t crv = cdw_safe_input_dialog(&data);
+	if (crv == CDW_OK) {
+		cdw_vdm ("INFO: dialog \"%s\": string saved as \"%s\"\n", data.window_title, global_config.other_cdrecord_options);
+	} else if (crv == CDW_CANCEL) {
+		;
+	} else {
+		cdw_vdm ("ERROR: \"%s\" dialog returns ERROR\n", data.window_title);
+	}
+
+	return;
+}
+
+
+
+
+
+
+
+int move_radio_selection(WINDOW * window, int radiobutton_number)
+{
+	mvwaddch(window, 4, 3, ' ');
+	mvwaddch(window, 5, 3, ' ');
+	mvwaddch(window, 6, 3, ' ');
+	mvwaddch(window, 7, 3, ' ');
+	if (radiobutton_number == 0) {
+		mvwaddch(window, 4, 3, '*');
+	} else if (radiobutton_number == 1) {
+		mvwaddch(window, 5, 3, '*');
+	} else if (radiobutton_number == 2) {
+		mvwaddch(window, 6, 3, '*');
+	} else if (radiobutton_number == 3){
+		mvwaddch(window, 7, 3, '*');
+	}
+
+	return radiobutton_number;
+}
+
+
+
+
+
+/**
+   \brief Show window allowing user to select disc size
+
+   Show user a window allowing him to select one of three predefined values
+   for size of media, or let him enter his own value in. Entered value will be
+   stored in global config variable.
+
+   \return CDW_OK if user pressed ENTER
+   \return CDW_CANCEL if user pressed ESCAPE
+   \return CDW_MEM_ERROR if malloc() failed
+   \return CDW_GEN_ERROR if an error occurred
+   \return CDW_ARG_ERROR if value entered by user is invalid
+*/
+cdw_rv_t cdw_config_ui_media_size_selector(void)
+{
+	const int start_col = 5;
+	/* 5 is reasonable upper limit for length of string
+	   describing size of media; update "no more than 5 digits"
+	   message below on any changes*/
+	const size_t buf_len = 5;
+	/* value displayed in text input area */
+	char *buffer = malloc(buf_len + 1); /* 1 for ending '\0' */
+	if (buffer == NULL) {
+		return CDW_MEM_ERROR;
+	}
+
+	size_t n_lines = 11, n_cols = 60;
+	size_t begin_y = ((size_t) LINES - n_lines) / 2, begin_x = ((size_t) COLS - n_cols) / 2;
+
+	WINDOW *window = newwin((int) n_lines, (int) n_cols, (int) begin_y, (int) begin_x);
+
+	wbkgd(window, COLOR_PAIR(CDW_COLORS_DIALOG));
+	werase(window);
+	keypad(window, TRUE);
+
+	/* 2TRANS: this is title of dialog window allowing user to
+	   select size of volume that will be created */
+	cdw_ncurses_nice_box(window, _("Volume size"),
+			     /* 2TRANS: this is a tooltip at the bottom of size selector
+				window. User can select size pressing corresponding
+				number key. Keep no longer than 45 chars. */
+			     _("Select using number key"));
+
+	/* 2TRANS: this is label in dialog window in which user can select
+	   size of disc currently in drive */
+	mvwprintw(window, 2, 3, "%s", _("Select volume size"));
+	/* 2TRANS: this is radio button label: 650MB CD */
+	mvwprintw(window, 4, start_col, "%s", _("1 - 650 MB (74 min CD)"));
+	/* 2TRANS: this is radio button label: 700MB CD */
+	mvwprintw(window, 5, start_col, "%s", _("2 - 700 MB (80 min CD)"));
+	/* 2TRANS: this is radio button label: DVD */
+	mvwprintw(window, 6, start_col, "%s", _("3 - 4,7 GB (DVD)"));
+	/* 2TRANS: this is radio button label, after this string an input
+	   field is displayed where user can enter value; please don't change
+	   length of this string, pad with spaces if necessary */
+	mvwprintw(window, 7, start_col, "%s", _("4 - "));
+
+	int y, x_4;
+	getyx(window, y, x_4);
+	mvwprintw(window, 7, x_4 + (int) buf_len + 1, "%s",
+		  /* 2TRANS: this is string displayed after custom media size
+		     value, MB means MegaBytes; keep as short as possible */
+		  _("MB"));
+	int x_mb;
+	getyx(window, y, x_mb);
+	WINDOW *subwindow_txt = derwin(window,
+				       3, (int) n_cols - (x_mb + 2),
+				       7, x_mb + 1);
+	/* 2TRANS: this is label next to input field, describing what kind of
+	   user data is acceptable in this field. 'separator' is comma or dot
+	   used in decimal number notation or space used to separate thousands;
+	   you probably want to keep parens */
+	cdw_textarea_print_message(subwindow_txt, _("(value greater than zero, no more than 32767, no separators)"),
+				   CDW_ALIGN_LEFT);
+
+	/* window for small, one-line text input area */
+	/* remember to keep subwindow width no larger than buffer size,
+	   otherwise setting buffer size limit will fail */
+	WINDOW *subwindow_input = derwin(window, 1, (int) buf_len, 7, x_4);
+	wbkgd(subwindow_input, COLOR_PAIR(CDW_COLORS_INPUT));
+	werase(subwindow_input);
+
+	if (global_config.volume_size_custom_value <= 0) {
+		global_config.volume_size_custom_value = 0;
+	} else {
+		if ((floor(log10((double) global_config.volume_size_custom_value)) + 1) > buf_len) {
+			global_config.volume_size_custom_value = 0;
+		}
+	}
+	snprintf(buffer, buf_len + 1, "%ld", global_config.volume_size_custom_value);
+
+	mvwprintw(subwindow_input, 0, 0, buffer);
+
+	long int result = 0; /* stores value corresponding to selection until user hits ENTER */
+	switch (global_config.volume_size_id) {
+		case CDW_CONFIG_VOLUME_SIZE_CD74:
+			move_radio_selection(window, 0);
+			result = cdw_config_volume_size_by_id(CDW_CONFIG_VOLUME_SIZE_CD74);
+			break;
+		case CDW_CONFIG_VOLUME_SIZE_CD80:
+			move_radio_selection(window, 1);
+			result = cdw_config_volume_size_by_id(CDW_CONFIG_VOLUME_SIZE_CD80);
+			break;
+		case CDW_CONFIG_VOLUME_SIZE_DVD_GENERIC:
+			move_radio_selection(window, 2);
+			result = cdw_config_volume_size_by_id(CDW_CONFIG_VOLUME_SIZE_DVD_GENERIC);
+			break;
+		default:
+			move_radio_selection(window, 3);
+			result = global_config.volume_size_custom_value;
+			break;
+	}
+
+	wrefresh(subwindow_input);
+	wmove(window, 9, 29);
+
+	cdw_rv_t crv = CDW_OK;
+	int ch = 0;
+	do {
+		ch = wgetch(window);
+		switch (ch) {
+			case '1':
+				move_radio_selection(window, 0);
+				result = cdw_config_volume_size_by_id(CDW_CONFIG_VOLUME_SIZE_CD74);
+				break;
+			case '2':
+				move_radio_selection(window, 1);
+				result = cdw_config_volume_size_by_id(CDW_CONFIG_VOLUME_SIZE_CD80);
+				break;
+			case '3':
+				move_radio_selection(window, 2);
+				result = cdw_config_volume_size_by_id(CDW_CONFIG_VOLUME_SIZE_DVD_GENERIC);
+				break;
+			case '4':
+				move_radio_selection(window, 3);
+				wrefresh(window);
+				snprintf(buffer, buf_len + 1, "%ld", global_config.volume_size_custom_value);
+				crv = cdw_one_line_form(window, subwindow_input, &buffer,
+							CDW_NCURSES_INPUT_INTEGER, buf_len);
+
+				/* we assign value to current char (ch) to speed up leaving while () */
+				if (crv == CDW_ARG_ERROR) {
+					crv = CDW_ARG_ERROR;
+					ch = CDW_ESCAPE;
+				} else if (crv == CDW_CANCEL) {
+					crv = CDW_CANCEL;
+					ch = CDW_ESCAPE;
+				} else if (crv == CDW_OK) {
+					crv = CDW_OK;
+					ch = CDW_ENTER;
+
+					/* user pressed enter, value is
+					   validated, store entered value */
+					int tmp = atoi(buffer);
+					if (tmp == 0 || tmp > 32767) { /* INT_MIN = 32767 */
+						crv = CDW_ARG_ERROR;
+						ch = CDW_ESCAPE;
+					} else {
+						global_config.volume_size_custom_value = tmp;
+						result = tmp;
+					}
+				} else { /* (crv == CDW_MEM_ERROR || crv == CDW_GEN_ERROR) */
+					crv = CDW_GEN_ERROR;
+					ch = CDW_ESCAPE;
+				}
+				break;
+			default: /* key that does not change selection */
+				break;
+		}
+
+		wrefresh(window);
+	} while ((ch != CDW_ESCAPE) && (ch != CDW_ENTER));
+
+	cdw_config_write_to_file();
+
+	delwin(subwindow_input);
+	subwindow_input = (WINDOW *) NULL;
+	delwin(subwindow_txt);
+	subwindow_txt = (WINDOW *) NULL;
+	delwin(window);
+	window = (WINDOW *) NULL;
+
+	free(buffer);
+	buffer = (char *) NULL;
+
+	if (ch == CDW_ENTER) {
+		global_config.volume_size_value = result;
+	}
+
+	cdw_main_ui_files_info_view_update(false);
+	cdw_main_ui_main_window_wrefresh_part(n_lines, n_cols, begin_y, begin_x);
+
+	if (crv == CDW_GEN_ERROR || crv == CDW_MEM_ERROR) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window,
+				      displayed after media selection window was
+				      closed and it returned an error - media size
+				      is either invalid or was not changed as
+				      desired; no specifics about reason of error
+				      are available */
+				   _("Changing media size failed. Please retry."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	} else if (crv == CDW_ARG_ERROR) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window,
+				      displayed after media selection window was
+				      closed and it returned an error - user entered
+				      incorrect value of value of wrong type
+				      (e.g. with letters */
+				   _("The value you entered is invalid. Please retry."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	}
+
+	return crv;
+}
+
+
+
+
+
+/* *** cdw_task.c *** */
+
+
+/* *** unused code below *** */
+
+
+
+#if 0
+cdw_rv_t cdw_task_select_tool_manually(cdw_task_t *task, cdw_disc_t *disc)
+{
+
+	bool error = false;
+
+	/* manual selection */
+	int selected_dvd_family = cdw_ext_tools_config_get_dvd_family();
+	int selected_cd_family = CDW_TOOL_CDRECORD; /* hardwired until support for xorriso is not added */
+
+	if (task->id == CDW_TASK_MEDIA_INFO) {
+		/* when task == mediainfo, it is safer to assume that all
+		   that is known is simple disc type (CD / DVD) discovered
+		   by libcdio call; if simple type == DVD, we can also
+		   expect that result of cdw_cdio_is_dvd_dl() will be valid */
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+			cdw_vdm ("INFO: task=mediainfo, disc=DVD\n");
+			if (selected_dvd_family == CDW_TOOL_GROWISOFS) {
+				// task->main_tool_id = CDW_TOOL_DVD_RW_MEDIAINFO;
+				task->media_info.tool.id = CDW_TOOL_DVD_RW_MEDIAINFO;
+				task->media_info.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_DVD_RW_MEDIAINFO);
+			} else if (selected_dvd_family == CDW_TOOL_CDRECORD) {
+				task->media_info.tool.id = CDW_TOOL_CDRECORD;
+				task->media_info.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_CDRECORD);
+			} else {
+				cdw_assert (0, "ERROR: incorrect tool family for DVD discs: %d\n",
+					    selected_dvd_family);
+			}
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+			cdw_vdm ("INFO: task=mediainfo, disc=CD\n");
+			task->media_info.tool.id = CDW_TOOL_CDRECORD;
+			task->media_info.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_CDRECORD);
+		} else {
+			cdw_assert (0, "ERROR: called the function with disc simple type different than CD and DVD: %d\n",
+				    disc->simple_type);
+		}
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+			cdw_vdm ("INFO: task=erase, disc=DVD\n");
+			/* prefer dvd+rw-format; reason: cdrecord (until up to
+			   cdrtools-2.01.01 version) implements only erasing
+			   of CD-RW discs and formatting of DVD+RW discs, no
+			   support for DVD-RW */
+			if (selected_dvd_family == CDW_TOOL_GROWISOFS) {
+				task->erase.tool.id = CDW_TOOL_DVD_RW_FORMAT;
+				task->erase.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_DVD_RW_FORMAT);
+			} else if (selected_dvd_family == CDW_TOOL_CDRECORD) {
+				task->erase.tool.id = CDW_TOOL_CDRECORD;
+				task->erase.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_CDRECORD);
+			} else {
+				cdw_assert (0, "ERROR: incorrect tool family for DVD discs: %d\n",
+					    selected_dvd_family);
+			}
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+			cdw_vdm ("INFO: task=mediainfo, disc=CD\n");
+			task->erase.tool.id = CDW_TOOL_CDRECORD;
+			task->erase.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_CDRECORD);
+
+		} else {
+			cdw_assert (0, "ERROR: called the function with disc simple type different than CD and DVD: %d\n",
+				    disc->simple_type);
+		}
+	} else if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+			cdw_vdm ("INFO: task=burn, disc=DVD\n");
+
+			if (task->id == CDW_TASK_BURN_FROM_FILES) {
+				if (selected_dvd_family == CDW_TOOL_GROWISOFS
+				    || selected_dvd_family == CDW_TOOL_CDRECORD) {
+
+					if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)) {
+						task->create_image.tool.id = CDW_TOOL_MKISOFS;
+						task->create_image.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_MKISOFS);
+
+						if (selected_dvd_family == CDW_TOOL_GROWISOFS) {
+							task->burn.tool.id = CDW_TOOL_GROWISOFS;
+							task->burn.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_GROWISOFS);
+						} else {
+							task->burn.tool.id = CDW_TOOL_CDRECORD;
+							task->burn.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_CDRECORD);
+						}
+					} else {
+						error = true;
+					}
+				/* } else if (selected_dvd_family == CDW_TOOL_XORRISO) { */
+				} else {
+					cdw_assert (0, "ERROR: incorrect tool family for DVD discs: %d\n",
+						    selected_dvd_family);
+				}
+			} else { /* burn iso file */
+				if (selected_dvd_family == CDW_TOOL_GROWISOFS) {
+					task->burn.tool.id = CDW_TOOL_GROWISOFS;
+					task->burn.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_GROWISOFS);
+				} else if (selected_dvd_family == CDW_TOOL_CDRECORD) {
+					task->burn.tool.id = CDW_TOOL_CDRECORD;
+					task->burn.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_CDRECORD);
+				/* } else if (selected_dvd_family == CDW_TOOL_XORRISO) { */
+				} else {
+					cdw_assert (0, "ERROR: incorrect tool family for DVD discs: %d\n",
+						    selected_dvd_family);
+				}
+			}
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+			if (task->id == CDW_TASK_BURN_FROM_FILES) {
+				if (selected_cd_family == CDW_TOOL_CDRECORD) {
+					if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)) {
+						task->create_image.tool.id = CDW_TOOL_MKISOFS;
+						task->create_image.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_MKISOFS);
+
+						task->burn.tool.id = CDW_TOOL_CDRECORD;
+						task->burn.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_CDRECORD);
+					} else {
+						error = true;
+					}
+				/* } else if (selected_cd_family == CDW_TOOL_XORRISO) { */
+				} else {
+					cdw_assert (0, "ERROR: incorrect tool family for CD discs: %d\n",
+						    selected_cd_family);
+				}
+			} else { /* burn iso file */
+				if (selected_cd_family == CDW_TOOL_CDRECORD) {
+					task->burn.tool.id = CDW_TOOL_CDRECORD;
+					task->burn.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_CDRECORD);
+				/* } else if (selected_cd_family == CDW_TOOL_XORRISO) { */
+				} else {
+					cdw_assert (0, "ERROR: incorrect tool family for CD discs: %d\n",
+						    selected_cd_family);
+				}
+			}
+		} else {
+			cdw_assert (0, "ERROR: called the function with disc simple type different than CD and DVD: %d\n",
+				    disc->simple_type);
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		cdw_vdm ("INFO: task=create image\n");
+		task->create_image.tool.id = CDW_TOOL_MKISOFS;
+		task->create_image.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_MKISOFS);
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		cdw_vdm ("INFO: task=check md5sum\n");
+		task->verify.tool.id = CDW_TOOL_MD5SUM;
+		task->verify.tool.fullpath = cdw_ext_tools_get_instance_selected_manually(CDW_TOOL_MD5SUM);
+	} else {
+		cdw_assert (0, "ERROR: incorrect task id = %d\n", task->id);
+	}
+
+	if (error) {
+		cdw_vdm ("ERROR: no tool(s) found\n");
+		cdw_task_e((char *) NULL,
+			   /* 2TRANS: this is message in dialog window;
+			      "tools" means "cdrecord", "growisofs" etc.*/
+			   _("There was some problem with selecting a tool for current task. You may need to check your system. Please refer to previous error messages and cdw log file for details."));
+
+		return CDW_GEN_ERROR;
+	} else {
+		return CDW_OK;
+	}
+
+}
+
+
+
+
+
+/* right now this "intelligence" is simply selecting system default
+   instance of a tool */
+cdw_rv_t cdw_task_select_tool_intelligently(cdw_task_t *task, cdw_disc_t *disc)
+{
+	bool error = false;
+	if (task->id == CDW_TASK_MEDIA_INFO) {
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+			cdw_vdm ("INFO: task=mediainfo, disc=DVD\n");
+			if (cdw_ext_tools_is_tool_available(CDW_TOOL_DVD_RW_MEDIAINFO)) {
+				task->media_info.tool.id = CDW_TOOL_DVD_RW_MEDIAINFO;
+				task->media_info.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_DVD_RW_MEDIAINFO);
+			} else if (cdw_ext_tools_is_tool_available(CDW_TOOL_CDRECORD)) {
+				task->media_info.tool.id = CDW_TOOL_CDRECORD;
+				task->media_info.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_CDRECORD);
+			} else {
+				error = true;
+			}
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+			cdw_vdm ("INFO: task=mediainfo, disc=CD\n");
+			if (cdw_ext_tools_is_tool_available(CDW_TOOL_CDRECORD)) {
+				task->media_info.tool.id = CDW_TOOL_CDRECORD;
+				task->media_info.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_CDRECORD);
+			} else {
+				error = true;
+			}
+		} else {
+			cdw_assert (0, "ERROR: called the function with disc simple type different than CD and DVD: %d\n",
+				    disc->simple_type);
+		}
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+			cdw_vdm ("INFO: task=erase, disc=DVD\n");
+			if (cdw_ext_tools_is_tool_available(CDW_TOOL_DVD_RW_FORMAT)) {
+				task->erase.tool.id = CDW_TOOL_DVD_RW_FORMAT;
+				task->erase.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_DVD_RW_FORMAT);
+			} else if (cdw_ext_tools_is_tool_available(CDW_TOOL_CDRECORD)) {
+				task->erase.tool.id = CDW_TOOL_CDRECORD;
+				task->erase.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_CDRECORD);
+			} else {
+				error = true;
+			}
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+			cdw_vdm ("INFO: task=erase, disc=CD\n");
+			if (cdw_ext_tools_is_tool_available(CDW_TOOL_CDRECORD)) {
+				task->erase.tool.id = CDW_TOOL_CDRECORD;
+				task->erase.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_CDRECORD);
+			} else {
+				error = true;
+			}
+		} else {
+			cdw_assert (0, "ERROR: called the function with disc simple type different than CD and DVD: %d\n",
+				    disc->simple_type);
+		}
+
+	} else if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+			cdw_vdm ("INFO: task=burn, disc=DVD\n");
+			if (task->id == CDW_TASK_BURN_FROM_FILES) {
+				if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)) {
+					task->create_image.tool.id = CDW_TOOL_MKISOFS;
+					task->create_image.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_MKISOFS);
+
+					if (cdw_ext_tools_is_tool_available(CDW_TOOL_GROWISOFS)) {
+						task->burn.tool.id = CDW_TOOL_GROWISOFS;
+						task->burn.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_GROWISOFS);
+					} else if (cdw_ext_tools_is_tool_available(CDW_TOOL_CDRECORD)) {
+						task->burn.tool.id = CDW_TOOL_CDRECORD;
+						task->burn.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_CDRECORD);
+					} else {
+						error = true;
+					}
+				/* } else if (cdw_ext_tools_is_tool_available(CDW_TOOL_XORRISO)) { */
+				} else {
+					error = true;
+				}
+			} else { /* task->source == OBJ_ISO_IMAGE */
+				if (cdw_ext_tools_is_tool_available(CDW_TOOL_GROWISOFS)) {
+					task->burn.tool.id = CDW_TOOL_GROWISOFS;
+					task->burn.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_GROWISOFS);
+				} else if (cdw_ext_tools_is_tool_available(CDW_TOOL_CDRECORD)) {
+					task->burn.tool.id = CDW_TOOL_CDRECORD;
+					task->burn.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_CDRECORD);
+				/* } else if (cdw_ext_tools_is_tool_available(CDW_TOOL_XORRISO)) { */
+				} else {
+					error = true;
+				}
+			}
+
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+			cdw_vdm ("INFO: task=burn, disc=CD\n");
+			if (task->id == CDW_TASK_BURN_FROM_FILES) {
+				if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)) {
+					task->create_image.tool.id = CDW_TOOL_MKISOFS;
+					task->create_image.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_MKISOFS);
+
+					if (cdw_ext_tools_is_tool_available(CDW_TOOL_CDRECORD)) {
+						task->burn.tool.id = CDW_TOOL_CDRECORD;
+						task->burn.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_CDRECORD);
+					} else {
+						error = true;
+					}
+				/* } else if (cdw_ext_tools_is_tool_available(CDW_TOOL_XORRISO)) { */
+				} else {
+					error = true;
+				}
+			} else { /* task->source == OBJ_ISO_IMAGE */
+				if (cdw_ext_tools_is_tool_available(CDW_TOOL_CDRECORD)) {
+					task->burn.tool.id = CDW_TOOL_CDRECORD;
+					task->burn.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_CDRECORD);
+				/* } else if (cdw_ext_tools_is_tool_available(CDW_TOOL_XORRISO)) { */
+				} else {
+					error = true;
+				}
+			}
+		} else {
+			cdw_assert (0, "ERROR: called the function with disc simple type different than CD and DVD: %d\n",
+				    disc->simple_type);
+		}
+
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		cdw_vdm ("INFO: task=create image\n");
+		if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)) {
+			task->create_image.tool.id = CDW_TOOL_MKISOFS;
+			task->create_image.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_MKISOFS);
+		} else {
+			error = true;
+		}
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		cdw_vdm ("INFO: task=check md5sum\n");
+		if (cdw_ext_tools_is_tool_available(CDW_TOOL_MD5SUM)) {
+
+			task->verify.tool.id = CDW_TOOL_MD5SUM;
+			task->verify.tool.fullpath = cdw_ext_tools_get_system_default_instance(CDW_TOOL_MD5SUM);
+		} else {
+			error = true;
+		}
+	} else {
+		cdw_assert (0, "ERROR: incorrect task id = %d\n", task->id);
+	}
+
+	if (error) {
+		cdw_vdm ("ERROR: no fullpath found\n");
+		cdw_task_e((char *) NULL,
+			   /* 2TRANS: this is message in dialog window;
+			      "tool" means "cdrecord", "growisofs", etc. */
+			   _("Can't find any tool for current task, please check your configuration and system or use manual selection of tools.\n"));
+
+		return CDW_GEN_ERROR;
+	} else {
+		return CDW_OK;
+	}
+}
+
+
+
+cdw_rv_t cdw_task_select_tool_for_task(cdw_task_t *task, cdw_disc_t *disc)
+{
+	if (task->id == CDW_TASK_ERASE || task->id == TASK_BURN || task->id == TASK_MEDIAINFO) {
+		cdw_assert (disc != (cdw_disc_t *) NULL, "disc cannot be null\n");
+	}
+
+	if (task->id == CDW_TASK_ERASE) {
+		if (disc->disc_type == CDW_CD_RW) {
+			cdw_sdm ("selecting cdrecord for blanking CD-RW\n");
+			task->tool = CDW_TOOL_CDRECORD;
+		} else if (disc->disc_type == CDW_DVD_RWP
+			|| disc->disc_type == CDW_DVD_RW
+			|| disc->disc_type == CDW_DVD_RW_SEQ
+			|| disc->disc_type == CDW_DVD_RW_RES) {
+
+			cdw_sdm ("selecting dvd+rw-format for blanking DVD\n");
+			task->tool.id = CDW_TOOL_DVD_RW_FORMAT;
+		} else {
+			cdw_task_e((char *) NULL,
+				   /* 2TRANS: this is message in dialog window */
+				   _("Disc doesn't seem to be erasable"));
+			task->tool.id = CDW_TOOL_NONE;
+			/* pass to error message */
+		}
+	} else if (task->id == CDW_TASK_BURN) {
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+
+			cdw_sdm ("selecting cdrecord for writing to CD\n");
+			task->tool.id = CDW_TOOL_CDRECORD;
+
+		} else if (disc->disc_type == CDW_DVD_RP_DL
+			   && config.support_dvd_rp_dl) {
+
+			cdw_sdm ("selecting cdrecord for writing to DVD+R DL\n");
+			task->tool.id = CDW_TOOL_CDRECORD;
+
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+
+			cdw_sdm ("selecting growisofs for writing to DVD\n");
+			task->tool.id = CDW_TOOL_GROWISOFS;
+		} else {
+			cdw_task_e((char *) NULL,
+				   /* 2TRANS: this is message in dialog window */
+				   _("Disc doesn't seem to be writable"));
+			task->tool.id = CDW_TOOL_NONE;
+			/* pass to error message */
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		task->tool.id = CDW_TOOL_MKISOFS;
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		task->tool.id = CDW_TOOL_MD5SUM;
+	} else if (task->id == CDW_TASK_MEDIAINFO) {
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+			cdw_vdm ("disc simple type is CD, selecting CDRECORD for mediainfo\n");
+			task->tool.id = CDW_TOOL_CDRECORD;
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+			if (cdw_cdio_is_dvd_dl()) {
+				cdw_vdm ("disc type is DVD DL, selecting CDRECORD for mediainfo\n");
+				task->tool.id = CDW_TOOL_CDRECORD;
+			} else {
+				cdw_vdm ("disc type is DVD SL, selecting DVD_RW_MEDIAINFO for mediainfo\n");
+				task->tool.id = CDW_TOOL_DVD_RW_MEDIAINFO;
+			}
+		} else {
+			cdw_vdm ("ERROR: unknown disc simple type %d\n", disc->simple_type);
+			return CDW_GEN_ERROR;
+		}
+
+	} else if (task->id == CDW_TASK_READ) {
+		cdw_assert (0, "you should not select tool for reading (task->id = TASK_READ)\n");
+	} else if (task->id == CDW_TASK_NONE) {
+		cdw_assert (0, "you should not select tool for task->id = TASK_NONE\n");
+	} else {
+		cdw_assert (0, "unknown value of task->id = %d\n", task->id);
+	}
+
+
+	if (cdw_ext_tools_is_tool_available(task->tool)) {
+		return CDW_OK;
+	} else {
+		cdw_ext_tools_error_dialog(task->tool);
+		cdw_vdm ("ERROR: no tool avaliable for the task\n");
+		return CDW_GEN_ERROR;
+	}
+}
+
+
+
+
+
+void cdw_task_display_current_writing_modes(cdw_task_t *task, int s)
+{
+	if (s == 0) {
+		/* TODO: write "char *cdw_task_session_mode_id_to_string(int id)" function */
+		int i = task->burn.session_mode;
+
+		if (task->burn.session_mode == CDW_SESSION_MODE_START_MULTI) {
+			cdw_vdm ("INFO: session write mode = %d / CDW_WRITE_SESSION_START_MULTI\n", i);
+		} else if (task->burn.session_mode == CDW_SESSION_MODE_CREATE_SINGLE) {
+			cdw_vdm ("INFO: session write mode = %d / CDW_WRITE_SESSION_CREATE_SINGLE\n", i);
+		} else if (task->burn.session_mode == CDW_SESSION_MODE_START_MULTI) {
+			cdw_vdm ("INFO: session write mode = %d / CDW_WRITE_SESSION_START_MULTI\n", i);
+		} else if (task->burn.session_mode == CDW_SESSION_MODE_CONTINUE_MULTI) {
+			cdw_vdm ("INFO: session write mode = %d / CDW_WRITE_SESSION_CONTINUE_MULTI\n", i);
+		} else if (task->burn.session_mode == CDW_SESSION_MODE_WRITE_FINAL) {
+			cdw_vdm ("INFO: session write mode = %d / CDW_WRITE_SESSION_WRITE_FINAL\n", i);
+		} else if (task->burn.session_mode == CDW_SESSION_MODE_INIT) {
+			cdw_vdm ("INFO: session write mode = %d / CDW_WRITE_SESSION_WRITE_INIT\n", i);
+		} else {
+			cdw_vdm ("INFO: session write mode = %d / CDW_WRITE_SESSION_ERROR\n", i);
+		}
+	} else {
+		int i = task->burn.disc_mode;
+
+		if (task->burn.disc_mode == CDW_DISC_MODE_INIT) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_INIT\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_UNSPECIFIED) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_UNSPECIFIED\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_TAO) {
+		        cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_TAO\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_DAO) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_DAO\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_SAO) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_SAO\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_RAW) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_RAW\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_RAW96P) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_RAW96P\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_RAW96R) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_RAW96R\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_ERROR) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_ERROR\n", i);
+		} else if (task->burn.disc_mode == CDW_DISC_MODE_N_MAX) {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_N_MAX\n", i);
+		} else {
+			cdw_vdm ("INFO: disc write mode = %d / CDW_WRITE_DISC_ERROR\n", i);
+		}
+	}
+
+	return;
+}
+
+
+
+
+#endif
+
+
+
+
+/* from cdw_config_ui_internals.c */
+
+
+
+/* ** unused code below *** */
+
+
+#if 0
+
+
+/**
+   \brief Handle keys while page of configuration window is displayed
+
+   Handle keys while a page of configuration window is displayed.
+   Function returns after user has hit F(X) unleast current page is the one
+   that corresponds to F(X) (current page index is X - 1).
+   Function returns F10 or ESCAPE if user pressed F10 or ESCAPE, regardless
+   of current page index.
+
+   You can tell the driver to bring focus to specific field in page by
+   calling the function with index of the field as an argument.
+   Pass -1 if you don't want to swith to any particular field (first field
+   will be selected by default).
+
+   'u' in function name stands for "universal" - function works for any
+   configuration page that has input fields and checkboxes (but not
+   dropdowns).
+
+   \param pi - page index, index of page that receives keys
+   \param initial_fi - initial field index, index of field to which driver should switch at the beginning
+   \param n_fields - number of fields on current page
+
+   \return CDW_ESCAPE - exit configuration window, no changes should be saved,
+   \return KEY_F(10) - exit configuration window, changes should be permanently saved
+   \return KEY_F(X) - change configuration page to page (X - 1)
+*/
+int page_u_driver(cdw_config_t *config, int pi, int initial_fi, int n_fields)
+{
+	int rv = form_driver(forms[pi], REQ_FIRST_FIELD);
+	if (rv != E_OK) {
+		cdw_vdm ("ERROR: form_driver() returns \"%s\"\n", cdw_ncurses_error_string(rv));
+	}
+	cdw_vdm ("INFO: form_driver() returns E_OK\n");
+	if (initial_fi <= 0) {
+		initial_fi = 0;
+	} else if (initial_fi >= n_fields) {
+		initial_fi = 0;
+	} else {
+		;
+	}
+
+	/* initial field may not be first when driver needs to switch
+	   to field in which there is an error */
+	/* TODO: check why using simple for() loop fails: iterating stops
+	   before correct field */
+	FIELD *cf = current_field(forms[pi]);
+	int ci = field_index(cf);
+	while (ci < initial_fi) {
+		form_driver(forms[pi], REQ_NEXT_FIELD);
+		cf = current_field(forms[pi]);
+		ci = field_index(cf);
+	}
+
+	form_driver(forms[pi], REQ_END_LINE);
+	wrefresh(subwindows[pi]);
+
+	int ch = KEY_END; /* safe init value */
+	curs_set(1);
+	do {
+		wrefresh(subwindows[pi]);
+		ch = wgetch(subwindows[pi]);
+
+		if (cdw_ncurses_is_form_movement_key(ch)) {
+			int fi = field_index(current_field(forms[pi]));
+			cdw_config_ui_driver_focus_off(pi, fi);
+		}
+
+		if (ch == KEY_HOME) {
+			form_driver(forms[pi], REQ_BEG_LINE);
+		} else if (ch == KEY_END) {
+			form_driver(forms[pi], REQ_END_LINE);
+		} else if (ch == KEY_LEFT) {
+			form_driver(forms[pi], REQ_PREV_CHAR);
+		} else if (ch == KEY_RIGHT) {
+			form_driver(forms[pi], REQ_NEXT_CHAR);
+		} else if (ch == KEY_DOWN || ch == CDW_KEY_TAB) {
+			form_driver(forms[pi], REQ_NEXT_FIELD);
+			form_driver(forms[pi], REQ_END_LINE);
+		} else if (ch == KEY_UP || ch == KEY_BTAB) {
+			form_driver(forms[pi], REQ_PREV_FIELD);
+			form_driver(forms[pi], REQ_END_LINE);
+		} else if (ch == KEY_BACKSPACE) {
+			form_driver(forms[pi], REQ_DEL_PREV);
+		} else if (ch == KEY_DC) {
+			form_driver(forms[pi], REQ_DEL_CHAR);
+
+			/* if pressed key is F key and the F key is for
+			   page different tham current... */
+		} else if ( ((ch == KEY_F(PAGE_A_INDEX + CDW_CONFIG_FX_START_KEY)) && (pi != PAGE_A_INDEX))
+			    || ((ch == KEY_F(PAGE_B_INDEX + CDW_CONFIG_FX_START_KEY)) && (pi != PAGE_B_INDEX))
+			    || ((ch == KEY_F(PAGE_C_INDEX + CDW_CONFIG_FX_START_KEY)) && (pi != PAGE_C_INDEX))
+			    || ((ch == KEY_F(PAGE_D_INDEX + CDW_CONFIG_FX_START_KEY)) && (pi != PAGE_D_INDEX))
+			    || ((ch == KEY_F(PAGE_E_INDEX + CDW_CONFIG_FX_START_KEY)) && (pi != PAGE_E_INDEX))
+			    || ((ch == KEY_F(PAGE_F_INDEX + CDW_CONFIG_FX_START_KEY)) && (pi != PAGE_F_INDEX))
+			    /* ... or if we want to exit... */
+			    || (ch == KEY_F(CDW_CONFIG_SnC_KEY)) ) {
+				form_driver(forms[pi], REQ_VALIDATION); /* we DO check return value :) */
+				curs_set(0); /* turn cursor off */
+				return ch;
+		} else if (ch == CDW_KEY_ENTER) {
+			int fi = field_index(current_field(forms[pi]));
+			cdw_config_ui_page_u_driver_handle_enter(config, pi, fi);
+		} else { /* other keys */
+			int fi = field_index(current_field(forms[pi]));
+			if (is_checkbox_field_index(pi, fi)) {
+				if (ch == ' ' || ch == 'x' || ch == 'X') {
+					cdw_config_ui_page_u_driver_handle_toggle(&(c_pages[pi].cdw_form), fi);
+				}
+			} else {
+				/* normal text/input field, pass char from keyboard to field */
+				form_driver(forms[pi], ch);
+			}
+		}
+		if (cdw_ncurses_is_form_movement_key(ch)) {
+			int fi = field_index(current_field(forms[pi]));
+			cdw_config_ui_driver_focus_on(pi, fi);
+		}
+	} while ( ch != CDW_ESCAPE );
+
+	curs_set(0);
+
+	/* we get here only when user pressed ESCAPE;
+	   F2, F3 and F10 keys are handled above, their handling is
+	   simply returning */
+	return CDW_ESCAPE;
+}
+
+
+
+
+
+#if 0
+
+CDW_DROPDOWN *cdw_config_ui_get_dropdown_from_form(int pi, int fi)
+{
+	CDW_DROPDOWN *dropdown = (CDW_DROPDOWN *) NULL;
+	FIELD *field = c_pages[pi].cdw_form.fields[fi];
+	cdw_assert (field != (FIELD *) NULL, "ERROR field %d in page %d is NULL\n", fi, pi);
+	FIELDTYPE *ft = field_type(field);
+	/* note: some fields may have ft == NULL */
+	// cdw_assert (ft != (FIELDTYPE *) NULL, "ERROR: field type of field %d in page %d is NULL\n", fi, pi);
+	if (ft == CDW_FIELD_TYPE_DROPDOWN) {
+		dropdown = (CDW_DROPDOWN *) field_userptr(field);
+		cdw_assert (dropdown != (CDW_DROPDOWN *) NULL, "ERROR: field user pointer is NULL dropdown (pi = %d, fi = %d)\n", pi, fi);
+	}
+
+	return dropdown;
+}
+
+
+
+CDW_BUTTON *cdw_config_ui_get_button_from_form(int pi, int fi)
+{
+	CDW_BUTTON *button = (CDW_BUTTON *) NULL;
+	if (pi == PAGE_D_INDEX) {
+		if (fi == f_tempdir_b) {
+			button = iso_image_path_button;
+		}
+	} else if (pi == PAGE_C_INDEX) {
+		if (fi == f_audiodir_b) {
+			button = audio_dir_button;
+		}
+	} else if (pi == PAGE_F_INDEX) {
+		if (fi == f_log_fp_b) {
+			button = log_path_button;
+		}
+	} else {
+		;
+	}
+
+	return button;
+}
+
+#endif
+
+
+
+
+
+/**
+   \brief Check if given form field is a checkbox
+
+   Function checks if given field \p fi on given page \p pi
+   corresponds to a checkbox.
+
+   \param pi - page index, index of page on which given field is displayed
+   \param fi - field index
+
+   \return true if given field is used as a checkbox
+   \return false if given field is not used as a checkbox
+*/
+bool is_checkbox_field_index(int pi, int fi)
+{
+	if (pi == PAGE_A_INDEX) {
+		if (fi == f_eject_i
+			|| fi == f_burnproof_i || fi == f_pad_i
+			|| fi == f_dummy_i || fi == f_blank_i) {
+
+			return true;
+		} else {
+			return false;
+		}
+
+	} else if (pi == PAGE_D_INDEX) {
+		if (fi == f_showvol_cb
+			|| fi == f_rockridge_cb
+			|| fi == f_joliet_cb
+			|| fi == f_useful_rr_cb
+			|| fi == f_follow_symlinks_cb) {
+
+			return true;
+		} else {
+			return false;
+		}
+	} else if (pi == PAGE_E_INDEX) {
+		if (fi == f_manual_selection_cb) {
+			return true;
+		} else {
+			return false;
+		}
+	} else if (pi == PAGE_F_INDEX) {
+		if (fi == f_showlog_cb) {
+
+			return true;
+		} else {
+			return false;
+		}
+	} else {
+		return false;
+	}
+}
+
+
+
+
+
+/**
+   \brief Check if given form field is a dropdown
+
+   Function checks if given field \p fi on given page \p pi
+   corresponds to a dropdown.
+
+   \param pi - page index, index of page on which given field is displayed
+   \param fi - field index
+
+   \return true if given field is used as a dropdown
+   \return false if given field is not used as a dropdown
+*/
+bool is_dropdown_field_index(int pi, int fi)
+{
+	FIELDTYPE *ft = field_type(c_pages[pi].cdw_form.fields[fi]);
+	/* note: some fields may have ft == NULL */
+	//cdw_assert (ft != (FIELDTYPE *) NULL, "ERROR: field type of field %d in page %d is NULL\n", fi, pi);
+	if (ft == CDW_FIELD_TYPE_DROPDOWN) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+
+
+
+/**
+   \brief Check if given form field is a button
+
+   Function checks if given field \p fi on given page \p pi
+   corresponds to a button.
+
+   \param pi - page index, index of page on which given field is displayed
+   \param fi - field index
+
+   \return true if given field is used as a button
+   \return false if given field is not used as a button
+*/
+bool is_button_field_index(int pi, int fi)
+{
+	if (pi == PAGE_D_INDEX) {
+		if (fi == f_tempdir_b) {
+			return true;
+		} else {
+			return false;
+		}
+	} else if (pi == PAGE_C_INDEX) {
+		if (fi == f_audiodir_b) {
+			return true;
+		} else {
+			return false;
+		}
+	} else if (pi == PAGE_F_INDEX) {
+		if (fi == f_log_fp_b) {
+			return true;
+		} else {
+			return false;
+		}
+	} else {
+		return false;
+	}
+}
+
+
+
+#if 0
+
+/**
+   \brief Draw widgets on specified page
+
+   Function draws any dropdowns or additional (text) subwindows that should
+   be visible on page specified by \p pi index. Accepted values of \p pi are
+   those defined in cdw_confg_ui.h (page_X_index).
+
+   Function uses values from \p config if needed.
+
+   \param config - config variable with current configuration
+   \param pi - page index, index of page, for which to draw widgets
+
+   \return CDW_OK if there were no problems
+   \return CDW_GEN_ERROR if there was a problem when creating some widget
+*/
+cdw_rv_t cdw_config_ui_draw_widgets(cdw_config_t *config, int pi)
+{
+	if (pi == PAGE_A_INDEX) {
+		cdw_dropdown_display_current_item(speed_range_dropdown);
+
+	} else if (pi == PAGE_B_INDEX) {
+		/* first -2 is because subwindow sizes are (CONF_* - 2);
+		   rest of values are choosen so that this subwindow 'looks good' */
+		page_B_txt_subwin = derwin(c_pages[PAGE_B_INDEX].cdw_form->subwindow, CONF_HEIGHT - 2 - 7, WIDE_FIELD_WIDTH, 6, 1);
+		if (page_B_txt_subwin == (WINDOW *) NULL) {
+			cdw_vdm ("ERROR: failed to create txt subwindow in page B\n");
+			return CDW_GEN_ERROR;
+		}
+
+		/* 2TRANS: this is message displayed as a small help in configuration
+		   window. Please keep line breaks, they are used for making message
+		   layout more readable, not to preserve certain lengths of lines.
+		   Please keep "/dev/xxx" unchanged. Remember to escape quotes. */
+		cdw_textarea_print_message(page_B_txt_subwin, _("INFO:\n\n\"CD Reader/Writer device\" entry should have form \'/dev/xxx\' and is obligatory - it cannot be left empty. Don't put ending slash in the path.\n\n\"SCSI device\" entry should have \'X,Y,Z\' or \'ATAPI:X,Y,Z\' form and is optional. It should be set and used only if cdrecord has troubles using \'/dev/xxx\' device - otherwise leave empty. Consult cdrecord manual and/or output of 'cdrecord dev=help' command for details of \"SCSI device\" entry."),
+					   CDW_ALIGN_LEFT);
+
+		wrefresh(page_B_txt_subwin);
+		form_driver(c_pages[PAGE_B_INDEX].cdw_form->form, REQ_END_LINE);
+
+	} else if (pi == PAGE_C_INDEX) {
+		cdw_button_unfocus(audio_dir_button);
+
+	} else if (pi == PAGE_D_INDEX) {
+		cdw_assert (config->iso_level > 0 && config->iso_level < 5,
+			    "ERROR: invalid value of iso level: %d\n", config->iso_level);
+		cdw_dropdown_set_current_item_by_id(iso_level_dropdown, (size_t) config->iso_level);
+		cdw_dropdown_display_current_item(iso_level_dropdown);
+		cdw_button_unfocus(iso_image_path_button);
+
+	} else if (pi == PAGE_E_INDEX) {
+		page_E_txt_subwin = derwin(c_pages[PAGE_E_INDEX].cdw_form->subwindow,
+					   4, WIDE_FIELD_WIDTH, 0, 1);
+		if (page_E_txt_subwin == (WINDOW *) NULL) {
+			cdw_vdm ("ERROR: failed to create txt subwindow in page E\n");
+			return CDW_GEN_ERROR;
+		}
+
+		cdw_textarea_print_message(page_E_txt_subwin,
+					   /* 2TRANS: this is a description in one of
+					      configuration window panels; a series of
+					      dropdown widgets is displayed below the label */
+					   _("Changes made here won't be saved after closing cdw."),
+					   CDW_ALIGN_LEFT);
+		wrefresh(page_E_txt_subwin);
+
+		cdw_dropdown_display_current_item(ext_tools_dropdowns.mkisofs);
+		cdw_dropdown_display_current_item(ext_tools_dropdowns.cdrecord);
+		cdw_dropdown_display_current_item(ext_tools_dropdowns.growisofs);
+		cdw_dropdown_display_current_item(ext_tools_dropdowns.dvd_rw_mediainfo);
+		cdw_dropdown_display_current_item(ext_tools_dropdowns.dvd_rw_format);
+		cdw_dropdown_display_current_item(ext_tools_dropdowns.dvd_family);
+
+		cdw_config_ui_page_e_driver_toggle_manual_selection();
+
+	} else if (pi == PAGE_F_INDEX) {
+		cdw_button_unfocus(log_path_button);
+		cdw_dropdown_display_current_item(volume_size_dropdown);
+	} else {
+		cdw_assert (0, "incorrect page index: %d\n", pi);
+	}
+
+	return CDW_OK;
+
+}
+#endif
+
+
+
+
+
+#endif
+
+
+
+
+/* from cdw_cdio.c */
+/**
+   \brief Read meta information from optical disc
+
+   Read following information from disc:
+    - disc mode (of type discmode_t, as defined in cdio/disc.h)
+    - simple disc type (CD, DVD, NONE, UNKNOWN)
+    - information if disc is blank
+    - if disc is not blank: information about tracks number, sizes and types, and about sector sizes
+
+   Read this information using libcdio calls only.
+
+   \return CDW_OK if disc meta information was read without problems and disc is not blank
+   \return CDW_NO if disc meta information was read without problems but disc is blank
+   \return CDW_CANCEL if disc meta information was read only partially (perhaps unknown / unsupported disc type?)
+   \return CDW_GEN_ERROR if function can't get any meta information
+*/
+cdw_rv_t cdw_cdio_get_disc_meta_info_old(void)
+{
+	cdw_assert (g_disc.open, "trying to get meta info from closed disc\n");
+
+	g_disc.mode = cdio_get_discmode(g_disc.p_cdio);
+	if (g_disc.mode == CDIO_DISC_MODE_CD_DATA) {
+		/* libcdio 0.78 calls mmc command to get disc type, but the
+		   call returns CD_DATA for mixed mode CD; let's do
+		   some additional checks */
+		cdw_rv_t crv = get_cds_mixed_with_ioctl();
+		if (crv == CDW_OK) {
+			/* linux ioctl() says that this is MIXED mode cd,
+			   so let's stick with what ioctl() says */
+			g_disc.mode = CDIO_DISC_MODE_CD_MIXED;
+		}
+	}
+
+	/* debug code */
+	if (g_disc.mode == CDIO_DISC_MODE_CD_DATA) {
+		cdw_vdm ("disc->mode == CDIO_DISC_MODE_CD_DATA\n");
+	} else if (g_disc.mode == CDIO_DISC_MODE_CD_XA) {
+		cdw_vdm ("disc->mode == CDIO_DISC_MODE_CD_XA\n");
+	} else if (g_disc.mode == CDIO_DISC_MODE_CD_DA) {
+		cdw_vdm ("disc->mode == CDIO_DISC_MODE_CD_DA\n");
+	} else {
+		cdw_vdm ("disc->mode == UNKNOWN\n");
+	}
+
+	if (cdio_is_discmode_cdrom(g_disc.mode)) {
+		g_disc.simple_type = CDW_DISC_SIMPLE_TYPE_CD;
+		cdw_vdm ("cdio simple type = CD\n");
+
+	} else if (cdio_is_discmode_dvd(g_disc.mode)
+		/* somehow cdio does not classify CDIO_DISC_MODE_DVD_OTHER as dvd */
+		|| (g_disc.mode == CDIO_DISC_MODE_DVD_OTHER)) {
+
+		g_disc.simple_type = CDW_DISC_SIMPLE_TYPE_DVD;
+		cdw_vdm ("cdio simple type = DVD\n");
+		/* cdio calls can't get anything more from DVD */
+		g_disc.set = true;
+		return CDW_OK;
+
+	} else {
+		g_disc.simple_type = CDW_DISC_SIMPLE_TYPE_UNKNOWN;
+		cdw_vdm ("cdio simple type = UNKNOWN\n");
+		/* we won't work with unknown disc types at all */
+		cdw_vdm ("ERROR: failed to get disc simple type\n");
+		return CDW_GEN_ERROR;
+	}
+
+	cdio_log_level_t cdio_loglevel_tmp = cdio_loglevel_default;
+	/* turn off libcdio warnings in case of reading blank cd -
+	   libcdio would print warning to stdout */
+	cdio_loglevel_default = CDIO_LOG_ERROR;
+
+	/* get more information about current disc */
+	g_disc.first_track = cdio_get_first_track_num(g_disc.p_cdio);
+	g_disc.last_track = cdio_get_last_track_num(g_disc.p_cdio);
+	g_disc.n_tracks = (track_t) (g_disc.last_track - g_disc.first_track + 1);
+
+	cdio_loglevel_default = cdio_loglevel_tmp;
+
+	/* debug messages */
+	cdw_vdm ("disc first track = %d\n", g_disc.first_track);
+	cdw_vdm ("disc last track = %d\n", g_disc.last_track);
+	cdw_vdm ("disc n tracks = %d\n", g_disc.n_tracks);
+	cdw_vdm ("CDIO_CDROM_LEADOUT_TRACK = %d\n", CDIO_CDROM_LEADOUT_TRACK);
+
+	if (g_disc.first_track == CDIO_INVALID_TRACK) {
+		/* this is empirical result: disc is blank, don't try to
+		   recognize tracks, because this will cause ioctl() errors; */
+		g_disc.blank = true;
+
+		g_disc.first_track = CDIO_INVALID_TRACK;
+		g_disc.last_track = CDIO_INVALID_TRACK;
+		g_disc.n_tracks = 0;
+
+		/* disc is blank, but major variables now have correct values */
+		g_disc.set = true;
+
+		return CDW_NO;
+	} else {
+		g_disc.blank = false;
+		g_disc.unknown_tracks = 0;
+
+		/* inspect every track on disc */
+		track_t t = 0;
+		for (t = g_disc.first_track; t <= g_disc.last_track; t++) {
+
+			cdw_rv_t crv = cdw_cdio_recognize_track(&g_disc, t);
+			if (crv == CDW_GEN_ERROR) {
+				g_disc.unknown_tracks++;
+			}
+		}
+		cdw_vdm ("disc->unknown_tracks = %d, disc->n_tracks = %d\n",
+			 g_disc.unknown_tracks,
+			 g_disc.n_tracks);
+
+		/* some tracks may be unknow, but all data fields have
+		   values that correspond to disc in drive */
+		g_disc.set = true;
+
+		if (g_disc.unknown_tracks == g_disc.n_tracks) {
+			cdw_vdm ("ERROR: all %d tracks on disc are of unknown type\n", g_disc.unknown_tracks);
+			return CDW_GEN_ERROR;
+		} else if (g_disc.unknown_tracks > 0
+			   && g_disc.unknown_tracks < g_disc.n_tracks) {
+
+			return CDW_CANCEL;
+		} else {
+			return CDW_OK;
+		}
+	}
+}
+
+
+bool cdw_cdio_is_dvd_dl(void)
+{
+	if (g_disc.dvd_layers == 2) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+
+
+
+/* *** cdrecord_interface.c *** */
+
+
+
+
+/**
+   \brief Get basic info about multisessions on disc currently in drive
+
+   Run cdrecord with -msinfo argument to obtain some information about
+   sessions on disc that is currently in drive. The information is written
+   to log file and can be processed with regexp code.
+
+   The function detects when cdrecord cannot open device and displays
+   error message.
+
+   \param task - variable describing current task
+
+   \return CDW_MEM_ERROR on malloc() errors
+   \return CDW_GEN_ERROR when cdrecord failed for some reason
+   \return CDW_OK on success
+ */
+cdw_rv_t cdw_cdrecord_msinfo(cdw_task_t *task)
+{
+	cdw_assert (task->id == TASK_MSINFO, "incorrect task id\n");
+	cdw_assert (task->tool_id == CDW_TOOL_CDRECORD, "incorrect tool\n");
+	bool use_scsi;
+	/* using config.scsi (X:Y:Z) is optional and advised only if
+	   config.cdrw_device (/dev/xxx) does not work; if /dev/xxx works fine,
+	   then config.scsi should be left empty */
+	if (!strlen(config.scsi)) {
+		use_scsi = false;
+	} else {
+		use_scsi = true;
+	}
+
+	/* don't use 'more verbosity' option, ideally
+	   run_command_cdrecord_msinfo() should be used to get only multisession
+	   info. Rest of CD metainformation should be gathered by other means. */
+	const char *ext_tool_fullpath = cdw_ext_tools_get_tool_fullpath(TOOL_CDRECORD);
+	char *command = cdw_string_concat(ext_tool_fullpath,
+					  " -msinfo ",
+					  " dev=", use_scsi ? config.scsi : config.cdrw_device,
+					  (char *) NULL);
+
+	if (command == (char *) NULL) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("An error occurred when attempting to read multisession info from CD."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return CDW_MEM_ERROR;
+	}
+
+	/* 2TRANS: this is message in dialog window, displayed when
+	   program reads some meta-data from cd */
+	cdw_processwin_create(_("Load CD session info..."), (char *) NULL, false);
+
+	cdw_vdm ("command = \"%s\"\n", command);
+	run_command(command, task);
+
+	cdw_processwin_destroy((char *) NULL, false);
+
+	free(command);
+	command = (char *) NULL;
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+   \brief Call "cdrecord -prcap" to get drive capabilities
+
+   Run cdrecord with -prcap argument to obtain some information about
+   drive. Currently only CD writing speeds table is parsed by regexp
+   functions.
+
+   The function detects when cdrecord cannot open device and displays
+   error message.
+
+   \param task - variable describing current task
+
+   \return CDW_MEM_ERROR on malloc() errors
+   \return CDW_GEN_ERROR when cdrecord failed for some reason
+   \return CDW_OK on success
+ */
+cdw_rv_t cdw_cdrecord_prcap(cdw_task_t *task)
+{
+	bool use_scsi;
+	/* using config.scsi (X:Y:Z) is optional and advised only if
+	   config.cdrw_device (/dev/xxx) does not work; if /dev/xxx works fine,
+	   then config.scsi should be left empty */
+	if (!strlen(config.scsi)) {
+		use_scsi = false;
+	} else {
+		use_scsi = true;
+	}
+
+	const char *ext_tool_fullpath = cdw_ext_tools_get_tool_fullpath(TOOL_CDRECORD);
+	char *command = cdw_string_concat(ext_tool_fullpath,
+					  " -prcap ",
+					  " dev=", use_scsi ? config.scsi : config.cdrw_device,
+					  (char *) NULL);
+
+	if (command == (char *) NULL) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("An error occurred when attempting to read CAP info from CD."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return CDW_MEM_ERROR;
+	}
+
+	/* 2TRANS: this is message in dialog window, displayed when
+	   program reads some meta-data from cd */
+	cdw_processwin_create(_("Load CD info..."), (char *) NULL, false);
+
+	cdw_vdm ("command = \"%s\"\n", command);
+
+	run_command(command, task);
+
+	cdw_processwin_destroy((char *) NULL, false);
+
+	free(command);
+	command = (char *) NULL;
+	return CDW_OK;
+}
+
+
+
+
+/**
+   \brief Get basic info about disc currently in drive using 'cdrecord -atip' command
+
+   Run cdrecord with -atip argument to obtain some information about disc
+   that is currently in drive. The information is written to log file and can
+   be processed with regexp code.
+
+   The function detects when cdrecord cannot open device and displays
+   error message.
+
+   \param task - variable describing current task
+
+   \return CDW_MEM_ERROR on malloc() errors
+   \return CDW_GEN_ERROR when cdrecord failed for some reason
+   \return CDW_OK on success
+ */
+cdw_rv_t cdw_cdrecord_atip(cdw_task_t *task)
+{
+	bool use_scsi;
+	/* using config.scsi (X:Y:Z) is optional and advised only if
+	   config.cdrw_device (/dev/xxx) does not work; if /dev/xxx works fine,
+	   then config.scsi should be left empty */
+	if (!strlen(config.scsi)) {
+		use_scsi = false;
+	} else {
+		use_scsi = true;
+	}
+
+	const char *ext_tool_fullpath = cdw_ext_tools_get_tool_fullpath(TOOL_CDRECORD);
+	char *command = cdw_string_concat(ext_tool_fullpath,
+					  " -vvvv -atip ",
+					  " dev=", use_scsi ? config.scsi : config.cdrw_device,
+					  (char *) NULL);
+
+	if (command == (char *) NULL) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("An error occurred when attempting to read ATIP info from CD."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return CDW_MEM_ERROR;
+	}
+
+	/* 2TRANS: this is message in dialog window, displayed when
+	   program reads some meta-data from cd */
+	cdw_processwin_create(_("Load CD info..."), (char *) NULL, false);
+
+	cdw_vdm ("command = \"%s\"\n", command);
+
+	run_command(command, task);
+
+	cdw_processwin_destroy((char *) NULL, false);
+
+	free(command);
+	command = (char *) NULL;
+	return CDW_OK;
+}
+
+
+
+
+
+/* *** cdw_fs.c *** */
+/* *** unused code below *** */
+
+#if 0
+
+
+/**
+   \brief Check if device of given path is mounted in file system
+
+   Use GNU libc interface to /etc/mtab file to determine if given device
+   is mounted. Officially you have to pass to a function a string with path
+   to device file (like '/dev/xxx') which has to be checked, but
+   mount point is also (implicitly) accepted.
+
+   Function should work even if given \p device_fullpath is a symbolic
+   link to real device.
+
+   You most probably want to use this function to check if cdrom
+   drive is mounted.
+
+   \param device_fullpath - path to device file which has to be checked. No trailing slashes are accepted.
+
+   \return CDW_OK if device is mounted
+   \return CDW_NO if device is not mounted
+   \return CDW_SYS_ERROR if /etc/mtab API function call fails
+*/
+cdw_rv_t cdw_fs_check_device_mounted(const char *device_fullpath)
+{
+	cdw_assert (device_fullpath != (char *) NULL, "device fullpath is null\n");
+	struct mntent *mnt;
+
+	FILE *mtab_file = setmntent(_PATH_MOUNTED, "r");
+	if (mtab_file == NULL) {
+		return CDW_SYS_ERROR;
+	}
+
+	bool success = false;
+
+	while ( (mnt = getmntent(mtab_file)) != (struct mntent *) NULL ) {
+		cdw_sdm ("mnt_fsname: %s, ", mnt->mnt_fsname);
+		cdw_sdm ("mnt_dir: %s, ", mnt->mnt_dir);
+		cdw_sdm ("mnt_type: %s, ", mnt->mnt_type);
+		cdw_sdm ("mnt_opts: %s, ", mnt->mnt_opts);
+		cdw_sdm ("mnt_freq: %d\n", mnt->mnt_freq);
+
+		int a = strcmp(device_fullpath, mnt->mnt_fsname);
+		int b = strcmp(device_fullpath, mnt->mnt_dir);
+
+		if (a == 0 || b == 0) {
+			cdw_vdm ("device %s is not a symlink and is mounted\n", device_fullpath);
+			success = true;
+			break;
+		}
+
+		/* path to a device specified by user in configuration may
+		   be a symbolic link (although user may not know it);
+		   check device fullpath and examine link, if there is one */
+
+		struct stat finfo;
+		int z = lstat(device_fullpath, &finfo);
+		if (z == -1) {
+			cdw_vdm ("ERROR: stat() returns !0 (%d) for device_fullpath %s\n", z, device_fullpath);
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window */
+					   _("Path to burner specified in configuration is incorrect. Please check your configuration."),
+					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		} else {
+			if (!S_ISLNK(finfo.st_mode)) {
+				/* device_fullpath is not a link */
+				cdw_vdm ("device %s is not a symlink and is not mounted\n", device_fullpath);
+
+			} else { /* S_ISLNK(finfo.st_mode) */
+				/* second argument == NULL is standardized in POSIX.1-2008 */
+				char *newpath = realpath(device_fullpath, (char *) NULL);
+				if (newpath == (char *) NULL) {
+					cdw_vdm ("ERROR: realpath() can't resolve real path for device_fullpath link %s\n", device_fullpath);
+				} else {
+					int c = strcmp(newpath, mnt->mnt_fsname);
+					int d = strcmp(newpath, mnt->mnt_dir);
+
+					if (c == 0 || d == 0) {
+						cdw_vdm ("device %s is a symlink to %s, which is mounted\n", device_fullpath, newpath);
+						success = true;
+					} else {
+						cdw_vdm ("device %s is a symlink to %s, which is not mounted\n", device_fullpath, newpath);
+					}
+					free(newpath);
+					newpath = (char *) NULL;
+
+					if (success) {
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	/* endmntent() frees all resources - does it mean that we don't
+	   have to free() mnt? */
+	endmntent(mtab_file);
+
+	if (success) {
+		return CDW_OK;
+	} else {
+		return CDW_NO; /* device is not mounted */
+	}
+}
+
+
+
+
+
+/**
+   \brief Get size of all files and dirs that are in table with paths
+
+   Get size of all files and dirs (recursively) that are in pathtable - data
+   structure (a table) holding all paths.
+
+   If \p follow_symlinks is true, function will include size of targets
+   of all symlinks met (directly or indirectly) on the list. If
+   \p follow_symlinks is false, size of targets of symlinks won't be added,
+   size of symlinks themsevles will be added.
+
+   \param pathtable - pointer to table of *char strings with full (non-relative) paths
+   \param n_paths - size of table (number of paths)
+
+   \return size of all dirs/files from table on success
+   \return -1 if failure
+*/
+cdw_rv_t cdw_fs_traverse_paths(char **pathtable, int n_paths, cdw_fs_visitor_t visitor, cdw_fs_visitor_data_t *visitor_data)
+{
+	for (int i = 0; i < n_paths; i++) {
+		cdw_rv_t crv = cdw_fs_traverse_path(*(pathtable + i), visitor, visitor_data);
+		if (crv != CDW_OK) {
+			return CDW_GEN_ERROR;
+		}
+	}
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+   \brief Get size of given dir (recursively) or file
+
+   Get size of given dir (recursively) or file.
+
+   If \p follow_symlinks is true, function will include size of targets
+   of all symlinks met (directly or indirectly) on the list. If
+   \p follow_symlinks is false, size of targets of symlinks won't be added,
+   size of symlinks themsevles will be added.
+
+   \param fullpath - non-relative path to dir or file
+   \param follow_symlinks - describes policy for symlinks
+
+   \return value >=0 on success
+   \return -1 on failure
+*/
+long long int cdw_fs_dirsize_path(char *fullpath, bool follow_symlinks)
+{
+	struct stat finfo;
+	/* WARNING: don't use stat() - it yelds bad results for symlinks;
+	   at this point we don't want to follow symbolic links, we only
+	   need to know if file pointed by path is a symlink or not;
+	   we will examine symlinks more closely below */
+	int ok = lstat(fullpath, &finfo);
+	if (ok != 0) {
+		/* TODO: that is weird, but lstat() fails on broken links;
+		   this is not a bad thing in this context that we return
+		   here, but I thought that lstat won't fail on broken links */
+		/* TODO: perhaps we could write skipped paths to log file? */
+		cdw_vdm ("ERROR: lstat fails for \"%s\", err = \"%s\"\n", fullpath, strerror(errno));
+		// assert (0);
+		return -1;
+	}
+
+	long long int retval = 0;
+
+	if ( S_ISREG(finfo.st_mode) ) { /* regular file */
+		/* st_size is file size, in bytes */
+		retval += finfo.st_size;
+	} else if ( S_ISLNK(finfo.st_mode) ) { /* symbolic link */
+		if (follow_symlinks) {
+			/* path pointed to by link can be resolved using two
+			   methods: using realpath() or using readlink();
+			   each method needs different buffer */
+			char *realpath_fullpath = (char *) NULL;
+			char readlink_fullpath[PATH_MAX];
+
+			/* generic pointer set to point to one of the buffers above */
+			char *resolved_fullpath = (char *) NULL;
+			int e = 0;
+
+#if 0
+			/* implementation using realpath(), which is
+			   susceptible to circular directory loop */
+			realpath_fullpath = realpath(fullpath, (char *) NULL);
+			e = errno;
+			resolved_fullpath = realpath_fullpath;
+#else
+			/* implementation using readlink(), which avoids
+			   circular directory loop because it may be buggy
+			   (can't handle relative links), but it is not quite
+			   definitively true */
+			ssize_t len = readlink(fullpath, readlink_fullpath, PATH_MAX);
+			e = errno;
+			if (len == -1) {
+				resolved_fullpath = (char *) NULL;
+			} else {
+				resolved_fullpath = readlink_fullpath;
+				resolved_fullpath[len] = '\0';
+			}
+#endif
+
+			if (resolved_fullpath == (char *) NULL) {
+				cdw_vdm ("ERROR: failed to fetch target for link \"%s\"\n", fullpath);
+				cdw_vdm ("ERROR: errno %d%s (\"%s\")\n",
+					 e, e == ENOENT ? "/ENOENT" : "", strerror(e));
+
+#if 0 /* enable after checking behavior of stat() and lstat() on broken links */
+				if (errno == ENOENT) {
+
+					struct stat link_info;
+					int sym1 = lstat(new_fullpath, &link_info);
+					int sym2 = stat(new_fullpath, &link_info);
+					if (sym1 == 0 && sym2 != 0) {
+						cdw_vdm ("  errno == ENOENT && the link is broken\n");
+						/* we can broken link and happily scan dir further */
+					} else {
+						cdw_vdm ("  errno == ENOENT, but reason is other than broken link\n");
+						/* TODO: some more information for user pls */
+						return -1;
+					}
+				}
+#endif
+
+				retval = -1;
+			} else { /* resolved_fullpath != NULL */
+				if (!strcmp(resolved_fullpath, ".")) {
+					cdw_vdm ("INFO: link \"%s\" resolved as \".\", skipping\n", fullpath);
+				} else {
+					cdw_vdm ("INFO: link \"%s\" resolved as new fullpath = \"%s\", checking it...\n",
+						 fullpath, resolved_fullpath);
+
+					long long int dd = cdw_fs_dirsize_path(resolved_fullpath, follow_symlinks);
+					if (dd > 0) {
+						cdw_vdm ("INFO: following link %s, adding size %lld\n", resolved_fullpath, dd);
+						retval += dd;
+					} else {
+						retval = -1;
+					}
+
+					if (realpath_fullpath == (char *) NULL) {
+						free(realpath_fullpath);
+						realpath_fullpath = (char *) NULL;
+					}
+				}
+			}
+		} else {
+			cdw_vdm ("INFO: NOT following link, adding size %d\n", (int) finfo.st_size);
+			/* st_size is length of path without terminating null */
+			retval += finfo.st_size;
+		}
+	} else if ( S_ISDIR(finfo.st_mode) ) { /* directory */
+		/* st_blocks is the actual number of blocks allocated for
+		   the file in 512-byte units */
+		retval += finfo.st_size;
+		// retval += (finfo.st_blocks * 512);
+
+		struct dirent **eps = NULL;
+		/* get directory listing - this allocates memory for **eps */
+		int n = scandir(fullpath, &eps, cdw_scandir_filter_two, &alphasort);
+		if (n < 0) {
+			return -1;
+		} else {
+			int i;
+			for (i = 0; i < n; i++) {
+				/* for every dir entry create new full path to this entry and scan it */
+				char *newpath = (char *) malloc(strlen(fullpath) + 1 + strlen(eps[i]->d_name) + 1);
+				sprintf(newpath, "%s/%s", fullpath, eps[i]->d_name);
+				long long int dd = cdw_fs_dirsize_path(newpath, follow_symlinks);
+				if (dd > 0) {
+					retval += dd;
+				}
+
+				free(eps[i]);
+				eps[i] = NULL;
+
+				free(newpath);
+				newpath = NULL;
+			}
+		}
+
+		if (eps != NULL) {
+			free(eps);
+			eps = NULL;
+		}
+	}
+
+	return retval;
+}
+
+
+
+
+/**
+   \brief Modify given fullpath so that it points to new directory
+
+   Function does a bit more than only concatenating \p file_name
+   to \p dirpath. New dirpath is tested if it really points to directory,
+   and if the directory can be visited and read.
+
+   Note that both \p dirpath and \p file_name directory names should be
+   ended with "\". Resulting path will also follow this convention.
+
+   \p dirpath is updated only if new path is a directory and the directory
+   can be visited and read - only then the function returns CDW_OK. In any
+   other case \p dirpath is not modified and function returns proper error
+   value.
+
+   \param dirpath - directory path to be updated, it must be non-null string
+                    that can be allocated by this function
+   \param file_name - subdirectory name (not path) that should be used to
+                      update \p dirpath
+
+   \return CDW_MEM_ERROR on some allocation errors
+   \return CDW_SYS_ERROR if function can't read new directory at all (resulting fullpath is invalid?)
+   \return CDW_NO if the path is valid, but it is not a directory path
+   \return CDW_EPERM_NO_X if the directory can't be visited (no x permissions)
+   \return CDW_EPERM_NO_R if content of the directory can't be read (no r permissions)
+   \return CDW_GEN_ERROR on other errors
+   \return CDW_OK on success
+*/
+cdw_rv_t cdw_fs_update_dirpath(char **dirpath, const char *file_name)
+{
+	cdw_assert (*dirpath != (char *) NULL, "passed null dirpath to the function\n");
+	cdw_assert (file_name != (char *) NULL, "passed null file name to the function\n");
+	cdw_assert ((*dirpath)[0] == '/', "passed dirpath without leading slash\n");
+	size_t len = strlen(*dirpath);
+	cdw_assert (len > 0, "len of dirpath is zero\n");
+	cdw_assert ((*dirpath)[len - 1] == '/', "dirpath argument is without ending slash\n");
+
+	char *tmp = cdw_string_concat(*dirpath, file_name, (char *) NULL);
+	if (tmp == (char *) NULL) {
+		cdw_vdm ("ERROR: failed to concat dirpath and file name\n");
+		return CDW_MEM_ERROR;
+	}
+
+	char *resolved = realpath(tmp, (char *) NULL);
+	free(tmp);
+	tmp = (char *) NULL;
+
+	if (resolved == (char *) NULL) {
+		cdw_vdm ("ERROR: failed to resolve new dirpath with realpath() for %s / %s\n", *dirpath, file_name);
+		return CDW_SYS_ERROR;
+	} else {
+		len = strlen(resolved);
+		if (resolved[len - 1] != '/') {
+			cdw_rv_t crv = cdw_fs_correct_dir_path_ending(&resolved);
+			if (crv != CDW_OK) {
+				cdw_vdm ("ERROR: failed to ensure correct dir path ending for resolved path %s\n", resolved);
+				free(resolved);
+				resolved = (char *) NULL;
+
+				return CDW_GEN_ERROR;
+			}
+		}
+	}
+
+	cdw_sdm ("new dir path = %s\n", resolved);
+
+	/* so at this point we have potential path to new
+	   directory: resolved; lets check it closer */
+
+	struct stat stbuf;
+	if (stat(resolved, &stbuf) == -1) {
+		free(resolved);
+		resolved = (char *) NULL;
+
+		return CDW_SYS_ERROR;
+	}
+
+	/* check what the item is: file or dir? */
+	if ((stbuf.st_mode & S_IFMT) != S_IFDIR) {
+		/* pressing ENTER on non-directory should have no effect;
+		   link to directory is regarded as directory, so this
+		   condition won't be true for link to dir */
+		free(resolved);
+		resolved = (char *) NULL;
+
+		return CDW_NO;
+	}
+
+	/* so this is a dir path - check permissions */
+	if (access(resolved, X_OK) == -1) {
+		/* cannot change directory, get rid of resolved,
+		   old dirpath remains without changes */
+
+		free(resolved);
+		resolved = (char *) NULL;
+
+		/* can't change directory, no point in checking if we can
+		   read its content */
+		return CDW_EPERM_NO_X;
+	} else {
+		if (access(resolved, R_OK) == -1) {
+
+			/* save current dir path - update value of
+			   function's argument; */
+
+			/* technically it would be possible to visit
+			   this dir, but file manager won't have too much
+			   use of this path - scandir will return -1 for it */
+			free(resolved);
+			resolved = (char *) NULL;
+
+			/* can change dir, but can't read its content;
+			   file manager can't do much here either */
+			return CDW_EPERM_NO_R;
+		} else {
+			/* we have execute and read prems for new dir:
+			   we can go into this dir and can read its content */
+
+			/* save current dir path - update value of function's argument */
+			free(*dirpath);
+			*dirpath = resolved;
+
+			return CDW_OK;
+		}
+	}
+}
+
+
+
+
+
+/*
+  \p result is not modified if canonicalization fails
+*/
+cdw_rv_t cdw_fs_canonicalize_path(const char *base, char *path, char **result)
+{
+	size_t base_len = 0;
+	if (base == (char *) NULL || !strcmp(base, "")) {
+		base_len = 0;
+		if (path[0] != '/') {
+			cdw_vdm ("ERROR: base is empty, but path doesn't start with root: \"%s\"\n", path);
+			return CDW_GEN_ERROR;
+		}
+	} else {
+		if (base[0] != '/') {
+			cdw_vdm ("ERROR: base path doesn't start with root: \"%s\"\n", base);
+			return CDW_GEN_ERROR;
+		} else {
+			base_len = strlen(base);
+		}
+	}
+	size_t path_len = strlen(path);
+
+	int a = 0;
+	if (base_len == 0) {
+		a = asprintf(result, "%s", path);
+	} else {
+		a = asprintf(result, "%s%s", base, path);
+	}
+	if (a == -1) {
+		cdw_vdm ("ERROR: asprintf() returns -1\n");
+		return CDW_GEN_ERROR;
+	} else {
+		cdw_assert ((size_t) a == base_len + path_len, "ERROR: lengths mismatch: asprintf() returns %d, should return %zd\n", a, base_len + path_len);
+	}
+
+	/* at this point we have a full, non-relative path, regardless
+	   of input data (base and path); this full path may still contain
+	   "../" and "./" substrings which we should get rid of */
+
+	size_t from = 0; /* a cursor walking whole fullpath and inspecting every char */
+	size_t to = 0;   /* a cursor which will be the target of copied data */
+	for (from = 0; from < base_len + path_len; ) {
+
+		if ((*result)[from] == '/'
+		    && (from + 1 < base_len + path_len)  &&  (*result)[from + 1] == '.'
+		    && (from + 2 < base_len + path_len)  &&  (*result)[from + 2] == '.'
+		    && ( ((from + 3 < base_len + path_len)  &&  (*result)[from + 3] == '/')
+			 || (*result)[from + 3] == '\0') ) {
+
+			/* "/../" or "/..\0" */
+			if ((*result)[from + 3] == '\0') {
+				/* keep "from" in place so that ending '/' is copied */
+				from += 0;
+				(*result)[from + 1] = '\0';
+			} else {
+				/* move "from" forward, past this symbol */
+				from += 3;
+			}
+
+			/* now we have to move "to" one parent up, but before
+			   that we have to make sure that "to" doesn't stand on
+			   beginning of current "/../" symbol; such situation
+			   may happen when "to"=="from" */
+			if ((*result)[to] == '/') {
+				/* remember that this may be root dir */
+				to = to == 0 ? to : to - 1;
+			}
+
+			/* now we can safely move "to" cursor one parent dir up */
+			for (; to > 0; to--) {
+				if ((*result)[to] == '/') {
+					break;
+				}
+			}
+		} else if ((*result)[from] == '/'
+			   && (from + 1 < base_len + path_len)  &&  (*result)[from + 1] == '.'
+			   && ( ((from + 2 < base_len + path_len)  &&  (*result)[from + 2] == '/')
+				|| (*result)[from + 2] == '\0') ) {
+
+			/* "/./" or "/.\0" */
+			if ((*result)[from + 2] == '\0') {
+				/* keep "from" in place so that ending '/' is copied */
+				from += 0;
+				(*result)[from + 1] = '\0';
+			} else {
+				/* move "from" forward, past this symbol */
+				from += 2;
+			}
+		} else if ((*result)[from] == '/'
+			   && (from + 1 < base_len + path_len)  &&  (*result)[from + 1] == '/') {
+
+			/* "//" */
+			from += 1;
+		} else {
+			/* "normal" situation, the only place where we copy chars */
+			(*result)[to++] = (*result)[from++];
+		}
+	}
+
+	(*result)[to] = '\0';
+
+	return CDW_OK;
+}
+
+
+
+void test_cdw_fs_canonicalize_path(void)
+{
+	fprintf(stderr, "\ttesting cdw_fs_canonicalize_path()...\n");
+#ifndef NDEBUG
+	fprintf(stderr, "\t(if you see two \"ERROR\" messages below then you can ignore them)\n");
+#endif
+	cdw_rv_t crv = CDW_OK;
+	char base[1024];
+	char path[1024];
+	char *result = (char *) NULL;
+
+	/* test basic conditions on function's arguments */
+	strcpy(base, "");
+	strcpy(path, "a");
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_GEN_ERROR, "ERROR: A1\n");
+	cdw_assert (result == (char *) NULL, "ERROR: A2\n");
+
+
+	/* test basic conditions on function's arguments */
+	strcpy(base, "a");
+	strcpy(path, "/");
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_GEN_ERROR, "ERROR: B1\n");
+	cdw_assert (result == (char *) NULL, "ERROR: B2\n");
+
+
+	/* test normal situation, where path is not modified */
+	strcpy(base, "/");
+	strcpy(path, "my/simple/test/dirs/string");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: C1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/dirs/string"), "ERROR: C2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test cutting out "/./" elements */
+	strcpy(base, "/");
+	strcpy(path, "./my/./simple/test/dirs/string");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: D1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/dirs/string"), "ERROR: D2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test cutting out mix of "/./" and "//" elements */
+	strcpy(base, "/");
+	strcpy(path, "./my///simple/////test/././//dirs/string");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: E1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/dirs/string"), "ERROR: E2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test cutting out mix of more "/./" and "//" elements */
+	strcpy(base, "/");
+	strcpy(path, "././/./././/my////.//simple/./test/dirs/string");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: F1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/dirs/string"), "ERROR: F2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test behavior with reference to parent dir - simple case */
+	strcpy(base, "/");
+	strcpy(path, "my/simple/../test/dirs/string");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: G1\n");
+	cdw_assert (!strcmp(result, "/my/test/dirs/string"), "ERROR: G2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test behavior with reference to parent dir - more complicated case */
+	strcpy(base, "/../");
+	strcpy(path, "../simple/../../test/dirs/string");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: H1\n");
+	cdw_assert (!strcmp(result, "/test/dirs/string"), "ERROR: H2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test behavior with mix of "/../", "/./" and "//" */
+	strcpy(base, "/..///../base/dir///.././/of/.//./");
+	strcpy(path, "my/simple/../././//././/.//..//test/dirs/string");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: I1\n");
+	cdw_assert (!strcmp(result, "/base/of/test/dirs/string"), "ERROR: I2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* "...", "..of..", "..my." are valid dir names, not special entities */
+	strcpy(base, "/base/.../..of..//");
+	strcpy(path, "..my./simple/...//./..//././/.//..//test/dirs../string.../////// ");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: J1\n");
+	cdw_assert (!strcmp(result, "/base/.../..of../..my./test/dirs../string.../ "), "ERROR: J2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test removing "." from end of path */
+	strcpy(base, "/");
+	strcpy(path, "my/simple/test/dirs/string/.");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: K1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/dirs/string/"), "ERROR: K2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test removing ending ".." and last dir from of path */
+	strcpy(base, "/");
+	strcpy(path, "my/simple/test/dirs/string/..");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: L1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/dirs/"), "ERROR: L2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test removing ending ".." and last dir from of path - second case */
+	strcpy(base, "/");
+	strcpy(path, "my/simple/test/dirs/string/../..//");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: M1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/"), "ERROR: M2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+	/* test removing ending ".."/"." and last dir from of path - third case */
+	strcpy(base, "/");
+	strcpy(path, "my/simple/test/dirs/string/..//../.");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: N1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/"), "ERROR: N2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+
+	/* test removing duplicated "/" from end of path */
+	strcpy(base, "/");
+	strcpy(path, "my/simple/test/dirs/string//");
+	cdw_sdm ("INFO: base = %s, path = %s\n", base, path);
+	crv = cdw_fs_canonicalize_path(base, path, &result);
+	cdw_assert (crv == CDW_OK, "ERROR: O1\n");
+	cdw_assert (!strcmp(result, "/my/simple/test/dirs/string/"), "ERROR: O2: %s\n", result);
+	free(result);
+	result = (char *) NULL;
+
+	fprintf(stderr, "OK\n");
+
+	return;
+}
+
+
+
+
+#endif
+
+
+
+/* from external_tools/cdw_regex_dispatch.c */
+
+
+
+/* *** unused code below *** */
+
+#if 0
+
+
+/* stdout_regexp_execute() is still used, but I'm pasting it here
+   because of the while() loop used in it */
+/**
+   \brief Regular expressions execution code for stdout pipe
+
+   This function calls *_stdout_regexp_execute() depending on value of
+   \p task->tool variable.
+*/
+void stdout_regexp_execute(const cdw_task_t *task)
+{
+	cdw_sdm ("INFO: STDOUT PIPE: %s\n", stdout_pipe_buffer);
+	cdw_sdm ("dispatching... \n");
+
+	if (task->main_tool_id == CDW_TOOL_GROWISOFS) {
+		cdw_sdm ("dispatching to growisofs\n");
+		growisofs_stdout_regexp_execute();
+
+	} else if (task->main_tool_id == CDW_TOOL_CDRECORD) {
+		cdw_sdm ("dispatching to cdrecord\n");
+		cdrecord_stdout_regexp_execute();
+
+	} else if (task->main_tool_id == CDW_TOOL_MKISOFS) {
+		cdw_sdm ("dispatching to mkisofs\n");
+		mkisofs_stdout_regexp_execute();
+
+	} else if (task->main_tool_id == CDW_TOOL_DVD_RW_MEDIAINFO) {
+		cdw_sdm ("dispatching to dvd_rw_mediainfo\n");
+
+#if 0 /* this doesn't seem to be necessary anymore, because I changed how
+	 thread functions read data from pipes (char after char) and how
+	 they detect newline and react to it - external tool's output is
+	 now processed truly line after line, not block after block */
+
+		/*
+		There is this strange thing with dvd+rw-mediainfo output:
+		it seems to print TOC information in one block with '\n'
+		chars as line separators instead of writing it in separate,
+		'\0'-terminated lines. The code emulates '\0'-terminating of
+		separate lines. Whole block with '\n' chars is split into
+		chunks of chars with '\0' at the end.
+
+		It works for normal lines (normal as in	"one bit of
+		information per '\0'-terminated string) and it should work
+		when this bug (?) in dvd+rw-mediainfo will be fixed.
+		*/
+		/* TODO: is this necessary after making read() read char
+		   by char in thread.c code? */
+
+		int i = 0;
+		while (i < PIPE_BUFFER_SIZE) {
+			/* index of PREVIOUS occurrence of '\n' in block */
+			int previ = i;
+
+			/* replace NEXT occurrence of '\n' with '\0' */
+			for (; i < PIPE_BUFFER_SIZE; i++) {
+				if (stdout_pipe_buffer[i] == '\n') {
+					stdout_pipe_buffer[i] = '\0';
+					break;
+				}
+			}
+
+			/* blank string from beginning of string to end
+			of PREVIOUS chunk of chars */
+			int j = 0;
+			for (j = 0; j <= previ; j++) {
+				stdout_pipe_buffer[j] = ' ';
+			}
+
+			/* let regexp code handle NEXT chunk of chars */
+			dvd_rw_mediainfo_stdout_regexp_execute();
+		}
+#else
+		dvd_rw_mediainfo_stdout_regexp_execute();
+#endif
+
+	} else if (task->main_tool_id == CDW_TOOL_DVD_RW_FORMAT) {
+		/* cdw_sdm ("dispatching to dvd+rw-format\n",); */
+		/* cdw_dvd_rw_format_stdout_regexp_execute(); currently only stderr is 'active' */
+
+	} else if (task->main_tool_id == CDW_TOOL_MD5SUM) {
+		cdw_sdm ("dispatching to md5sum\n");
+		md5sum_stdout_regexp_execute();
+
+	} else if (task->main_tool_id == CDW_TOOL_WHICH) {
+		cdw_sdm ("dispatching to which\n");
+		which_stdout_regexp_execute();
+
+	} else {
+		cdw_assert (0, "unknown tool %d caused me to fail\n", task->main_tool_id);
+	}
+
+	return;
+}
+
+
+
+#if 0
+/**
+   \brief Regular expressions setup code for stdout pipe
+
+   This function calls *_stdout_regexp_prepare() depending on value of
+   \p task->tool variable.
+*/
+void stdout_regexp_prepare(const cdw_task_t *task)
+{
+	cdw_sdm ("dispatching... \n");
+
+	if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
+			cdw_sdm ("dispatching to growisofs\n");
+			growisofs_stdout_regexp_prepare();
+		} else if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_prepare();
+		} else {
+			cdw_vdm ("ERROR: incorrect burning tool id %d\n", task->burn.tool.id);
+		}
+
+		if (task->id == CDW_TASK_BURN_FROM_FILES) {
+			/* mkisofs will be used during creation of
+			   intermediate ISO file system, and this is
+			   to catch errors reported during this process */
+			cdw_sdm ("dispatching to mkisofs as a helper tool for burning files\n");
+			mkisofs_stdout_regexp_prepare();
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		cdw_sdm ("dispatching to mkisofs\n");
+		mkisofs_stdout_regexp_prepare();
+	} else if (task->id == CDW_TASK_MEDIA_INFO) {
+		if (task->media_info.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_prepare();
+		} else if (task->media_info.tool.id == CDW_TOOL_DVD_RW_MEDIAINFO) {
+			cdw_sdm ("dispatching to dvd_rw_mediainfo\n");
+			dvd_rw_mediainfo_stdout_regexp_prepare();
+		} else {
+			cdw_vdm ("ERROR: incorrect media info tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (task->erase.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_prepare();
+		} else if (task->erase.tool.id == CDW_TOOL_DVD_RW_FORMAT) {
+			/* cdw_sdm ("dispatching to dvd+rw-format\n"); */
+			/* cdw_dvd_rw_format_stdout_regexp_prepare(); currently only stderr is 'active' */
+		} else {
+			cdw_vdm ("ERROR: incorrect erase tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		cdw_sdm ("dispatching to md5sum\n");
+		md5sum_stdout_regexp_prepare();
+	} else {
+		cdw_assert (0, "ERROR: unknown task id %d\n", task->id);
+	}
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Regular expressions execution code for stdout pipe
+
+   This function calls *_stdout_regexp_execute() depending on value of
+   \p task->tool variable.
+*/
+void stdout_regexp_execute(const cdw_task_t *task)
+{
+	cdw_sdm ("INFO: STDOUT PIPE: %s\n", stdout_pipe_buffer);
+	cdw_sdm ("dispatching... \n");
+
+	if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
+			cdw_sdm ("dispatching to growisofs\n");
+			growisofs_stdout_regexp_execute();
+		} else if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_execute();
+		} else {
+			cdw_vdm ("ERROR: incorrect burning tool id %d\n", task->burn.tool.id);
+		}
+
+		if (task->id == CDW_TASK_BURN_FROM_FILES) {
+			/* mkisofs will be used during creation of
+			   intermediate ISO file system, and this is
+			   to catch errors reported during this process */
+			cdw_sdm ("dispatching to mkisofs as a helper tool for burning files\n");
+			mkisofs_stdout_regexp_execute();
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		cdw_sdm ("dispatching to mkisofs\n");
+		mkisofs_stdout_regexp_execute();
+	} else if (task->id == CDW_TASK_MEDIA_INFO) {
+		if (task->media_info.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_execute();
+		} else if (task->media_info.tool.id == CDW_TOOL_DVD_RW_MEDIAINFO) {
+			cdw_sdm ("dispatching to dvd_rw_mediainfo\n");
+			dvd_rw_mediainfo_stdout_regexp_execute();
+		} else {
+			cdw_vdm ("ERROR: incorrect media info tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (task->erase.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_execute();
+		} else if (task->erase.tool.id == CDW_TOOL_DVD_RW_FORMAT) {
+			/* cdw_sdm ("dispatching to dvd+rw-format\n",); */
+			/* cdw_dvd_rw_format_stdout_regexp_execute(); currently only stderr is 'active' */
+		} else {
+			cdw_vdm ("ERROR: incorrect erase tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		cdw_sdm ("dispatching to md5sum\n");
+		md5sum_stdout_regexp_execute();
+	} else {
+		cdw_assert (0, "ERROR: unknown task id %d\n", task->id);
+	}
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Regular expressions cleanup code for stdout pipe
+
+   This function calls *_stdout_regexp_destroy() depending on value of
+   \p task->tool variable.
+*/
+void stdout_regexp_destroy(const cdw_task_t *task)
+{
+	cdw_sdm ("dispatching... \n");
+
+	if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
+			cdw_sdm ("dispatching to growisofs\n");
+			growisofs_stdout_regexp_destroy();
+		} else if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_destroy();
+		} else {
+			cdw_vdm ("ERROR: incorrect burning tool id %d\n", task->burn.tool.id);
+		}
+
+		if (task->id == CDW_TASK_BURN_FROM_FILES) {
+			/* mkisofs will be used during creation of
+			   intermediate ISO file system, and this is
+			   to catch errors reported during this process */
+			cdw_sdm ("dispatching to mkisofs as a helper tool for burning files\n");
+			mkisofs_stdout_regexp_destroy();
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		cdw_sdm ("dispatching to mkisofs\n");
+		mkisofs_stdout_regexp_destroy();
+	} else if (task->id == CDW_TASK_MEDIA_INFO) {
+		if (task->media_info.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_destroy();
+		} else if (task->media_info.tool.id == CDW_TOOL_DVD_RW_MEDIAINFO) {
+			cdw_sdm ("dispatching to dvd_rw_mediainfo\n");
+			dvd_rw_mediainfo_stdout_regexp_destroy();
+		} else {
+			cdw_vdm ("ERROR: incorrect media info tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (task->erase.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stdout_regexp_destroy();
+		} else if (task->erase.tool.id == CDW_TOOL_DVD_RW_FORMAT) {
+			/* cdw_sdm ("dispatching to dvd+rw-format\n"); */
+			/* cdw_dvd_rw_format_stdout_regexp_destroy(); currently only stderr is 'active' */
+		} else {
+			cdw_vdm ("ERROR: incorrect erase tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		cdw_sdm ("dispatching to md5sum\n");
+		md5sum_stdout_regexp_destroy();
+	} else {
+		cdw_assert (0, "ERROR: unknown task id %d\n", task->id);
+	}
+
+	return;
+}
+
+
+
+
+
+/**
+ * \brief Regular expressions setup code for stderr pipe
+ *
+ * This function calls *_stderr_regexp_prepare() depending on value of
+ * \p task->tool variable.
+ */
+void stderr_regexp_prepare(const cdw_task_t *task)
+{
+	cdw_sdm ("dispatching... \n");
+
+	if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
+			cdw_sdm ("dispatching to growisofs\n");
+			growisofs_stderr_regexp_prepare();
+		} else if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_prepare();
+		} else {
+			cdw_vdm ("ERROR: incorrect burning tool id %d\n", task->burn.tool.id);
+		}
+
+		if (task->id == CDW_TASK_BURN_FROM_FILES) {
+			/* mkisofs will be used during creation of
+			   intermediate ISO file system, and this is
+			   to catch errors reported during this process */
+			cdw_sdm ("dispatching to mkisofs as a helper tool for burning files\n");
+			mkisofs_stderr_regexp_prepare();
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		cdw_sdm ("dispatching to mkisofs\n");
+		mkisofs_stderr_regexp_prepare();
+	} else if (task->id == CDW_TASK_MEDIA_INFO) {
+		if (task->media_info.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_prepare();
+		} else if (task->media_info.tool.id == CDW_TOOL_DVD_RW_MEDIAINFO) {
+			/* we don't capture any data on stderr of dvd+rw-mediainfo */
+			/* cdw_sdm ("dispatching to dvd+rw-mediainfo\n"); */
+			/* dvd_rw_mediainfo_stderr_regexp_prepare(); */
+		} else {
+			cdw_vdm ("ERROR: incorrect media info tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (task->erase.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_prepare();
+		} else if (task->erase.tool.id == CDW_TOOL_DVD_RW_FORMAT) {
+			cdw_sdm ("dispatching to dvd+rw-format\n");
+			cdw_dvd_rw_format_stderr_regexp_prepare();
+		} else {
+			cdw_vdm ("ERROR: incorrect erase tool id %d\n", task->erase.tool.id);
+		}
+
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		/* md5sum does not produce any data on stderr  */
+		/* cdw_sdm ("dispatching to md5sum\n"); */
+		;
+	} else {
+		cdw_assert (0, "ERROR: unknown task id %d\n", task->id);
+	}
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Regular expressions execution code for stderr pipe
+
+   This function calls *_stderr_regexp_execute() depending on value of
+   \p task->tool variable.
+*/
+void stderr_regexp_execute(const cdw_task_t *task)
+{
+	cdw_sdm ("INFO: STDERR PIPE: %s\n", stderr_pipe_buffer);
+	cdw_sdm ("dispatching... \n");
+
+	if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
+			cdw_sdm ("dispatching to growisofs\n");
+			growisofs_stderr_regexp_execute();
+		} else if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_execute();
+		} else {
+			cdw_vdm ("ERROR: incorrect burning tool id %d\n", task->burn.tool.id);
+		}
+
+		if (task->id == CDW_TASK_BURN_FROM_FILES) {
+			/* mkisofs will be used during creation of
+			   intermediate ISO file system, and this is
+			   to catch errors reported during this process */
+			cdw_sdm ("dispatching to mkisofs as a helper tool for burning files\n");
+			mkisofs_stderr_regexp_execute();
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		cdw_sdm ("dispatching to mkisofs\n");
+		mkisofs_stderr_regexp_execute();
+	} else if (task->id == CDW_TASK_MEDIA_INFO) {
+		if (task->media_info.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_execute();
+		} else if (task->media_info.tool.id == CDW_TOOL_DVD_RW_MEDIAINFO) {
+			/* we don't capture any data on stderr of dvd+rw-mediainfo */
+			/* cdw_sdm ("dispatching to dvd+rw-mediainfo\n"); */
+			/* dvd_rw_mediainfo_stderr_regexp_execute(); */
+		} else {
+			cdw_vdm ("ERROR: incorrect media info tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (task->erase.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_execute();
+		} else if (task->erase.tool.id == CDW_TOOL_DVD_RW_FORMAT) {
+			cdw_sdm ("dispatching to dvd+rw-format\n");
+			cdw_dvd_rw_format_stderr_regexp_execute();
+		} else {
+			cdw_vdm ("ERROR: incorrect erase tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		/* md5sum does not produce any data on stderr */
+		/* cdw_sdm ("dispatching to md5sum\n"); */
+	} else {
+		cdw_assert (0, "ERROR: unknown task id %d\n", task->id);
+	}
+
+	return;
+}
+
+
+
+
+
+
+
+
+
+/**
+   \brief Regular expressions cleanup code for stderr pipe
+
+   This function calls *_stderr_regexp_destroy() depending on value of
+   \p task->tool variable.
+*/
+void stderr_regexp_destroy(const cdw_task_t *task)
+{
+	cdw_sdm ("dispatching... \n");
+
+	if (task->id == CDW_TASK_BURN_FROM_FILES || task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
+			cdw_sdm ("dispatching to growisofs\n");
+			growisofs_stderr_regexp_destroy();
+		} else if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_destroy();
+		} else {
+			cdw_vdm ("ERROR: incorrect burning tool id %d\n", task->burn.tool.id);
+		}
+
+		if (task->id == CDW_TASK_BURN_FROM_FILES) {
+			/* mkisofs will be used during creation of
+			   intermediate ISO file system, and this is
+			   to catch errors reported during this process */
+			cdw_sdm ("dispatching to mkisofs as a helper tool for burning files\n");
+			mkisofs_stderr_regexp_destroy();
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE) {
+		cdw_sdm ("dispatching to mkisofs\n");
+		mkisofs_stderr_regexp_destroy();
+	} else if (task->id == CDW_TASK_MEDIA_INFO) {
+		if (task->media_info.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_destroy();
+		} else if (task->media_info.tool.id == CDW_TOOL_DVD_RW_MEDIAINFO) {
+			/* we don't capture any data on stderr of dvd+rw-mediainfo */
+			/* cdw_sdm ("dispatching to dvd+rw-mediainfo\n"); */
+			/* dvd_rw_mediainfo_stderr_regexp_destroy(); */
+		} else {
+			cdw_vdm ("ERROR: incorrect media info tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (task->erase.tool.id == CDW_TOOL_CDRECORD) {
+			cdw_sdm ("dispatching to cdrecord\n");
+			cdrecord_stderr_regexp_destroy();
+		} else if (task->erase.tool.id == CDW_TOOL_DVD_RW_FORMAT) {
+			cdw_sdm ("dispatching to dvd+rw-format\n");
+			cdw_dvd_rw_format_stderr_regexp_destroy();
+		} else {
+			cdw_vdm ("ERROR: incorrect erase tool id %d\n", task->media_info.tool.id);
+		}
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		/* md5sum does not produce any data on stderr */
+		/* cdw_sdm ("dispatching to md5sum\n"); */
+	} else {
+		cdw_assert (0, "ERROR: unknown task id %d\n", task->id);
+	}
+
+	return;
+}
+
+
+#endif
+
+
+
+#endif
+
+
+
+/* *** from external_tools/cdw_cdrecord_regex.c *** */
+
+
+#if 0
+
+
+/* unused, writing speeds are collected by checking "cdrecord -prcap" */
+void handle_t1_speed(regex_t *regex, regmatch_t *matches)
+{
+	unsigned int i;
+	for (i = 0; i < (regex->re_nsub + 1); i++) {
+		size_t len = matches[i].rm_eo - matches[i].rm_so;
+		char submatch[PIPE_BUFFER_SIZE];
+		strncpy(submatch, (char *) &stdout_pipe_buffer[matches[i].rm_so], len);
+		submatch[len] = '\0';
+
+		cdw_sdm ("matching submatch: \"%s\"\n", submatch);
+		if (i == 1) {
+			cdw_sdm ("submatch%d: \"%s\"\n", submatch);
+		} else if (i == 2) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+			current_disc.cdrecord_info.atip_t1_low_speed = atoi(submatch);
+		} else if (i == 3) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+		} else if (i == 4) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+			current_disc.cdrecord_info.atip_t1_high_speed = atoi(submatch);
+		} else if (i == 5) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+		}
+		/* only 5 submatches defined */
+	}
+
+	return;
+}
+
+
+
+
+
+void handle_t2_speed(regex_t *regex, regmatch_t *matches)
+{
+	unsigned int i;
+	for (i = 0; i < (regex->re_nsub + 1); i++) {
+		size_t len = matches[i].rm_eo - matches[i].rm_so;
+		char submatch[PIPE_BUFFER_SIZE];
+		strncpy(submatch, (char *) &stdout_pipe_buffer[matches[i].rm_so], len);
+		submatch[len] = '\0';
+
+		cdw_sdm ("matching submatch: \"%s\"\n", submatch);
+		if (i == 1) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+		} else if (i == 2) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+			current_disc.cdrecord_info.atip_t2_low_speed = atoi(submatch);
+		} else if (i == 3) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+		} else if (i == 4) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+		} else if (i == 5) {
+			cdw_sdm ("submatch%d: \"%s\"\n", i, submatch);
+			current_disc.cdrecord_info.atip_t2_high_speed = atoi(submatch);
+		}
+		/* only 5 submatches defined */
+	}
+
+	return;
+}
+
+
+
+
+
+void handle_msinfo_sesion_offset(regex_t *regex, regmatch_t *matches)
+{
+	cdw_sdm ("called\n");
+
+	unsigned int i;
+	for (i = 0; i < (regex->re_nsub + 1); i++) {
+		size_t len = (size_t) (matches[i].rm_eo - matches[i].rm_so);
+		char submatch[PIPE_BUFFER_SIZE];
+		strncpy(submatch, (char *) &stdout_pipe_buffer[matches[i].rm_so], len);
+		submatch[len] = '\0';
+
+		cdw_sdm ("matching submatch: \"%s\"\n", submatch);
+
+		if (i == 1) {
+			cdw_sdm ("submatch%d: \"%s\"\n",  i, submatch);
+		}
+		/* only 1 submatch defined */
+	}
+
+	return;
+}
+
+
+
+
+void handle_audio_grab(char *c5)
+{
+	int perc = atoi(c5);
+	char percent[30];
+
+	if ((thread_task->id == TASK_READ && thread_task->tool == TOOL_CDRECORD) && (perc <= 100)) {
+		if (previous_percent != perc) {
+			char eta_string[25];
+			int eta = (int) ((difftime(time(NULL), time0) * (100 - perc)) / perc);
+			cdw_utils_eta_calculations(eta_string, eta);
+			previous_percent = perc;
+		}
+		mvwprintw(processwin, 5, 5, "");
+		processwin_draw_progress_bar((perc / 5), 5, 2, ACS_BLOCK);
+
+		/* 2TRANS: this string is currently not used; %d%% is amount of audio
+		   data already read from cd (in percents) */
+		sprintf(percent, _("  %d%% done  "), perc);
+		mvwprintw(processwin, 3, 15 - (strlen(percent) / 2), "%s", percent);
+		/* mvwprintw(processwin, 5, 5, "");
+		mvwprintw(processwin, 9, 29, "");
+		mvwprintw(processwin, 7, 5, "T: %d P: %d L: %d   ", track, perc, lasttrack); */
+		wrefresh(processwin);
+		/* fprintf(log, "\nT: %d P: %d L: %d\n", track, perc, lasttrack); */
+		/* fflush(logfi); */
+		stderr_pipe_buffer[0] = '\0';
+		/* track=perc;
+		sleep(1); */
+	}
+
+	return;
+}
+
+
+
+
+
+
+void handle_is_erasable(regex_t *regex, regmatch_t *matches)
+{
+	current_disc.type_erasable = CDW_TRUE;
+
+	return;
+}
+#endif
+
+
+
+
+
+/* *** cdw_erase_wizard.c *** */
+
+
+#if 0
+/**
+   \brief Build labels representing available erasing modes
+
+   \param disc_type - variable describing exact disc type
+*/
+cdw_rv_t cdw_erase_wizard_build_erase_mode_dd_labels(cdw_disc_type_t disc_type)
+{
+	if (disc_type == CDW_DVD_RWP) {
+		/* 2TRANS: this string means "perform erasing in fast mode" */
+		wizard.erase_mode_dd.labels[0] = strdup(_("Erase in fast mode"));
+		wizard.erase_mode_dd.ids[0] = CDW_ERASE_MODE_ID_FAST;
+
+		wizard.erase_mode_dd.labels[1] = (char *) NULL;
+		wizard.erase_mode_dd.ids[1] = CDW_ERASE_MODE_ID_INIT;
+
+		if (wizard.erase_mode_dd.labels[0] == (char *) NULL) {
+			cdw_vdm ("ERROR: failed to create erase mode dropdown label 0\n");
+			return CDW_GEN_ERROR;
+		}
+	} else {
+		/* 2TRANS: this string means "perform erasing in fast mode" */
+		wizard.erase_mode_dd.labels[0] = strdup(_("Erase in fast mode"));
+		wizard.erase_mode_dd.ids[0] = CDW_ERASE_MODE_ID_FAST;
+
+		/* 2TRANS: this string means "erase all data from disc" */
+		wizard.erase_mode_dd.labels[1] = strdup(_("Erase all content (long time)"));
+		wizard.erase_mode_dd.ids[1] = CDW_ERASE_MODE_ID_LONG;
+
+		wizard.erase_mode_dd.labels[2] = (char *) NULL;
+		wizard.erase_mode_dd.ids[2] = CDW_ERASE_MODE_ID_INIT;
+
+		if (wizard.erase_mode_dd.labels[0] == (char *) NULL
+		    || wizard.erase_mode_dd.labels[1] == (char *) NULL) {
+
+			cdw_vdm ("ERROR: failed to create erase mode dropdown label 0 or 1\n");
+			return CDW_GEN_ERROR;
+		}
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+   \brief Build labels for dropdown representing possible formatting modes for DVD-RW
+
+   These formatting modes are:
+   \li 'don't change format' (in most cases this should probably be default)
+   \li 'format to sequential'
+   \li 'format to restricted'
+
+   \param disc_type - variable describing exact disc type
+
+   \return CDW_OK on success
+   \return CDW_GEN_ERROR on some malloc error
+*/
+cdw_rv_t cdw_erase_wizard_build_format_mode_dd_labels(cdw_disc_type_t disc_type)
+{
+	/* remember that gettext() result strings must not be free()d */
+
+	/* 2TRANS: this is label in dropdown: it means "don't change
+	   format of DVD-RW during process of erasing disc" */
+	char *dont_change = _("Don't change format of DVD-RW");
+	/* 2TRANS: this is label in dropdown: 'Sequential' is one of two
+	   possible formats of DVD-RW */
+	char *seq = _("Change format to Sequential");
+	/* 2TRANS: this is label in dropdown: 'Restricted' is one of two
+	   possible formats of DVD-RW */
+	char *res = _("Change format to Restricted");
+
+	if (seq == (char *) NULL || res == (char *) NULL || dont_change == (char *) NULL) {
+		cdw_vdm ("ERROR: failed to create initial labels for format mode dropdown\n");
+		return CDW_GEN_ERROR;
+	}
+
+	if (disc_type == CDW_DVD_RW_SEQ) {
+		wizard.format_mode_dd.labels[0] = strdup(dont_change);
+		wizard.format_mode_dd.ids[0] = DVD_RW_FORMAT_SEQ;
+
+		wizard.format_mode_dd.labels[1] = strdup(res);
+		wizard.format_mode_dd.ids[1] = DVD_RW_FORMAT_RES;
+
+		wizard.format_mode_dd.labels[2] = (char *) NULL;
+
+	} else if (disc_type == CDW_DVD_RW_RES) {
+		wizard.format_mode_dd.labels[0] = strdup(dont_change);
+		wizard.format_mode_dd.ids[0] = DVD_RW_FORMAT_RES;
+
+		wizard.format_mode_dd.labels[1] = strdup(seq);
+		wizard.format_mode_dd.ids[1] = DVD_RW_FORMAT_SEQ;
+
+		wizard.format_mode_dd.labels[2] = (char *) NULL;
+
+	} else { /* we don't know if current disc is in Sequential or Restricted format */
+		wizard.format_mode_dd.labels[0] = strdup(res);
+		wizard.format_mode_dd.ids[0] = DVD_RW_FORMAT_RES;
+
+		wizard.format_mode_dd.labels[1] = strdup(seq);
+		wizard.format_mode_dd.ids[1] = DVD_RW_FORMAT_SEQ;
+
+		wizard.format_mode_dd.labels[2] = (char *) NULL;
+	}
+
+	if (wizard.format_mode_dd.labels[0] == (char *) NULL
+	    || wizard.format_mode_dd.labels[1] == (char *) NULL) {
+
+		cdw_vdm ("ERROR: failed to initialize format mode dropdown label 0 or 1\n");
+		return CDW_GEN_ERROR;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+#if 0
+/**
+   \brief Build widgets visible in wizard window and place them in that window
+
+   Function creates dropdowns and buttons that should be visible in
+   wizard window, and places them in that window - ready for use.
+   Function checks if "format mode" dropdown should be created or not (depending
+   on disc type), and creates it - or not.
+
+   \param disc
+
+   \return CDW_OK on success
+   \return CDW_GEN_ERROR on failure
+*/
+cdw_rv_t cdw_erase_wizard_build_widgets(cdw_disc_t *disc)
+{
+	/* **** erasing mode dropdown ("fast"/"all") **** */
+
+	/* 2TRANS: this is label in blank wizard window. User may select
+	   mode of erasing a disc in dropdown below this message. */
+	mvwprintw(wizard.window.win, erase_mode_row, first_col, _("Select mode of erasing:"));
+	/* this function also sets which dropdown item is selected at the beginning */
+	wizard.erase_mode.dropdown = cdw_erase_wizard_make_erase_mode_dropdown(disc->type);
+	if (wizard.erase_mode.dropdown == (CDW_DROPDOWN *) NULL) {
+		cdw_vdm ("ERROR: failed to create erase mode dropdown\n");
+		return CDW_GEN_ERROR;
+	}
+
+	/* **** erasing speed dropdown (2, 4, 8 etc.) **** */
+
+	/* 2TRANS: this is message in blank wizard window. User may select
+	   speed of erasing a disc in dropdown below this message. */
+	mvwprintw(wizard.window.win, SPEED_ROW, first_col, _("Select speed:"));
+	/* this function also sets which dropdown item is selected at the beginning */
+	wizard.speed.dropdown = cdw_erase_wizard_make_speed_dropdown(disc);
+	if (wizard.speed.dropdown == (CDW_DROPDOWN *) NULL) {
+		cdw_vdm ("ERROR: failed to create speed dropdown\n");
+		return CDW_GEN_ERROR;
+	}
+
+
+	/* **** format mode dropdown for visible only when
+	   disc type == DVD-RW and erasing tool == dvd+rw-format */
+	if (wizard.format_mode.visible) {
+
+		/* 2TRANS: this is label next to dropdown: process of
+		   erasing DVD-RW also allows to choose mode of formatting of
+		   DVD-RW: Sequential or Restricted */
+		mvwprintw(wizard.window.win, FORMAT_MODE_ROW, first_col, _("Select new format for DVD-RW:"));
+		/* this function also sets which dropdown item is selected at the beginning
+		   (although it doesn't do this too intelligently) */
+		wizard.format_mode.dropdown = cdw_erase_wizard_make_format_mode_dropdown(disc);
+		if (wizard.format_mode.dropdown == (CDW_DROPDOWN *) NULL) {
+			cdw_vdm ("ERROR: failed to create format mode dropdown\n");
+			return CDW_GEN_ERROR;
+		}
+
+		cdw_dropdown_display_current_item(wizard.format_mode.dropdown);
+	}
+
+	cdw_dropdown_display_current_item(wizard.erase_mode.dropdown);
+	cdw_dropdown_display_current_item(wizard.speed.dropdown);
+
+	/* 2TRANS: this is label of button, 'erase' as in 'erase content of disc' */
+	wizard.erase_button = cdw_button_new(wizard.window.win, BUTTONS_ROW, 4, _("Erase"), CDW_COLORS_DIALOG);
+	/* 2TRANS: this is label of button */
+	wizard.cancel_button = cdw_button_new(wizard.window.win, BUTTONS_ROW, 15, _("Cancel"), CDW_COLORS_DIALOG);
+	if (! wizard.erase_button || ! wizard.cancel_button) {
+		cdw_vdm ("ERROR: failed to create \"erase\" or \"cancel\" button\n");
+		return CDW_GEN_ERROR;
+	} else {
+		return CDW_OK;
+	}
+}
+#endif
+
+
+#if 0
+
+/**
+   \brief Function handling keys entered when write wizard window is displayed
+
+   The function recognizes tab key as a key moving focus between all elements
+   of wizard window. Function handles keys pressed when focus is on button,
+   input field or unexpanded dropdown, and calls cdw_dropdown_driver() to
+   handle keyboard input when user operates in expanded dropdown.
+
+   \return CDW_OK - if user pressed ENTER when focus was on Write button,
+   \return CDW_CANCEL - if user pressed ENTER when focus was on Cancel button
+                         or user pressed Escape key at any moment
+*/
+cdw_rv_t cdw_erase_wizard_driver(void)
+{
+	/* points where currently cursor is placed,
+	   default selection is Cancel button */
+	enum {
+		SPEED_DROP,
+		ERASE_MODE_DROP,
+		FORMAT_MODE_DROP,
+
+		ERASE_BUTTON,
+		CANCEL_BUTTON
+	} current_focus = CANCEL_BUTTON;
+	cdw_button_focus(wizard.cancel_button);
+
+	int c = 0;
+
+	while (c != CDW_ESCAPE) {
+		if (c == '\t') {
+			/* TAB key only moves focus - nothing more */
+
+			if (current_focus == ERASE_BUTTON) {
+				cdw_button_unfocus(wizard.erase_button);
+				cdw_button_focus(wizard.cancel_button);
+				current_focus = CANCEL_BUTTON;
+				cdw_vdm ("INFO: focus on Cancel button, waiting for key\n");
+
+			} else if (current_focus == CANCEL_BUTTON) {
+				cdw_button_unfocus(wizard.cancel_button);
+				cdw_dropdown_focus(wizard.erase_mode.dropdown);
+				current_focus = ERASE_MODE_DROP;
+				cdw_vdm ("INFO: focus on erase mode dropdown, waiting for key\n");
+
+			} else if (current_focus == ERASE_MODE_DROP) {
+				cdw_dropdown_unfocus(wizard.erase_mode.dropdown);
+				cdw_dropdown_focus(wizard.speed.dropdown);
+				current_focus = SPEED_DROP;
+				cdw_vdm ("INFO: focus on speed dropdown, waiting for key\n");
+
+			} else if (current_focus == SPEED_DROP) {
+				cdw_dropdown_unfocus(wizard.speed.dropdown);
+
+				if (wizard.format_mode.visible) {
+					current_focus = FORMAT_MODE_DROP;
+					cdw_dropdown_focus(wizard.format_mode.dropdown);
+					cdw_vdm ("INFO: focus on format mode dropdown, waiting for key\n");
+				} else {
+					current_focus = ERASE_BUTTON;
+					cdw_button_focus(wizard.erase_button);
+					cdw_vdm ("INFO: focus on Erase button, waiting for key\n");
+				}
+
+			} else if (current_focus == FORMAT_MODE_DROP) {
+
+				cdw_dropdown_unfocus(wizard.format_mode.dropdown);
+				cdw_button_focus(wizard.erase_button);
+				current_focus = ERASE_BUTTON;
+				cdw_vdm ("INFO: focus on Erase button, waiting for key\n");
+			} else {
+				cdw_sdm ("WARNING: NO FOCUS\n");
+			}
+
+			c = 'a';  /* dummy value to keep focus in place and avoid idle looping */
+
+		} else if (c == CDW_ENTER || c == KEY_DOWN || c == ' ') {
+			/* toggle element that currently has focus;
+			   in case of button it means "pressing the button",
+			   in case of dropdowns it means "expanding the dropdown" */
+
+			if (current_focus == ERASE_BUTTON) {
+				if (c == CDW_ENTER) {
+					cdw_vdm ("INFO: clicked Erase button\n");
+					break;
+				} else {
+					; /* button reacts only to ENTER */
+				}
+			} else if (current_focus == CANCEL_BUTTON) {
+				if (c == CDW_ENTER) {
+					cdw_vdm ("INFO: clicked Cancel button\n");
+					break;
+				} else {
+					; /* button reacts only to ENTER */
+				}
+			} else if (current_focus == SPEED_DROP) {
+				cdw_rv_t crv = cdw_dropdown_driver(wizard.speed.dropdown);
+				wizard.speed.current_id = cdw_dropdown_get_current_item_id(wizard.speed.dropdown);
+				cdw_vdm ("INFO: visited speed dropdown, speed %s %d\n",
+					 crv == CDW_OK ? "changed to" : "is still",
+					 wizard.speed.current_id);
+
+			} else if (current_focus == FORMAT_MODE_DROP) {
+				cdw_rv_t crv = cdw_dropdown_driver(wizard.format_mode.dropdown);
+
+				wizard.format_mode.current_id = cdw_dropdown_get_current_item_id(wizard.format_mode_dropdown);
+
+				cdw_vdm ("INFO: visited format mode dropdown, format mode %s \"%s\" (item ind = %d)\n",
+					 crv == CDW_OK ? "changed to" : "is still",
+					 cdw_dropdown_get_current_item_label(wizard.format_mode.dropdown),
+					 cdw_dropdown_get_current_item_ind(wizard.format_mode.dropdown));
+
+			} else if (current_focus == ERASE_MODE_DROP) {
+				cdw_rv_t crv = cdw_dropdown_driver(wizard.erase_mode.dropdown);
+				int ind = cdw_dropdown_get_current_item_ind(wizard.erase_mode.dropdown);
+				cdw_assert (ind < 2, /* there are no more than 2 valid IDs in the dropdown */
+					    "ERROR: erase dropdown driver returns index too large: %d\n", ind);
+
+				wizard.erase_mode.current_id = cdw_dropdown_get_current_item_id(wizard.erase_mode.dropdown);
+				cdw_vdm ("INFO: visited erase mode dropdown, erase mode %s \"%s\"\n",
+					 crv == CDW_OK ? "changed to" : "is still",
+					 wizard.erase_mode.current_id == CDW_ERASE_MODE_ID_FAST ? "fast" : "all");
+			} else {
+				;
+			}
+			c = 'a'; /* dummy value to keep focus in place and avoid idle looping */
+		} else {
+			c = wgetch(wizard.window.win);
+			cdw_vdm ("INFO: got %s key\n", cdw_ncurses_key_label(c));
+		}
+	}
+
+	curs_set(0);
+	redrawwin(wizard.window.win);
+	wrefresh(wizard.window.win);
+
+	cdw_sdm ("INFO: returning c = %d (%s)\n", c, cdw_ncurses_key_label(c));
+
+	if (c == CDW_ENTER) { /* user pressed Enter key, but where? */
+		if (current_focus == ERASE_BUTTON) {
+			return CDW_OK;
+		} else {
+			return CDW_CANCEL;
+		}
+	} else { /* user pressed Escape key */
+		return CDW_CANCEL;
+	}
+}
+
+
+#endif
+
+
+
+
+#if 0
+/**
+   \brief Build wizard window
+
+   Build wizard window, but don't put there any widgets,
+   this will be done by separate function.
+
+   \param disc
+
+   \return CDW_OK on success
+   \return CDW_GEN_ERROR if window was not build correctly
+*/
+cdw_rv_t cdw_erase_wizard_build_window(cdw_disc_t *disc)
+{
+	wizard.window.win = newwin(wizard.window.n_lines, wizard.window.n_cols,
+				   wizard.window.begin_y, wizard.window.begin_x);
+	if (wizard.window.win == (WINDOW *) NULL) {
+		cdw_vdm ("ERROR: failed to create window with newwin() for erase wizard\n");
+		return CDW_GEN_ERROR;
+	}
+
+	keypad(wizard.window.win, TRUE);
+	wbkgd(wizard.window.win, COLOR_PAIR(CDW_COLORS_DIALOG));
+	werase(wizard.window.win);
+	/* 2TRANS: this is title of dialog window. Small window for
+	   preconfiguring erasing process */
+	cdw_ncurses_nice_box(wizard.window.win, _("Erase wizard"),
+			     /* 2TRANS: this is a tip for user - Tab key can be
+				used to move between window elements */
+			     _("Use Tab to move"));
+
+	mvwprintw(wizard.window.win, MESSAGE_ROW, FIRST_COL,
+		  /* 2TRANS: this is message in blank wizard window, erasing
+		     means here erasing content of optical disc, %s is disc
+		     type: CD or DVD */
+		  _("Select parameters for erasing a %s disc"),
+		  (disc->type == CDW_CD_RW) ?
+		  /* 2TRANS: this is disc type label: CD = Compact Disc - keep
+		     as short as possible */
+		  _("CD") :
+		  /* 2TRANS: this is disc type label: DVD - keep as short
+		     as possible */
+		  _("DVD"));
+
+	return CDW_OK;
+}
+#endif
+
+
+#endif
+
+
+
+
+/* from cdw_drive.c */
+/* *** unused code below *** */
+
+
+#if 0
+
+void cdw_drive_toggle_tray_with_ui_update(void)
+{
+	cdw_disc_current_disc_reset();
+	cdw_disc_t *current_disc = cdw_disc_get();
+	cdw_main_ui_disc_info_view_display_data(current_disc);
+	cdw_rv_t crv = cdw_drive_toggle_tray(global_config.cdrw_device);
+
+	if (crv == CDW_OK) {
+		cdw_sdm ("tray is open\n");
+	} else if (crv == CDW_CANCEL) {
+		cdw_sdm ("tray is closed (CDS_DISC_OK), getting metainfo\n");
+		/* read metainfo from disc, but only if disc is in drive */
+		cdw_rv_t mi = cdw_disc_get_meta_info(true);
+		if (mi != CDW_OK) {
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window */
+					   _("Cannot get media info."),
+					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+
+		} else {
+			;
+		}
+	} else {
+		;
+	}
+
+	cdw_main_ui_disc_info_view_display_data(current_disc);
+
+	return;
+}
+
+
+
+/**
+   \brief Check state of optical drive and eject or close tray
+
+   The function closes drive tray if it is open, and opens it if
+   it is closed. The function displays message if drive cannot be
+   accessed or does not respond for too long.
+
+   \param device_fullpath - path to device that you want to control
+ */
+cdw_rv_t cdw_drive_toggle_tray(const char *device_fullpath)
+{
+	cdw_rv_t m = cdw_fs_check_device_mounted(device_fullpath);
+	if (m == CDW_SYS_ERROR) {
+		; /* let's try anyway */
+	} else if (m == CDW_OK) { /* device is mounted */
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Message"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Cannot eject tray. Please unmount your drive."),
+				   CDW_BUTTONS_OK, CDW_COLORS_WARNING);
+		return CDW_GEN_ERROR;
+	} else { /* crv == CDW_NO, not mounted */
+		;
+	}
+
+	/* eject/close tray */
+	int rv = cdw_drive_status(device_fullpath);
+	if (rv == CDS_TRAY_OPEN) {
+		cdw_vdm ("INFO: tray is open (CDS_TRAY_OPEN) - closing\n");
+		/* 2TRANS: this is message displayed in process window */
+		cdw_processwin_display_sub_info(_("Closing tray"));
+		cdw_processwin_wrefresh();
+		/* NOTE: it may happen that if there is no disc, then
+		   cdw_drive_close_tray() will fail, and you should call
+		   cdw_drive_eject_tray() first */
+		cdw_drive_close_tray(device_fullpath);
+
+		return CDW_CANCEL;
+
+	} else if (rv == CDS_DISC_OK || rv == CDS_NO_DISC) {
+		cdw_vdm ("INFO: tray is closed (CDS_DISC_OK || CDS_NO_DISC) - ejecting\n");
+		/* 2TRANS: this is message displayed in process window */
+		cdw_processwin_display_sub_info(_("Ejecting tray"));
+		cdw_processwin_wrefresh();
+		cdw_drive_eject_tray(device_fullpath);
+
+		return CDW_OK;
+
+	} else if (rv == -1 || rv == CDS_NO_INFO) {
+		cdw_sdm ("error - CDW_SYS_ERROR || CDS_NO_INFO\n");
+		/* 2TRANS: this is title of dialog window: some error occurred
+		   while trying to access disc */
+		cdw_buttons_dialog(_("CD drive error"),
+				   /* 2TRANS: this is message in dialog window:
+				      some error occurred while accessing cdrom */
+				   _("Can't open device. Please check your configuration."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return CDW_GEN_ERROR;
+
+	} else if (rv == CDS_DRIVE_NOT_READY) {
+		/* 2TRANS: this is title of dialog window: some error occurred
+		   while trying to access disc */
+		cdw_buttons_dialog(_("CD drive error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("CDROM doesn't respond (timeout)."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		cdw_sdm ("error - CDS_DRIVE_NOT_READY\n");
+		return CDW_GEN_ERROR;
+	} else {
+		; /* won't happen, all return values covered */
+		return CDW_GEN_ERROR;
+	}
+}
+
+
+
+
+#endif
+
+
+
+/* from cdw_ext_tools.c */
+
+
+/* *** unused code below *** */
+
+
+
+#if 0
+/**
+   \brief Getter function for getting full path in file system to given tool
+
+   Function returns pointer to string with full path to instance of tool
+   (tool specified by \p tool_id).
+
+   Since there can be several instances of a given tool (tool may be
+   installed in several places), user either chooses one of them in cdw
+   configuration (so that it becomes default path / instance), or accepts
+   default one, preselected by code in this module at startup of application.
+
+   This function returns pointer to this default path.
+
+   You should call this function only when you are sure that given tool
+   is available - use cdw_ext_tools_is_tool_available() first, because
+   this function in release build won't do this for you.
+
+   \param tool_id - id of a tool (as defined in header file)
+
+   \return pointer to string with full path to a tool
+*/
+const char *cdw_ext_tools_get_tool_fullpath_old(enum cdw_tool tool_id)
+{
+	cdw_assert (tool_id >= CDW_TOOL_MKISOFS && tool_id <= CDW_TOOL_MD5SUM,
+		    "ERROR: incorrect tool id: %d\n", tool_id);
+
+	cdw_assert (cdw_tools[tool_id].available,
+		    "ERROR: asked for fullpath of tool \"%s\" that is not available\n",
+		    cdw_tools[tool_id].name);
+
+	size_t ind = 0;
+
+	if (cdw_ext_tools.manual_selection) {
+
+		ind = cdw_tools[tool_id].dd_index;
+
+		if (ind == cdw_tools[tool_id].n_instances) {
+			/* "system default" label is first one in dropdown after
+			   last path to real instance of a tool; system default tool
+			   is usually the first one returned by "which",
+			   and thus it is first one on list of tools */
+			ind = 0;
+			cdw_vdm ("INFO: manually selecting system default tool \"%s\"\n",
+				 cdw_tools[tool_id].labels[ind]);
+
+		} else {
+			/* ind = ind */
+			cdw_vdm ("INFO: manually selecting tool %zd (\"%s\")\n",
+				 ind, cdw_tools[tool_id].labels[ind]);
+		}
+
+		cdw_assert (ind <= cdw_tools[tool_id].n_instances, "ERROR: resolved tool id = %zd is out of range\n", ind);
+		cdw_assert (cdw_tools[tool_id].fullpaths[ind] != (char *) NULL,
+			    "ERROR: full path to \"%s\" tool is null, should be non-null (index = %zd)\n",
+			    cdw_tools[tool_id].name, ind);
+	} else {
+		ind = cdw_ext_tools_select_tool_impl_intelligently(tool_id);
+		cdw_vdm ("INFO: cdw selects tool %zd (\"%s\")\n",
+				 ind, cdw_tools[tool_id].labels[ind]);
+	}
+
+	return cdw_tools[tool_id].fullpaths[ind];
+}
+
+
+
+
+
+/* return index of tool implementation, resolved by immense intelligence of cdw */
+size_t cdw_ext_tools_select_tool_impl_intelligently(__attribute__((unused)) enum cdw_tool tool_id)
+{
+	/* for now it is very simple, but in future selection may
+	   take into account implementation of a tool and
+	   its version (and thus its capabilities or maturity) */
+	return 0;
+}
+
+
+
+
+
+/**
+   \brief Check if "which" tool is available on user's system
+
+   Function checks if "which" tool is available on user's system.
+   It is done by searching "which" in dirs specified in shell variable PATH.
+
+   Function searches for "which" in directories specified in PATH
+   shell variable, so it is pretty much guaranteed that if any "which"
+   will be found, it will be available to the program by only executable name,
+   not necessarily by full path to executable: we will be able to use "which",
+   and not e.g. "/usr/bin/which" when searching for other external tools.
+
+   \return CDW_OK if "which" was found
+   \return CDW_NO if "which" was not found
+   \return CDW_GEN_ERROR when there were some problems with looking for "which"
+   \return CDW_SYS_ERROR if call to getenv() fails (that would mean that there is no "PATH" shell variable)
+*/
+cdw_rv_t cdw_ext_tools_check_which_availability(void)
+{
+	/* getenv() returns NUL-terminated string or NULL */
+	if (getenv("PATH") == (char *) NULL) {
+		cdw_vdm ("ERROR: failed to get \"PATH\" variable\n");
+		return CDW_SYS_ERROR;
+	}
+
+	char *path_table = strdup(getenv("PATH"));
+	size_t len = strlen(path_table);
+	if (len == 0) {
+		cdw_vdm ("ERROR: failed to get \"PATH\" with non-zero length\n");
+		free(path_table);
+		path_table = (char *) NULL;
+		return CDW_GEN_ERROR;
+	}
+
+	char *pt_start = path_table;
+	cdw_vdm ("PATH: \"%s\"\n", path_table);
+
+	size_t i = 0;
+	bool success = false;
+	do {
+		i = strcspn(path_table, ":");
+		len = strlen(path_table);
+		if (i == 0 && len == 0) {
+			/* we reached end of path_table when moving '\0'
+			   more and more to the right, no (more) paths to check  */
+			break;
+		} else if (i == 0 && len > 0) {
+			cdw_assert (0, "ERROR: strcspn() found separator at the beginning of string\n");
+		} else if (i > 0 && len == 0) {
+			cdw_assert (0, "ERROR: strcspn() found separators in empty string\n");
+		} else { /* i > 0 && len > 0,
+			    there is at least one path in PATH, if there are
+			    more (i.e. len - 1 > i) this will cut them out,
+			    but just for this iteration; this creates valid
+			    C string containing only one path, rest of paths
+			    is (potentially) after this '\0' */
+			path_table[i] = '\0';
+		}
+
+		cdw_sdm ("currently processing this path from path table: \"%s\"\n", path_table);
+
+		char *fullpath = cdw_string_concat(path_table, "/which", (char *) NULL);
+		cdw_vdm ("testing path \"%s\"\n", fullpath);
+		int w = access(fullpath, X_OK);
+		free(fullpath);
+		fullpath = (char *) NULL;
+		if (w == 0) {
+			/* we found one "which", no need to search next */
+			success = true;
+			cdw_vdm ("found which in %s\n", path_table);
+			break;
+		} else {
+			/* jump over '\0' that we put in place of ":" to
+			   divide path_table into substrings that were
+			   valid C strings */
+			path_table = path_table + i + 1;
+		}
+	} while (i > 0);
+
+	free(pt_start);
+	pt_start = (char *) NULL;
+
+	if (success) {
+		cdw_ext_tools.tools[CDW_TOOL_WHICH].available = true;
+		return CDW_OK;
+	} else {
+		cdw_ext_tools.tools[CDW_TOOL_WHICH].available = false;
+		cdw_vdm ("ERROR: failed to find \"which\" utility\n");
+		return CDW_NO;
+	}
+}
+
+
+/**
+   \brief Run "which" UNIX tool with names of external tools
+
+   The function calls run_command_which() for every tool in cdw_tools[] table
+   to collect full paths to all instances of every tool and potential target
+   files of links if the full paths turn out to be paths to symbolic links.
+*/
+void cdw_ext_tools_run_which(void)
+{
+	for (int t = 0; t < CDW_N_TOOLS; t++) {
+		CDW_TASK_CREATE_TASK(task, CDW_TASK_WHICH);
+		task.which.searched_tool.id = t;
+		task.which.searched_tool.name = cdw_ext_tools.tools[t].name;
+
+		cdw_which_run_task(&task);
+	}
+
+	return;
+}
+
+
+
+
+/**
+   \brief Assign correct values to fields of cdw_tools[] using results of calls to cdw which utility
+
+   Function checks results of calling cdw "which" utility for every interesting
+   tool (these results being full paths to executables), and assigns correct
+   values to certain fields of variables collected in cdw_tools[].
+
+   Calling first cdw_ext_tools_init_cdw_tools(), then cdw_ext_tools_run_which2()
+   and then cdw_ext_tools_process_which_results() makes cdw_tools[] almost ready
+   for use. What is left to do is to call cdw_ext_tools_error_dialog().
+
+   \return CDW_OK
+*/
+cdw_rv_t cdw_ext_tools_process_which_results(void)
+{
+	for (int t = 0; t < CDW_N_TOOLS; t++) {
+
+		/* cdw_ext_tools_run_which2() has already set correct value
+		   of cdw_ext_tools.tools[t].n_instances for tool t */
+
+		if (cdw_ext_tools.tools[t].n_instances == 0) {
+			cdw_ext_tools.tools[t].available = false;
+			cdw_ext_tools.tools[t].dd.index = 0;
+		} else {
+			cdw_ext_tools.tools[t].available = true;
+			/* this sets "selected by cdw" as default dropdown value */
+			cdw_ext_tools.tools[t].dd.index = cdw_ext_tools.tools[t].n_instances;
+		}
+	}
+
+	/* for debug purposes only */
+#ifndef NDEBUG
+	cdw_vdm ("\n\nexternal tool fullpaths initialized as:\n\n");
+	cdw_ext_tools_print_fullpaths();
+#endif
+
+	return CDW_OK;
+}
+
+#endif
+
+
+
+
+/* *** from cdw_file.c *** */
+
+
+
+/* ************************* */
+/* *** unused code below *** */
+/* ************************* */
+
+
+#if 0
+
+
+
+cdw_file_t *cdw_file_new2(const char *fullpath)
+{
+	cdw_assert (fullpath != (const char *) NULL, "ERROR: fullpath argument is NULL\n");
+
+	cdw_file_t *file = (cdw_file_t *) NULL;
+
+	file = cdw_file_new_base();
+	if (file == (cdw_file_t *) NULL) {
+		cdw_vdm ("ERROR: failed to create new file with cdw_file_new()\n");
+		return (cdw_file_t *) NULL;
+	}
+
+	cdw_string_set(&(file->fullpath), fullpath);
+
+	cdw_rv_t crv = cdw_file_new_sub(file);
+	cdw_assert (crv == CDW_OK, "ERROR: call to cdw_file_new_sub() failed\n");
+
+	return file;
+}
+
+
+
+
+#endif
+
+
+
+
+/* from cdw_file_picker.c */
+
+
+/* *** unused code below *** */
+
+
+#if 0
+/*
+  Function makes sure that path is no longer than allowed
+  on system, on which cdw was compiled (PATH_MAX - 1 chars) */
+cdw_rv_t cdw_fs_ui_get_path(const char *title, const char *message, char **fullpath, int perms, int cdw_file_type, int new_or_existing)
+{
+	/* to avoid overwritting function's argument by incorrect path */
+	char *local_buffer = (char *) NULL;
+	if (!(*fullpath)) {
+		;
+	} else {
+		local_buffer = strdup(*fullpath);
+		if (!local_buffer) {
+			cdw_vdm ("ERROR: failed to allocate local_buffer with strdup()\n");
+			return CDW_GEN_ERROR;
+		}
+	}
+
+	int i = 0;
+	int n = 5;
+	cdw_rv_t crv = CDW_OK;
+	for (i = 0; i < n; i++) {
+		/* input mode = 0, size limit = (PATH_MAX - 1), remember
+		   that value of PATH_MAX includes ending NUL */
+
+		crv = cdw_fs_ui_get_safe_path(title, message, &local_buffer);
+
+		if (crv != CDW_OK) {
+			break; /* user abandoned action */
+		}
+
+		cdw_string_rtrim(local_buffer);
+		if (cdw_file_type == CDW_FS_DIR) {
+			cdw_fs_correct_dir_path_ending(&local_buffer);
+		}
+
+		crv = cdw_fs_ui_get_path_check(local_buffer, cdw_file_type, perms, new_or_existing);
+
+		/* CDW_OK: accept the path from local_buffer and put it in caller's buffer,
+		   CDW_CANCEL: disregard path from local_buffer, don't modify caller's buffer */
+		if (crv == CDW_OK || crv == CDW_CANCEL) {
+			break;
+		} else if (crv == CDW_NO) {
+			; /* don't overwrite current file, loop */
+		} else {
+			/* loop, even in case of errors */
+			cdw_vdm ("ERROR: failed at checking path, but perhaps will try again\n");
+		}
+	}
+	if (crv == CDW_OK) {
+		crv = cdw_string_set(fullpath, local_buffer);
+		if (crv != CDW_OK) {
+			cdw_vdm ("ERROR: failed to set result path with cdw_string_set()\n");
+		}
+	}
+
+	if (local_buffer) {
+		free(local_buffer);
+		local_buffer = (char *) NULL;
+	}
+
+	if (crv == CDW_OK || crv == CDW_CANCEL) {
+		return crv;
+	} else {
+		cdw_vdm ("ERROR: failed to get correct path\n");
+		return CDW_GEN_ERROR;
+	}
+}
+
+
+
+
+
+cdw_rv_t cdw_fs_ui_get_path_check(char *fullpath, int cdw_file_type, int perms, int new_or_existing)
+{
+	int rv = cdw_fs_check_existing_path(fullpath, perms, cdw_file_type);
+
+	if (new_or_existing == CDW_FS_NEW) {
+		cdw_vdm ("strerror(CDW_FS_NEW): \"%s\"\n", strerror(rv));
+
+		if (rv == ENOENT) {
+			/* file does not exist, which is ok in this case */
+			return CDW_OK;
+		} else if (rv == 0) {
+			/* file exists, and in this case it is an incorrect
+			   situation (but not an application error) */
+			return cdw_fs_errno_handler(EEXIST);
+		} else {
+			/* a real problem with path or system error */
+			cdw_vdm ("ERROR: failed to check path, strerror = \"%s\"\n", strerror(rv));
+			cdw_fs_errno_handler(rv);
+			return CDW_GEN_ERROR;
+		}
+	} else if (new_or_existing == CDW_FS_EXISTING) {
+		cdw_vdm ("strerror(CDW_FS_EXISTING): \"%s\"\n", strerror(rv));
+
+		if (rv == ENOENT) {
+			/* cdw_dialogbox("Error", "File does not exist, try again",
+				      DIALOG_OK, CDW_COLORS_ERROR);
+				      return CDW_GEN_ERROR; */
+			cdw_sys_errno_handler(ENOENT);
+			return CDW_GEN_ERROR;
+		} else if (rv == 0) {
+			/* file does exist, so this is as intended,
+			   so don't warn user about possible overwrite */
+			return CDW_OK;
+		} else {
+			/* a real problem with path or system error */
+			cdw_vdm ("ERROR: failed to check path, strerror = \"%s\"\n", strerror(rv));
+			cdw_fs_errno_handler(rv);
+			return CDW_GEN_ERROR;
+		}
+	} else if (new_or_existing == (CDW_FS_NEW | CDW_FS_EXISTING)) {
+		cdw_vdm ("strerror(CDW_FS_NEW | CDW_FS_EXISTING): \"%s\"\n", strerror(rv));
+
+		if (rv == ENOENT) {
+			/* file does not exist, so it is as intended, and
+			   we have nothing to warn about */
+			return CDW_OK;
+		} else if (rv == 0) {
+			/* file does exist, so this is as intended,
+			   but here we have to warn user about possible
+			   overwrite because this is "new OR existing" */
+			cdw_rv_t crv = cdw_fs_errno_handler(EEXIST);
+			cdw_vcrv ("cdw_fs_errno_handler", crv);
+			return crv;
+		} else {
+			/* a real problem with path or system error */
+			cdw_vdm ("ERROR: failed to check path, strerror = \"%s\"\n", strerror(rv));
+			cdw_fs_errno_handler(rv);
+			return CDW_GEN_ERROR;
+		}
+	} else {
+		cdw_vdm ("ERROR: you are searching for path to file that is neither new, nor existing\n");
+		return CDW_GEN_ERROR;
+	}
+}
+
+
+
+
+
+cdw_rv_t cdw_fs_ui_get_safe_path(const char *title, const char *message, char **buffer)
+{
+	cdw_safe_input_data_t data;
+
+	data.attempts_max = 3; /* how many attempts? */
+	data.window_title = title;   /* title of input window */
+	data.prompt_message = message; /* message in input window */
+	data.input_type = CDW_NCURSES_INPUT_NONE;
+	data.chars_max = PATH_MAX - 1;    /* maximal length of string */
+	data.buffer = buffer;
+
+	/* error message displayed at the end in case of failure */
+	/* 2TRANS: this is error message displayed in dialog window
+	   when getting a filesystem path from user failed */
+	data.error_message = _("Can't get valid path, aborting.");
+
+	cdw_rv_t crv = cdw_safe_input_dialog(&data);
+
+	return crv;
+}
+
+
+#endif
+
+
+/* from cdw_main_window.c */
+
+
+/* *** unused code below *** */
+
+
+#if 0
+
+
+/**
+   \brief Re-read and display optical disc information, show it in text window if required
+
+   Read meta-information form optical disc that is currently in drive
+   and display summary in 'Disc info' area of ui.
+
+   \return CDW_OK if media info was read properly
+   \return CDW_NO if media info was not read properly
+*/
+cdw_rv_t cdw_main_ui_disc_info_view_update(void)
+{
+	cdw_disc_current_disc_reset();
+	cdw_disc_t *current_disc = cdw_disc_get();
+	cdw_main_ui_disc_info_view_display_data(current_disc);
+
+	const char *drive = cdw_drive_get_drive_fullpath();
+	if (cdw_drive_is_disc_in_drive(drive)) {
+		cdw_rv_t m = cdw_fs_check_device_mounted(drive);
+		if (m == CDW_SYS_ERROR) {
+			; /* let's try anyway */
+		} else if (m == CDW_OK) { /* device is mounted */
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window */
+					   _("Cannot check media. Please unmount your drive."),
+					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+			return CDW_NO;
+		} else { /* crv == CDW_NO, not mounted */
+			;
+		}
+		cdw_rv_t mi = cdw_disc_get_meta_info(true);
+
+		/* get_meta_info() may fail only partially; display what you can */
+		cdw_main_ui_disc_info_view_display_data(current_disc);
+
+		if (mi != CDW_OK) {
+			/* 2TRANS: this is title of dialog window */
+			cdw_buttons_dialog(_("Error"),
+					   /* 2TRANS: this is message in dialog window */
+					   _("Cannot get media info. Consult log file ('L' hotkey in main window)."),
+					   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+			return CDW_NO;
+		} else {
+			return CDW_OK;
+		}
+	} else {
+		/* WARNING: it is an problematic thing to expose "disc_type"
+		   field in this place and to use cdw_disc_current_disc_resolve(),
+		   which should be static in cdw_disc.c */
+		current_disc->type = CDW_DISC_NONE;
+		cdw_disc_resolve(current_disc);
+		cdw_main_ui_disc_info_view_display_data(current_disc);
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Cannot show disc info. No disc in drive."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return CDW_NO;
+	}
+}
+
+
+#endif
+
+
+
+
+
+/* from cdw_ncurses.c */
+
+
+
+/* *** unused code below *** */
+
+#if 0
+
+
+/**
+ * \brief Create new editable ncurses field that will be used as input field
+ *
+ * Create 1xX input field that will be used in a page as text input field.
+ *
+ * \param height - height of the label
+ * \param width - width of the label
+ * \param y - row in which the field will be put
+ * \param x - column in which the field will be put
+ * \param buffer_content - text that will be used as value of the label
+ *
+ * \return field - newly created field
+ */
+FIELD *cdw_input_field_new(size_t n_lines, size_t n_cols, size_t begin_y, size_t begin_x, const char *init_string, size_t len_max)
+{
+	FIELD *field = cdw_ncurses_new_input_field(n_lines, n_cols,
+						   begin_y, begin_x,
+						   init_string == (char *) NULL ? "" : init_string, len_max,
+						   CDW_NCURSES_INPUT_NONE,
+						   CDW_COLORS_INPUT);
+	if (field == (FIELD *) NULL) {
+		cdw_vdm ("ERROR: failed to create new field\n");
+		return (FIELD *) NULL;
+	} else {
+		return field;
+	}
+}
+
+#endif
+
+
+
+/* from cdw_widgets.c */
+
+
+/* *** unused code below *** */
+
+#if 0
+
+/**
+   \brief Widget allowing to enter simple string value
+
+   Display widget with title and label, allowing user to enter simple
+   value, like name, path or number. This is wrapper around wrapper
+   around curses WINDOW window + FORM field.
+
+   See cdw_one_line_form() for details on \p buffer, \p input_type and \p limit.
+
+   The function itself does not modify \p buffer. All modifications come
+   from cdw_one_line_form().
+
+   The string returned in \p buffer on success is ended with '\0'. Note
+   that empty string ("") is treated as correct user input (as long as
+   \p input_type is not set to any CDW_FIELD_TYPE* value).
+
+   \param title - title of a window
+   \param message - information displayed in the window; a prompt
+   \param buffer - pointer to buffer with data
+   \param input_type - mode of work of input field
+   \param limit - maximal length of data that user can enter into a field
+
+   \return CDW_OK if user pressed CDW_KEY_ENTER and data was validated correctly (if validation was required)
+   \return CDW_CANCEL if user pressed CDW_KEY_ESCAPE
+   \return CDW_ARG_ERROR if user entered data of incorrect type (if type was required by setting \p input_type)
+   \return CDW_GEN_ERROR on any other error
+*/
+cdw_rv_t cdw_unsafe_input_dialog(const char *title, const char *message, char **buffer, int input_type, size_t limit)
+{
+	CDW_DIALOG_BASE *dialog = cdw_dialog_base_new(CDW_DIALOG_INPUT, input_type);
+	if (!dialog) {
+		return CDW_GEN_ERROR;
+	}
+	dialog->input.limit = limit;
+
+	cdw_dialog_base_calculate_sizes(dialog, message);
+	cdw_dialog_base_display_basics(dialog, title, message, CDW_ALIGN_LEFT);
+
+	size_t n_rows = 1;
+	size_t n_cols = dialog->input.n_cols;
+	if (dialog->input.limit) {
+		if (n_cols > dialog->input.limit) {
+			/* input subwindow must be no wider than limit,
+			   otherwise setting size limit for input buffer
+			   will fail */
+			n_cols = dialog->input.limit;
+		}
+	}
+
+	size_t begin_x = ((size_t) getmaxx(dialog->window) - n_cols) / 2;
+	WINDOW *subwindow = derwin(dialog->window, (int) n_rows, (int) n_cols, (int) begin_y, (int) begin_x);
+	if (subwindow == (WINDOW *) NULL) {
+		cdw_vdm ("ERROR: failed to create inputbox input subwindow\n");
+		return CDW_GEN_ERROR;
+	}
+
+	keypad(subwindow, TRUE);
+	wrefresh(subwindow);
+
+	cdw_rv_t crv = cdw_one_line_form(dialog->window, subwindow, buffer, CDW_NCURSES_INPUT_NONE, limit);
+
+	delwin(subwindow);
+	subwindow = (WINDOW *) NULL;
+
+	int begx, begy, maxx, maxy;
+	getbegyx(dialog->window, begy, begx);
+	getmaxyx(dialog->window, maxy, maxx);
+	cdw_main_ui_main_window_wrefresh_part((size_t) maxy, (size_t) maxx, (size_t) begy, (size_t) begx);
+
+	cdw_dialog_base_delete(&dialog);
+
+	if (crv == CDW_MEM_ERROR){
+		cdw_vdm ("ERROR: failed to get proper return value from one line input, crv = %d\n", crv);
+		crv = CDW_GEN_ERROR;
+	}
+
+	return crv;
+}
+
+
+
+
+/**
+   \brief Small, one-line editable text area
+
+   This is wrapper around single curses FORM field. It is displayed in window,
+   which has to be prepared by caller. The window must be one row high.
+
+   \p window is a parent window of \p subwidow
+
+   \p subwindow is ncurses window created and initialized by caller. Its height
+   must be 1. If \p limit is non-zero, width of \window must be no larger than
+   value of \p limit, otherwise setting limit of widget's buffer will fail.
+
+   \p buffer is a pointer to memory where data entered by user will be stored.
+   It will be realloc()ed if necessary. Content of the buffer will be updated
+   by the function only when user presses ENTER and (if validation is
+   requested) field content is valid. Validation is performed when field type
+   is set using \p input_type parameter. Data in \p buffer will be ended with '\0'.
+
+   \p input_type controls the widget. Two ORed values are recognized:
+   CDW_INPUT_HIDDEN and (CDW_INPUT_INTEGER or CDW_INPUT_NUMERIC). Using
+   first makes the widget not to display entered characters, second
+   forces the widget to validate data as of type 'integer', third is
+   numeric data, possibly with decimal point. If input type was set to
+   CDW_INPUT_INTEGER or CDW_INPUT_NUMERIC, then data is validated before
+   copying it to \p buffer and returning. If validation fails CDW_ARG_ERROR
+   is returned and \p buffer is not modified. Set \p input_type to zero or
+   CDW_INPUT_NONE you don't want to set any input type.
+
+   \p limit is maximal amount of chars that can be entered in field and stored
+   in \p buffer. The value does not include ending '\0'. Set \p limit to zero
+   if you don't want to restrict size of entered data. Set \p limit to
+   value > 0 if data entered by user is required to be no longer than \p limit.
+
+   Note that empty string ("") is treated as correct user input if \p input_type
+   is not set to any CDW_INPUT_* value.
+
+   \param window - parent window of subwindow
+   \param subwindow - ncurses window to be used as widget area;
+   \param buffer - pointer to buffer where value entered by user is stored
+   \param input_type - mode of work of input field
+   \param limit - maximal number of chars of data entered by user
+
+   \return CDW_OK if user pressed CDW_KEY_ENTER and data was validated as correct (if validation was required)
+   \return CDW_CANCEL if user pressed CDW_KEY_ESCAPE
+   \return CDW_ARG_ERROR if validation of value entered by user was requested and value is invalid
+*/
+cdw_rv_t cdw_one_line_form(WINDOW *window, WINDOW *subwindow, char **buffer, int input_type, size_t limit)
+{
+	cdw_assert (window != (WINDOW *) NULL, "ERROR: cannot operate on NULL window\n");
+	cdw_assert (subwindow != (WINDOW *) NULL, "ERROR: cannot operate on NULL subwindow\n");
+
+	int both = CDW_NCURSES_INPUT_NUMERIC | CDW_NCURSES_INPUT_INTEGER;
+	cdw_assert ((input_type & both) != both, "ERROR: you should settle on only one CDW_NCURSES_INPUT* value\n");
+
+	int n_cols = getmaxx(subwindow);
+	int n_rows = getmaxy(subwindow);
+
+	cdw_assert (n_rows == 1, "ERROR: incorrect number of rows in subwindow, should be 1, is %d\n", n_rows);
+	if (limit > 0) {
+		/* this condition must be met: calling set_max_field() to
+		   set limit for input field that has width larger than limit
+		   returns E_BAD_ARGUMENT */
+		cdw_assert (n_cols <= (int) limit, "ERROR: width of widget window is larger than limit: %d > %zd\n", n_cols, limit);
+	}
+	cdw_sdm ("INFO: width = %d, limit = %d\n", n_cols, limit);
+
+	FIELD *field[2];
+	field[1] = (FIELD *) NULL; /* obligatory ending element */
+	field[0] = cdw_ncurses_new_input_field(1, (size_t) n_cols, /* n_lines, n_cols */
+					       0, 0,               /* begin_y, begin_x */
+					       *buffer, limit,
+					       input_type, CDW_COLORS_INPUT);
+
+	FORM *form = cdw_form_new_form(window, subwindow, field);
+	if (form == (FORM *) NULL) {
+		cdw_vdm ("ERROR: failed to create form with new_form()\n");
+		free_field(field[0]);
+		field[0] = (FIELD *) NULL;
+		return CDW_GEN_ERROR;
+	}
+	int r = set_current_field(form, field[0]);
+	if (r != E_OK) {
+		cdw_vdm ("ERROR: failed to set current field with set_current_field(), error code is \"%s\"\n", cdw_ncurses_error_string(r));
+		return CDW_GEN_ERROR;
+	}
+	r = form_driver(form, REQ_BEG_LINE);
+	if (r != E_OK) {
+		cdw_vdm ("ERROR: failed in form_driver(), error code is \"%s\"\n", cdw_ncurses_error_string(r));
+		return CDW_GEN_ERROR;
+	}
+	wrefresh(subwindow);
+
+	curs_set(1);
+
+	/* now user can enter data */
+	int validation_result = E_OK;
+	int ch = cdw_one_line_form_driver(form, &validation_result, false);
+
+	if (input_type == CDW_NCURSES_INPUT_NONE) {
+		validation_result = E_OK;
+	}
+
+	curs_set(0);
+
+	cdw_rv_t ret_val = CDW_OK;
+	if (ch == CDW_KEY_ENTER) {
+		if (validation_result == E_OK) {
+			/* all that can go wrong at this point is malloc()
+			   failure - return value will be CDW_GEN_ERROR */
+			ret_val = cdw_ncurses_get_field_buffer(field[0], buffer, limit);
+			if (ret_val != CDW_OK) {
+				cdw_vdm ("ERROR: failed to get field buffer with cdw_ncurses_get_field_buffer()\n");
+				ret_val = CDW_GEN_ERROR;
+			}
+		} else if (validation_result == E_INVALID_FIELD) {
+			/* invalid form content */
+			ret_val = CDW_ARG_ERROR;
+			cdw_vdm ("ERROR: failed to get field buffer (arg error)\n");
+		} else {
+			/* some other error, but we won't inspect it */
+			cdw_vdm ("ERROR: failed to get field buffer (gen error)\n");
+			ret_val = CDW_GEN_ERROR;
+		}
+	} else if (ch == CDW_KEY_ESCAPE) {
+		ret_val = CDW_CANCEL;
+	} else {
+		ret_val = CDW_CANCEL;
+		cdw_assert (0, "ERROR: incorrect key %d\n", ch);
+	}
+
+	/* clean up */
+	/* IMPORTANT: for some reason you have first free fields
+	   and then unpost and free form */
+	free_field(field[0]);
+	unpost_form(form);
+	field[0] = (FIELD *) NULL;
+
+	free_form(form);
+	form = (FORM *) NULL;
+
+	return ret_val;
+}
+
+
+
+
+
+/**
+   \return CDW_KEY_ENTER if user pressed Enter key
+   \return CDW_KEY_TAB ('\t') if user pressed Tab key
+   \return CDW_KEY_ESCAPE if user pressed Escape key
+   \return KEY_EXIT on errors
+*/
+int cdw_input_line_driver(CDW_INPUT_LINE *input_line, char **buffer)
+{
+	curs_set(1);
+
+	int validation_result = E_OK;
+	int key = cdw_one_line_form_driver(input_line->form, &validation_result, true);
+
+	if (input_line->input_type == CDW_NCURSES_INPUT_NONE) {
+		validation_result = E_OK;
+	}
+
+	curs_set(0);
+
+	if (key == CDW_KEY_ENTER
+	    || (key == CDW_KEY_TAB && input_line->save_data_on_tab)) {
+
+		if (validation_result == E_OK) {
+			/* all that can go wrong at this point is malloc()
+			   failure - return value will be CDW_GEN_ERROR */
+			cdw_rv_t crv = cdw_ncurses_get_field_buffer(input_line->field[0], buffer, (size_t) input_line->chars_max);
+			if (crv != CDW_OK) {
+				cdw_vdm ("ERROR: failed to get field buffer with cdw_ncurses_get_field_buffer()\n");
+				key = KEY_EXIT;
+			} else {
+				; /* key = key */
+			}
+		} else if (validation_result == E_INVALID_FIELD) {
+			/* invalid form content */
+			cdw_vdm ("ERROR: failed to get field buffer (arg error)\n");
+			key = KEY_EXIT;
+		} else {
+			/* some other error, but we won't inspect it */
+			cdw_vdm ("ERROR: failed to get field buffer (gen error)\n");
+			key = KEY_EXIT;
+		}
+
+	} else if (key == CDW_KEY_ESCAPE) {
+		;
+	} else if (key == CDW_KEY_TAB) {
+		;
+	} else {
+		key = KEY_EXIT;
+		cdw_assert (0, "ERROR: incorrect key from one line form driver: %d\n", key);
+	}
+
+	return key;
+}
+
+
+
+
+
+/**
+   \brief Simple dropdown list
+
+   Dropdown list displayed in parent window at position (begin_y, begin_x)
+   with item names taken from item_labels.
+
+   \p parent is required, because position of dropdown is relative
+   to this window. Parent is also refreshed in this function.
+
+   \p item_labels must end with (char *) NULL element.
+
+   Note that \p item_labels is owned by caller all the time.
+   Argument \p current_item_ind can be used to set value initially highlighted
+   when dropdown is created
+
+   \param parent - window in which the dropdown will be displayed
+   \param begin_y - y position of dropdown, relative to begin_y of parent window
+   \param begin_x - x position of dropdown, relative to begin_x of parent window
+   \param width - width of dropdown
+   \param item_labels - list of (char *) strings that will be used as dropdown item names.
+   \param current_item_ind - list item that has to be initially selected, zero-based
+   \param colors - color scheme of dropdown
+
+   \return pointer to dropdown widget if success
+   \return NULL if creating dropdown failed
+*/
+CDW_DROPDOWN *cdw_dropdown_new(WINDOW *parent, int begin_y, int begin_x, int width, const char **item_labels, int current_item_ind, cdw_colors_t colors)
+{
+	cdw_assert (parent != (WINDOW *) NULL, "ERROR: parent window is NULL\n");
+
+	CDW_DROPDOWN *dropdown = (CDW_DROPDOWN *) malloc(sizeof(CDW_DROPDOWN));
+	if (dropdown == (CDW_DROPDOWN *) NULL) {
+		return (CDW_DROPDOWN *) NULL;
+	}
+	dropdown->new_style = false;
+
+	dropdown->labels = item_labels;
+	dropdown->parent = parent;
+	dropdown->current_item_ind = current_item_ind;
+
+        cdw_sdm ("INFO: setting dropdown->current_item_ind to %d\n", dropdown->current_item_ind);
+	dropdown->begin_y = begin_y;
+	dropdown->begin_x = begin_x;
+	dropdown->width = width;
+	dropdown->colors = colors;
+
+	dropdown->n_items = 0;
+	dropdown->visible = true;
+
+	for (dropdown->n_items = 0; (dropdown->labels)[dropdown->n_items] != NULL; dropdown->n_items++) {
+		cdw_vdm ("INFO: label #%d = \"%s\"\n", dropdown->n_items, dropdown->labels[dropdown->n_items]);
+	}
+	cdw_assert (dropdown->n_items > dropdown->current_item_ind,
+		    "ERROR: index of initial item #%d is larger than number of items in list (%d)\n",
+		    dropdown->current_item_ind, dropdown->n_items);
+
+	cdw_vdm ("(newline)\n");
+	cdw_sdm ("INFO: labels[n_items] breaks at n_items = %zd\n", dropdown->n_items);
+
+	/* the loop above breaks on NULL element, so n_items == number of real, non-NULL items */
+
+	/* standard code creating ITEM elements */
+	dropdown->menu_items = (ITEM **) calloc((size_t) dropdown->n_items + 1, sizeof(ITEM *));
+	if (dropdown->menu_items == (ITEM **) NULL) {
+		free(dropdown);
+		dropdown = (CDW_DROPDOWN *) NULL;
+		return (CDW_DROPDOWN *) NULL;
+	}
+
+	for (int i = 0; i < dropdown->n_items; i++) {
+		dropdown->menu_items[i] = new_item(dropdown->labels[i], "");
+	}
+	dropdown->menu_items[dropdown->n_items] = (ITEM *) NULL;
+
+	/* standard code creating MENU element */
+	dropdown->menu = new_menu(dropdown->menu_items);
+	dropdown->parent_x = getbegx(dropdown->parent);
+	dropdown->parent_y = getbegy(dropdown->parent);
+	/* menu should be displayed between opening and closing bracket,
+	   so it should be narrower than 'width' and moved a bit right */
+	dropdown->menu_window = newwin(dropdown->n_items, dropdown->width - 2,
+				       dropdown->parent_y + dropdown->begin_y,
+				       dropdown->parent_x + dropdown->begin_x + 1);
+	set_menu_win(dropdown->menu, dropdown->menu_window);
+	dropdown->menu_window_sub = derwin(dropdown->menu_window, dropdown->n_items, dropdown->width - 2, 0, 0);
+	set_menu_sub(dropdown->menu, dropdown->menu_window_sub);
+
+	/* remember that post_menu() displays menu in its subwindow, not on the
+	   screen - you have to call refresh() to make menu visible to user */
+	post_menu(dropdown->menu);
+	cdw_dropdown_make_visible(dropdown);
+
+	return dropdown;
+}
+
+#endif
+
+
+
+/* from cdw_cdll.c */
+
+
+
+/* *** unused code below *** */
+
+
+#if 0
+
+
+/**
+ * \brief Remove all elements from list
+ *
+ * \return CDW_OK
+ */
+cdw_rv_t cdw_cdll_destroy_old(cdw_cdll_t *head)
+{
+	cdw_cdll_t *perm_head = head;
+	do {
+		free(head->prev);
+		head->prev = (cdw_cdll_t *) NULL;
+		head = head->next;
+	} while (head != perm_head);
+
+	head = (cdw_cdll_t *) NULL;
+
+	return CDW_OK;
+}
+
+#endif
+
+
+/* from cdw_config_ui_internals.c */
+
+
+
+
+/* *** unused code below *** */
+
+#if 0
+
+/**
+   \brief Create fields that are shown on "ISO9660" page configuration window
+
+   Create fields that are shown on "ISO9660" page configuration window,
+   including initialization of size and position, set their types, options
+   and appearance. Fields will be initialized with values from \p config.
+
+   \param cdw_form - form page for which the fields will be built
+   \param config - variable holding current configuration
+
+   \return CDW_OK when all fields were created (probably) without problems
+   \return CDW_GEN_ERROR if one of fields was created incorrectly
+*/
+cdw_rv_t page_iso9660_build_fields(cdw_form_t *cdw_form, void *cdw_config, int first_col, int second_col, int width_wide, int width_narrow)
+{
+	cdw_config_t *config = cdw_config;
+	cdw_form->fields = page_iso9660_fields;
+	int ild_width = 5;
+	int rr_width = 15;
+	int iso_image_button_col = first_col + width_wide - 3;
+	cdw_form_descr_t descr[] = {
+		/*     type        begin_y   begin_x       n_cols           n_lines  field enum              data1                                       data2 */
+
+		/* 2TRANS: this is input field label: keep no longer than original; volume id is name of cd visible e.g. in file manager */
+		{ CDW_WIDGET_LABEL,    1,    first_col,       width_narrow - 10,  1,  f_volumeid_l,         _("Volume ID label"),                          0 },
+		{ CDW_WIDGET_INPUT,    1,    second_col - 10, VOLUME_ID_LEN_MAX, 1,  f_volumeid_i,         config->volumeid,              VOLUME_ID_LEN_MAX },
+		/* 2TRANS: this is checkbox label: keep no longer than original; volume id is name of cd visible e.g. in file manager */
+		{ CDW_WIDGET_LABEL,    2,    first_col,   width_narrow,           1,  f_showvol_l,          _("Ask for volume ID"),                        0 },
+		{ CDW_WIDGET_CHECKBOX, 2,    second_col,  0,                    0,  f_showvol_cb,         (void *) NULL,           config->showvol ? 1 : 0 },
+		/* 2TRANS: this is dropdown label: keep no longer than original */
+		{ CDW_WIDGET_LABEL,    3,    first_col,   width_narrow,           1,  f_iso_level_l,        _("ISO level"),                                0 },
+		{ CDW_WIDGET_DROPDOWN, 3,    second_col,  ild_width,             1,  f_iso_level_dd,       dropdown_makers,                              1 },
+		/* 2TRANS: this is checkbox label: keep no longer than original */
+		{ CDW_WIDGET_LABEL,    4,    first_col,   width_narrow,           1,  f_joliet_l,           _("Joliet information"),                       0 },
+		{ CDW_WIDGET_CHECKBOX, 4,    second_col,  0,                     0,  f_joliet_cb,          (void *) NULL,            config->joliet ? 1 : 0 },
+		/* 2TRANS: this is checkbox label: keep no longer than original; you probably want to keep it untranslated */
+		{ CDW_WIDGET_LABEL,    5,    first_col,   width_narrow,           1,  f_rock_ridge_l,       _("Rock Ridge"),                               0 },
+		{ CDW_WIDGET_DROPDOWN, 5,    second_col,  rr_width,              1,  f_rock_ridge_dd,      dropdown_makers,                              2 },
+		/* 2TRANS: this is checkbox label: keep no longer than original */
+		{ CDW_WIDGET_LABEL,    6,    first_col,   width_narrow,           1,  f_joliet_long_l,      _("Long Joliet names"),                        0 },
+		{ CDW_WIDGET_CHECKBOX, 6,    second_col,  0,                     0,  f_joliet_long_cb,     (void *) NULL,       config->joliet_long ? 1 : 0 },
+		/* 2TRANS: this is checkbox label: keep no longer than original */
+		{ CDW_WIDGET_LABEL,    7,    first_col,   width_narrow,           1,  f_follow_symlinks_l,  _("Follow symbolic links"),                    0 },
+		{ CDW_WIDGET_CHECKBOX, 7,    second_col,  0,                     0,  f_follow_symlinks_cb, (void *) NULL,   config->follow_symlinks ? 1 : 0 },
+		/* 2TRANS: this is input field label: keep no longer than original */
+		{ CDW_WIDGET_LABEL,    9,    first_col,   width_wide,      1,  f_iso_image_full_path_l,  _("Path to ISO image file:"),              0 },
+		{ CDW_WIDGET_INPUT,   10,    first_col,   width_wide - 3,  1,  f_iso_image_full_path_i,  config->iso_image_full_path,               0 },
+		/* this fields is created only because there will be a button
+		   here, that I need to be able to navigate to, so string can be empty */
+		{ CDW_WIDGET_BUTTON,  10,    iso_image_button_col, 1,            1,  f_iso_image_full_path_b,  _(">"),                    CDW_COLORS_DIALOG },
+		/* 2TRANS: this is input field label: keep no longer than original;
+		   input field holds options related to boot image for bootable disc */
+		{ CDW_WIDGET_LABEL,   12,    first_col,   width_wide,      1,  f_boot_disc_options_l,   _("Boot disc options (not tested):"),       0 },
+		{ CDW_WIDGET_INPUT,   13,    first_col,   width_wide,      1,  f_boot_disc_options_i,   config->boot_disc_options,                  0 },
+		/* 2TRANS: this is input field label: keep no longer than original; other options passed to program creating ISO image */
+		{ CDW_WIDGET_LABEL,   15,    first_col,   width_wide,      1,  f_omo_l,                 _("Other \"mkisofs\" options:"),            0 },
+		{ CDW_WIDGET_INPUT,   16,    first_col,   width_wide,      1,  f_omo_i,                 config->other_mkisofs_options,              0 },
+		/* guard */
+		{ -1,                  0,    0,           0,                     0,  0,                       (void *) NULL,                              0 } };
+
+	/* the function adds guard at the end of fields */
+	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to convert form description to form\n");
+		return CDW_GEN_ERROR;
+	} else {
+		cdw_form_set_function(cdw_form, f_iso_image_full_path_b, page_iso9660_handle_enter_on_iso_path_button);
+		return CDW_OK;
+	}
+}
+
+
+
+
+
+/**
+   \brief Create fields that are shown on "writing" page configuration window
+
+   Create fields that are shown on "writing" page configuration window,
+   including initialization of size and position, set their types, options
+   and appearance. Fields will be initialized with values from \p config.
+
+   \param cdw_form - form page for which the fields will be built
+   \param config - variable holding current configuration
+
+   \return CDW_OK when all fields were created (probably) without problems
+   \return CDW_GEN_ERROR if one of fields was created incorrectly
+*/
+cdw_rv_t page_writing_build_fields(cdw_form_t *cdw_form, void *cdw_config, int first_col, int second_col, int width_wide, int width_narrow)
+{
+	/* does not include ending '\0' */
+#define PADSIZE_FIELD_LEN_MAX 4
+
+	cdw_config_t *config = cdw_config;
+	cdw_form->fields = page_writing_fields;
+	int sd_width = 10;
+	char pad_size[PADSIZE_FIELD_LEN_MAX + 1];
+	snprintf(pad_size, PADSIZE_FIELD_LEN_MAX + 1, "%d", config->pad_size);
+	size_t erase_mode = config->erase_mode == CDW_ERASE_MODE_FAST ? 1 : 0;
+	int Xs_col = second_col + PADSIZE_FIELD_LEN_MAX;
+
+	cdw_form_descr_t descr[] = {
+		/*     type         begin_y   begin_x       n_cols       n_lines   field enum                   data1                           data2 */
+
+		/* 2TRANS: this is a separator label, below the label there will be options "common" for group of tools */
+		{ CDW_WIDGET_LABEL,     1,    first_col,   width_narrow,       1,  f_general_l,         _("  ---  Common options  ---  "),         0 },
+		/* 2TRANS: this is checkbox label: keep no longer than original; discs can be erased in 'fast' or 'all' mode */
+		{ CDW_WIDGET_LABEL,     2,    first_col,   width_narrow,       1,  f_blank_l,           _("Erase fast"),                           0 },
+		{ CDW_WIDGET_CHECKBOX,  2,    second_col,  1,                 1,  f_blank_cb,          (void *) NULL,                    erase_mode },
+		/* 2TRANS: this is checkbox label: keep no longer than original; "eject" refers to ejecting cd drive tray */
+		{ CDW_WIDGET_LABEL,     3,    first_col,   width_narrow,       1,  f_eject_l,           _("Eject when done"),                      0 },
+		{ CDW_WIDGET_CHECKBOX,  3,    second_col,  1,                 1,  f_eject_cb,          (void *) NULL,         config->eject ? 1 : 0 },
+		/* 2TRANS: this is input field label: keep no longer than original */
+		{ CDW_WIDGET_LABEL,     4,    first_col,   width_narrow,       1,  f_speed_l,           _("Preferred writing speed"),              0 },
+		{ CDW_WIDGET_DROPDOWN,  4,    second_col,  sd_width,          1,  f_speed_dd,          dropdown_makers,                           3 },
+		/* 2TRANS: this is a separator label, below the label there will be options specific for cdrecord */
+		{ CDW_WIDGET_LABEL,     8,    first_col,   width_wide,  1,  f_cdrecord_l,        _(" --- Options for cdrecord --- "),       0 },
+		/* 2TRANS: this is checkbox label: keep no longer than original; "Pad" refers to adding empty data at the end of track */
+		{ CDW_WIDGET_LABEL,     9,    first_col,   width_narrow,       1,  f_pad_l,             _("Pad (recommended)"),                    0 },
+		{ CDW_WIDGET_CHECKBOX,  9,    second_col,  1,                 1,  f_pad_cb,            (void *) NULL,           config->pad ? 1 : 0 },
+		/* the "150" value is selected after small tests with DVD; originally it was 63, which
+		   worked just fine for CDs, but for DVDs it was insufficient;
+		   TODO: the same value is used in code initializing config variable,
+		   so it should be a constant defined in some header */
+		/* 2TRANS: this is checkbox label: keep no longer than original; "Pad" refers to adding empty data at the end of track */
+		{ CDW_WIDGET_LABEL,    10,    first_col,   width_wide,  1,  f_pad_size_l,        _("Pad size (number >= 0, '150' is recommended)"), 0 },
+		{ CDW_WIDGET_INPUT,    11,    second_col,  PADSIZE_FIELD_LEN_MAX,  1,  f_pad_size_i,   pad_size,              PADSIZE_FIELD_LEN_MAX },
+		/* padsize, Xs */
+		/* 2TRANS: do not translate */
+		{ CDW_WIDGET_LABEL,    11,    Xs_col,  1,                     1,  f_pad_size_xl,       _("s"),                                    0 },
+		/* 2TRANS: this is checkbox label: keep no longer than original */
+		{ CDW_WIDGET_LABEL,    12,    first_col,   width_narrow,       1,  f_burnproof_l,       _("Burnproof"),                            0 },
+		{ CDW_WIDGET_CHECKBOX, 12,    second_col,  1,                 1,  f_burnproof_cb,      (void *) NULL,     config->burnproof ? 1 : 0 },
+		/* 2TRANS: this is input field label: keep no longer than original; other options passed to program writing data to cd */
+		{ CDW_WIDGET_LABEL,    13,    first_col,   width_wide,  1,  f_oco_l,             _("Other \"cdrecord\" options:"),          0 },
+		{ CDW_WIDGET_INPUT,    14,    first_col,   width_wide,  1,  f_oco_i,             config->other_cdrecord_options,            0 },
+		/* 2TRANS: this is a separator label, below the label there will be options specific for growisofs */
+		{ CDW_WIDGET_LABEL,    17,    first_col,   width_wide,  1,  f_growisofs_l,       _(" --- Options for growisofs --- "),      0 },
+		/* 2TRANS: this is input field label: keep no longer than original; other options passed to program creating iso image */
+		{ CDW_WIDGET_LABEL,    18,    first_col,   width_wide,  1,  f_ogo_l,             _("Other \"growisofs\" options:"),         0 },
+		{ CDW_WIDGET_INPUT,    19,    first_col,   width_wide,  1,  f_ogo_i,             config->other_growisofs_options,           0 },
+		/* guard */
+		{ -1,                  0,     0,           0,                 0,  0,                   (void *) NULL,                             0 }};
+
+	/* the function adds guard at the end of fields */
+	cdw_rv_t crv = cdw_form_description_to_fields(descr, cdw_form);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to convert form description to form\n");
+		return CDW_GEN_ERROR;
+	} else {
+		field_opts_on(cdw_form->fields[f_pad_size_i], O_STATIC);
+		set_field_just(cdw_form->fields[f_ogo_l], JUSTIFY_LEFT);
+		return CDW_OK;
+	}
+}
+
+
+
+
+
+/* function called when user pressed Enter key on button next
+   to ISO file path, so we need to call file picker, and after closing
+   the picker we need to update content of "iso file path" field if necessary */
+int page_iso9660_handle_enter_on_iso_path_button(void *cdw_form, __attribute__((unused)) void *dummy)
+{
+	cdw_form_t *form = (cdw_form_t *) cdw_form;
+	/* 2TRANS: this is title of window with file picker */
+	cdw_rv_t crv = cdw_fs_ui_file_picker(_("ISO file"),
+					     /* 2TRANS: this is message in file picker
+						window, explaining what file should be
+						selected */
+					     _("Select ISO file"),
+					     &(local_config->iso_image_full_path),
+					     CDW_FS_FILE,
+					     R_OK | W_OK,
+					     CDW_FS_NEW | CDW_FS_EXISTING);
+	if (crv == CDW_OK) {
+		int rv = set_field_buffer(form->fields[f_iso_image_full_path_i], 0, local_config->iso_image_full_path);
+		if (rv != E_OK) {
+			cdw_vdm ("ERROR: failed to set field buffer with string = \"%s\"\n", local_config->iso_image_full_path);
+		} else {
+			form_driver(form->form, REQ_END_LINE);
+		}
+	}
+
+	cdw_main_ui_main_window_wrefresh();
+	cdw_config_window_refresh_page(form->form_id);
+
+	return 'a';
+}
+
+
+
+
+
+/* function called when user pressed Enter key on button next
+   to boot image file path, so we need to call file picker, and after closing
+   the picker we need to update content of "boot file path" field if necessary */
+void page_iso9660_handle_enter_on_boot_path_button(cdw_config_t *config)
+{
+	long int id = CONFIG_PAGE_ID_ISO9660;
+	/* 2TRANS: this is title of window with file picker */
+	cdw_rv_t crv = cdw_fs_ui_file_picker(_("boot image file"),
+					     /* 2TRANS: this is message in file picker
+						window, explaining what file should be
+						selected */
+					     _("Select boot image file"),
+					     &(config->boot_image_path),
+					     CDW_FS_FILE,
+					     R_OK | W_OK,
+					     CDW_FS_NEW | CDW_FS_EXISTING);
+	if (crv == CDW_OK) {
+		int rv = set_field_buffer(c_pages[id].cdw_form->fields[f_boot_image_path_i], 0, config->boot_image_path);
+		if (rv != E_OK) {
+			cdw_vdm ("ERROR: failed to set field buffer with string = \"%s\"\n", config->boot_image_path);
+		} else {
+			form_driver(c_pages[id].cdw_form->form, REQ_END_LINE);
+		}
+	}
+
+	cdw_main_ui_main_window_wrefresh();
+	cdw_config_window_refresh_page(id);
+
+	return;
+}
+
+
+
+
+
+
+
+
+#define N_ISO_LEVEL_ITEMS_MAX 4 /* iso level = 1, 2, 3, 4; id == level */
+static cdw_id_label_t iso_items[N_ISO_LEVEL_ITEMS_MAX] = {
+	/* 2TRANS: do not translate */
+	{ 1,       gettext_noop("1") },
+	/* 2TRANS: do not translate */
+	{ 2,       gettext_noop("2") },
+	/* 2TRANS: do not translate */
+	{ 3,       gettext_noop("3") },
+	/* 2TRANS: do not translate */
+	{ 4,       gettext_noop("4") } };
+
+
+CDW_DROPDOWN *cdw_config_ui_make_iso_level_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	cdw_assert (local_config->iso_level > 0 && local_config->iso_level < 5,
+		    "ERROR: invalid value of iso level: %d\n", local_config->iso_level);
+
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, N_ISO_LEVEL_ITEMS_MAX, iso_items);
+	cdw_dropdown_set_current_item_by_id(dd, (size_t) local_config->iso_level);
+	return dd;
+
+}
+
+
+
+
+
+#define N_ROCK_RIDGE_ITEMS_MAX 3 /* none/useful/full */
+static cdw_id_label_t rr_items[N_ROCK_RIDGE_ITEMS_MAX] = {
+	/* 2TRANS: none = no Rock Ridge extensions */
+	{ 0,       gettext_noop("None") },
+	/* 2TRANS: useful = some values of attributes of file system are set to some more useful values */
+	{ 1,       gettext_noop("Useful") },
+	/* 2TRANS: full = full Rock Ridge extensions */
+	{ 2,       gettext_noop("Full") } };
+
+
+
+CDW_DROPDOWN *cdw_config_ui_make_rock_ridge_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+
+	cdw_assert (local_config->rock_ridge >= CDW_ISO9660_RR_NONE && local_config->rock_ridge <= CDW_ISO9660_RR_FULL,
+		    "ERROR: invalid value of Rock Ridge: %d\n", local_config->rock_ridge);
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, N_ROCK_RIDGE_ITEMS_MAX, rr_items);
+	cdw_dropdown_set_current_item_by_id(dd, (size_t) local_config->rock_ridge);
+
+	return dd;
+}
+
+
+
+
+
+#define N_SPEED_RANGE_ITEMS_MAX 4 /* auto, lowest, middle, highest */
+static cdw_id_label_t speed_items[N_SPEED_RANGE_ITEMS_MAX] = {
+	/* 2TRANS: it means 'speed of writing set automatically' */
+	{ SPEED_RANGE_AUTO,       gettext_noop("auto") },
+	/* 2TRANS: it means 'lowest writing speed available' */
+	{ SPEED_RANGE_LOWEST,     gettext_noop("lowest") },
+	/* 2TRANS: it means 'medium speed of writing' */
+	{ SPEED_RANGE_MIDDLE,     gettext_noop("middle") },
+	/* 2TRANS: it means 'highest writing speed available' */
+	{ SPEED_RANGE_HIGHEST,    gettext_noop("highest") }};
+
+
+
+CDW_DROPDOWN *cdw_config_ui_make_speed_range_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, N_SPEED_RANGE_ITEMS_MAX, speed_items);
+	cdw_dropdown_set_current_item_by_id(dd, local_config->speed_range);
+	cdw_assert (dd != (CDW_DROPDOWN *) NULL, "ERROR: speed range dropdown is NULL\n");
+
+	return dd;
+}
+
+
+
+#endif
+
+
+/* from cdw_cdio.h */
+
+#if 0
+
+
+/**
+   \brief Read tracks from current disc and write them to given file descriptor
+
+   More detailed description is following:
+       cdw_cdio_copy_tracks_to_file()
+   calls for every tracks
+       cdw_cdio_copy_sectors_to_file()
+   to read all tracks from disc.
+
+   This is just a wrapper for one 'for' loop iterating on tracks, one
+   function call inside loop, and some additional stuff.
+
+   \p output_file must be file descriptior for file that is already
+   open for writing.
+
+   \param fd - file descriptor of output file
+
+   \return CDW_OK when all tracks were copied successfully
+   \return CDW_NO when function copied some tracks (but not all) correctly
+   \return CDW_ERROR when function failed to read any track correctly
+*/
+cdw_rv_t cdw_cdio_copy_tracks_to_file(int fd)
+{
+	cdw_assert (disc->open, "ERROR: trying to read from closed disc\n");
+	cdw_assert (fd != -1 && fd != 0, "ERROR: invalid output file: %d\n", fd);
+
+	int failed_tracks = 0;
+
+	cdw_vdm ("INFO: number of tracks on disc to read: %d\n", disc->n_tracks);
+
+	for (track_t t = disc->first_track; t <= disc->last_track; t++) {
+		if (disc->tracks[t].cdw_track_format == CDW_TRACK_BLACK_BOOK_UNKNOWN) {
+			/* 2TRANS: this is message printed to log file;
+			   "Copy" is a name of task of copying track from
+			   CD to hard disc; %d is a track number */
+			cdw_logging_write(_("Copy: skipping track #%d with unknown format\n"), t);
+
+			failed_tracks++;
+			continue;
+		}
+
+		int rv = cdw_cdio_copy_sectors_to_file_sub(disc, t, fd, sectors);
+		cdw_sdm ("INFO track #%d finished with rv = %d\n", t, rv);
+
+		if (rv != 0) {
+			failed_tracks++;
+			cdw_vdm ("  ERROR: failed reading track #%d\n", t);
+			cdw_cdio_copy_print_debug_on_error(rv);
+		}
+	}
+
+	if (failed_tracks == disc->n_tracks) {
+		cdw_vdm ("ERROR: number of tracks read correctly is zero\n")
+		return CDW_ERROR;
+	} else if (failed_tracks < disc->n_tracks && failed_tracks > 0) {
+		cdw_vdm ("WARNING: failed to read correctly %d tracks\n", failed_tracks);
+		return CDW_CANCEL;
+	} else {
+		return CDW_OK;
+	}
+}
+
+
+
+
+
+cdw_rv_t cdw_cdio_open_iso9660_fs(cdw_cdio_t *disc)
+{
+	cdw_assert (cdw_ofs_is_iso(disc->fs.type),
+		    "ERROR: file system type is not ISO\n");
+	disc->fs.fs.iso9660.p_iso = iso9660_open(disc->device_fullpath);
+	if (disc->fs.fs.iso9660.p_iso == (iso9660_t *) NULL) {
+		cdw_vdm ("ERROR: can't open ISO file system on a disc\n");
+		return CDW_ERROR;
+	}
+
+	disc->fs.fs.iso9660.fd = open(disc->device_fullpath, O_RDONLY);
+	if (disc->fs.fs.iso9660.fd == -1) {
+		int e = errno;
+		cdw_vdm ("ERROR: can't open ISO file system on a disc, errno = \"%s\"\n", strerror(e));
+		iso9660_close(disc->fs.fs.iso9660.p_iso);
+		disc->fs.fs.iso9660.p_iso = (iso9660_t *) NULL;
+
+		return CDW_ERROR;
+	}
+
+
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_cdio_get_iso9660_fs_meta_information(cdw_cdio_t *disc)
+{
+	bool read_pvd = iso9660_fs_read_pvd(disc->p_cdio, &(disc->fs.fs.iso9660.pvd));
+	if (!read_pvd) {
+		cdw_vdm ("ERROR: failed to read pvd from a disc\n");
+
+		return CDW_ERROR;
+	}
+
+	char *id = iso9660_get_volume_id(&(disc->fs.fs.iso9660.pvd));
+	if (id == (char *) NULL) {
+		cdw_vdm ("WARNING: can't get volume id from iso9660 file system\n");
+		/* perhaps given file system simply has no volume id? */
+		disc->fs.volume_id[0] = '\0';
+	} else {
+		strncpy(disc->fs.volume_id, id, ISO_MAX_VOLUME_ID);
+		disc->fs.volume_id[ISO_MAX_VOLUME_ID] = '\0';
+		free(id);
+		id = (char *) NULL;
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+static inline long int cdw_cdio_read_sectors(cdw_cdio_t *disc, track_t t, unsigned char *buffer, lsn_t sector, uint32_t n_sectors, int read_mode)
+{
+	const int n_tries = 2; /* two read attempts seem to be reasonable */
+	long int rv = 0;
+	for (int i = 0; i < n_tries; i++) {
+		if (disc->tracks[t].cdw_track_format == CDW_TRACK_RED_BOOK_AUDIO) {
+			rv = cdio_read_audio_sectors(disc->p_cdio, buffer, sector, n_sectors);
+		} else if (disc->tracks[t].cdw_track_format == CDW_TRACK_DVD) {
+
+#ifndef CDW_CDIO_USE_ISO9660_READ
+			/* this special case for DVDs is important:
+			   cdio_read_data_sectors() pays attention to
+			   disc->tracks[t].last_sector, which may not
+			   mark the real end of ISO volume on DVDs.
+			   This is why it is better to use
+			   iso9660_iso_seek_read() rather than
+			   cdio_read_data_sectors() for DVDs */
+			/* UNFORTUNATELY, iso9660_iso_seek_read() fails
+			   for ISO volumes larger than 2^32 bytes :( */
+			rv = iso9660_iso_seek_read(disc->ofs->cdio_iso, (void *) buffer,
+						   sector, (long int) n_sectors);
+#else
+			rv = read(disc->ofs->fd, (void *) buffer, disc->tracks[t].sector_size * n_sectors);
+			if (rv == -1) {
+				int e = errno;
+				cdw_vdm ("ERROR: fd = %d, errno = \"%s\"\n", disc->ofs->fd, strerror(e));
+				break; /* no re-reads when using read(); */
+			}
+#endif
+
+		} else { /* data CD */
+			/* track-dependent sector size + universal read() function */
+			rv = cdio_read_data_sectors(disc->p_cdio, buffer, sector,
+						    disc->tracks[t].sector_size, n_sectors);
+		}
+		if (rv >= 0) {
+			/* success */
+			if (i > 0) {
+				cdw_vdm ("INFO: success in attempt #%d\n", i);
+			}
+			break;
+		} else {
+			int e = errno;
+			cdw_vdm ("ERROR: failed at read attempt #%d\n", i);
+			cdw_vdm ("ERROR: sector #%d: %d / \"%s\" / %ld / \"%s\"\n",
+				 sector, e, strerror(e), rv, cdw_cdio_get_driver_error_label(rv));
+		}
+	}
+
+	return rv;
+}
+
+
+void cdw_cdio_debug_print(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get information about disc that is not open\n");
+	cdw_vdm ("INFO: disc simple type is %s\n", disc->simple_type_label);
+
+	if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+		if (disc->mode == CDIO_DISC_MODE_CD_DATA) {
+			cdw_vdm ("INFO: disc is CDIO_DISC_MODE_CD_DATA\n");
+		} else if (disc->mode == CDIO_DISC_MODE_CD_XA) {
+			cdw_vdm ("INFO: disc is CDIO_DISC_MODE_CD_XA\n");
+		} else if (disc->mode == CDIO_DISC_MODE_CD_DA) {
+			cdw_vdm ("INFO: disc is CDIO_DISC_MODE_CD_DA\n");
+		} else {
+			cdw_vdm ("INFO: disc is CD / UNKNOWN\n");
+		}
+	}
+
+	cdw_vdm ("INFO: tracks: first / last / unknown / total: %d / %d / %d / %d\n",
+		 disc->first_track, disc->last_track, disc->unknown_tracks, disc->n_tracks);
+
+	if (disc->n_tracks > 0) {
+		if (disc->unknown_tracks == disc->n_tracks) {
+			cdw_vdm ("ERROR: there are %d / %d unknown tracks\n",
+				 disc->unknown_tracks, disc->n_tracks);
+		} else if (disc->unknown_tracks > 0
+			   && disc->unknown_tracks < disc->n_tracks) {
+			cdw_vdm ("WARNING: there are %d / %d unknown tracks\n",
+				 disc->unknown_tracks, disc->n_tracks);
+
+		} else {
+			;
+		}
+	}
+
+	for (int t = disc->first_track; t <= disc->n_tracks; t++) {
+		cdw_vdm ("INFO: track #%d: format: \"%s\", size: %d, fs: \"%s\"\n",
+			 t,
+			 track_format_data[disc->tracks[t].cdw_track_format].cdw_track_format_label,
+			 disc->tracks[t].n_sectors_to_read,
+			 cdw_ofs_fs_label(disc->tracks[t].fs.cdio_fs));
+	}
+	return;
+}
+
+
+
+
+const char *cdw_cdio_get_fs_type_label(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get data from closed disc\n");
+	return cdw_ofs_short_label(disc->ofs->type);
+}
+
+
+
+
+cdio_fs_t cdw_cdio_get_fs_type(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get data from closed disc\n");
+	return disc->ofs->type;
+}
+
+
+
+
+
+const char *cdw_cdio_get_volume_id(cdw_cdio_t *disc)
+{
+	return disc->ofs->volume_id;
+}
+
+
+
+
+
+long int cdw_cdio_get_fs_n_sectors(cdw_cdio_t *disc)
+{
+	return disc->ofs->n_sectors;
+}
+
+
+
+
+cdw_ofs_t *cdw_cdio_ofs_ref(cdw_cdio_t *disc)
+{
+	return disc->ofs;
+}
+
+
+
+
+
+cdw_disc_simple_type_t cdw_cdio_get_simple_type(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get information about disc that is not open\n");
+	cdw_assert (disc->simple_type != CDW_DISC_SIMPLE_TYPE_UNKNOWN,
+		    "ERROR: trying to get simple disc type when it is set to CDW_DISC_SIMPLE_TYPE_UNKNOWN\n");
+
+	return disc->simple_type;
+}
+
+
+
+
+
+discmode_t cdw_cdio_get_disc_mode(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get information about disc that is not open\n");
+	return disc->mode;
+}
+
+
+
+
+
+track_t cdw_cdio_get_first_track_number(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get information about disc that is not open\n");
+	return disc->first_track;
+}
+
+
+
+
+
+bool cdw_cdio_is_blank(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get information about disc that is not open\n");
+	return disc->blank;
+}
+
+
+
+
+
+track_t cdw_cdio_get_first_track(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get information about disc that is not open\n");
+	return disc->first_track;
+}
+
+
+
+
+
+track_t cdw_cdio_get_last_track(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get information about disc that is not open\n");
+	return disc->last_track;
+}
+
+
+
+
+
+track_t cdw_cdio_get_number_of_tracks(cdw_cdio_t *disc)
+{
+	cdw_assert (disc->open, "ERROR: trying to get information about disc that is not open\n");
+	return disc->n_tracks;
+}
+
+
+
+
+
+#endif
+
+
+
+
+/* cdw_string.c */
+
+/**
+   \brief Calculate number of lines of given text when wrapping
+
+   Sometimes it may be necessary to not to wrap a text in \p buffer,
+   but only to know how many logical lines the text would occupy (after
+   wrapping it with given width as a constraint).
+
+   The function does just that: it counts logical lines of text in
+   \p buffer, without actually modifying the buffer.
+
+   \param buffer - buffer text with message to be wrapped
+   \param len_max - maximal length of line in wrapped text
+
+   \return number of lines in wrapped buffer
+*/
+int cdw_string_wrap_count(const char *buffer, int len_max)
+{
+	cdw_assert (buffer != (char *) NULL, "ERROR: cannot operate on NULL buffer\n");
+
+	char *tmp = strdup(buffer);
+	cdw_assert (tmp != (char *) NULL, "ERROR: failed to strdup buffer \"%s\"\n", buffer);
+
+#if 0
+	/* debug code */
+	cdw_vdm ("INFO: width = %d, control string is this:\n", len_max);
+	for (size_t i = 0; i < len_max; i++) {
+		fprintf(stderr, "o");
+	}
+	fprintf(stderr, "\n");
+#endif
+
+	int n_lines = cdw_string_wrap(tmp, len_max);
+
+	free(tmp);
+	tmp = (char *) NULL;
+
+	return n_lines;
+}
+
+
+
+
+
+/**
+   \brief Wrap text from given text buffer
+
+   Put line breaks in text stored in \p buffer so that the text
+   lines aren't longer than \p width.
+   Line breaks will occur on word boundaries. Newline characters
+   ('\n') will be observed.
+
+   Function modifies \p buffer (by replacing some of
+   white characters with newline), but does not reallocate it.
+
+   Function results number of logical lines in modified buffer.
+
+   You can use the function e.g. to prepare a string for displaying
+   it in a window with text wrapped at word boundaries (instead of
+   wrapping it at constant point equal to maximal width).
+
+   \param buffer - buffer with text to wrap
+   \param len_max - maximal length of line in wrapped text
+
+   \return number of lines in resulting buffer
+*/
+int cdw_string_wrap(char *buffer, int len_max)
+{
+	cdw_assert (len_max > 5, "ERROR: maximal width is far too small\n");
+	cdw_assert (buffer != (char *) NULL, "ERROR: text to wrap is NULL\n");
+
+	int len = (int) strlen(buffer);
+
+	/* The idea is to introduce line breaks ('\n') in proper places
+	   of message so there is no substring longer than given width.
+	   Splitting message into substrings is done using substring_start
+	   and len_max variables, and iterating through the substrings
+	   searching for white chars where you can put line break. */
+	for (int substring_start = 0; substring_start < len; ) {
+		bool linebreak = false;
+
+		if (len - substring_start <= len_max) {
+			/* end of substring, no point in looking for
+			   places where line can be broken */
+			break;
+		}
+
+		/* Search for line break in substring, iterating from
+		   start of substring. If you find one, no new line break
+		   will have to be inserted in current substring and
+		   substring_start will have to be moved forward. */
+		for (int i = 0; i < len_max; i++) {
+			if (*(buffer + substring_start + i) == '\n') {
+				substring_start = substring_start + i + 1;
+				linebreak = true;
+				break;
+			}
+		}
+
+		if (linebreak) {
+			/* ok, got one line break in substring,
+			   prepare new substring */
+			linebreak = false;
+		} else {
+			/* search for last white char in substring - a good
+			   place to insert line break; next char after
+			   inserted line break will be start of next substring */
+
+			int n = cdw_string_get_words_end(buffer + substring_start, len_max);
+			*(buffer + substring_start + n) = '\n';
+			if (isspace(*(buffer + substring_start + n))) {
+				/* all is well, we can produce
+				   substring no longer than 'width' */
+				substring_start = substring_start + n + 1;
+			} else {
+				/* not good! given substring is longer
+				   than 'width'! string will be wrapped in
+				   window in the middle of word - not an end
+				   of the world, but won't look that well */
+				/* FIXME: worse than that: it may turn out that
+				   we are replacing a non-white char with '\n' */
+				substring_start = substring_start + len_max;
+			}
+		}
+	}
+
+	int n_lines = 0;
+	int i = 0;
+	for (i = 0; i < len; i++) {
+		if (*(buffer + i) == '\n') {
+			n_lines++;
+		}
+	}
+	if (*(buffer + i - 1) != '\n') {
+		/* add one more line for whatever text there is
+		   after last '\n' in buffer */
+		n_lines++;
+	}
+
+	return n_lines;
+}
+
+
+
+
+
+static void test_cdw_string_get_words_end(void)
+{
+	fprintf(stderr, "\ttesting cdw_string_get_words_end()... ");
+	struct {
+		const char *string;
+		size_t chars_max;
+		int expected_value;
+	} test_data[] = {
+		{ "", 1,   0 },
+		{ "", 10,  0 },
+
+		{ "hello world", 1, 1 },
+		{ "hello world", 5, 5 },
+		{ "hello world", 6, 5 },
+		{ "hello world", 7, 5 },
+
+		{ "hello\nworld", 1, 1 },
+		{ "hello\nworld", 5, 5 },
+		{ "hello\nworld", 6, 5 },
+		{ "hello\nworld", 7, 5 },
+		{ "hello\nworld", 27, 5 },
+
+
+		{ "12345678901234567890", 1, 1 },
+		{ "12345678901234567890", 10, 10 },
+		{ "12345678901234567890", 20, 20 },
+		{ "12345678901234567890", 21, 20 },
+		{ "12345678901234567890", 22, 20 },
+		{ "12345678901234567890", 30, 20 },
+		{ "12345678901234567890 12345678901234567890", 30, 20 },
+		{ "12345678901234567890 12345678901234567890", 45, 41 },
+
+		{ (char *) NULL, 0, 0 },
+
+	};
+
+	int i = 0;
+	while (test_data[i].chars_max != 0) {
+		int result = cdw_string_get_words_end(test_data[i].string, test_data[i].chars_max);
+		cdw_assert (result == test_data[i].expected_value,
+			    "ERROR: test #%d: string = \"%s\", expected value = %zd, result = %zd\n",
+			    i, test_data[i].string, test_data[i].expected_value, result);
+		i++;
+	}
+
+	fprintf(stderr, "OK\n");
+	return;
+}
+
+#if 0
+
+/*
+   - If string has words separated with spaces, return number of characters
+     in given range up to end of last word;
+   - If string has no spaces, return number of characters in range given by
+     chars_max; If string is shorter than chars_max, the function will return
+     length of string;
+   - If there is a new line character, return number of characters before
+     the new line character;
+   - If string starts with the delimiting character (NUL, new line character,
+     space), the function returns 0;
+
+     The function is a bit too simple, because it can't handle
+     strings with two or more consecutive delimiting characters.
+*/
+int cdw_string_get_words_end(const char *string, int chars_max)
+{
+	if (string[0] == '\n' || string[0] == '\0' || string[0] == ' ') {
+		return 0;
+	}
+
+	int last_space = 0;
+	int len = (int) strlen(string);
+	int i = 0;
+	for (i = 0; i < chars_max && i <= len; i++) {
+		if (string[i] == ' ') {
+			/* remember last position of space in
+			   string as you traverse whole string */
+			last_space = i;
+		} else if (string[i] == '\n' || string[i] == '\0') {
+			/* no need to traverse the string further,
+			   this is where we must return */
+			return i;
+		} else {
+			;
+		}
+	}
+	/* we get here when one of two things happen: */
+	if (last_space == 0) {
+		/* no spaces or line breaks in given range of string,
+		   return last position in traversed data */
+		return i;
+	} else {
+		/* there was at least one space, its position was saved
+		   as we traversed the string */
+		return last_space;
+	}
+}
+#endif
+
+
+#endif
+
+
+
+
+
+
+#if 0
+
+
+/**
+   \brief Split line containing '=' char into 'name' and 'value' part
+
+   \date Function's top-level comment reviewed on 2012-02-07
+   \date Function's body reviewed on 2012-02-07
+
+   The function takes one 'char *' string, recognizes where is first
+   '=' char in it. What is on the left side of the char is treated
+   as option name, and what is on the right side of the char is treated
+   as option value. Pointers to beginning of both name and value are placed
+   in \p option. These pointers point to substrings of original string.
+
+   Original string is modified so that strings representing name and value
+   don't have any white chars at the beginning and end. '\0' chars are
+   also inserted into original string (function's argument) to properly
+   delimit the two substrings.
+
+   The function heavily modifies its \p line argument!
+
+   The function recognizes '#' as comment char and erases everything from
+   line starting from '#' char;
+
+   \p line must be proper char * string ending with '\0'
+
+   Both fields of \p option are set to NULL if:
+   \li function's \p line argument is NULL;
+   \li function's \p line argument is empty;
+   \li function's \p line argument does not contain '=' char;
+   \li function's \p line argument is a comment line.
+   \li function's \p line argument has '=' char but don't have any option name
+
+   Otherwise the fields of \p option are set with valid pointers pointing
+   to two substrings in function's \p line argument. Again: these substrings
+   are proper C strings and are ended with '\0'.
+
+   Don't use cdw_config_option_free() on \p option!
+
+   This function is similar to cdw_config_split_options_line(),
+   the difference being that name and value are substrings in \p line,
+   and not freshly allocated strings.
+
+   \param option - variable where pointers to substrings are placed
+   \param line - line that you want to extract option from
+
+   \return true on success (both fields of \p option are set)
+   \return false otherwise
+*/
+bool cdw_config_split_options_line_old(cdw_option_t *option, char *line)
+{
+	cdw_sdm ("INFO: input line = '%s'\n", line);
+
+	option->name = (char *) NULL;
+	option->value = (char *) NULL;
+
+	if (!line) {
+		return false;
+	}
+
+	/* this will make sure that comment, starting at any position
+	   in line, will be erased from line */
+	char *comment = strstr(line, "#"); /* beginning of in-line comment */
+	if (comment) {
+		size_t len = strlen(comment);
+		for (size_t i = 0; i < len; i++) {
+			*(comment + i) = '\0';
+		}
+	}
+
+	char *tline = cdw_string_ltrim(cdw_string_rtrim(line));
+	char *eq = strstr(tline, "="); /* first occurrence of '=' in line */
+
+	if (eq) {
+		option->name = tline;
+		*eq = '\0';
+		option->name = cdw_string_rtrim(option->name);
+
+		if (!strcmp(option->name, "")) {
+			option->name = (char *) NULL;
+			option->value = (char *) NULL;
+			return false;
+		}
+
+		option->value = cdw_string_ltrim(eq + 1);
+		/* value may be empty string too, but this is not an error
+		   condition, since given option value can be empty
+		   (no value set) - this is correct situation */
+
+		cdw_sdm ("INFO:    option.name  = \"%s\"\n", option->name);
+		cdw_sdm ("INFO:    option.value = \"%s\"\n", option->value);
+
+		return true;
+	} else {
+		cdw_vdm ("ERROR: line is invalid: \"%s\"\n", line);
+
+		return false;
+	}
+
+}
+
+
+
+
+
+void test_cdw_config_split_options_line_old(void)
+{
+	fprintf(stderr, "\ttesting cdw_config_split_options_line_old()... ");
+
+	struct {
+		const char *line;
+		bool expected_return_value;
+		bool expected_null_name;
+		bool expected_null_value;
+		const char *expected_name;
+		const char *expected_value;
+
+	} input_data[] = {
+		/* correct line */
+		{ "option name=value string",
+		  true,
+		  false, false,
+		  "option name", "value string" },
+
+		/* correct line */
+		{ "\t option name \t\t = \t value string \t",
+		  true,
+		  false, false,
+		  "option name", "value string" },
+
+		/* correct line, but no value */
+		{ "\t option name = \t \t",
+		  true,
+		  false, false,
+		  "option name", "" },
+
+		/* correct line, but no value (2) */
+		{ "\t option name = #value string\t \t",
+		  true,
+		  false, false,
+		  "option name", "" },
+
+		/* incorrect line, no '=' char (1) */
+		{ "\t option name \t # = value string\t \t",
+		  false,
+		  true, true,
+		  (char *) NULL, (char *) NULL },
+
+		/* incorrect line, no '=' char (2) */
+		{ "\t option name \t  value string\t \t",
+		  false,
+		  true, true,
+		  (char *) NULL, (char *) NULL },
+
+		/* incorrect line, all content is comment */
+		{ " \t #\t option name = value string\t \t",
+		  false,
+		  true, true,
+		  (char *) NULL, (char *) NULL },
+
+		/* incorrect line, empty line */
+		{ "",
+		  false,
+		  true, true,
+		  (char *) NULL, (char *) NULL },
+
+		/* incorrect line, empty line (2) */
+		{ " \t \t    \t\t\t\t     \t               \t#    ",
+		  false,
+		  true, true,
+		  (char *) NULL, (char *) NULL },
+
+		/* incorrect line, line = NULL */
+		{ (char *) NULL,
+		  false,
+		  true, true,
+		  (char *) NULL, (char *) NULL },
+
+		{ (char *) NULL,
+		  false,
+		  false, true, /* <-- guard */
+		  (char *) NULL, (char *) NULL }
+	};
+
+	/* remember that option fields are pointers to places inside
+	   input strings, not pointers to newly allocated strings */
+	cdw_option_t option;
+
+	int i = 0;
+	while (input_data[i].expected_null_name == input_data[i].expected_null_value) {
+		char *line = (char *) NULL;
+		if (input_data[i].line) {
+			line = strdup(input_data[i].line);
+		}
+
+		bool rv = cdw_config_split_options_line_old(&option, line);
+		cdw_assert (input_data[i].expected_return_value == rv, "ERROR: failed at function call#%d\n", i);
+
+		if (input_data[i].expected_null_name) {
+			cdw_assert (!option.name, "ERROR: name is not NULL (#%d)\n", i);
+		} else {
+			cdw_assert (option.name, "ERROR: name is NULL (#%d)\n", i);
+		}
+
+		if (input_data[i].expected_null_value) {
+			cdw_assert (!option.value, "ERROR: value is not NULL (#%d)\n", i);
+		} else {
+			cdw_assert (option.value, "ERROR: value is NULL (#%d)\n", i);
+		}
+
+		if (!input_data[i].expected_null_name && input_data[i].expected_null_value) {
+
+			cdw_assert (!strcmp(option.name, input_data[i].expected_name), "ERROR: unexpected name #%d: \"%s\"\n", i, option.name);
+			cdw_assert (!strcmp(option.value, input_data[i].expected_value), "ERROR: unexpected value #%d: \"%s\"\n", i, option.value);
+		}
+
+		if (line) {
+			free(line);
+			line = (char *) NULL;
+		}
+
+		i++;
+	}
+
+
+	fprintf(stderr, "OK\n");
+
+	return;
+}
+
+
+
+
+
+#endif
+
+
+
+
+#if 0
+cdw_rv_t cdw_mkisofsrc_options_validate_old(cdw_form_t *cdw_form, int *fi)
+{
+	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_abstract_i));
+	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_mkisofsrc_abstract_i;
+		return CDW_NO;
+	}
+
+	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_volume_set_id_i));
+	crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_mkisofsrc_volume_set_id_i;
+		return CDW_NO;
+	}
+
+	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_copyright_i));
+	crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_mkisofsrc_copyright_i;
+		return CDW_NO;
+	}
+
+	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_publisher_i));
+	crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_mkisofsrc_publisher_i;
+		return CDW_NO;
+	}
+
+	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_preparer_i));
+	crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_mkisofsrc_preparer_i;
+		return CDW_NO;
+	}
+
+	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_mkisofsrc_system_id_i));
+	crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_mkisofsrc_system_id_i;
+		return CDW_NO;
+	}
+
+	return CDW_OK;
+}
+#endif
+
+
+
+
+#if 0
+cdw_rv_t cdw_xorrisorc_validate_old(cdw_form_t *cdw_form, int *fi)
+{
+	char *s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_publisher_i));
+	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_xorrisorc_publisher_i;
+		return CDW_NO;
+	}
+
+	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_volume_set_id_i));
+	crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_xorrisorc_volume_set_id_i;
+		return CDW_NO;
+	}
+
+	s = cdw_ncurses_get_field_string(*(cdw_form->fields + f_xorrisorc_system_id_i));
+	crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv != CDW_OK) {
+		*fi = f_xorrisorc_system_id_i;
+		return CDW_NO;
+	}
+
+	return CDW_OK;
+}
+#endif
+
+
+
+/* *** unused code *** */
+
+#if 0
+
+/**
+   \brief Display CD usage summary on bottom of cdw window
+
+   Display amount of space used by selected files, amount of
+   space that would stay free on disk, and percent of CD disk usage.
+   CD/DVD size is taken from config panel/file.
+
+   I try to pack all information in just two lines, so that it is always
+   visible and always updated when file selector is on top and files_info area
+   is partially covered by file selector.
+
+   The function does not collect nor calculate any data (except for some local
+   variables), it just uses current values from some global variables.
+*/
+void cdw_main_window_volume_info_view_display_data(size_t n_files, double size_mb)
+{
+	cdw_assert (cdw_ui.volume_info_view.subwindow != (WINDOW *) NULL,
+		    "called the function for null subwindow\n");
+	WINDOW *subwindow = cdw_ui.volume_info_view.subwindow;
+	wattrset(subwindow, A_BOLD | COLOR_PAIR(CDW_COLORS_MAIN));
+
+	int s_row = 3;    /* "Size: " row */
+	int b_row = 4;    /* usage bar row */
+        const int col = 2;        /* start column for content drawn in window */
+	const int bar_width = 30; /* number of cells in bar, does not include borders */
+
+	/* clean row in which usage bar and information about space usage is displayed */
+	mvwhline(subwindow, s_row, 1, ' ', cdw_ui.volume_info_view.n_cols - 2);
+	mvwhline(subwindow, b_row, 1, ' ', cdw_ui.volume_info_view.n_cols - 2);
+
+	/* left and right border of usage bar */
+	mvwaddch(subwindow, b_row, col, '[');
+	mvwaddch(subwindow, b_row, col + bar_width + 1, ']');
+
+	bool too_much = false;
+	if (size_mb > (double) global_config.volume_size_value) {
+		too_much = true;
+		wattrset(subwindow, COLOR_PAIR(CDW_COLORS_ERROR));
+	} else {
+		/* 0.8 (80%): arbitrary value of 'safe' level of disc usage */
+		if (size_mb <= ((double) global_config.volume_size_value * 0.8)) {
+			wattrset(subwindow, COLOR_PAIR(CDW_COLORS_MAIN));
+		} else {
+			wattrset(subwindow, COLOR_PAIR(CDW_COLORS_WARNING));
+		}
+	}
+
+	double percent = size_mb * 100 / ((double) global_config.volume_size_value);
+	int n = 0;
+	if (too_much) { /* files size is larger than available space */
+		/* 2TRANS: this string displays total size of dirs/files
+		   selected ('%.1f'), total available space ('%d') and
+		   number of items selected (second '%d'). */
+		mvwprintw(subwindow, s_row, col, _("%.1f/%ld MB in %d items"),
+			  size_mb, global_config.volume_size_value, n_files);
+
+		n = bar_width;
+	} else {
+		/* 2TRANS: this string displays total size of dirs/files
+		   selected ('%.1f'), total available space ('%d'), number of
+		   items selected (second '%d'), and free space left ('%.0f'). */
+		mvwprintw(subwindow, s_row, col, _("%.1f/%ld MB in %d items, %.0f MB free"),
+			  size_mb, global_config.volume_size_value,
+			  n_files, (double) global_config.volume_size_value - size_mb);
+
+		n = (int) ((percent * (double) bar_width) / 100);
+	}
+
+	mvwhline(subwindow, b_row, col + 1, ACS_BLOCK, n); /* +1 to skip left brace [ */
+
+	mvwprintw(subwindow, b_row, col + bar_width + 3, /* 3 to move past indicator bar */
+		  /* 2TRANS: this is information about usage of CD space:
+		     '%2.1f%%' is information about used space, displayed
+		     as percentage of total disc size */
+		  _("%2.1f%%"), percent);
+
+	wattrset(subwindow, A_NORMAL | COLOR_PAIR(CDW_COLORS_MAIN));
+	wrefresh(subwindow);
+
+	return;
+}
+
+#endif
+
+
+
+
+
+/* *** unused code below */
+
+
+
+
+
+# if 0
+
+
+
+/**
+   \brief Get 0/1 state from a checkbox widget associated with given field
+
+   Check content of field's buffer (if it is "X" or not) and return 0 or 1.
+
+   The field must be configured and used as a checkbox (field of size 1x1),
+   because only first character of field's buffer is checked.
+
+   \param field - field that you want to inspect
+
+   \return true if given field's buffer contains "X" string
+   \return false if given field's buffer does not contain "X" string
+*/
+bool cdw_ncurses_get_field_bit(FIELD *field)
+{
+	cdw_assert (field != (FIELD *) NULL, "ERROR: field argument passed for examination is NULL\n");
+	return !strncmp(field_buffer(field, 0), "X", 1) ? true : false;
+}
+
+#endif
+
+
+
+/* unused code below */
+
+#if 0
+
+
+cdw_id_t cdw_task_select_tool_family(cdw_task_t *task, cdw_disc_t *disc)
+{
+	cdw_id_t tool_family = CDW_TOOL_NONE;
+	if (task->id == CDW_TASK_MEDIA_INFO
+	    || task->id == CDW_TASK_BURN_FROM_IMAGE
+	    || task->id == CDW_TASK_BURN_FROM_FILES
+	    || task->id == CDW_TASK_ERASE_DISC) {
+
+		/* note on cdw_ext_tools_config_get_X_family(): if manual
+		   selection is in effect, these two functions simply take
+		   value selected in "tool family" menu in configuration panel;
+		   if "intelligent" selection is in effect, returned values
+		   are selected with some intelligent method */
+		if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_CD) {
+			tool_family = cdw_ext_tools_config_get_cd_handler_id();
+			if (tool_family == CDW_TOOL_NONE) {
+				cdw_task_e((char *) NULL,
+					   /* 2TRANS: this is message in dialog window;
+					      "tools" means "cdrecord", "growisofs" etc. */
+					   _("cdw can't find in your system any tools for handling CD discs. Current action can't be performed."));
+			}
+			cdw_assert (tool_family == CDW_TOOL_CDRECORD, "ERROR: tool family for CD is not cdrecord\n");
+
+		} else if (disc->simple_type == CDW_DISC_SIMPLE_TYPE_DVD) {
+			tool_family = cdw_ext_tools_config_get_dvd_handler_id();
+			if (tool_family == CDW_TOOL_NONE) {
+				cdw_task_e((char *) NULL,
+					   /* 2TRANS: this is message in dialog window;
+					      "tools" means "cdrecord", "growisofs" etc. */
+					   _("cdw can't find in your system any tools for handling DVD discs. Current action can't be performed."));
+			}
+			cdw_assert (tool_family == CDW_TOOL_CDRECORD || tool_family == CDW_TOOL_GROWISOFS,
+				    "ERROR: tool family for DVD is neither cdrecord nor growisofs\n");
+		} else {
+			cdw_assert (0, "ERROR: incorrect disc simple type %d\n", disc->simple_type);
+		}
+	} else if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
+		tool_family = cdw_ext_tools_config_get_iso9660_id();
+		if (tool_family == CDW_TOOL_NONE) {
+			cdw_task_e((char *) NULL,
+				   /* 2TRANS: this is message in dialog window;
+				      "tools" means "mkisofs", "xorriso" etc. */
+				   _("cdw can't find in your system any tools for creating ISO9660 files. Current action can't be performed."));
+		}
+		cdw_assert (tool_family == CDW_TOOL_MKISOFS || tool_family == CDW_TOOL_XORRISO,
+			    "ERROR: too family for creating ISO9660 is invalid: %ld\n", tool_family);
+	} else {
+		;
+	}
+	return tool_family;
+}
+
+
+
+
+
+bool cdw_task_select_tool_sub(cdw_task_t *task, cdw_id_t tool_family)
+{
+	bool success = true;
+	if (task->id == CDW_TASK_MEDIA_INFO) {
+		if (tool_family == CDW_TOOL_GROWISOFS) {
+			task->media_info.tool.id = CDW_TOOL_DVD_RW_MEDIAINFO;
+		} else if (tool_family == CDW_TOOL_CDRECORD) {
+			task->media_info.tool.id = CDW_TOOL_CDRECORD;
+		/* } else if (tool_family == CDW_TOOL_XORRISO) {
+		        task->media_info.tool.id = CDW_TOOL_XORRISO; */
+		} else {
+			success = false;
+			cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
+		}
+		if (success) {
+			task->media_info.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->media_info.tool.id);
+		}
+
+	} else if (task->id == CDW_TASK_ERASE_DISC) {
+		if (tool_family == CDW_TOOL_GROWISOFS) {
+			task->erase.tool.id = CDW_TOOL_DVD_RW_FORMAT;
+		} else if (tool_family == CDW_TOOL_CDRECORD) {
+			task->erase.tool.id = CDW_TOOL_CDRECORD;
+		/* } else if (tool_family == CDW_TOOL_XORRISO) {
+		        task->erase.tool.id = CDW_TOOL_XORRISO; */
+		} else {
+			success = false;
+			cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
+		}
+		if (success) {
+			task->erase.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->erase.tool.id);
+		}
+	} else if (task->id == CDW_TASK_BURN_FROM_FILES) {
+		   if (tool_family == CDW_TOOL_GROWISOFS
+		       || tool_family == CDW_TOOL_CDRECORD) {
+
+			   if (cdw_ext_tools_is_tool_available(CDW_TOOL_MKISOFS)) {
+				   task->create_image.tool.id = CDW_TOOL_MKISOFS;
+				   task->create_image.tool.fullpath = cdw_ext_tools_get_tool_fullpath(CDW_TOOL_MKISOFS);
+
+				   if (tool_family == CDW_TOOL_GROWISOFS) {
+					   task->burn.tool.id = CDW_TOOL_GROWISOFS;
+				   } else {
+					   task->burn.tool.id = CDW_TOOL_CDRECORD;
+				   }
+			   } else {
+				   success = false;
+			   }
+		   /* } else if (tool_family == CDW_TOOL_XORRISO) {
+		              task->burn.tool.id = CDW_TOOL_XORRISO; */
+		   } else {
+			   success = false;
+			   cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
+		   }
+		   if (success) {
+			   task->burn.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->burn.tool.id);
+		   }
+	} else if (task->id == CDW_TASK_BURN_FROM_IMAGE) {
+		if (tool_family == CDW_TOOL_GROWISOFS) {
+			task->burn.tool.id = CDW_TOOL_GROWISOFS;
+		} else if (tool_family == CDW_TOOL_CDRECORD) {
+			task->burn.tool.id = CDW_TOOL_CDRECORD;
+		/* } else if (tool_family == CDW_TOOL_XORRISO) {
+		        task->burn.tool.id = CDW_TOOL_XORRISO;*/
+		} else {
+			success = false;
+			cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
+		}
+		if (success) {
+			task->burn.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->burn.tool.id);
+		}
+
+	} else if (task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
+		if (tool_family == CDW_TOOL_MKISOFS) {
+			task->create_image.tool.id = CDW_TOOL_MKISOFS;
+		} else if (tool_family == CDW_TOOL_XORRISO) {
+			task->create_image.tool.id = CDW_TOOL_XORRISO;
+		} else {
+			success = false;
+			cdw_assert (0, "ERROR: incorrect tool family %ld\n", tool_family);
+		}
+		if (success) {
+			task->create_image.tool.fullpath = cdw_ext_tools_get_tool_fullpath(task->create_image.tool.id);
+		}
+	} else if (task->id == CDW_TASK_CHECK_MD5SUM) {
+		if (cdw_ext_tools_is_tool_available(CDW_TOOL_MD5SUM)) {
+			task->calculate_digest.tool.id = CDW_TOOL_MD5SUM;
+			task->calculate_digest.tool.fullpath = cdw_ext_tools_get_tool_fullpath(CDW_TOOL_MD5SUM);
+		} else {
+			success = false;
+		}
+	} else {
+		cdw_assert (0, "ERROR: incorrect task id = %d\n", task->id);
+	}
+
+	return success;
+}
+
+
+#endif
+
+
+
+
+/* use to check if there is a disc in drive and if we can operate on it */
+//static bool cdw_disc_is_disc_ready(void);
+
+#if 0
+static bool using_local_processwin = false;
+
+
+
+/**
+   \brief Re-read and display optical disc information, show it in text window if required
+
+   Read meta-information form optical disc that is currently in drive
+   and display summary in 'Disc info' area of ui.
+
+   TODO: this function needs some review and improvement.
+
+   \return CDW_OK if media info was read properly
+   \return CDW_NO if media info was not read properly
+*/
+cdw_rv_t cdw_read_disc_info(void)
+{
+	const char *drive = cdw_drive_get_drive_fullpath();
+	if (drive == (char *) NULL) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Can't find any drives, please check your hardware."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		return CDW_NO;
+	}
+
+	if (cdw_processwin_is_active()) {
+		using_local_processwin = false;
+	} else {
+		using_local_processwin = true;
+		/* 2TRANS: this is title of process window; reading
+		   disc meta information */
+		cdw_processwin_create(_("Read disc information"),
+				      /* 2TRANS: this is message in
+					 process window */
+				      _("Reading disc information"),
+				      false);
+	}
+
+	cdw_disc_t *disc = cdw_disc_get__();
+	cdw_main_window_disc_info_view_display_data(disc);
+
+	cdw_rv_t retval = CDW_OK;
+	if (!cdw_drive_is_disc_in_drive()) {
+		cdw_vdm ("INFO: no disc in drive\n");
+		cdw_main_window_disc_info_view_display_data(disc);
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Cannot show disc info. No disc in drive."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		retval = CDW_NO;
+		goto cdw_read_disc_info_return;
+	}
+
+	drive = cdw_drive_get_drive_fullpath();
+	cdw_rv_t mounted = cdw_fs_check_device_mounted(drive);
+	if (mounted == CDW_ERROR) {
+		cdw_vdm ("WARNING: checking if disc is mounted ended with error\n");
+		/* let's try and proceed with further checks anyway */
+	} else if (mounted == CDW_OK) { /* device is mounted */
+		cdw_vdm ("INFO: optical disc is mounted\n");
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Cannot check media. Please unmount your drive."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		retval = CDW_NO;
+		goto cdw_read_disc_info_return;
+	} else { /* mounted == CDW_NO, not mounted */
+		cdw_vdm ("INFO: disc is not mounted\n");
+	}
+
+
+	/* get_meta_info() may fail only partially; display what you can */
+	cdw_main_window_disc_info_view_display_data(disc);
+	if (!disc->has_data) {
+		cdw_vdm ("ERROR: can't get disc meta info\n");
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Cannot get media info. Consult log file ('L' hotkey in main window)."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+		retval = CDW_NO;
+		goto cdw_read_disc_info_return;
+	} else { /* mediainfo == CDW_OK, we have proper media info */
+		cdw_vdm ("INFO: disc meta info read properly\n");
+	}
+
+
+	/* at this point everything ends well: disc is in drive, it
+	   is not mounted, we have read its meta information properly */
+	retval = CDW_OK;
+
+cdw_read_disc_info_return:
+	if (using_local_processwin) {
+		cdw_processwin_destroy("", false);
+	}
+	return retval;
+}
+
+#endif
+
+
+
+
+#if 0 /* unused */
+
+/**
+   \brief Check if disc is in drive and if it is unmounted
+
+   Check if disc is ready for further investigations and actions,
+   i.e. if it is in drive at all and if it is unmounted. This is
+   important when you want to read metadata from disc or when you
+   want to burn to disc or erase disc (perhaps read disc as well).
+
+   \return true when disc is ready, or when this is not certain, but user wants to continue
+   \return false when disc is not ready, or when disc is probably not ready, but user don't want to continue
+*/
+bool cdw_disc_is_disc_ready(void)
+{
+	/* this function only checks if there is media in drive */
+	if (!cdw_drive_is_disc_in_drive()) {
+		/* cdw_dialogbox() was called by the function to
+		   inform about problems */
+		// current_disc.disc_type = CDW_DISC_NONE;
+		// cdw_disc_resolve();
+		return false;
+	}
+
+	const char *drive = cdw_drive_get_drive_fullpath();
+	int tries = 5;
+	for (int i = 0; i < tries; i++) {
+		/* can't write to disc that is mounted */
+		cdw_rv_t crv = cdw_fs_check_device_mounted(drive);
+		if (crv == CDW_ERROR) {
+			/* 2TRANS: this is title of dialog window */
+			cdw_rv_t d = cdw_buttons_dialog(_("Error"),
+							/* 2TRANS: this is message in dialog
+							   window, user can select "OK" or
+							   "Cancel" button */
+							_("Cannot check if disc is unmounted. You should unmount your drive. Continue?"),
+							CDW_BUTTONS_OK_CANCEL, CDW_COLORS_ERROR);
+			if (d == CDW_OK) {
+				/* disc may be mounted, but user wants to try anyway */
+				return true;
+
+			} else {
+				/* disc may be mounted, and user don't want
+				   to try to continue */
+				return false;
+
+			}
+		} else if (crv == CDW_OK) { /* device is mounted */
+			if (i == tries - 1) {
+				/* 2TRANS: this is title of dialog window */
+				cdw_buttons_dialog(_("Error"),
+						   /* 2TRANS: this is message in dialog window: an
+						      operation cannot be executed, because optical
+						      disc is mounted in file system */
+						   _("Cannot continue with mounted drive."),
+						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+				return false;
+			}
+
+			/* 2TRANS: this is title of dialog window */
+			cdw_rv_t m = cdw_buttons_dialog(_("Error"),
+							/* 2TRANS: this is message in dialog window: an
+							   operation cannot be executed, because optical
+							   disc is mounted in file system */
+							_("Cannot continue. Please unmount your drive and press OK."),
+							CDW_BUTTONS_OK_CANCEL, CDW_COLORS_ERROR);
+			if (m == CDW_OK) {
+				; /* try again */
+			} else {
+				return false;
+			}
+		} else { /* crv == CDW_NO, not mounted */
+			return true;
+		}
+	}
+
+	return false;
+}
+#endif
+
+
+
+
+cdw_rv_t cdw_create_image_get_target_data_image_path(void)
+{
+	/* 2TRANS: this is title of dialog window */
+	cdw_rv_t crv = cdw_fs_ui_file_picker(_("Path to iso image"),
+					     /* 2TRANS: this is message in dialog window;
+					     below it there is an input field where user can
+					     enter path to ISO image file */
+					     _("Please enter FULL path to new iso image file:"),
+					     &(global_config.iso_image_full_path),
+					     CDW_FS_FILE, R_OK | W_OK, CDW_FS_NEW | CDW_FS_EXISTING);
+
+	cdw_vcrv ("cdw_fs_ui_file_picker", crv);
+	if (crv == CDW_OK) {
+		cdw_vdm ("INFO: file picker returns \"%s\"\n", global_config.iso_image_full_path);
+	} else if (crv == CDW_CANCEL) {
+		cdw_vdm ("INFO: pressed escape in file picker, fullpath is \"%s\"\n", global_config.iso_image_full_path);
+	} else {
+		cdw_vdm ("INFO: file picker returns CDW_ERROR, fullpath is \"%s\"\n", global_config.iso_image_full_path);
+	}
+	cdw_main_ui_main_window_wrefresh();
+
+	return crv;
+}
+
+
+
+/* unused code below */
+
+#if 0
+
+
+
+/* for now it only works for growisofs */
+cdw_rv_t cdw_ext_tools_check_versions(void)
+{
+	int i = 0;
+	char *fullpath = cdw_ext_tools.tools[CDW_TOOL_GROWISOFS].instances[i];
+
+	while (fullpath != (char *) NULL) {
+		char *command = cdw_string_concat(fullpath, " --version", (char *) NULL);
+		if (command == (char *) NULL) {
+			cdw_vdm ("ERROR: failed to create command for fullpath \"%s\"\n", fullpath);
+			return CDW_ERROR;
+		} else {
+			/* need the task only for pipe regexp dispatcher,
+			   and the dispatcher checks for some specific fields,
+			   which we have to set here */
+			cdw_task_t task;
+			task.burn.tool.id = CDW_TOOL_GROWISOFS;
+			task.id = CDW_TASK_BURN_FROM_IMAGE;
+
+			run_command(command, &task);
+			free(command);
+			command = (char *) NULL;
+
+			i++;
+			fullpath = cdw_ext_tools.tools[CDW_TOOL_GROWISOFS].instances[i];
+		}
+	}
+
+	return CDW_OK;
+}
+
+#endif
+
+
+
+
+
+/* *** unused code below *** */
+
+#if 0
+
+
+/**
+   \brief Create process writing audio CD; this code is currently not maintained
+
+   \param task - variable describing current task
+
+   \return CDW_OK
+ */
+cdw_rv_t run_command_cdrecord_write_audio(cdw_task_t *task)
+{
+	char command[500];
+	cdw_rv_t crv = CDW_OK;
+
+	crv = cdw_config_ui_conditional_volume_label_dialog();
+	bool use_scsi = cdw_config_has_scsi_device();
+	const char *device = use_scsi ? global_config.scsi : cdw_drive_get_drive_fullpath();
+
+	if (crv == CDW_OK) { /* user entered label: empty or non-empty, but continue in both cases */
+		cdw_assert (task->burn.tool.fullpath != (char *) NULL, "ERROR: tool fullpath is NULL\n");
+		sprintf(command, "%s -v speed=%d dev=%s -audio", task->burn.tool.fullpath, task->burn.speed, device);
+		if (global_config.pad) {
+			/* when you go back to maintaining this code, don't
+			   forget to add padsize */
+			strcat(command, " -pad ");
+		}
+		if (task->burn.disc_mode == CDW_DISC_MODE_DAO) {
+			strcat(command, " -dao ");
+		}
+		if (global_config.dummy) {
+			strcat(command, " -dummy ");
+		}
+		if (global_config.burnproof) {
+			strcat(command, " -driveropts=burnproof ");
+		}
+		sprintf(command, "%s %s/*.wav", command, global_config.audiodir);
+		/* 2TRANS: this is dialog window title
+		   (writing audio files to CD) */
+		cdw_processwin_create(_("Write audio"),
+				      /* 2TRANS: this is message in dialog
+					 window: writing audio CD is in
+					 progress */
+				      _("Writing audio..."), true);
+
+		run_command(command, task);
+
+		/* 2TRANS: this is message in dialog window; result of
+		   operation is unknown */
+		cdw_processwin_destroy(_("Writing audio finished"), true);
+
+		/* 2TRANS: this string will be used as title of window
+		   displaying log of operation (of writing audio CD) */
+		after_event(_("Write audio log"), 1);
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+   \brief Create process copying CD disk; this code is currently not maintained
+
+   \param task - variable describing current task
+
+   \return CDW_OK
+ */
+cdw_rv_t run_command_cdrecord_copy_disk(cdw_task_t *task)
+{
+	char command[500];
+	int in_fd;
+	bool use_scsi = cdw_config_has_scsi_device();
+	const char *device = use_scsi ? global_config.scsi : cdw_drive_get_drive_fullpath();
+
+	if ((in_fd = open("/dev/cdrom", O_RDONLY)) != -1) {
+		close(in_fd);
+		cdw_assert (task->burn.tool.fullpath != (char *) NULL, "ERROR: tool fullpath is NULL\n");
+		sprintf(command, "%s -v speed=%d dev=%s %s", task->burn.tool.fullpath, task->burn.speed, device, lobal_config.other_cdrecord_options);
+		if (global_config.eject) {
+			strcat(command, " -eject");
+		}
+		if (global_config.dummy) {
+			strcat(command, " -dummy");
+		}
+
+		sprintf(command, "%s -isosize %s", command, global_config.cdrw_device);
+		/* 2TRANS: this is dialog window title */
+		cdw_processwin_create(_("Copy data CD"), (char *) NULL, true);
+
+		run_command(command, task);
+
+		/* 2TRANS: this is message in dialog window:
+		   result of operation (success/failure) unknown */
+		cdw_processwin_destroy(_("Copying data CD finished"), true);
+
+		/* 2TRANS: this string will be used as title of
+		   window displaying log of operation (of copying CD) */
+		after_event(_("Copy data CD log"), 1);
+	}
+
+	return CDW_OK;
+}
+
+
+
+#endif
+
+
+#if 0
+
+cdw_rv_t cdw_iso9660_read_from_config(cdw_iso9660_t *iso)
+{
+	iso->joliet_information = global_config.iso9660.joliet_information;
+	iso->joliet_long        = global_config.iso9660.joliet_long;
+	iso->rock_ridge         = global_config.iso9660.rock_ridge;
+	iso->follow_symlinks    = global_config.iso9660.follow_symlinks;
+	iso->pad                = true;
+	iso->iso_level          = global_config.iso9660.iso_level;
+
+	cdw_rv_t crv = cdw_string_set(&(iso->root_dir), global_config.iso9660.root_dir);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set root_dir with \"%s\"\n", global_config.iso9660.root_dir);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(iso->other_mkisofs_options), global_config.iso9660.other_mkisofs_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set other_mkisofs_options with \"%s\"\n", global_config.iso9660.other_mkisofs_options);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(iso->other_xorriso_iso_options), global_config.iso9660.other_xorriso_iso_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set other_xorriso_iso_options with \"%s\"\n", global_config.iso9660.other_xorriso_iso_options);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(iso->boot_disc_options), global_config.iso9660.boot_disc_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set boot_disc_options with \"%s\"\n", global_config.iso9660.boot_disc_options);
+		return CDW_ERROR;
+	}
+
+	strncpy(iso->volume_id, global_config.iso9660.volume_id, CDW_ISO9660_VOLI_LEN);
+	        iso->volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
+
+	strncpy(iso->volume_set_id, global_config.iso9660.volume_set_id, CDW_ISO9660_VOLS_LEN);
+	        iso->volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
+
+	strncpy(iso->preparer, global_config.iso9660.preparer, CDW_ISO9660_PREP_LEN);
+	        iso->preparer[CDW_ISO9660_PREP_LEN] = '\0';
+
+	strncpy(iso->publisher, global_config.iso9660.publisher, CDW_ISO9660_PUBL_LEN);
+	        iso->publisher[CDW_ISO9660_PUBL_LEN] = '\0';
+
+	strncpy(iso->system_id, global_config.iso9660.system_id, CDW_ISO9660_SYSI_LEN);
+	        iso->system_id[CDW_ISO9660_SYSI_LEN] = '\0';
+
+	strncpy(iso->copyright, global_config.iso9660.copyright, CDW_ISO9660_COPY_LEN);
+	        iso->copyright[CDW_ISO9660_COPY_LEN] = '\0';
+
+	strncpy(iso->abstract, global_config.iso9660.abstract, CDW_ISO9660_ABST_LEN);
+	        iso->abstract[CDW_ISO9660_ABST_LEN] = '\0';
+
+	return CDW_OK;
+
+}
+
+
+
+
+
+cdw_rv_t cdw_iso9660_write_to_config(cdw_iso9660_t *iso)
+{
+	global_config.iso9660.joliet_information = iso->joliet_information;
+	global_config.iso9660.joliet_long        = iso->joliet_long;
+	global_config.iso9660.rock_ridge         = iso->rock_ridge;
+	global_config.iso9660.follow_symlinks    = iso->follow_symlinks;
+	/* pad - not saved */
+	global_config.iso9660.iso_level          = iso->iso_level;
+
+	cdw_rv_t crv = cdw_string_set(&(global_config.iso9660.root_dir), iso->root_dir);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set root_dir with \"%s\"\n", iso->root_dir);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(global_config.iso9660.other_mkisofs_options), iso->other_mkisofs_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set other_mkisofs_options with \"%s\"\n", iso->other_mkisofs_options);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(global_config.iso9660.other_xorriso_iso_options), iso->other_xorriso_iso_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set other_xorriso_iso_options with \"%s\"\n", iso->other_xorriso_iso_options);
+		return CDW_ERROR;
+	}
+
+	crv = cdw_string_set(&(global_config.iso9660.boot_disc_options), iso->boot_disc_options);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to set boot_disc_options with \"%s\"\n", iso->boot_disc_options);
+		return CDW_ERROR;
+	}
+
+	strncpy(global_config.iso9660.volume_id, iso->volume_id, CDW_ISO9660_VOLI_LEN);
+	        global_config.iso9660.volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
+
+	strncpy(global_config.iso9660.volume_set_id, iso->volume_set_id, CDW_ISO9660_VOLS_LEN);
+	        global_config.iso9660.volume_set_id[CDW_ISO9660_VOLS_LEN] = '\0';
+
+	strncpy(global_config.iso9660.preparer, iso->preparer, CDW_ISO9660_PREP_LEN);
+	        global_config.iso9660.preparer[CDW_ISO9660_PREP_LEN] = '\0';
+
+	strncpy(global_config.iso9660.publisher, iso->publisher, CDW_ISO9660_PUBL_LEN);
+	        global_config.iso9660.publisher[CDW_ISO9660_PUBL_LEN] = '\0';
+
+	strncpy(global_config.iso9660.system_id, iso->system_id, CDW_ISO9660_SYSI_LEN);
+	        global_config.iso9660.system_id[CDW_ISO9660_SYSI_LEN] = '\0';
+
+	strncpy(global_config.iso9660.copyright, iso->copyright, CDW_ISO9660_COPY_LEN);
+	        global_config.iso9660.copyright[CDW_ISO9660_COPY_LEN] = '\0';
+
+	strncpy(global_config.iso9660.abstract, iso->abstract, CDW_ISO9660_ABST_LEN);
+	        global_config.iso9660.abstract[CDW_ISO9660_ABST_LEN] = '\0';
+
+	return CDW_OK;
+}
+
+#endif
+
+#if 0
+/**
+   \brief Toggle state of checkbox
+
+   Toggle state of checkbox that is placed in field with index\p fi.
+   Make sure that this is really a checkbox before calling the function.
+
+   Additionally the function shows/hides widgets in "tools" page as
+   state of related checkbox changes.
+
+   \param cdw_form - form in which a checkbox is placed
+   \param fi - field index, index of field of form, that is related to the checkbox
+*/
+void cdw_form_driver_toggle_checkbox(cdw_form_t *cdw_form, int fi)
+{
+	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_CHECKBOX,
+		    "ERROR: called the function for non-checkbox\n");
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
+		    fi, cdw_form->n_fields);
+
+	CDW_CHECKBOX *checkbox = cdw_form_get_checkbox(cdw_form, fi);
+	cdw_checkbox_toggle(checkbox);
+	if (checkbox->on_toggle_callback != (cdw_form_widget_function_t) NULL) {
+		bool state = cdw_checkbox_get_state(checkbox);
+		checkbox->on_toggle_callback(cdw_form, &state);
+	}
+	return;
+}
+#endif
+
+
+#if 0
+int cdw_form_handle_enter(cdw_form_t *cdw_form, int fi)
+{
+	if (cdw_form_is_button_field_index(cdw_form, fi)) {
+		CDW_BUTTON *b = cdw_form_get_button(cdw_form, fi);
+		return b->on_click_callback((void *) cdw_form, (void *) NULL);
+	} else if (cdw_form_is_dropdown_field_index(cdw_form, fi)) {
+		CDW_DROPDOWN *dropdown = cdw_form_get_dropdown(cdw_form, fi);
+		cdw_assert (dropdown != (CDW_DROPDOWN *) NULL, "ERROR: dropdown is NULL\n");
+		int key = cdw_dropdown_driver(dropdown);
+		if (key == CDW_KEY_ENTER) {
+			const char *label = cdw_dropdown_get_current_item_label(dropdown);
+			FIELD **fields = form_fields(cdw_form->form);
+			/* setting buffer makes field to display
+			   string, but slightly moved to left */
+			set_field_buffer(*(fields + fi), 0, label);
+
+			/* call to cdw_dropdown_focus() fixes it */
+			cdw_dropdown_focus(dropdown);
+
+			form_driver(cdw_form->form, REQ_VALIDATION);
+		} else {
+			;
+		}
+		return 'a';
+	} else {
+		return 'a';
+	}
+}
+#endif
+
+
+
+
+#if 0
+/**
+   \brief Control keyboard input when focus is on dropdown - top level function
+
+   \date Function's top-level comment reviewed on 2012-01-07
+   \date Function's body reviewed on 2012-01-07
+
+   This function calls cdw_dropdown_expanded_driver() to control
+   keyboard input in expanded \p dropdown.
+
+   \param dropdown - dropdown that has focus
+
+   \return CDW_KEY_ENTER if user pressed ENTER in expanded dropdown
+   \return CDW_KEY_ESCAPE if user pressed ESCAPE, Q or q in expanded dropdown
+*/
+int cdw_dropdown_driver_old(CDW_DROPDOWN *dropdown)
+{
+	cdw_assert (dropdown, "ERROR: cannot control NULL dropdown\n");
+	cdw_assert (dropdown->parent, "ERROR: cannot control dropdown with NULL parent\n");
+
+	cdw_dropdown_expand(dropdown);
+	int key = cdw_dropdown_expanded_driver(dropdown);
+	cdw_dropdown_collapse(dropdown);
+
+	if (key == CDW_KEY_ENTER) {
+		/* when dropdown is closed (hidden), it should remain
+		   highlighted, so second parameter is true */
+		cdw_dropdown_display_current_item_reverse(dropdown, true);
+
+		/* Pass selected item ID to client code. */
+		if (dropdown->on_select_callback) {
+			dropdown->on_select_callback(NULL, &(dropdown->items[dropdown->current_item_ind]->id));
+		}
+	}
+
+	redrawwin(dropdown->parent);
+	wrefresh(dropdown->parent);
+
+	return key;
+}
+#endif
+
+
+
+
+/* unused code */
+
+#if 0
+
+char *cdw_string_wrap_old(const char *string, size_t width_max, int align)
+{
+	/* Input text buffer may have arbitrary length, but output text
+	   buffer's length must be a multiple of width_max. */
+	size_t n_lines = cdw_string_count_lines(string, width_max);
+	size_t out_len = width_max * n_lines;
+	char *retval = malloc(out_len + 1);
+	memset(retval, ' ', out_len + 1);
+
+	const char *input = string;
+	char *output = retval;
+
+	/* copy text from input to output */
+	while (1) {
+		/* function returns zero-based index */
+		size_t line_len = cdw_string_get_line_end(input, width_max);
+		if (!line_len) {
+			break;
+		}
+		line_len++;
+
+		size_t begin = cdw_string_wrap_start(width_max, line_len, align);
+		snprintf(output + begin, line_len + 1, "%s", input);
+
+		output[begin + line_len] = ' '; /* overwrite trailing NUL, we don't want to end the string just yet */
+
+		input = input + line_len;
+		output = output + width_max;
+
+		if (isspace(*input)) {
+			input++;
+		}
+	}
+
+	retval[out_len] = '\0';
+
+	return retval;
+}
+
+#endif
+
+
+
+
+#if 0
+/**
+ * \brief Display message about current problem with initializing log path
+ *
+ * Display dialog box informing about specific problem with given path.
+ *
+ * \param problem - identifier of problem, defined values are NO_SPACE, EMPTY_PATH, INVALID_PATH
+ */
+void cdw_logging_display_problem(int problem)
+{
+	if (problem == NO_SPACE) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Too little space left on disc, can't write to log file."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	} else if (problem == EMPTY_PATH) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Path to log file is empty, can't open file."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	} else if (problem == INVALID_PATH) {
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("Path to log file is invalid, can't open file"),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	} else { /* problem == GEN_ERROR */
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("cdw can't configure its log file. Please restart the program."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+	}
+}
+#endif
diff -Naur orig/src/user_interface/cdw_colors.c patched/src/user_interface/cdw_colors.c
--- orig/src/user_interface/cdw_colors.c	2012-03-27 21:26:10.000000000 +0200
+++ patched/src/user_interface/cdw_colors.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _BSD_SOURCE /* PATH_MAX */
@@ -338,6 +338,8 @@
 		buffer[CDW_COLORS_BUFFER_SIZE - 1] = '\0';
 
 		char *line = cdw_string_ltrim(buffer);
+		cdw_string_rtrim(line);
+
 		int i = 0;
 		switch (i = cdw_colors_get_attribute_name(line)) {
 		        case CONF_COMMENT:
diff -Naur orig/src/user_interface/cdw_erase_wizard.c patched/src/user_interface/cdw_erase_wizard.c
--- orig/src/user_interface/cdw_erase_wizard.c	2012-03-28 20:56:44.000000000 +0200
+++ patched/src/user_interface/cdw_erase_wizard.c	2014-04-06 22:27:50.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #define _BSD_SOURCE /* strdup() */
 
@@ -58,9 +58,6 @@
 static cdw_rv_t cdw_erase_wizard_initial_warning(cdw_disc_type_t disc_type);
 static void     cdw_erase_wizard_print_debug_info(cdw_task_t *task, bool format_mode_visible);
 
-static int cdw_erase_wizard_on_enter_on_cancel(cdw_form_t *cdw_form, void *dummy);
-static int cdw_erase_wizard_on_enter_on_erase(cdw_form_t *cdw_form, void *dummy);
-
 
 static struct {
 	cdw_form_t *cdw_form;
@@ -90,12 +87,6 @@
 #define first_col                  2 /* main message and some labels start in leftmost column */
 #define second_col                40
 #define top_label_row              2 /* main message is displayed on top of window */
-#define erase_mode_row             2
-#define erase_speed_row            5
-#define format_mode_row            8 /* label above of button invoking configuration window */
-#define eject_row                 11
-#define buttons_row               13 /* Erase and Cancel buttons are at the bottom of window */
-
 #define window_n_cols             52
 #define window_n_lines            20
 #define subwindow_n_cols           (window_n_cols - 2)
@@ -121,8 +112,8 @@
 	f_eject_cb,
 	f_eject_l,
 
-	f_erase_button_i,
-	f_cancel_button_i
+	f_erase_button_b,
+	f_cancel_button_b
 };
 
 
@@ -165,7 +156,7 @@
 	if (crv == CDW_CANCEL) {
 		return CDW_CANCEL;
 	}
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	/* TODO: there is a problem with implicit initialization of
 	   dropdowns in the wizard: dropdowns are initialized with
@@ -196,7 +187,7 @@
 		CDW_DROPDOWN *dd = (CDW_DROPDOWN *) NULL;
 		if (wizard.format_mode_dropdown_visible) {
 			dd = cdw_form_get_dropdown(wizard.cdw_form, f_format_mode_dd);
-			task->erase.format_mode = cdw_dropdown_get_current_item_id(dd);
+			task->erase.dvd_rw_format_mode = cdw_dropdown_get_current_item_id(dd);
 		}
 		dd = cdw_form_get_dropdown(wizard.cdw_form, f_erase_speed_dd);
 		task->erase.speed_id = cdw_dropdown_get_current_item_id(dd);
@@ -213,7 +204,7 @@
 	cdw_erase_wizard_destroy();
 
 	/* redraw parent */
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	return crv;
 }
@@ -224,7 +215,7 @@
 
 cdw_rv_t cdw_erase_wizard_driver(void)
 {
-	int fi = f_cancel_button_i; /* initial focus on "cancel" button */
+	int fi = f_cancel_button_b; /* initial focus on "cancel" button */
 	int key = 'a'; /* safe initial value */
 
 	while (key != CDW_KEY_ESCAPE && key != 'q' && key != 'Q') {
@@ -235,13 +226,13 @@
 		   buttons */
 		if (key == CDW_KEY_ENTER) {
 			fi = field_index(current_field(wizard.cdw_form->form));
-			if (fi == f_erase_button_i) {
+			if (fi == f_erase_button_b) {
 
 				/* flush */
 				form_driver(wizard.cdw_form->form, REQ_VALIDATION);
 
 				return CDW_OK;
-			} else if (fi == f_cancel_button_i) {
+			} else if (fi == f_cancel_button_b) {
 				return CDW_CANCEL;
 			} else {
 				;
@@ -285,20 +276,12 @@
 */
 void cdw_erase_wizard_destroy(void)
 {
-	if (wizard.cdw_form->subwindow != (WINDOW *) NULL) {
-		delwin(wizard.cdw_form->subwindow);
-		wizard.cdw_form->subwindow = (WINDOW *) NULL;
-	}
-
-	if (wizard.cdw_form->window != (WINDOW *) NULL) {
-		delwin(wizard.cdw_form->window);
-		wizard.cdw_form->window = (WINDOW *) NULL;
-	}
-
-	if (wizard.cdw_form != (cdw_form_t *) NULL) {
-		cdw_form_delete_form_objects(wizard.cdw_form);
-		cdw_form_delete(&(wizard.cdw_form));
-	}
+	/* This order of these four function calls minimizes number of
+	   problems reported by valgrind. */
+	cdw_form_delete_form_objects(wizard.cdw_form);
+	cdw_window_delete(&wizard.cdw_form->subwindow);
+	cdw_window_delete(&wizard.cdw_form->window);
+	cdw_form_delete(&(wizard.cdw_form));
 
 	return;
 }
@@ -377,7 +360,7 @@
 	}
 
 	wizard.cdw_form = cdw_form_new(CDW_ERASE_WIZARD_N_FIELDS);
-	if (wizard.cdw_form == (cdw_form_t *) NULL) {
+	if (!wizard.cdw_form) {
 		cdw_vdm ("ERROR: failed to create cdw form\n");
 		return CDW_ERROR;
 	}
@@ -394,7 +377,7 @@
 						 /* 2TRANS: this is tip at the bottom of window - user can
 						    switch between window elements using tab key */
 						 _("Use 'Tab' key to move"));
-	if (wizard.cdw_form->window == (WINDOW *) NULL) {
+	if (!wizard.cdw_form->window) {
 		cdw_vdm ("ERROR: failed to create window\n");
 		return CDW_ERROR;
 	}
@@ -404,7 +387,7 @@
 						    3, 1,
 						    CDW_COLORS_DIALOG, (char *) NULL, (char *) NULL);
 
-	if (wizard.cdw_form->subwindow == (WINDOW *) NULL) {
+	if (!wizard.cdw_form->subwindow) {
 		cdw_vdm ("ERROR: failed to create subwindow\n");
 		return CDW_ERROR;
 	}
@@ -420,7 +403,7 @@
 	wizard.cdw_form->form = cdw_ncurses_new_form(wizard.cdw_form->window,
 						     wizard.cdw_form->subwindow,
 						     wizard.cdw_form->fields);
-	if (wizard.cdw_form->form == (FORM *) NULL) {
+	if (!wizard.cdw_form->form) {
 		cdw_vdm ("ERROR: failed to create form\n");
 		return CDW_ERROR;
 	}
@@ -439,8 +422,8 @@
 
 	cdw_form_add_return_chars(wizard.cdw_form, CDW_KEY_ENTER, CDW_KEY_ESCAPE, 'q', 'Q', 0);
 
-	cdw_form_set_function(wizard.cdw_form, f_erase_button_i, cdw_erase_wizard_on_enter_on_erase);
-	cdw_form_set_function(wizard.cdw_form, f_cancel_button_i, cdw_erase_wizard_on_enter_on_cancel);
+	cdw_form_set_button_return_key(wizard.cdw_form, f_erase_button_b, CDW_KEY_ENTER);
+	cdw_form_set_button_return_key(wizard.cdw_form, f_cancel_button_b, CDW_KEY_ESCAPE);
 
 	wrefresh(wizard.cdw_form->subwindow);
 	wrefresh(wizard.cdw_form->window);
@@ -455,32 +438,32 @@
 cdw_rv_t cdw_erase_wizard_build_fields(cdw_task_t *task)
 {
 	cdw_form_descr_t descr[] = {
-		/*    widget type       begin_y               begin_x         n_cols                   n_lines    field enum         data1                        data2 */
+		/* widget type           begin_y    begin_x         n_cols                 n_lines    field enum          data1                            data2 */
 
 		/* 2TRANS: this is label in erase wizard */
-		{ CDW_WIDGET_LABEL,      erase_mode_row,       first_col,      label_n_cols,                1,    f_erase_mode_l,     _("Mode of erasing:"),   0 },
-		{ CDW_WIDGET_DROPDOWN,   erase_mode_row + 1,   first_col + 1,  wide_dropdown_n_cols - 2,    1,    f_erase_mode_dd,    dropdown_makers,                0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,  2,   first_col,      label_n_cols,                1,    f_erase_mode_l,     _("Mode of erasing:"),           0 },
+		{ CDW_WIDGET_ID_DROPDOWN,      3,   first_col + 1,  wide_dropdown_n_cols - 2,    1,    f_erase_mode_dd,    dropdown_makers,                 0 },
 
 		/* 2TRANS: this is label in erase wizard */
-		{ CDW_WIDGET_LABEL,      erase_speed_row,      first_col,      label_n_cols,                1,    f_erase_speed_l,    _("Speed of erasing:") ,  0 },
-		{ CDW_WIDGET_DROPDOWN,   erase_speed_row + 1,  first_col + 1,  narrow_dropdown_n_cols - 2,  1,    f_erase_speed_dd,    dropdown_makers,                1 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,  5,   first_col,      label_n_cols,                1,    f_erase_speed_l,    _("Speed of erasing:"),          0 },
+		{ CDW_WIDGET_ID_DROPDOWN,      6,   first_col + 1,  narrow_dropdown_n_cols - 2,  1,    f_erase_speed_dd,   dropdown_makers,                 1 },
 
 		/* 2TRANS: this is label in erase wizard, it's about target
 		   format for a DVD-RW disc */
-		{ CDW_WIDGET_LABEL,      format_mode_row,      first_col,      label_n_cols,                1,    f_format_mode_l,    _("Format of DVD-RW:"),      0 },
-		{ CDW_WIDGET_DROPDOWN,   format_mode_row + 1,  first_col + 1,  wide_dropdown_n_cols - 2,    1,    f_format_mode_dd,    dropdown_makers,                2 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,  8,   first_col,      label_n_cols,                1,    f_format_mode_l,    _("Format of DVD-RW:"),          0 },
+		{ CDW_WIDGET_ID_DROPDOWN,      9,   first_col + 1,  wide_dropdown_n_cols - 2,    1,    f_format_mode_dd,   dropdown_makers,                 2 },
 
-		{ CDW_WIDGET_CHECKBOX,   eject_row,            first_col + 2,  1,                           1,    f_eject_cb,         (void *) NULL,  task->erase.eject ? 1 : 0 },
+		{ CDW_WIDGET_ID_CHECKBOX,      11,  first_col + 2,  1,                           1,    f_eject_cb,         (void *) NULL,  task->erase.eject ? 1 : 0 },
 		/* 2TRANS: this is label of checkbox; "tray" is a tray of CD burner; "erasing" refers to blanking of optical disc */
-		{ CDW_WIDGET_LABEL,      eject_row,            first_col + 5,  label_n_cols - 5,            1,    f_eject_l,          _("Eject tray after erasing") ,  0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,  11,  first_col + 5,  label_n_cols - 5,            1,    f_eject_l,          _("Eject tray after erasing"),   0 },
 
 		/* 2TRANS: button label, it refers to erasing optical disc */
-		{ CDW_WIDGET_BUTTON,     buttons_row,          3,              2,                           1,    f_erase_button_i,   _("Erase"),      CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,        13,  3,              2,                           1,    f_erase_button_b,   _("Erase"),      CDW_COLORS_DIALOG },
 		/* 2TRANS: button label */
-		{ CDW_WIDGET_BUTTON,     buttons_row,          15,             2,                           1,    f_cancel_button_i,  _("Cancel"),     CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,        13,  15,             2,                           1,    f_cancel_button_b,  _("Cancel"),     CDW_COLORS_DIALOG },
 
 		/* guard */
-		{ -1,                    0,                    0,              0,                           0,    0,                  (void *) NULL,                   0 }};
+		{ -1,                          0,   0,              0,                           0,    0,                  (void *) NULL,                   0 }};
 
 
 	wizard.cdw_form->n_fields = CDW_ERASE_WIZARD_N_FIELDS;
@@ -504,7 +487,7 @@
 	CDW_DROPDOWN *dropdown = cdw_dropdown_new(window, begin_y, begin_x, width,
 						  2, /* n_items_max */
 						  CDW_COLORS_DIALOG);
-	if (dropdown == (CDW_DROPDOWN *) NULL) {
+	if (!dropdown) {
 		cdw_vdm ("ERROR: failed to create new dropdown\n");
 		return (CDW_DROPDOWN *) NULL;
 	}
@@ -552,7 +535,7 @@
 	CDW_DROPDOWN *dropdown = cdw_dropdown_new(window, begin_y, begin_x, width,
 						  local_disc->write_speeds.n_speeds,   /* n_items_max */
 						  CDW_COLORS_DIALOG);
-	if (dropdown == (CDW_DROPDOWN *) NULL) {
+	if (!dropdown) {
 		cdw_vdm ("ERROR: failed to create new dropdown\n");
 		return (CDW_DROPDOWN *) NULL;
 	}
@@ -590,23 +573,18 @@
 
 	/* 2TRANS: this is label in dropdown: it means "don't change
 	   format of DVD-RW during process of erasing disc" */
-	char *dont_change = _("Don't change format of DVD-RW");
+	const char *dont_change = _("Don't change format of DVD-RW");
 	/* 2TRANS: this is label in dropdown: 'Sequential' is one of two
 	   possible formats of DVD-RW */
-	char *seq = _("Change format to Sequential");
+	const char *seq = _("Change format to Sequential");
 	/* 2TRANS: this is label in dropdown: 'Restricted' is one of two
 	   possible formats of DVD-RW */
-	char *res = _("Change format to Restricted");
-
-	if (seq == (char *) NULL || res == (char *) NULL || dont_change == (char *) NULL) {
-		cdw_vdm ("ERROR: failed to create initial labels for format mode dropdown\n");
-		return (CDW_DROPDOWN *) NULL;
-	}
+	const char *res = _("Change format to Restricted");
 
 	CDW_DROPDOWN *dropdown = cdw_dropdown_new(window, begin_y, begin_x, width,
 						  3,                    /* n_items_max */
 						  CDW_COLORS_DIALOG);
-	if (dropdown == (CDW_DROPDOWN *) NULL) {
+	if (!dropdown) {
 		cdw_vdm ("ERROR: failed to create new dropdown\n");
 		return (CDW_DROPDOWN *) NULL;
 	}
@@ -663,32 +641,15 @@
 	cdw_vdm ("INFO:    eject tray after erasing = \"%s\"\n", task->erase.eject ? "true" : "false");
 
 	if (format_mode_dropdown_visible) {
-		if (task->erase.format_mode == CDW_ERASE_DVD_RW_FORMAT_SEQ) {
+		if (task->erase.dvd_rw_format_mode == CDW_ERASE_DVD_RW_FORMAT_SEQ) {
 			cdw_vdm ("INFO: selected DVD-RW format mode = \"Sequential\"\n");
-		} else if (task->erase.format_mode == CDW_ERASE_DVD_RW_FORMAT_RES) {
+		} else if (task->erase.dvd_rw_format_mode == CDW_ERASE_DVD_RW_FORMAT_RES) {
 			cdw_vdm ("INFO: selected DVD-RW format mode = \"Restricted overwrite\"\n");
 		} else {
-			cdw_vdm ("ERROR: incorrect format mode = %lld\n", task->erase.format_mode);
+			cdw_vdm ("ERROR: incorrect format mode = %lld\n", task->erase.dvd_rw_format_mode);
 		}
 	} else {
 		cdw_vdm ("INFO: DVD-RW format mode dropdown is NOT visible\n");
 	}
 	return;
 }
-
-
-
-
-
-int cdw_erase_wizard_on_enter_on_cancel(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	return CDW_KEY_ESCAPE;
-}
-
-
-
-int cdw_erase_wizard_on_enter_on_erase(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	return CDW_KEY_ENTER;
-}
-
diff -Naur orig/src/user_interface/cdw_form.c patched/src/user_interface/cdw_form.c
--- orig/src/user_interface/cdw_form.c	2012-02-26 15:24:35.000000000 +0100
+++ patched/src/user_interface/cdw_form.c	2014-04-12 20:23:47.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <string.h>
@@ -29,20 +29,28 @@
 #include "cdw_string.h"
 
 static void cdw_form_driver_focus_off(cdw_form_t *cdw_form, int fi);
-static void cdw_form_driver_focus_on(cdw_form_t *cdw_form, int fi);
 static void cdw_form_driver_toggle_focus(cdw_form_t *cdw_form, int fi, bool off);
-static void cdw_form_driver_toggle_checkbox(cdw_form_t *cdw_form, int fi);
 static bool cdw_form_is_return_key(cdw_form_t *form, int key);
-static int  cdw_form_handle_enter(cdw_form_t *cdw_form, int fi);
 
 static bool cdw_form_is_checkbox_field_index(cdw_form_t *cdw_form, int fi);
 static bool cdw_form_is_dropdown_field_index(cdw_form_t *cdw_form, int fi);
 static bool cdw_form_is_button_field_index(cdw_form_t *cdw_form, int fi);
 static bool cdw_form_is_input_field_index(cdw_form_t *cdw_form, int fi);
+static bool cdw_form_is_safe_input_line_index(cdw_form_t *cdw_form, int fi);
+static bool cdw_form_is_checkbox_index(cdw_form_t *cdw_form, int fi);
 
 
 
 
+static cdw_rv_t cdw_form_description_to_static_label(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi);
+static cdw_rv_t cdw_form_description_to_checkbox(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi);
+static cdw_rv_t cdw_form_description_to_dropdown(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi);
+static cdw_rv_t cdw_form_description_to_button(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi);
+static cdw_rv_t cdw_form_description_to_text(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi);
+static cdw_rv_t cdw_form_description_to_dynamic_label(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi);
+
+
+
 
 /**
    \brief Constructor
@@ -52,14 +60,14 @@
 cdw_form_t *cdw_form_new(int n_fields)
 {
 	cdw_form_t *cdw_form = (cdw_form_t *) malloc(sizeof (cdw_form_t));
-	if (cdw_form == (cdw_form_t *) NULL) {
+	if (!cdw_form) {
 		cdw_vdm ("ERROR: failed to allocate memory for new cdw form\n");
 		return (cdw_form_t *) NULL;
 	}
 	cdw_form->n_fields = n_fields;
 
 	cdw_form->field_widget_types = malloc((size_t) cdw_form->n_fields * sizeof (cdw_id_t));
-	if (cdw_form->field_widget_types ==  NULL) {
+	if (!cdw_form->field_widget_types) {
 		cdw_vdm ("ERROR: failed to allocate fields widget ids table\n");
 		free(cdw_form);
 		cdw_form = (cdw_form_t *) NULL;
@@ -77,9 +85,6 @@
 		cdw_form->return_keys[i] = 0;
 	}
 
-	/* may be overwritten by form-specific handler */
-	cdw_form->handle_enter = cdw_form_handle_enter;
-
 	return cdw_form;
 }
 
@@ -122,35 +127,47 @@
 */
 void cdw_form_delete_form_objects(cdw_form_t *cdw_form)
 {
-	if (cdw_form == (cdw_form_t *) NULL) {
+	if (!cdw_form) {
 		cdw_vdm ("WARNING: passing NULL form to function\n");
 		return;
 	}
-	/* from ncurses docs: "The functions free_field() and
+	/* From ncurses docs: "The functions free_field() and
 	   free_form are available to free field and form objects.
 	   It is an error to attempt to free a field connected to
 	   a form, but not vice-versa; thus, you will generally
-	   free your form objects first. */
-	if (cdw_form->form != (FORM *) NULL) {
+	   free your form objects first." */
+	if (cdw_form->form) {
 		unpost_form(cdw_form->form);
 		free_form(cdw_form->form);
 		cdw_form->form = (FORM *) NULL;
 	}
 
 	for (int i = 0; i < cdw_form->n_fields; i++) {
-		if (cdw_form->fields[i] != (FIELD *) NULL) {
-			if (cdw_form->field_widget_types[i] == CDW_WIDGET_CHECKBOX) {
+		/* I forgot why I do this 'if (cdw_form->fields[i])'
+		   test here.  Most probably because on failure to
+		   build a cdw_form the fields[] table may be
+		   sparse. */
+		if (cdw_form->fields[i]) {
+			if (cdw_form->field_widget_types[i] == CDW_WIDGET_ID_CHECKBOX) {
 				CDW_CHECKBOX *cb = (CDW_CHECKBOX *) field_userptr(cdw_form->fields[i]);
-				cdw_assert (cb != (CDW_CHECKBOX *) NULL, "ERROR: field #%d is checkbox, but the pointer is null\n", i);
+				cdw_assert (cb, "ERROR: field #%d is checkbox, but the pointer is null\n", i);
 				cdw_checkbox_free(cb);
-			} else if (cdw_form->field_widget_types[i] == CDW_WIDGET_BUTTON) {
+			} else if (cdw_form->field_widget_types[i] == CDW_WIDGET_ID_BUTTON) {
 				CDW_BUTTON *b = (CDW_BUTTON *) field_userptr(cdw_form->fields[i]);
-				cdw_assert (b != (CDW_BUTTON *) NULL, "ERROR: field #%d is button, but the pointer is null\n", i);
+				cdw_assert (b, "ERROR: field #%d is button, but the pointer is null\n", i);
 				cdw_button_free(b);
-			} else if (cdw_form->field_widget_types[i] == CDW_WIDGET_DROPDOWN) {
-				CDW_DROPDOWN *d = (CDW_DROPDOWN *) field_userptr(cdw_form->fields[i]);
-				cdw_assert (d != (CDW_DROPDOWN *) NULL, "ERROR: field #%d is dropdown, but the pointer is null\n", i);
-				cdw_dropdown_free(d);
+			} else if (cdw_form->field_widget_types[i] == CDW_WIDGET_ID_DROPDOWN) {
+				CDW_DROPDOWN *dd = (CDW_DROPDOWN *) field_userptr(cdw_form->fields[i]);
+				cdw_assert (dd, "ERROR: field #%d is dropdown, but the pointer is null\n", i);
+				cdw_dropdown_free(dd);
+			} else if (cdw_form->field_widget_types[i] == CDW_WIDGET_ID_DYNAMIC_LABEL) {
+				CDW_DYNAMIC_LABEL *label = (CDW_DYNAMIC_LABEL *) field_userptr(cdw_form->fields[i]);
+				cdw_assert (label, "ERROR: field #%d is label, but the pointer is null\n", i);
+				cdw_dynamic_label_delete(&label);
+			} else if (cdw_form->field_widget_types[i] == CDW_WIDGET_ID_SAFE_INPUT_LINE) {
+				CDW_SAFE_INPUT_LINE *input_line = (CDW_SAFE_INPUT_LINE *) field_userptr(cdw_form->fields[i]);
+				cdw_assert (input_line, "ERROR: field #%d is input_line, but the pointer is null\n", i);
+				cdw_safe_input_line_delete(&input_line);
 			} else {
 				;
 			}
@@ -166,90 +183,126 @@
 
 
 
+/**
+   \brief New style driver, for widgets that support ->driver() function
+
+   This driver is simpler than cdw_form_driver_old(), mainly because it
+   does not handle that many keys. It is only concerned with
+   inter-field movement keys and most important keys: Enter, Escape
+   and Exit.
+
+   Ideally all forms used by cdw should migrate to this driver.
+
+   In order for this function to work properly, all widgets in given
+   \p cdw_form must support ->driver().
+
+   \param cdw_form - cdw form to control
+   \param initial_fi - index of widget that will initially have keyboard focus
+
+   \return CDW_KEY_ENTER if one of widgets' driver has returned CDW_KEY_ENTER
+   \return CDW_KEY_ESCAPE if one of widgets' driver has returned CDW_KEY_ESCAPE
+   \return CDW_KEY_EXIT if one of widgets' driver has returned CDW_KEY_EXIT
+*/
 int cdw_form_driver(cdw_form_t *cdw_form, int initial_fi)
 {
-	cdw_assert (cdw_form->handle_enter != (int (*)(cdw_form_t *, int)) NULL,
-		    "ERROR: this form has no Enter handler set up\n");
-
 	cdw_form_driver_go_to_field(cdw_form, initial_fi);
+	/* TODO: why this assignment? */
 	initial_fi = field_index(current_field(cdw_form->form));
 	cdw_form_driver_focus_on(cdw_form, initial_fi);
 
-	form_driver(cdw_form->form, REQ_END_LINE);
-	wrefresh(cdw_form->subwindow);
 
-	int key = KEY_END; /* safe initial value */
-	do {
-		wrefresh(cdw_form->subwindow);
-		key = wgetch(cdw_form->subwindow);
+	int key = 'a'; /* Safe initial value. */
+	int fi = initial_fi;
 
-		if (cdw_form_is_movement_key(key)) {
-			int fi = field_index(current_field(cdw_form->form));
-			cdw_form_driver_focus_off(cdw_form, fi);
-		}
+	while (key != CDW_KEY_ESCAPE && key != CDW_KEY_ENTER && key != KEY_EXIT) {
+
+		/* Call a widget-specific driver, and don't care about
+		   widget-specific behaviour. The widget-specific
+		   behaviour is defined in widget module.
+
+		   TODO: two widget drivers below accept "cdw_form_t
+		   *" variable as second arg. Consider converting the
+		   type of second arg to all widget's drivers from
+		   "void *" to "cdw_form_t *".
+		*/
+		void *widget = field_userptr(cdw_form->fields[fi]);
+		if (cdw_form_is_button_field_index(cdw_form, fi)) {
+			CDW_BUTTON *b = (CDW_BUTTON *) widget;
+			key = cdw_button_driver(b, (void *) cdw_form);
+
+		} else if (cdw_form_is_dropdown_field_index(cdw_form, fi)) {
+			CDW_DROPDOWN *dd = (CDW_DROPDOWN *) widget;
+			key = cdw_dropdown_driver(dd, NULL);
+
+		} else if (cdw_form_is_safe_input_line_index(cdw_form, fi)) {
+			CDW_SAFE_INPUT_LINE *line = (CDW_SAFE_INPUT_LINE *) widget;
+			key = cdw_safe_input_line_driver(line, NULL);
+
+		} else if (cdw_form_is_checkbox_index(cdw_form, fi)) {
+			CDW_CHECKBOX *cb = (CDW_CHECKBOX *) widget;
+			key = cdw_checkbox_driver(cb, (void *) cdw_form);
 
-		if (key == KEY_HOME) {
-			form_driver(cdw_form->form, REQ_BEG_LINE);
-		} else if (key == KEY_END) {
-			form_driver(cdw_form->form, REQ_END_LINE);
-		} else if (key == KEY_LEFT) {
-			form_driver(cdw_form->form, REQ_PREV_CHAR);
-		} else if (key == KEY_RIGHT) {
-			form_driver(cdw_form->form, REQ_NEXT_CHAR);
-		} else if (key == KEY_DOWN || key == CDW_KEY_TAB) {
-			form_driver(cdw_form->form, REQ_NEXT_FIELD);
-			form_driver(cdw_form->form, REQ_END_LINE);
-		} else if (key == KEY_UP || key == KEY_BTAB) {
-			form_driver(cdw_form->form, REQ_PREV_FIELD);
-			form_driver(cdw_form->form, REQ_END_LINE);
-		} else if (key == KEY_BACKSPACE) {
-			form_driver(cdw_form->form, REQ_DEL_PREV);
-		} else if (key == KEY_DC) {
-			form_driver(cdw_form->form, REQ_DEL_CHAR);
-		} else if (key == CDW_KEY_ENTER) {
-			int fi = field_index(current_field(cdw_form->form));
-			/* the function may return dummy key 'a' which means
-			   to continue in driver loop */
-			key = cdw_form->handle_enter(cdw_form, fi);
 		} else {
-			int fi = field_index(current_field(cdw_form->form));
-			if (cdw_form_is_checkbox_field_index(cdw_form, fi)) {
-				if (key == ' ' || key == 'x' || key == 'X') {
-					cdw_form_driver_toggle_checkbox(cdw_form, fi);
-				}
-			} else if (cdw_form_is_dropdown_field_index(cdw_form, fi)) {
-				/* dropdown in its initial state reacts only
-				   to enter, and this has already been handled
-				   elsewhere by cdw_form->handle_enter() */
-				;
-			} else {
-				/* normal text/input field, pass char from keyboard to field */
-				form_driver(cdw_form->form, key);
-			}
+			/* May be that the only widget in the form is
+			   a widget without a driver (e.g. TEXT
+			   widget). What then? Here is a solution: */
+			key = wgetch(cdw_form->subwindow);
 		}
+
+
+
+		/* Handle movement between widgets. */
+
+
 		if (cdw_form_is_movement_key(key)) {
-			int fi = field_index(current_field(cdw_form->form));
+			/* We are moving away from a
+			   widget. Un-highlight it to show that
+			   keyboard focus is no longer on the
+			   widget. */
+			int old_fi = field_index(current_field(cdw_form->form));
+			cdw_form_driver_focus_off(cdw_form, old_fi);
+
+
+
+			/* Move to next or previous widget in the form. */
+			if (key == KEY_DOWN || key == CDW_KEY_TAB) {
+				form_driver(cdw_form->form, REQ_NEXT_FIELD);
+				form_driver(cdw_form->form, REQ_END_LINE);
+
+			} else if (key == KEY_UP || key == KEY_BTAB || key == KEY_BACKSPACE) {
+				form_driver(cdw_form->form, REQ_PREV_FIELD);
+				form_driver(cdw_form->form, REQ_END_LINE);
+
+			} else {
+				cdw_vdm ("ERROR: unhandled movement key %d/%s\n", key, cdw_ncurses_key_label(key));
+			}
+
+
+
+			/* We are moving into a next widget. Highlight it to
+			   show that keyboard focus has moved to the
+			   widget. */
+			fi = field_index(current_field(cdw_form->form));
 			cdw_form_driver_focus_on(cdw_form, fi);
-		}
-		if (cdw_form_is_return_key(cdw_form, key)) {
-			int fi = field_index(current_field(cdw_form->form));
+
+
+		} else if (cdw_form_is_return_key(cdw_form, key)) {
+			int ret_fi = field_index(current_field(cdw_form->form));
 			if (isprint(key)
-			    && cdw_form_is_input_field_index(cdw_form, fi)) {
-				/* keys like 'q'/'Q' may be configured
-				   as return keys, but they shouldn't be
-				   considered as such in regular text
-				   input fields */
+			    && cdw_form_is_input_field_index(cdw_form, ret_fi)) {
+				/* Keys like 'q'/'Q' may be configured
+				   as return keys, but they shouldn't
+				   be considered as such in regular
+				   text input fields. */
 				;
 			} else {
 				break;
 			}
+		} else {
+			;
 		}
+	}
 
-
-	} while (key != CDW_KEY_ESCAPE);
-
-	form_driver(cdw_form->form, REQ_VALIDATION);
-	curs_set(0); /* turn cursor off */
 	return key;
 }
 
@@ -277,7 +330,7 @@
 
 void cdw_form_add_return_char(cdw_form_t *form, int key)
 {
-	cdw_assert (form != (cdw_form_t *) NULL, "ERROR: \"form\" argument is NULL\n");
+	cdw_assert (form, "ERROR: \"form\" argument is NULL\n");
 	cdw_assert (form->n_return_keys < N_RETURN_KEYS_MAX,
 		    "ERROR: there are already %d / %d return keys in the form, can't add another one\n",
 		    form->n_return_keys, N_RETURN_KEYS_MAX);
@@ -299,7 +352,7 @@
 
 void cdw_form_add_return_chars(cdw_form_t *form, ...)
 {
-	cdw_assert (form != (cdw_form_t *) NULL, "ERROR: \"form\" argument is NULL\n");
+	cdw_assert (form, "ERROR: \"form\" argument is NULL\n");
 	cdw_assert (form->n_return_keys < N_RETURN_KEYS_MAX,
 		    "ERROR: there are already %d / %d return keys in the form, can't add another one\n",
 		    form->n_return_keys, N_RETURN_KEYS_MAX);
@@ -318,111 +371,50 @@
 
 
 
+typedef cdw_rv_t (* cdw_form_converter_t)(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi);
+
+
+/* Order of widget constructors/converters matches enumeration of
+   widget types in cdw_widget.h. */
+cdw_form_converter_t cdw_form_converters[] = {
+	NULL,
+	cdw_form_description_to_static_label,
+	cdw_form_description_to_checkbox,
+	cdw_form_description_to_dropdown,
+	cdw_form_description_to_button,
+	cdw_form_description_to_text,
+	cdw_form_description_to_safe_input_line,
+	cdw_form_description_to_dynamic_label
+};
+
+
+
+
 
 cdw_rv_t cdw_form_description_to_fields(cdw_form_descr_t descr[], cdw_form_t *cdw_form)
 {
-	FIELD **fields = cdw_form->fields;
 	/* "<=" - to set proper value of guard in fields table */
 	for (int i = 0; i <= cdw_form->n_fields; i++) {
-		fields[i] = (FIELD *) NULL;
+		cdw_form->fields[i] = (FIELD *) NULL;
 	}
 
 	cdw_assert (cdw_form->field_widget_types != (cdw_id_t *) NULL, "ERROR: table of widget ids is NULL\n");
 
-	for (int i = 0; i < cdw_form->n_fields; i++) {
-		cdw_id_t widget_type = descr[i].widget_type;
-		cdw_assert (i == descr[i].field_enum, "ERROR: order of items! field iterator (%d) != field enum (%d)\n", i, descr[i].field_enum);
+	for (int fi = 0; fi < cdw_form->n_fields; fi++) {
+		cdw_id_t widget_type = descr[fi].widget_type;
+		cdw_assert (fi == descr[fi].field_enum, "ERROR: wrong order of items: field iterator (%d) != field enum (%d)\n", fi, descr[fi].field_enum);
 		if (widget_type == -1) { /* guard in form description table */
-			cdw_assert (0, "ERROR: reached descr guard, so loop condition is incorrect; i = %d, n_fields = %d\n", i, cdw_form->n_fields);
+			cdw_assert (0, "ERROR: reached descr guard, so loop condition is incorrect; fi = %d, n_fields = %d\n", fi, cdw_form->n_fields);
 			break;
-		} else if (widget_type == CDW_WIDGET_LABEL) {
-			cdw_vdm ("INFO: creating field #%d: label with string = \"%s\"\n", i, (char *) descr[i].data1);
-			fields[i] = cdw_ncurses_new_label_field(descr[i].n_lines, descr[i].n_cols,
-								descr[i].begin_y, descr[i].begin_x,
-								(char *) descr[i].data1);
-		} else if (widget_type == CDW_WIDGET_CHECKBOX) {
-			cdw_vdm ("INFO: creating field #%d: checkbox (new)\n", i);
-			fields[i] = cdw_ncurses_new_checkbox_field(descr[i].begin_y, descr[i].begin_x,
-								   (char *) NULL);
-			/* I don't know why, but sometimes moving into
-			   a checkbox field erases content displayed
-			   in overlaying window; turning off O_PUBLIC
-			   seems to fix this problem */
-			field_opts_off(fields[i], O_PUBLIC);
-			CDW_CHECKBOX *cb = cdw_checkbox_new(cdw_form->subwindow, descr[i].begin_y, descr[i].begin_x, descr[i].data2);
-			int rv = set_field_userptr(fields[i], (void *) cb);
-			cdw_assert (rv == E_OK, "ERROR: can't set userptr for field #%d\n", i);
-		} else if (widget_type == CDW_WIDGET_INPUT) {
-			cdw_vdm ("INFO: creating field #%d: input with initial string = \"%s\"\n", i, (char *) descr[i].data1);
-			fields[i] = cdw_ncurses_new_input_field(descr[i].n_lines,
-								descr[i].n_cols,
-								descr[i].begin_y,
-								descr[i].begin_x,
-								(char *) descr[i].data1,
-								descr[i].data2,
-								CDW_NCURSES_INPUT_NONE,
-								CDW_COLORS_INPUT);
-		} else if (widget_type == CDW_WIDGET_BUTTON) {
-			cdw_vdm ("INFO: creating field #%d: button\n", i);
-			fields[i] = cdw_ncurses_new_input_field(descr[i].n_lines,
-								descr[i].n_cols,
-								descr[i].begin_y,
-								descr[i].begin_x,
-								(char *) NULL,
-								0, //descr[i].data2,
-								CDW_NCURSES_INPUT_NONE,
-								CDW_COLORS_INPUT);
-			/* to avoid situation when user presses some
-			   alphanumeric key and the key is entered
-			   into field under a button */
-			field_opts_off(fields[i], O_EDIT);
-			CDW_BUTTON *b = cdw_button_new(cdw_form->subwindow, descr[i].begin_y, descr[i].begin_x, descr[i].data1, descr[i].data2);
-			if (b == (CDW_BUTTON *) NULL) {
-				cdw_vdm ("ERROR: failed to create \"log path\" button for field #%d\n", i);
-				return CDW_ERROR;
-			}
-			int rv = set_field_userptr(fields[i], (void *) b);
-			cdw_assert (rv == E_OK, "ERROR: can't set userptr for field #%d\n", i);
-		} else if (widget_type == CDW_WIDGET_DROPDOWN) {
-			cdw_vdm ("INFO: creating field #%d: dropdown (new)\n", i);
-			fields[i] = cdw_ncurses_new_input_field(descr[i].n_lines,
-								descr[i].n_cols,
-								descr[i].begin_y,
-								descr[i].begin_x,
-								(char *) NULL,
-								0,
-								CDW_NCURSES_INPUT_NONE,
-								CDW_COLORS_INPUT);
-
-			cdw_form_dropdown_maker_t *makers = (cdw_form_dropdown_maker_t *) descr[i].data1;
-			int ind = (int) descr[i].data2;
-			CDW_DROPDOWN *dd = makers[ind](cdw_form->subwindow, descr[i].begin_y, descr[i].begin_x,
-						       descr[i].n_cols);
-			int rv = set_field_userptr(fields[i], (void *) dd);
-			cdw_assert (rv == E_OK, "ERROR: can't set userptr, i = %d\n", i);
-		} else if (widget_type == CDW_WIDGET_TEXT) {
-			cdw_vdm ("INFO: creating field #%d: text area\n", i);
-
-			cdw_form_text_maker_t *makers = (cdw_form_text_maker_t *) descr[i].data1;
-			int ind = (int) descr[i].data2;
-			char *message = makers[ind]((int) descr[i].n_cols);
-
-			fields[i] = cdw_ncurses_new_label_field(descr[i].n_lines, descr[i].n_cols,
-								descr[i].begin_y, descr[i].begin_x,
-								message);
-			free(message);
-			message = (char *) NULL;
-
-			field_opts_off(fields[i], O_ACTIVE);
-			field_opts_off(fields[i], O_EDIT);
-		} else {
-			cdw_assert (0, "ERROR: unknown widget type: %lld (field #%d)\n", widget_type, i);
 		}
 
-		cdw_form->field_widget_types[i] = widget_type;
+		cdw_assert (cdw_widget_is_valid_widget_id(widget_type), "ERROR: invalid widget type %lld\n", widget_type);
+		cdw_vdm ("INFO: creating field #%d: %s\n", fi, cdw_widgets_widget_type_label(widget_type));
 
-		if (fields[i] == (FIELD *) NULL) {
-			cdw_vdm ("ERROR: failed to initialize field #%d\n", i);
+		cdw_rv_t crv = cdw_form_converters[widget_type](cdw_form, &descr[fi], fi);
+		if (crv != CDW_OK) {
+			cdw_vdm ("ERROR: converter failed for widget #%d with id %lld (%s)\n",
+				 fi, widget_type, cdw_widgets_widget_type_label(widget_type));
 			return CDW_ERROR;
 		}
 	}
@@ -434,6 +426,249 @@
 
 
 
+cdw_rv_t cdw_form_description_to_static_label(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi)
+{
+	cdw_vdm ("INFO: initial string = \"%s\"\n", (char *) descr->data1);
+
+	cdw_form->fields[fi] = cdw_ncurses_new_label_field(descr->n_lines,
+							   descr->n_cols,
+							   descr->begin_y,
+							   descr->begin_x,
+							   (char *) descr->data1);
+	if (!cdw_form->fields[fi]) {
+		cdw_vdm ("ERROR: failed to initialize field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	cdw_form->field_widget_types[fi] = CDW_WIDGET_ID_STATIC_LABEL;
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_form_description_to_checkbox(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi)
+{
+	cdw_form->fields[fi] = cdw_ncurses_new_checkbox_field(descr->begin_y, descr->begin_x, (char *) NULL);
+	if (!cdw_form->fields[fi]) {
+		cdw_vdm ("ERROR: failed to initialize field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	/* I don't know why, but sometimes moving into a checkbox
+	   field erases content displayed in overlaying window;
+	   turning off O_PUBLIC seems to fix this problem */
+	field_opts_off(cdw_form->fields[fi], O_PUBLIC);
+
+	CDW_CHECKBOX *cb = cdw_checkbox_new(cdw_form->subwindow, descr->begin_y, descr->begin_x, descr->data2);
+	if (!cb) {
+		cdw_vdm ("ERROR: failed to create checkbox widget for field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	int rv = set_field_userptr(cdw_form->fields[fi], (void *) cb);
+	if (rv != E_OK) {
+		cdw_vdm ("ERROR: can't set userptr for field #%d: %d (%s) \n",
+			 fi, rv, cdw_ncurses_error_string(rv));
+		return CDW_ERROR;
+	}
+
+	cdw_form->field_widget_types[fi] = CDW_WIDGET_ID_CHECKBOX;
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_form_description_to_dropdown(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi)
+{
+	cdw_form->fields[fi] = cdw_ncurses_new_input_field(descr->n_lines,
+							   descr->n_cols,
+							   descr->begin_y,
+							   descr->begin_x,
+							   (char *) NULL,
+							   0,
+							   CDW_NCURSES_INPUT_NONE,
+							   CDW_COLORS_INPUT);
+	if (!cdw_form->fields[fi]) {
+		cdw_vdm ("ERROR: failed to initialize field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+
+	cdw_form_dropdown_maker_t *makers = (cdw_form_dropdown_maker_t *) descr->data1;
+	int ind = (int) descr->data2;
+
+	CDW_DROPDOWN *dd = makers[ind](cdw_form->subwindow, descr->begin_y, descr->begin_x,
+				       descr->n_cols);
+	if (!dd) {
+		cdw_vdm ("ERROR: failed to create dropdown widget for field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	int rv = set_field_userptr(cdw_form->fields[fi], (void *) dd);
+	if (rv != E_OK) {
+		cdw_vdm ("ERROR: can't set userptr for field #%d: %d (%s) \n",
+			 fi, rv, cdw_ncurses_error_string(rv));
+		return CDW_ERROR;
+	}
+
+	cdw_form->field_widget_types[fi] = CDW_WIDGET_ID_DROPDOWN;
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_form_description_to_button(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi)
+{
+	cdw_form->fields[fi] = cdw_ncurses_new_input_field(descr->n_lines,
+							   descr->n_cols,
+							   descr->begin_y,
+							   descr->begin_x,
+							   (char *) NULL,
+							   0, //descr->data2,
+							   CDW_NCURSES_INPUT_NONE,
+							   CDW_COLORS_INPUT);
+	if (!cdw_form->fields[fi]) {
+		cdw_vdm ("ERROR: failed to initialize field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	/* To avoid situation when user presses some alphanumeric key
+	   and the key is entered into field under a button. */
+	field_opts_off(cdw_form->fields[fi], O_EDIT);
+
+	CDW_BUTTON *b = cdw_button_new(cdw_form->subwindow, descr->begin_y, descr->begin_x, descr->data1, descr->data2);
+	if (!b) {
+		cdw_vdm ("ERROR: failed to create button widget for field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	int rv = set_field_userptr(cdw_form->fields[fi], (void *) b);
+	if (rv != E_OK) {
+		cdw_vdm ("ERROR: can't set userptr for field #%d: %d (%s) \n",
+			 fi, rv, cdw_ncurses_error_string(rv));
+		return CDW_ERROR;
+	}
+
+	cdw_form->field_widget_types[fi] = CDW_WIDGET_ID_BUTTON;
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_form_description_to_text(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi)
+{
+	cdw_form_text_maker_t *makers = (cdw_form_text_maker_t *) descr->data1;
+	int ind = (int) descr->data2;
+	char *message = makers[ind]((int) descr->n_cols);
+
+	cdw_form->fields[fi] = cdw_ncurses_new_label_field(descr->n_lines, descr->n_cols,
+							   descr->begin_y, descr->begin_x,
+							   message);
+	free(message);
+	message = (char *) NULL;
+
+	if (!cdw_form->fields[fi]) {
+		cdw_vdm ("ERROR: failed to initialize field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	field_opts_off(cdw_form->fields[fi], O_ACTIVE);
+	field_opts_off(cdw_form->fields[fi], O_EDIT);
+
+	cdw_form->field_widget_types[fi] = CDW_WIDGET_ID_TEXT;
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_form_description_to_safe_input_line(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi)
+{
+	cdw_vdm ("INFO: initial string = \"%s\"\n", (char *) descr->data1);
+	cdw_form->fields[fi] = cdw_ncurses_new_input_field(descr->n_lines,
+							   descr->n_cols,
+							   descr->begin_y,
+							   descr->begin_x,
+							   (char *) descr->data1,
+							   descr->data2,
+							   CDW_NCURSES_INPUT_NONE,
+							   CDW_COLORS_INPUT);
+	if (!cdw_form->fields[fi]) {
+		cdw_vdm ("ERROR: failed to initialize field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	CDW_SAFE_INPUT_LINE *line = cdw_safe_input_line_new(cdw_form->subwindow,
+							    &(cdw_form->form),
+							    cdw_form->fields[fi],
+							    descr->n_cols,
+							    (char *) descr->data1,
+							    CDW_NCURSES_INPUT_NONE,
+							    (int) descr->data2);
+	if (!line) {
+		cdw_vdm ("ERROR: failed to create safe input line widget for field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	int rv = set_field_userptr(cdw_form->fields[fi], (void *) line);
+	if (rv != E_OK) {
+		cdw_vdm ("ERROR: can't set userptr for field #%d: %d (%s) \n",
+			 fi, rv, cdw_ncurses_error_string(rv));
+		return CDW_ERROR;
+	}
+
+	cdw_form->field_widget_types[fi] = CDW_WIDGET_ID_SAFE_INPUT_LINE;
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_form_description_to_dynamic_label(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi)
+{
+	cdw_vdm ("INFO: initial string = \"%s\"\n", (char *) descr->data1);
+	cdw_form->fields[fi] = cdw_ncurses_new_label_field(descr->n_lines, descr->n_cols,
+							   descr->begin_y, descr->begin_x,
+							   (char *) descr->data1);
+	if (!cdw_form->fields[fi]) {
+		cdw_vdm ("ERROR: failed to initialize field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	CDW_DYNAMIC_LABEL *label = cdw_dynamic_label_new(cdw_form->subwindow,
+							 cdw_form->fields[fi],
+							 descr->n_cols,
+							 (char *) descr->data1);
+	if (!label) {
+		cdw_vdm ("ERROR: failed to create dynamic label widget for field #%d\n", fi);
+		return CDW_ERROR;
+	}
+
+	int rv = set_field_userptr(cdw_form->fields[fi], (void *) label);
+	if (rv != E_OK) {
+		cdw_vdm ("ERROR: can't set userptr for field #%d: %d (%s) \n",
+			 fi, rv, cdw_ncurses_error_string(rv));
+		return CDW_ERROR;
+	}
+
+	cdw_form->field_widget_types[fi] = CDW_WIDGET_ID_DYNAMIC_LABEL;
+	return CDW_OK;
+}
+
+
+
+
+
 bool cdw_form_is_movement_key(int key)
 {
 	if (key == KEY_DOWN
@@ -487,13 +722,13 @@
    then highlight of current widget is turned off */
 void cdw_form_driver_toggle_focus(cdw_form_t *cdw_form, int fi, bool off)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
 
 	if (cdw_form_is_button_field_index(cdw_form, fi)) {
 		CDW_BUTTON *button = cdw_form_get_button(cdw_form, fi);
-		if (button != (CDW_BUTTON *) NULL) {
+		if (button) {
 			void (*function)(CDW_BUTTON *) = (void (*)(CDW_BUTTON *)) NULL;
 			if (off) {
 				function = cdw_button_unfocus;
@@ -508,7 +743,7 @@
 		}
 	} else if (cdw_form_is_dropdown_field_index(cdw_form, fi)) {
 		CDW_DROPDOWN *dropdown = cdw_form_get_dropdown(cdw_form, fi);
-		if (dropdown != (CDW_DROPDOWN *) NULL) {
+		if (dropdown) {
 			void (*function)(CDW_DROPDOWN *) = (void (*)(CDW_DROPDOWN *)) NULL;
 			if (off) {
 				function = cdw_dropdown_unfocus;
@@ -546,39 +781,113 @@
 
 CDW_DROPDOWN *cdw_form_get_dropdown(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
-	FIELD *field = cdw_form->fields[fi];
-	cdw_assert (field != (FIELD *) NULL, "ERROR: field %d is NULL\n", fi);
 
-	CDW_DROPDOWN *dropdown = (CDW_DROPDOWN *) NULL;
-	if (cdw_form->field_widget_types[fi] == CDW_WIDGET_DROPDOWN) {
-		dropdown = (CDW_DROPDOWN *) field_userptr(field);
-		cdw_assert (dropdown != (CDW_DROPDOWN *) NULL, "ERROR: field user pointer is NULL dropdown (fi = %d)\n", fi);
-	}
+	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_DROPDOWN,
+		    "ERROR: field index %d: widget type is not DROPDOWN, is %s\n",
+		    fi, cdw_widgets_widget_type_label(cdw_form->field_widget_types[fi]));
+
+	cdw_assert (cdw_form->fields[fi], "ERROR: field %d is NULL\n", fi);
+
+
+	CDW_DROPDOWN *dd = (CDW_DROPDOWN *) field_userptr(cdw_form->fields[fi]);
+	cdw_assert (dd, "ERROR: field index %d: field user pointer is NULL\n", fi);
+	cdw_assert (dd->widget_id == CDW_WIDGET_ID_DROPDOWN,
+		    "ERROR: field index %d: internal widget id is not DROPDOWN, is %s\n",
+		    fi, cdw_widgets_widget_type_label(dd->widget_id));
+
+	return dd;
+}
+
+
+
+
+
+CDW_DYNAMIC_LABEL *cdw_form_get_dynamic_label(cdw_form_t *cdw_form, int fi)
+{
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
+		    fi, cdw_form->n_fields);
+
+	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_DYNAMIC_LABEL,
+		    "ERROR: field index %d: widget type is not DYNAMIC_LABEL, is %s\n",
+		    fi, cdw_widgets_widget_type_label(cdw_form->field_widget_types[fi]));
+
+	cdw_assert (cdw_form->fields[fi], "ERROR: field %d is NULL\n", fi);
+
+
+	CDW_DYNAMIC_LABEL *label = (CDW_DYNAMIC_LABEL *) field_userptr(cdw_form->fields[fi]);
+	cdw_assert (label, "ERROR: field index %d: field user pointer is NULL\n", fi);
+	cdw_assert (label->widget_id == CDW_WIDGET_ID_DYNAMIC_LABEL,
+		    "ERROR: field index %d: internal widget id is not DYNAMIC_LABEL, is %s\n",
+		    fi, cdw_widgets_widget_type_label(label->widget_id));
+
+	return label;
+}
+
+
+
 
-	return dropdown;
+
+CDW_SAFE_INPUT_LINE *cdw_form_get_safe_input_line(cdw_form_t *cdw_form, int fi)
+{
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
+		    fi, cdw_form->n_fields);
+
+	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_SAFE_INPUT_LINE,
+		    "ERROR: field index %d: widget type is not SAFE_INPUT_LINE, is %s\n",
+		    fi, cdw_widgets_widget_type_label(cdw_form->field_widget_types[fi]));
+
+	cdw_assert (cdw_form->fields[fi], "ERROR: field %d is NULL\n", fi);
+
+
+	CDW_SAFE_INPUT_LINE *line = (CDW_SAFE_INPUT_LINE *) field_userptr(cdw_form->fields[fi]);
+	cdw_assert (line, "ERROR: field index %d: field user pointer is NULL\n", fi);
+	cdw_assert (line->widget_id == CDW_WIDGET_ID_SAFE_INPUT_LINE,
+		    "ERROR: field index %d: internal widget id is not SAFE_INPUT_LINE, is %s\n",
+		    fi, cdw_widgets_widget_type_label(line->widget_id));
+
+	return line;
 }
 
 
 
 
 
+/**
+   \brief Get string from an input line widget
+
+   The function works for both older INPUT_LINE widget, as well as for
+   newer "SAFE_INPUT_LINE" widget.
+
+   String is trimmed from right side. Returned pointer is owned by
+   this function (by cdw_form, to be more precise). Do not free() it.
+
+   \param cdw_form - form in which an input line widget is embedded
+   \param fi - field index, index of the widget in the form
+
+   \return pointer to string stored in input line widget
+*/
 const char *cdw_form_get_string(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
-	FIELD *field = cdw_form->fields[fi];
-	cdw_assert (field != (FIELD *) NULL, "ERROR: field %d is NULL\n", fi);
 
-	char *string = (char *) NULL;
-	if (cdw_form->field_widget_types[fi] == CDW_WIDGET_INPUT) {
-		string = field_buffer(cdw_form->fields[fi], 0);
-		cdw_string_rtrim(string);
-		cdw_assert (string != (char *) NULL, "ERROR: field user pointer is NULL char (fi = %d)\n", fi);
-	}
+	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_SAFE_INPUT_LINE,
+
+		    "ERROR: field index %d: widget type is not input, is %s\n",
+		    fi, cdw_widgets_widget_type_label(cdw_form->field_widget_types[fi]));
+
+	cdw_assert (cdw_form->fields[fi], "ERROR: field %d is NULL\n", fi);
+
+
+	char *string = field_buffer(cdw_form->fields[fi], 0);
+	cdw_assert (string, "ERROR: field index %d: field user pointer is NULL\n", fi);
+	cdw_string_rtrim(string);
 
 	return string;
 }
@@ -589,17 +898,22 @@
 
 CDW_BUTTON *cdw_form_get_button(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
-	FIELD *field = cdw_form->fields[fi];
-	cdw_assert (field != (FIELD *) NULL, "ERROR: field %d is NULL\n", fi);
 
-	CDW_BUTTON *button = (CDW_BUTTON *) NULL;
-	if (cdw_form->field_widget_types[fi] == CDW_WIDGET_BUTTON) {
-		button = (CDW_BUTTON *) field_userptr(field);
-		cdw_assert (button != (CDW_BUTTON *) NULL, "ERROR: field user pointer is NULL button (fi = %d)\n", fi);
-	}
+	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_BUTTON,
+		    "ERROR: field index %d: widget type is not BUTTON, is %s\n",
+		    fi, cdw_widgets_widget_type_label(cdw_form->field_widget_types[fi]));
+
+	cdw_assert (cdw_form->fields[fi], "ERROR: field %d is NULL\n", fi);
+
+
+	CDW_BUTTON *button = (CDW_BUTTON *) field_userptr(cdw_form->fields[fi]);
+	cdw_assert (button, "ERROR: field index %d: field user pointer is NULL\n", fi);
+	cdw_assert (button->widget_id == CDW_WIDGET_ID_BUTTON,
+		    "ERROR: field index %d: internal widget id is not BUTTON, is %s\n",
+		    fi, cdw_widgets_widget_type_label(button->widget_id));
 
 	return button;
 }
@@ -610,19 +924,24 @@
 
 CDW_CHECKBOX *cdw_form_get_checkbox(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
-	FIELD *field = cdw_form->fields[fi];
-	cdw_assert (field != (FIELD *) NULL, "ERROR: field %d is NULL\n", fi);
 
-	CDW_CHECKBOX *checkbox = (CDW_CHECKBOX *) NULL;
-	if (cdw_form->field_widget_types[fi] == CDW_WIDGET_CHECKBOX) {
-		checkbox = (CDW_CHECKBOX *) field_userptr(field);
-		cdw_assert (checkbox != (CDW_CHECKBOX *) NULL, "ERROR: field user pointer is NULL checkbox (fi = %d)\n", fi);
-	}
+	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_CHECKBOX,
+		    "ERROR: field index %d: widget type is not CHECKBOX, is %s\n",
+		    fi, cdw_widgets_widget_type_label(cdw_form->field_widget_types[fi]));
+
+	cdw_assert (cdw_form->fields[fi], "ERROR: field %d is NULL\n", fi);
+
+
+	CDW_CHECKBOX *cb = (CDW_CHECKBOX *) field_userptr(cdw_form->fields[fi]);
+	cdw_assert (cb, "ERROR: field index %d: field user pointer is NULL\n", fi);
+	cdw_assert (cb->widget_id == CDW_WIDGET_ID_CHECKBOX,
+		    "ERROR: field index %d: internal widget id is not CHECKBOX, is %s\n",
+		    fi, cdw_widgets_widget_type_label(cb->widget_id));
 
-	return checkbox;
+	return cb;
 }
 
 
@@ -631,16 +950,11 @@
 
 bool cdw_form_is_checkbox_field_index(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
-	cdw_id_t type = cdw_form->field_widget_types[fi];
 
-	if (type == CDW_WIDGET_CHECKBOX) {
-		return true;
-	} else {
-		return false;
-	}
+	return cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_CHECKBOX;
 }
 
 
@@ -649,71 +963,63 @@
 
 bool cdw_form_is_dropdown_field_index(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
-	if (cdw_form->field_widget_types[fi] == CDW_WIDGET_DROPDOWN) {
-		return true;
-	} else {
-		return false;
-	}
+
+	return cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_DROPDOWN;
 }
 
 
 
 
 
-bool cdw_form_is_button_field_index(cdw_form_t *cdw_form, int fi)
+bool cdw_form_is_safe_input_line_index(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
-	return cdw_form->field_widget_types[fi] == CDW_WIDGET_BUTTON ? true : false;
+
+	return cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_SAFE_INPUT_LINE;
 }
 
 
 
 
 
-bool cdw_form_is_input_field_index(cdw_form_t *cdw_form, int fi)
+bool cdw_form_is_checkbox_index(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
-	return cdw_form->field_widget_types[fi] == CDW_WIDGET_INPUT ? true : false;
+
+	return cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_CHECKBOX;
 }
 
 
 
 
 
-/**
-   \brief Toggle state of checkbox
+bool cdw_form_is_button_field_index(cdw_form_t *cdw_form, int fi)
+{
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
+		    fi, cdw_form->n_fields);
 
-   Toggle state of checkbox that is placed in field with index\p fi.
-   Make sure that this is really a checkbox before calling the function.
+	return cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_BUTTON;
+}
 
-   Additionally the function shows/hides widgets in "tools" page as
-   state of related checkbox changes.
 
-   \param cdw_form - form in which a checkbox is placed
-   \param fi - field index, index of field of form, that is related to the checkbox
-*/
-void cdw_form_driver_toggle_checkbox(cdw_form_t *cdw_form, int fi)
+
+
+
+bool cdw_form_is_input_field_index(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_CHECKBOX,
-		    "ERROR: called the function for non-checkbox\n");
-	cdw_assert (fi < cdw_form->n_fields,
-		    "ERROR: fi is larger than number of fields: %d / %d\n",
+	cdw_assert (fi >= 0 && fi < cdw_form->n_fields,
+		    "ERROR: field index %d is out of range (n_fields = %d)\n",
 		    fi, cdw_form->n_fields);
 
-	CDW_CHECKBOX *checkbox = cdw_form_get_checkbox(cdw_form, fi);
-	cdw_checkbox_toggle(checkbox);
-	if (checkbox->on_toggle != (cdw_form_widget_function_t) NULL) {
-		bool state = cdw_checkbox_get_state(checkbox);
-		checkbox->on_toggle(cdw_form, &state);
-	}
-	return;
+	return cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_SAFE_INPUT_LINE;
 }
 
 
@@ -765,13 +1071,16 @@
 {
 	for (int i = 0; i < cdw_form->n_fields; i++) {
 		cdw_id_t id = cdw_form->field_widget_types[i];
-		if (id == CDW_WIDGET_CHECKBOX) {
+		if (id == CDW_WIDGET_ID_CHECKBOX) {
 			CDW_CHECKBOX *cb = cdw_form_get_checkbox(cdw_form, i);
 			cdw_checkbox_draw(cb);
-		} else if (id == CDW_WIDGET_BUTTON) {
+		} else if (id == CDW_WIDGET_ID_BUTTON) {
 			CDW_BUTTON *b = cdw_form_get_button(cdw_form, i);
+			/* TODO: what if the button has keyboard
+			   focus? With current code it would appear as
+			   not having the focus. */
 			cdw_button_unfocus(b);
-		} else if (id == CDW_WIDGET_DROPDOWN) {
+		} else if (id == CDW_WIDGET_ID_DROPDOWN) {
 			CDW_DROPDOWN *dd = cdw_form_get_dropdown(cdw_form, i);
 			cdw_dropdown_display_current_item(dd);
 		} else {
@@ -788,7 +1097,7 @@
 
 bool cdw_form_get_checkbox_state(cdw_form_t *cdw_form, int fi)
 {
-	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_CHECKBOX,
+	cdw_assert (cdw_form->field_widget_types[fi] == CDW_WIDGET_ID_CHECKBOX,
 		    "ERROR: trying to get state of field which isn't a CHECKBOX\n");
 
 	CDW_CHECKBOX *cb = cdw_form_get_checkbox(cdw_form, fi);
@@ -799,21 +1108,42 @@
 
 
 
-void *cdw_form_set_function(cdw_form_t *cdw_form, int fi, cdw_form_widget_function_t function)
+/**
+   \brief Set a callback function for a widget
+
+   For different widgets the callback is called on different actions.
+
+   In case of button widgets, use this function only to set some
+   interesting callback. A button's callback that only returns a key
+   pressed while keyboard focus was on the button (e.g. Escape or
+   Enter key) is not an interesting callback. To configure key
+   returned by button on such occasion, use
+   cdw_form_set_button_return_key().
+
+   An interesting callback function opens options window, reads
+   contents of file, displays file picker dialog. Use this function to
+   configure such an interesting callback for a widget.
+*/
+void *cdw_form_set_widget_callback(cdw_form_t *cdw_form, int fi, cdw_form_widget_function_t function)
 {
 	cdw_id_t id = cdw_form->field_widget_types[fi];
-	if (id == CDW_WIDGET_BUTTON) {
+	if (id == CDW_WIDGET_ID_BUTTON) {
 		CDW_BUTTON *b = field_userptr(cdw_form->fields[fi]);
-		b->on_click = function;
+		b->on_click_callback = function;
 		set_field_userptr(cdw_form->fields[fi], (void *) b);
 		return (void *) b;
-	} else if (id == CDW_WIDGET_CHECKBOX) {
+	} else if (id == CDW_WIDGET_ID_CHECKBOX) {
 		CDW_CHECKBOX *cb = field_userptr(cdw_form->fields[fi]);
-		cb->on_toggle = function;
+		cb->on_toggle_callback = function;
 		set_field_userptr(cdw_form->fields[fi], (void *) cb);
 		return (void *) cb;
+	} else if (id == CDW_WIDGET_ID_DROPDOWN) {
+		CDW_DROPDOWN *dd = field_userptr(cdw_form->fields[fi]);
+		dd->on_select_callback = function;
+		set_field_userptr(cdw_form->fields[fi], (void *) dd);
+		return (void *) dd;
 	} else {
-		cdw_assert(0, "ERROR: called the function for widget, which doesn't have a function to set\n");
+		cdw_assert (0, "ERROR: called the function for widget that doesn't have a callback\n");
 		return (void *) NULL;
 	}
 }
@@ -822,31 +1152,118 @@
 
 
 
-int cdw_form_handle_enter(cdw_form_t *cdw_form, int fi)
+/**
+   \brief Bind instances of two specific widgets together
+
+   Safe input line widget requires a reference to dynamic label widget
+   in order to work properly (to display error message on insecure
+   character). This function makes the connection.
+
+   The two widgets are embedded in a cdw form, so they are identified
+   by indexes referring to the form.
+
+   \param cdw_form - form in which the two widgets are embedded
+   \param safe_input_fi index of form field associated with CDW_WIDGET_ID_SAFE_INPUT_LINE widget
+   \param dynamic_label_fi index of form field associated with CDW_WIDGET_ID_DYNAMIC_LABEL widget
+*/
+void cdw_form_bind_input_and_label(cdw_form_t *cdw_form, int safe_input_fi, int dynamic_label_fi)
 {
-	if (cdw_form_is_button_field_index(cdw_form, fi)) {
-		CDW_BUTTON *b = cdw_form_get_button(cdw_form, fi);
-		return b->on_click((void *) cdw_form, (void *) NULL);
-	} else if (cdw_form_is_dropdown_field_index(cdw_form, fi)) {
-		CDW_DROPDOWN *dropdown = cdw_form_get_dropdown(cdw_form, fi);
-		cdw_assert (dropdown != (CDW_DROPDOWN *) NULL, "ERROR: dropdown is NULL\n");
-		int key = cdw_dropdown_driver(dropdown);
-		if (key == CDW_KEY_ENTER) {
-			const char *label = cdw_dropdown_get_current_item_label(dropdown);
-			FIELD **fields = form_fields(cdw_form->form);
-			/* setting buffer makes field to display
-			   string, but slightly moved to left */
-			set_field_buffer(*(fields + fi), 0, label);
+#if 0
+	cdw_id_t i_id = cdw_form->field_widget_types[safe_input_fi];
+	cdw_assert (i_id == CDW_WIDGET_ID_SAFE_INPUT_LINE, "ERROR: the widget is not safe input line\n");
+	cdw_id_t l_id = cdw_form->field_widget_types[dynamic_label_fi];
+	cdw_assert (l_id == CDW_WIDGET_ID_DYNAMIC_LABEL, "ERROR: the widget is not dynamic label\n");
+#endif
 
-			/* call to cdw_dropdown_focus() fixes it */
-			cdw_dropdown_focus(dropdown);
+	CDW_SAFE_INPUT_LINE *line = cdw_form_get_safe_input_line(cdw_form, safe_input_fi);
+	CDW_DYNAMIC_LABEL *label = cdw_form_get_dynamic_label(cdw_form, dynamic_label_fi);
 
-			form_driver(cdw_form->form, REQ_VALIDATION);
-		} else {
-			;
-		}
-		return 'a';
-	} else {
-		return 'a';
+	cdw_safe_input_line_bind_message_area(line, label);
+
+	set_field_userptr(cdw_form->fields[safe_input_fi], (void *) line);
+
+	return;
+}
+
+
+
+
+
+void *cdw_form_set_button_return_key(cdw_form_t *cdw_form, int fi, int return_key)
+{
+	cdw_id_t id = cdw_form->field_widget_types[fi];
+	cdw_assert (id == CDW_WIDGET_ID_BUTTON, "ERROR: trying to add return key for widget other than button (id = %lld / %s).\n", id, cdw_widgets_widget_type_label(id));
+
+	CDW_BUTTON *b = field_userptr(cdw_form->fields[fi]);
+	b->on_click_key = return_key;
+	set_field_userptr(cdw_form->fields[fi], (void *) b);
+	return (void *) b;
+}
+
+
+
+
+
+/**
+   \brief Replace a field in existing cdw_form with new field
+
+   To be more precise, old widget is replaced with new one. The
+   ncurses FIELD field is being recreated in the process as well.
+
+   Notice that the cdw_form is not recreated from scratch, just a part
+   of it.
+
+   In theory the function can replace old widget of any type with new
+   widget of any other type, but for now the function only works (and
+   has been tested) for old and new widget of type
+   CDW_WIDGET_ID_SAFE_INPUT_LINE.
+*/
+cdw_rv_t cdw_form_replace_field(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi, cdw_id_t old_widget_id, cdw_id_t new_widget_id)
+{
+	cdw_assert (old_widget_id == CDW_WIDGET_ID_SAFE_INPUT_LINE
+		    && old_widget_id == CDW_WIDGET_ID_SAFE_INPUT_LINE,
+		    "ERROR: for now only CDW_WIDGET_ID_SAFE_INPUT_LINE is supported\n");
+	/* TODO: add rest of constructors. */
+
+	cdw_assert (old_widget_id == cdw_form->field_widget_types[fi], "ERROR: old widget IDs don't match\n");
+
+
+	/* Delete old widget. */
+	if (old_widget_id == CDW_WIDGET_ID_SAFE_INPUT_LINE) {
+		CDW_SAFE_INPUT_LINE *line = cdw_form_get_safe_input_line(cdw_form, fi);
+		cdw_safe_input_line_delete(&line);
+	}
+
+
+	/* New ncurses FIELD field will be created in constructor
+	   function called after this free_field(). */
+	/* From ncurses docs: "The functions free_field() and
+	   free_form are available to free field and form objects.  It
+	   is an error to attempt to free a field connected to a form,
+	   but not vice-versa; thus, you will generally free your form
+	   objects first.".
+
+	   So first unpost form, then free form, then free field. */
+	int rv = unpost_form(cdw_form->form);
+	cdw_vdm_n ("unpost_form", rv, "");
+	rv = free_form(cdw_form->form);
+	cdw_vdm_n ("free_form", rv, "");
+	rv = free_field(cdw_form->fields[fi]);
+	cdw_vdm_n ("free_field", rv, "");
+
+
+	/* Create and insert new widget. */
+	if (new_widget_id == CDW_WIDGET_ID_SAFE_INPUT_LINE) {
+		cdw_form_description_to_safe_input_line(cdw_form, descr, fi);
 	}
+
+	cdw_form->form = cdw_ncurses_new_form(cdw_form->window,
+					      cdw_form->subwindow,
+					      cdw_form->fields);
+	/* Make new widget become visible and usable in cdw form. */
+	rv = set_form_fields(cdw_form->form, cdw_form->fields);
+	cdw_vdm ("INFO: set_form_fields() returns %s\n", cdw_ncurses_error_string(rv));
+	post_form(cdw_form->form);
+
+	return CDW_OK;
 }
diff -Naur orig/src/user_interface/cdw_form.h patched/src/user_interface/cdw_form.h
--- orig/src/user_interface/cdw_form.h	2011-04-10 12:09:08.000000000 +0200
+++ patched/src/user_interface/cdw_form.h	2014-03-20 20:37:10.000000000 +0100
@@ -5,9 +5,10 @@
 #include <stddef.h>
 
 #include "main.h"
+#include "cdw_widgets.h"
 #include "cdw_ncurses.h"
 #include "cdw_config.h"
-#include "cdw_widgets.h"
+
 
 
 /* this data structure is in "draft" version, it may change many times */
@@ -36,8 +37,11 @@
 	   client's responsibility to free this memory */
 	FORM *form;
 
-	/* TODO: make "form" and "fields" fields fully "owned" by cdw form */
-
+	/* TODO: make "form" and "fields" fields fully "owned" by cdw
+	   form: "form" and "fields" should be malloc()ed and free()d
+	   by cdw_form functions so that the client code doesn't have
+	   to care about these. Managing them should be totally hidden
+	   from client code.  */
 	int n_fields;
 	cdw_id_t *field_widget_types; /* table of widget types/IDs, allocated at runtime */
 
@@ -45,9 +49,6 @@
 
 	int return_keys[N_RETURN_KEYS_MAX];
 	int n_return_keys;
-
-	/* this one you have to initialize yourself */
-	int (* handle_enter)(cdw_form_t *cdw_form, int fi);
 };
 
 /* these are for "cdw form" data structure */
@@ -55,7 +56,9 @@
 void        cdw_form_delete_form_objects(cdw_form_t *cdw_form);
 void        cdw_form_delete(cdw_form_t **cdw_form);
 int         cdw_form_driver(cdw_form_t *cdw_form, int initial_fi);
+void        cdw_form_driver_focus_on(cdw_form_t *cdw_form, int fi);
 cdw_rv_t    cdw_form_description_to_fields(cdw_form_descr_t descr[], cdw_form_t *cdw_form);
+cdw_rv_t    cdw_form_description_to_safe_input_line(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi);
 void        cdw_form_add_return_char(cdw_form_t *form, int key);
 void        cdw_form_add_return_chars(cdw_form_t *form, ...);
 void        cdw_form_driver_go_to_field(cdw_form_t *cdw_form, int fi);
@@ -63,15 +66,21 @@
 bool cdw_form_is_movement_key(int key);
 
 
-CDW_DROPDOWN *cdw_form_get_dropdown(cdw_form_t *cdw_form, int fi);
-CDW_BUTTON   *cdw_form_get_button(cdw_form_t *cdw_form, int fi);
-CDW_CHECKBOX *cdw_form_get_checkbox(cdw_form_t *cdw_form, int fi);
-bool          cdw_form_get_checkbox_state(cdw_form_t *cdw_form, int fi);
-const char   *cdw_form_get_string(cdw_form_t *cdw_form, int fi);
+CDW_DROPDOWN        *cdw_form_get_dropdown(cdw_form_t *cdw_form, int fi);
+CDW_DYNAMIC_LABEL   *cdw_form_get_dynamic_label(cdw_form_t *cdw_form, int fi);
+CDW_SAFE_INPUT_LINE *cdw_form_get_safe_input_line(cdw_form_t *cdw_form, int fi);
+CDW_BUTTON          *cdw_form_get_button(cdw_form_t *cdw_form, int fi);
+CDW_CHECKBOX        *cdw_form_get_checkbox(cdw_form_t *cdw_form, int fi);
+bool                 cdw_form_get_checkbox_state(cdw_form_t *cdw_form, int fi);
+const char          *cdw_form_get_string(cdw_form_t *cdw_form, int fi);
+
 
+void  cdw_form_redraw_widgets(cdw_form_t *cdw_form);
+void *cdw_form_set_widget_callback(cdw_form_t *cdw_form, int fi, cdw_form_widget_function_t function);
+void *cdw_form_set_button_return_key(cdw_form_t *cdw_form, int fi, int return_key);
+void  cdw_form_bind_input_and_label(cdw_form_t *cdw_form, int safe_input_fi, int dynamic_label_fi);
 
-void cdw_form_redraw_widgets(cdw_form_t *cdw_form);
-void *cdw_form_set_function(cdw_form_t *cdw_form, int fi, cdw_form_widget_function_t function);
+cdw_rv_t cdw_form_replace_field(cdw_form_t *cdw_form, cdw_form_descr_t *descr, int fi, cdw_id_t old_widget_id, cdw_id_t new_widget_id);
 
 typedef CDW_DROPDOWN * (* cdw_form_dropdown_maker_t)(WINDOW *window, int begin_y, int begin_x, int width);
 typedef char         * (* cdw_form_text_maker_t)(int n_cols);
diff -Naur orig/src/user_interface/cdw_help.c patched/src/user_interface/cdw_help.c
--- orig/src/user_interface/cdw_help.c	2012-03-06 20:31:36.000000000 +0100
+++ patched/src/user_interface/cdw_help.c	2014-03-24 22:20:13.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include "cdw_main_window.h"
@@ -24,7 +24,7 @@
 #include "gettext.h"
 #include "cdw_help.h"
 #include "cdw_debug.h"
-
+#include "cdw_string.h"
 
 
 
@@ -52,7 +52,7 @@
 					/* 2TRANS: this is message at the
 					   bottom of help window */
 					_("Press ESCAPE to close window"));
-	if (window == (WINDOW *) NULL) {
+	if (!window) {
 		cdw_vdm ("ERROR: failed to create window for help panel\n");
 		return;
 	}
@@ -114,7 +114,7 @@
 
 	cdw_window_delete(&window);
 
-	cdw_main_ui_main_window_wrefresh_part(n_lines, n_cols, begin_y, begin_x);
+	cdw_main_window_wrefresh_part(n_lines, n_cols, begin_y, begin_x);
 
 	return;
 }
@@ -158,8 +158,8 @@
 
 void display_tooltip(int item)
 {
-	WINDOW *subwindow = cdw_main_ui_get_tooltips_subwindow();
-	cdw_assert (subwindow != (WINDOW *) NULL, "ERROR: tooltips subwindow is not initialized yet\n");
+	WINDOW *subwindow = cdw_main_window_get_tooltips_subwindow();
+	cdw_assert (subwindow, "ERROR: tooltips subwindow is not initialized yet\n");
 
 	werase(subwindow);
 	switch(item) {
@@ -173,7 +173,7 @@
 			break;
 		case CDW_MENU_CREATE_IMAGE:
 			/* 2TRANS: this is tooltip displayed at the bottom of main cdw window */
-			cdw_window_print_message(subwindow, _("Create ISO9660 image from selected files."), CDW_ALIGN_LEFT);
+			cdw_window_print_message(subwindow, _("Create ISO9660 or UDF image from selected files."), CDW_ALIGN_LEFT);
 			break;
 		case CDW_MENU_RIP_DISC:
 			/* 2TRANS: this is tooltip displayed at the bottom of main cdw window */
@@ -199,6 +199,10 @@
 			/* 2TRANS: this is tooltip displayed at the bottom of main cdw window */
 			cdw_window_print_message(subwindow, _("cdw configuration: hardware, external tools and other."), CDW_ALIGN_LEFT);
 			break;
+	        case CDW_MENU_ABOUT:
+			/* 2TRANS: this is tooltip displayed at the bottom of main cdw window */
+			cdw_window_print_message(subwindow, _("About cdw: display short information about this program."), CDW_ALIGN_LEFT);
+			break;
 		case CDW_MENU_EXIT_CDW:
 			/* 2TRANS: this is tooltip displayed at the bottom of main cdw window */
 			cdw_window_print_message(subwindow, _("Close this program, return to command line session."), CDW_ALIGN_LEFT);
@@ -207,10 +211,8 @@
 			werase(subwindow);
 			break;
 	}
-	wrefresh(subwindow);
+	int rv = wrefresh(subwindow);
+	cdw_vdm_n ("wrefresh", rv, "");
 
 	return;
 }
-
-
-
diff -Naur orig/src/user_interface/cdw_image_wizard.c patched/src/user_interface/cdw_image_wizard.c
--- orig/src/user_interface/cdw_image_wizard.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/user_interface/cdw_image_wizard.c	2014-04-12 20:22:55.000000000 +0200
@@ -0,0 +1,1335 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+   \file cdw_image_wizard.c
+
+   Wizard for creating ISO9660 or UDF stand-alone image files.
+
+   Most options are available in separate window, opened by clicking
+   "Options" window in wizard. The only options available in main
+   window of the wizard are image format (ISO9660/UDF), image volume
+   string, and path to image file.
+
+   The wizard does not change file extension in image file path if
+   user changes image format.
+*/
+
+#define _GNU_SOURCE /* asprintf() */
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "cdw_file_picker.h"
+#include "cdw_config_window.h"
+#include "gettext.h"
+#include "cdw_string.h"
+#include "cdw_widgets.h"
+#include "cdw_ncurses.h"
+#include "cdw_window.h"
+#include "cdw_main_window.h"
+#include "cdw_debug.h"
+#include "cdw_ext_tools.h"
+#include "cdw_form.h"
+#include "cdw_task.h"
+#include "cdw_mkisofs_options.h"
+#include "cdw_mkisofsrc.h"
+#include "cdw_xorriso_options.h"
+#include "cdw_xorrisorc.h"
+#include "cdw_mkudffs_options.h"
+#include "cdw_tabs_window.h"
+#include "cdw_image_wizard.h"
+#include "cdw_udf.h"
+#include "cdw_iso9660.h"
+
+
+enum field_ids {
+	f_image_format_l = 0,
+	f_image_format_dd,
+	f_volume_id_l,
+	f_volume_id_i,
+	f_image_file_l,
+	f_image_file_i,
+	f_image_file_b,
+	f_options_b,
+	f_create_b,
+	f_cancel_b,
+};
+
+
+/* Does not include guard. */
+#define CDW_IMAGE_WIZARD_N_FIELDS 10
+
+/* ISO9660 + UDF = 2 */
+#define CDW_IMAGE_WIZARD_FORMATS_MAX 2
+
+
+
+static cdw_id_clabel_t cdw_img_wizard_formats[CDW_IMAGE_WIZARD_FORMATS_MAX] = {
+	/* 2TRANS: ISO9660 optical image file format. */
+	{ CDW_IMAGE_FORMAT_ISO9660,   gettext_noop("ISO9660") },
+	/* 2TRANS: UDF optical image file format. */
+	{ CDW_IMAGE_FORMAT_UDF,       gettext_noop("UDF") },
+};
+
+
+
+static cdw_rv_t cdw_image_wizard_init(cdw_task_t *task);
+static cdw_rv_t cdw_image_wizard_build(cdw_task_t *task);
+static void     cdw_image_wizard_destroy(void);
+static int      cdw_image_wizard_driver(void);
+static cdw_rv_t cdw_image_wizard_build_fields(cdw_task_t *task);
+static cdw_rv_t cdw_image_wizard_validate_and_save(cdw_task_t *task, int *fi);
+
+
+static int      cdw_image_wizard_options_window_show(cdw_id_t *pid, int *fi);
+static cdw_rv_t cdw_image_wizard_options_window_sub(cdw_task_t *task, cdw_id_t *pid, int *fi);
+static int      cdw_image_wizard_options_window_by_callback(cdw_form_t *cdw_form, void *dummy);
+static int      cdw_image_wizard_options_window_by_flow(cdw_id_t *pid, int *fi);
+static int      cdw_image_wizard_options_window_driver(cdw_task_t *task);
+static void     cdw_image_wizard_options_window_destroy(void);
+
+
+static cdw_rv_t cdw_image_wizard_options_save(cdw_task_t *task);
+static cdw_rv_t cdw_image_wizard_options_validate(cdw_task_t *task, cdw_id_t *page_id, int *fi);
+static cdw_rv_t cdw_image_wizard_options_validate_closed(cdw_task_t *task);
+
+
+static int cdw_image_wizard_image_file_selector(void *dummy1, void *dummy2);
+static int cdw_image_wizard_on_select_image_format(void *dummy1, void *vid);
+static void cdw_image_wizard_on_select_image_format_sub(cdw_form_descr_t *volume_line, const char *label_text);
+
+static void cdw_image_wizard_recreate_volume_id_input(cdw_form_t *cdw_form);
+
+static void cdw_image_wizard_debug_at_exit(cdw_task_t *task);
+CDW_DROPDOWN *cdw_img_wizard_make_image_format_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+
+
+static struct {
+	/* Form used in main window of image wizard. Forms used in
+	   "Options" window tabs are elsewhere. */
+	cdw_form_t *cdw_form;
+
+	/* UDF/ISO9660. */
+	cdw_id_t image_format;
+
+	cdw_task_t *task;
+
+	FIELD *fields[CDW_IMAGE_WIZARD_N_FIELDS + 1];
+
+	/* Text displayed at the bottom of Options window. So it
+	   doesn't belong to wizard, rather to Options window. */
+	char *window_tip;
+
+} wizard;
+
+
+
+
+static cdw_form_dropdown_maker_t main_dropdown_makers[] = {
+	cdw_img_wizard_make_image_format_dropdown
+};
+
+
+
+/* Some layout constraints. */
+static const int first_col =  2;  /* Most of widgets start in leftmost column. */
+static const int vid_row   =  4;  /* Volume ID row. */
+
+
+#define window_n_cols             52
+#define window_n_lines            20
+#define subwindow_n_cols           (window_n_cols - 2)
+#define subwindow_n_lines          (window_n_lines - 4)
+#define wide_label_n_cols          (subwindow_n_cols - 2)
+#define narrow_label_n_cols        (subwindow_n_cols - 15)
+
+/* The "voli" field will contain "Volume Identifier" for ISO9660 or "Logical
+   Volume Identifier" for UDF file system. I would like the field to
+   display full string (without any visual truncation) for at least
+   the shorter of the two IDs.
+
+   The maximal length for ISO9660 is much smaller than for UDF, so the
+   width (not capacity!) of the field will be equal to maximal length
+   of ISO9660 volume identifier. */
+#define voli_field_n_cols          CDW_ISO9660_VOLI_LEN
+
+
+
+
+
+/**
+   \brief Ncurses window showing summary of prepared "create image" task
+
+   A window that shows 'You are creating image' message and some basic
+   options. User can press 'More options' button to see and change
+   other options. Two other buttons available are 'Create' and
+   'Cancel'.
+
+   \param task - variable describing current task
+
+   \return CDW_IMAGE_FORMAT_ISO9660 or CDW_IMAGE_FORMAT_UDF if user selects 'Create' button
+   \return CDW_IMAGE_FORMAT_NONE if user presses Escape key or selects 'Cancel' button
+   \return CDW_IMAGE_FORMAT_ERROR on errors
+*/
+int cdw_image_wizard(cdw_task_t *task)
+{
+	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE_ISO9660
+		    || task->id == CDW_TASK_CREATE_IMAGE_UDF,
+		    "ERROR: incorrect task id %lld\n", task->id);
+
+	cdw_rv_t crv = cdw_image_wizard_init(task);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to init wizard\n");
+		cdw_image_wizard_destroy();
+		return CDW_IMAGE_FORMAT_ERROR;
+	}
+	crv = cdw_image_wizard_build(task);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build wizard\n");
+		cdw_image_wizard_destroy();
+		cdw_main_window_wrefresh();
+		return CDW_IMAGE_FORMAT_ERROR;
+	}
+
+	int rv = cdw_image_wizard_driver();
+
+	cdw_image_wizard_destroy();
+	cdw_main_window_wrefresh();
+
+	if (rv == CDW_KEY_ENTER) {
+		/* Enter == Enter on Create button == proceed with
+		   creating image file. */
+
+#ifndef NDEBUG
+		cdw_image_wizard_debug_at_exit(task);
+#endif
+		return (int) wizard.image_format;
+	} else {
+		cdw_sdm ("INFO: not attempting creating image, not displaying settings\n");
+		return CDW_IMAGE_FORMAT_NONE;
+	}
+}
+
+
+
+
+
+/**
+   \brief Set initial values of some variables global in the file
+
+   Function sets values of various fields of "wizard" variable.
+*/
+cdw_rv_t cdw_image_wizard_init(cdw_task_t *task)
+{
+	wizard.task = task;
+
+	wizard.image_format = CDW_IMAGE_FORMAT_NONE;
+
+	wizard.cdw_form = cdw_form_new(CDW_IMAGE_WIZARD_N_FIELDS);
+	if (!wizard.cdw_form) {
+		cdw_vdm ("ERROR: failed to create cdw form\n");
+		return CDW_ERROR;
+	}
+
+	wizard.cdw_form->fields = wizard.fields;
+	for (int i = 0; i < CDW_IMAGE_WIZARD_N_FIELDS; i++ ) {
+		wizard.cdw_form->fields[i] = (FIELD *) NULL;
+	}
+
+	wizard.window_tip = (char *) NULL;
+
+	return CDW_OK;
+}
+
+
+
+
+
+int cdw_image_wizard_driver(void)
+{
+	int fi = f_cancel_b; /* Initial focus on "Cancel" button. */
+	int key = 'a';
+
+	while (key != CDW_KEY_ESCAPE && key != 'q' && key != 'Q') {
+		key = cdw_form_driver(wizard.cdw_form, fi);
+
+		/* In top-level driver of wizard we are mainly
+		   interested in ENTER being pressed on either "create"
+		   or "cancel" button. */
+		if (key == CDW_KEY_ENTER) {
+			fi = field_index(current_field(wizard.cdw_form->form));
+			/* The form and driver are designed so that
+			   Enter is returned only upon pressing
+			   "Create" button. */
+			cdw_assert (fi == f_create_b, "ERROR: driver returns KEY_ENTER for widget other than create (%d)\n", fi);
+
+			/* Flush. */
+			form_driver(wizard.cdw_form->form, REQ_VALIDATION);
+
+			/* Check options in closed "Options" window. */
+			cdw_rv_t crv = cdw_image_wizard_options_validate_closed(wizard.task);
+			if (crv != CDW_OK) {
+				return CDW_KEY_ESCAPE;
+			}
+
+			/* Check options in main wizard window. */
+			crv = cdw_image_wizard_validate_and_save(wizard.task, &fi);
+			if (crv == CDW_NO) {
+				/* one of option strings in main
+				   wizard window is invalid */
+
+				/* 2TRANS: this is title of dialog window */
+				cdw_buttons_dialog(_("Error"),
+						   /* 2TRANS: this is message in dialog window */
+						   _("One of option fields is incorrect or contains character that is not allowed. Please fix it."),
+						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+
+				cdw_form_driver_go_to_field(wizard.cdw_form, fi);
+				/* Loop. */
+			} else {
+				/* Fields from Options window and from
+				   main page of the wizard are
+				   validated and saved into task
+				   variable. */
+				return CDW_KEY_ENTER;
+			}
+		} else if (key == CDW_KEY_ESCAPE) {
+			/* Either "Cancel" button pressed (which is
+			   configured to return Escape), or "Escape"
+			   key anywhere else. The result is the
+			   same. */
+			return CDW_KEY_ESCAPE;
+		} else {
+			/* Some unspecified key. */
+		}
+	}
+
+	return CDW_KEY_ESCAPE;
+}
+
+
+
+
+
+/**
+   \brief Deallocate all resources allocated by "create image" wizard
+*/
+void cdw_image_wizard_destroy(void)
+{
+	/* This order of these four function calls minimizes number of
+	   problems reported by valgrind. */
+	cdw_form_delete_form_objects(wizard.cdw_form);
+	cdw_window_delete(&wizard.cdw_form->subwindow);
+	cdw_window_delete(&wizard.cdw_form->window);
+	cdw_form_delete(&wizard.cdw_form);
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Print to stderr values of \p task fields set in "create image" wizard
+
+   \param task - task variable, in which some fields were set in "create image" wizard
+*/
+void cdw_image_wizard_debug_at_exit(cdw_task_t *task)
+{
+	cdw_task_debug_print_options(task, "at image wizard exit");
+	return;
+}
+
+
+
+
+
+/**
+   \brief Create all UI elements in wizard window
+
+   \param task - variable describing current task
+   \param disc - variable describing disc currently in drive
+
+   \return CDW_OK on success
+   \return CDW_ERROR on failure
+*/
+cdw_rv_t cdw_image_wizard_build(cdw_task_t *task)
+{
+	int begin_y = ((LINES - window_n_lines) / 2) - 2;
+	int begin_x = (COLS - window_n_cols) / 2;
+	wizard.cdw_form->window =
+		cdw_window_new((WINDOW *) NULL,
+			       window_n_lines, window_n_cols,
+			       begin_y, begin_x,
+			       CDW_COLORS_DIALOG,
+			       /* 2TRANS: this is title of wizard
+				  window; */
+			       _("Image wizard"),
+			       /* 2TRANS: this is tip at the bottom
+				  of window - user can switch between
+				  window elements using tab key */
+			       _("Use 'Tab' key to move"));
+
+	if (!wizard.cdw_form->window) {
+		cdw_vdm ("ERROR: failed to create window\n");
+		return CDW_ERROR;
+	}
+
+	wizard.cdw_form->subwindow =
+		cdw_window_new(wizard.cdw_form->window,
+			       subwindow_n_lines, subwindow_n_cols,
+			       3, 1,
+			       CDW_COLORS_DIALOG,
+			       (char *) NULL, (char *) NULL);
+
+	if (!wizard.cdw_form->subwindow) {
+		cdw_vdm ("ERROR: failed to create subwindow\n");
+		return CDW_ERROR;
+	}
+
+	cdw_rv_t crv = cdw_image_wizard_build_fields(task);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build fields\n");
+		return CDW_ERROR;
+	}
+
+	wizard.cdw_form->form = cdw_ncurses_new_form(wizard.cdw_form->window,
+						     wizard.cdw_form->subwindow,
+						     wizard.cdw_form->fields);
+	if (!wizard.cdw_form->form) {
+		cdw_vdm ("ERROR: failed to create form\n");
+		return CDW_ERROR;
+	}
+
+
+	/* Check current value in "image format" dropdown, and make an
+	   input field of appropriate width. */
+	cdw_image_wizard_recreate_volume_id_input(wizard.cdw_form);
+
+	/* Make sure that cdw widgets are presented properly. */
+	cdw_form_redraw_widgets(wizard.cdw_form);
+
+
+	wrefresh(wizard.cdw_form->subwindow);
+	wrefresh(wizard.cdw_form->window);
+
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_image_wizard_build_fields(cdw_task_t *task)
+{
+	int iso_button_col = first_col + wide_label_n_cols - 5;
+
+	cdw_form_descr_t descr[] = {
+		/* type                       begin_y    begin_x              n_cols             n_lines   field enum          data1                             data2 */
+
+		/* 2TRANS: this is label next to input field, where user can select format of image: ISO9660 or UDF. */
+		{ CDW_WIDGET_ID_STATIC_LABEL,       1,   first_col,           wide_label_n_cols,       1,  f_image_format_l,   _("Image format:"),                  0 },
+		{ CDW_WIDGET_ID_DROPDOWN,           2,   first_col,           narrow_label_n_cols,     1,  f_image_format_dd,  main_dropdown_makers,                0 },
+
+		/* 2TRANS: this is label next to input field, where user can enter a label describing created IMAGE volume */
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,      vid_row,     first_col,   wide_label_n_cols,       1,  f_volume_id_l,      _("Volume ID:"),                     0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,    vid_row + 1, first_col,   voli_field_n_cols,       1,  f_volume_id_i,      task->create_image.iso9660.volume_id,    CDW_ISO9660_VOLI_LEN },
+
+		/* 2TRANS: this is label next to input field, where user can specify path to ISO9660 or UDF file on disc. */
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,      7,   first_col,           wide_label_n_cols - 2,   1,  f_image_file_l,     _("Output image file:"),             0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,    8,   first_col,           wide_label_n_cols - 8,   1,  f_image_file_i,     task->image_file_fullpath,           0 },
+
+		/* 2TRANS: do not translate */
+		{ CDW_WIDGET_ID_BUTTON,             8,   iso_button_col,      1,                       1,  f_image_file_b,     _(">"),              CDW_COLORS_DIALOG },
+
+		/* 2TRANS: this is label of a button that opens configuration window; "more options" related to creating IMAGE file */
+		{ CDW_WIDGET_ID_BUTTON,            11,   first_col,           1,                       1,  f_options_b,        _("More options"),   CDW_COLORS_DIALOG },
+
+		/* 2TRANS: button label, it refers to creating ISO9660 or UDF image. */
+		{ CDW_WIDGET_ID_BUTTON,            14,   3,                   2,                       1,  f_create_b,         _("Create"),         CDW_COLORS_DIALOG },
+		/* 2TRANS: button label */
+		{ CDW_WIDGET_ID_BUTTON,            14,  15,                   2,                       1,  f_cancel_b,         _("Cancel"),         CDW_COLORS_DIALOG },
+
+		/* guard */
+		{ -1,                               0,   0,                   0,                       0,  0,                  (void *) NULL,                       0 }};
+
+
+	wizard.cdw_form->n_fields = CDW_IMAGE_WIZARD_N_FIELDS;
+
+	cdw_rv_t crv = cdw_form_description_to_fields(descr, wizard.cdw_form);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to convert form description to form\n");
+		return CDW_ERROR;
+	} else {
+		cdw_form_add_return_chars(wizard.cdw_form, CDW_KEY_ENTER, CDW_KEY_ESCAPE, 'q', 'Q', 0);
+
+		cdw_form_set_button_return_key(wizard.cdw_form, f_create_b, CDW_KEY_ENTER);
+		cdw_form_set_button_return_key(wizard.cdw_form, f_cancel_b, CDW_KEY_ESCAPE);
+
+		cdw_form_set_widget_callback(wizard.cdw_form, f_image_file_b,    (cdw_form_widget_function_t) cdw_image_wizard_image_file_selector);
+		cdw_form_set_widget_callback(wizard.cdw_form, f_options_b,       (cdw_form_widget_function_t) cdw_image_wizard_options_window_by_callback);
+		cdw_form_set_widget_callback(wizard.cdw_form, f_image_format_dd, (cdw_form_widget_function_t) cdw_image_wizard_on_select_image_format);
+
+		cdw_form_bind_input_and_label(wizard.cdw_form, f_volume_id_i, f_volume_id_l);
+		cdw_form_bind_input_and_label(wizard.cdw_form, f_image_file_i, f_image_file_l);
+
+		return CDW_OK;
+	}
+}
+
+
+
+
+
+int cdw_image_wizard_options_window_by_callback(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
+{
+	return cdw_image_wizard_options_window_show((cdw_id_t *) NULL, (int *) NULL);
+}
+
+
+
+
+
+int cdw_image_wizard_options_window_by_flow(cdw_id_t *pid, int *fi)
+{
+	return cdw_image_wizard_options_window_show(pid, fi);
+}
+
+
+
+
+
+int cdw_image_wizard_options_window_show(cdw_id_t *pid, int *fi)
+{
+	CDW_DROPDOWN *dd = cdw_form_get_dropdown(wizard.cdw_form, f_image_format_dd);
+	cdw_assert (dd, "ERROR: image format dd is NULL (field id = %d)\n", f_image_format_dd);
+
+	/* FIXME: possible error: where is the code that prevents
+	   creating wizard when cdw can't find any tools for creating
+	   image of any format? The code should be in cdw_task module -
+	   creating new task should fail if external_tools module
+	   can't provide any tools. */
+	cdw_assert (dd->n_items, "ERROR: wizard created when no tools for stand-alone are available\n");
+
+	wizard.image_format = cdw_dropdown_get_current_item_id(dd);
+	cdw_vdm ("INFO: image format = %lld\n", wizard.image_format);
+
+
+	cdw_rv_t crv = cdw_image_wizard_options_window_sub(wizard.task, pid, fi);
+
+	cdw_main_window_wrefresh();
+
+	redrawwin(wizard.cdw_form->window);
+	redrawwin(wizard.cdw_form->subwindow);
+	wrefresh(wizard.cdw_form->window);
+	wrefresh(wizard.cdw_form->subwindow);
+
+	/* the function needs to return int representing a char */
+	if (crv == CDW_OK) {
+		return '1';
+	} else {
+		return '0';
+	}
+}
+
+
+
+
+
+int cdw_image_wizard_image_file_selector(__attribute__((unused)) void *dummy1, __attribute__((unused)) void *dummy2)
+{
+	/* 2TRANS: this is title of dialog window */
+	cdw_rv_t crv = cdw_fs_ui_file_picker(_("Path to image file"),
+					     /* 2TRANS: this is message in dialog window;
+					     below it there is an input field where user can
+					     enter path to ISO9660 or UDF image file */
+					     _("Please enter FULL path to new image file:"),
+					     &(wizard.task->image_file_fullpath),
+					     CDW_FS_FILE, R_OK | W_OK, CDW_FS_NEW | CDW_FS_EXISTING);
+
+	cdw_main_window_wrefresh();
+
+	redrawwin(wizard.cdw_form->window);
+	wrefresh(wizard.cdw_form->window);
+	redrawwin(wizard.cdw_form->subwindow);
+	wrefresh(wizard.cdw_form->subwindow);
+
+	char *fp = wizard.task->image_file_fullpath;
+	if (crv == CDW_OK) {
+		int rv = set_field_buffer(wizard.cdw_form->fields[f_image_file_i], 0, fp);
+		if (rv != E_OK) {
+			cdw_vdm ("ERROR: failed to set field buffer with string = \"%s\"\n", fp);
+		} else {
+			form_driver(wizard.cdw_form->form, REQ_END_LINE);
+		}
+		cdw_vdm ("INFO: file picker returns \"%s\"\n", fp);
+		return '1';
+	} else if (crv == CDW_CANCEL) {
+		cdw_vdm ("INFO: pressed escape in file picker, fullpath is \"%s\"\n", fp);
+		return '0';
+	} else {
+		cdw_vdm ("INFO: file picker returns CDW_ERROR, fullpath is \"%s\"\n", fp);
+		return '0';
+	}
+}
+
+
+
+
+
+/*
+  Change of image format involves changing of "volume ID" input
+  field. The ID has different maximum length depending on image
+  format. I have to change the maximal capacity of the input field
+  accordingly.
+
+  While ncurses allows me to increase the capacity (with
+  set_max_field()), it doesn't allow me to decrease it. As a
+  workaround I have to delete old ncurses field, and create new
+  one. But then I have to inform ncurses form that there has been a
+  change in fields table.
+
+  This is why I have free_field() -> unpost_form() ->
+  set_form_fields() -> post_form().
+*/
+int cdw_image_wizard_on_select_image_format(__attribute__((unused)) void *dummy1, void *vid)
+{
+	/* ID of currently selected list item. */
+	cdw_id_t *id = (cdw_id_t *) vid;
+	cdw_assert (*id == CDW_IMAGE_FORMAT_ISO9660
+		    || *id == CDW_IMAGE_FORMAT_UDF,
+
+		    "ERROR: invalid image format %lld\n", *id);
+
+	wizard.image_format = *id;
+
+	CDW_SAFE_INPUT_LINE *line = cdw_form_get_safe_input_line(wizard.cdw_form, f_volume_id_i);
+
+	/* The "" string is used in form description because upon
+	   changing capacity of input field from 126 to 32 chars I may
+	   truncate the string. In some situations the truncation
+	   won't be obvious to the user, so he will notice the fact
+	   only after creating the image (or burning the disc).
+
+	   Completely erasing the ID string is more noticeable and
+	   will hopefully prompt user to enter correct ID. */
+
+	/* Initial value of .data2 in volume_line doesn't matter, it
+	   will be overwritten inside
+	   cdw_image_wizard_on_select_image_format_sub() with proper
+	   value before volume_line will be used to create new input
+	   line. */
+	/*                               type                           begin_y      begin_x    n_cols             n_lines   field enum      data1   data2  */
+	cdw_form_descr_t volume_line = { CDW_WIDGET_ID_SAFE_INPUT_LINE, vid_row + 1, first_col, voli_field_n_cols, 1,        f_volume_id_i,  _(""),  CDW_UDF_LVID_LEN_MAX };
+
+	if (*id == CDW_IMAGE_FORMAT_ISO9660) {
+
+		if (line->chars_max == CDW_ISO9660_VOLI_LEN) {
+			/* The input line already has proper width, so
+			   we assume that it is an input field
+			   suitable for ISO9660 volume label. Don't
+			   replace it with new input field. */
+		} else {
+			cdw_vdm ("INFO: replacing input field with field for ISO9660\n");
+
+			cdw_assert (CDW_ISO9660_VOLI_LEN == 32, "ERROR: wrong value of volume len\n");
+			/* Proper length limit (capacity) of input line. */
+			volume_line.data2 = CDW_ISO9660_VOLI_LEN;
+			cdw_image_wizard_on_select_image_format_sub(&volume_line, "Volume ID (32 chars max)");
+		}
+
+		wizard.task->id = CDW_TASK_CREATE_IMAGE_ISO9660;
+
+		/* As the selected image format changes, so should the
+		   tool change as well. */
+		/* Do the tool selection even if the 'if ()' above is
+		   true - this function may be called in wizard
+		   initialization, where tool is not set yet. */
+		bool sel = cdw_ext_tools_set_iso9660_sa_tool(&wizard.task->create_image.tool);
+		cdw_assert (sel, "ERROR: failed to get tool for sa ISO9660 FS\n");
+		cdw_vdm ("INFO: TASK ID = ISO9660, tool = %s\n", wizard.task->create_image.tool.label);
+
+	} else { /* Current selection of "Image format" dropdown is UDF. */
+
+		if (line->chars_max == CDW_UDF_LVID_LEN_MAX) {
+			/* The input line already has proper width, so
+			   we assume that it is an input field
+			   suitable for UDF volume label. Don't
+			   replace it with new input field. */
+		} else {
+			cdw_vdm ("INFO: replacing input field with field for UDF\n");
+
+			cdw_assert (CDW_UDF_LVID_LEN_MAX == 126, "ERROR: wrong value of volume len\n");
+			/* Proper length limit (capacity) of input line. */
+			volume_line.data2 = CDW_UDF_LVID_LEN_MAX;
+			cdw_image_wizard_on_select_image_format_sub(&volume_line, "Logical Volume ID (126 chars max)");
+		}
+
+		wizard.task->id = CDW_TASK_CREATE_IMAGE_UDF;
+
+		/* As the selected image format changes, so should the
+		   tool change as well. */
+		/* Do the tool selection even if the 'if ()' above is
+		   true - this function may be called in wizard
+		   initialization, where tool is not set yet. */
+		bool sel = cdw_ext_tools_set_udf_sa_tool(&wizard.task->create_image.tool);
+		cdw_assert (sel, "ERROR: failed to get tool for stand-alone UDF file system\n");
+		cdw_vdm ("INFO: TASK ID = UDF, tool = %s\n", wizard.task->create_image.tool.label);
+	}
+
+	return 0;
+}
+
+
+
+
+
+void cdw_image_wizard_on_select_image_format_sub(cdw_form_descr_t *volume_line, const char *label_text)
+{
+	/* First replace old input field with new one, that has
+	   correct capacity. The capacity is already configured by
+	   caller as volume_line.data2. */
+	cdw_form_replace_field(wizard.cdw_form, volume_line, f_volume_id_i, CDW_WIDGET_ID_SAFE_INPUT_LINE, CDW_WIDGET_ID_SAFE_INPUT_LINE);
+
+
+	/* Update the text of dynamic label widget. It can be done at
+	   any time, the widget should accept a new label at any time
+	   of its life, regardless if the widget is bound to any input
+	   field or not. */
+	CDW_DYNAMIC_LABEL *label = cdw_form_get_dynamic_label(wizard.cdw_form, f_volume_id_l);
+	cdw_dynamic_label_set_new(label, label_text);
+	cdw_form_bind_input_and_label(wizard.cdw_form, f_volume_id_i, f_volume_id_l);
+
+
+	/* Make sure that all cdw widgets in the form are presented
+	   properly. */
+	cdw_form_redraw_widgets(wizard.cdw_form);
+
+	int current_fi = field_index(current_field(wizard.cdw_form->form));
+	cdw_form_driver_focus_on(wizard.cdw_form, current_fi);
+
+	return;
+}
+
+
+
+
+
+/* Depending on state of "image format" dropdown, set up proper input
+   field and label for "volume id". */
+void cdw_image_wizard_recreate_volume_id_input(cdw_form_t *cdw_form)
+{
+	CDW_DROPDOWN *dd = cdw_form_get_dropdown(cdw_form, f_image_format_dd);
+	cdw_id_t id = cdw_dropdown_get_current_item_id(dd);
+
+	cdw_image_wizard_on_select_image_format(NULL, &id);
+
+	return;
+}
+
+
+
+
+
+
+/* some size and layout constants */
+/* width and height of main options window can't be smaller
+   than size of minimal supported terminal */
+
+/** \brief Width of options window */
+#define OPTIONS_WIDTH 80
+/** \brief Height of options window */
+#define OPTIONS_HEIGHT 24
+/** \brief Width of right-hand area with tabs */
+#define TABS_WIDTH 23
+/** \brief Width of (most) labels in options window */
+#define LABEL_WIDTH 30
+/** \brief Width of some fields that should be as wide as possible: input
+    fields storing file path, some dropdowns, "other options" fields,
+    txt subwins, long labels */
+#define WIDE_FIELD_WIDTH (OPTIONS_WIDTH - TABS_WIDTH - 4)
+/** \brief Window column of first column of items in options page  */
+#define FIRST_COL 1
+/** \brief Window column of second column of items in options page  */
+#define SECOND_COL (FIRST_COL + LABEL_WIDTH + 2)
+
+
+
+/* We may create three different "options" windows:
+
+   - first type for mkisofs (with main options and with meta-data read
+     from rc file),
+
+   - second type for xorriso (with main options and with meta-data
+     read from rc file);
+
+   - third type for mkudffs (with main options (for mkudffs and its
+     helpers) and with udf meta-data);
+
+   Each window type has N pages. We need to distinguish the pages with
+   these IDs. */
+#define IMAGE_PAGE_ID_MKISOFS_ISO_MAIN    0
+#define IMAGE_PAGE_ID_MKISOFS_ISO_META    1
+#define IMAGE_PAGE_ID_XORRISO_ISO_MAIN    2
+#define IMAGE_PAGE_ID_XORRISO_ISO_META    3
+#define IMAGE_PAGE_ID_MKUDFFS_UDF_MAIN    4
+#define IMAGE_PAGE_ID_MKUDFFS_UDF_META    5
+
+
+/* this is first main component of options window: a big table
+   aggregating data and functions that prepare the data; the data
+   represents widgets displayed in pages of options window */
+static cdw_options_page_t c_pages[] = {
+	/* 2TRANS: label of a tab in configuration window with options related to ISO9660; probably you don't want to translate this */
+	{ false, CDW_MKISOFS_ISO_MAIN_OPTIONS_N_FIELDS,   cdw_mkisofs_options_form,       gettext_noop("ISO9660"),   (cdw_form_t *) NULL },
+	/* 2TRANS: label of a tab in configuration window with options related to meta information of ISO9660 file system */
+	{ false, CDW_MKISOFS_ISO_META_OPTIONS_N_FIELDS,   cdw_mkisofsrc_options_form,     gettext_noop("Meta data"), (cdw_form_t *) NULL },
+	/* 2TRANS: label of a tab in configuration window with options related to ISO9660; probably you don't want to translate this */
+	{ false, CDW_XORRISO_ISO_MAIN_OPTIONS_N_FIELDS,   cdw_xorriso_iso_options_form,   gettext_noop("ISO9660"),   (cdw_form_t *) NULL },
+	/* 2TRANS: label of a tab in configuration window with options related to meta information of ISO9660 file system */
+	{ false, CDW_XORRISO_ISO_META_OPTIONS_N_FIELDS,   cdw_xorrisorc_options_form,     gettext_noop("Meta data"), (cdw_form_t *) NULL },
+	/* 2TRANS: label of a tab in configuration window with options related to UDF; probably you don't want to translate this */
+	{ false, CDW_MKUDFFS_UDF_MAIN_OPTIONS_N_FIELDS,   cdw_mkudffs_options_form_p1,    gettext_noop("UDF tools"), (cdw_form_t *) NULL },
+	/* 2TRANS: label of a tab in configuration window with options related to meta information of UDF file system */
+	{ false, CDW_MKUDFFS_UDF_META_OPTIONS_N_FIELDS,   cdw_mkudffs_options_form_p2,    gettext_noop("Meta data"), (cdw_form_t *) NULL }
+};
+
+
+/* this is a pointer to second main component of options window:
+   tabbed window, which enables switching between pages */
+static cdw_tabs_window_t *c_twindow = (cdw_tabs_window_t *) NULL;
+
+
+
+
+cdw_rv_t cdw_image_wizard_options_window_sub(cdw_task_t *task, cdw_id_t *pid, int *fi)
+{
+	cdw_assert (wizard.image_format == CDW_IMAGE_FORMAT_ISO9660
+		    || wizard.image_format == CDW_IMAGE_FORMAT_UDF,
+
+		    "ERROR: invalid image format %lld\n", wizard.image_format);
+
+	/* 2TRANS: this is message at the bottom of options window;
+	   cancel means: quit without saving; '%d' is an integer used to
+	   create label of function key, e.g. "F10" */
+	int rv = asprintf(&wizard.window_tip,
+			  _("Press F%d / F%d key to save changes or ESC to cancel"),
+			  CDW_CONFIG_UI_SnC_KEY_B, CDW_CONFIG_UI_SnC_KEY_A);
+	if (!wizard.window_tip || rv == -1) {
+		cdw_vdm ("ERROR: failed to create window tip\n");
+		return CDW_ERROR;
+	}
+
+	int n_tabs = 0;
+	if (wizard.image_format == CDW_IMAGE_FORMAT_ISO9660) {
+		n_tabs = 2; /* mkisofs|xorriso + mkisofsrc|xorrisorc */
+		/* 2TRANS: this is title of cdw options main window */
+		c_twindow = cdw_tabs_window_init(n_tabs, _("ISO9660 options"), wizard.window_tip);
+		cdw_tabs_window_set_geometry(c_twindow, OPTIONS_HEIGHT, OPTIONS_WIDTH, 4, 4, TABS_WIDTH);
+
+
+		/* prepare tabbed window */
+		cdw_id_t id = 0;
+		int ind = 0;
+		/* tool-specific options: mkisofs or xorriso */
+		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
+			id = IMAGE_PAGE_ID_MKISOFS_ISO_MAIN;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+			ind++;
+
+			id = IMAGE_PAGE_ID_MKISOFS_ISO_META;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+			ind++;
+		} else {
+			id = IMAGE_PAGE_ID_XORRISO_ISO_MAIN;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+			ind++;
+
+			id = IMAGE_PAGE_ID_XORRISO_ISO_META;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+			ind++;
+		}
+	} else { /* wizard.image_format == CDW_IMAGE_FORMAT_UDF */
+		n_tabs = 2; /* mkudffs main options + UDF meta data. */
+		/* 2TRANS: this is title of cdw options main window */
+		c_twindow = cdw_tabs_window_init(n_tabs, _("UDF options"), wizard.window_tip);
+		cdw_tabs_window_set_geometry(c_twindow, OPTIONS_HEIGHT, OPTIONS_WIDTH, 4, 4, TABS_WIDTH);
+
+		/* prepare tabbed window */
+		int ind = 0;
+		cdw_id_t id = IMAGE_PAGE_ID_MKUDFFS_UDF_MAIN;
+		cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+		ind++;
+
+		id = IMAGE_PAGE_ID_MKUDFFS_UDF_META;
+		cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+		ind++;
+	}
+
+
+	cdw_tabs_window_add_return_keys(c_twindow,
+					KEY_F(CDW_CONFIG_UI_SnC_KEY_A), KEY_F(CDW_CONFIG_UI_SnC_KEY_B),
+					CDW_KEY_ESCAPE, 'q', 'Q', 0);
+	c_twindow->driver_reader = cdw_config_ui_tabs_window_form_reader;
+	cdw_tabs_window_finalize(c_twindow);
+
+	/* prepare forms in the tabbed window */
+	for (int i = 0; i < n_tabs; i++) {
+		cdw_id_t id = c_twindow->tabs[i].id;
+
+		c_pages[id].cdw_form = cdw_form_new(c_pages[id].n_fields);
+		c_pages[id].cdw_form->form_id = id;
+		c_pages[id].cdw_form->window = c_twindow->tabs[i].window;
+		c_pages[id].cdw_form->subwindow = c_twindow->tabs[i].subwindow;
+
+		c_pages[id].visible = true;
+
+		cdw_rv_t crv;
+		if (id == IMAGE_PAGE_ID_MKUDFFS_UDF_MAIN || id == IMAGE_PAGE_ID_MKUDFFS_UDF_META) {
+			crv = c_pages[id].fields_builder(c_pages[id].cdw_form, &(task->create_image.udf), FIRST_COL, SECOND_COL, WIDE_FIELD_WIDTH, LABEL_WIDTH);
+		} else {
+			crv = c_pages[id].fields_builder(c_pages[id].cdw_form, &(task->create_image.iso9660), FIRST_COL, SECOND_COL, WIDE_FIELD_WIDTH, LABEL_WIDTH);
+		}
+		if (crv != CDW_OK) {
+			cdw_vdm ("ERROR: failed to build fields in page #%d\n", i);
+			return CDW_ERROR;;
+		}
+
+		c_pages[id].cdw_form->form = cdw_ncurses_new_form(c_pages[id].cdw_form->window,
+								  c_pages[id].cdw_form->subwindow,
+								  c_pages[id].cdw_form->fields);
+
+		for (int j = 0; j < n_tabs; j++) {
+			cdw_form_add_return_char(c_pages[id].cdw_form, KEY_F(j + CDW_CONFIG_UI_FX_START_KEY));
+		}
+		cdw_form_add_return_char(c_pages[id].cdw_form, KEY_F(CDW_CONFIG_UI_SnC_KEY_A));
+		cdw_form_add_return_char(c_pages[id].cdw_form, KEY_F(CDW_CONFIG_UI_SnC_KEY_B));
+		cdw_form_add_return_char(c_pages[id].cdw_form, 'q'); /* will work only for non-text fields */
+	}
+	c_twindow->user_data = (void *) c_pages;
+
+	cdw_tabs_window_draw_tabs(c_twindow);
+	cdw_config_ui_tabs_window_form_draw(c_twindow);
+
+	if (pid && fi
+	    && *pid != -1 && *fi != -1) {
+
+		cdw_tabs_window_show_tab_by_id(c_twindow, *pid);
+		cdw_form_driver_go_to_field(c_pages[*pid].cdw_form, *fi);
+	}
+
+        int key = cdw_image_wizard_options_window_driver(task);
+	cdw_image_wizard_options_window_destroy();
+	if (key == CDW_KEY_ENTER) {
+		return CDW_OK;
+	} else {
+		return CDW_CANCEL;
+	}
+}
+
+
+
+
+
+/**
+   \brief Destructor function for cdw options window
+*/
+void cdw_image_wizard_options_window_destroy(void)
+{
+	if (wizard.window_tip) {
+		free(wizard.window_tip);
+		wizard.window_tip = (char *) NULL;
+	}
+
+	for (int i = 0; i < c_twindow->n_tabs; i++) {
+		cdw_id_t id = c_twindow->tabs[i].id;
+		if (c_pages[id].cdw_form) {
+			cdw_form_delete_form_objects(c_pages[id].cdw_form);
+		}
+		if (c_pages[id].cdw_form) {
+			cdw_form_delete(&(c_pages[id].cdw_form));
+		}
+	}
+
+	cdw_tabs_window_delete(&c_twindow);
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Function reacting to keys pressed when options window is displayed
+
+   Function catches all keys pressed when options window is displayed,
+   and reacts to them either by switching pages, or by passing the keys to
+   page driver(s).
+
+   Keys configured as hotkeys for "tabbed window" tabs are used to switch
+   between pages. F(CDW_CONFIG_SnC_KEY) key is interpreted as "save and close"
+   key - values of all option fields are stored in \p config and validated.
+   Function then returns CDW_OK if validation is successful, or displays
+   incorrect field to user.
+   ESCAPE key causes the function to return with CDW_KEY_ESCAPE.
+
+   \param config - variable in which function saves values of all option fields
+
+   \return CDW_KEY_ESCAPE if user pressed ESCAPE key in options window
+   \return CDW_KEY_ENTER if user pressed F10 and validation of \p tmp config was successful
+*/
+int cdw_image_wizard_options_window_driver(cdw_task_t *task)
+{
+	while (1) {
+		int key = cdw_tabs_window_driver(c_twindow);
+		if (key == CDW_KEY_ESCAPE || key == 'q' || key == 'Q') {
+			break;
+		} else if (key == KEY_F(CDW_CONFIG_UI_SnC_KEY_A)
+			   || key == KEY_F(CDW_CONFIG_UI_SnC_KEY_B)) { /* SnC = Save and Close */
+
+			/* flush */
+			for (int i = 0; i < c_twindow->n_tabs; i++) {
+				cdw_id_t id = c_twindow->tabs[i].id;
+				form_driver(c_pages[id].cdw_form->form, REQ_VALIDATION);
+			}
+			cdw_id_t page_id = 0;
+			int fi = 0;
+			cdw_image_wizard_options_save(task);
+			cdw_rv_t valid = cdw_image_wizard_options_validate(task, &page_id, &fi);
+			if (valid == CDW_NO) { /* some option field is invalid */
+
+				/* 2TRANS: this is title of dialog window */
+				cdw_buttons_dialog(_("Error"),
+						   /* 2TRANS: this is message in dialog window */
+						   _("One of option fields is incorrect or contains character that is not allowed. Please fix it."),
+						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+
+				cdw_tabs_window_show_tab_by_id(c_twindow, page_id);
+				cdw_form_driver_go_to_field(c_pages[page_id].cdw_form, fi);
+
+				/* loop */
+			} else {
+				/* options from window with advanced
+				   options are validated and saved into
+				   task variable */
+				return CDW_KEY_ENTER;
+			}
+		} else {
+			/* loop */
+		}
+	} /* while (1) */
+
+	return CDW_KEY_ESCAPE;
+}
+
+
+
+
+
+cdw_rv_t cdw_image_wizard_options_save(cdw_task_t *task)
+{
+	cdw_id_t pid;
+
+	if (wizard.image_format == CDW_IMAGE_FORMAT_ISO9660) {
+		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
+
+			pid = IMAGE_PAGE_ID_MKISOFS_ISO_MAIN;
+			cdw_mkisofs_options_save(c_pages[pid].cdw_form, &(task->create_image.iso9660));
+
+			pid = IMAGE_PAGE_ID_MKISOFS_ISO_META;
+			cdw_mkisofsrc_options_save(c_pages[pid].cdw_form, &(task->create_image.iso9660));
+		} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
+
+			pid = IMAGE_PAGE_ID_XORRISO_ISO_MAIN;
+			cdw_xorriso_iso_options_save(c_pages[pid].cdw_form, &(task->create_image.iso9660));
+
+			pid = IMAGE_PAGE_ID_XORRISO_ISO_META;
+			cdw_xorrisorc_options_save(c_pages[pid].cdw_form, &(task->create_image.iso9660));
+		} else {
+			cdw_assert (0, "ERROR: invalid tool id for task \"create image\": %s (%lld)\n",
+				    cdw_ext_tools_get_tool_name(task->create_image.tool.id),
+				    task->create_image.tool.id);
+			return CDW_NO;
+		}
+
+	} else {
+		pid = IMAGE_PAGE_ID_MKUDFFS_UDF_MAIN;
+		cdw_mkudffs_options_save_p1(&(task->create_image.udf), c_pages[pid].cdw_form);
+		pid = IMAGE_PAGE_ID_MKUDFFS_UDF_META;
+		cdw_mkudffs_options_save_p2(&(task->create_image.udf), c_pages[pid].cdw_form);
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+   \brief Check options for creating image
+
+   Check options used to create ISO9660/UDF image file that *would* be
+   displayed in options window. The function should be called when
+   "Options" window has not been displayed, i.e. when user pressed
+   "Create" button in wizard without visiting "Options" window.
+
+   Some options in such non-visited window may be invalid, this
+   function should detect this.
+
+   First it tests contents of task variable, and if there is anything
+   wrong with any of the options related to creating image, it creates
+   and display options window, with cursor placed in problematic
+   field.
+
+   User is given a chance to fix the options in the window. User may
+   press Escape key in the window, the function will then return
+   CDW_NO. The function also returns CDW_NO if it decides that for
+   some reason they weren't fixed by user.
+
+   \param task - task which needs to be validated
+
+   \return CDW_OK if options for creating image are valid
+   \return CDW_NO if the options are invalid, or if user has pressed Escape key in options window
+*/
+cdw_rv_t cdw_image_wizard_options_validate_closed(cdw_task_t *task)
+{
+	cdw_id_t pid;
+	int fi;
+	cdw_rv_t valid = cdw_image_wizard_options_validate(task, &pid, &fi);
+	if (valid == CDW_NO) { /* some option field is invalid */
+
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("One of option fields is incorrect or contains character that is not allowed. Please fix it."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+
+		int c = cdw_image_wizard_options_window_by_flow(&pid, &fi);
+		if (c == '0') {
+			return CDW_NO;
+		} else {
+			/* c == '1', invalid options have been fixed
+			   and user pressed "Save and Close"
+			   key. Validate again, just to be sure. */
+			valid = cdw_image_wizard_options_validate(task, &pid, &fi);
+			if (valid == CDW_NO) {
+				/* 2TRANS: this is title of dialog window */
+				cdw_buttons_dialog(_("Error"),
+						   /* 2TRANS: this is message in dialog window */
+						   _("The invalid option(s) in options window has not been fixed."),
+						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+				return CDW_NO;
+			}
+		}
+	} else {
+		/* Options are valid and user has pressed "save and close" key. */
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_image_wizard_options_validate(cdw_task_t *task, cdw_id_t *pid, int *fi)
+{
+	cdw_rv_t crv = CDW_NO;
+	if (wizard.image_format == CDW_IMAGE_FORMAT_ISO9660) {
+		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
+
+			*pid = IMAGE_PAGE_ID_MKISOFS_ISO_MAIN;
+			crv = cdw_mkisofs_options_validate(&(task->create_image.iso9660), fi);
+			if (crv == CDW_NO) {
+				return CDW_NO;
+			}
+
+			*pid = IMAGE_PAGE_ID_MKISOFS_ISO_META;
+			crv = cdw_mkisofsrc_options_validate(&(task->create_image.iso9660), fi);
+			if (crv == CDW_NO) {
+				return CDW_NO;
+			}
+
+
+		} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
+
+			*pid = IMAGE_PAGE_ID_XORRISO_ISO_MAIN;
+			crv = cdw_xorriso_iso_options_validate(&(task->create_image.iso9660), fi);
+			if (crv == CDW_NO) {
+				return CDW_NO;
+			}
+
+			*pid = IMAGE_PAGE_ID_XORRISO_ISO_META;
+			crv = cdw_xorrisorc_options_validate(&(task->create_image.iso9660), fi);
+			if (crv == CDW_NO) {
+				return CDW_NO;
+			}
+		} else {
+			cdw_assert (0, "ERROR: invalid tool id for task \"create image\": %lld\n",
+				    task->create_image.tool.id);
+			return CDW_NO;
+		}
+
+	} else {
+		*pid = IMAGE_PAGE_ID_MKUDFFS_UDF_MAIN;
+		crv = cdw_mkudffs_options_validate_p1(&(task->create_image.udf), fi);
+		if (crv == CDW_NO) {
+			return CDW_NO;
+		}
+
+		*pid = IMAGE_PAGE_ID_MKUDFFS_UDF_META;
+		crv = cdw_mkudffs_options_validate_p2(&(task->create_image.udf), fi);
+		if (crv == CDW_NO) {
+			return CDW_NO;
+		}
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+   \brief Validate and save values of options
+   available in main page of the wizard
+
+   Values of options will be saved in \p task.
+   If any value is invalid, index of corresponding field
+   will be saved in \fi, and function will return CDW_NO.
+
+   \param task - variable describing current task
+   \param fi - field index
+
+   \return CDW_OK on success
+   \return CDW_NO if any value in main wizard page is invalid
+*/
+cdw_rv_t cdw_image_wizard_validate_and_save(cdw_task_t *task, int *fi)
+{
+	/* First validate. */
+	const char *s = field_buffer(wizard.cdw_form->fields[f_volume_id_i], 0);
+	cdw_rv_t crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv == CDW_NO) {
+		*fi = f_volume_id_i;
+		return CDW_NO;
+	}
+
+	s = field_buffer(wizard.cdw_form->fields[f_image_file_i], 0);
+	crv = cdw_string_security_parser(s, (char *) NULL);
+	if (crv == CDW_NO) {
+		*fi = f_image_file_i;
+		return CDW_NO;
+	}
+
+
+
+	/* Save only when valid. */
+	s = cdw_form_get_string(wizard.cdw_form, f_volume_id_i);
+	if (wizard.image_format == CDW_IMAGE_FORMAT_ISO9660) {
+		strncpy(task->create_image.iso9660.volume_id, s, CDW_ISO9660_VOLI_LEN);
+		task->create_image.iso9660.volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
+
+	} else { /* CDW_IMAGE_FORMAT_UDF */
+		strncpy(task->create_image.udf.mkudffs_lvid, s, CDW_UDF_LVID_LEN_MAX);
+		task->create_image.udf.mkudffs_lvid[CDW_UDF_LVID_LEN_MAX] = '\0';
+	}
+
+	s = cdw_form_get_string(wizard.cdw_form, f_image_file_i);
+	cdw_string_set(&(task->image_file_fullpath), s);
+
+	return CDW_OK;
+}
+
+
+
+
+
+/**
+   Dropdown list to select image file format: ISO9660 or UDF.
+*/
+CDW_DROPDOWN *cdw_img_wizard_make_image_format_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	/* Decide on default item in dropdown, taking into
+	   consideration an ID of the task and availability of
+	   tools. */
+	cdw_id_t dd_id = CDW_IMAGE_FORMAT_ISO9660;     /* Initial value. */
+	if (wizard.task->id == CDW_TASK_CREATE_IMAGE_ISO9660) {
+		if (cdw_ext_tools_get_n_iso9660_handlers() > 0) {
+			dd_id = CDW_IMAGE_FORMAT_ISO9660;
+		} else {
+			if (cdw_ext_tools_udf_sa_tools_tools_available()) {
+				dd_id = CDW_IMAGE_FORMAT_UDF;
+			} else {
+				cdw_assert (0, "ERROR: no tools available for creating sa image, the function shouldn't have been called at all\n");
+				return (CDW_DROPDOWN *) NULL;
+			}
+		}
+	} else if (wizard.task->id == CDW_TASK_CREATE_IMAGE_UDF) {
+		if (cdw_ext_tools_udf_sa_tools_tools_available()) {
+			dd_id = CDW_IMAGE_FORMAT_UDF;
+		} else {
+			if (cdw_ext_tools_get_n_iso9660_handlers() > 0) {
+				dd_id = CDW_IMAGE_FORMAT_ISO9660;
+			} else {
+				cdw_assert (0, "ERROR: no tools available for creating sa image, the function shouldn't have been called at all\n");
+				return (CDW_DROPDOWN *) NULL;
+			}
+		}
+	} else {
+		cdw_assert (0, "ERROR: invalid task id %lld\n", wizard.task->id);
+		return (CDW_DROPDOWN *) NULL;
+	}
+
+
+	cdw_id_clabel_t items[CDW_IMAGE_WIZARD_FORMATS_MAX];
+	int n_items = 0;
+
+
+	/* Put available options into dropdown. */
+
+	if (cdw_ext_tools_get_n_iso9660_handlers() > 0) {
+
+		/* There is some tool needed to create ISO9660 image -
+		   either mkisofs (or its replacement genisoimage), or
+		   xorriso. */
+
+		items[n_items].id = cdw_img_wizard_formats[CDW_IMAGE_FORMAT_ISO9660].id;
+		items[n_items].label = cdw_img_wizard_formats[CDW_IMAGE_FORMAT_ISO9660].label;
+		n_items++;
+	}
+
+	if (cdw_ext_tools_udf_sa_tools_tools_available()) {
+		/* Full set of tools needed to create UDF file is present.
+		   FIXME: the "1" above is only temporary - the list will be longer. */
+
+		items[n_items].id = cdw_img_wizard_formats[CDW_IMAGE_FORMAT_UDF].id;
+		items[n_items].label = cdw_img_wizard_formats[CDW_IMAGE_FORMAT_UDF].label;
+		n_items++;
+	}
+
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, n_items, items);
+	cdw_dropdown_set_current_item_by_id(dd, dd_id);
+
+	return dd;
+}
diff -Naur orig/src/user_interface/cdw_image_wizard.h patched/src/user_interface/cdw_image_wizard.h
--- orig/src/user_interface/cdw_image_wizard.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/user_interface/cdw_image_wizard.h	2014-02-05 22:33:42.000000000 +0100
@@ -0,0 +1,22 @@
+#ifndef H_CDW_IMAGE_WIZARD
+#define H_CDW_IMAGE_WIZARD
+
+#include "main.h"
+#include "cdw_task.h"
+
+
+/* To avoid magic numbers. Will be used to index table as well, so
+   keep it non-sparse, starting from zero. */
+enum {
+	CDW_IMAGE_FORMAT_ISO9660 = 0,
+	CDW_IMAGE_FORMAT_UDF     = 1,
+	CDW_IMAGE_FORMAT_ERROR   = 2,
+	CDW_IMAGE_FORMAT_NONE    = 3
+};
+
+
+
+int cdw_image_wizard(cdw_task_t *task);
+
+
+#endif /* #ifndef H_CDW_IMAGE_WIZARD */
diff -Naur orig/src/user_interface/cdw_iso9660_wizard.c patched/src/user_interface/cdw_iso9660_wizard.c
--- orig/src/user_interface/cdw_iso9660_wizard.c	2012-03-28 21:01:57.000000000 +0200
+++ patched/src/user_interface/cdw_iso9660_wizard.c	2014-01-26 17:24:40.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
@@ -42,60 +42,89 @@
 #include "cdw_mkisofsrc.h"
 #include "cdw_xorriso_options.h"
 #include "cdw_xorrisorc.h"
+#include "cdw_mkudffs.h"
 #include "cdw_tabs_window.h"
 #include "cdw_iso9660_wizard.h"
+#include "cdw_udf.h"
 
 
 enum field_ids {
-	f_volume_id_l = 0,
+	f_image_format_l = 0,
+	f_image_format_dd,
+	f_volume_id_l,
 	f_volume_id_i,
-	f_iso_file_l,
-	f_iso_file_i,
-	f_iso_file_b,
+	f_image_file_l,
+	f_image_file_i,
+	f_image_file_b,
 	f_options_b,
 	f_create_b,
 	f_cancel_b,
 };
 
 
-#define CDW_WRITE_WIZARD_N_FIELDS 8
-static FIELD *wizard_fields[CDW_WRITE_WIZARD_N_FIELDS + 1];
+#define CDW_IMAGE_WIZARD_N_FIELDS 10
+static FIELD *wizard_fields[CDW_IMAGE_WIZARD_N_FIELDS + 1];
 
-static cdw_rv_t cdw_iso9660_wizard_options(cdw_task_t *task);
-static void     cdw_iso9660_options_window_destroy(void);
-static cdw_rv_t cdw_iso9660_wizard_options_window_driver(cdw_task_t *task);
-
-static cdw_rv_t cdw_iso9660_wizard_init(void);
-static cdw_rv_t cdw_iso9660_wizard_build(cdw_task_t *task);
-static void     cdw_iso9660_wizard_destroy(void);
-static int      cdw_iso9660_wizard_driver(void);
-static cdw_rv_t cdw_iso9660_wizard_options_validate_and_save(cdw_task_t *task, cdw_id_t *page_id, int *fi);
-static cdw_rv_t cdw_iso9660_wizard_validate_and_save(cdw_task_t *task, int *fi);
-
-static int cdw_iso9660_wizard_on_enter_on_cancel(cdw_form_t *cdw_form, void *dummy);
-static int cdw_iso9660_wizard_on_enter_on_create(cdw_form_t *cdw_form, void *dummy);
-static int cdw_iso9660_wizard_on_enter_on_options(cdw_form_t *cdw_form, void *dummy);
-static int cdw_iso9660_wizard_on_enter_on_iso_file(cdw_form_t *cdw_form, void *dummy);
 
-static void cdw_iso9660_wizard_debug_at_exit(cdw_task_t *task);
+/* ISO9660 + UDF = 2 */
+#define CDW_IMAGE_WIZARD_FORMATS_MAX 2
 
+/* To avoid magic numbers. Will be used to index table as well, so
+   keep it non-sparse, starting from zero. */
+#define CDW_IMAGE_FORMAT_ISO9660 0
+#define CDW_IMAGE_FORMAT_UDF     1
+
+
+static cdw_id_clabel_t cdw_img_wizard_formats[CDW_IMAGE_WIZARD_FORMATS_MAX] = {
+	/* 2TRANS: ISO9660 optical image file format. */
+	{ CDW_IMAGE_FORMAT_ISO9660,   gettext_noop("ISO9660") },
+	/* 2TRANS: UDF optical image file format. */
+	{ CDW_IMAGE_FORMAT_UDF,       gettext_noop("UDF") },
+};
+
+
+static cdw_rv_t cdw_image_wizard_options(cdw_task_t *task);
+static void     cdw_image_options_window_destroy(void);
+static cdw_rv_t cdw_image_wizard_options_window_driver(cdw_task_t *task);
+
+static cdw_rv_t cdw_image_wizard_init(void);
+static cdw_rv_t cdw_image_wizard_build(cdw_task_t *task);
+static void     cdw_image_wizard_destroy(void);
+static int      cdw_image_wizard_driver(void);
+static cdw_rv_t cdw_image_wizard_options_validate_and_save(cdw_task_t *task, cdw_id_t *page_id, int *fi);
+static cdw_rv_t cdw_image_wizard_validate_and_save(cdw_task_t *task, int *fi);
+
+static int cdw_image_wizard_on_enter_on_options(void *dummy1, void *dummy2);
+static int cdw_image_wizard_on_enter_on_image_file(void *dummy1, void *dummy2);
+static int cdw_image_wizard_on_select_image_format(void *dummy1, void *vid);
+
+static void cdw_image_wizard_resolve_volume_id(cdw_form_t *cdw_form);
+
+static void cdw_image_wizard_debug_at_exit(cdw_task_t *task);
+CDW_DROPDOWN *cdw_img_wizard_make_image_format_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
 
 
 static struct {
 	cdw_form_t *cdw_form;
+	cdw_id_t image_format;
 } wizard;
 
 
 static cdw_task_t *local_task = (cdw_task_t *) NULL;
 
+static cdw_form_dropdown_maker_t main_dropdown_makers[] = {
+	cdw_img_wizard_make_image_format_dropdown
+};
 
-/* *** some layout constraints *** */
 
-#define first_col                  2  /* main message and some labels start in leftmost column */
-#define volume_id_label_row        2
-#define iso_file_label_row         5
-#define options_button_row        10
-#define buttons_row               13  /* Create and Cancel buttons are at the bottom of window */
+
+/* Some layout constraints. */
+static const int first_col             =  2;  /* Main message and some labels start in leftmost column. */
+static const int img_type_row          =  1;
+static const int volume_id_label_row   =  4;
+static const int image_file_label_row  =  7;
+static const int options_button_row    = 11;
+static const int buttons_row           = 14;  /* Create and Cancel buttons are at the bottom of window. */
 
 #define window_n_cols             52
 #define window_n_lines            20
@@ -104,6 +133,18 @@
 #define wide_label_n_cols          (subwindow_n_cols - 2)
 #define narrow_label_n_cols        (subwindow_n_cols - 15)
 
+/* The "voli" field will contain "Volume Identifier" for ISO9660 or "Logical
+   Volume Identifier" for UDF file system. I would like the field to
+   display full string (without any visual truncation) for at least
+   the shorter of the two IDs.
+
+   The maximal length for ISO9660 is much smaller than for UDF, so the
+   width of the field will equal to maximal length of ISO9660 volume
+   identifier. */
+#define voli_field_n_cols          CDW_ISO9660_VOLI_LEN
+
+
+
 
 
 /**
@@ -120,45 +161,48 @@
    \return CDW_CANCEL if user presses Escape key or selects 'Cancel' button
    \return CDW_GEN_ERROR on errors
 */
-cdw_rv_t cdw_iso9660_wizard(cdw_task_t *task)
+cdw_rv_t cdw_image_wizard(cdw_task_t *task)
 {
 	cdw_assert (task->id == CDW_TASK_CREATE_IMAGE,
 		    "ERROR: incorrect task id %lld\n", task->id);
 
 	local_task = task;
 
-	cdw_rv_t crv = cdw_iso9660_wizard_init();
+	/* Non-valid initial value. */
+	wizard.image_format = -CDW_IMAGE_FORMAT_ISO9660;
+
+	cdw_rv_t crv = cdw_image_wizard_init();
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to init wizard\n");
-		cdw_iso9660_wizard_destroy();
+		cdw_image_wizard_destroy();
 		return CDW_ERROR;
 	}
-	crv = cdw_iso9660_wizard_build(task);
+	crv = cdw_image_wizard_build(task);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to build wizard\n");
-		cdw_iso9660_wizard_destroy();
+		cdw_image_wizard_destroy();
 		return CDW_ERROR;
 	}
 
 	wrefresh(wizard.cdw_form->subwindow);
 
-	int rv = cdw_iso9660_wizard_driver();
+	int rv = cdw_image_wizard_driver();
 	if (rv == CDW_KEY_ENTER) {
 #ifndef NDEBUG
 		/* use task variable, to which wizard saves result
 		   at return, not values from dropdowns/checkboxes */
-		cdw_iso9660_wizard_debug_at_exit(task);
+		cdw_image_wizard_debug_at_exit(task);
 #endif
 	} else {
 		cdw_vdm ("INFO: not attempting writing, not displaying settings\n");
 	}
 
-	cdw_iso9660_wizard_destroy();
+	cdw_image_wizard_destroy();
 
 	/* redraw parent */
 	cdw_main_ui_main_window_wrefresh();
 
-	cdw_vdm ("INFO: path at exit from wizard: %s\n", task->create_image.iso9660_file_fullpath);
+	cdw_vdm ("INFO: path at exit from wizard: %s\n", task->create_image.image_file_fullpath);
 
 	return rv == CDW_KEY_ENTER ? CDW_OK : CDW_CANCEL;
 }
@@ -172,9 +216,9 @@
 
    Function sets values of various fields of "wizard" variable.
 */
-cdw_rv_t cdw_iso9660_wizard_init(void)
+cdw_rv_t cdw_image_wizard_init(void)
 {
-	wizard.cdw_form = cdw_form_new(CDW_WRITE_WIZARD_N_FIELDS);
+	wizard.cdw_form = cdw_form_new(CDW_IMAGE_WIZARD_N_FIELDS);
 	if (wizard.cdw_form == (cdw_form_t *) NULL) {
 		cdw_vdm ("ERROR: failed to create cdw form\n");
 		return CDW_ERROR;
@@ -189,49 +233,52 @@
 
 
 
-int cdw_iso9660_wizard_driver(void)
+int cdw_image_wizard_driver(void)
 {
-	int fi = 0;
+	int fi = f_image_format_dd;
 	int key = 'a';
+
+	CDW_SAFE_INPUT_LINE *line = field_userptr(wizard.cdw_form->fields[3]);
+	cdw_assert (line, "ERROR: input line is null\n");
+	cdw_assert (line->widget_id == CDW_WIDGET_SAFE_INPUT_LINE, "ERROR: the widget is not input line (is %d)\n", line->widget_id);
+
 	while (key != CDW_KEY_ESCAPE && key != 'q' && key != 'Q') {
-		key = cdw_form_driver(wizard.cdw_form, fi);
+		key = cdw_form_driver2(wizard.cdw_form, fi);
 
 		fi = field_index(current_field(wizard.cdw_form->form));
+
 		if (key == CDW_KEY_ENTER) {
-			if (fi == f_create_b) {
+			cdw_assert (fi == f_create_b, "ERROR: driver returns KEY_ENTER for widget other than create (%d)\n", fi);
+
+			/* flush */
+			form_driver(wizard.cdw_form->form, REQ_VALIDATION);
 
-				/* flush */
-				form_driver(wizard.cdw_form->form, REQ_VALIDATION);
+			cdw_rv_t crv = cdw_image_wizard_validate_and_save(local_task, &fi);
+			if (crv == CDW_NO) {
+				/* one of option strings in main
+				   wizard window is invalid */
+
+				/* 2TRANS: this is title of dialog window */
+				cdw_buttons_dialog(_("Error"),
+						   /* 2TRANS: this is message in dialog window */
+						   _("One of option fields is incorrect or contains character that is not allowed. Please fix it."),
+						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
 
-				cdw_rv_t crv = cdw_iso9660_wizard_validate_and_save(local_task, &fi);
-				if (crv == CDW_NO) {
-					/* one of option strings in main
-					   wizard window is invalid */
-
-					/* 2TRANS: this is title of dialog window */
-					cdw_buttons_dialog(_("Error"),
-							   /* 2TRANS: this is message in dialog window */
-							   _("One of option fields is incorrect or contains character that is not allowed. Please fix it."),
-							   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-
-					cdw_form_driver_go_to_field(wizard.cdw_form, fi);
-					/* loop */
-				} else {
-					/* fields in main page of the wizard
-					   are validated and saved into task
-					   variable */
-					return CDW_KEY_ENTER;
-				}
-			} else if (fi == f_cancel_b) {
-				return CDW_KEY_ESCAPE;
+				cdw_form_driver_go_to_field(wizard.cdw_form, fi);
+				/* loop */
 			} else {
-				;
+				/* fields in main page of the wizard
+				   are validated and saved into task
+				   variable */
+				return CDW_KEY_ENTER;
 			}
 		} else if (key == CDW_KEY_ESCAPE) {
 			return CDW_KEY_ESCAPE;
 		} else {
 			;
 		}
+
+
 	}
 
 	return CDW_KEY_ESCAPE;
@@ -245,7 +292,7 @@
 /**
    \brief Deallocate all resources allocated by write wizard
 */
-void cdw_iso9660_wizard_destroy(void)
+void cdw_image_wizard_destroy(void)
 {
 	if (wizard.cdw_form->subwindow != (WINDOW *) NULL) {
 		delwin(wizard.cdw_form->subwindow);
@@ -274,7 +321,7 @@
 
    \param task - task variable, in which some fields were set in write wizard
 */
-void cdw_iso9660_wizard_debug_at_exit(cdw_task_t *task)
+void cdw_image_wizard_debug_at_exit(cdw_task_t *task)
 {
 	cdw_task_debug_print_iso9660_options(task);
 	return;
@@ -293,7 +340,7 @@
    \return CDW_OK on success
    \return CDW_ERROR on failure
 */
-cdw_rv_t cdw_iso9660_wizard_build(cdw_task_t *task)
+cdw_rv_t cdw_image_wizard_build(cdw_task_t *task)
 {
 	int begin_y = ((LINES - window_n_lines) / 2) - 2;
 	int begin_x = (COLS - window_n_cols) / 2;
@@ -305,7 +352,7 @@
 			       /* 2TRANS: this is title of wizard
 				  window; "write" as in
 				  'writing to optical disc" */
-			       _("ISO9660 wizard"),
+			       _("Image wizard"),
 			       /* 2TRANS: this is tip at the bottom
 				  of window - user can switch between
 				  window elements using tab key */
@@ -332,30 +379,37 @@
 	int iso_button_col = first_col + wide_label_n_cols - 5;
 
 	cdw_form_descr_t descr[] = {
-		/*     type             begin_y                   begin_x         n_cols                n_lines    field enum      data1                  data2 */
-		/* 2TRANS: this is label next to input field, where user can enter a label describing created ISO9660 volume */
-		{ CDW_WIDGET_LABEL,   volume_id_label_row,      first_col,      wide_label_n_cols,       1,  f_volume_id_l,  _("Volume ID:"),                                  0 },
-		{ CDW_WIDGET_INPUT,   volume_id_label_row + 1,  first_col,      CDW_ISO9660_VOLI_LEN,    1,  f_volume_id_i,  task->create_image.volume_id,  CDW_ISO9660_VOLI_LEN },
-
-		/* 2TRANS: this is label next to input field, where user can specify path to ISO9660 file */
-		{ CDW_WIDGET_LABEL,   iso_file_label_row,       first_col,      wide_label_n_cols - 2,   1,  f_iso_file_l,   _("ISO9660 image file:"),                         0 },
-		{ CDW_WIDGET_INPUT,   iso_file_label_row + 1,   first_col,      wide_label_n_cols - 8,   1,  f_iso_file_i,   task->create_image.iso9660_file_fullpath,         0 },
+		/* type                          begin_y                  begin_x            n_cols               n_lines    field enum           data1                                   data2 */
+
+		/* 2TRANS: this is label next to input field, where user can select type of image: ISO9660 or UDF. */
+		{ CDW_WIDGET_STATIC_LABEL,       img_type_row,            first_col,         wide_label_n_cols,       1,  f_image_format_l,   _("Image type:"),                                   0 },
+		{ CDW_WIDGET_DROPDOWN,           img_type_row + 1,        first_col,         narrow_label_n_cols,     1,  f_image_format_dd,  main_dropdown_makers,                               0 },
+
+
+		/* 2TRANS: this is label next to input field, where user can enter a label describing created IMAGE volume */
+		{ CDW_WIDGET_DYNAMIC_LABEL,      volume_id_label_row,     first_col,         wide_label_n_cols,       1,  f_volume_id_l,      _("Volume ID:"),                                    0 },
+		{ CDW_WIDGET_SAFE_INPUT_LINE,    volume_id_label_row + 1, first_col,         voli_field_n_cols,       1,  f_volume_id_i,      task->create_image.volume_id,    CDW_ISO9660_VOLI_LEN },
+
+
+		/* 2TRANS: this is label next to input field, where user can specify path to ISO9660 or UDF file on disc. */
+		{ CDW_WIDGET_DYNAMIC_LABEL,      image_file_label_row,     first_col,        wide_label_n_cols - 2,   1,  f_image_file_l,     _("Output image file:"),                            0 },
+		{ CDW_WIDGET_SAFE_INPUT_LINE,    image_file_label_row + 1, first_col,        wide_label_n_cols - 8,   1,  f_image_file_i,     task->create_image.image_file_fullpath,             0 },
 		/* 2TRANS: do not translate */
-		{ CDW_WIDGET_BUTTON,  iso_file_label_row + 1,   iso_button_col, 1,                       1,  f_iso_file_b,   _(">"),                           CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_BUTTON,             image_file_label_row + 1, iso_button_col,   1,                       1,  f_image_file_b,     _(">"),                             CDW_COLORS_DIALOG },
 
-		/* 2TRANS: this is label of a button that opens configuration window; "more options" related to creating ISO9660 file */
-		{ CDW_WIDGET_BUTTON,  options_button_row,       first_col,      1,                       1,  f_options_b,    _("More options"),                CDW_COLORS_DIALOG },
+		/* 2TRANS: this is label of a button that opens configuration window; "more options" related to creating IMAGE file */
+		{ CDW_WIDGET_BUTTON,             options_button_row,       first_col,        1,                       1,  f_options_b,        _("More options"),                  CDW_COLORS_DIALOG },
 
 		/* 2TRANS: button label, it refers to writing to optical disc */
-		{ CDW_WIDGET_BUTTON,  buttons_row,               3,             2,                       1,  f_create_b,     _("Create"),                      CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_BUTTON,             buttons_row,               3,               2,                       1,  f_create_b,         _("Create"),                        CDW_COLORS_DIALOG },
 		/* 2TRANS: button label */
-		{ CDW_WIDGET_BUTTON,  buttons_row,              15,             2,                       1,  f_cancel_b,     _("Cancel"),                      CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_BUTTON,             buttons_row,              15,               2,                       1,  f_cancel_b,         _("Cancel"),                        CDW_COLORS_DIALOG },
 
 		/* guard */
-		{ -1,                 0,                         0,             0,                       0,  0,              (void *) NULL,                                    0 }};
+		{ -1,                    0,                          0,              0,                       0,  0,                  (void *) NULL,                                      0 }};
 
 
-	wizard.cdw_form->n_fields = CDW_WRITE_WIZARD_N_FIELDS;
+	wizard.cdw_form->n_fields = CDW_IMAGE_WIZARD_N_FIELDS;
 
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, wizard.cdw_form);
 	if (crv != CDW_OK) {
@@ -371,55 +425,60 @@
 		return CDW_ERROR;
 	}
 
-	/* current items are set in functions creating respective
-	   dropdowns; now just display them */
-	cdw_form_redraw_widgets(wizard.cdw_form);
 
 	cdw_form_add_return_chars(wizard.cdw_form, CDW_KEY_ENTER, CDW_KEY_ESCAPE, 'q', 'Q', 0);
+	cdw_form_set_return_key(wizard.cdw_form, f_create_b,      CDW_KEY_ENTER);
+	cdw_form_set_return_key(wizard.cdw_form, f_cancel_b,      CDW_KEY_ESCAPE);
 
-	cdw_form_set_function(wizard.cdw_form, f_create_b,   cdw_iso9660_wizard_on_enter_on_create);
-	cdw_form_set_function(wizard.cdw_form, f_cancel_b,   cdw_iso9660_wizard_on_enter_on_cancel);
-	cdw_form_set_function(wizard.cdw_form, f_iso_file_b, cdw_iso9660_wizard_on_enter_on_iso_file);
-	cdw_form_set_function(wizard.cdw_form, f_options_b,  cdw_iso9660_wizard_on_enter_on_options);
-
-	wrefresh(wizard.cdw_form->subwindow);
-	wrefresh(wizard.cdw_form->window);
+	cdw_form_set_function(wizard.cdw_form, f_image_file_b,    (cdw_form_widget_function_t) cdw_image_wizard_on_enter_on_image_file);
+	cdw_form_set_function(wizard.cdw_form, f_options_b,       (cdw_form_widget_function_t) cdw_image_wizard_on_enter_on_options);
+	cdw_form_set_function(wizard.cdw_form, f_image_format_dd, (cdw_form_widget_function_t) cdw_image_wizard_on_select_image_format);
 
-	return CDW_OK;
-}
+	cdw_form_bind_input_and_label(wizard.cdw_form, f_volume_id_i, f_volume_id_l);
+	cdw_form_bind_input_and_label(wizard.cdw_form, f_image_file_i, f_image_file_l);
 
+	/* Check current value in "image format" dropdown, and make an
+	   input field of appropriate width. */
+	cdw_image_wizard_resolve_volume_id(wizard.cdw_form);
 
+	/* Make sure that cdw widgets are presented properly. */
+	cdw_form_redraw_widgets(wizard.cdw_form);
 
 
+	wrefresh(wizard.cdw_form->subwindow);
+	wrefresh(wizard.cdw_form->window);
 
-int cdw_iso9660_wizard_on_enter_on_cancel(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	return CDW_KEY_ESCAPE;
+	return CDW_OK;
 }
 
 
 
 
 
-int cdw_iso9660_wizard_on_enter_on_create(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
+int cdw_image_wizard_on_enter_on_options(__attribute__((unused)) void *dummy1, __attribute__((unused)) void *dummy2)
 {
-	return CDW_KEY_ENTER;
-}
+	CDW_DROPDOWN *dd = cdw_form_get_dropdown(wizard.cdw_form, f_image_format_dd);
+	cdw_assert (dd, "ERROR: image format dd is NULL (field id = %d)\n", f_image_format_dd);
 
+	/* FIXME: possible error: where is the code that prevents
+	   creating wizard when cdw can't find any tools for creating
+	   image of any type? The code should be in cdw_task module -
+	   creating new task should fail if external_tools module
+	   can't provide any tools. */
+	cdw_assert (dd->n_items, "ERROR: wizard created when no tools for stand-alone are available\n");
 
+	wizard.image_format = cdw_dropdown_get_current_item_id(dd);
+	cdw_vdm ("INFO: image format = %lld\n", wizard.image_format);
 
 
-
-int cdw_iso9660_wizard_on_enter_on_options(cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	cdw_rv_t crv = cdw_iso9660_wizard_options(local_task);
+	cdw_rv_t crv = cdw_image_wizard_options(local_task);
 
 	cdw_main_ui_main_window_wrefresh();
 
-	redrawwin(cdw_form->window);
-	redrawwin(cdw_form->subwindow);
-	wrefresh(cdw_form->window);
-	wrefresh(cdw_form->subwindow);
+	redrawwin(wizard.cdw_form->window);
+	redrawwin(wizard.cdw_form->subwindow);
+	wrefresh(wizard.cdw_form->window);
+	wrefresh(wizard.cdw_form->subwindow);
 
 	/* the function needs to return int representing a char */
 	if (crv == CDW_OK) {
@@ -432,15 +491,15 @@
 
 
 
-int cdw_iso9660_wizard_on_enter_on_iso_file(cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
+int cdw_image_wizard_on_enter_on_image_file(__attribute__((unused)) void *dummy1, __attribute__((unused)) void *dummy2)
 {
 	/* 2TRANS: this is title of dialog window */
-	cdw_rv_t crv = cdw_fs_ui_file_picker(_("Path to iso image"),
+	cdw_rv_t crv = cdw_fs_ui_file_picker(_("Path to image file"),
 					     /* 2TRANS: this is message in dialog window;
 					     below it there is an input field where user can
-					     enter path to ISO image file */
-					     _("Please enter FULL path to new iso image file:"),
-					     &(local_task->create_image.iso9660_file_fullpath),
+					     enter path to ISO9660 or UDF image file */
+					     _("Please enter FULL path to new image file:"),
+					     &(local_task->create_image.image_file_fullpath),
 					     CDW_FS_FILE, R_OK | W_OK, CDW_FS_NEW | CDW_FS_EXISTING);
 
 	cdw_main_ui_main_window_wrefresh();
@@ -450,13 +509,13 @@
 	redrawwin(wizard.cdw_form->subwindow);
 	wrefresh(wizard.cdw_form->subwindow);
 
-	char *fp = local_task->create_image.iso9660_file_fullpath;
+	char *fp = local_task->create_image.image_file_fullpath;
 	if (crv == CDW_OK) {
-		int rv = set_field_buffer(cdw_form->fields[f_iso_file_i], 0, fp);
+		int rv = set_field_buffer(wizard.cdw_form->fields[f_image_file_i], 0, fp);
 		if (rv != E_OK) {
 			cdw_vdm ("ERROR: failed to set field buffer with string = \"%s\"\n", fp);
 		} else {
-			form_driver(cdw_form->form, REQ_END_LINE);
+			form_driver(wizard.cdw_form->form, REQ_END_LINE);
 		}
 		cdw_vdm ("INFO: file picker returns \"%s\"\n", fp);
 		return '1';
@@ -473,6 +532,130 @@
 
 
 
+/*
+  Change of image format involves changing of "volume ID" input
+  field. The ID has different maximum length depending on image
+  format. I have to change the maximal capacity of the input field
+  accordingly.
+
+  While ncurses allows me to increase the capacity (with
+  set_max_field()), it doesn't allow me to decrease it. As a
+  workaround I have to delete old ncurses field, and create new
+  one. But then I have to inform ncurses form that there has been a
+  change in fields table.
+
+  This is why I have free_field() -> unpost_form() ->
+  set_form_fields() -> post_form().
+*/
+int cdw_image_wizard_on_select_image_format(__attribute__((unused)) void *dummy1, void *vid)
+{
+	CDW_DYNAMIC_LABEL *label = cdw_form_get_dynamic_label(wizard.cdw_form, f_volume_id_l);
+	CDW_SAFE_INPUT_LINE *line = cdw_form_get_safe_input_line(wizard.cdw_form, f_volume_id_i);
+
+	/* ID of currently selected list item. */
+	cdw_id_t *id = (cdw_id_t *) vid;
+	cdw_assert (*id == CDW_IMAGE_FORMAT_ISO9660
+		    || *id == CDW_IMAGE_FORMAT_UDF,
+
+		    "ERROR: invalid image format %lld\n", *id);
+
+	/* The "" strings are used here because upon changing capacity
+	   of input field from 126 to 32 chars I may truncate the
+	   string. In some situations the truncation won't be obvious
+	   to the user, so he will notice the fact only after creating
+	   the image (or burning the disc).
+
+	   Completely erasing the ID string is more noticeable and
+	   will hopefully prompt user to enter correct ID. */
+
+	/*                                type                        begin_y                  begin_x    n_cols         n_lines   field enum  data1   data2 */
+	cdw_form_descr_t iso9660_line = { CDW_WIDGET_SAFE_INPUT_LINE, volume_id_label_row + 1, first_col, voli_field_n_cols, 1, f_volume_id_i, _(""),  CDW_ISO9660_VOLI_LEN };
+	cdw_form_descr_t udf_line =     { CDW_WIDGET_SAFE_INPUT_LINE, volume_id_label_row + 1, first_col, voli_field_n_cols, 1, f_volume_id_i, _(""),  CDW_UDF_LVID_LEN     };
+
+	if (*id == CDW_IMAGE_FORMAT_ISO9660) {
+
+		if (line->chars_max == CDW_ISO9660_VOLI_LEN) {
+			/* The input line already has proper width, so
+			   we assume that it is an input field
+			   suitable for ISO9660 volume label. Don't
+			   replace it with new input field. */
+		} else {
+			cdw_vdm ("INFO: replacing input field with field for ISO9660\n");
+
+			free_field(wizard.cdw_form->fields[f_volume_id_i]);
+			cdw_safe_input_line_delete(&line);
+
+			cdw_form_description_to_safe_input_line(&iso9660_line, wizard.cdw_form, CDW_WIDGET_SAFE_INPUT_LINE, f_volume_id_i);
+
+			/* Don't forget about updating the label too. */
+			cdw_assert (CDW_ISO9660_VOLI_LEN == 32, "ERROR: wrong value of volume len\n");
+			cdw_dynamic_label_set_new(label, "Volume ID (32 chars max)");
+
+			unpost_form(wizard.cdw_form->form);
+			int rv = set_form_fields(wizard.cdw_form->form, wizard.cdw_form->fields);
+			cdw_vdm ("INFO: set_form_fields() returns %s\n", cdw_ncurses_error_string(rv));
+			post_form(wizard.cdw_form->form);
+
+			/* Make sure that cdw widgets are presented properly. */
+			cdw_form_redraw_widgets(wizard.cdw_form);
+
+			int current_fi = field_index(current_field(wizard.cdw_form->form));
+			cdw_form_driver_focus_on(wizard.cdw_form, current_fi);
+		}
+	} else { /* Current selection of "Image format" dropdown is UDF. */
+
+		if (line->chars_max == CDW_UDF_LVID_LEN) {
+			/* The input line already has proper width, so
+			   we assume that it is an input field
+			   suitable for UDF volume label. Don't
+			   replace it with new input field. */
+		} else {
+			cdw_vdm ("INFO: replacing input field with field for UDF\n");
+
+			free_field(wizard.cdw_form->fields[f_volume_id_i]);
+			cdw_safe_input_line_delete(&line);
+
+			cdw_form_description_to_safe_input_line(&udf_line, wizard.cdw_form, CDW_WIDGET_SAFE_INPUT_LINE, f_volume_id_i);
+
+			/* Don't forget about updating the label too. */
+			cdw_assert (CDW_UDF_LVID_LEN == 126, "ERROR: wrong value of volume len\n");
+			cdw_dynamic_label_set_new(label, "Logical Volume ID (126 chars max)");
+
+			unpost_form(wizard.cdw_form->form);
+			int rv = set_form_fields(wizard.cdw_form->form, wizard.cdw_form->fields);
+			cdw_vdm ("INFO: set_form_fields() returns %s\n", cdw_ncurses_error_string(rv));
+			post_form(wizard.cdw_form->form);
+
+			/* Make sure that cdw widgets are presented properly. */
+			cdw_form_redraw_widgets(wizard.cdw_form);
+
+			int current_fi = field_index(current_field(wizard.cdw_form->form));
+			cdw_form_driver_focus_on(wizard.cdw_form, current_fi);
+		}
+	}
+
+	cdw_form_bind_input_and_label(wizard.cdw_form, f_volume_id_i, f_volume_id_l);
+
+	return 0;
+}
+
+
+
+
+
+/* Depending on state of "image format" dropdown, set up proper input
+   field and label for "volume id". */
+void cdw_image_wizard_resolve_volume_id(cdw_form_t *cdw_form)
+{
+	CDW_DROPDOWN *dd = cdw_form_get_dropdown(cdw_form, f_image_format_dd);
+	cdw_id_t id = cdw_dropdown_get_current_item_id(dd);
+
+	cdw_image_wizard_on_select_image_format(NULL, &id);
+
+	return;
+}
+
+
 
 
 
@@ -503,11 +686,22 @@
 static char *cdw_wizard_window_tip = (char *) NULL;
 
 
+/* We may create three different "options" windows:
+   - one type for mkisofs (with main options and with meta-data read
+     from rc file),
+   - second type for xorriso (with main options and with meta-data
+     read from rc file);
+
+   - third type for mkudffs - currently only for this tool, maybe some
+     other tools from "make UDF image" recipe will also get their
+     options and their separate options page.
+
+   Each window type has N pages. We need to distinguish them with these IDs. */
 #define ISO9660_PAGE_ID_MKISOFS   0
 #define ISO9660_PAGE_ID_XORRISO   1
 #define ISO9660_PAGE_ID_MKISOFSRC 2
 #define ISO9660_PAGE_ID_XORRISORC 3
-
+#define ISO9660_PAGE_ID_MKUDFFS   4
 
 /* this is first main component of options window: a big table
    aggregating data and functions that prepare the data; the data
@@ -520,7 +714,10 @@
 	/* 2TRANS: label of a tab in configuration window with options related to meta information of ISO9660 file system */
 	{ false, CDW_MKISOFSRC_OPTIONS_N_FIELDS,     cdw_mkisofsrc_options_form,     gettext_noop("Meta data"), (cdw_form_t *) NULL },
 	/* 2TRANS: label of a tab in configuration window with options related to meta information of ISO9660 file system */
-	{ false, CDW_XORRISORC_N_FIELDS,             cdw_xorrisorc_form,             gettext_noop("Meta data"), (cdw_form_t *) NULL }};
+	{ false, CDW_XORRISORC_N_FIELDS,             cdw_xorrisorc_form,             gettext_noop("Meta data"), (cdw_form_t *) NULL },
+	/* 2TRANS: label of a tab in configuration window with options related to UDF; probably you don't want to translate this */
+	{ false, CDW_MKUDFFS_N_FIELDS,               cdw_mkudffs_options_form,       gettext_noop("UDF tools"),      (cdw_form_t *) NULL }
+};
 
 
 /* this is a pointer to second main component of options window:
@@ -530,8 +727,13 @@
 
 
 
-cdw_rv_t cdw_iso9660_wizard_options(cdw_task_t *task)
+cdw_rv_t cdw_image_wizard_options(cdw_task_t *task)
 {
+	cdw_assert (wizard.image_format == CDW_IMAGE_FORMAT_ISO9660
+		    || wizard.image_format == CDW_IMAGE_FORMAT_UDF,
+
+		    "ERROR: invalid image format %lld\n", wizard.image_format);
+
 	/* 2TRANS: this is message at the bottom of options window;
 	   cancel means: quit without saving; '%d' is an integer used to
 	   create label of function key, e.g. "F10" */
@@ -542,34 +744,50 @@
 		cdw_vdm ("ERROR: failed to create window tip\n");
 		return CDW_ERROR;
 	}
-	int n_tabs = 2; /* mkisofs|xorriso + mkisofsrc|xorrisorc */
-	/* 2TRANS: this is title of cdw options main window */
-	c_twindow = cdw_tabs_window_init(n_tabs, _("ISO9660 options"), cdw_wizard_window_tip);
-	cdw_tabs_window_set_geometry(c_twindow, OPTIONS_HEIGHT, OPTIONS_WIDTH, 4, 4, TABS_WIDTH);
-
-
-	/* prepare tabbed window */
-	cdw_id_t id = 0;
-	int ind = 0;
-	/* tool-specific options: mkisofs or xorriso */
-	if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-		id = ISO9660_PAGE_ID_MKISOFS;
-		cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
-		ind++;
-
-		id = ISO9660_PAGE_ID_MKISOFSRC;
-		cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
-		ind++;
-	} else {
-		id = ISO9660_PAGE_ID_XORRISO;
-		cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
-		ind++;
 
-		id = ISO9660_PAGE_ID_XORRISORC;
+	int n_tabs = 0;
+	if (wizard.image_format == CDW_IMAGE_FORMAT_ISO9660) {
+		n_tabs = 2; /* mkisofs|xorriso + mkisofsrc|xorrisorc */
+		/* 2TRANS: this is title of cdw options main window */
+		c_twindow = cdw_tabs_window_init(n_tabs, _("ISO9660 options"), cdw_wizard_window_tip);
+		cdw_tabs_window_set_geometry(c_twindow, OPTIONS_HEIGHT, OPTIONS_WIDTH, 4, 4, TABS_WIDTH);
+
+
+		/* prepare tabbed window */
+		cdw_id_t id = 0;
+		int ind = 0;
+		/* tool-specific options: mkisofs or xorriso */
+		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
+			id = ISO9660_PAGE_ID_MKISOFS;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+			ind++;
+
+			id = ISO9660_PAGE_ID_MKISOFSRC;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+			ind++;
+		} else {
+			id = ISO9660_PAGE_ID_XORRISO;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+			ind++;
+
+			id = ISO9660_PAGE_ID_XORRISORC;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+			ind++;
+		}
+	} else { /* wizard.image_format == CDW_IMAGE_FORMAT_UDF */
+		n_tabs = 1; /* mkudffs */
+		/* 2TRANS: this is title of cdw options main window */
+		c_twindow = cdw_tabs_window_init(n_tabs, _("UDF options"), cdw_wizard_window_tip);
+		cdw_tabs_window_set_geometry(c_twindow, OPTIONS_HEIGHT, OPTIONS_WIDTH, 4, 4, TABS_WIDTH);
+
+		/* prepare tabbed window */
+		int ind = 0;
+		cdw_id_t id = ISO9660_PAGE_ID_MKUDFFS;
 		cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
 		ind++;
 	}
 
+
 	cdw_tabs_window_add_return_keys(c_twindow,
 					KEY_F(CDW_CONFIG_UI_SnC_KEY_A), KEY_F(CDW_CONFIG_UI_SnC_KEY_B),
 					CDW_KEY_ESCAPE, 'q', 'Q', 0);
@@ -578,7 +796,7 @@
 
 	/* prepare forms in the tabbed window */
 	for (int i = 0; i < n_tabs; i++) {
-		id = c_twindow->tabs[i].id;
+		cdw_id_t id = c_twindow->tabs[i].id;
 
 		c_pages[id].cdw_form = cdw_form_new(c_pages[id].n_fields);
 		c_pages[id].cdw_form->form_id = id;
@@ -611,8 +829,8 @@
 
 	bool old_follow_symlinks = task->create_image.follow_symlinks;
 
-	cdw_rv_t crv = cdw_iso9660_wizard_options_window_driver(task);
-	cdw_iso9660_options_window_destroy();
+	cdw_rv_t crv = cdw_image_wizard_options_window_driver(task);
+	cdw_image_options_window_destroy();
 	if (crv == CDW_OK) {
 		cdw_main_ui_handle_follow_symlinks_change(old_follow_symlinks, task->create_image.follow_symlinks);
 		return CDW_OK;
@@ -628,7 +846,7 @@
 /**
    \brief Destructor function for cdw options window
 */
-void cdw_iso9660_options_window_destroy(void)
+void cdw_image_options_window_destroy(void)
 {
 	if (cdw_wizard_window_tip != (char *) NULL) {
 		free(cdw_wizard_window_tip);
@@ -673,7 +891,7 @@
    \return CDW_CANCEL if user pressed ESCAPE key in options window
    \return CDW_OK if user pressed F10 and validation of \p tmp config was successful
 */
-cdw_rv_t cdw_iso9660_wizard_options_window_driver(cdw_task_t *task)
+cdw_rv_t cdw_image_wizard_options_window_driver(cdw_task_t *task)
 {
 	while (1) {
 		int key = cdw_tabs_window_driver(c_twindow);
@@ -689,7 +907,7 @@
 			}
 			cdw_id_t page_id = 0;
 			int fi = 0;
-			cdw_rv_t valid = cdw_iso9660_wizard_options_validate_and_save(task, &page_id, &fi);
+			cdw_rv_t valid = cdw_image_wizard_options_validate_and_save(task, &page_id, &fi);
 			if (valid == CDW_NO) { /* some option field is invalid */
 
 				/* 2TRANS: this is title of dialog window */
@@ -720,53 +938,72 @@
 
 
 
-cdw_rv_t cdw_iso9660_wizard_options_validate_and_save(cdw_task_t *task, cdw_id_t *page_id, int *fi)
+cdw_rv_t cdw_image_wizard_options_validate_and_save(cdw_task_t *task, cdw_id_t *page_id, int *fi)
 {
-	if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-		cdw_id_t id = ISO9660_PAGE_ID_MKISOFS;
-		cdw_rv_t crv = cdw_mkisofs_options_validate(c_pages[id].cdw_form, fi);
-		if (crv == CDW_NO) {
-			*page_id = id;
-			return CDW_NO;
-		}
-		id = ISO9660_PAGE_ID_MKISOFSRC;
-		crv = cdw_mkisofsrc_options_validate(c_pages[id].cdw_form, fi);
-		if (crv == CDW_NO) {
-			*page_id = id;
-			return CDW_NO;
-		}
-	} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
-		cdw_id_t id = ISO9660_PAGE_ID_XORRISO;
-		cdw_rv_t crv = cdw_xorriso_iso_options_validate(c_pages[id].cdw_form, fi);
-		if (crv == CDW_NO) {
-			*page_id = id;
+	if (wizard.image_format == CDW_IMAGE_FORMAT_ISO9660) {
+		if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
+			cdw_id_t id = ISO9660_PAGE_ID_MKISOFS;
+			cdw_rv_t crv = cdw_mkisofs_options_validate(c_pages[id].cdw_form, fi);
+			if (crv == CDW_NO) {
+				*page_id = id;
+				return CDW_NO;
+			}
+
+			id = ISO9660_PAGE_ID_MKISOFSRC;
+			crv = cdw_mkisofsrc_options_validate(c_pages[id].cdw_form, fi);
+			if (crv == CDW_NO) {
+				*page_id = id;
+				return CDW_NO;
+			}
+
+			/* First validate both pages, and only then save. */
+
+			id = ISO9660_PAGE_ID_MKISOFS;
+			cdw_mkisofs_options_save(c_pages[id].cdw_form, task);
+
+			id = ISO9660_PAGE_ID_MKISOFSRC;
+			cdw_mkisofsrc_options_save(c_pages[id].cdw_form, task);
+
+		} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
+			cdw_id_t id = ISO9660_PAGE_ID_XORRISO;
+			cdw_rv_t crv = cdw_xorriso_iso_options_validate(c_pages[id].cdw_form, fi);
+			if (crv == CDW_NO) {
+				*page_id = id;
+				return CDW_NO;
+			}
+
+			id = ISO9660_PAGE_ID_XORRISORC;
+			crv = cdw_xorrisorc_validate(c_pages[id].cdw_form, fi);
+			if (crv == CDW_NO) {
+				*page_id = id;
+				return CDW_NO;
+			}
+
+			/* First validate both pages, and only then save. */
+
+			id = ISO9660_PAGE_ID_XORRISO;
+			cdw_xorriso_iso_options_save(c_pages[id].cdw_form, task);
+
+			id = ISO9660_PAGE_ID_XORRISORC;
+			cdw_xorrisorc_save(c_pages[id].cdw_form, task);
+
+		} else {
+			cdw_assert (0, "ERROR: invalid tool id for task \"create image\": %lld\n",
+				    task->create_image.tool.id);
 			return CDW_NO;
 		}
-		id = ISO9660_PAGE_ID_XORRISORC;
-		crv = cdw_xorrisorc_validate(c_pages[id].cdw_form, fi);
+
+	} else {
+		cdw_id_t id = ISO9660_PAGE_ID_MKUDFFS;
+		cdw_rv_t crv = cdw_mkudffs_options_validate(c_pages[id].cdw_form, fi);
 		if (crv == CDW_NO) {
 			*page_id = id;
 			return CDW_NO;
 		}
-	} else {
-		cdw_assert (0, "ERROR: invalid tool id for task \"create image\": %lld\n",
-			    task->create_image.tool.id);
-		return CDW_NO;
-	}
-
 
-	if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-		cdw_id_t id = ISO9660_PAGE_ID_MKISOFS;
-		cdw_mkisofs_options_save(c_pages[id].cdw_form, task);
-
-		id = ISO9660_PAGE_ID_MKISOFSRC;
-		cdw_mkisofsrc_options_save(c_pages[id].cdw_form, task);
-	} else {
-		cdw_id_t id = ISO9660_PAGE_ID_XORRISO;
-		cdw_xorriso_iso_options_save(c_pages[id].cdw_form, task);
+		/* First validate the page, and only then save. */
 
-		id = ISO9660_PAGE_ID_XORRISORC;
-		cdw_xorrisorc_save(c_pages[id].cdw_form, task);
+		cdw_mkudffs_options_save(c_pages[id].cdw_form, task);
 	}
 
 	return CDW_OK;
@@ -790,7 +1027,7 @@
    \return CDW_OK on success
    \return CDW_NO if any value in main wizard page is invalid
 */
-cdw_rv_t cdw_iso9660_wizard_validate_and_save(cdw_task_t *task, int *fi)
+cdw_rv_t cdw_image_wizard_validate_and_save(cdw_task_t *task, int *fi)
 {
 	/* validate */
 	const char *s = field_buffer(wizard.cdw_form->fields[f_volume_id_i], 0);
@@ -800,10 +1037,10 @@
 		return CDW_NO;
 	}
 
-	s = field_buffer(wizard.cdw_form->fields[f_iso_file_i], 0);
+	s = field_buffer(wizard.cdw_form->fields[f_image_file_i], 0);
 	crv = cdw_string_security_parser(s, (char *) NULL);
 	if (crv == CDW_NO) {
-		*fi = f_iso_file_i;
+		*fi = f_image_file_i;
 		return CDW_NO;
 	}
 
@@ -812,8 +1049,49 @@
 	strncpy(task->create_image.volume_id, s, CDW_ISO9660_VOLI_LEN);
 	task->create_image.volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
 
-	s = cdw_form_get_string(wizard.cdw_form, f_iso_file_i);
-	cdw_string_set(&(task->create_image.iso9660_file_fullpath), s);
+	s = cdw_form_get_string(wizard.cdw_form, f_image_file_i);
+	cdw_string_set(&(task->create_image.image_file_fullpath), s);
 
 	return CDW_OK;
 }
+
+
+
+
+
+/**
+   Dropdown list to select image file format: ISO9660 or UDF.
+*/
+CDW_DROPDOWN *cdw_img_wizard_make_image_format_dropdown(WINDOW *window, int begin_y, int begin_x, int width)
+{
+	cdw_id_clabel_t items[CDW_IMAGE_WIZARD_FORMATS_MAX];
+	int n_items = 0;
+
+	if (cdw_ext_tools_get_n_iso9660_handlers() > 0) {
+
+		/* There is some tool needed to create ISO9660 image -
+		   either mkisofs (or its replacement genisoimage), or
+		   xorriso. */
+
+		items[n_items].id = cdw_img_wizard_formats[CDW_IMAGE_FORMAT_ISO9660].id;
+		items[n_items].label = cdw_img_wizard_formats[CDW_IMAGE_FORMAT_ISO9660].label;
+		n_items++;
+	}
+
+
+	if (cdw_ext_tools_get_n_udf_handlers() == 1) {
+		/* Full set of tools needed to create UDF file is present.
+		   FIXME: the "1" above is only temporary - the list will be longer. */
+
+		items[n_items].id = cdw_img_wizard_formats[CDW_IMAGE_FORMAT_UDF].id;
+		items[n_items].label = cdw_img_wizard_formats[CDW_IMAGE_FORMAT_UDF].label;
+		n_items++;
+	}
+
+	CDW_DROPDOWN *dd = cdw_dropdown_maker_wrapper(window, begin_y, begin_x, width, n_items, items);
+
+	/* If the dd contains both ISO9660 and UDF labels, ISO9660 will be first. */
+	cdw_dropdown_set_current_item_by_ind(dd, 0);
+
+	return dd;
+}
diff -Naur orig/src/user_interface/cdw_iso9660_wizard.h patched/src/user_interface/cdw_iso9660_wizard.h
--- orig/src/user_interface/cdw_iso9660_wizard.h	2011-01-23 20:33:09.000000000 +0100
+++ patched/src/user_interface/cdw_iso9660_wizard.h	2014-01-23 22:27:08.000000000 +0100
@@ -1,10 +1,10 @@
-#ifndef H_CDW_ISO9660_WIZARD
-#define H_CDW_ISO9660_WIZARD
+#ifndef H_CDW_IMAGE_WIZARD
+#define H_CDW_IMAGE_WIZARD
 
 #include "main.h"
 #include "cdw_task.h"
 
-cdw_rv_t cdw_iso9660_wizard(cdw_task_t *task);
+cdw_rv_t cdw_image_wizard(cdw_task_t *task);
 
 
-#endif /* #ifndef H_CDW_ISO9660_WIZARD */
+#endif /* #ifndef H_CDW_IMAGE_WIZARD */
diff -Naur orig/src/user_interface/cdw_list_display.c patched/src/user_interface/cdw_list_display.c
--- orig/src/user_interface/cdw_list_display.c	2012-03-11 17:08:37.000000000 +0100
+++ patched/src/user_interface/cdw_list_display.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -119,10 +119,10 @@
 */
 CDW_LIST_DISPLAY *cdw_list_display_new(WINDOW *parent, int n_lines, int n_cols, int begin_y, int begin_x, cdw_colors_t colors)
 {
-	cdw_assert (parent != (WINDOW *) NULL, "ERROR: called the function with null parent window\n");
+	cdw_assert (parent, "ERROR: called the function with null parent window\n");
 
 	CDW_LIST_DISPLAY *display = (CDW_LIST_DISPLAY *) malloc(sizeof(CDW_LIST_DISPLAY));
-	if (display == (CDW_LIST_DISPLAY *) NULL) {
+	if (!display) {
 		cdw_vdm ("ERROR: failed to allocate memory for display\n");
 		return (CDW_LIST_DISPLAY *) NULL;
 	}
@@ -146,7 +146,7 @@
 	display->subwindow = derwin(display->window,
 				    (int) display->n_lines, (int) display->n_cols,
 				    (int) display->begin_y, (int) display->begin_x);
-	if (display->subwindow == (WINDOW *) NULL) {
+	if (!display->subwindow) {
 		cdw_vdm ("ERROR: failed to create subwindow for embedded display\n");
 
 		free(display);
@@ -195,14 +195,14 @@
 		return;
 	}
 
-	if ((*display)->subwindow == (WINDOW *) NULL) {
+	if (!(*display)->subwindow) {
 		cdw_vdm ("ERROR: \"display->subwindow\" is NULL\n");
 	} else {
 		delwin((*display)->subwindow);
 		(*display)->subwindow = (WINDOW *) NULL;
 	}
 
-	if ((*display)->window == (WINDOW *) NULL) {
+	if (!(*display)->window) {
 		cdw_vdm ("ERROR: \"display->window\" is NULL\n");
 	} /* no "else", we can't free parent window */
 
@@ -266,8 +266,8 @@
 */
 int cdw_list_display_driver(CDW_LIST_DISPLAY *display)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: \"display\" argument in NULL\n");
-	cdw_assert (display->display_item != NULL, "ERROR: the display doesn't have ->display_item() set\n");
+	cdw_assert (display, "ERROR: \"display\" argument in NULL\n");
+	cdw_assert (display->display_item, "ERROR: the display doesn't have ->display_item() set\n");
 
 	size_t h_offset = 0; /* indicates if and how much content of the window was moved to left */
 
@@ -418,9 +418,9 @@
 */
 void cdw_list_display_refresh(CDW_LIST_DISPLAY *display)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: \"display\" argument is NULL\n");
-	cdw_assert (display->window != (WINDOW *) NULL, "ERROR: \"display->window\" is NULL\n");
-	cdw_assert (display->subwindow != (WINDOW *) NULL, "ERROR: \"display->subwindow\" is NULL\n");
+	cdw_assert (display, "ERROR: \"display\" argument is NULL\n");
+	cdw_assert (display->window, "ERROR: \"display->window\" is NULL\n");
+	cdw_assert (display->subwindow, "ERROR: \"display->subwindow\" is NULL\n");
 
 	wrefresh(display->subwindow);
 	redrawwin(display->window);
@@ -461,9 +461,9 @@
 */
 void cdw_list_display_scroll_to_current(CDW_LIST_DISPLAY *display, size_t h_offset, bool highlight)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: \"display\" argument is NULL\n");
-	cdw_assert (display->subwindow != (WINDOW *) NULL, "ERROR: \"display->subwindow\" is NULL\n");
-	cdw_assert (display->display_item != NULL, "ERROR: ->display_item() function pointer is NULL\n");
+	cdw_assert (display, "ERROR: \"display\" argument is NULL\n");
+	cdw_assert (display->subwindow, "ERROR: \"display->subwindow\" is NULL\n");
+	cdw_assert (display->display_item, "ERROR: ->display_item() function pointer is NULL\n");
 
 	if (display->n_items == 0) {
 		/* perfectly normal situation, but it means that we have
@@ -531,7 +531,7 @@
 */
 void cdw_list_display_add_return_key(CDW_LIST_DISPLAY *display, int c)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: \"display\" argument is NULL\n");
+	cdw_assert (display, "ERROR: \"display\" argument is NULL\n");
 	cdw_assert (display->n_return_chars < N_RETURN_KEYS_MAX,
 		    "ERROR: there are already %d / %d return chars in the display, can't add another one\n",
 		    display->n_return_chars, N_RETURN_KEYS_MAX);
@@ -567,7 +567,7 @@
 */
 void cdw_list_display_add_return_keys(CDW_LIST_DISPLAY *display, ...)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: \"display\" argument is NULL\n");
+	cdw_assert (display, "ERROR: \"display\" argument is NULL\n");
 	cdw_assert (display->n_return_chars < N_RETURN_KEYS_MAX,
 		    "ERROR: there are already %d / %d return keys in the form, can't add another one\n",
 		    display->n_return_chars, N_RETURN_KEYS_MAX);
@@ -602,11 +602,10 @@
 */
 bool cdw_list_display_is_return_key(CDW_LIST_DISPLAY *display, int c)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: \"display\" argument is NULL\n");
+	cdw_assert (display, "ERROR: \"display\" argument is NULL\n");
 	cdw_assert (c != 0, "ERROR: asking for 0, which is an initialization value\n");
 
-	int i = 0;
-	for (i = 0; i < display->n_return_chars; i++) {
+	for (int i = 0; i < display->n_return_chars; i++) {
 		if (display->return_chars[i] == c) {
 			return true;
 		}
@@ -640,7 +639,7 @@
 */
 cdw_rv_t cdw_list_display_remove_item(CDW_LIST_DISPLAY *display, size_t item_i)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: display is null\n");
+	cdw_assert (display, "ERROR: display is null\n");
 	cdw_assert (display->n_items > 0, "ERROR: you called the function for display with empty list\n");
 	cdw_assert (display->list != (cdw_dll_item_t *) NULL, "ERROR: list associated with the display is null\n");
 
@@ -648,7 +647,7 @@
 
 #ifndef NDEBUG
 	cdw_dll_item_t *item = cdw_dll_ith_item(display->list, display->current_item_ind);
-	cdw_assert (item->data == NULL, "ERROR: item payload is not NULL, trying to leak memory?\n");
+	cdw_assert (!item->data, "ERROR: item payload is not NULL, trying to leak memory?\n");
 #endif
 
 #ifndef NDEBUG
@@ -736,7 +735,7 @@
 
 void cdw_list_display_scroll_to(CDW_LIST_DISPLAY *display, size_t current_item_ind, size_t h_offset, bool highlight)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: passed NULL display to function\n");
+	cdw_assert (display, "ERROR: passed NULL display to function\n");
 	if (display->n_items > 0) {
 		cdw_assert (current_item_ind < display->n_items, "ERROR: item index %zd is larger than number of items %zd\n",
 			    current_item_ind, display->n_items);
@@ -754,7 +753,7 @@
 
 void *cdw_list_display_get_current_item_data(CDW_LIST_DISPLAY *display)
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: passed NULL display to function\n");
+	cdw_assert (display, "ERROR: passed NULL display to function\n");
 	cdw_assert (display->n_items > display->current_item_ind,
 		    "ERROR, current item index (0-based) is %zd but number of items is %zd\n",
 		    display->current_item_ind, display->n_items);
@@ -788,7 +787,7 @@
 */
 bool cdw_list_display_is_member(CDW_LIST_DISPLAY *display, void *data, bool (*pred)(const void *, const void *))
 {
-	cdw_assert (display != (CDW_LIST_DISPLAY *) NULL, "ERROR: display is NULL\n");
+	cdw_assert (display, "ERROR: display is NULL\n");
 	cdw_assert (pred != (bool (*)(const void *, const void *)) NULL, "ERROR: predicate function is NULL\n");
 	return cdw_dll_is_member(display->list, data, pred);
 }
diff -Naur orig/src/user_interface/cdw_main_window.c patched/src/user_interface/cdw_main_window.c
--- orig/src/user_interface/cdw_main_window.c	2012-03-31 15:46:25.000000000 +0200
+++ patched/src/user_interface/cdw_main_window.c	2014-03-24 22:22:58.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #define _BSD_SOURCE /* strdup() */
 
@@ -23,8 +23,9 @@
 #include <unistd.h>
 #include <errno.h>
 
+#include "config_cdw.h"
+
 #include "cdw_fs.h"
-#include "config.h"
 #include "cdw_main_window.h"
 #include "cdw_config.h"
 #include "gettext.h"
@@ -40,11 +41,11 @@
 
 extern cdw_config_t global_config; /* main cdw configuration variable */
 
-static void cdw_main_ui_init_values(void);
-static void cdw_main_ui_recalculate_sizes(void);
+static void cdw_main_window_init_values(void);
+static void cdw_main_window_recalculate_sizes(void);
 
 /** \brief Number of items in main cdw menu on the left; does not include last NULL item */
-#define MENU_ITEMS 10
+#define MENU_ITEMS 11
 /* in theory this is just a length of labels in menu, and indirectly
    width of menu; but it also (indirectly) influences width of
    "disc info" box below menu */
@@ -93,13 +94,13 @@
 
 
 
-static cdw_rv_t cdw_main_ui_main_menu_view_create(void);
-static cdw_rv_t cdw_main_ui_files_list_view_create(void);
-static cdw_rv_t cdw_main_ui_volume_info_view_create(void);
-static cdw_rv_t cdw_main_ui_disc_info_view_create(void);
-static cdw_rv_t cdw_main_ui_tooltips_view_create(void);
+static cdw_rv_t cdw_main_window_main_menu_view_create(void);
+static cdw_rv_t cdw_main_window_files_list_view_create(void);
+static cdw_rv_t cdw_main_window_volume_info_view_create(void);
+static cdw_rv_t cdw_main_window_disc_info_view_create(void);
+static cdw_rv_t cdw_main_window_tooltips_view_create(void);
 
-static void cdw_main_ui_volume_info_view_display_data_new(bool show_disc_info, size_t n_files, double used_space, double selected_size, int total_space);
+static void cdw_main_window_volume_info_view_display_data_new(bool show_disc_info, size_t n_files, double used_space, double selected_size, int total_space);
 
 
 
@@ -114,67 +115,80 @@
    \return CDW_GEN_ERROR if some other error occurred
    \return CDW_OK if user interface was initialized properly
 */
-cdw_rv_t cdw_main_ui_init(void)
+cdw_rv_t cdw_main_window_module_init(void)
 {
-	cdw_main_ui_init_values();
+	cdw_main_window_init_values();
 
 	/* main NCURSES window */
 	cdw_ui.window = newwin(cdw_ui.n_rows, cdw_ui.n_cols, 0, 0);
 	if (!cdw_ui.window) {
-		cdw_main_ui_clean();
+		cdw_main_window_module_clean();
 		cdw_vdm ("ERROR: failed to create main app window\n");
 		return CDW_ERROR;
 	}
 
-	keypad(cdw_ui.window, TRUE);
-	wbkgd(cdw_ui.window, A_NORMAL | COLOR_PAIR(CDW_COLORS_MAIN));
+	int rv = wrefresh(cdw_ui.window);
+	cdw_vdm_n ("wrefresh", rv, "");
+
+	rv = keypad(cdw_ui.window, TRUE);
+	cdw_vdm_n ("keypad", rv, "");
+	rv = wbkgd(cdw_ui.window, A_NORMAL | COLOR_PAIR(CDW_COLORS_MAIN));
+	cdw_vdm_n ("wbkgd", rv, "");
 
 	/* left-hand, main app menu */
-	cdw_rv_t crv = cdw_main_ui_main_menu_view_create();
+	cdw_rv_t crv = cdw_main_window_main_menu_view_create();
 	if (crv != CDW_OK) {
-		cdw_main_ui_clean();
+		cdw_main_window_module_clean();
 		cdw_vdm ("ERROR: failed to create main app menu\n");
 		return CDW_ERROR;
 	}
 
-	mvwaddch(cdw_ui.window, 0, 1, ACS_RTEE);
-	wattrset(cdw_ui.window, A_BOLD | COLOR_PAIR(CDW_COLORS_TITLE));
-	mvwprintw(cdw_ui.window, 0, 2, " ::: %s %s ::: ", PACKAGE, VERSION);
-	wattrset(cdw_ui.window, A_NORMAL | COLOR_PAIR(CDW_COLORS_MAIN));
-	waddch(cdw_ui.window, ACS_LTEE);
+	rv = mvwaddch(cdw_ui.window, 0, 1, ACS_RTEE);
+	cdw_vdm_n ("mvwaddch", rv, "");
+	rv = wattrset(cdw_ui.window, A_BOLD | COLOR_PAIR(CDW_COLORS_TITLE));
+	cdw_vdm_n ("wattrset", rv, "");
+	rv = mvwprintw(cdw_ui.window, 0, 2, " ::: %s %s ::: ", PACKAGE, VERSION);
+	cdw_vdm_n ("mvwprintw", rv, "");
+	rv = wattrset(cdw_ui.window, A_NORMAL | COLOR_PAIR(CDW_COLORS_MAIN));
+	cdw_vdm_n ("wattrset", rv, "");
+	rv = waddch(cdw_ui.window, ACS_LTEE);
+	cdw_vdm_n ("waddch", rv, "");
+
+	rv = wrefresh(cdw_ui.window);
+	cdw_vdm_n ("wrefresh", rv, "");
 
 	/* window in which selected files are displayed */
-	crv = cdw_main_ui_files_list_view_create();
+	crv = cdw_main_window_files_list_view_create();
 	if (crv != CDW_OK) {
-		cdw_main_ui_clean();
+		cdw_main_window_module_clean();
 		cdw_vdm ("ERROR: failed to create selected files list view\n");
 		return CDW_ERROR;
 	}
 
 	/* area displaying summarized information about selected files
 	   and disc capacity/usage/estimated future usage */
-	crv = cdw_main_ui_volume_info_view_create();
+	crv = cdw_main_window_volume_info_view_create();
 	if (crv != CDW_OK) {
-		cdw_main_ui_clean();
+		cdw_main_window_module_clean();
 		cdw_vdm ("ERROR: failed to create selected files info view\n");
 		return CDW_ERROR;
 	}
 
-	cdw_main_window_volume_info_view_update(-1, -1, true, global_config.follow_symlinks);
+	cdw_main_window_volume_info_view_update(-1, -1, true);
 	//selected_files_size_mb = 0.0;
 	//cdw_ui_volume_info_view_display_data();
 
 	/* area displaying information about current optical disc */
-	crv = cdw_main_ui_disc_info_view_create();
+	crv = cdw_main_window_disc_info_view_create();
 	if (crv != CDW_OK) {
-		cdw_main_ui_clean();
+		cdw_main_window_module_clean();
 		cdw_vdm ("ERROR: failed to create disc info view\n");
 		return CDW_ERROR;
 	}
 
-	crv = cdw_main_ui_tooltips_view_create();
+	crv = cdw_main_window_tooltips_view_create();
 	if (crv != CDW_OK) {
-		cdw_main_ui_clean();
+		cdw_main_window_module_clean();
 		cdw_vdm ("ERROR: failed to create help view\n");
 		return CDW_ERROR;
 	}
@@ -195,12 +209,11 @@
    this functions and all functions called check if resource was allocated,
    and if so, then proceeds with cleaning resource.
 */
-void cdw_main_ui_clean(void)
+void cdw_main_window_module_clean(void)
 {
 	if (cdw_ui.main_menu.menu) {
-		unpost_menu(cdw_ui.main_menu.menu);
 		cdw_ncurses_delete_menu_and_items(&(cdw_ui.main_menu.menu));
-		cdw_assert (!cdw_ui.main_menu.menu, "failed to set cdw_ui.main_menu.menu to NULL\n")
+		cdw_assert (!cdw_ui.main_menu.menu, "ERROR: failed to set cdw_ui.main_menu.menu to NULL\n")
 	}
 
 	/* IMPORTANT: first clean subwindows, then parent window */
@@ -220,10 +233,11 @@
 	   and then you press 'q' again and then select 'ok'
 	   2. if you run cdw in 81x26 terminal */
 
+
+	cdw_file_manager_delete_selected_files_view();
 	cdw_window_delete(&cdw_ui.files_list_view.subwindow);
+
 	cdw_window_delete(&cdw_ui.main_menu.menu_subwindow);
-	cdw_assert (cdw_ui.main_menu.menu_subwindow == (WINDOW *) NULL,
-		    "ERROR: delete() function didn't set a window to NULL\n");
 	cdw_window_delete(&cdw_ui.main_menu.subwindow);
 	cdw_window_delete(&cdw_ui.volume_info_view.subwindow);
 	cdw_window_delete(&cdw_ui.disc_info_view.subwindow);
@@ -247,7 +261,7 @@
    also called when application receives information that terminal size has
    changed (TODO: catching signal is to be implemented).
 */
-void cdw_main_ui_recalculate_sizes(void)
+void cdw_main_window_recalculate_sizes(void)
 {
 	/* There are only few known limitations on UI layout:
 	    - tooltips area at the bottom of window must have exactly 1 line;
@@ -331,7 +345,7 @@
 	/* 2TRANS: label of item in main menu: write
 	   selected dirs/files to optical disc */
 	gettext_noop(" Write files to disc "),
-	/* 2TRANS: label of item in main menu: create ISO9660 image file
+	/* 2TRANS: label of item in main menu: create ISO9660 or UDF image file
 	   using selected files/directories */
 	gettext_noop(" Create image "),
 	/* 2TRANS: label of item in main menu: write (burn) ISO9660 image
@@ -346,6 +360,9 @@
 	gettext_noop(" Verify data "),
 	/* 2TRANS: label of item in main menu: change configuration of cdw */
 	gettext_noop(" Configuration "),
+	/* 2TRANS: label of item in main menu: information about the
+	   application (authors, license, web address). */
+	gettext_noop(" About "),
 	/* 2TRANS: label of item in main menu: exit cdw */
 	gettext_noop(" Quit ") };
 
@@ -362,7 +379,7 @@
    \return CDW_MEM_ERROR if some malloc() error occurred
    \return CDW_ERROR if some other error
 */
-cdw_rv_t cdw_main_ui_main_menu_view_create(void)
+cdw_rv_t cdw_main_window_main_menu_view_create(void)
 {
 	cdw_assert (cdw_ui.window, "calling the function for null main window\n");
 
@@ -456,7 +473,7 @@
    \return CDW_OK on success
    \return CDW_ERROR if some error occurred
 */
-cdw_rv_t cdw_main_ui_files_list_view_create(void)
+cdw_rv_t cdw_main_window_files_list_view_create(void)
 {
 	cdw_assert (cdw_ui.window, "ERROR: calling the function for null main window\n");
 
@@ -503,7 +520,7 @@
    \return CDW_OK on success
    \return CDW_ERROR if some error occurred
 */
-cdw_rv_t cdw_main_ui_disc_info_view_create(void)
+cdw_rv_t cdw_main_window_disc_info_view_create(void)
 {
 	cdw_ui.disc_info_view.subwindow = derwin(cdw_ui.window,
 						 cdw_ui.disc_info_view.n_rows,
@@ -530,7 +547,7 @@
 
 	   cdw_disc_get(disc); */
 
-	cdw_main_ui_disc_info_view_display_data(disc);
+	cdw_main_window_disc_info_view_display_data(disc);
 	cdw_disc_delete(&disc);
 
 	return CDW_OK;
@@ -551,7 +568,7 @@
 
    \param disc - variable from which to take values to display
 */
-void cdw_main_ui_disc_info_view_display_data(const cdw_disc_t *disc)
+void cdw_main_window_disc_info_view_display_data(const cdw_disc_t *disc)
 {
 	cdw_assert (cdw_ui.disc_info_view.subwindow, "called the function for NULL subwindow\n");
 	cdw_assert (disc, "called the function with NULL argument\n");
@@ -596,6 +613,7 @@
 		   "refresh" means - (re)read disc information and display
 		   it in disc information area */
 		mvwprintw(cdw_ui.disc_info_view.subwindow, row_h + 2, pcol, _("'R' key - refresh"));
+		wrefresh(cdw_ui.disc_info_view.subwindow);
 		return;
 	} else {
 		if (disc->state_empty == CDW_TRUE) {
@@ -664,9 +682,9 @@
 /**
    Refresh part of main application window.
 */
-void cdw_main_ui_main_window_wrefresh_part(int n_lines, int n_cols, int begin_y, int begin_x)
+void cdw_main_window_wrefresh_part(int n_lines, int n_cols, int begin_y, int begin_x)
 {
-	if (cdw_ui.window == (WINDOW *) NULL) {
+	if (!cdw_ui.window) {
 		/* previously there was an assert() here, but this function
 		   may be called by dialogbox when main ui (and thus main
 		   window) is not initialized yet; example: when after starting
@@ -674,12 +692,12 @@
 		   main window is still not created, but cdw displays dialog
 		   that informs user about resetting path, and the dialog
 		   window calls this function */
-		cdw_vdm ("ERROR: called the function for null window\n");
+		cdw_vdm ("ERROR: called the function for NULL window\n");
 		return;
 	}
 
 	WINDOW *window = derwin(cdw_ui.window, n_lines, n_cols, begin_y, begin_x);
-	if (window == (WINDOW *) NULL) {
+	if (!window) {
 		cdw_vdm ("ERROR: failed to create derived window for refresh\n");
 	} else {
 		wrefresh(window);
@@ -696,9 +714,9 @@
 /**
    \brief Redraw content of main app window
 */
-void cdw_main_ui_main_window_wrefresh(void)
+void cdw_main_window_wrefresh(void)
 {
-	cdw_assert (cdw_ui.window, "called the function for null window\n");
+	cdw_assert (cdw_ui.window, "ERROR: called the function for NULL window\n");
 
 	redrawwin(cdw_ui.window);
 	wrefresh(cdw_ui.window);
@@ -710,7 +728,7 @@
 
 
 
-cdw_rv_t cdw_main_window_volume_info_view_update(long long disc_sectors_used, long long disc_sectors_total, bool rescan_selected_files, bool follow_symlinks)
+cdw_rv_t cdw_main_window_volume_info_view_update(long long disc_sectors_used, long long disc_sectors_total, bool rescan_selected_files)
 {
 	static long long disc_capacity_sectors_used = 0;
 	static long long disc_capacity_sectors_total = 0;
@@ -730,7 +748,7 @@
 	double selected_files_size_mb = 0.0;
 	if (n_files != 0) {
 		if (rescan_selected_files) {
-			selected_files_size_mb = cdw_file_manager_calculate_selected_files_size_mb(follow_symlinks);
+			selected_files_size_mb = cdw_file_manager_calculate_selected_files_size_mb();
 			if (selected_files_size_mb < 0.0) {
 				error = true;
 			}
@@ -744,7 +762,7 @@
 	double used_space =  0.0;
 	bool show_disc_info = false;
 
-	if (global_config.volume_size_id == CDW_CONFIG_VOLUME_SIZE_AUTO) {
+	if (global_config.general.volume_size_id == CDW_CONFIG_VOLUME_SIZE_AUTO) {
 		used_space = (double) disc_capacity_sectors_used / 512.0;
 		total_space = (int) disc_capacity_sectors_total / 512;
 
@@ -760,10 +778,10 @@
 	} else {
 		/* either custom value, or constant value corresponding
 		   to total capacity of some preselected disc type */
-		total_space = (int) cdw_config_get_current_volume_size_value();
+		total_space = (int) cdw_config_get_current_volume_size_value_megabytes();
 	}
 
-	cdw_main_ui_volume_info_view_display_data_new(show_disc_info, n_files, used_space, selected_files_size_mb, total_space);
+	cdw_main_window_volume_info_view_display_data_new(show_disc_info, n_files, used_space, selected_files_size_mb, total_space);
 
 	if (error) {
 		cdw_vdm ("ERROR: size of selected files is < 0\n");
@@ -772,7 +790,7 @@
 				   /* 2TRANS: this is message in dialog window */
 				   _("One or more of selected files may be missing. Check log file for more information - press 'L' key in main window."),
 				   CDW_BUTTONS_OK, CDW_COLORS_WARNING);
-		cdw_main_ui_main_window_wrefresh();
+		cdw_main_window_wrefresh();
 		return CDW_ERROR;
 	} else {
 		return CDW_OK;
@@ -807,10 +825,9 @@
    \param selected_size - size of selected files
    \param total_space - total capacity of optical disc
 */
-void cdw_main_ui_volume_info_view_display_data_new(bool show_disc_info, size_t n_files, double used_space, double selected_size, int total_space)
+void cdw_main_window_volume_info_view_display_data_new(bool show_disc_info, size_t n_files, double used_space, double selected_size, int total_space)
 {
-	cdw_assert (cdw_ui.volume_info_view.subwindow != (WINDOW *) NULL,
-		    "ERROR: called the function for NULL subwindow\n");
+	cdw_assert (cdw_ui.volume_info_view.subwindow, "ERROR: called the function for NULL subwindow\n");
 	WINDOW *subwindow = cdw_ui.volume_info_view.subwindow;
 	wattrset(subwindow, A_BOLD | COLOR_PAIR(CDW_COLORS_MAIN));
 
@@ -897,6 +914,26 @@
 	}
 
 	wattrset(subwindow, A_NORMAL | COLOR_PAIR(CDW_COLORS_MAIN));
+
+
+	/* 2TRANS: this is title of area showing basic info
+	   (total size, usage of space on optical disc) about
+	   selected files. "Volume" as in "disc volume", or
+	   "ISO9660 volume". */
+	const char *title = _("Volume");
+	const char *message = global_config.general.selected_follow_symlinks ?
+		/* 2TRANS: this is a message saying that when
+		   calculating size of selected files, cdw will follow
+		   symbolic links that it will find among selected
+		   files. */
+		_("Symlinks in selected files are followed")
+		/* 2TRANS: this is a message saying that when
+		   calculating size of selected files, cdw will not
+		   follow symbolic links that it will find among
+		   selected files. */
+		: _("Symlinks in selected files are not followed");
+	cdw_window_add_strings(subwindow, title, message);
+
 	wrefresh(subwindow);
 
 	return;
@@ -917,7 +954,7 @@
    is deleted because it is outdated (new one should be created only
    when attempting to do sth using selected files).
 */
-cdw_rv_t cdw_main_ui_delete_from_selected_files(void)
+cdw_rv_t cdw_main_window_delete_from_selected_files(void)
 {
         size_t num = cdw_file_manager_number_of_selected_files();
 
@@ -948,7 +985,7 @@
 
 
 
-cdw_rv_t cdw_main_ui_add_to_selected_files(void)
+cdw_rv_t cdw_main_window_add_to_selected_files(void)
 {
 	cdw_file_manager_handle_adding_to_selected_files();
 
@@ -966,7 +1003,7 @@
    \return CDW_OK on success
    \return CDW_ERROR if some error occurred
 */
-cdw_rv_t cdw_main_ui_volume_info_view_create(void)
+cdw_rv_t cdw_main_window_volume_info_view_create(void)
 {
 	cdw_assert (cdw_ui.window, "calling the function for null main window\n");
 
@@ -982,9 +1019,13 @@
 	}
 
 	cdw_window_add_strings(cdw_ui.volume_info_view.subwindow,
-			       /* 2TRANS: this is title of area showing basic info (total
-				  size, CD usage) about selected files */
-			       _("ISO volume"), (char *) NULL);
+			       /* 2TRANS: this is title of area
+				  showing basic info (total size,
+				  usage of space on optical disc)
+				  about selected files. "Volume" as in
+				  "disc volume", or "ISO9660
+				  volume". */
+			       _("Volume"), (char *) NULL);
 
 	return CDW_OK;
 }
@@ -999,7 +1040,7 @@
    Try to display GPL-2 file from system-default location, if this fails
    then display basic license info in dialog box.
 */
-void cdw_main_ui_show_license(void)
+void cdw_main_window_show_license(void)
 {
 	size_t len1 = strlen(COMMON);
 	size_t len2 = strlen("/GPL-2");
@@ -1027,7 +1068,7 @@
 		   directly as function's argument */
 		/* 2TRANS: this is standard information about licensing
 		   program under GPL; it may be non-translatable in your area */
-		char *msg = strdup(_("This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"));
+		char *msg = strdup(_("This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA."));
 		if (msg) {
 			/* 2TRANS: this is title of dialog window, in which
 			   basic information about licensing is displayed */
@@ -1054,7 +1095,7 @@
 
 
 
-cdw_rv_t cdw_main_ui_tooltips_view_create(void)
+cdw_rv_t cdw_main_window_tooltips_view_create(void)
 {
 	cdw_assert (cdw_ui.window, "calling the function for null main window\n");
 
@@ -1079,7 +1120,7 @@
 
 
 
-WINDOW *cdw_main_ui_get_tooltips_subwindow(void)
+WINDOW *cdw_main_window_get_tooltips_subwindow(void)
 {
 	cdw_assert(cdw_ui.tooltips_view.subwindow,
 		   "called help tooltip before initializing cdw ui -> tooltips view\n");
@@ -1090,7 +1131,7 @@
 
 
 
-MENU *cdw_main_ui_get_main_menu(void)
+MENU *cdw_main_window_get_main_menu(void)
 {
 	cdw_assert(cdw_ui.main_menu.menu,
 		   "called help tooltip before initializing cdw ui -> menu\n");
@@ -1101,7 +1142,7 @@
 
 
 
-WINDOW *cdw_main_ui_get_main_window(void)
+WINDOW *cdw_main_window_get_main_window(void)
 {
 	cdw_assert(cdw_ui.window,
 		   "called help tooltip before initializing cdw ui -> window\n");
@@ -1113,7 +1154,7 @@
 
 
 
-void cdw_main_ui_init_values(void)
+void cdw_main_window_init_values(void)
 {
 	cdw_ui.tooltips_view.subwindow = (WINDOW *) NULL;
 	cdw_ui.disc_info_view.subwindow = (WINDOW *) NULL;
@@ -1126,7 +1167,7 @@
 	cdw_ui.window = (WINDOW *) NULL;
 
 	/* 'sizes' are layout constraints and parameters */
-	cdw_main_ui_recalculate_sizes();
+	cdw_main_window_recalculate_sizes();
 
 	return;
 }
@@ -1135,14 +1176,14 @@
 
 
 
-void cdw_main_ui_handle_follow_symlinks_change(bool old_state, bool current_state)
+void cdw_main_window_handle_follow_symlinks_change(bool old_state, bool current_state)
 {
 	if (current_state != old_state) {
 		/* user changed the way how symlinks should be treated,
 		   and this may affect size of selected files */
 		cdw_vdm ("INFO: changed \"follow symlinks\" to %s, recalculating files size\n",
 			 current_state ? "true" : "false");
-		cdw_main_window_volume_info_view_update(-1, -1, true, current_state);
+		cdw_main_window_volume_info_view_update(-1, -1, true);
 		cdw_file_manager_regenerate_selected_files_view();
 	} else {
 		cdw_vdm ("INFO: \"follow symlinks\" is still %s\n", current_state ? "true" : "false");
@@ -1154,91 +1195,22 @@
 
 
 
-/* *** unused code *** */
-
-#if 0
-
-/**
-   \brief Display CD usage summary on bottom of cdw window
-
-   Display amount of space used by selected files, amount of
-   space that would stay free on disk, and percent of CD disk usage.
-   CD/DVD size is taken from config panel/file.
-
-   I try to pack all information in just two lines, so that it is always
-   visible and always updated when file selector is on top and files_info area
-   is partially covered by file selector.
-
-   The function does not collect nor calculate any data (except for some local
-   variables), it just uses current values from some global variables.
-*/
-void cdw_main_ui_volume_info_view_display_data(size_t n_files, double size_mb)
+void cdw_about(void)
 {
-	cdw_assert (cdw_ui.volume_info_view.subwindow != (WINDOW *) NULL,
-		    "called the function for null subwindow\n");
-	WINDOW *subwindow = cdw_ui.volume_info_view.subwindow;
-	wattrset(subwindow, A_BOLD | COLOR_PAIR(CDW_COLORS_MAIN));
+	cdw_buttons_dialog(_("About cdw"),
+			   /* 2TRANS: this is message in dialog window */
+			   _("cdw 0.7.1 - front end for tools creating ISO9660 and UDF file systems and writing data to optical discs.\n"
+
+			     "Copyright (C) 2002 Varkonyi Balazs\n"
+			     "Copyright (C) 2007 - 2014 Kamil Ignacak\n"
+
+			     "This program is free software; you can redistribute it and/or modify\n"
+			     "it under the terms of the GNU General Public License as published by\n"
+			     "the Free Software Foundation; either version 2 of the License, or\n"
+			     "(at your option) any later version.\n"
 
-	int s_row = 3;    /* "Size: " row */
-	int b_row = 4;    /* usage bar row */
-        const int col = 2;        /* start column for content drawn in window */
-	const int bar_width = 30; /* number of cells in bar, does not include borders */
-
-	/* clean row in which usage bar and information about space usage is displayed */
-	mvwhline(subwindow, s_row, 1, ' ', cdw_ui.volume_info_view.n_cols - 2);
-	mvwhline(subwindow, b_row, 1, ' ', cdw_ui.volume_info_view.n_cols - 2);
-
-	/* left and right border of usage bar */
-	mvwaddch(subwindow, b_row, col, '[');
-	mvwaddch(subwindow, b_row, col + bar_width + 1, ']');
-
-	bool too_much = false;
-	if (size_mb > (double) global_config.volume_size_value) {
-		too_much = true;
-		wattrset(subwindow, COLOR_PAIR(CDW_COLORS_ERROR));
-	} else {
-		/* 0.8 (80%): arbitrary value of 'safe' level of disc usage */
-		if (size_mb <= ((double) global_config.volume_size_value * 0.8)) {
-			wattrset(subwindow, COLOR_PAIR(CDW_COLORS_MAIN));
-		} else {
-			wattrset(subwindow, COLOR_PAIR(CDW_COLORS_WARNING));
-		}
-	}
-
-	double percent = size_mb * 100 / ((double) global_config.volume_size_value);
-	int n = 0;
-	if (too_much) { /* files size is larger than available space */
-		/* 2TRANS: this string displays total size of dirs/files
-		   selected ('%.1f'), total available space ('%d') and
-		   number of items selected (second '%d'). */
-		mvwprintw(subwindow, s_row, col, _("%.1f/%ld MB in %d items"),
-			  size_mb, global_config.volume_size_value, n_files);
-
-		n = bar_width;
-	} else {
-		/* 2TRANS: this string displays total size of dirs/files
-		   selected ('%.1f'), total available space ('%d'), number of
-		   items selected (second '%d'), and free space left ('%.0f'). */
-		mvwprintw(subwindow, s_row, col, _("%.1f/%ld MB in %d items, %.0f MB free"),
-			  size_mb, global_config.volume_size_value,
-			  n_files, (double) global_config.volume_size_value - size_mb);
-
-		n = (int) ((percent * (double) bar_width) / 100);
-	}
-
-	mvwhline(subwindow, b_row, col + 1, ACS_BLOCK, n); /* +1 to skip left brace [ */
-
-	mvwprintw(subwindow, b_row, col + bar_width + 3, /* 3 to move past indicator bar */
-		  /* 2TRANS: this is information about usage of CD space:
-		     '%2.1f%%' is information about used space, displayed
-		     as percentage of total disc size */
-		  _("%2.1f%%"), percent);
-
-	wattrset(subwindow, A_NORMAL | COLOR_PAIR(CDW_COLORS_MAIN));
-	wrefresh(subwindow);
+			     "Press F9 or F10 key in main window to see full license text."),
+			   CDW_BUTTONS_OK, CDW_COLORS_DIALOG);
 
 	return;
 }
-
-#endif
-
diff -Naur orig/src/user_interface/cdw_main_window.h patched/src/user_interface/cdw_main_window.h
--- orig/src/user_interface/cdw_main_window.h	2012-01-21 17:00:18.000000000 +0100
+++ patched/src/user_interface/cdw_main_window.h	2014-03-12 21:41:46.000000000 +0100
@@ -47,31 +47,32 @@
 	CDW_MENU_ERASE_DISC,
 	CDW_MENU_VERIFY,
 	CDW_MENU_CONFIG,
+	CDW_MENU_ABOUT,
 	CDW_MENU_EXIT_CDW
 } cdw_menu_items_t;
 
 
-cdw_rv_t cdw_main_ui_init(void);
-void     cdw_main_ui_clean(void);
+cdw_rv_t cdw_main_window_module_init(void);
+void     cdw_main_window_module_clean(void);
 
 
-void cdw_main_ui_main_window_wrefresh_part(int n_lines, int n_cols, int begin_y, int begin_x);
-void cdw_main_ui_main_window_wrefresh(void);
+void cdw_main_window_wrefresh_part(int n_lines, int n_cols, int begin_y, int begin_x);
+void cdw_main_window_wrefresh(void);
 
-//cdw_rv_t cdw_main_ui_disc_info_view_update(void);
-void cdw_main_ui_disc_info_view_display_data(const cdw_disc_t *disc);
+void cdw_main_window_disc_info_view_display_data(const cdw_disc_t *disc);
 
-cdw_rv_t cdw_main_window_volume_info_view_update(long long disc_sectors_used, long long disc_sectors_total, bool rescan_selected_files, bool follow_symlinks);
+cdw_rv_t cdw_main_window_volume_info_view_update(long long disc_sectors_used, long long disc_sectors_total, bool rescan_selected_files);
 
-cdw_rv_t cdw_main_ui_add_to_selected_files(void);
-cdw_rv_t cdw_main_ui_delete_from_selected_files(void);
+cdw_rv_t cdw_main_window_add_to_selected_files(void);
+cdw_rv_t cdw_main_window_delete_from_selected_files(void);
 
-void cdw_main_ui_show_license(void);
+void cdw_about(void);
+void cdw_main_window_show_license(void);
 
-void cdw_main_ui_handle_follow_symlinks_change(bool old_state, bool current_state);
+void cdw_main_window_handle_follow_symlinks_change(bool old_state, bool current_state);
 
-WINDOW *cdw_main_ui_get_tooltips_subwindow(void);
-WINDOW *cdw_main_ui_get_main_window(void);
-MENU *cdw_main_ui_get_main_menu(void);
+WINDOW *cdw_main_window_get_tooltips_subwindow(void);
+WINDOW *cdw_main_window_get_main_window(void);
+MENU   *cdw_main_window_get_main_menu(void);
 
 #endif /* H_CDW_MAIN_WINDOW */
diff -Naur orig/src/user_interface/cdw_ncurses.c patched/src/user_interface/cdw_ncurses.c
--- orig/src/user_interface/cdw_ncurses.c	2012-02-26 15:24:22.000000000 +0100
+++ patched/src/user_interface/cdw_ncurses.c	2014-03-24 22:19:40.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #define _GNU_SOURCE /* strndup() */
 
@@ -110,10 +110,16 @@
 cdw_rv_t cdw_ncurses_init(void)
 {
 	initscr();
-	start_color();
-	cbreak();
-	noecho();
-	keypad(stdscr, TRUE);
+	int rv = start_color();
+	cdw_vdm_n ("start_color", rv, "");
+	rv = cbreak();
+	cdw_vdm_n ("cbreak", rv, "");
+	rv = noecho();
+	cdw_vdm_n ("noecho", rv, "");
+	rv = keypad(stdscr, TRUE);
+	cdw_vdm_n ("keypad", rv, "");
+	rv = refresh();
+	cdw_vdm_n ("refresh", rv, "");
 
 	if (cdw_commandline_arguments.escdelay_ms != -1) {
 		set_escdelay(cdw_commandline_arguments.escdelay_ms);
@@ -220,7 +226,7 @@
 
 	cdw_vdm ("INFO: reallocing buffer for len = %zd\n", len);
 	char *tmp = (char *) realloc(*buffer, len + 1);
-	if (tmp == (char *) NULL) {
+	if (!tmp) {
 		cdw_vdm ("ERROR: failed to reallocate buffer with new len %zd\n", len);
 		return CDW_ERROR;
 	} else {
@@ -324,28 +330,20 @@
 		   # Free the menu, using free_menu().
 		   # Free the items using free_item(). */
 
-		unpost_menu(*menu);
+		int rv = unpost_menu(*menu);
+		cdw_vdm_n ("unpost_menu", rv, "");
+
 		ITEM **items = menu_items(*menu);
 
-		int rv = free_menu(*menu);
+		rv = free_menu(*menu);
 		*menu = (MENU *) NULL;
-		if (rv == E_OK) {
-			;
-		} else if (rv == E_SYSTEM_ERROR) {
-			int e = errno;
-			cdw_vdm ("ERROR: failed to free menu, error = \"%s\"\n", strerror(e));
-		} else if (rv == E_BAD_ARGUMENT) {
-			cdw_vdm ("ERROR: failed to free menu, bad argument\n");
-		} else if (rv == E_POSTED) {
-			cdw_vdm ("ERROR: failed to free menu, menu is posted\n");
-		} else {
-			cdw_vdm ("ERROR: unrecognized error when calling free_menu: %d\n", rv);
-		}
+		cdw_vdm_n ("free_menu", rv, "");
 
 		if (items != (ITEM **) NULL) {
 			for (int i = 0; items[i] != (ITEM *) NULL; i++){
-				free_item(items[i]);
+				rv = free_item(items[i]);
 				items[i] = (ITEM *) NULL;
+				cdw_vdm_n ("free_item", rv, "");
 			}
 
 			free(items);
@@ -374,9 +372,11 @@
 		{ KEY_NPAGE,    "Page Down" },
 		{ KEY_HOME,     "KEY_HOME" },
 		{ KEY_END,      "KEY_END" },
+		{ KEY_EXIT,     "KEY_EXIT" },
 		{ ' ',          "SPACE" },
 		{ '\t',         "TAB" },
 		{ CDW_KEY_TAB,  "TAB" },
+		{ KEY_BTAB,     "BackTAB" },
 		{ KEY_F(1),     "F1" },
 		{ KEY_F(2),     "F2" },
 		{ KEY_F(3),     "F3" },
@@ -484,7 +484,7 @@
 			cdw_vdm ("ERROR: failed to turn off O_PUBLIC with field_opts_off(), error = \"%s\"\n", cdw_ncurses_error_string(e));
 		}
 	} else {
-		if (initial_value != (char *) NULL) {
+		if (initial_value) {
 			/* this may also set content of buffer to "" */
 			e = set_field_buffer(field, 0, initial_value);
 			if (e != E_OK) {
@@ -538,6 +538,7 @@
 	if (!field) {
 		int e = errno;
 		cdw_vdm ("ERROR: failed to create a field with new_field(), \"%s\"\n", cdw_ncurses_error_string(e));
+		cdw_vdm ("ERROR: n_lines = %d, n_cols = %d, begin_y = %d, begin_x = %d\n", n_lines, n_cols, begin_y, begin_x);
 		return (FIELD *) NULL;
 	}
 
@@ -592,12 +593,12 @@
 	                    int offscreen, int nbuffers); */
 
 	FIELD *field = new_field(1, 1, begin_y, begin_x, 0, 0);
-	if (field == (FIELD *) NULL) {
+	if (!field) {
 		cdw_vdm ("ERROR: failed to create a field with new_field\n");
 		return (FIELD *) NULL;
 	}
 	int rv = 0;
-	if (initial_value != (char *) NULL) {
+	if (initial_value) {
 		rv = set_field_buffer(field, 0, initial_value);
 		if (rv != E_OK) {
 			cdw_vdm ("ERROR: set_field_buffer() returns !E_OK\n");
@@ -685,37 +686,36 @@
 */
 FORM *cdw_ncurses_new_form(WINDOW *window, WINDOW *subwindow, FIELD *field[])
 {
-	cdw_assert (window != (WINDOW *) NULL, "ERROR: function called with window == NULL\n");
-	cdw_assert (subwindow != (WINDOW *) NULL, "ERROR: function called with subwindow == NULL\n");
+	cdw_assert (window, "ERROR: function called with window == NULL\n");
+	cdw_assert (subwindow, "ERROR: function called with subwindow == NULL\n");
 	cdw_assert (field != (FIELD **) NULL, "ERROR: function called with fields array == NULL\n");
 
 	FORM *form = new_form(field);
-	if (form == (FORM *) NULL) {
+	if (!form) {
 #ifndef NDEBUG
 		int e = errno;
-		cdw_vdm ("ERROR: failed to create form with new_form(), error code is \"%s\"\n",
-			 cdw_ncurses_error_string(e));
+		cdw_vdm ("ERROR: failed to create form with new_form(): \"%s\"\n", cdw_ncurses_error_string(e));
 #endif
 		return (FORM *) NULL;
 	}
 	int r;
 	r = set_form_win(form, window);
 	if (r != E_OK) {
-		cdw_vdm ("ERROR: failed to set form window with set_form_win(), error code is \"%s\"\n", cdw_ncurses_error_string(r));
+		cdw_vdm ("ERROR: failed to set form window with set_form_win(): \"%s\"\n", cdw_ncurses_error_string(r));
 		free_form(form);
 		form = (FORM *) NULL;
 		return (FORM *) NULL;
 	}
 	r = set_form_sub(form, subwindow);
 	if (r != E_OK) {
-		cdw_vdm ("ERROR: failed to set form subwindow with set_form_sub(), error code is \"%s\"\n", cdw_ncurses_error_string(r));
+		cdw_vdm ("ERROR: failed to set form subwindow with set_form_sub(): \"%s\"\n", cdw_ncurses_error_string(r));
 		free_form(form);
 		form = (FORM *) NULL;
 		return (FORM *) NULL;
 	}
 	r = post_form(form);
 	if (r != E_OK) {
-		cdw_vdm ("ERROR: failed to post form with post_form(), error code is \"%s\"\n", cdw_ncurses_error_string(r));
+		cdw_vdm ("ERROR: failed to post form with post_form(): \"%s\"\n", cdw_ncurses_error_string(r));
 		free_form(form);
 		form = (FORM *) NULL;
 		return (FORM *) NULL;
@@ -731,7 +731,7 @@
 /**
    \brief Get string from given field's buffer
 
-   Function removes trailing white chars from te string before returning it.
+   Function removes trailing white chars from the string before returning it.
 
    Function returns empty string ("") if given field's buffer is NULL.
 
@@ -741,10 +741,10 @@
 */
 char *cdw_ncurses_get_field_string(FIELD *field)
 {
-	assert(field != (FIELD *) NULL);
+	cdw_assert (field, "ERROR: \"field\" argument is NULL\n");
 
 	char *s = field_buffer(field, 0);
-	if (s == (char *) NULL) {
+	if (!s) {
 		return empty_string;
 	} else {
 		cdw_vdm ("INFO: returning field string \"%s\"\n", s);
@@ -752,36 +752,3 @@
 	}
 
 }
-
-
-
-/* *** unused code below */
-
-
-
-
-
-# if 0
-
-
-
-/**
-   \brief Get 0/1 state from a checkbox widget associated with given field
-
-   Check content of field's buffer (if it is "X" or not) and return 0 or 1.
-
-   The field must be configured and used as a checkbox (field of size 1x1),
-   because only first character of field's buffer is checked.
-
-   \param field - field that you want to inspect
-
-   \return true if given field's buffer contains "X" string
-   \return false if given field's buffer does not contain "X" string
-*/
-bool cdw_ncurses_get_field_bit(FIELD *field)
-{
-	cdw_assert (field != (FIELD *) NULL, "ERROR: field argument passed for examination is NULL\n");
-	return !strncmp(field_buffer(field, 0), "X", 1) ? true : false;
-}
-
-#endif
diff -Naur orig/src/user_interface/cdw_ncurses.h patched/src/user_interface/cdw_ncurses.h
--- orig/src/user_interface/cdw_ncurses.h	2012-01-04 20:29:13.000000000 +0100
+++ patched/src/user_interface/cdw_ncurses.h	2014-01-19 20:49:59.000000000 +0100
@@ -3,7 +3,7 @@
 
 #include <stddef.h>
 
-#include "config.h"
+#include "config_cdw.h"
 
 /* Some systems put ncurses headers in /usr/include, and somehow Autotools
    can't see them there; see Sourceforge for a feature request in cdw:
@@ -57,5 +57,3 @@
 const char *cdw_ncurses_key_label(int c);
 
 #endif /* H_CDW_NCURSES */
-
-
diff -Naur orig/src/user_interface/cdw_processwin.c patched/src/user_interface/cdw_processwin.c
--- orig/src/user_interface/cdw_processwin.c	2012-03-25 18:31:30.000000000 +0200
+++ patched/src/user_interface/cdw_processwin.c	2014-04-06 22:29:27.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdio.h>
@@ -29,6 +29,7 @@
 #include "cdw_window.h"
 #include "cdw_processwin.h"
 #include "cdw_debug.h"
+#include "cdw_string.h"
 
 
 /* *** some processwin layout constants *** */
@@ -52,7 +53,7 @@
 
 
 /* this string is used to erase parts of processwin - it has to be
- * filled with spaces (and ended with \0') first */
+  filled with spaces (and ended with \0') first */
 #define EMPTY_STRING_LEN PROCESSWIN_COLS - 2 - 1
 static char processwin_empty_string[EMPTY_STRING_LEN + 1];
 
@@ -66,6 +67,8 @@
 
 
 static void cdw_processwin_display_text_info(int row, const char *string);
+static void cdw_processwin_reset_progressbar(void);
+
 
 static struct {
 	/* has the window been created and displayed? can
@@ -74,10 +77,14 @@
 
 	WINDOW *window;
 
-	/* area where progress bar is displayed;
-	   may be used only by some instances of processwin */
+	/* Area where progress bar is displayed.
+	   May be used only by some instances of processwin. */
 	WINDOW *progressbar_sub;
 
+	/* Value indicated by progressbar. The variable is used to
+	   check how the progressbar should be drawn.  */
+	int progressbar_value;
+
 	WINDOW *subwindow_txt1;
 	WINDOW *subwindow_txt2;
 
@@ -93,19 +100,19 @@
 
 
 /**
- * \brief Create UI window in which progress of some process (perhaps created by fork()) is shown
- *
- * Create UI window to show progress of process, make some initialization, too.
- * Put \p window_title string in title area of window.
- * Put \p window_label in first row of window (below title).
- *
- * \param window_title - title of processwin window
- * \param window_label - initial information displayed in window
- * \param show_progress - should progress bar be displayed?
- *
- * \return CDW_OK on success
- * \return CDW_GEN_ERROR if function failed to create progress window
- */
+   \brief Create UI window in which progress of some process (perhaps created by fork()) is shown
+
+   Create UI window to show progress of process, make some initialization, too.
+   Put \p window_title string in title area of window.
+   Put \p window_label in first row of window (below title).
+
+   \param window_title - title of processwin window
+   \param window_label - initial information displayed in window
+   \param show_progress - should progress bar be displayed?
+
+   \return CDW_OK on success
+   \return CDW_GEN_ERROR if function failed to create progress window
+*/
 cdw_rv_t cdw_processwin_create(const char *window_title, const char *window_label, bool show_progress)
 {
 	if (processwin.active) {
@@ -129,7 +136,7 @@
 				   processwin.begin_y,
 				   processwin.begin_x);
 
-	if (processwin.window == (WINDOW *) NULL) {
+	if (!processwin.window) {
 		cdw_vdm ("ERROR: failed to create process window with newwin()\n");
 		return CDW_ERROR;
 	}
@@ -143,7 +150,7 @@
 					   processwin.n_cols - 2,
 					   processwin.subwindow_txt1_row, 1);
 
-	if (processwin.subwindow_txt1 == (WINDOW *) NULL) {
+	if (!processwin.subwindow_txt1) {
 		delwin(processwin.window);
 		processwin.window = (WINDOW *) NULL;
 		cdw_vdm ("ERROR: failed to create subwindow_txt1 with derwin()\n");
@@ -152,7 +159,7 @@
 	processwin.subwindow_txt2 = derwin(processwin.window, 2,
 					   processwin.n_cols - 2,
 					   processwin.subwindow_txt2_row, 1);
-	if (processwin.subwindow_txt2 == (WINDOW *) NULL) {
+	if (!processwin.subwindow_txt2) {
 		delwin(processwin.subwindow_txt1);
 		processwin.subwindow_txt1 = (WINDOW *) NULL;
 		delwin(processwin.window);
@@ -166,6 +173,7 @@
 	if (show_progress) {
 		cdw_processwin_add_progress_bar();
 	}
+	processwin.progressbar_value = 0;
 
 	processwin.active = true;
 
@@ -182,21 +190,21 @@
 
 
 /**
- * \brief Destroy UI window created by processwin_create()
- *
- * This is just wrapper for simple destroying of curses window
- * Set second argument as true if you want to wait for user key
- * before destroying the window - user will have time and opportunity
- * to read \p status_string. The string will be displayed
- * as primary information string in processwin. Secondary information
- * string will be sth like "press any key". If \p is false, then
- * \p status_string won't be displayed, and window will be destroyed
- * without waiting for any user action.
- *
- * \param status_string - text displayed in process window
- * \param wait - decides if the window should wait for a key from
- *                    user before closing.
- */
+   \brief Destroy UI window created by processwin_create()
+
+   This is just wrapper for simple destroying of curses window
+   Set second argument as true if you want to wait for user key
+   before destroying the window - user will have time and opportunity
+   to read \p status_string. The string will be displayed
+   as primary information string in processwin. Secondary information
+   string will be sth like "press any key". If \p is false, then
+   \p status_string won't be displayed, and window will be destroyed
+   without waiting for any user action.
+
+   \param status_string - text displayed in process window
+   \param wait - decides if the window should wait for a key from
+   user before closing.
+*/
 void cdw_processwin_destroy(const char *status_string, bool wait)
 {
 	if (!processwin.active) {
@@ -226,10 +234,10 @@
 	processwin.window = (WINDOW *) NULL;
 	processwin.active = false;
 
-	cdw_main_ui_main_window_wrefresh_part(processwin.n_rows,
-					      processwin.n_cols,
-					      processwin.begin_y,
-					      processwin.begin_x);
+	cdw_main_window_wrefresh_part(processwin.n_rows,
+				      processwin.n_cols,
+				      processwin.begin_y,
+				      processwin.begin_x);
 
 	return;
 }
@@ -265,6 +273,8 @@
 	cdw_processwin_display_progress(0, 100, "");
 	cdw_processwin_wrefresh();
 
+	processwin.progressbar_value = 0;
+
 	return;
 }
 
@@ -279,7 +289,7 @@
 		return;
 	}
 
-	if (processwin.progressbar_sub == (WINDOW *) NULL) {
+	if (!processwin.progressbar_sub) {
 		cdw_vdm ("ERROR: called the function for process window without progress bar\n");
 		return;
 	}
@@ -298,6 +308,8 @@
 	delwin(processwin.progressbar_sub);
 	processwin.progressbar_sub = (WINDOW *) NULL;
 
+	processwin.progressbar_value = 0;
+
 	return;
 }
 
@@ -306,14 +318,14 @@
 
 
 /**
- * \brief Display ETA string in progress window
- *
- * The function itself doesn't know anything about calculation of ETA, it just
- * knows if and where to display it. You can erase place where usually
- * ETA string is displayed by providing null string ((char *) NULL) as an argument.
- *
- * \param eta_string - string containing ETA information
- */
+   \brief Display ETA string in progress window
+
+   The function itself doesn't know anything about calculation of ETA, it just
+   knows if and where to display it. You can erase place where usually
+   ETA string is displayed by providing null string ((char *) NULL) as an argument.
+
+   \param eta_string - string containing ETA information
+*/
 void cdw_processwin_display_eta(const char *eta_string)
 {
 	if (!processwin.active) {
@@ -354,21 +366,25 @@
 
 
 /**
- * \brief Draw progress bar strip in processwin
- *
- * Draw progress bar strip (not the borders, those should be created
- * when processwin itself is created) of length=value. Maximal value of
- * variable 'value' should be normalized by caller to width of processwin.
- *
- * \param value - current length of progress bar to draw
- * \param color1 - color name used for drawing a progress bar
- * \param color2 - name of normal color of process window
- * \param c - character to be used to draw bar
- */
+   \brief Draw progress bar strip in processwin
+
+   Draw progress bar strip (not the borders, those should be created
+   when processwin itself is created) of length=value. Maximal value of
+   variable 'value' should be normalized by caller to width of processwin.
+
+   \param value - current length of progress bar to draw
+   \param color1 - color name used for drawing a progress bar
+   \param color2 - name of normal color of process window
+   \param c - character to be used to draw bar
+*/
 void cdw_processwin_draw_progress_bar(int value, cdw_colors_t color1, cdw_colors_t color2, chtype c)
 {
-	cdw_assert (processwin.progressbar_sub != (WINDOW *) NULL,
-		    "ERROR: called %s() for processwin without progressbar\n", __func__);
+	cdw_assert (processwin.progressbar_sub, "ERROR: called %s() for processwin without progressbar\n", __func__);
+
+	if (value < processwin.progressbar_value) {
+		/* Progress bar will have to be drawn from scratch. */
+		cdw_processwin_reset_progressbar();
+	}
 
 	const int start_col = 1;
 	(void) wattrset(processwin.progressbar_sub, COLOR_PAIR(color1));
@@ -379,6 +395,8 @@
 	(void) wattrset(processwin.progressbar_sub, COLOR_PAIR(color2));
 	wrefresh(processwin.progressbar_sub);
 
+	processwin.progressbar_value = value;
+
 	return;
 }
 
@@ -387,20 +405,20 @@
 
 
 /**
- * Show (in processwin window) information about progress of process. Do this only if necessary.
- *
- * Check if value describing current status (in terms of percentage of task
- * done) has changed. If yes, then update processwin with new information
- * (which requires call of ncurses wrefresh()). If not then do nothing.
- *
- * \param current - current status of task - this is value of arbitrary unit,
- *                  reflecting current amount of work done
- * \param total - total size of task - this is value of arbitrary unit (but
- *                  the same as of 'current'), reflecting maximal amount of
- *                  work that has to be done
- * \param description - string containing data or information
- *                  prepared by caller (can be NULL or empty)
- */
+   \brief Show (in processwin window) information about progress of process. Do this only if necessary.
+
+   Check if value describing current status (in terms of percentage of task
+   done) has changed. If yes, then update processwin with new information
+   (which requires call of ncurses wrefresh()). If not then do nothing.
+
+   \param current - current status of task - this is value of arbitrary unit,
+                    reflecting current amount of work done
+   \param total - total size of task - this is value of arbitrary unit (but
+                    the same as of 'current'), reflecting maximal amount of
+                    work that has to be done
+   \param description - string containing data or information
+                    prepared by caller (can be NULL or empty)
+*/
 void cdw_processwin_display_progress_conditional(long current, long total, const char *description)
 {
 	/* assertion may fail if caller botched calculations of
@@ -432,36 +450,36 @@
 
 
 /**
- * \brief Show (in processwin window) information about progress of process.
- *
- * Show to user updated information about progress of current process. This
- * can be done in two ways: by displaying text line prepared by caller or by
- * showing percentage information.
- *
- * Third argument can have any character, even descriptive, but since this
- * function is called cdw_processwin_display_progress(), it would be nice if
- * this argument hold some sort of numerical information, perhaps with units
- * of measure.
- *
- * First and second argument should be provided without any preprocessing,
- * because they will be recalculated to percents like this:
- * percentage_info = (current_amount * 100) / total_amount.
- *
- * Percentage information is shown both in form of "x% done" text and in form
- * of progress bar.
- *
- * All information is displayed in one line, in following format:
- * "xx% done (current_value_string)". Both parts ('xx%done' and
- * 'current_value_string') can be omitted (set to 0 or (char *) NULL).
- *
- * \p description should be no longer than (PROCESSWIN_COLS - 2) chars,
- * including ending '\0'. It should be even shorter to make place for
- * numeric data displayed in the same line as \p description.
- *
- * \param current_amount - value representing current state (stage) of process
- * \param total_amount - value representing final, expected state (stage) of process
- * \param description - string containing details on data or other information
- */
+   \brief Show (in processwin window) information about progress of process.
+
+   Show to user updated information about progress of current process. This
+   can be done in two ways: by displaying text line prepared by caller or by
+   showing percentage information.
+
+   Third argument can have any character, even descriptive, but since this
+   function is called cdw_processwin_display_progress(), it would be nice if
+   this argument hold some sort of numerical information, perhaps with units
+   of measure.
+
+   First and second argument should be provided without any preprocessing,
+   because they will be recalculated to percents like this:
+   percentage_info = (current_amount  100) / total_amount.
+
+   Percentage information is shown both in form of "x% done" text and in form
+   of progress bar.
+
+   All information is displayed in one line, in following format:
+   "xx% done (current_value_string)". Both parts ('xx%done' and
+   'current_value_string') can be omitted (set to 0 or (char *) NULL).
+
+   \p description should be no longer than (PROCESSWIN_COLS - 2) chars,
+   including ending '\0'. It should be even shorter to make place for
+   numeric data displayed in the same line as \p description.
+
+   \param current_amount - value representing current state (stage) of process
+   \param total_amount - value representing final, expected state (stage) of process
+   \param description - string containing details on data or other information
+*/
 void cdw_processwin_display_progress(long current_amount, long total_amount, const char *description)
 {
 	bool has_descr = false; /* is description string non-empty? */
@@ -535,18 +553,18 @@
 
 
 /**
- * \brief Show (in processwin window) text information about status of process
- *
- * Display string with information, or erase (blank) it. The string is
- * displayed in first or second topmost row, depending on value of
- * first argument. Accepted values of \p row are 1 or 2.
- *
- * Set second argument to (char *) NULL if you want to erase it, or set
- * it to pointer to a valid string if you want to display the string.
- *
- * \param row - index of row that you want to update
- * \param string - string displayed in processwin
- */
+   \brief Show (in processwin window) text information about status of process
+
+   Display string with information, or erase (blank) it. The string is
+   displayed in first or second topmost row, depending on value of
+   first argument. Accepted values of \p row are 1 or 2.
+
+   Set second argument to (char *) NULL if you want to erase it, or set
+   it to pointer to a valid string if you want to display the string.
+
+   \param row - index of row that you want to update
+   \param string - string displayed in processwin
+*/
 void cdw_processwin_display_text_info(int row, const char *string)
 {
 	cdw_assert (row == 1 || row == 2, "ERROR: incorrect id of row to print in (%d), should be 1 or 2\n", row);
@@ -563,10 +581,10 @@
 	} else {
 		window = processwin.subwindow_txt2;
 	}
-	cdw_assert (window != (WINDOW *) NULL, "ERROR: attempting to print to NULL window\n");
+	cdw_assert (window, "ERROR: attempting to print to NULL window\n");
 
 	werase(window);
-	if (string != (char *) NULL && (strcmp(string, ""))) {
+	if (string && (strcmp(string, ""))) {
 		cdw_window_print_message(window, string, CDW_ALIGN_CENTER);
 	} else {
 		/* user may pass null pointer or empty string ("")
@@ -582,14 +600,14 @@
 
 
 /**
- * \brief Display fifo buffer information
- *
- * This function displays test string in form of "Fifo: %d%%" in
- * process window. It is useful when writing data to a disc.
- * If fifo value is lower than 25, the text background is highlighted.
- *
- * \param fifo_level - FIFO buffer usage value (0 - 100)
- */
+   \brief Display fifo buffer information
+
+   This function displays test string in form of "Fifo: %d%%" in
+   process window. It is useful when writing data to a disc.
+   If fifo value is lower than 25, the text background is highlighted.
+
+   \param fifo_level - FIFO buffer usage value (0 - 100)
+*/
 void cdw_processwin_display_fifo_and_speed(int fifo_level, int speed_decimal, int speed_fract)
 {
 	if (!processwin.active) {
@@ -720,10 +738,10 @@
 
 
 /**
- * \brief Very simple wrapper for functions refreshing processwin window
- *
- * First the window is touchwin()ed and then it is wrefresh()ed.
- */
+   \brief Very simple wrapper for functions refreshing processwin window
+
+   First the window is touchwin()ed and then it is wrefresh()ed.
+*/
 void cdw_processwin_force_refresh(void)
 {
 	if (!processwin.active) {
@@ -741,8 +759,8 @@
 
 
 /**
- * \brief Reset any information about progress accumulated so far in progress window
- */
+   \brief Reset any information about progress accumulated so far in progress window
+*/
 void cdw_processwin_reset_progress(void)
 {
 	if (!processwin.active) {
@@ -758,15 +776,25 @@
 	progress_string[PROCESSWIN_MAX_RTEXT_LEN] = '\0';
 	mvwprintw(processwin.window, PROCESSWIN_AMOUNT_ROW, 1, "%s", progress_string);
 
+	cdw_processwin_reset_progressbar();
+
+	wrefresh(processwin.window);
+
+	return;
+}
+
+
+
+
+
+void cdw_processwin_reset_progressbar(void)
+{
 	int ncols = getmaxx(processwin.progressbar_sub);
 	for (int i = 1; i < ncols - 1; i++) {
 		mvwprintw(processwin.progressbar_sub, 1, i, " ");
 	}
 
 	wrefresh(processwin.progressbar_sub);
-	wrefresh(processwin.window);
 
 	return;
 }
-
-
diff -Naur orig/src/user_interface/cdw_tabs_window.c patched/src/user_interface/cdw_tabs_window.c
--- orig/src/user_interface/cdw_tabs_window.c	2012-02-26 15:34:26.000000000 +0100
+++ patched/src/user_interface/cdw_tabs_window.c	2014-03-22 18:04:24.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #define _GNU_SOURCE /* asprintf() */
 #include <stdio.h>
@@ -75,7 +75,7 @@
 cdw_tabs_window_t *cdw_tabs_window_init(int n_tabs, const char *title, const char *subtitle)
 {
 	cdw_tabs_window_t *twindow = (cdw_tabs_window_t *) malloc(sizeof (cdw_tabs_window_t));
-	if (twindow == (cdw_tabs_window_t *) NULL) {
+	if (!twindow) {
 		cdw_vdm ("ERROR: failed to create tabs window\n");
 		return (cdw_tabs_window_t *) NULL;
 	}
@@ -96,7 +96,7 @@
 	twindow->geometry.tabs_width = 0;
 
 	twindow->tabs = (cdw_tab_t *) malloc((long unsigned int) n_tabs * sizeof (cdw_tab_t));
-	if (twindow->tabs == (cdw_tab_t *) NULL) {
+	if (!twindow->tabs) {
 		cdw_vdm ("ERROR: failed to create tabs in twindow\n");
 		free(twindow);
 		twindow = (cdw_tabs_window_t *) NULL;
@@ -105,7 +105,7 @@
 
 	twindow->title = strdup(title);
 	twindow->subtitle = strdup(subtitle);
-	if (twindow->title == (char *) NULL || twindow->subtitle == (char *) NULL) {
+	if (!twindow->title || !twindow->subtitle) {
 		cdw_vdm ("ERROR: failed to strdup window title \"%s\" or subtitle \"%s\"\n",
 			 title, subtitle);
 		cdw_tabs_window_delete(&twindow);
@@ -138,12 +138,12 @@
 
 cdw_rv_t cdw_tabs_window_append_tab(cdw_tabs_window_t *twindow, cdw_id_t id, int hotkey, const char *label)
 {
-	cdw_assert (twindow != (cdw_tabs_window_t *) NULL, "ERROR: twindow is NULL\n");
-	cdw_assert (label != (char *) NULL, "ERROR: tab label is NULL\n");
+	cdw_assert (twindow, "ERROR: twindow is NULL\n");
+	cdw_assert (label, "ERROR: tab label is NULL\n");
 
 	/* search for first free slot and "insert" a new tab there */
 	for (int i = 0; i < twindow->n_tabs; i++) {
-		if (twindow->tabs[i].label == (char *) NULL) {
+		if (!twindow->tabs[i].label) { /* Yes, this is a lame test of free slot. */
 			twindow->tabs[i].id = id;
 			asprintf(&(twindow->tabs[i].label), "<%s>%s", cdw_ncurses_key_label(hotkey), label);
 			cdw_vdm ("INFO: added label #%d: \"%s\"\n", i, twindow->tabs[i].label);
@@ -198,7 +198,7 @@
 	for (int i = 0; i < twindow->n_tabs; i++) {
 		WINDOW *window = twindow->tabs[i].subwindow;
 		/* this may happen if there are less tabs attached than n_tabs */
-		cdw_assert (window != (WINDOW *) NULL, "ERROR: subwindow #%d is NULL\n", i);
+		cdw_assert (window, "ERROR: subwindow #%d is NULL\n", i);
 
 		int start_col = twindow->geometry.n_cols - twindow->geometry.tabs_width;
 		mvwvline(window, 0, start_col, ACS_VLINE, twindow->geometry.n_cols);
@@ -251,7 +251,7 @@
 							 (LINES - twindow->geometry.n_lines) / 2,
 							 (COLS - twindow->geometry.n_cols) / 2,
 							 CDW_COLORS_DIALOG, twindow->title, twindow->subtitle);
-		if (twindow->tabs[i].window == (WINDOW *) NULL) {
+		if (!twindow->tabs[i].window) {
 			cdw_vdm ("ERROR: failed to create window #%d\n", i);
 			return CDW_ERROR;
 		}
@@ -260,13 +260,13 @@
 							    twindow->geometry.n_lines - 2,
 							    twindow->geometry.n_cols - 2, 1, 1,
 							    CDW_COLORS_DIALOG, (char *) NULL, (char *) NULL);
-		if (twindow->tabs[i].subwindow == (WINDOW *) NULL) {
+		if (!twindow->tabs[i].subwindow) {
 			cdw_vdm ("ERROR: failed to create subwindow #%d\n", i);
 			return CDW_ERROR;
 		}
 
 		twindow->tabs[i].panel = new_panel(twindow->tabs[i].window);
-		if (twindow->tabs[i].panel == (PANEL *) NULL) {
+		if (!twindow->tabs[i].panel) {
 			cdw_vdm ("ERROR: failed to create panel #%d with new_panel()\n", i);
 			return CDW_ERROR;
 		}
@@ -312,7 +312,7 @@
 
 			show_panel(twindow->tabs[twindow->current_tab].panel);
 			update_panels();
-			cdw_main_ui_main_window_wrefresh();
+			cdw_main_window_wrefresh();
 			cdw_tabs_window_refresh_current_tab(twindow);
 
 		} else if (cdw_tabs_window_is_return_key(twindow, key)) {
@@ -360,42 +360,28 @@
 
 void cdw_tabs_window_delete(cdw_tabs_window_t **twindow)
 {
-	if (*twindow == (cdw_tabs_window_t *) NULL) {
+	if (!*twindow) {
 		cdw_vdm ("WARNING: passed NULL twindow to the function\n");
 		return;
 	}
 
-	if ((*twindow)->title != (char *) NULL) {
-		free((*twindow)->title);
-		(*twindow)->title = (char *) NULL;
-	}
-	if ((*twindow)->subtitle != (char *) NULL) {
-		free((*twindow)->subtitle);
-		(*twindow)->subtitle = (char *) NULL;
-	}
+	cdw_string_delete(&(*twindow)->title);
+	cdw_string_delete(&(*twindow)->subtitle);
 
-	if ((*twindow)->tabs != (cdw_tab_t *) NULL) {
+	if ((*twindow)->tabs) {
 
 		for (int i = 0; i < (*twindow)->n_tabs; i++) {
 
-			if ((*twindow)->tabs[i].panel != (PANEL *) NULL) {
-				del_panel((*twindow)->tabs[i].panel);
+			if ((*twindow)->tabs[i].panel) {
+				int rv = del_panel((*twindow)->tabs[i].panel);
+				cdw_vdm_n ("del_panel", rv, "");
 				(*twindow)->tabs[i].panel = (PANEL *) NULL;
 			}
 
-			if ((*twindow)->tabs[i].subwindow != (WINDOW *) NULL) {
-				delwin((*twindow)->tabs[i].subwindow);
-				(*twindow)->tabs[i].subwindow = (WINDOW *) NULL;
-			}
+			cdw_window_delete(&(*twindow)->tabs[i].subwindow);
+			cdw_window_delete(&(*twindow)->tabs[i].window);
 
-			if ((*twindow)->tabs[i].window != (WINDOW *) NULL) {
-				delwin((*twindow)->tabs[i].window);
-				(*twindow)->tabs[i].window = (WINDOW *) NULL;
-			}
-			if ((*twindow)->tabs[i].label != (char *) NULL) {
-				free((*twindow)->tabs[i].label);
-				(*twindow)->tabs[i].label = (char *) NULL;
-			}
+			cdw_string_delete(&(*twindow)->tabs[i].label);
 		}
 
 		free((*twindow)->tabs);
@@ -426,7 +412,7 @@
 
 void cdw_tabs_window_add_return_key(cdw_tabs_window_t *twindow, int key)
 {
-	cdw_assert (twindow != (cdw_tabs_window_t *) NULL, "ERROR: \"twindow\" argument is NULL\n");
+	cdw_assert (twindow, "ERROR: \"twindow\" argument is NULL\n");
 	cdw_assert (twindow->n_return_keys < N_RETURN_KEYS_MAX,
 		    "ERROR: there are already %d / %d return keys in the window, can't add another one\n",
 		    twindow->n_return_keys, N_RETURN_KEYS_MAX);
@@ -482,7 +468,7 @@
 */
 bool cdw_tabs_window_is_return_key(cdw_tabs_window_t *twindow, int key)
 {
-	cdw_assert (twindow != (cdw_tabs_window_t *) NULL, "ERROR: \"twindow\" argument is NULL\n");
+	cdw_assert (twindow, "ERROR: \"twindow\" argument is NULL\n");
 	cdw_assert (key != 0, "ERROR: asking for key = 0, which is an initialization value\n");
 
 	for (int i = 0; i < twindow->n_return_keys; i++) {
@@ -505,7 +491,7 @@
 			twindow->current_tab = i;
 			show_panel(twindow->tabs[twindow->current_tab].panel);
 			update_panels();
-			cdw_main_ui_main_window_wrefresh();
+			cdw_main_window_wrefresh();
 			cdw_tabs_window_refresh_current_tab(twindow);
 
 			return CDW_OK;
diff -Naur orig/src/user_interface/cdw_text_file_viewer.c patched/src/user_interface/cdw_text_file_viewer.c
--- orig/src/user_interface/cdw_text_file_viewer.c	2012-02-26 15:23:26.000000000 +0100
+++ patched/src/user_interface/cdw_text_file_viewer.c	2014-03-12 21:55:32.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _BSD_SOURCE /* strdup() */
@@ -103,12 +103,12 @@
 	while (n_lines < N_LINES_READ_MAX) {
 		/* fgets() puts '\0' at the end of read buffer */
 		char *c = fgets(read_buffer, READ_BUFFER_SIZE + 1, file);
-		if (c == (char *) NULL) {
+		if (!c) {
 			success = true;
 			break;
 		}
 		char *data = strdup(read_buffer);
-		if (data == (char *) NULL) {
+		if (!data) {
 			success = false;
 			break;
 		}
@@ -151,7 +151,7 @@
 	CDW_LIST_DISPLAY *display = (CDW_LIST_DISPLAY *) displ;
 	char *buffer = (char *) data;
 
-	if (buffer == (char *) NULL) {
+	if (!buffer) {
 		return;
 	}
 
@@ -233,7 +233,7 @@
 	cdw_assert (strlen(fullpath), "file path len is zero\n");
 
 	FILE *file = fopen(fullpath, "r");
-	if (file == (FILE *) NULL) {
+	if (!file) {
 		return CDW_ERROR;
 	}
 
@@ -279,13 +279,13 @@
 	int begin_x = 1;
 
 	WINDOW *window = newwin(n_lines, n_cols, begin_y, begin_x);
-	if (window == (WINDOW *) NULL) {
+	if (!window) {
 		cdw_vdm ("ERROR: failed to create window for text file viewer\n");
 		return CDW_ERROR;
 	}
 
 	CDW_LIST_DISPLAY *display = cdw_list_display_new(window, n_lines - 2, n_cols - 2, 1, 1, CDW_COLORS_DIALOG);
-	if (display == (CDW_LIST_DISPLAY *) NULL) {
+	if (!display) {
 		delwin (window);
 		window = (WINDOW *) NULL;
 
@@ -318,7 +318,7 @@
 	delwin(window);
 	window = (WINDOW *) NULL;
 
-	cdw_main_ui_main_window_wrefresh_part(n_lines, n_cols, begin_y, begin_x);
+	cdw_main_window_wrefresh_part(n_lines, n_cols, begin_y, begin_x);
 	if (n == -1) {
 		cdw_vdm ("ERROR: problems occurred when reading file\n");
 		/* there will be no error message for user here, it should
@@ -351,15 +351,10 @@
 */
 cdw_rv_t cdw_text_file_viewer_dealloc_lines_from_list(cdw_dll_item_t *list)
 {
-	if (list != (cdw_dll_item_t *) NULL) {
-		cdw_dll_item_t *item = list;
-		for ( ; item != (cdw_dll_item_t *) NULL; item = item->next) {
-			free((char *) item->data);
-			item->data = (char *) NULL;
-		}
+	for (cdw_dll_item_t *item = list; item; item = item->next) {
+		free((char *) item->data);
+		item->data = (char *) NULL;
 	}
 
 	return CDW_OK;
 }
-
-
diff -Naur orig/src/user_interface/cdw_verify_wizard.c patched/src/user_interface/cdw_verify_wizard.c
--- orig/src/user_interface/cdw_verify_wizard.c	2012-03-28 21:05:44.000000000 +0200
+++ patched/src/user_interface/cdw_verify_wizard.c	2014-04-06 22:29:00.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include "cdw_widgets.h"
@@ -47,8 +47,6 @@
 
 static CDW_DROPDOWN *cdw_verify_wizard_make_verify_mode_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
 
-static int cdw_verify_wizard_on_enter_on_cancel(cdw_form_t *cdw_form, void *dummy);
-static int cdw_verify_wizard_on_enter_on_verify(cdw_form_t *cdw_form, void *dummy);
 static char *cdw_verify_wizard_make_message(int n_cols);
 
 static struct {
@@ -152,7 +150,7 @@
 	cdw_verify_wizard_destroy();
 
 	/* redraw parent */
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	return wizard.mode;
 }
@@ -221,20 +219,12 @@
 */
 void cdw_verify_wizard_destroy(void)
 {
-	if (wizard.cdw_form->window != (WINDOW *) NULL) {
-		delwin(wizard.cdw_form->window);
-		wizard.cdw_form->window = (WINDOW *) NULL;
-	}
-
-	if (wizard.cdw_form->subwindow != (WINDOW *) NULL) {
-		delwin(wizard.cdw_form->subwindow);
-		wizard.cdw_form->subwindow = (WINDOW *) NULL;
-	}
-
-	if (wizard.cdw_form != (cdw_form_t *) NULL) {
-		cdw_form_delete_form_objects(wizard.cdw_form);
-		cdw_form_delete(&(wizard.cdw_form));
-	}
+	/* This order of these four function calls ensures minimum
+	   problems reported by valgrind. */
+	cdw_form_delete_form_objects(wizard.cdw_form);
+	cdw_window_delete(&wizard.cdw_form->subwindow);
+	cdw_window_delete(&wizard.cdw_form->window);
+	cdw_form_delete(&(wizard.cdw_form));
 
 	return;
 }
@@ -256,7 +246,7 @@
 cdw_rv_t cdw_verify_wizard_build(void)
 {
 	wizard.cdw_form = cdw_form_new(CDW_VERIFY_WIZARD_N_FIELDS);
-	if (wizard.cdw_form == (cdw_form_t *) NULL) {
+	if (!wizard.cdw_form) {
 		cdw_vdm ("ERROR: failed to create cdw form\n");
 		return CDW_ERROR;
 	}
@@ -273,7 +263,7 @@
 						 /* 2TRANS: this is tip at the bottom of window - user can
 						    switch between window elements using tab key */
 						 _("Use 'Tab' key to move"));
-	if (wizard.cdw_form->window == (WINDOW *) NULL) {
+	if (!wizard.cdw_form->window) {
 		cdw_vdm ("ERROR: failed to create window\n");
 		return CDW_ERROR;
 	}
@@ -283,7 +273,7 @@
 						    1, 1,
 						    CDW_COLORS_DIALOG, (char *) NULL, (char *) NULL);
 
-	if (wizard.cdw_form->subwindow == (WINDOW *) NULL) {
+	if (!wizard.cdw_form->subwindow) {
 		cdw_vdm ("ERROR: failed to create subwindow\n");
 		return CDW_ERROR;
 	}
@@ -293,7 +283,7 @@
 	wizard.cdw_form->form = cdw_ncurses_new_form(wizard.cdw_form->window,
 						     wizard.cdw_form->subwindow,
 						     wizard.cdw_form->fields);
-	if (wizard.cdw_form->form == (FORM *) NULL) {
+	if (!wizard.cdw_form->form) {
 		cdw_vdm ("ERROR: failed to create form\n");
 		return CDW_ERROR;
 	}
@@ -303,8 +293,8 @@
 
 	cdw_form_add_return_chars(wizard.cdw_form, CDW_KEY_ENTER, CDW_KEY_ESCAPE, 'q', 'Q', 0);
 
-	cdw_form_set_function(wizard.cdw_form, f_ok_b, cdw_verify_wizard_on_enter_on_verify);
-	cdw_form_set_function(wizard.cdw_form, f_cancel_b, cdw_verify_wizard_on_enter_on_cancel);
+	cdw_form_set_button_return_key(wizard.cdw_form, f_ok_b, CDW_KEY_ENTER);
+	cdw_form_set_button_return_key(wizard.cdw_form, f_cancel_b, CDW_KEY_ESCAPE);
 
 	wrefresh(wizard.cdw_form->subwindow);
 	wrefresh(wizard.cdw_form->window);
@@ -319,20 +309,20 @@
 cdw_rv_t cdw_verify_wizard_build_fields(void)
 {
 	cdw_form_descr_t descr[] = {
-		/*    widget type        begin_y              begin_x        n_cols         n_lines     field enum         data1                       data2 */
+		/*    widget type           begin_y            begin_x         n_cols         n_lines   field enum        data1                      data2 */
 
 		/* 2TRANS: this is label in verify wizard */
-		{ CDW_WIDGET_TEXT,       top_message_row,     first_col,     label_n_cols,        4,  f_top_message_t,  text_makers,                  0 },
+		{ CDW_WIDGET_ID_TEXT,       top_message_row,   first_col,      label_n_cols,        4,  f_top_message_t,  text_makers,                  0 },
 
-		{ CDW_WIDGET_DROPDOWN,   mode_row,            first_col + 1, dropdown_n_cols - 2, 1,  f_mode_dd,        dropdown_makers,              0 },
+		{ CDW_WIDGET_ID_DROPDOWN,   mode_row,          first_col + 1,  dropdown_n_cols - 2, 1,  f_mode_dd,        dropdown_makers,              0 },
 
 		/* 2TRANS: button label, "verify" means "verify data" */
-		{ CDW_WIDGET_BUTTON,     buttons_row,         3,             2,                   1,  f_ok_b,           _("Verify"),  CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,     buttons_row,       3,              2,                   1,  f_ok_b,           _("Verify"),  CDW_COLORS_DIALOG },
 		/* 2TRANS: button label */
-		{ CDW_WIDGET_BUTTON,     buttons_row,         15,            2,                   1,  f_cancel_b,       _("Cancel"),  CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,     buttons_row,      15,              2,                   1,  f_cancel_b,       _("Cancel"),  CDW_COLORS_DIALOG },
 
 		/* guard */
-		{ -1,                    0,                   0,             0,                   0,  0,                (void *) NULL,                0 }};
+		{ -1,                       0,                 0,              0,                   0,  0,                (void *) NULL,                0 }};
 
 
 	wizard.cdw_form->n_fields = CDW_VERIFY_WIZARD_N_FIELDS;
@@ -356,7 +346,7 @@
 	CDW_DROPDOWN *dropdown = cdw_dropdown_new(window, begin_y, begin_x, width,
 						  3, /* n_items_max */
 						  CDW_COLORS_DIALOG);
-	if (dropdown == (CDW_DROPDOWN *) NULL) {
+	if (!dropdown) {
 		cdw_vdm ("ERROR: failed to create new dropdown\n");
 		return (CDW_DROPDOWN *) NULL;
 	}
@@ -402,28 +392,8 @@
 
 
 
-int cdw_verify_wizard_on_enter_on_cancel(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	return CDW_KEY_ESCAPE;
-}
-
-
-
-
-
-int cdw_verify_wizard_on_enter_on_verify(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	return CDW_KEY_ENTER;
-}
-
-
-
-
-
 char *cdw_verify_wizard_make_message(int n_cols)
 {
 	/* 2TRANS: this is message printed in a wizard; */
 	return cdw_string_wrap(_("Select what you want to verify. Verification algorithm (md5sum, sha1sum etc.) can be changed in main window -> Configuration -> Tools -> Digest tool."), (size_t) n_cols, CDW_ALIGN_LEFT);
 }
-
-
diff -Naur orig/src/user_interface/cdw_verify_wizard.h patched/src/user_interface/cdw_verify_wizard.h
--- orig/src/user_interface/cdw_verify_wizard.h	2011-03-05 23:10:22.000000000 +0100
+++ patched/src/user_interface/cdw_verify_wizard.h	2014-03-20 22:55:47.000000000 +0100
@@ -1,5 +1,5 @@
 #ifndef H_CDW_VERIFY_WIZARD
-#define H_CDWE_VERIFY_WIZARD
+#define H_CDW_VERIFY_WIZARD
 
 #include "main.h"
 
diff -Naur orig/src/user_interface/cdw_widgets.c patched/src/user_interface/cdw_widgets.c
--- orig/src/user_interface/cdw_widgets.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/user_interface/cdw_widgets.c	2014-04-06 22:28:34.000000000 +0200
@@ -0,0 +1,75 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+
+#include "cdw_widgets.h"
+#include "cdw_debug.h"
+
+
+/* Indexed with values of enum from header file. */
+static const char *widget_type_labels[] = {
+	"NONE",                      /* Right now the IDs in header file start with 1. */
+	"STATIC_LABEL",
+	"CHECKBOX",
+	"DROPDOWN",
+	"BUTTON",
+	"TEXT",
+	"SAFE_INPUT_LINE",
+	"DYNAMIC_LABEL"
+};
+
+
+const char *cdw_widgets_widget_type_label(cdw_id_t widget_type)
+{
+	return widget_type_labels[widget_type];
+}
+
+
+
+
+
+bool cdw_widget_is_valid_widget_id(cdw_id_t widget_type)
+{
+	/* This assert is used to make sure that declarations in
+	   header file are consistent with contents of *.c file. */
+	cdw_assert (CDW_WIDGET_ID_STATIC_LABEL        == 1
+		    && CDW_WIDGET_ID_CHECKBOX         == 2
+		    && CDW_WIDGET_ID_DROPDOWN         == 3
+		    && CDW_WIDGET_ID_BUTTON           == 4
+		    && CDW_WIDGET_ID_TEXT             == 5
+		    && CDW_WIDGET_ID_SAFE_INPUT_LINE  == 6
+		    && CDW_WIDGET_ID_DYNAMIC_LABEL    == 7,
+
+		    "ERROR: changed order of widget IDs, check code that uses this function as the code may depend on order of the IDs\n");
+
+
+	if (widget_type == CDW_WIDGET_ID_STATIC_LABEL
+	    || widget_type == CDW_WIDGET_ID_CHECKBOX
+	    || widget_type == CDW_WIDGET_ID_DROPDOWN
+	    || widget_type == CDW_WIDGET_ID_BUTTON
+	    || widget_type == CDW_WIDGET_ID_TEXT
+	    || widget_type == CDW_WIDGET_ID_SAFE_INPUT_LINE
+	    || widget_type == CDW_WIDGET_ID_DYNAMIC_LABEL) {
+
+		return true;
+
+	} else {
+		return false;
+	}
+}
diff -Naur orig/src/user_interface/cdw_widgets.h patched/src/user_interface/cdw_widgets.h
--- orig/src/user_interface/cdw_widgets.h	2012-01-08 11:42:04.000000000 +0100
+++ patched/src/user_interface/cdw_widgets.h	2014-03-16 22:22:59.000000000 +0100
@@ -10,18 +10,22 @@
 #include "cdw_button.h"
 #include "cdw_checkbox.h"
 #include "cdw_input_line.h"
+#include "cdw_safe_input_line.h"
 #include "cdw_dialog.h"
-#include "cdw_string.h"
+#include "cdw_dynamic_label.h"
 
 
-/* widget IDs, useful e.g. for selecting constructors
-   when building form with many widgets */
-#define CDW_WIDGET_LABEL     1
-#define CDW_WIDGET_CHECKBOX  2
-#define CDW_WIDGET_INPUT     3
-#define CDW_WIDGET_DROPDOWN  4
-#define CDW_WIDGET_BUTTON    5
-#define CDW_WIDGET_TEXT      6 /* like label, but larger, and with special requirements */
+/* Widget IDs, useful e.g. for selecting constructors
+   when building form with many widgets. */
+enum {
+	CDW_WIDGET_ID_STATIC_LABEL      = 1,
+	CDW_WIDGET_ID_CHECKBOX          = 2,
+	CDW_WIDGET_ID_DROPDOWN          = 3,
+	CDW_WIDGET_ID_BUTTON            = 4,
+	CDW_WIDGET_ID_TEXT              = 5,  /* Like label, but larger, and with special requirements. */
+	CDW_WIDGET_ID_SAFE_INPUT_LINE   = 6,  /* With built-in checking for insecure characters. */
+	CDW_WIDGET_ID_DYNAMIC_LABEL     = 7
+};
 
 
 /* some widgets have table of return keys - keys on which
@@ -31,6 +35,7 @@
 #define N_RETURN_KEYS_MAX 20
 
 
-
+const char *cdw_widgets_widget_type_label(cdw_id_t widget_type);
+bool        cdw_widget_is_valid_widget_id(cdw_id_t widget_type);
 
 #endif /* ifndef H_CDW_WIDGETS */
diff -Naur orig/src/user_interface/cdw_window.c patched/src/user_interface/cdw_window.c
--- orig/src/user_interface/cdw_window.c	2012-02-26 15:35:11.000000000 +0100
+++ patched/src/user_interface/cdw_window.c	2014-04-06 22:27:18.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #define _GNU_SOURCE /* strndup() */
 
@@ -61,12 +61,12 @@
 WINDOW *cdw_window_new(WINDOW *parent, int n_lines, int n_cols, int begin_y, int begin_x, chtype cdw_colors, const char *top_string, const char *bottom_string)
 {
 	WINDOW *window = (WINDOW *) NULL;
-	if (parent == (WINDOW *) NULL) {
+	if (!parent) {
 		window = newwin(n_lines, n_cols, begin_y, begin_x);
 	} else {
 		window = derwin(parent, n_lines, n_cols, begin_y, begin_x);
 	}
-	if (window == (WINDOW *) NULL) {
+	if (!window) {
 		cdw_vdm ("ERROR: failed to create %s window\n",
 			 parent == (WINDOW *) NULL ? "new" : "derived");
 		cdw_vdm ("ERROR: problem occurred when creating \"%s\" / \"%s\" window\n",
@@ -88,9 +88,12 @@
 			 top_string, bottom_string);
 	}
 
-	if (parent != (WINDOW *) NULL) {
+	if (parent) {
 		return window;
+	} else {
+		; /* Top-level / parent window. Add strings. */
 	}
+
 	cdw_rv_t crv = cdw_window_add_strings(window, top_string, bottom_string);
 	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: cdw_ncurses_nice_box() returns !CDW_OK\n");
@@ -126,12 +129,18 @@
 */
 void cdw_window_delete(WINDOW **window)
 {
+	if (!window) {
+		cdw_vdm ("ERROR: function argument is NULL\n");
+		return;
+	}
+
 	if (*window == (WINDOW *) NULL) {
 		cdw_vdm ("WARNING: passing NULL window to the function\n");
 		return;
 	} else {
-		delwin(*window);
+		int rv = delwin(*window);
 		*window = (WINDOW *) NULL;
+		cdw_vdm_n ("delwin", rv, "");
 		return;
 	}
 }
@@ -294,8 +303,8 @@
  */
 int cdw_window_print_message(WINDOW *window, const char *message, int align)
 {
-	cdw_assert (window != (WINDOW *) NULL, "ERROR: cannot print in NULL window\n");
-	cdw_assert (message != (char *) NULL, "ERROR: cannot print NULL message\n");
+	cdw_assert (window, "ERROR: cannot print in NULL window\n");
+	cdw_assert (message, "ERROR: cannot print NULL message\n");
 
 	int n_cols = getmaxx(window);
 	int n_rows = getmaxy(window);
@@ -307,7 +316,7 @@
 	}
 
 	char *string = cdw_string_wrap(message, (size_t) n_cols, align);
-	if (string == (char *) NULL) {
+	if (!string) {
 		cdw_vdm ("ERROR: can't produce wrapped string\n");
 		return -1;
 	}
@@ -324,6 +333,3 @@
 		return 0;
 	}
 }
-
-
-
diff -Naur orig/src/user_interface/cdw_write_wizard.c patched/src/user_interface/cdw_write_wizard.c
--- orig/src/user_interface/cdw_write_wizard.c	2012-03-28 21:07:54.000000000 +0200
+++ patched/src/user_interface/cdw_write_wizard.c	2014-04-06 22:26:40.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,11 +14,11 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 /**
-   \file write_wizard.c
+   \file cdw_write_wizard.c
    \brief Window with basic write options, displayed when user selects writing action
 
    The window displays message "You are writing to X disc", allows user to
@@ -28,17 +28,17 @@
 
    If current task is writing ISO image to blank CD/DVD, then 'Verify' checkbox
    is also available. It is coupled with task->burn.verify (where task
-   is argument passed to write_wizard()).
+   is argument passed to cdw_write_wizard()).
 
    Writing speed values and modes that can be selected in wizard window are
    calculated every time the window is displayed and are disc-specific.
    They are calculated by functions defined in this file using values stored
    in disc argument. Be sure to call run_command_cdrecord_atip(),
    run_command_cdrecord_msinfo() or run_command_dvd_rw_mediainfo() before
-   calling write_wizard().
+   calling cdw_write_wizard().
 
    Code in this file does not check writing preconditions - be sure to check
-   burning preconditions before calling write_wizard().
+   burning preconditions before calling cdw_write_wizard().
 */
 
 #define _GNU_SOURCE /* asprintf() */
@@ -63,8 +63,10 @@
 #include "cdw_cdrecord.h"
 #include "cdw_cdrecord_options.h"
 #include "cdw_mkisofs_options.h"
+#include "cdw_mkisofsrc.h"
 #include "cdw_xorriso.h"
 #include "cdw_xorriso_options.h"
+#include "cdw_xorrisorc.h"
 #include "cdw_utils.h"
 
 extern cdw_config_t global_config; /* main cdw configuration variable */
@@ -87,8 +89,8 @@
 	f_eject_l,
 	f_eject_cb,
 	f_other_options_b,
-	f_write_i,
-	f_cancel_i
+	f_write_b,
+	f_cancel_b
 };
 
 
@@ -99,18 +101,24 @@
 static cdw_rv_t cdw_write_wizard_build_fields(cdw_task_t *task);
 static cdw_rv_t cdw_write_wizard_validate_and_save(cdw_task_t *task, int *fi);
 
-static CDW_DROPDOWN *cdw_write_wizard_make_speed_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
-static CDW_DROPDOWN *cdw_write_wizard_make_session_mode_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
-static CDW_DROPDOWN *cdw_write_wizard_make_disc_mode_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
 
-static cdw_rv_t cdw_write_wizard_options(cdw_task_t *task);
-static cdw_rv_t cdw_write_wizard_options_validate_and_save(cdw_task_t *task, cdw_id_t *page_id, int *fi);
+static int      cdw_write_wizard_options_window_show(cdw_id_t *pid, int *fi);
+static cdw_rv_t cdw_write_wizard_options_window_sub(cdw_task_t *task, cdw_id_t *pid, int *fi);
+static int      cdw_write_wizard_options_window_by_callback(cdw_form_t *cdw_form, void *dummy);
+static int      cdw_write_wizard_options_window_by_flow(cdw_id_t *pid, int *fi);
 static int      cdw_write_wizard_options_window_driver(cdw_task_t *task);
 static void     cdw_write_wizard_options_window_destroy(void);
 
-static int cdw_write_wizard_on_enter_on_cancel(cdw_form_t *cdw_form, void *dummy);
-static int cdw_write_wizard_on_enter_on_write(cdw_form_t *cdw_form, void *dummy);
-static int cdw_write_wizard_on_enter_on_config(cdw_form_t *cdw_form, void *dummy);
+
+static cdw_rv_t cdw_write_wizard_options_save(cdw_task_t *task);
+static cdw_rv_t cdw_write_wizard_options_validate(cdw_task_t *task, cdw_id_t *page_id, int *fi);
+static cdw_rv_t cdw_write_wizard_options_validate_closed(cdw_task_t *task);
+
+
+static CDW_DROPDOWN *cdw_write_wizard_make_speed_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_write_wizard_make_session_mode_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+static CDW_DROPDOWN *cdw_write_wizard_make_disc_mode_dropdown(WINDOW *window, int begin_y, int begin_x, int width);
+
 
 static void cdw_write_wizard_debug_at_exit(cdw_task_t *task);
 static void cdw_write_wizard_debug_verify_invisible(cdw_task_t *task, cdw_disc_t *disc);
@@ -119,8 +127,9 @@
 static bool cdw_write_wizard_show_dummy_checkbox(cdw_task_t *task, cdw_disc_t *disc);
 
 
+/* Does not include guard. */
 #define CDW_WRITE_WIZARD_N_FIELDS 18
-static FIELD *wizard_fields[CDW_WRITE_WIZARD_N_FIELDS + 1];
+
 
 static struct {
 	/* used in code related to 'Verify' checkbox, we can do verification
@@ -141,6 +150,16 @@
 	char *header; /* main message in wizard window */
 
 	cdw_form_t *cdw_form;
+
+	cdw_task_t *task;
+
+	cdw_disc_t *disc;
+
+	FIELD *fields[CDW_WRITE_WIZARD_N_FIELDS + 1];
+
+	/* Text displayed at the bottom of wizard window. */
+	char *window_tip;
+
 } wizard;
 
 
@@ -151,25 +170,12 @@
 	cdw_write_wizard_make_disc_mode_dropdown
 };
 
-static cdw_task_t *local_task = (cdw_task_t *) NULL;
-static cdw_disc_t *local_disc = (cdw_disc_t *) NULL;
 
 
 /* *** some layout constraints *** */
 
 #define first_col                  2  /* main message and some labels start in leftmost column */
 
-#define top_label_row              1  /* main message is displayed on top of window */
-#define volume_id_label_row        2
-#define write_speed_label_row      4
-#define session_mode_label_row     6
-#define disc_mode_label_row        8
-#define verify_checkbox_label_row 11
-#define dummy_checkbox_label_row  12
-#define eject_checkbox_label_row  13
-#define other_options_button_row  14  /* button invoking "other options" window */
-#define buttons_row               16  /* Write, Cancel and Help buttons are at the bottom of window */
-
 #define window_n_cols             52
 #define window_n_lines            20
 #define subwindow_n_cols           (window_n_cols - 2)
@@ -202,8 +208,8 @@
 		    "ERROR: incorrect task id %lld\n", task->id);
 	cdw_assert (disc->type_writable == CDW_TRUE, "ERROR: disc type is not writable\n");
 
-	local_task = task;
-	local_disc = disc;
+	wizard.task = task;
+	wizard.disc = disc;
 	wizard.header = (char *) NULL;
 
 	if (disc->type_writable != CDW_TRUE) {
@@ -230,7 +236,7 @@
 
 	cdw_write_wizard_destroy();
 	/* redraw parent */
-	cdw_main_ui_main_window_wrefresh();
+	cdw_main_window_wrefresh();
 
 	if (key == CDW_KEY_ENTER) {
 #ifndef NDEBUG
@@ -264,11 +270,18 @@
 	wizard.volume_id_visible = task->id == CDW_TASK_BURN_FROM_FILES ? true : false;
 
 	wizard.cdw_form = cdw_form_new(CDW_WRITE_WIZARD_N_FIELDS);
-	if (wizard.cdw_form == (cdw_form_t *) NULL) {
+	if (!wizard.cdw_form) {
 		cdw_vdm ("ERROR: failed to create cdw form\n");
 		return CDW_ERROR;
 	}
 
+	wizard.cdw_form->fields = wizard.fields;
+	for (int i = 0; i < CDW_WRITE_WIZARD_N_FIELDS; i++ ) {
+		wizard.cdw_form->fields[i] = (FIELD *) NULL;
+	}
+
+	wizard.window_tip = (char *) NULL;
+
 	return CDW_OK;
 }
 
@@ -278,33 +291,60 @@
 
 int cdw_write_wizard_driver(void)
 {
-	int fi = 0;
+	int fi = f_cancel_b; /* Initial focus on "Cancel" button. */
 	int key = 'a';
+
 	while (key != CDW_KEY_ESCAPE && key != 'q' && key != 'Q') {
 		key = cdw_form_driver(wizard.cdw_form, fi);
 
-		/* in this wizard driver we are interested only in
-		   ENTER being pressed on either "write" or "cancel"
-		   buttons */
+		/* In top-level driver of wizard we are mainly
+		   interested in ENTER being pressed on either "write"
+		   or "cancel" button. */
 		if (key == CDW_KEY_ENTER) {
 			fi = field_index(current_field(wizard.cdw_form->form));
-			if (fi == f_write_i) {
+			/* The form and driver are designed so that
+			   Enter is returned only upon pressing
+			   "Write" button. */
+			cdw_assert (fi == f_write_b, "ERROR: driver returns KEY_ENTER for widget other than write (%d)\n", fi);
+
+			/* Flush. */
+			form_driver(wizard.cdw_form->form, REQ_VALIDATION);
+
+			/* Check options in closed "Options" window. */
+			cdw_rv_t crv = cdw_write_wizard_options_validate_closed(wizard.task);
+			if (crv != CDW_OK) {
+				return CDW_KEY_ESCAPE;
+			}
 
-				/* flush */
-				form_driver(wizard.cdw_form->form, REQ_VALIDATION);
+			/* Check options in main wizard window. */
+			crv = cdw_write_wizard_validate_and_save(wizard.task, &fi);
+			if (crv == CDW_NO) {
+				/* one of option strings in main
+				   wizard window is invalid */
 
-				cdw_write_wizard_validate_and_save(local_task, &fi);
-				/* not checking return value after validation
-				   as none of options available directly in
-				   wizard options are validated */
-				return CDW_KEY_ENTER;
-			} else if (fi == f_cancel_i) {
-				return CDW_KEY_ESCAPE;
+				/* 2TRANS: this is title of dialog window */
+				cdw_buttons_dialog(_("Error"),
+						   /* 2TRANS: this is message in dialog window */
+						   _("One of option fields is incorrect or contains character that is not allowed. Please fix it."),
+						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+
+				cdw_form_driver_go_to_field(wizard.cdw_form, fi);
+				/* Loop. */
 			} else {
-				;
+				/* Fields from Options window and from
+				   main page of the wizard are
+				   validated and saved into task
+				   variable. */
+				return CDW_KEY_ENTER;
 			}
+		} else if (key == CDW_KEY_ESCAPE) {
+			/* Either "Cancel" button pressed (which is
+			   configured to return Escape), or "Escape"
+			   key anywhere else. The result is the
+			   same. */
+			return CDW_KEY_ESCAPE;
 		} else {
-			;
+			/* Some unspecified key. */
 		}
 	}
 
@@ -355,7 +395,7 @@
 		/* session_modes is non-sparse up until
 		   element of value CDW_SESSION_MODE_INIT */
 
-		int allowed_mode_id = local_task->burn.session_modes[n_items];
+		cdw_id_t allowed_mode_id = wizard.task->burn.session_modes[n_items];
 		if (allowed_mode_id == CDW_SESSION_MODE_INIT) {
 			break;
 		} else {
@@ -430,7 +470,7 @@
 		/* disc_modes is non-sparse up until
 		   element of value CDW_DISC_MODE_INIT */
 
-		cdw_id_t allowed_mode_id = local_task->burn.disc_modes[n_items];
+		cdw_id_t allowed_mode_id = wizard.task->burn.disc_modes[n_items];
 		if (allowed_mode_id == CDW_DISC_MODE_INIT) {
 			break;
 		} else {
@@ -473,20 +513,20 @@
 						  begin_y,
 						  begin_x,
 						  width,
-						  local_disc->write_speeds.n_speeds,  /* n_items_max */
+						  wizard.disc->write_speeds.n_speeds,  /* n_items_max */
 						  CDW_COLORS_DIALOG);
 
-	if (dropdown == (CDW_DROPDOWN *) NULL) {
+	if (!dropdown) {
 		cdw_vdm ("ERROR: failed to create new dropdown\n");
 		return (CDW_DROPDOWN *) NULL;
 	}
 
-	for (int i = 0; i < local_disc->write_speeds.n_speeds; i++) {
+	for (int i = 0; i < wizard.disc->write_speeds.n_speeds; i++) {
 		char label[4 + 1];
-		snprintf(label, 4 + 1, "%d", local_disc->write_speeds.speeds[i]);
-		cdw_rv_t crv = cdw_dropdown_add_item(dropdown, local_disc->write_speeds.speeds[i], label);
+		snprintf(label, 4 + 1, "%d", wizard.disc->write_speeds.speeds[i]);
+		cdw_rv_t crv = cdw_dropdown_add_item(dropdown, wizard.disc->write_speeds.speeds[i], label);
 		if (crv != CDW_OK) {
-			cdw_vdm ("ERROR: failed to create dropdown label #%d of value %d\n", i, local_disc->write_speeds.speeds[i]);
+			cdw_vdm ("ERROR: failed to create dropdown label #%d of value %d\n", i, wizard.disc->write_speeds.speeds[i]);
 			cdw_dropdown_delete(&dropdown);
 			return (CDW_DROPDOWN *) NULL;
 		}
@@ -498,7 +538,7 @@
 		cdw_dropdown_delete(&dropdown);
 		return (CDW_DROPDOWN *) NULL;
 	} else {
-		cdw_dropdown_set_current_item_by_id(dropdown, local_task->burn.speed_id);
+		cdw_dropdown_set_current_item_by_id(dropdown, wizard.task->burn.speed_id);
 		return dropdown;
 	}
 }
@@ -512,25 +552,14 @@
 */
 void cdw_write_wizard_destroy(void)
 {
-	if (wizard.cdw_form->subwindow != (WINDOW *) NULL) {
-		delwin(wizard.cdw_form->subwindow);
-		wizard.cdw_form->subwindow = (WINDOW *) NULL;
-	}
-
-	if (wizard.cdw_form->window != (WINDOW *) NULL) {
-		delwin(wizard.cdw_form->window);
-		wizard.cdw_form->window = (WINDOW *) NULL;
-	}
+	/* This order of these four function calls minimizes number of
+	   problems reported by valgrind. */
+	cdw_form_delete_form_objects(wizard.cdw_form);
+	cdw_window_delete(&wizard.cdw_form->subwindow);
+	cdw_window_delete(&wizard.cdw_form->window);
+	cdw_form_delete(&wizard.cdw_form);
 
-	if (wizard.cdw_form != (cdw_form_t *) NULL) {
-		cdw_form_delete_form_objects(wizard.cdw_form);
-		cdw_form_delete(&(wizard.cdw_form));
-	}
-
-	if (wizard.header != (char *) NULL) {
-		free(wizard.header);
-		wizard.header = (char *) NULL;
-	}
+	cdw_string_delete(&wizard.header);
 
 	return;
 }
@@ -552,8 +581,8 @@
 	cdw_vdm ("INFO: disc mode dropdown is %svisible\n", wizard.disc_mode_dd_visible ? "" : "not ");
 	cdw_vdm ("INFO: volume id field is %svisible\n", wizard.volume_id_visible ? "" : "not ");
 
-	cdw_task_debug_print_burn_options(task);
-	cdw_task_debug_print_iso9660_options(task);
+	cdw_write_debug_print_options(&task->burn);
+	cdw_task_debug_print_options(task, "at write wizard exit");
 
 	return;
 }
@@ -663,7 +692,7 @@
 						 /* 2TRANS: this is tip at the bottom of window - user can
 						    switch between window elements using tab key */
 						 _("Use 'Tab' key to move"));
-	if (wizard.cdw_form->window == (WINDOW *) NULL) {
+	if (!wizard.cdw_form->window) {
 		cdw_vdm ("ERROR: failed to create window\n");
 		return CDW_ERROR;
 	}
@@ -673,7 +702,7 @@
 						    1, 1,
 						    CDW_COLORS_DIALOG, (char *) NULL, (char *) NULL);
 
-	if (wizard.cdw_form->subwindow == (WINDOW *) NULL) {
+	if (!wizard.cdw_form->subwindow) {
 		cdw_vdm ("ERROR: failed to create subwindow\n");
 		return CDW_ERROR;
 	}
@@ -686,16 +715,20 @@
 		return CDW_ERROR;
 	}
 
-	cdw_write_wizard_build_fields(task);
+	cdw_rv_t crv = cdw_write_wizard_build_fields(task);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to build fields\n");
+		return CDW_ERROR;
+	}
 
 	wizard.cdw_form->form = cdw_ncurses_new_form(wizard.cdw_form->window,
 						     wizard.cdw_form->subwindow,
 						     wizard.cdw_form->fields);
-	if (wizard.cdw_form->form == (FORM *) NULL) {
+	if (!wizard.cdw_form->form) {
 		cdw_vdm ("ERROR: failed to create form\n");
 		return CDW_ERROR;
 	}
-	set_current_field(wizard.cdw_form->form, wizard.cdw_form->fields[f_cancel_i]);
+	set_current_field(wizard.cdw_form->form, wizard.cdw_form->fields[f_cancel_b]);
 
 	if (!wizard.volume_id_visible) {
 		field_opts_off(wizard.cdw_form->fields[f_volume_id_l], O_VISIBLE);
@@ -742,10 +775,6 @@
 
 	cdw_form_add_return_chars(wizard.cdw_form, CDW_KEY_ENTER, CDW_KEY_ESCAPE, 'q', 'Q', 0);
 
-	cdw_form_set_function(wizard.cdw_form, f_write_i, cdw_write_wizard_on_enter_on_write);
-	cdw_form_set_function(wizard.cdw_form, f_cancel_i, cdw_write_wizard_on_enter_on_cancel);
-	cdw_form_set_function(wizard.cdw_form, f_other_options_b, cdw_write_wizard_on_enter_on_config);
-
 	wrefresh(wizard.cdw_form->subwindow);
 	wrefresh(wizard.cdw_form->window);
 
@@ -763,101 +792,73 @@
 	int other_options_n_cols = (int) strlen(other_options) + 2;
 
 	cdw_form_descr_t descr[] = {
-		/*     type             begin_y                        begin_x         n_cols                n_lines    field enum      data1                  data2 */
+		/*     type                   begin_y   begin_x         n_cols                n_lines    field enum      data1                                 data2 */
 
-		{ CDW_WIDGET_LABEL,      top_label_row,               first_col,      wide_label_n_cols,          1,    f_header_l,     wizard.header,                      0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,       1,  first_col,      wide_label_n_cols,          1,   f_header_l,     wizard.header,                            0 },
 
 		/* 2TRANS: this is label next to input field, where user can enter a label describing created ISO9660 volume */
-		{ CDW_WIDGET_LABEL,      volume_id_label_row,         first_col,      wide_label_n_cols,          1,    f_volume_id_l,  _("Volume ID:"),                    0 },
-		{ CDW_WIDGET_INPUT,      volume_id_label_row + 1,     first_col + 3,  CDW_ISO9660_VOLI_LEN,       1,    f_volume_id_i,  task->create_image.volume_id,  CDW_ISO9660_VOLI_LEN },
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,      2,  first_col,      wide_label_n_cols,          1,   f_volume_id_l,  _("Volume ID:"),                          0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,    3,  first_col + 3,  CDW_ISO9660_VOLI_LEN,       1,   f_volume_id_i,  task->create_image.iso9660.volume_id,  CDW_ISO9660_VOLI_LEN },
 
 		/* 2TRANS: this is a label in write wizard, after which a writing speed selection list will be displayed */
-		{ CDW_WIDGET_LABEL,      write_speed_label_row,       first_col,      wide_label_n_cols,          1,    f_speed_l,      _("Writing speed:"),                0 },
-		{ CDW_WIDGET_DROPDOWN,   write_speed_label_row + 1,   first_col + 3,  narrow_dropdown_n_cols - 2, 1,    f_speed_dd,     dropdown_makers,                    0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,       4,  first_col,      wide_label_n_cols,          1,   f_speed_l,      _("Writing speed:"),                      0 },
+		{ CDW_WIDGET_ID_DROPDOWN,           5,  first_col + 3,  narrow_dropdown_n_cols - 2, 1,   f_speed_dd,     dropdown_makers,                          0 },
 
 		/* 2TRANS: this is a label in write wizard, after which a session writing mode selection list will be displayed */
-		{ CDW_WIDGET_LABEL,      session_mode_label_row,      first_col,      wide_label_n_cols,          1,    f_session_l,    _("Session writing mode:"),         0 },
-		{ CDW_WIDGET_DROPDOWN,   session_mode_label_row + 1,  first_col + 3,  wide_dropdown_n_cols - 2,   1,    f_session_dd,   dropdown_makers,                    1 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,       6,  first_col,      wide_label_n_cols,          1,   f_session_l,    _("Session writing mode:"),               0 },
+		{ CDW_WIDGET_ID_DROPDOWN,           7,  first_col + 3,  wide_dropdown_n_cols - 2,   1,   f_session_dd,   dropdown_makers,                          1 },
 
 		/* 2TRANS: this is a label in write wizard, after which a disc writing mode selection list will be displayed */
-		{ CDW_WIDGET_LABEL,      disc_mode_label_row,         first_col,      wide_label_n_cols,          1,    f_disc_l,       _("Disc writing mode:"),            0 },
-		{ CDW_WIDGET_DROPDOWN,   disc_mode_label_row + 1,     first_col + 3,  wide_dropdown_n_cols - 2,   1,    f_disc_dd,      dropdown_makers,                    2 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,       8,  first_col,      wide_label_n_cols,          1,   f_disc_l,       _("Disc writing mode:"),                  0 },
+		{ CDW_WIDGET_ID_DROPDOWN,           9,  first_col + 3,  wide_dropdown_n_cols - 2,   1,   f_disc_dd,      dropdown_makers,                          2 },
 
 		/* 2TRANS: this is label next to checkbox; marked checkbox enables verification of correctness of writing to CD; this feature is experimental */
-		{ CDW_WIDGET_LABEL,      verify_checkbox_label_row,   first_col + 4,  narrow_label_n_cols,        1,    f_verify_l,     _("Verify write (experimental)"),   0 },
-		{ CDW_WIDGET_CHECKBOX,   verify_checkbox_label_row,   first_col + 1,  1,                          1,    f_verify_i,     (void *) NULL,    task->burn.verify ? 1 : 0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      11,  first_col + 4,  narrow_label_n_cols,        1,   f_verify_l,     _("Verify write (experimental)"),         0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          11,  first_col + 1,  1,                          1,   f_verify_i,     (void *) NULL,    task->burn.verify ? 1 : 0 },
 
 		/* 2TRANS: this is checkbox label: keep no longer than original; "Dummy write" means attempting to write
 		   to a disc and performing all normal operations (just for a try), but without actual burning */
-		{ CDW_WIDGET_LABEL,      dummy_checkbox_label_row,    first_col + 4,  narrow_label_n_cols,        1,    f_dummy_l,    _("Dummy write"),                         0 },
-		{ CDW_WIDGET_CHECKBOX,   dummy_checkbox_label_row,    first_col + 1,  1,                          1,    f_dummy_i,    (void *) NULL,     task->burn.dummy ? 1 : 0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      12,  first_col + 4,  narrow_label_n_cols,        1,   f_dummy_l,      _("Dummy write"),                         0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          12,  first_col + 1,  1,                          1,   f_dummy_i,      (void *) NULL,     task->burn.dummy ? 1 : 0 },
 
 		/* 2TRANS: this is a checkbox label; "tray" is a tray of optical drive; "writing" is burning to optical disc */
-		{ CDW_WIDGET_LABEL,      eject_checkbox_label_row,    first_col + 4,  narrow_label_n_cols,        1,    f_eject_l,    _("Eject tray after writing"),            0 },
-		{ CDW_WIDGET_CHECKBOX,   eject_checkbox_label_row,    first_col + 1,  1,                          1,    f_eject_cb,   (void *) NULL,     task->burn.eject ? 1 : 0 },
+		{ CDW_WIDGET_ID_STATIC_LABEL,      13,  first_col + 4,  narrow_label_n_cols,        1,   f_eject_l,      _("Eject tray after writing"),            0 },
+		{ CDW_WIDGET_ID_CHECKBOX,          13,  first_col + 1,  1,                          1,   f_eject_cb,     (void *) NULL,     task->burn.eject ? 1 : 0 },
 
 		/* 2TRANS: button label */
-		{ CDW_WIDGET_BUTTON,     other_options_button_row,    first_col,      other_options_n_cols,       1,    f_other_options_b,   other_options,  CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,            14,  first_col,      other_options_n_cols,       1,   f_other_options_b,   other_options,       CDW_COLORS_DIALOG },
 
 		/* 2TRANS: button label, it refers to writing to optical disc */
-		{ CDW_WIDGET_BUTTON,     buttons_row,                 3,              2,                          1,    f_write_i,    _("Write"),          CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,            16,   3,             2,                          1,   f_write_b,      _("Write"),               CDW_COLORS_DIALOG },
 		/* 2TRANS: button label */
-		{ CDW_WIDGET_BUTTON,     buttons_row,                 15,             2,                          1,    f_cancel_i,   _("Cancel"),         CDW_COLORS_DIALOG },
+		{ CDW_WIDGET_ID_BUTTON,            16,  15,             2,                          1,   f_cancel_b,     _("Cancel"),              CDW_COLORS_DIALOG },
 
 		/* guard */
-		{ -1,                    0,                           0,              0,                          0,    0,            (void *) NULL,                       0 }};
+		{ -1,                               0,   0,             0,                          0,   0,              (void *) NULL,                            0 }};
 
 	wizard.cdw_form->n_fields = CDW_WRITE_WIZARD_N_FIELDS;
-	wizard.cdw_form->fields = wizard_fields;
+	wizard.cdw_form->fields = wizard.fields;
 
 	/* the function adds guard at the end of fields */
 	cdw_rv_t crv = cdw_form_description_to_fields(descr, wizard.cdw_form);
-	if (crv == CDW_OK) {
-		return CDW_OK;
-	} else {
+	if (crv != CDW_OK) {
 		cdw_vdm ("ERROR: failed to convert form description to form\n");
 		return CDW_ERROR;
-	}
-}
-
-
-
-
-
-int cdw_write_wizard_on_enter_on_cancel(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	return CDW_KEY_ESCAPE;
-}
-
-
-
+	} else {
+		cdw_form_set_widget_callback(wizard.cdw_form, f_other_options_b, cdw_write_wizard_options_window_by_callback);
 
+		cdw_form_set_button_return_key(wizard.cdw_form, f_write_b, CDW_KEY_ENTER);
+		cdw_form_set_button_return_key(wizard.cdw_form, f_cancel_b, CDW_KEY_ESCAPE);
 
-int cdw_write_wizard_on_enter_on_write(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	return CDW_KEY_ENTER;
+		cdw_form_bind_input_and_label(wizard.cdw_form, f_volume_id_i, f_volume_id_l);
+		return CDW_OK;
+	}
 }
 
 
 
 
 
-int cdw_write_wizard_on_enter_on_config(cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
-{
-	cdw_write_wizard_options(local_task);
-
-	cdw_main_ui_main_window_wrefresh();
-	redrawwin(cdw_form->window);
-	redrawwin(cdw_form->subwindow);
-	wrefresh(cdw_form->window);
-	wrefresh(cdw_form->subwindow);
-
-	return 'a';
-}
-
-
-
-
 /* some size and layout constants */
 /* width and height of main options window can't be smaller
    than size of minimal supported terminal */
@@ -880,31 +881,39 @@
 #define SECOND_COL (FIRST_COL + LABEL_WIDTH + 2)
 
 
-/* text displayed at the bottom of wizard window */
-static char *cdw_wizard_window_tip = (char *) NULL;
-
 
-#define WRITE_CDRECORD        0
-#define WRITE_GROWISOFS       1
-#define WRITE_XORRISO_BURN    2
-#define WRITE_MKISOFS         3
-#define WRITE_XORRISO_ISO     4
+enum {
+	WRITE_CDRECORD = 0,
+	WRITE_GROWISOFS,
+	WRITE_XORRISO_BURN,
+	WRITE_MKISOFS_ISO_MAIN,
+	WRITE_XORRISO_ISO_MAIN,
+	WRITE_MKISOFS_ISO_META,
+	WRITE_XORRISO_ISO_META
+};
 
 
 /* this is first main component of options window: a big table
    aggregating data and functions that prepare the data; the data
    represents widgets displayed in pages of options window */
-static cdw_config_page_t c_pages[] = {
+static cdw_options_page_t c_pages[] = {
 	/* 2TRANS: label of a tab in configuration window with options related burning */
-	{ false, CDW_CDRECORD_OPTIONS_N_FIELDS,      cdw_cdrecord_options_form,        gettext_noop("Write"),   (cdw_form_t *) NULL },
+	{ false, CDW_CDRECORD_OPTIONS_N_FIELDS,          cdw_cdrecord_options_form,        gettext_noop("Write"),   (cdw_form_t *) NULL },
 	/* 2TRANS: label of a tab in configuration window with options related burning */
-	{ false, CDW_GROWISOFS_OPTIONS_N_FIELDS,     cdw_growisofs_options_form,       gettext_noop("Write"),   (cdw_form_t *) NULL },
+	{ false, CDW_GROWISOFS_OPTIONS_N_FIELDS,         cdw_growisofs_options_form,       gettext_noop("Write"),   (cdw_form_t *) NULL },
 	/* 2TRANS: label of a tab in configuration window with options related burning */
-	{ false, CDW_XORRISO_BURN_OPTIONS_N_FIELDS,  cdw_xorriso_burn_options_form,    gettext_noop("Write"),   (cdw_form_t *) NULL },
+	{ false, CDW_XORRISO_BURN_OPTIONS_N_FIELDS,      cdw_xorriso_burn_options_form,    gettext_noop("Write"),   (cdw_form_t *) NULL },
+
 	/* 2TRANS: label of a tab in configuration window with options related to ISO9660; probably you don't want to translate this */
-	{ false, CDW_MKISOFS_OPTIONS_N_FIELDS,       cdw_mkisofs_options_form,         gettext_noop("ISO9660"), (cdw_form_t *) NULL },
+	{ false, CDW_MKISOFS_ISO_MAIN_OPTIONS_N_FIELDS,  cdw_mkisofs_options_form,         gettext_noop("ISO9660"), (cdw_form_t *) NULL },
 	/* 2TRANS: label of a tab in configuration window with options related to ISO9660; probably you don't want to translate this */
-	{ false, CDW_XORRISO_ISO_OPTIONS_N_FIELDS,   cdw_xorriso_iso_options_form,     gettext_noop("ISO9660"), (cdw_form_t *) NULL }};
+	{ false, CDW_XORRISO_ISO_MAIN_OPTIONS_N_FIELDS,  cdw_xorriso_iso_options_form,     gettext_noop("ISO9660"), (cdw_form_t *) NULL },
+
+	/* 2TRANS: label of a tab in configuration window with options related to meta information of ISO9660 file system */
+	{ false, CDW_MKISOFS_ISO_META_OPTIONS_N_FIELDS,  cdw_mkisofsrc_options_form,       gettext_noop("Meta data"), (cdw_form_t *) NULL },
+	/* 2TRANS: label of a tab in configuration window with options related to meta information of ISO9660 file system */
+	{ false, CDW_XORRISO_ISO_META_OPTIONS_N_FIELDS,  cdw_xorrisorc_options_form,       gettext_noop("Meta data"), (cdw_form_t *) NULL },
+};
 
 
 /* this is a pointer to second main component of options window:
@@ -914,26 +923,68 @@
 
 
 
-cdw_rv_t cdw_write_wizard_options(cdw_task_t *task)
+
+int cdw_write_wizard_options_window_by_callback(__attribute__((unused)) cdw_form_t *cdw_form, __attribute__((unused)) void *dummy)
+{
+	return cdw_write_wizard_options_window_show((cdw_id_t *) NULL, (int *) NULL);
+}
+
+
+
+
+
+int cdw_write_wizard_options_window_by_flow(cdw_id_t *pid, int *fi)
+{
+	return cdw_write_wizard_options_window_show(pid, fi);
+}
+
+
+
+
+
+
+int cdw_write_wizard_options_window_show(cdw_id_t *pid, int *fi)
+{
+	cdw_rv_t crv = cdw_write_wizard_options_window_sub(wizard.task, pid, fi);
+
+	cdw_main_window_wrefresh();
+	redrawwin(wizard.cdw_form->window);
+	redrawwin(wizard.cdw_form->subwindow);
+	wrefresh(wizard.cdw_form->window);
+	wrefresh(wizard.cdw_form->subwindow);
+
+	/* the function needs to return int representing a char */
+	if (crv == CDW_OK) {
+		return '1';
+	} else {
+		return '0';
+	}
+}
+
+
+
+
+
+cdw_rv_t cdw_write_wizard_options_window_sub(cdw_task_t *task, cdw_id_t *pid, int *fi)
 {
 	/* 2TRANS: this is message at the bottom of options window;
 	   cancel means: quit without saving; '%d' is an integer used to
 	   create label of function key, e.g. "F10" */
-	int rv = asprintf(&cdw_wizard_window_tip,
+	int rv = asprintf(&wizard.window_tip,
 			  _("Press F%d / F%d key to save changes or ESC to cancel"),
 			  CDW_CONFIG_UI_SnC_KEY_B, CDW_CONFIG_UI_SnC_KEY_A);
-	if (cdw_wizard_window_tip == (char *) NULL || rv == -1) {
+	if (!wizard.window_tip || rv == -1) {
 		cdw_vdm ("ERROR: failed to create window tip\n");
 		return CDW_ERROR;
 	}
 	int n_tabs = 0;
 	if (task->id == CDW_TASK_BURN_FROM_FILES) {
-		n_tabs = 2; /* (cdrecord|growisofs|xorriso) + (mkisofs|xorriso) */
+		n_tabs = 3; /* (cdrecord|growisofs|xorriso) + (basic ISO9660 by mkisofs|xorriso) + (ISO9660 metadata)  */
 	} else { /* CDW_TASK_BURN_FROM_IMAGE */
 		n_tabs = 1; /* (cdrecord|growisofs|xorriso) */
 	}
 	/* 2TRANS: this is title of cdw options main window */
-	c_twindow = cdw_tabs_window_init(n_tabs, _("Write options"), cdw_wizard_window_tip);
+	c_twindow = cdw_tabs_window_init(n_tabs, _("Write options"), wizard.window_tip);
 	cdw_tabs_window_set_geometry(c_twindow, OPTIONS_HEIGHT, OPTIONS_WIDTH, 4, 4, TABS_WIDTH);
 
 
@@ -942,7 +993,10 @@
 	cdw_id_t id = 0;
 	int ind = 0;
 
-	/* tool-specific options: cdrecord or growisofs */
+	/* Tool-specific (cdrecord/growisofs/xorriso) options for
+	   burning. These should be always present, whether we are
+	   writing files on-the-fly, or burning existing image to
+	   disc. */
 	if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
 		id = WRITE_CDRECORD;
 		cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
@@ -953,18 +1007,36 @@
 		id = WRITE_GROWISOFS;
 		cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
 	}
-	/* options of tool creating ISO9660 file system;
-	   the tool may be mkisofs or xorriso */
+
+	/* Options of tool creating ISO9660 file system on the fly.
+	   The tool may be either mkisofs or xorriso, and there are
+	   two pages for each of these tools (basic options + metadata
+	   options). */
 	if (task->id == CDW_TASK_BURN_FROM_FILES) {
 		if (task->burn.tool.id == CDW_TOOL_CDRECORD || task->burn.tool.id == CDW_TOOL_GROWISOFS) {
 			cdw_assert (task->create_image.tool.id == CDW_TOOL_MKISOFS, "ERROR: invalid ISO tool: %lld\n", task->create_image.tool.id);
+
+			/* Basic mkisofs options for ISO9660 fs. */
+			ind++;
+			id = WRITE_MKISOFS_ISO_MAIN;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+
+			/* mkisofs options for ISO9660 fs metadata. */
 			ind++;
-			id = WRITE_MKISOFS;
+			id = WRITE_MKISOFS_ISO_META;
 			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+
 		} else if (task->burn.tool.id == CDW_TOOL_XORRISO) {
 			cdw_assert (task->create_image.tool.id == CDW_TOOL_XORRISO, "ERROR: invalid ISO tool: %lld\n", task->create_image.tool.id);
+
+			/* Basic xorriso options for ISO9660 fs. */
 			ind++;
-			id = WRITE_XORRISO_ISO;
+			id = WRITE_XORRISO_ISO_MAIN;
+			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
+
+			/* xorriso options for ISO9660 fs metadata. */
+			ind++;
+			id = WRITE_XORRISO_ISO_META;
 			cdw_tabs_window_append_tab(c_twindow, id, KEY_F(ind + 2), c_pages[id].label);
 		} else {
 			cdw_assert (0, "ERROR: invalid burn tool: %lld\n", task->burn.tool.id);
@@ -988,7 +1060,17 @@
 
 		c_pages[id].visible = true;
 
-		cdw_rv_t crv = c_pages[id].fields_builder(c_pages[id].cdw_form, task, FIRST_COL, SECOND_COL, WIDE_FIELD_WIDTH, LABEL_WIDTH);
+		cdw_rv_t crv;
+		if (id == WRITE_MKISOFS_ISO_MAIN
+		    || id == WRITE_MKISOFS_ISO_META
+		    || id == WRITE_XORRISO_ISO_MAIN
+		    || id == WRITE_XORRISO_ISO_META) {
+
+			crv = c_pages[id].fields_builder(c_pages[id].cdw_form, &(task->create_image.iso9660), FIRST_COL, SECOND_COL, WIDE_FIELD_WIDTH, LABEL_WIDTH);
+		} else {
+			crv = c_pages[id].fields_builder(c_pages[id].cdw_form, task, FIRST_COL, SECOND_COL, WIDE_FIELD_WIDTH, LABEL_WIDTH);
+		}
+
 		if (crv != CDW_OK) {
 			cdw_vdm ("ERROR: failed to build fields in page #%d\n", i);
 			return CDW_ERROR;
@@ -1003,17 +1085,27 @@
 		}
 		cdw_form_add_return_char(c_pages[id].cdw_form, KEY_F(CDW_CONFIG_UI_SnC_KEY_A));
 		cdw_form_add_return_char(c_pages[id].cdw_form, KEY_F(CDW_CONFIG_UI_SnC_KEY_B));
+		cdw_form_add_return_char(c_pages[id].cdw_form, 'q'); /* will work only for non-text fields */
 	}
 	c_twindow->user_data = (void *) c_pages;
 
 	cdw_tabs_window_draw_tabs(c_twindow);
-	cdw_config_ui_tabs_window_form_draw(c_twindow, c_pages);
+	cdw_config_ui_tabs_window_form_draw(c_twindow);
+
+	if (pid && fi
+	    && *pid != -1 && *fi != -1) {
 
-	bool follow_symlinks = task->create_image.follow_symlinks;
-	cdw_write_wizard_options_window_driver(task);
-	cdw_main_ui_handle_follow_symlinks_change(follow_symlinks, task->create_image.follow_symlinks);
+		cdw_tabs_window_show_tab_by_id(c_twindow, *pid);
+		cdw_form_driver_go_to_field(c_pages[*pid].cdw_form, *fi);
+	}
 
+	int key = cdw_write_wizard_options_window_driver(task);
 	cdw_write_wizard_options_window_destroy();
+	if (key == CDW_KEY_ENTER) {
+		return CDW_OK;
+	} else {
+		return CDW_CANCEL;
+	}
 
 	return CDW_OK;
 }
@@ -1027,17 +1119,17 @@
 */
 void cdw_write_wizard_options_window_destroy(void)
 {
-	if (cdw_wizard_window_tip != (char *) NULL) {
-		free(cdw_wizard_window_tip);
-		cdw_wizard_window_tip = (char *) NULL;
+	if (wizard.window_tip) {
+		free(wizard.window_tip);
+		wizard.window_tip = (char *) NULL;
 	}
 
 	for (int i = 0; i < c_twindow->n_tabs; i++) {
 		cdw_id_t id = c_twindow->tabs[i].id;
-		if (c_pages[id].cdw_form != (cdw_form_t *) NULL) {
+		if (c_pages[id].cdw_form) {
 			cdw_form_delete_form_objects(c_pages[id].cdw_form);
 		}
-		if (c_pages[id].cdw_form != (cdw_form_t *) NULL) {
+		if (c_pages[id].cdw_form) {
 			cdw_form_delete(&(c_pages[id].cdw_form));
 		}
 	}
@@ -1074,7 +1166,7 @@
 {
 	while (1) {
 		int key = cdw_tabs_window_driver(c_twindow);
-		if (key == CDW_KEY_ESCAPE) {
+		if (key == CDW_KEY_ESCAPE || key == 'q' || key == 'Q') {
 			break;
 		} else if (key == KEY_F(CDW_CONFIG_UI_SnC_KEY_A)
 			   || key == KEY_F(CDW_CONFIG_UI_SnC_KEY_B)) { /* SnC = Save and Close */
@@ -1086,7 +1178,8 @@
 			}
 			cdw_id_t page_id = 0;
 			int fi = 0;
-			cdw_rv_t valid = cdw_write_wizard_options_validate_and_save(task, &page_id, &fi);
+			cdw_write_wizard_options_save(task);
+			cdw_rv_t valid = cdw_write_wizard_options_validate(task, &page_id, &fi);
 			if (valid == CDW_NO) { /* some option field is invalid */
 
 				/* 2TRANS: this is title of dialog window */
@@ -1117,80 +1210,209 @@
 
 
 
-cdw_rv_t cdw_write_wizard_options_validate_and_save(cdw_task_t *task, cdw_id_t *page_id, int *fi)
+cdw_rv_t cdw_write_wizard_options_validate(cdw_task_t *task, cdw_id_t *pid, int *fi)
 {
-	cdw_form_t *cdw_form = (cdw_form_t *) NULL;
+	cdw_rv_t crv = CDW_NO;
+
 	if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
-		cdw_id_t id = WRITE_CDRECORD;
-		cdw_form = c_pages[id].cdw_form;
-		cdw_rv_t crv = cdw_cdrecord_options_validate(cdw_form, fi);
+		*pid = WRITE_CDRECORD;
+		crv = cdw_cdrecord_options_validate(task, fi);
 		if (crv == CDW_NO) {
-			*page_id = id;
 			return CDW_NO;
 		}
 	} else if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
-		cdw_id_t id = WRITE_GROWISOFS;
-		cdw_form = c_pages[id].cdw_form;
-		cdw_rv_t crv = cdw_growisofs_options_validate(cdw_form, fi);
+		*pid = WRITE_GROWISOFS;
+		crv = cdw_growisofs_options_validate(task, fi);
 		if (crv == CDW_NO) {
-			*page_id = id;
 			return CDW_NO;
 		}
 	} else if (task->burn.tool.id == CDW_TOOL_XORRISO) {
-		cdw_id_t id = WRITE_XORRISO_BURN;
-		cdw_form = c_pages[id].cdw_form;
-		cdw_rv_t crv = cdw_xorriso_burn_options_validate(cdw_form, fi);
+		*pid = WRITE_XORRISO_BURN;
+		crv = cdw_xorriso_burn_options_validate(task, fi);
 		if (crv == CDW_NO) {
-			*page_id = id;
 			return CDW_NO;
 		}
 	} else {
-		cdw_assert (0, "ERROR: invalid tool id for task \"burn\": %lld\n",
-			    task->burn.tool.id);
+		cdw_assert (0, "ERROR: invalid tool id for task \"burn\": %s (%lld)\n",
+			    cdw_ext_tools_get_tool_name(task->burn.tool.id), task->burn.tool.id);
 		return CDW_NO;
 	}
 
+
+	if (task->id != CDW_TASK_BURN_FROM_FILES) {
+		/* Don't validate options for creating ISO9660 fs
+		   on-the-fly. */
+
+		return CDW_OK;
+	}
+
+
 	if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-		cdw_id_t id = WRITE_MKISOFS;
-		cdw_form = c_pages[id].cdw_form;
-		cdw_rv_t crv = cdw_mkisofs_options_validate(cdw_form, fi);
+		*pid = WRITE_MKISOFS_ISO_MAIN;
+		crv = cdw_mkisofs_options_validate(&(task->create_image.iso9660), fi);
 		if (crv == CDW_NO) {
-			*page_id = id;
 			return CDW_NO;
 		}
+
+		*pid = WRITE_MKISOFS_ISO_META;
+		crv = cdw_mkisofsrc_options_validate(&(task->create_image.iso9660), fi);
+		if (crv == CDW_NO) {
+			return CDW_NO;
+		}
+
 	} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
-		cdw_id_t id = WRITE_XORRISO_ISO;
-		cdw_form = c_pages[id].cdw_form;
-		cdw_rv_t crv = cdw_xorriso_iso_options_validate(cdw_form, fi);
+		*pid = WRITE_XORRISO_ISO_MAIN;
+		crv = cdw_xorriso_iso_options_validate(&(task->create_image.iso9660), fi);
+		if (crv == CDW_NO) {
+			return CDW_NO;
+		}
+
+		*pid = WRITE_XORRISO_ISO_META;
+		crv = cdw_xorrisorc_options_validate(&(task->create_image.iso9660), fi);
 		if (crv == CDW_NO) {
-			*page_id = id;
 			return CDW_NO;
 		}
 	} else {
-		;
+		cdw_assert (0, "ERROR: invalid tool id for task \"create image\": %s (%lld)\n",
+			    cdw_ext_tools_get_tool_name(task->create_image.tool.id), task->create_image.tool.id);
 	}
 
+	return CDW_OK;
+}
+
+
+
+
+
+cdw_rv_t cdw_write_wizard_options_save(cdw_task_t *task)
+{
+	cdw_id_t pid = 0;
+	cdw_form_t *cdw_form = (cdw_form_t *) NULL;
+
 	if (task->burn.tool.id == CDW_TOOL_CDRECORD) {
-		cdw_form = c_pages[WRITE_CDRECORD].cdw_form;
+		pid = WRITE_CDRECORD;
+
+		cdw_form = c_pages[pid].cdw_form;
 		cdw_cdrecord_options_save(cdw_form, task);
+
 	} else if (task->burn.tool.id == CDW_TOOL_GROWISOFS) {
-		cdw_form = c_pages[WRITE_GROWISOFS].cdw_form;
+		pid = WRITE_GROWISOFS;
+
+		cdw_form = c_pages[pid].cdw_form;
 		cdw_growisofs_options_save(cdw_form, task);
+
 	} else if (task->burn.tool.id == CDW_TOOL_XORRISO) {
-		cdw_form = c_pages[WRITE_XORRISO_BURN].cdw_form;
+		pid = WRITE_XORRISO_BURN;
+
+		cdw_form = c_pages[pid].cdw_form;
 		cdw_xorriso_burn_options_save(cdw_form, task);
+
 	} else {
-		;
+		cdw_assert (0, "ERROR: invalid tool id for task \"burn\": %s (%lld)\n",
+			    cdw_ext_tools_get_tool_name(task->burn.tool.id), task->burn.tool.id);
+		return CDW_NO;
 	}
 
+
+	if (task->id != CDW_TASK_BURN_FROM_FILES) {
+		/* Don't save options for creating ISO9660 fs
+		   on-the-fly. */
+
+		return CDW_OK;
+	}
+
+
 	if (task->create_image.tool.id == CDW_TOOL_MKISOFS) {
-		cdw_form = c_pages[WRITE_MKISOFS].cdw_form;
-		cdw_mkisofs_options_save(cdw_form, task);
+		pid = WRITE_MKISOFS_ISO_MAIN;
+
+		cdw_form = c_pages[pid].cdw_form;
+		cdw_mkisofs_options_save(cdw_form, &(task->create_image.iso9660));
+
+		pid = WRITE_MKISOFS_ISO_META;
+
+		cdw_form = c_pages[pid].cdw_form;
+		cdw_mkisofsrc_options_save(cdw_form, &(task->create_image.iso9660));
+
 	} else if (task->create_image.tool.id == CDW_TOOL_XORRISO) {
-		cdw_form = c_pages[WRITE_XORRISO_ISO].cdw_form;
-		cdw_xorriso_iso_options_save(cdw_form, task);
+		pid = WRITE_XORRISO_ISO_MAIN;
+
+		cdw_form = c_pages[pid].cdw_form;
+		cdw_xorriso_iso_options_save(cdw_form, &(task->create_image.iso9660));
+
+		pid = WRITE_XORRISO_ISO_META;
+
+		cdw_form = c_pages[pid].cdw_form;
+		cdw_xorrisorc_options_save(cdw_form, &(task->create_image.iso9660));
+
 	} else {
-		;
+		cdw_assert (0, "ERROR: invalid tool id for task \"create image\": %s (%lld)\n",
+			    cdw_ext_tools_get_tool_name(task->create_image.tool.id), task->create_image.tool.id);
+	}
+
+	return CDW_OK;
+}
+
+
+
+
+/**
+   \brief Check options for burning
+
+   Check options used to burn a disc that *would* be displayed in
+   options window. The function should be called when "Options" window
+   has not been displayed, i.e. when user pressed "Write" button in
+   wizard without visiting "Options" window.
+
+   Some options in such non-visited window may be invalid, this
+   function should detect this.
+
+   First it tests contents of task variable, and if there is anything
+   wrong with any of the options related to writing, it creates
+   and display options window, with cursor placed in problematic
+   field.
+
+   User is given a chance to fix the options in the window. User may
+   press Escape key in the window, the function will then return
+   CDW_NO. The function also returns CDW_NO if it decides that for
+   some reason they weren't fixed by user.
+
+   \param task - task which needs to be validated
+
+   \return CDW_OK if options for writing are valid
+   \return CDW_NO if the options are invalid, or if user has pressed Escape key in options window
+*/
+cdw_rv_t cdw_write_wizard_options_validate_closed(cdw_task_t *task)
+{
+	cdw_id_t pid;
+	int fi;
+	cdw_rv_t valid = cdw_write_wizard_options_validate(task, &pid, &fi);
+	if (valid == CDW_NO) { /* some option field is invalid */
+
+		/* 2TRANS: this is title of dialog window */
+		cdw_buttons_dialog(_("Error"),
+				   /* 2TRANS: this is message in dialog window */
+				   _("One of option fields is incorrect or contains character that is not allowed. Please fix it."),
+				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+
+		int c = cdw_write_wizard_options_window_by_flow(&pid, &fi);
+		if (c == '0') {
+			return CDW_NO;
+		} else {
+			/* c == '1', invalid options have been fixed
+			   and user pressed "Save and Close"
+			   key. Validate again, just to be sure. */
+			valid = cdw_write_wizard_options_validate(task, &pid, &fi);
+			if (valid == CDW_NO) {
+				/* 2TRANS: this is title of dialog window */
+				cdw_buttons_dialog(_("Error"),
+						   /* 2TRANS: this is message in dialog window */
+						   _("The invalid option(s) in options window has not been fixed."),
+						   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+				return CDW_NO;
+			}
+		}
+	} else {
+		/* Options are valid and user has pressed "save and close" key. */
 	}
 
 	return CDW_OK;
@@ -1228,8 +1450,8 @@
 
 	/* save */
 	s = cdw_form_get_string(wizard.cdw_form, f_volume_id_i);
-	strncpy(task->create_image.volume_id, s, CDW_ISO9660_VOLI_LEN);
-	task->create_image.volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
+	strncpy(task->create_image.iso9660.volume_id, s, CDW_ISO9660_VOLI_LEN);
+	task->create_image.iso9660.volume_id[CDW_ISO9660_VOLI_LEN] = '\0';
 
 	if (wizard.verify_checkbox_visible) {
 		task->burn.verify = cdw_form_get_checkbox_state(wizard.cdw_form, f_verify_i);
@@ -1256,4 +1478,3 @@
 
 	return CDW_OK;
 }
-
diff -Naur orig/src/user_interface/Makefile.am patched/src/user_interface/Makefile.am
--- orig/src/user_interface/Makefile.am	2012-01-04 20:31:56.000000000 +0100
+++ patched/src/user_interface/Makefile.am	2014-01-26 17:47:43.000000000 +0100
@@ -7,11 +7,11 @@
         cdw_form.c cdw_form.h \
         cdw_list_display.c cdw_list_display.h \
         cdw_processwin.c cdw_processwin.h \
-        cdw_widgets.h \
+        cdw_widgets.c cdw_widgets.h \
 	cdw_window.c cdw_window.h \
         cdw_text_file_viewer.c cdw_text_file_viewer.h \
         cdw_write_wizard.c cdw_write_wizard.h \
-	cdw_iso9660_wizard.c cdw_iso9660_wizard.h \
+	cdw_image_wizard.c cdw_image_wizard.h \
 	cdw_erase_wizard.c cdw_erase_wizard.h \
 	cdw_verify_wizard.c cdw_verify_wizard.h \
         cdw_main_window.c cdw_main_window.h \
@@ -32,4 +32,4 @@
 # library built only for purposes of testing (checking)
 check_LIBRARIES = libcdwuserinterface_check.a
 libcdwuserinterface_check_a_SOURCES = $(sources)
-libcdwuserinterface_check_a_CPPFLAGS = -DCDW_UNIT_TEST_CODE $(AM_CPPFLAGS)
\ Nincs jsor a fjl vgn
+libcdwuserinterface_check_a_CPPFLAGS = -DCDW_UNIT_TEST_CODE $(AM_CPPFLAGS)
diff -Naur orig/src/user_interface/Makefile.in patched/src/user_interface/Makefile.in
--- orig/src/user_interface/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/user_interface/Makefile.in	2014-01-26 17:48:02.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,29 +76,34 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/user_interface
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwuserinterface_a_AR = $(AR) $(ARFLAGS)
 libcdwuserinterface_a_LIBADD =
 am__objects_1 = cdw_colors.$(OBJEXT) cdw_ncurses.$(OBJEXT) \
 	cdw_form.$(OBJEXT) cdw_list_display.$(OBJEXT) \
-	cdw_processwin.$(OBJEXT) cdw_window.$(OBJEXT) \
-	cdw_text_file_viewer.$(OBJEXT) cdw_write_wizard.$(OBJEXT) \
-	cdw_iso9660_wizard.$(OBJEXT) cdw_erase_wizard.$(OBJEXT) \
-	cdw_verify_wizard.$(OBJEXT) cdw_main_window.$(OBJEXT) \
-	cdw_help.$(OBJEXT) cdw_tabs_window.$(OBJEXT)
+	cdw_processwin.$(OBJEXT) cdw_widgets.$(OBJEXT) \
+	cdw_window.$(OBJEXT) cdw_text_file_viewer.$(OBJEXT) \
+	cdw_write_wizard.$(OBJEXT) cdw_image_wizard.$(OBJEXT) \
+	cdw_erase_wizard.$(OBJEXT) cdw_verify_wizard.$(OBJEXT) \
+	cdw_main_window.$(OBJEXT) cdw_help.$(OBJEXT) \
+	cdw_tabs_window.$(OBJEXT)
 am_libcdwuserinterface_a_OBJECTS = $(am__objects_1)
 libcdwuserinterface_a_OBJECTS = $(am_libcdwuserinterface_a_OBJECTS)
 libcdwuserinterface_check_a_AR = $(AR) $(ARFLAGS)
@@ -64,10 +113,11 @@
 	libcdwuserinterface_check_a-cdw_form.$(OBJEXT) \
 	libcdwuserinterface_check_a-cdw_list_display.$(OBJEXT) \
 	libcdwuserinterface_check_a-cdw_processwin.$(OBJEXT) \
+	libcdwuserinterface_check_a-cdw_widgets.$(OBJEXT) \
 	libcdwuserinterface_check_a-cdw_window.$(OBJEXT) \
 	libcdwuserinterface_check_a-cdw_text_file_viewer.$(OBJEXT) \
 	libcdwuserinterface_check_a-cdw_write_wizard.$(OBJEXT) \
-	libcdwuserinterface_check_a-cdw_iso9660_wizard.$(OBJEXT) \
+	libcdwuserinterface_check_a-cdw_image_wizard.$(OBJEXT) \
 	libcdwuserinterface_check_a-cdw_erase_wizard.$(OBJEXT) \
 	libcdwuserinterface_check_a-cdw_verify_wizard.$(OBJEXT) \
 	libcdwuserinterface_check_a-cdw_main_window.$(OBJEXT) \
@@ -76,30 +126,80 @@
 am_libcdwuserinterface_check_a_OBJECTS = $(am__objects_2)
 libcdwuserinterface_check_a_OBJECTS =  \
 	$(am_libcdwuserinterface_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwuserinterface_a_SOURCES) \
 	$(libcdwuserinterface_check_a_SOURCES)
 DIST_SOURCES = $(libcdwuserinterface_a_SOURCES) \
 	$(libcdwuserinterface_check_a_SOURCES)
-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
-	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
-AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
-	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
 	distdir
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -132,6 +232,7 @@
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -228,11 +329,11 @@
         cdw_form.c cdw_form.h \
         cdw_list_display.c cdw_list_display.h \
         cdw_processwin.c cdw_processwin.h \
-        cdw_widgets.h \
+        cdw_widgets.c cdw_widgets.h \
 	cdw_window.c cdw_window.h \
         cdw_text_file_viewer.c cdw_text_file_viewer.h \
         cdw_write_wizard.c cdw_write_wizard.h \
-	cdw_iso9660_wizard.c cdw_iso9660_wizard.h \
+	cdw_image_wizard.c cdw_image_wizard.h \
 	cdw_erase_wizard.c cdw_erase_wizard.h \
 	cdw_verify_wizard.c cdw_verify_wizard.h \
         cdw_main_window.c cdw_main_window.h \
@@ -355,14 +456,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwuserinterface.a: $(libcdwuserinterface_a_OBJECTS) $(libcdwuserinterface_a_DEPENDENCIES) $(EXTRA_libcdwuserinterface_a_DEPENDENCIES) 
-	-rm -f libcdwuserinterface.a
-	$(libcdwuserinterface_a_AR) libcdwuserinterface.a $(libcdwuserinterface_a_OBJECTS) $(libcdwuserinterface_a_LIBADD)
-	$(RANLIB) libcdwuserinterface.a
+	$(AM_V_at)-rm -f libcdwuserinterface.a
+	$(AM_V_AR)$(libcdwuserinterface_a_AR) libcdwuserinterface.a $(libcdwuserinterface_a_OBJECTS) $(libcdwuserinterface_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwuserinterface.a
+
 libcdwuserinterface_check.a: $(libcdwuserinterface_check_a_OBJECTS) $(libcdwuserinterface_check_a_DEPENDENCIES) $(EXTRA_libcdwuserinterface_check_a_DEPENDENCIES) 
-	-rm -f libcdwuserinterface_check.a
-	$(libcdwuserinterface_check_a_AR) libcdwuserinterface_check.a $(libcdwuserinterface_check_a_OBJECTS) $(libcdwuserinterface_check_a_LIBADD)
-	$(RANLIB) libcdwuserinterface_check.a
+	$(AM_V_at)-rm -f libcdwuserinterface_check.a
+	$(AM_V_AR)$(libcdwuserinterface_check_a_AR) libcdwuserinterface_check.a $(libcdwuserinterface_check_a_OBJECTS) $(libcdwuserinterface_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwuserinterface_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -374,7 +477,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_erase_wizard.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_form.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_help.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_iso9660_wizard.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_image_wizard.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_list_display.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_main_window.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_ncurses.Po@am__quote@
@@ -382,13 +485,14 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_tabs_window.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_text_file_viewer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_verify_wizard.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_widgets.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_window.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_write_wizard.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_iso9660_wizard.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_image_wizard.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Po@am__quote@
@@ -396,236 +500,254 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_widgets.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwuserinterface_check_a-cdw_colors.o: cdw_colors.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_colors.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Tpo -c -o libcdwuserinterface_check_a-cdw_colors.o `test -f 'cdw_colors.c' || echo '$(srcdir)/'`cdw_colors.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_colors.c' object='libcdwuserinterface_check_a-cdw_colors.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_colors.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Tpo -c -o libcdwuserinterface_check_a-cdw_colors.o `test -f 'cdw_colors.c' || echo '$(srcdir)/'`cdw_colors.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_colors.c' object='libcdwuserinterface_check_a-cdw_colors.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_colors.o `test -f 'cdw_colors.c' || echo '$(srcdir)/'`cdw_colors.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_colors.o `test -f 'cdw_colors.c' || echo '$(srcdir)/'`cdw_colors.c
 
 libcdwuserinterface_check_a-cdw_colors.obj: cdw_colors.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_colors.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Tpo -c -o libcdwuserinterface_check_a-cdw_colors.obj `if test -f 'cdw_colors.c'; then $(CYGPATH_W) 'cdw_colors.c'; else $(CYGPATH_W) '$(srcdir)/cdw_colors.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_colors.c' object='libcdwuserinterface_check_a-cdw_colors.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_colors.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Tpo -c -o libcdwuserinterface_check_a-cdw_colors.obj `if test -f 'cdw_colors.c'; then $(CYGPATH_W) 'cdw_colors.c'; else $(CYGPATH_W) '$(srcdir)/cdw_colors.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_colors.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_colors.c' object='libcdwuserinterface_check_a-cdw_colors.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_colors.obj `if test -f 'cdw_colors.c'; then $(CYGPATH_W) 'cdw_colors.c'; else $(CYGPATH_W) '$(srcdir)/cdw_colors.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_colors.obj `if test -f 'cdw_colors.c'; then $(CYGPATH_W) 'cdw_colors.c'; else $(CYGPATH_W) '$(srcdir)/cdw_colors.c'; fi`
 
 libcdwuserinterface_check_a-cdw_ncurses.o: cdw_ncurses.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_ncurses.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Tpo -c -o libcdwuserinterface_check_a-cdw_ncurses.o `test -f 'cdw_ncurses.c' || echo '$(srcdir)/'`cdw_ncurses.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_ncurses.c' object='libcdwuserinterface_check_a-cdw_ncurses.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_ncurses.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Tpo -c -o libcdwuserinterface_check_a-cdw_ncurses.o `test -f 'cdw_ncurses.c' || echo '$(srcdir)/'`cdw_ncurses.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_ncurses.c' object='libcdwuserinterface_check_a-cdw_ncurses.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_ncurses.o `test -f 'cdw_ncurses.c' || echo '$(srcdir)/'`cdw_ncurses.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_ncurses.o `test -f 'cdw_ncurses.c' || echo '$(srcdir)/'`cdw_ncurses.c
 
 libcdwuserinterface_check_a-cdw_ncurses.obj: cdw_ncurses.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_ncurses.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Tpo -c -o libcdwuserinterface_check_a-cdw_ncurses.obj `if test -f 'cdw_ncurses.c'; then $(CYGPATH_W) 'cdw_ncurses.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ncurses.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_ncurses.c' object='libcdwuserinterface_check_a-cdw_ncurses.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_ncurses.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Tpo -c -o libcdwuserinterface_check_a-cdw_ncurses.obj `if test -f 'cdw_ncurses.c'; then $(CYGPATH_W) 'cdw_ncurses.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ncurses.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_ncurses.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_ncurses.c' object='libcdwuserinterface_check_a-cdw_ncurses.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_ncurses.obj `if test -f 'cdw_ncurses.c'; then $(CYGPATH_W) 'cdw_ncurses.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ncurses.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_ncurses.obj `if test -f 'cdw_ncurses.c'; then $(CYGPATH_W) 'cdw_ncurses.c'; else $(CYGPATH_W) '$(srcdir)/cdw_ncurses.c'; fi`
 
 libcdwuserinterface_check_a-cdw_form.o: cdw_form.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_form.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Tpo -c -o libcdwuserinterface_check_a-cdw_form.o `test -f 'cdw_form.c' || echo '$(srcdir)/'`cdw_form.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_form.c' object='libcdwuserinterface_check_a-cdw_form.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_form.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Tpo -c -o libcdwuserinterface_check_a-cdw_form.o `test -f 'cdw_form.c' || echo '$(srcdir)/'`cdw_form.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_form.c' object='libcdwuserinterface_check_a-cdw_form.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_form.o `test -f 'cdw_form.c' || echo '$(srcdir)/'`cdw_form.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_form.o `test -f 'cdw_form.c' || echo '$(srcdir)/'`cdw_form.c
 
 libcdwuserinterface_check_a-cdw_form.obj: cdw_form.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_form.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Tpo -c -o libcdwuserinterface_check_a-cdw_form.obj `if test -f 'cdw_form.c'; then $(CYGPATH_W) 'cdw_form.c'; else $(CYGPATH_W) '$(srcdir)/cdw_form.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_form.c' object='libcdwuserinterface_check_a-cdw_form.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_form.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Tpo -c -o libcdwuserinterface_check_a-cdw_form.obj `if test -f 'cdw_form.c'; then $(CYGPATH_W) 'cdw_form.c'; else $(CYGPATH_W) '$(srcdir)/cdw_form.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_form.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_form.c' object='libcdwuserinterface_check_a-cdw_form.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_form.obj `if test -f 'cdw_form.c'; then $(CYGPATH_W) 'cdw_form.c'; else $(CYGPATH_W) '$(srcdir)/cdw_form.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_form.obj `if test -f 'cdw_form.c'; then $(CYGPATH_W) 'cdw_form.c'; else $(CYGPATH_W) '$(srcdir)/cdw_form.c'; fi`
 
 libcdwuserinterface_check_a-cdw_list_display.o: cdw_list_display.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_list_display.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Tpo -c -o libcdwuserinterface_check_a-cdw_list_display.o `test -f 'cdw_list_display.c' || echo '$(srcdir)/'`cdw_list_display.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_list_display.c' object='libcdwuserinterface_check_a-cdw_list_display.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_list_display.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Tpo -c -o libcdwuserinterface_check_a-cdw_list_display.o `test -f 'cdw_list_display.c' || echo '$(srcdir)/'`cdw_list_display.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_list_display.c' object='libcdwuserinterface_check_a-cdw_list_display.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_list_display.o `test -f 'cdw_list_display.c' || echo '$(srcdir)/'`cdw_list_display.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_list_display.o `test -f 'cdw_list_display.c' || echo '$(srcdir)/'`cdw_list_display.c
 
 libcdwuserinterface_check_a-cdw_list_display.obj: cdw_list_display.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_list_display.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Tpo -c -o libcdwuserinterface_check_a-cdw_list_display.obj `if test -f 'cdw_list_display.c'; then $(CYGPATH_W) 'cdw_list_display.c'; else $(CYGPATH_W) '$(srcdir)/cdw_list_display.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_list_display.c' object='libcdwuserinterface_check_a-cdw_list_display.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_list_display.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Tpo -c -o libcdwuserinterface_check_a-cdw_list_display.obj `if test -f 'cdw_list_display.c'; then $(CYGPATH_W) 'cdw_list_display.c'; else $(CYGPATH_W) '$(srcdir)/cdw_list_display.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_list_display.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_list_display.c' object='libcdwuserinterface_check_a-cdw_list_display.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_list_display.obj `if test -f 'cdw_list_display.c'; then $(CYGPATH_W) 'cdw_list_display.c'; else $(CYGPATH_W) '$(srcdir)/cdw_list_display.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_list_display.obj `if test -f 'cdw_list_display.c'; then $(CYGPATH_W) 'cdw_list_display.c'; else $(CYGPATH_W) '$(srcdir)/cdw_list_display.c'; fi`
 
 libcdwuserinterface_check_a-cdw_processwin.o: cdw_processwin.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_processwin.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Tpo -c -o libcdwuserinterface_check_a-cdw_processwin.o `test -f 'cdw_processwin.c' || echo '$(srcdir)/'`cdw_processwin.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_processwin.c' object='libcdwuserinterface_check_a-cdw_processwin.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_processwin.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Tpo -c -o libcdwuserinterface_check_a-cdw_processwin.o `test -f 'cdw_processwin.c' || echo '$(srcdir)/'`cdw_processwin.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_processwin.c' object='libcdwuserinterface_check_a-cdw_processwin.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_processwin.o `test -f 'cdw_processwin.c' || echo '$(srcdir)/'`cdw_processwin.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_processwin.o `test -f 'cdw_processwin.c' || echo '$(srcdir)/'`cdw_processwin.c
 
 libcdwuserinterface_check_a-cdw_processwin.obj: cdw_processwin.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_processwin.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Tpo -c -o libcdwuserinterface_check_a-cdw_processwin.obj `if test -f 'cdw_processwin.c'; then $(CYGPATH_W) 'cdw_processwin.c'; else $(CYGPATH_W) '$(srcdir)/cdw_processwin.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_processwin.c' object='libcdwuserinterface_check_a-cdw_processwin.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_processwin.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Tpo -c -o libcdwuserinterface_check_a-cdw_processwin.obj `if test -f 'cdw_processwin.c'; then $(CYGPATH_W) 'cdw_processwin.c'; else $(CYGPATH_W) '$(srcdir)/cdw_processwin.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_processwin.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_processwin.c' object='libcdwuserinterface_check_a-cdw_processwin.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_processwin.obj `if test -f 'cdw_processwin.c'; then $(CYGPATH_W) 'cdw_processwin.c'; else $(CYGPATH_W) '$(srcdir)/cdw_processwin.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_processwin.obj `if test -f 'cdw_processwin.c'; then $(CYGPATH_W) 'cdw_processwin.c'; else $(CYGPATH_W) '$(srcdir)/cdw_processwin.c'; fi`
+
+libcdwuserinterface_check_a-cdw_widgets.o: cdw_widgets.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_widgets.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_widgets.Tpo -c -o libcdwuserinterface_check_a-cdw_widgets.o `test -f 'cdw_widgets.c' || echo '$(srcdir)/'`cdw_widgets.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_widgets.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_widgets.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_widgets.c' object='libcdwuserinterface_check_a-cdw_widgets.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_widgets.o `test -f 'cdw_widgets.c' || echo '$(srcdir)/'`cdw_widgets.c
+
+libcdwuserinterface_check_a-cdw_widgets.obj: cdw_widgets.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_widgets.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_widgets.Tpo -c -o libcdwuserinterface_check_a-cdw_widgets.obj `if test -f 'cdw_widgets.c'; then $(CYGPATH_W) 'cdw_widgets.c'; else $(CYGPATH_W) '$(srcdir)/cdw_widgets.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_widgets.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_widgets.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_widgets.c' object='libcdwuserinterface_check_a-cdw_widgets.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_widgets.obj `if test -f 'cdw_widgets.c'; then $(CYGPATH_W) 'cdw_widgets.c'; else $(CYGPATH_W) '$(srcdir)/cdw_widgets.c'; fi`
 
 libcdwuserinterface_check_a-cdw_window.o: cdw_window.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_window.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Tpo -c -o libcdwuserinterface_check_a-cdw_window.o `test -f 'cdw_window.c' || echo '$(srcdir)/'`cdw_window.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_window.c' object='libcdwuserinterface_check_a-cdw_window.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_window.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Tpo -c -o libcdwuserinterface_check_a-cdw_window.o `test -f 'cdw_window.c' || echo '$(srcdir)/'`cdw_window.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_window.c' object='libcdwuserinterface_check_a-cdw_window.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_window.o `test -f 'cdw_window.c' || echo '$(srcdir)/'`cdw_window.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_window.o `test -f 'cdw_window.c' || echo '$(srcdir)/'`cdw_window.c
 
 libcdwuserinterface_check_a-cdw_window.obj: cdw_window.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_window.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Tpo -c -o libcdwuserinterface_check_a-cdw_window.obj `if test -f 'cdw_window.c'; then $(CYGPATH_W) 'cdw_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_window.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_window.c' object='libcdwuserinterface_check_a-cdw_window.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_window.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Tpo -c -o libcdwuserinterface_check_a-cdw_window.obj `if test -f 'cdw_window.c'; then $(CYGPATH_W) 'cdw_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_window.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_window.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_window.c' object='libcdwuserinterface_check_a-cdw_window.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_window.obj `if test -f 'cdw_window.c'; then $(CYGPATH_W) 'cdw_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_window.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_window.obj `if test -f 'cdw_window.c'; then $(CYGPATH_W) 'cdw_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_window.c'; fi`
 
 libcdwuserinterface_check_a-cdw_text_file_viewer.o: cdw_text_file_viewer.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_text_file_viewer.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Tpo -c -o libcdwuserinterface_check_a-cdw_text_file_viewer.o `test -f 'cdw_text_file_viewer.c' || echo '$(srcdir)/'`cdw_text_file_viewer.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_text_file_viewer.c' object='libcdwuserinterface_check_a-cdw_text_file_viewer.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_text_file_viewer.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Tpo -c -o libcdwuserinterface_check_a-cdw_text_file_viewer.o `test -f 'cdw_text_file_viewer.c' || echo '$(srcdir)/'`cdw_text_file_viewer.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_text_file_viewer.c' object='libcdwuserinterface_check_a-cdw_text_file_viewer.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_text_file_viewer.o `test -f 'cdw_text_file_viewer.c' || echo '$(srcdir)/'`cdw_text_file_viewer.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_text_file_viewer.o `test -f 'cdw_text_file_viewer.c' || echo '$(srcdir)/'`cdw_text_file_viewer.c
 
 libcdwuserinterface_check_a-cdw_text_file_viewer.obj: cdw_text_file_viewer.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_text_file_viewer.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Tpo -c -o libcdwuserinterface_check_a-cdw_text_file_viewer.obj `if test -f 'cdw_text_file_viewer.c'; then $(CYGPATH_W) 'cdw_text_file_viewer.c'; else $(CYGPATH_W) '$(srcdir)/cdw_text_file_viewer.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_text_file_viewer.c' object='libcdwuserinterface_check_a-cdw_text_file_viewer.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_text_file_viewer.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Tpo -c -o libcdwuserinterface_check_a-cdw_text_file_viewer.obj `if test -f 'cdw_text_file_viewer.c'; then $(CYGPATH_W) 'cdw_text_file_viewer.c'; else $(CYGPATH_W) '$(srcdir)/cdw_text_file_viewer.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_text_file_viewer.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_text_file_viewer.c' object='libcdwuserinterface_check_a-cdw_text_file_viewer.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_text_file_viewer.obj `if test -f 'cdw_text_file_viewer.c'; then $(CYGPATH_W) 'cdw_text_file_viewer.c'; else $(CYGPATH_W) '$(srcdir)/cdw_text_file_viewer.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_text_file_viewer.obj `if test -f 'cdw_text_file_viewer.c'; then $(CYGPATH_W) 'cdw_text_file_viewer.c'; else $(CYGPATH_W) '$(srcdir)/cdw_text_file_viewer.c'; fi`
 
 libcdwuserinterface_check_a-cdw_write_wizard.o: cdw_write_wizard.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_write_wizard.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_write_wizard.o `test -f 'cdw_write_wizard.c' || echo '$(srcdir)/'`cdw_write_wizard.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_write_wizard.c' object='libcdwuserinterface_check_a-cdw_write_wizard.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_write_wizard.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_write_wizard.o `test -f 'cdw_write_wizard.c' || echo '$(srcdir)/'`cdw_write_wizard.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_write_wizard.c' object='libcdwuserinterface_check_a-cdw_write_wizard.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_write_wizard.o `test -f 'cdw_write_wizard.c' || echo '$(srcdir)/'`cdw_write_wizard.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_write_wizard.o `test -f 'cdw_write_wizard.c' || echo '$(srcdir)/'`cdw_write_wizard.c
 
 libcdwuserinterface_check_a-cdw_write_wizard.obj: cdw_write_wizard.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_write_wizard.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_write_wizard.obj `if test -f 'cdw_write_wizard.c'; then $(CYGPATH_W) 'cdw_write_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_write_wizard.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_write_wizard.c' object='libcdwuserinterface_check_a-cdw_write_wizard.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_write_wizard.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_write_wizard.obj `if test -f 'cdw_write_wizard.c'; then $(CYGPATH_W) 'cdw_write_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_write_wizard.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_write_wizard.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_write_wizard.c' object='libcdwuserinterface_check_a-cdw_write_wizard.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_write_wizard.obj `if test -f 'cdw_write_wizard.c'; then $(CYGPATH_W) 'cdw_write_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_write_wizard.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_write_wizard.obj `if test -f 'cdw_write_wizard.c'; then $(CYGPATH_W) 'cdw_write_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_write_wizard.c'; fi`
 
-libcdwuserinterface_check_a-cdw_iso9660_wizard.o: cdw_iso9660_wizard.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_iso9660_wizard.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_iso9660_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_iso9660_wizard.o `test -f 'cdw_iso9660_wizard.c' || echo '$(srcdir)/'`cdw_iso9660_wizard.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_iso9660_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_iso9660_wizard.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_iso9660_wizard.c' object='libcdwuserinterface_check_a-cdw_iso9660_wizard.o' libtool=no @AMDEPBACKSLASH@
+libcdwuserinterface_check_a-cdw_image_wizard.o: cdw_image_wizard.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_image_wizard.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_image_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_image_wizard.o `test -f 'cdw_image_wizard.c' || echo '$(srcdir)/'`cdw_image_wizard.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_image_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_image_wizard.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_image_wizard.c' object='libcdwuserinterface_check_a-cdw_image_wizard.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_iso9660_wizard.o `test -f 'cdw_iso9660_wizard.c' || echo '$(srcdir)/'`cdw_iso9660_wizard.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_image_wizard.o `test -f 'cdw_image_wizard.c' || echo '$(srcdir)/'`cdw_image_wizard.c
 
-libcdwuserinterface_check_a-cdw_iso9660_wizard.obj: cdw_iso9660_wizard.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_iso9660_wizard.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_iso9660_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_iso9660_wizard.obj `if test -f 'cdw_iso9660_wizard.c'; then $(CYGPATH_W) 'cdw_iso9660_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_iso9660_wizard.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_iso9660_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_iso9660_wizard.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_iso9660_wizard.c' object='libcdwuserinterface_check_a-cdw_iso9660_wizard.obj' libtool=no @AMDEPBACKSLASH@
+libcdwuserinterface_check_a-cdw_image_wizard.obj: cdw_image_wizard.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_image_wizard.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_image_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_image_wizard.obj `if test -f 'cdw_image_wizard.c'; then $(CYGPATH_W) 'cdw_image_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_image_wizard.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_image_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_image_wizard.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_image_wizard.c' object='libcdwuserinterface_check_a-cdw_image_wizard.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_iso9660_wizard.obj `if test -f 'cdw_iso9660_wizard.c'; then $(CYGPATH_W) 'cdw_iso9660_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_iso9660_wizard.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_image_wizard.obj `if test -f 'cdw_image_wizard.c'; then $(CYGPATH_W) 'cdw_image_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_image_wizard.c'; fi`
 
 libcdwuserinterface_check_a-cdw_erase_wizard.o: cdw_erase_wizard.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_erase_wizard.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_erase_wizard.o `test -f 'cdw_erase_wizard.c' || echo '$(srcdir)/'`cdw_erase_wizard.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_erase_wizard.c' object='libcdwuserinterface_check_a-cdw_erase_wizard.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_erase_wizard.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_erase_wizard.o `test -f 'cdw_erase_wizard.c' || echo '$(srcdir)/'`cdw_erase_wizard.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_erase_wizard.c' object='libcdwuserinterface_check_a-cdw_erase_wizard.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_erase_wizard.o `test -f 'cdw_erase_wizard.c' || echo '$(srcdir)/'`cdw_erase_wizard.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_erase_wizard.o `test -f 'cdw_erase_wizard.c' || echo '$(srcdir)/'`cdw_erase_wizard.c
 
 libcdwuserinterface_check_a-cdw_erase_wizard.obj: cdw_erase_wizard.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_erase_wizard.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_erase_wizard.obj `if test -f 'cdw_erase_wizard.c'; then $(CYGPATH_W) 'cdw_erase_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_erase_wizard.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_erase_wizard.c' object='libcdwuserinterface_check_a-cdw_erase_wizard.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_erase_wizard.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_erase_wizard.obj `if test -f 'cdw_erase_wizard.c'; then $(CYGPATH_W) 'cdw_erase_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_erase_wizard.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_erase_wizard.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_erase_wizard.c' object='libcdwuserinterface_check_a-cdw_erase_wizard.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_erase_wizard.obj `if test -f 'cdw_erase_wizard.c'; then $(CYGPATH_W) 'cdw_erase_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_erase_wizard.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_erase_wizard.obj `if test -f 'cdw_erase_wizard.c'; then $(CYGPATH_W) 'cdw_erase_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_erase_wizard.c'; fi`
 
 libcdwuserinterface_check_a-cdw_verify_wizard.o: cdw_verify_wizard.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_verify_wizard.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_verify_wizard.o `test -f 'cdw_verify_wizard.c' || echo '$(srcdir)/'`cdw_verify_wizard.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_verify_wizard.c' object='libcdwuserinterface_check_a-cdw_verify_wizard.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_verify_wizard.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_verify_wizard.o `test -f 'cdw_verify_wizard.c' || echo '$(srcdir)/'`cdw_verify_wizard.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_verify_wizard.c' object='libcdwuserinterface_check_a-cdw_verify_wizard.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_verify_wizard.o `test -f 'cdw_verify_wizard.c' || echo '$(srcdir)/'`cdw_verify_wizard.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_verify_wizard.o `test -f 'cdw_verify_wizard.c' || echo '$(srcdir)/'`cdw_verify_wizard.c
 
 libcdwuserinterface_check_a-cdw_verify_wizard.obj: cdw_verify_wizard.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_verify_wizard.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_verify_wizard.obj `if test -f 'cdw_verify_wizard.c'; then $(CYGPATH_W) 'cdw_verify_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_verify_wizard.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_verify_wizard.c' object='libcdwuserinterface_check_a-cdw_verify_wizard.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_verify_wizard.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Tpo -c -o libcdwuserinterface_check_a-cdw_verify_wizard.obj `if test -f 'cdw_verify_wizard.c'; then $(CYGPATH_W) 'cdw_verify_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_verify_wizard.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_verify_wizard.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_verify_wizard.c' object='libcdwuserinterface_check_a-cdw_verify_wizard.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_verify_wizard.obj `if test -f 'cdw_verify_wizard.c'; then $(CYGPATH_W) 'cdw_verify_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_verify_wizard.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_verify_wizard.obj `if test -f 'cdw_verify_wizard.c'; then $(CYGPATH_W) 'cdw_verify_wizard.c'; else $(CYGPATH_W) '$(srcdir)/cdw_verify_wizard.c'; fi`
 
 libcdwuserinterface_check_a-cdw_main_window.o: cdw_main_window.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_main_window.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Tpo -c -o libcdwuserinterface_check_a-cdw_main_window.o `test -f 'cdw_main_window.c' || echo '$(srcdir)/'`cdw_main_window.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_main_window.c' object='libcdwuserinterface_check_a-cdw_main_window.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_main_window.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Tpo -c -o libcdwuserinterface_check_a-cdw_main_window.o `test -f 'cdw_main_window.c' || echo '$(srcdir)/'`cdw_main_window.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_main_window.c' object='libcdwuserinterface_check_a-cdw_main_window.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_main_window.o `test -f 'cdw_main_window.c' || echo '$(srcdir)/'`cdw_main_window.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_main_window.o `test -f 'cdw_main_window.c' || echo '$(srcdir)/'`cdw_main_window.c
 
 libcdwuserinterface_check_a-cdw_main_window.obj: cdw_main_window.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_main_window.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Tpo -c -o libcdwuserinterface_check_a-cdw_main_window.obj `if test -f 'cdw_main_window.c'; then $(CYGPATH_W) 'cdw_main_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_main_window.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_main_window.c' object='libcdwuserinterface_check_a-cdw_main_window.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_main_window.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Tpo -c -o libcdwuserinterface_check_a-cdw_main_window.obj `if test -f 'cdw_main_window.c'; then $(CYGPATH_W) 'cdw_main_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_main_window.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_main_window.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_main_window.c' object='libcdwuserinterface_check_a-cdw_main_window.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_main_window.obj `if test -f 'cdw_main_window.c'; then $(CYGPATH_W) 'cdw_main_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_main_window.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_main_window.obj `if test -f 'cdw_main_window.c'; then $(CYGPATH_W) 'cdw_main_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_main_window.c'; fi`
 
 libcdwuserinterface_check_a-cdw_help.o: cdw_help.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_help.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Tpo -c -o libcdwuserinterface_check_a-cdw_help.o `test -f 'cdw_help.c' || echo '$(srcdir)/'`cdw_help.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_help.c' object='libcdwuserinterface_check_a-cdw_help.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_help.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Tpo -c -o libcdwuserinterface_check_a-cdw_help.o `test -f 'cdw_help.c' || echo '$(srcdir)/'`cdw_help.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_help.c' object='libcdwuserinterface_check_a-cdw_help.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_help.o `test -f 'cdw_help.c' || echo '$(srcdir)/'`cdw_help.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_help.o `test -f 'cdw_help.c' || echo '$(srcdir)/'`cdw_help.c
 
 libcdwuserinterface_check_a-cdw_help.obj: cdw_help.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_help.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Tpo -c -o libcdwuserinterface_check_a-cdw_help.obj `if test -f 'cdw_help.c'; then $(CYGPATH_W) 'cdw_help.c'; else $(CYGPATH_W) '$(srcdir)/cdw_help.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_help.c' object='libcdwuserinterface_check_a-cdw_help.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_help.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Tpo -c -o libcdwuserinterface_check_a-cdw_help.obj `if test -f 'cdw_help.c'; then $(CYGPATH_W) 'cdw_help.c'; else $(CYGPATH_W) '$(srcdir)/cdw_help.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_help.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_help.c' object='libcdwuserinterface_check_a-cdw_help.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_help.obj `if test -f 'cdw_help.c'; then $(CYGPATH_W) 'cdw_help.c'; else $(CYGPATH_W) '$(srcdir)/cdw_help.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_help.obj `if test -f 'cdw_help.c'; then $(CYGPATH_W) 'cdw_help.c'; else $(CYGPATH_W) '$(srcdir)/cdw_help.c'; fi`
 
 libcdwuserinterface_check_a-cdw_tabs_window.o: cdw_tabs_window.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_tabs_window.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Tpo -c -o libcdwuserinterface_check_a-cdw_tabs_window.o `test -f 'cdw_tabs_window.c' || echo '$(srcdir)/'`cdw_tabs_window.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_tabs_window.c' object='libcdwuserinterface_check_a-cdw_tabs_window.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_tabs_window.o -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Tpo -c -o libcdwuserinterface_check_a-cdw_tabs_window.o `test -f 'cdw_tabs_window.c' || echo '$(srcdir)/'`cdw_tabs_window.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_tabs_window.c' object='libcdwuserinterface_check_a-cdw_tabs_window.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_tabs_window.o `test -f 'cdw_tabs_window.c' || echo '$(srcdir)/'`cdw_tabs_window.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_tabs_window.o `test -f 'cdw_tabs_window.c' || echo '$(srcdir)/'`cdw_tabs_window.c
 
 libcdwuserinterface_check_a-cdw_tabs_window.obj: cdw_tabs_window.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_tabs_window.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Tpo -c -o libcdwuserinterface_check_a-cdw_tabs_window.obj `if test -f 'cdw_tabs_window.c'; then $(CYGPATH_W) 'cdw_tabs_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_tabs_window.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_tabs_window.c' object='libcdwuserinterface_check_a-cdw_tabs_window.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwuserinterface_check_a-cdw_tabs_window.obj -MD -MP -MF $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Tpo -c -o libcdwuserinterface_check_a-cdw_tabs_window.obj `if test -f 'cdw_tabs_window.c'; then $(CYGPATH_W) 'cdw_tabs_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_tabs_window.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Tpo $(DEPDIR)/libcdwuserinterface_check_a-cdw_tabs_window.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_tabs_window.c' object='libcdwuserinterface_check_a-cdw_tabs_window.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_tabs_window.obj `if test -f 'cdw_tabs_window.c'; then $(CYGPATH_W) 'cdw_tabs_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_tabs_window.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwuserinterface_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwuserinterface_check_a-cdw_tabs_window.obj `if test -f 'cdw_tabs_window.c'; then $(CYGPATH_W) 'cdw_tabs_window.c'; else $(CYGPATH_W) '$(srcdir)/cdw_tabs_window.c'; fi`
 
 # This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
 	  echo "Making $$target in $$subdir"; \
 	  if test "$$subdir" = "."; then \
 	    dot_seen=yes; \
@@ -640,57 +762,12 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test "$$subdir" = "."; then :; else \
-	    rev="$$subdir $$rev"; \
-	  fi; \
-	done; \
-	rev="$$rev ."; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done && test -z "$$fail"
-tags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
-	done
-ctags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
-	done
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
 	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
@@ -706,12 +783,7 @@
 	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -723,15 +795,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -740,6 +808,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -776,13 +859,10 @@
 	done
 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
 	    $(am__relativize); \
 	    new_distdir=$$reldir; \
@@ -908,22 +988,21 @@
 
 uninstall-am:
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) check-am \
-	ctags-recursive install-am install-strip tags-recursive
+.MAKE: $(am__recursive_targets) check-am install-am install-strip
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-am clean clean-checkLIBRARIES \
-	clean-generic clean-noinstLIBRARIES ctags ctags-recursive \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	installdirs-am maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
-	ps ps-am tags tags-recursive uninstall uninstall-am
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
+	check-am clean clean-checkLIBRARIES clean-generic \
+	clean-noinstLIBRARIES cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-tags distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
+	tags tags-am uninstall uninstall-am
 
 
 # used by flymake
diff -Naur orig/src/user_interface/widgets/cdw_button.c patched/src/user_interface/widgets/cdw_button.c
--- orig/src/user_interface/widgets/cdw_button.c	2012-03-03 21:09:17.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_button.c	2014-03-16 22:34:29.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -28,6 +28,12 @@
 #include <string.h>
 #include <stdlib.h>
 
+#include "main.h"
+#include "cdw_widgets.h"
+#include "cdw_ncurses.h"
+#include "cdw_config.h"
+#include "cdw_debug.h"
+#include "cdw_string.h"
 #include "cdw_button.h"
 #include "cdw_debug.h"
 
@@ -36,13 +42,14 @@
 
 
 
+
 /**
    \brief Create new CDW_BUTTON widget
 
    \date Function's top-level comment reviewed on 2012-01-09
    \date Function's body reviewed on 2012-01-09
 
-   Remember to assign value to CDW_BUTTON->on_click
+   Remember to assign value to CDW_BUTTON->on_click_callback
 
    \param parent - parent window, in which the button will be displayed
    \param begin_y - number of row of parent window, in which will be displayed upper border of button
@@ -65,6 +72,8 @@
 
 	button->strip = (WINDOW *) NULL;
 	button->label = (char *) NULL;
+	button->widget_id = CDW_WIDGET_ID_BUTTON;
+	button->on_click_key = 0;
 
 	button->label = strdup(label);
 	if (!(button->label)) {
@@ -78,25 +87,27 @@
 	button->begin_x = begin_x;
 	button->begin_y = begin_y;
 	button->colors = colors;
-	button->on_click = (cdw_form_widget_function_t) NULL;
+	button->on_click_callback = (cdw_form_widget_function_t) NULL;
 	button->parent = parent;
 
 	int label_len = (int) strlen(button->label);
 	/* "[ label ]" = 2 + len + 2 */
 	button->strip = derwin(parent, 1, 2 + label_len + 2,
 			       button->begin_y, button->begin_x);
-	if (button->strip) {
+	if (!button->strip) {
+		cdw_vdm ("ERROR: can't create new button: derwin()\n");
+		cdw_vdm ("ERROR: nlines = %d, ncols = %d, begin_y = %d, begin_x = %d\n",
+			 1, 2 + label_len + 2, button->begin_y, button->begin_x);
+
+		cdw_button_delete(&button);
+		return (CDW_BUTTON *) NULL;
+	} else {
 		(void) wattrset(button->strip, COLOR_PAIR(button->colors));
 
 		mvwprintw(button->strip, 0, 0, "[ %s ]", button->label);
 		wrefresh(button->strip);
 
 		return button;
-	} else {
-		cdw_button_delete(&button);
-		cdw_vdm ("ERROR: can't create new button: derwin\n");
-
-		return (CDW_BUTTON *) NULL;
 	}
 }
 
@@ -221,3 +232,49 @@
 
 	return;
 }
+
+
+
+
+
+int cdw_button_driver(CDW_BUTTON *b, void *form)
+{
+	cdw_assert (b, "ERROR: NULL pointer to button\n");
+	cdw_assert (b->widget_id == CDW_WIDGET_ID_BUTTON, "ERROR: this is not a button widget\n");
+	cdw_assert (b->parent, "ERROR: can't control button without parent window\n");
+
+	int key = 'a'; /* Safe initial value. */
+	while (1) {
+		key = wgetch(b->parent);
+
+		if (key == CDW_KEY_ENTER) {
+			/* On enter we can either return control, or execute a
+			   callback defined by client code. */
+			if (b->on_click_callback) {
+				cdw_vdm ("INFO: Calling \"on click callback\"\n");
+				b->on_click_callback((cdw_form_t *) form, NULL);
+			} else {
+				cdw_vdm ("INFO: Returning key %s\n", cdw_ncurses_key_label(b->on_click_key));
+				return b->on_click_key;
+			}
+		} else if (key == CDW_KEY_TAB || key == KEY_BTAB
+			   || key == KEY_DOWN || key == KEY_UP) {
+
+			/* Inter-widget movement key. Will be handled
+			   by parent of the widget. */
+			break;
+		} else if (key == CDW_KEY_ESCAPE || key == 'q' || key == 'Q') {
+
+			key = CDW_KEY_ESCAPE;
+			break;
+		} else {
+			/* Some other key that may be handled only by
+			   parent of the widget. It may happen that
+			   parent is configured to handle special keys
+			   like F2 or other keys. */
+			break;
+		}
+	}
+
+	return key;
+}
diff -Naur orig/src/user_interface/widgets/cdw_button.h patched/src/user_interface/widgets/cdw_button.h
--- orig/src/user_interface/widgets/cdw_button.h	2011-12-27 23:00:56.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_button.h	2014-02-03 20:48:51.000000000 +0100
@@ -2,6 +2,7 @@
 #define H_CDW_BUTTON
 
 #include "main.h"
+#include "cdw_widgets.h"
 #include "cdw_ncurses.h"
 
 
@@ -9,7 +10,8 @@
 	WINDOW *parent; /* parent window of the widget */
 	WINDOW *strip;  /* a private window in which the widget displays its content */
 
-	cdw_form_widget_function_t on_click; /* callback */
+	cdw_form_widget_function_t on_click_callback;
+	int on_click_key;
 
 	int begin_x;
 	int begin_y;
@@ -17,6 +19,11 @@
 	char *label;
 
 	cdw_colors_t colors;
+
+	/* The variable will be set to CDW_WIDGET_ID_BUTTON by
+	   cdw_button_new(). */
+	int widget_id;
+
 } CDW_BUTTON;
 
 
@@ -26,9 +33,7 @@
 void cdw_button_free(CDW_BUTTON *button);
 void cdw_button_focus(CDW_BUTTON *button);
 void cdw_button_unfocus(CDW_BUTTON *button);
-
+int  cdw_button_driver(CDW_BUTTON *button, void *data);
 
 
 #endif /* ifndef H_CDW_BUTTON */
-
-
diff -Naur orig/src/user_interface/widgets/cdw_checkbox.c patched/src/user_interface/widgets/cdw_checkbox.c
--- orig/src/user_interface/widgets/cdw_checkbox.c	2012-01-10 21:35:50.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_checkbox.c	2014-03-16 22:32:15.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -40,15 +40,20 @@
 
 #include "cdw_checkbox.h"
 #include "cdw_debug.h"
+#include "cdw_form.h"
 
 
-/* Definitions made so that there is no possibility of
-   using "x" and "X" in different places */
+/* Definitions made so that symbol of marked checkbox is used
+   consistently in this module. */
 #define CDW_CHECKBOX_CHECKED   "X"
 #define CDW_CHECKBOX_UNCHECKED " "
 
 
 
+
+
+
+
 /**
    \brief Create new check box
 
@@ -82,8 +87,10 @@
 	checkbox->begin_x = begin_x;
 	checkbox->checked = checked;
 
+	checkbox->widget_id = CDW_WIDGET_ID_CHECKBOX;
+
 	checkbox->visible = true;
-	checkbox->on_toggle = (cdw_form_widget_function_t) NULL;
+	checkbox->on_toggle_callback = (cdw_form_widget_function_t) NULL;
 
 	return checkbox;
 }
@@ -313,3 +320,50 @@
 
 	return;
 }
+
+
+
+
+
+int cdw_checkbox_driver(CDW_CHECKBOX *cb, void *cdw_form)
+{
+	cdw_assert (cb, "ERROR: NULL pointer to checkbox\n");
+	cdw_assert (cb->widget_id == CDW_WIDGET_ID_CHECKBOX, "ERROR: this is not a checkbox widget\n");
+	cdw_assert (cb->parent, "ERROR: cannot control checkbox with NULL parent\n");
+
+	int key = 'a'; /* Safe initial value. */
+	while (1) {
+		key = wgetch(cb->parent);
+
+		if (key == ' ' || key == 'x' || key == 'X') {
+
+			cdw_checkbox_toggle(cb);
+			if (cb->on_toggle_callback) {
+				cdw_assert (cdw_form, "ERROR: 'cdw_form' argument to callback is NULL\n");
+				bool state = cdw_checkbox_get_state(cb);
+				cb->on_toggle_callback((cdw_form_t *) cdw_form, &state);
+			}
+		} else if (key == CDW_KEY_TAB || key == KEY_BTAB
+			   || key == KEY_DOWN || key == KEY_UP) {
+
+			/* Inter-widget movement key. Will be handled
+			   by parent of the widget. */
+			break;
+		} else if (key == CDW_KEY_ESCAPE || key == 'q' || key == 'Q') {
+
+			key = CDW_KEY_ESCAPE;
+			break;
+		} else {
+			/* Some other key that may be handled only by
+			   parent of the widget. It may happen that
+			   parent is configured to handle special keys
+			   like F2 or other keys. */
+			break;
+		}
+	}
+
+	redrawwin(cb->parent);
+	wrefresh(cb->parent);
+
+	return key;
+}
diff -Naur orig/src/user_interface/widgets/cdw_checkbox.h patched/src/user_interface/widgets/cdw_checkbox.h
--- orig/src/user_interface/widgets/cdw_checkbox.h	2011-12-27 22:57:32.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_checkbox.h	2014-02-03 20:48:51.000000000 +0100
@@ -11,7 +11,11 @@
 	bool checked;    /* state of the checkbox */
 	bool visible;    /* widget may be present, but invisible to the user, and "not-visitable" */
 
-	cdw_form_widget_function_t on_toggle;   /* callback */
+	/* The variable will be set to CDW_WIDGET_ID_CHECKBOX by
+	   cdw_checkbox_new(). */
+	cdw_id_t widget_id;
+
+	cdw_form_widget_function_t on_toggle_callback;
 } CDW_CHECKBOX;
 
 
@@ -25,6 +29,6 @@
 bool cdw_checkbox_set_state(CDW_CHECKBOX *checkbox, bool checked);
 void cdw_checkbox_set_visibility(CDW_CHECKBOX *checkbox, bool visible);
 void cdw_checkbox_draw(CDW_CHECKBOX *checkbox);
-
+int  cdw_checkbox_driver(CDW_CHECKBOX *checkbox, void *cdw_form);
 
 #endif /* #ifndef H_CDW_CHECKBOX */
diff -Naur orig/src/user_interface/widgets/cdw_dialog.c patched/src/user_interface/widgets/cdw_dialog.c
--- orig/src/user_interface/widgets/cdw_dialog.c	2012-03-03 21:09:09.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_dialog.c	2014-04-06 22:34:04.000000000 +0200
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -37,6 +37,17 @@
 #include "cdw_debug.h"
 #include "cdw_window.h"
 #include "cdw_string.h"
+#include "cdw_form.h"
+#include "cdw_ncurses.h"
+
+
+/* a dialog can be either dialog with input field, or dialog with
+   buttons; in future it may be possible that the two will be
+   possible at the same time */
+enum {
+	CDW_DIALOG_BUTTONS = 1,
+	CDW_DIALOG_INPUT = 2   /* Unused at the moment. */
+};
 
 
 /* 4 buttons should be enough for everyone */
@@ -475,6 +486,7 @@
 
 	if (n_rows > LINES) {
 		cdw_vdm ("ERROR: failed to calculate satisfactory sizes of text area, text may be clipped\n");
+		cdw_vdm ("ERROR: n_rows = %d, LINES = %d\n", n_rows, LINES);
 		return CDW_ERROR;
 	} else {
 		return CDW_OK;
@@ -760,85 +772,6 @@
 
 
 /**
-   \brief Create and display dialog window with text input
-
-   \date Function's top-level comment reviewed on 2012-01-08
-   \date Function's body reviewed on 2012-01-08
-
-   Create and display dialog window with input field. Display prompt in
-   the dialog window, accept data entered in the window, return proper
-   value after user ends interaction with the dialog.
-
-   Function's argument is this big data structure which isn't most
-   sophisticated solution, but it shortens function's argument list
-   significantly :)
-
-   Data entered in the dialog is returned by data->buffer. The buffer
-   must be managed by caller code.
-
-   \param data - data structure defining dialog's appearance
-
-   \return CDW_ERROR on failure
-   \return CDW_OK if user pressed Enter in the dialog
-   \return CDW_CANCEL if user pressed Escape in the dialog
-*/
-cdw_rv_t cdw_input_dialog(cdw_input_data_t *data)
-{
-	CDW_DIALOG_BASE *dialog = cdw_dialog_base_new(CDW_DIALOG_INPUT);
-	if (!dialog) {
-		cdw_vdm ("ERROR: failed to get new dialog base\n");
-		return CDW_ERROR;
-	}
-
-	cdw_dialog_base_sizes(dialog, data->prompt_message);
-	cdw_dialog_base_display_basics(dialog, data->window_title, data->prompt_message, CDW_ALIGN_LEFT);
-
-	if (data->chars_max) {
-		if (dialog->input.n_cols > data->chars_max) {
-			/* input subwindow must be no wider than limit,
-			   otherwise setting size limit for input buffer
-			   will fail */
-			dialog->input.n_cols = data->chars_max;
-		}
-	}
-
-	int begin_x = (getmaxx(dialog->window) - dialog->input.n_cols) / 2;
-	CDW_INPUT_LINE *input_line = cdw_input_line_new(dialog->window,
-							dialog->input.begin_y, begin_x,
-							dialog->input.n_cols, *(data->buffer),
-							data->input_type, data->chars_max);
-	if (!input_line) {
-		cdw_vdm ("ERROR: failed to create input line\n");
-		return CDW_ERROR;
-	}
-
-	cdw_rv_t retval = CDW_CANCEL;
-
-	int key = cdw_input_line_driver(input_line, data->buffer, data->attempts_max);
-	if (key == CDW_KEY_ENTER || key == CDW_KEY_TAB) {
-		/* user entered correct value, do noting */
-		retval = CDW_OK;
-	} else if (key == CDW_KEY_ESCAPE) {
-		/* user cancelled entering string, do nothing */
-		retval = CDW_CANCEL;
-	} else {
-		cdw_buttons_dialog(data->window_title,
-				   data->error_message,
-				   CDW_BUTTONS_OK, CDW_COLORS_WARNING);
-		retval = CDW_ERROR;
-	}
-
-	cdw_input_line_delete(&input_line);
-	cdw_dialog_base_delete(&dialog);
-
-	return retval;
-}
-
-
-
-
-
-/**
    \brief Show dialog window with title, message and buttons
 
    \date Function's top-level comment reviewed on 2012-01-08
@@ -884,7 +817,7 @@
 
 	/* debug code */
 	/* char *message = "\n  a  \n  b  \n  c  \n  d  \n  e  \n  f  \n  g  \n  h  \n  i  \n  j  \n  k  \n  l  \n  m  \n  n  \n  o  \n  p  \n  q  \n  r  \n  s  \n  t  \n  u  \n  w"; */
-	/* char *message = "This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"; */
+	/* char *message = "This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA."; */
 
 	cdw_dialog_base_sizes(dialog, message);
 	cdw_dialog_base_display_basics(dialog, title, message, CDW_ALIGN_CENTER);
@@ -902,3 +835,376 @@
 }
 
 
+
+
+
+
+/* ***************** */
+
+
+#define CDW_INPUT_DIALOG_N_FIELDS 5
+
+typedef struct {
+	WINDOW *window;
+	WINDOW *subwindow;
+
+	/* This pointer will point to string owned by client code. */
+	const char *prompt_message;
+
+	cdw_colors_t colors;
+
+	cdw_form_t *cdw_form;
+	FIELD *fields[CDW_INPUT_DIALOG_N_FIELDS + 1];
+
+	char *buffer; /* Buffer is owned by caller. */
+	int chars_max;
+
+	int begin_x;
+	int begin_y;
+
+	int n_cols;
+	int n_rows;
+
+	int sub_begin_x;
+	int sub_begin_y;
+
+	int sub_n_cols;
+	int sub_n_rows;
+
+	int txt_n_rows; /* Height of prompt message. */
+
+} CDW_INPUT_DIALOG;
+
+
+static CDW_INPUT_DIALOG *input_dialog = (CDW_INPUT_DIALOG *) NULL;
+
+
+static cdw_rv_t cdw_input_dialog_init(CDW_INPUT_DIALOG **dialog, const char *message, int chars_max, char *buffer);
+static void     cdw_input_dialog_delete(CDW_INPUT_DIALOG **d);
+static cdw_rv_t cdw_input_dialog_build(const char *title, const char *message, int chars_max, char *buffer);
+static cdw_rv_t cdw_input_dialog_sizes(CDW_INPUT_DIALOG *dialog);
+static int      cdw_input_dialog_driver(CDW_INPUT_DIALOG *dialog);
+static char *   cdw_input_dialog_prompt_message_maker(int n_cols);
+
+
+
+
+
+/* Some layout constraints. */
+static const int first_col =  0;
+
+
+enum {
+	f_prompt_t,
+	f_input_l,
+	f_input_i,
+	f_ok_b,
+	f_cancel_b
+};
+
+
+
+
+
+cdw_rv_t cdw_input_dialog(const char *title, const char *message, int chars_max, char *buffer)
+{
+	cdw_rv_t crv = cdw_input_dialog_build(title, message, chars_max, buffer);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to init wizard\n");
+		cdw_input_dialog_delete(&input_dialog);
+		return CDW_ERROR;
+	}
+
+	int rv = cdw_input_dialog_driver(input_dialog);
+	cdw_input_dialog_delete(&input_dialog);
+
+	if (rv == CDW_KEY_ENTER) {
+		return CDW_OK;
+	} else {
+		return CDW_CANCEL;
+	}
+}
+
+
+
+
+
+cdw_rv_t cdw_input_dialog_init(CDW_INPUT_DIALOG **d, const char *message, int chars_max, char *buffer)
+{
+	*d = (CDW_INPUT_DIALOG *) malloc(sizeof (CDW_INPUT_DIALOG));
+	if (!*d) {
+		cdw_vdm ("ERROR: failed to allocate memory for input line dialog\n");
+		return CDW_ERROR;
+	}
+
+	(*d)->window = (WINDOW *) NULL;
+	(*d)->subwindow = (WINDOW *) NULL;
+
+	(*d)->prompt_message = message;
+
+	(*d)->colors = CDW_COLORS_DIALOG;
+
+	(*d)->cdw_form = (cdw_form_t *) NULL;
+
+	for (int i = 0; i < CDW_INPUT_DIALOG_N_FIELDS + 1; i++) {
+		(*d)->fields[i] = (FIELD *) NULL;
+	}
+
+	(*d)->buffer = buffer;
+	(*d)->chars_max = chars_max;
+
+	(*d)->begin_x = 0;
+	(*d)->begin_y = 0;
+
+	(*d)->n_cols = 0;
+	(*d)->n_rows = 0;
+
+	(*d)->sub_begin_x = 0;
+	(*d)->sub_begin_y = 0;
+
+	(*d)->sub_n_cols = 0;
+	(*d)->sub_n_rows = 0;
+
+	(*d)->txt_n_rows = 0; /* Height of prompt message. */
+
+	return CDW_OK;
+}
+
+
+
+
+
+void cdw_input_dialog_delete(CDW_INPUT_DIALOG **d)
+{
+	cdw_assert (d, "ERROR: passed NULL pointer to the function\n");
+	if (!*d) {
+		cdw_vdm ("WARNING: passed NULL input dialog to the function\n");
+		return;
+	}
+
+	/* This order of these four function calls minimizes number of
+	   problems reported by valgrind. */
+	cdw_form_delete_form_objects((*d)->cdw_form);
+	cdw_window_delete(&(*d)->subwindow);
+	cdw_window_delete(&(*d)->window);
+	cdw_form_delete(&((*d)->cdw_form));
+
+	free(*d);
+	*d = (CDW_INPUT_DIALOG *) NULL;
+
+	return;
+}
+
+
+
+
+
+int cdw_input_dialog_driver(CDW_INPUT_DIALOG *d)
+{
+	int fi = f_input_i; /* Initial focus on input. */
+	int key = 'a';      /* Safe initial value. */
+
+	while (key != CDW_KEY_ESCAPE && key != 'q' && key != 'Q') {
+		key = cdw_form_driver(d->cdw_form, fi);
+		fi = field_index(current_field(d->cdw_form->form));
+
+		if (key == CDW_KEY_ENTER) {
+			cdw_assert (fi == f_ok_b, "ERROR: driver returns KEY_ENTER for widget other than OK button (%d)\n", fi);
+
+			/* flush */
+			form_driver(d->cdw_form->form, REQ_VALIDATION);
+
+			/* Thanks to using safe input line, if we got
+			   this far, the string in buffer is safe. */
+			char *b = field_buffer(d->cdw_form->fields[f_input_i], 0);
+			b = cdw_string_rtrim(b);
+			strncpy(d->buffer, b, (size_t) d->chars_max);
+			d->buffer[d->chars_max] = '\0';
+
+			return CDW_KEY_ENTER;
+		} else if (key == CDW_KEY_ESCAPE) {
+			return CDW_KEY_ESCAPE;
+		} else {
+			;
+		}
+	}
+
+	return CDW_KEY_ESCAPE;
+}
+
+
+
+
+
+static cdw_form_text_maker_t text_makers[] = {
+	cdw_input_dialog_prompt_message_maker
+};
+
+
+
+
+
+char *cdw_input_dialog_prompt_message_maker(int n_cols)
+{
+	/* 2TRANS: this is a description in one of
+	   configuration window panels; a series of
+	   dropdown widgets is displayed below the label */
+	return cdw_string_wrap(input_dialog->prompt_message, (size_t) n_cols, CDW_ALIGN_LEFT);
+}
+
+
+
+
+
+cdw_rv_t cdw_input_dialog_build(const char *title, const char *message, int chars_max, char *buffer)
+{
+	cdw_rv_t crv = cdw_input_dialog_init(&input_dialog, message, chars_max, buffer);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to get new input line dialog\n");
+		return CDW_ERROR;
+	}
+
+	CDW_INPUT_DIALOG *d = input_dialog;
+
+	d->cdw_form = cdw_form_new(CDW_INPUT_DIALOG_N_FIELDS);
+	if (!d->cdw_form) {
+		cdw_vdm ("ERROR: failed to create cdw form\n");
+		return CDW_ERROR;
+	}
+
+	d->cdw_form->fields = d->fields;
+
+	cdw_input_dialog_sizes(d);
+
+	d->cdw_form->window = cdw_window_new((WINDOW *) NULL,
+					     d->n_rows, d->n_cols,
+					     d->begin_y, d->begin_x,
+					     CDW_COLORS_DIALOG,
+					     title,
+					     /* 2TRANS: this is tip at the bottom
+						of window - user can switch between
+						window elements using tab key */
+					     _("Use 'Tab' key to move"));
+
+	if (!d->cdw_form->window) {
+		cdw_vdm ("ERROR: failed to create window\n");
+		return CDW_ERROR;
+	}
+
+	d->cdw_form->subwindow = cdw_window_new(d->cdw_form->window,
+						d->sub_n_rows, d->sub_n_cols,
+						d->sub_begin_y, d->sub_begin_x,
+						CDW_COLORS_DIALOG,
+						(char *) NULL, (char *) NULL);
+
+	if (!d->cdw_form->subwindow) {
+		cdw_vdm ("ERROR: failed to create subwindow\n");
+		return CDW_ERROR;
+	}
+
+	int input_cols = 0;
+	if (d->chars_max > d->sub_n_cols) {
+		input_cols = d->sub_n_cols;
+	} else {
+		input_cols = d->chars_max;
+	}
+
+	int last_row = d->sub_n_rows - 2;
+
+	cdw_form_descr_t descr[] = {
+		/* type                            begin_y         begin_x      n_cols           n_lines         field enum    data1                        data2 */
+		{ CDW_WIDGET_ID_TEXT,              0,              first_col,   d->sub_n_cols,   d->txt_n_rows,  f_prompt_t,   text_makers,                     0 },
+
+		{ CDW_WIDGET_ID_DYNAMIC_LABEL,     last_row - 3,   first_col,   d->sub_n_cols,   1,              f_input_l,    "",                              0 },
+		{ CDW_WIDGET_ID_SAFE_INPUT_LINE,   last_row - 2,   first_col,   input_cols,      1,              f_input_i,    d->buffer,   (size_t) d->chars_max },
+
+		/* 2TRANS: button label */
+		{ CDW_WIDGET_ID_BUTTON,            last_row,       3,           1,               1,              f_ok_b,       _("OK"),         CDW_COLORS_DIALOG },
+
+		/* 2TRANS: button label */
+		{ CDW_WIDGET_ID_BUTTON,            last_row,       23,          1,               1,              f_cancel_b,   _("Cancel"),     CDW_COLORS_DIALOG },
+
+		/* guard */
+		{ -1,                              0,              0,           0,               0,              0,            (void *) NULL,                   0 }};
+
+
+	d->cdw_form->n_fields = CDW_INPUT_DIALOG_N_FIELDS;
+
+	crv = cdw_form_description_to_fields(descr, d->cdw_form);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to convert form description to form\n");
+		return CDW_ERROR;
+	}
+
+	d->cdw_form->form = cdw_ncurses_new_form(d->cdw_form->window,
+						 d->cdw_form->subwindow,
+						 d->cdw_form->fields);
+	if (!d->cdw_form->form) {
+		cdw_vdm ("ERROR: failed to create form\n");
+		return CDW_ERROR;
+	}
+
+
+	cdw_form_add_return_chars(d->cdw_form, CDW_KEY_ENTER, CDW_KEY_ESCAPE, 'q', 'Q', 0);
+
+	cdw_form_set_button_return_key(d->cdw_form, f_ok_b, CDW_KEY_ENTER);
+	cdw_form_set_button_return_key(d->cdw_form, f_cancel_b, CDW_KEY_ESCAPE);
+
+	cdw_form_bind_input_and_label(d->cdw_form, f_input_i, f_input_l);
+
+
+	/* Make sure that cdw widgets are presented properly. */
+	cdw_form_redraw_widgets(d->cdw_form);
+
+
+	wrefresh(d->cdw_form->subwindow);
+	wrefresh(d->cdw_form->window);
+
+	return CDW_OK;
+
+}
+
+
+
+
+
+static const int cdw_dialog_sub_rows_diff = 1;
+static const int cdw_dialog_sub_cols_diff = 1;
+
+
+cdw_rv_t cdw_input_dialog_sizes(CDW_INPUT_DIALOG *d)
+{
+	int cols_space = 2 * cdw_dialog_sub_cols_diff; /* Horizontal space between parent window borders and content of window. */
+	int rows_space = 2 * cdw_dialog_sub_rows_diff; /* Vertical space between parent window borders and content of window. */
+
+	d->n_cols = 50;
+	d->sub_n_cols = d->n_cols - 2 * cols_space;
+
+	d->txt_n_rows = (int) cdw_string_count_lines(d->prompt_message, (size_t) d->sub_n_cols);
+
+	d->n_rows = 2 * rows_space        /* Parent window should be larger than subwindow by X rows on top and on bottom. */
+		+ d->txt_n_rows           /* Prompt on top. */
+		+ 1                       /* Space between prompt and rest of dialog. */
+		+ 1                       /* Dynamic label for "unsafe char" message. */
+		+ 1                       /* Safe input line. */
+		+ 1                       /* Space between safe input line and buttons. */
+		+ 1                       /* Buttons row. */
+		+ 1;                      /* Space between buttons row and bottom border of parent window. */
+
+	d->sub_n_rows = d->n_rows - 2 * rows_space;
+
+	d->begin_y = ((LINES - d->n_rows) / 2) - 2;
+	d->begin_x = (COLS - d->n_cols) / 2;
+
+	d->sub_begin_y = 2 * cdw_dialog_sub_rows_diff;
+	d->sub_begin_x = 2 * cdw_dialog_sub_cols_diff;
+
+	cdw_vdm ("INFO: input dialog base sizes:\n");
+	cdw_vdm ("INFO:     n_cols = %d\n", d->n_cols);
+	cdw_vdm ("INFO:     n_rows = %d\n", d->n_rows);
+	cdw_vdm ("INFO: sub n_cols = %d\n", d->sub_n_cols);
+	cdw_vdm ("INFO: sub n_rows = %d\n", d->sub_n_rows);
+	cdw_vdm ("INFO: txt n_rows = %d\n", d->txt_n_rows);
+
+	return CDW_OK;
+}
diff -Naur orig/src/user_interface/widgets/cdw_dialog.h patched/src/user_interface/widgets/cdw_dialog.h
--- orig/src/user_interface/widgets/cdw_dialog.h	2012-01-08 11:45:44.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_dialog.h	2014-03-16 22:22:02.000000000 +0100
@@ -6,14 +6,6 @@
 #include "cdw_widgets.h"
 
 
-/* a dialog can be either dialog with input field, or dialog with
-   buttons; in future it may be possible that the two will be
-   possible at the same time */
-enum {
-	CDW_DIALOG_BUTTONS = 1,
-	CDW_DIALOG_INPUT = 2
-};
-
 
 /* number and type of buttons in dialog with buttons */
 enum {
@@ -23,25 +15,7 @@
 };
 
 
-
-typedef struct {
-
-	const char *window_title;    /* title of input window and error dialog windows */
-	const char *prompt_message;  /* message in input window */
-	char *error_message;         /* error message displayed in separate dialog at the end in case of failure */
-
-	int attempts_max;            /* how many times should the widget ask for correct (i.e. without unsafe chars) string? */
-
-	int input_type;              /* CDW_NCURSES_INPUT_{NONE | HIDDEN | INTEGER | NUMERIC } */
-
-	int chars_max;               /* maximal allowed length of entered string, zero for no limit */
-	char **buffer;               /* pointer to data buffer, the buffer must be provided by code using input dialog */
-
-} cdw_input_data_t;
-
-
 cdw_rv_t cdw_buttons_dialog(const char *title, const char *message, int button_types, cdw_colors_t colors);
-cdw_rv_t cdw_input_dialog(cdw_input_data_t *data);
-
+cdw_rv_t cdw_input_dialog(const char *title, const char *message, int chars_max, char *buffer);
 
 #endif /* #ifndef CDW_DIALOG_BASE */
diff -Naur orig/src/user_interface/widgets/cdw_dropdown.c patched/src/user_interface/widgets/cdw_dropdown.c
--- orig/src/user_interface/widgets/cdw_dropdown.c	2012-03-03 21:09:22.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_dropdown.c	2014-03-24 22:23:35.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -33,6 +33,7 @@
 #include "cdw_dropdown.h"
 #include "gettext.h"
 #include "cdw_debug.h"
+#include "cdw_widgets.h"
 
 
 static int      cdw_dropdown_expanded_driver(CDW_DROPDOWN *dropdown);
@@ -43,7 +44,6 @@
 
 
 
-
 /**
    \brief Create basis for new dropdown
 
@@ -83,6 +83,10 @@
 	dropdown->n_items_max = n_items_max;
 	dropdown->n_items = 0;
 
+	dropdown->current_item_ind = 0; /* There will be at least one item in the dropdown, so index=0 should be safe. */
+
+	dropdown->widget_id = CDW_WIDGET_ID_DROPDOWN;
+
 	dropdown->items = (cdw_id_label_t **) malloc((size_t) (dropdown->n_items_max + 1) * sizeof (cdw_id_label_t *));
 
 	if (!dropdown->items) {
@@ -102,6 +106,8 @@
 	dropdown->width = width;
 	dropdown->colors = colors;
 
+	dropdown->on_select_callback = (cdw_form_widget_function_t) NULL;
+
 	dropdown->visible = true;
 
 	return dropdown;
@@ -373,34 +379,73 @@
 /**
    \brief Control keyboard input when focus is on dropdown - top level function
 
+   This driver should be used only as (dropdown variable)->driver().
+
    \date Function's top-level comment reviewed on 2012-01-07
    \date Function's body reviewed on 2012-01-07
 
-   This function calls cdw_dropdown_expanded_driver() to control
-   keyboard input in expanded \p dropdown.
+   This function controls keyboard input while a \p dropdown has
+   keyboard focus.
+
+   Since this function will be used in some kind of dispatcher calling
+   drivers for widgets of different types, we need to pass \p dropdown
+   as void pointer.
 
-   \param dropdown - dropdown that has focus
+   \param dd - dropdown that has focus
+   \param dummy - pointer to additional data; currently unused
 
    \return CDW_KEY_ENTER if user pressed ENTER in expanded dropdown
    \return CDW_KEY_ESCAPE if user pressed ESCAPE, Q or q in expanded dropdown
+   \return if any other key has been pressed the function returns the key
 */
-int cdw_dropdown_driver(CDW_DROPDOWN *dropdown)
+int cdw_dropdown_driver(CDW_DROPDOWN *dd, __attribute__((unused)) void *dummy)
 {
-	cdw_assert (dropdown, "ERROR: cannot control NULL dropdown\n");
-	cdw_assert (dropdown->parent, "ERROR: cannot control dropdown with NULL parent\n");
+	cdw_assert (dd, "ERROR: NULL pointer to dropdown\n");
+	cdw_assert (dd->widget_id == CDW_WIDGET_ID_DROPDOWN, "ERROR: this is not a dropdown widget\n");
+	cdw_assert (dd->parent, "ERROR: cannot control dropdown with NULL parent\n");
+
+	int key = 'a'; /* Safe initial value. */
+
+	while (1) {
+		key = wgetch(dd->parent);
+
+		if (key == CDW_KEY_ENTER) {
+			cdw_dropdown_expand(dd);
+			int expanded_key = cdw_dropdown_expanded_driver(dd);
+			cdw_dropdown_collapse(dd);
+
+			if (expanded_key == CDW_KEY_ENTER) {
+				/* when dropdown is closed (hidden), it should remain
+				   highlighted, so second parameter is true */
+				cdw_dropdown_display_current_item_reverse(dd, true);
+
+				/* Call callback function, let it know which item (by
+				   ID) has been selected. */
+				if (dd->on_select_callback) {
+					dd->on_select_callback(NULL, &(dd->items[dd->current_item_ind]->id));
+				}
+			}
+		} else if (key == CDW_KEY_TAB || key == KEY_BTAB
+			   || key == KEY_DOWN || key == KEY_UP) {
 
-	cdw_dropdown_expand(dropdown);
-	int key = cdw_dropdown_expanded_driver(dropdown);
-	cdw_dropdown_collapse(dropdown);
-
-	if (key == CDW_KEY_ENTER) {
-		/* when dropdown is closed (hidden), it should remain
-		   highlighted, so second parameter is true */
-		cdw_dropdown_display_current_item_reverse(dropdown, true);
+			/* Inter-widget movement key. Will be handled
+			   by parent of the widget. */
+			break;
+		} else if (key == CDW_KEY_ESCAPE || key == 'q' || key == 'Q') {
+
+			key = CDW_KEY_ESCAPE;
+			break;
+		} else {
+			/* Some other key that may be handled only by
+			   parent of the widget. It may happen that
+			   parent is configured to handle special keys
+			   like F2 or other keys. */
+			break;
+		}
 	}
 
-	redrawwin(dropdown->parent);
-	wrefresh(dropdown->parent);
+	redrawwin(dd->parent);
+	wrefresh(dd->parent);
 
 	return key;
 }
@@ -953,6 +998,8 @@
 		return (CDW_DROPDOWN *) NULL;
 	}
 
+	dropdown->on_select_callback = (cdw_form_widget_function_t) NULL;
+
 	for (int i = 0; i < n_items; i++) {
 		cdw_rv_t crv = cdw_dropdown_add_item(dropdown, items[i].id, _(items[i].label));
 		if (crv != CDW_OK) {
@@ -971,4 +1018,3 @@
 	}
 	return dropdown;
 }
-
diff -Naur orig/src/user_interface/widgets/cdw_dropdown.h patched/src/user_interface/widgets/cdw_dropdown.h
--- orig/src/user_interface/widgets/cdw_dropdown.h	2011-12-30 22:08:10.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_dropdown.h	2014-03-13 22:17:39.000000000 +0100
@@ -30,6 +30,9 @@
 	bool visible;            /* is widget visible and visitable? */
 	cdw_id_label_t **items;  /* the content of the widget */
 
+	/* The variable will be set to CDW_WIDGET_ID_DROPDOWN by
+	   cdw_dropdown_new(). */
+	int widget_id;
 
 	/* internal details of implementation */
 	MENU   *menu;
@@ -37,6 +40,8 @@
 	WINDOW *menu_window;
 	WINDOW *menu_window_sub;
 
+	cdw_form_widget_function_t on_select_callback;
+
 } CDW_DROPDOWN;
 
 
@@ -49,7 +54,7 @@
 cdw_rv_t      cdw_dropdown_finalize(CDW_DROPDOWN *dropdown);
 cdw_rv_t      cdw_dropdown_delete(CDW_DROPDOWN **dropdown);
 void          cdw_dropdown_free(CDW_DROPDOWN *dropdown);
-int           cdw_dropdown_driver(CDW_DROPDOWN *dropdown);
+int           cdw_dropdown_driver(CDW_DROPDOWN *dropdown, void *dummy);
 void          cdw_dropdown_display_current_item(CDW_DROPDOWN *dropdown);
 
 void cdw_dropdown_focus(CDW_DROPDOWN *dropdown);
@@ -69,5 +74,3 @@
 
 
 #endif /* #ifndef H_CDW_DROPDOWN */
-
-
diff -Naur orig/src/user_interface/widgets/cdw_dynamic_label.c patched/src/user_interface/widgets/cdw_dynamic_label.c
--- orig/src/user_interface/widgets/cdw_dynamic_label.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_dynamic_label.c	2014-04-06 22:32:07.000000000 +0200
@@ -0,0 +1,186 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <unistd.h> /* sleep() */
+#include <stdlib.h>
+#include <string.h>
+
+#include "cdw_dynamic_label.h"
+#include "cdw_string.h"
+#include "cdw_debug.h"
+#include "cdw_widgets.h"
+
+
+
+
+
+/**
+   \brief Create new dynamic label widget
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   \param parent - parent window
+   \param field - ncurses field in parent form
+   \param n_cols - width of the label
+   \param content - initial contents of the label
+
+   \return new widget on success
+   \return NULL on errors
+*/
+CDW_DYNAMIC_LABEL *cdw_dynamic_label_new(WINDOW *parent, FIELD *field, int n_cols, const char *content)
+{
+	cdw_assert (parent, "ERROR: parent window can't be NULL\n");
+	cdw_assert (content, "ERROR: initial content of the label can't be NULL\n");
+
+	CDW_DYNAMIC_LABEL *label = (CDW_DYNAMIC_LABEL *) malloc(sizeof (CDW_DYNAMIC_LABEL));
+	if (!label) {
+		cdw_vdm ("ERROR: failed to malloc label widget\n");
+		return (CDW_DYNAMIC_LABEL *) NULL;
+	}
+
+	label->content = strdup(content);
+	if (!(label->content)) {
+		cdw_vdm ("ERROR: failed to malloc content string\n");
+		free(label);
+		label = (CDW_DYNAMIC_LABEL *) NULL;
+		return (CDW_DYNAMIC_LABEL *) NULL;
+	}
+
+	label->parent = parent;
+	label->field = field;
+	label->n_cols = n_cols;
+
+	label->widget_id = CDW_WIDGET_ID_DYNAMIC_LABEL;
+
+	int rv = set_field_buffer(label->field, 0, label->content);
+	if (rv == E_OK) {
+		return label;
+	} else {
+		cdw_dynamic_label_delete(&label);
+		return (CDW_DYNAMIC_LABEL *) NULL;
+	}
+}
+
+
+
+
+
+/**
+   \brief Delete widget
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Deallocate all memory associated with the widget. Set \p label to
+   NULL.
+
+   \param label - pointer to widget to delete
+*/
+void cdw_dynamic_label_delete(CDW_DYNAMIC_LABEL **label)
+{
+	cdw_assert (label, "ERROR: passing to the function a NULL pointer to a widget\n");
+
+	if (!*label) {
+		cdw_vdm ("WARNING: passing NULL label to the function\n");
+		return;
+	}
+
+	if ((*label)->content) {
+		free((*label)->content);
+		(*label)->content = (char *) NULL;
+	}
+
+	free(*label);
+	*label = (CDW_DYNAMIC_LABEL *) NULL;
+	return;
+}
+
+
+
+
+
+/**
+   \brief Set new contents of a dynamic label widget
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   \param label - dynamic label widget
+   \param content - new content of dynamic label widget
+
+   \return CDW_OK on success
+   \return CDW_ERROR on failure
+*/
+cdw_rv_t cdw_dynamic_label_set_new(CDW_DYNAMIC_LABEL *label, const char *content)
+{
+	cdw_assert (content, "ERROR: can't set new NULL content\n");
+
+	cdw_rv_t crv = cdw_string_set(&(label->content), content);
+	if (crv == CDW_OK) {
+		int rv = set_field_buffer(label->field, 0, label->content);
+		if (rv == E_OK) {
+			return CDW_OK;
+		}
+	}
+
+	return CDW_ERROR;
+}
+
+
+
+
+/**
+   \brief Set new, temporary contents of dynamic label widget
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Display string from \p temporary_content for \p seconds seconds
+   using \p colors color scheme. After \p seconds seconds display
+   again the original contents of the label using the original colors
+   scheme.
+
+   \param label - dynamic label widget
+   \param temporary_content - temporary content to be set
+   \param seconds - period of time in which to display the temporary contents
+   \param colors - fore/background colors scheme to use for displaying the temporary contents
+
+   \return CDW_OK
+*/
+cdw_rv_t cdw_dynamic_label_set_new_temporary(CDW_DYNAMIC_LABEL *label, const char *temporary_content, unsigned int seconds, cdw_colors_t colors)
+{
+	cdw_assert (temporary_content, "ERROR: can't set new NULL content\n");
+
+	/* Display the temporary content... */
+	set_field_fore(label->field, COLOR_PAIR(colors));
+	set_field_buffer(label->field, 0, temporary_content);
+	wrefresh(label->parent);
+
+	/* ... but only for X seconds.  During this time input from
+	   user is blocked. */
+	sleep(seconds);
+
+	/* Restore original string with regular colors. */
+	set_field_fore(label->field, COLOR_PAIR(CDW_COLORS_DIALOG));
+	set_field_buffer(label->field, 0, label->content);
+	wrefresh(label->parent);
+
+	return CDW_OK;
+}
diff -Naur orig/src/user_interface/widgets/cdw_dynamic_label.h patched/src/user_interface/widgets/cdw_dynamic_label.h
--- orig/src/user_interface/widgets/cdw_dynamic_label.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_dynamic_label.h	2014-04-06 22:32:38.000000000 +0200
@@ -0,0 +1,27 @@
+#ifndef H_CDW_DYNAMIC_LABEL
+#define H_CDW_DYNAMIC_LABEL
+
+#include "main.h"
+#include "cdw_ncurses.h"
+
+
+typedef struct {
+	WINDOW *parent;  /* parent window of the widget */
+
+	char *content;
+	FIELD *field;
+	int n_cols;
+
+	/* For consistency with other widget types that have driver function. */
+	int widget_id;
+
+} CDW_DYNAMIC_LABEL;
+
+
+
+CDW_DYNAMIC_LABEL *cdw_dynamic_label_new(WINDOW *parent, FIELD *field, int n_cols, const char *content);
+void     cdw_dynamic_label_delete(CDW_DYNAMIC_LABEL **label);
+cdw_rv_t cdw_dynamic_label_set_new(CDW_DYNAMIC_LABEL *label, const char *content);
+cdw_rv_t cdw_dynamic_label_set_new_temporary(CDW_DYNAMIC_LABEL *label, const char *temporary_content, unsigned int seconds, cdw_colors_t colors);
+
+#endif /* #ifndef H_CDW_DYNAMIC_LABEL */
diff -Naur orig/src/user_interface/widgets/cdw_input_line.c patched/src/user_interface/widgets/cdw_input_line.c
--- orig/src/user_interface/widgets/cdw_input_line.c	2012-01-10 21:31:29.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_input_line.c	2014-03-22 18:09:40.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -38,6 +38,7 @@
 #include "gettext.h"
 #include "cdw_string.h"
 #include "cdw_debug.h"
+#include "cdw_window.h"
 
 
 
@@ -192,27 +193,31 @@
 		return;
 	}
 
-	/* IMPORTANT: for some reason you have first free fields
-	   and then unpost and free form */
-	if ((*input_line)->field[0]) {
-		free_field((*input_line)->field[0]);
-		unpost_form((*input_line)->form);
-		(*input_line)->field[0] = (FIELD *) NULL;
-	}
+	/* From ncurses docs: "The functions free_field() and
+	   free_form are available to free field and form objects.  It
+	   is an error to attempt to free a field connected to a form,
+	   but not vice-versa; thus, you will generally free your form
+	   objects first.".
 
+	   So first unpost form, then free form, then free field. */
 	if ((*input_line)->form) {
-		int e = free_form((*input_line)->form);
+		int rv = unpost_form((*input_line)->form);
+		cdw_vdm_n ("unpost_form", rv, "");
+
+		rv = free_form((*input_line)->form);
+		cdw_vdm_n ("free_form", rv, "");
+
 		(*input_line)->form = (FORM *) NULL;
-		if (e != E_OK) {
-			cdw_vdm ("ERROR: free_form() returns \"%s\"\n", cdw_ncurses_error_string(e));
-		}
 	}
 
-	if ((*input_line)->win) {
-		delwin(((*input_line)->win));
-		(*input_line)->win = (WINDOW *) NULL;
+	if ((*input_line)->field[0]) {
+		int rv = free_field((*input_line)->field[0]);
+		cdw_vdm_n ("free_field", rv, "");
+		(*input_line)->field[0] = (FIELD *) NULL;
 	}
 
+	cdw_window_delete(&(*input_line)->win);
+
 	free(*input_line);
 	*input_line = (CDW_INPUT_LINE *) NULL;
 
@@ -585,11 +590,13 @@
 		cdw_vdm ("INFO: \"%s\" is secure\n", local_buffer);
 		crv = cdw_string_set(output_buffer, local_buffer);
 		cdw_assert (crv == CDW_OK, "ERROR: failed to save final string \"%s\"\n", local_buffer);
+		cdw_string_delete(&local_buffer);
 		/* key = key */
 		return CDW_OK;
 	} else {
 		cdw_vdm ("ERROR: insecure char in \"%s\"\n", local_buffer);
 		cdw_input_line_driver_message(input_line, insecure);
+		cdw_string_delete(&local_buffer);
 		return CDW_ERROR;
 	}
 }
diff -Naur orig/src/user_interface/widgets/cdw_safe_input_line.c patched/src/user_interface/widgets/cdw_safe_input_line.c
--- orig/src/user_interface/widgets/cdw_safe_input_line.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_safe_input_line.c	2014-04-06 22:30:40.000000000 +0200
@@ -0,0 +1,675 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+
+/**
+   \file cdw_safe_input_line.c
+
+   Widget that allows entering text into single line input field.
+
+   The widget doesn't accept string with insecure characters, as
+   defined in cdw_string.h -> CDW_STRING_UNSAFE_CHARS_STRING.
+
+   Insecure characters are reported through error message displayed in
+   dynamic label. The dynamic label widget must be associated by
+   client code with the safe input line widget using
+   cdw_safe_input_line_bind_message_area().
+
+   Text entered into the input line is not stored in this widget. It
+   is stored in ncurses form field associated with this widget (the
+   'field' argument to _new() function).
+
+   The widget provides _driver() function that should be used to
+   control user's keyboard actions when keyboard focus is on the
+   widget.
+*/
+
+
+
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h> /* isprint() */
+
+#include "cdw_safe_input_line.h"
+#include "cdw_widgets.h"
+#include "gettext.h"
+#include "cdw_string.h"
+#include "cdw_debug.h"
+
+
+
+static void     cdw_safe_input_line_print_message(CDW_SAFE_INPUT_LINE *line, char *insecure);
+static void     cdw_safe_input_line_prepare_message(char *message, int len_max, char *insecure);
+static int      cdw_safe_input_line_form_driver(CDW_SAFE_INPUT_LINE *line);
+static cdw_rv_t cdw_safe_input_line_test_content_security(CDW_SAFE_INPUT_LINE *line, char *insecure);
+
+
+
+/**
+   \brief Create new safe input line widget
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Create widget that consists of a single line input field.
+
+   The input field has width \p n_cols, and is placed in \p
+   parent. The \p parent is a subwindow used in
+   set_form_sub(form, subwindow) call.
+
+   Exact position of the widget is specified by ncurses FIELD \p
+   field. The \p field must be created by caller before calling the
+   function. The \p field is owned by the caller. This widget may
+   alter text string stored by the \p field, but it won't attempt to
+   destroy/deallocate the \p field.
+
+   In addition to \p field, the widget also uses ncurses FORM \p form.
+   \p form needs to be a pointer to pointer because in some cases a
+   ncurses form is not created yet at time of calling this function.
+
+   The field may be pre-filled with \p initial_content.  You may put a
+   restriction on number of characters that can be entered into the
+   field by setting \p chars_max to value > 0.
+
+   Input behavior may be tuned by \p input_type:
+   none/hidden/integer/numeric, see cdw_ncurses.h for specifics.
+
+   \param parent - window in which to display the widget
+   \param form - ncurses form, to which \p fields will belong to
+   \param field - ncurses field
+   \param n_cols - width of the input line
+   \param initial_content - initial data displayed in input line
+   \param input_type - type of input
+   \param chars_max - limit on number of chars that can be entered by user
+
+   \return NULL pointer on errors
+   \return pointer to new widget on success
+*/
+CDW_SAFE_INPUT_LINE *cdw_safe_input_line_new(WINDOW *parent, FORM **form, FIELD *field, int n_cols, const char *initial_content, int input_type, int chars_max)
+{
+	CDW_SAFE_INPUT_LINE *line = (CDW_SAFE_INPUT_LINE *) malloc(sizeof(CDW_SAFE_INPUT_LINE));
+	if (!line) {
+		cdw_vdm ("ERROR: failed to allocate memory for safe input line widget\n");
+		return (CDW_SAFE_INPUT_LINE *) NULL;
+	}
+
+	line->parent = parent;
+	line->form = form;
+	line->field = field;
+	line->n_cols = n_cols;
+
+	if (initial_content) {
+		int rv = set_field_buffer(line->field, 0, initial_content);
+		if (rv != E_OK) {
+			cdw_vdm ("ERROR: failed to set field buffer with string \"%s\": %s\n",
+				 initial_content, cdw_ncurses_error_string(rv));
+
+			cdw_safe_input_line_delete(&line);
+			return (CDW_SAFE_INPUT_LINE *) NULL;
+		}
+	} else {
+		cdw_vdm ("WARNING: NULL initial content\n");
+		/* TODO: shouldn't we call set_field_buffer(line->field, 0, "") ? */
+	}
+
+	line->input_type = input_type;
+	line->chars_max = chars_max;
+
+	line->widget_id = CDW_WIDGET_ID_SAFE_INPUT_LINE;
+	line->attempts_max = CDW_SAFE_INPUT_LINE_ATTEMPTS_MAX;
+
+	line->message_area = (CDW_DYNAMIC_LABEL *) NULL;
+
+	wrefresh(line->parent);
+	return line;
+}
+
+
+
+
+
+/**
+   \brief Delete a safe input line widget
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Deallocate all memory associated with \p line, free the \p line
+   itself, set the widget to NULL.
+
+   Notice that the function does not touch ncurses field that has been
+   passed to cdw_safe_input_line_new(), nor the string that is stored
+   in the field. The field is owned by the caller.
+
+   \param line - pointer to safe input line widget
+*/
+void cdw_safe_input_line_delete(CDW_SAFE_INPUT_LINE **line)
+{
+	cdw_assert (line, "ERROR: passing NULL pointer to the function\n");
+
+	if (!(*line)) {
+		cdw_vdm ("WARNING: passed NULL widget to the function\n");
+		return;
+	}
+
+	free(*line);
+	*line = (CDW_SAFE_INPUT_LINE *) NULL;
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Assign dynamic label widget to given safe input line widget
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Safe input line widget needs a dynamic label widget to display
+   error message. There needs to be a way to bind the two widgets
+   together. This function does the binding.
+
+   \param line - safe input line widget
+   \param label - dynamic label widget
+*/
+void cdw_safe_input_line_bind_message_area(CDW_SAFE_INPUT_LINE *line, CDW_DYNAMIC_LABEL *label)
+{
+	cdw_assert (label, "ERROR: dynamic label for message area is NULL\n");
+
+	line->message_area = label;
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Top-level driver for input line widget
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Driver for input line widget - it handles keyboard input when
+   keyboard focus is on the widget.
+
+   Enter key is not treated as a special key - it is *not* treated as
+   "I'm telling you to accept this input" command from user.
+
+   Upon detecting TAB, BackTAB, Down or Up key the function checks the
+   string entered by user for insecure characters, and if there are
+   any, displays an error message. Up to
+   CDW_SAFE_INPUT_LINE_ATTEMPTS_MAX attempts to enter a valid string
+   are allowed.
+
+   \param line - widget to be controlled
+   \param dummy - unused parameter
+
+   \return CDW_KEY_TAB, KEY_BTAB, KEY_DOWN or KEY_UP if user pressed any of those keys
+   \return CDW_KEY_ESCAPE if user pressed Escape key
+   \return KEY_EXIT on errors
+*/
+int cdw_safe_input_line_driver(CDW_SAFE_INPUT_LINE *line, __attribute__((unused)) void *dummy)
+{
+	cdw_assert (line, "ERROR: NULL pointer to safe input line\n");
+	cdw_assert (line->widget_id == CDW_WIDGET_ID_SAFE_INPUT_LINE, "ERROR: this is not a safe input line widget\n");
+	cdw_assert (line->parent, "ERROR: can't control safe input line without parent window\n");
+
+	int key = 'a'; /* Safe initial value. */
+
+	for (int i = 0; i < line->attempts_max; i++) {
+
+		curs_set(1);
+		key = cdw_safe_input_line_form_driver(line);
+		curs_set(0);
+
+		if (key == CDW_KEY_TAB || key == KEY_BTAB
+		    || key == KEY_DOWN || key == KEY_UP) {
+
+			/* Don't allow leaving the field when there is
+			   unsafe input in it. */
+
+			char insecure[2];
+			cdw_rv_t crv = cdw_safe_input_line_test_content_security(line, insecure);
+			if (crv == CDW_OK) {
+				/* String is secure, keyboard focus is
+				   allowed to leave the widget. */
+				break;
+			} else if (crv == CDW_ERROR) {
+				/* Internal error. */
+				key = KEY_EXIT;
+				break;
+			} else { /* crv == CDW_NO, string is not secure. */
+				cdw_safe_input_line_print_message(line, insecure);
+				if (i == line->attempts_max - 1) {
+					/* Too many attempts to enter
+					   correct string. */
+					key = CDW_KEY_ESCAPE;
+					break;
+				} else {
+					/* Allow user to fix the
+					   insecure string. */
+				}
+			}
+		} else if (key == KEY_EXIT) {
+			/* Invalid form content. */
+			cdw_vdm ("ERROR: failed to get field buffer\n");
+			key = KEY_EXIT;
+			break;
+		} else if (key == CDW_KEY_ESCAPE) {
+			break;
+		} else {
+			/* May be a control key - to be investigated
+			   by parent. */
+			break;
+		}
+	}
+
+	return key;
+}
+
+
+
+
+
+/**
+   \brief Print (in line's message field) message about insecure character
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   If user enters insecure character into safe input line, the widget
+   won't accept entered string. The widget has to inform user why
+   string hasn't been accepted, and it does it by printing "insecure
+   character X" message in a dynamic label (message area) associated
+   with the \p line.
+
+   The message should contain information about the insecure character
+   - pass it using a regular string \p insecure of length=1,
+   terminated with NUL.
+
+   \param line - safe input line widget
+   \param insecure - string representing insecure character
+*/
+void cdw_safe_input_line_print_message(CDW_SAFE_INPUT_LINE *line, char *insecure)
+{
+	cdw_assert (line->message_area, "ERROR: message area is NULL\n");
+
+	/* Error message can't be longer than width of associated
+	   message area. */
+	int len_max = line->message_area->n_cols;
+	char *message = (char *) malloc((size_t) len_max + 1);
+	if (!message) {
+		cdw_vdm ("ERROR: failed to malloc() message buffer\n");
+		return;
+	}
+
+	/* Produce error message that is as verbose as possible, but
+	   no longer than len_max characters. */
+	cdw_safe_input_line_prepare_message(message, len_max, insecure);
+
+	/* At this point we have in "message" one of three possible
+	   message string without truncation, or - as worst case
+	   scenario - last of the message strings (the shortest one)
+	   with truncation. */
+
+	cdw_dynamic_label_set_new_temporary(line->message_area, message,
+					    CDW_SAFE_INPUT_LINE_ERROR_MESSAGE_TIME,
+					    CDW_COLORS_WARNING);
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Prepare error message about insecure character
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Since the length of message area may be less than sufficient for
+   fully verbose error message, let's have N variants of error message
+   with the same meaning, but decreasing lengths.  Let's also hope
+   that at least one of them will be no longer than width of message
+   area.
+
+   This function tries up to 3 times to produce an error message with
+   decreasing length.
+
+   Message is returned through \p message. It will contain an insecure
+   character \p insecure (unless the message will be truncated so much
+   that the character won't fit into the message).
+
+   \param message - buffer to fill with error message
+   \param len_max - maximal length of message to be produced
+   \param insecure - string with insecure character to be included in the message
+*/
+void cdw_safe_input_line_prepare_message(char *message, int len_max, char *insecure)
+{
+	/* +1 for ending '\0'.*/
+	/* 2TRANS: this is error message in dialog window, "%s" is
+	   string with single insecure character; keep short */
+	int n = snprintf(message, (size_t) len_max + 1, _("ERROR: insecure char %s "), insecure);
+	if (n < 0) {
+		cdw_vdm ("ERROR: snprintf() returns negative value for string #1\n");
+	} else if (n >= 0 && n <= len_max) {
+		/* snprintf() printed at most len_max chars (excluding
+		   ending '\0'); message #1 was short enough, accept
+		   it */
+		return;
+	} else {
+		; /* Pass. Try creating shorter message. */
+	}
+
+
+	/* Second attempt, with shorter message. */
+
+
+	/* +1 for ending '\0'.*/
+	/* 2TRANS: this is error message in dialog window, "%s" is
+	   string with single insecure character; keep short */
+	n = snprintf(message, (size_t) len_max + 1, _("Insecure char %s "), insecure);
+	if (n < 0) {
+		cdw_vdm ("ERROR: snprintf() returns negative value for string #2\n");
+	} else if (n >= 0 && n <= len_max) {
+		/* snprintf() printed at most len_max chars (excluding
+		   ending '\0'); message #2 was short enough, accept
+		   it */
+		return;
+	} else {
+		; /* Pass. Try creating shorter message. */
+	}
+
+
+	/* Third attempt with even shorter message. */
+
+
+	/* +1 for ending '\0'. */
+	/* 2TRANS: this is error message in dialog window,
+	   "%s" is string with single insecure character; keep
+	   short */
+	n = snprintf(message, (size_t) len_max + 1, _("Insec. char %s"), insecure);
+	if (n < 0) {
+		cdw_vdm ("ERROR: snprintf() returns negative value for string #3\n");
+	} else if (n >= 0 && n <= len_max) {
+		/* snprintf() printed at most len_max chars
+		   (excluding ending '\0'); message #3 was
+		   short enough, accept it */
+		return;
+	} else {
+		/* Unfortunately the error message will be truncated. */
+		cdw_vdm ("ERROR: snprintf() truncates message; limit of printable chars = %d, will print %d chars\n",
+			 len_max, n);
+		cdw_vdm ("ERROR: printed string:            \"%s\"\n", message);
+	}
+
+	return;
+}
+
+
+
+
+
+/**
+   \brief Put a new string into safe input line
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   You can pass initial string to widget's constructor, but it is sometimes
+   also necessary to update the widget with a string after the widget has
+   been created. The function does just that - enters new content into
+   given safe input line.
+
+   As said elsewhere, the string is not stored directly in the widget,
+   but in ncursed FIELD field. Both string and field are owned by
+   client code.
+
+   \param line - widget to update
+   \param content - string to put into input line
+
+   \return CDW_OK on success
+   \return CDW_ERROR on failure
+*/
+cdw_rv_t cdw_safe_input_line_set_content(CDW_SAFE_INPUT_LINE *line, const char *content)
+{
+	cdw_assert (content, "ERROR: string passed to function is NULL\n");
+
+	int rv = set_field_buffer(line->field, 0, content);
+
+#ifndef NDEBUG
+	cdw_assert (rv == E_OK, "ERROR: failed to set buffer of input line, error = %s\n", cdw_ncurses_error_string(rv));
+	char *buffer_string = cdw_string_rtrim(field_buffer(line->field, 0));
+	cdw_assert (!strcmp(buffer_string, content),
+		    "ERROR: buffer string and input string are different:\nbuffer string: \"%s\"\ninput string: \"%s\"\n",
+		    buffer_string, content);
+#endif
+
+	wrefresh(line->parent);
+
+	if (rv == E_OK) {
+		return CDW_OK;
+	} else {
+		return CDW_ERROR;
+	}
+}
+
+
+
+
+
+/**
+   \brief Low-level input line driver
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Low level driver used by cdw_safe_input_line_driver(). It deals
+   directly with ncurses form/field that is the heart of the safe
+   input line widget.
+
+   Function returns when user presses TAB, BackTAB, Up, Down or
+   Escape.  The function does not return when user presses ENTER.
+
+   Returned key should be interpreted by caller, and content of the
+   widget should be extracted from widget and used as caller wants it.
+   The widget does not try to actively pass its content to the caller.
+
+   \param line - widget to be controlled
+
+   \return CDW_KEY_ESCAPE if user pressed ESCAPE key.
+   \return CDW_KEY_TAB, KEY_BTAB, KEY_DOWN or KEY_UP if user pressed any of those keys
+   \return KEY_EXIT on errors
+*/
+int cdw_safe_input_line_form_driver(CDW_SAFE_INPUT_LINE *line)
+{
+	bool loop = true; /* Flag controlling outer do/while loop. */
+	int key = 0;
+
+	do {
+		int rv = E_OK;
+		key = wgetch(line->parent);
+		switch (key) {
+			case KEY_LEFT:
+				rv = form_driver(*(line->form), REQ_PREV_CHAR);
+				break;
+			case KEY_RIGHT:
+				rv = form_driver(*(line->form), REQ_NEXT_CHAR);
+				break;
+			case KEY_BACKSPACE:
+				rv = form_driver(*(line->form), REQ_DEL_PREV);
+				break;
+			case KEY_DC:
+				rv = form_driver(*(line->form), REQ_DEL_CHAR);
+				break;
+		        case KEY_HOME:
+				rv = form_driver(*(line->form), REQ_BEG_LINE);
+				break;
+		        case KEY_END:
+				rv = form_driver(*(line->form), REQ_END_LINE);
+				break;
+		        case CDW_KEY_ENTER:
+				/* Ignore the key. The only way to
+				   leave the field is by
+				   TAB/BackTAB/Down/Up/ESCAPE. The
+				   Enter key does not mean "OK, now
+				   close the window that uses this
+				   input line". */
+				break;
+			case CDW_KEY_ESCAPE:
+		        case CDW_KEY_TAB:
+		        case KEY_BTAB:
+		        case KEY_UP:
+		        case KEY_DOWN:
+				/* These keys are the only way to
+				   correctly make the keyboard focus
+				   move outside of the widget. */
+				loop = false;
+				break;
+			default:
+				if (isprint(key)) {
+					/* Push user input to form. */
+					rv = form_driver(*(line->form), key);
+					wrefresh(line->parent);
+					break;
+				} else {
+					/* Probably a control key. Let parent decide. */
+					loop = false;
+					break;
+				}
+		} /* switch () */
+
+		if (rv != E_OK) {
+			cdw_vdm ("WARNING: form_driver(..., key) returns %s for key %s\n",
+				 cdw_ncurses_error_string(rv), cdw_ncurses_key_label(key));
+		}
+
+	} while (loop);
+
+	if (key == CDW_KEY_ESCAPE) {
+		/* No need to validate field content. */
+		return key;
+	}
+
+	/* Flush form buffer */
+	int rv = form_driver(*(line->form), REQ_VALIDATION);
+	if (rv != E_OK) {
+		cdw_vdm ("WARNING: form_driver(..., REQ_VALIDATION) returns %s for key %s\n",
+			 cdw_ncurses_error_string(rv), cdw_ncurses_key_label(key));
+		return KEY_EXIT;
+	} else {
+		/* Escape, Tab, BTab, Down or Up. */
+		return key;
+	}
+}
+
+
+
+
+
+/**
+   \brief Get string from input line
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   Function returns freshly allocated string with content of \p
+   line. The string is owned by caller.  Function returns NULL on
+   errors.
+
+   The function does not perform validity or security checks of the
+   string. String is trimmed from right side.
+
+   \return copy of string from \p line on success
+   \return NULL on errors
+*/
+char *cdw_safe_input_line_get_content(CDW_SAFE_INPUT_LINE *line)
+{
+	char *s = cdw_ncurses_get_field_string(line->field);
+	if (s) {
+		return strdup(s);
+	} else {
+		return (char *) NULL;
+	}
+}
+
+
+
+
+
+/**
+   \brief Check if a widget contains insecure characters
+
+   \date Function's top-level comment reviewed on 2014-03-30
+   \date Function's body reviewed on 2014-03-30
+
+   The function only checks if there are any insecure characters
+   stored in \p line. It does not print any error message. First
+   insecure character encountered in \p line is stored in \p insecure
+   string.
+
+   The \p insecure string should be a two-char buffer (the second char
+   in the buffer is a space for terminating NUL).
+
+   \param line - widget to be checked
+   \param insecure - output buffer for insecure character
+
+   \return CDW_OK if content of string is secure
+   \return CDW_NO if content of string is insecure
+   \return CDW_ERROR on errors
+*/
+cdw_rv_t cdw_safe_input_line_test_content_security(CDW_SAFE_INPUT_LINE *line, char *insecure)
+{
+	char *local_buffer = (char *) NULL;
+	/* all that can go wrong at this point is malloc()
+	   failure - return value will be CDW_ERROR */
+	cdw_rv_t crv = cdw_ncurses_get_field_buffer(line->field, &local_buffer, (size_t) line->chars_max);
+	if (crv != CDW_OK) {
+		cdw_vdm ("ERROR: failed to get field buffer with cdw_ncurses_get_field_buffer()\n");
+		return CDW_ERROR;
+	}
+
+	/* TODO: Placing security check here makes input line less
+	   versatile, as I can imagine places where security checking
+	   may be unwanted, or may need different implementation. I
+	   have to update implementation of input line so that it is
+	   more configurable and universal. */
+
+	cdw_rv_t sec = cdw_string_security_parser(local_buffer, insecure);
+	if (sec == CDW_OK) {
+		cdw_vdm ("INFO: \"%s\" is secure\n", local_buffer);
+	} else if (sec == CDW_NO) {
+		cdw_vdm ("ERROR: insecure char in \"%s\"\n", local_buffer);
+ 	} else {
+		cdw_vdm ("ERROR: security parser returns CDW_ERROR for string \"%s\"\n", local_buffer);
+		sec = CDW_ERROR; /* Just in case if we haven't caught some other return value. */
+	}
+
+	free(local_buffer);
+	local_buffer = (char *) NULL;
+	return sec;
+}
diff -Naur orig/src/user_interface/widgets/cdw_safe_input_line.h patched/src/user_interface/widgets/cdw_safe_input_line.h
--- orig/src/user_interface/widgets/cdw_safe_input_line.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/src/user_interface/widgets/cdw_safe_input_line.h	2014-04-06 22:31:15.000000000 +0200
@@ -0,0 +1,53 @@
+#ifndef H_CDW_SAFE_INPUT_LINE
+#define H_CDW_SAFE_INPUT_LINE
+
+
+#include "cdw_ncurses.h"
+#include "cdw_dynamic_label.h"
+
+
+
+/* User can make N attempts to enter and fix string with unsafe
+   character(s). After the N times the widget's driver returns
+   CDW_KEY_ESCAPE. */
+#define CDW_SAFE_INPUT_LINE_ATTEMPTS_MAX   5
+
+
+
+/* Error messsage will be displayed for X seconds in a message area
+   associated with the input line. */
+#define CDW_SAFE_INPUT_LINE_ERROR_MESSAGE_TIME     3
+
+
+
+typedef struct  {
+	WINDOW *parent;
+
+	int n_cols;  /* width - number of columns of input field */
+	/* no height field, it is always equal 1 */
+
+	int chars_max;  /* maximum number of chars that user can enter into input line */
+	int input_type;
+
+	/* The variable will be set to CDW_WIDGET_ID_SAFE_INPUT_LINE by
+	   cdw_safe_input_line_new(). */
+	int widget_id;
+
+	FORM **form;
+	FIELD *field;
+
+	CDW_DYNAMIC_LABEL *message_area;
+
+	int attempts_max;
+} CDW_SAFE_INPUT_LINE;
+
+
+
+CDW_SAFE_INPUT_LINE *cdw_safe_input_line_new(WINDOW *parent, FORM **form, FIELD *field, int n_cols, const char *initial_content, int input_type, int chars_max);
+void     cdw_safe_input_line_delete(CDW_SAFE_INPUT_LINE **line);
+char    *cdw_safe_input_line_get_content(CDW_SAFE_INPUT_LINE *line);
+cdw_rv_t cdw_safe_input_line_set_content(CDW_SAFE_INPUT_LINE *line, const char *content);
+void     cdw_safe_input_line_bind_message_area(CDW_SAFE_INPUT_LINE *line, CDW_DYNAMIC_LABEL *label);
+int      cdw_safe_input_line_driver(CDW_SAFE_INPUT_LINE *line, void *dummy);
+
+#endif /* #ifndef H_CDW_SAFE_INPUT_LINE */
diff -Naur orig/src/user_interface/widgets/Makefile.am patched/src/user_interface/widgets/Makefile.am
--- orig/src/user_interface/widgets/Makefile.am	2012-01-04 20:34:27.000000000 +0100
+++ patched/src/user_interface/widgets/Makefile.am	2014-01-25 23:27:07.000000000 +0100
@@ -4,7 +4,9 @@
 	cdw_button.c cdw_button.h \
 	cdw_checkbox.c cdw_checkbox.h \
 	cdw_dialog.c cdw_dialog.h \
-	cdw_input_line.c cdw_input_line.h
+	cdw_input_line.c cdw_input_line.h \
+	cdw_safe_input_line.c cdw_safe_input_line.h \
+	cdw_dynamic_label.c cdw_dynamic_label.h
 
 
 # defines values of AM_CPPFLAGS and AM_CFLAGS
diff -Naur orig/src/user_interface/widgets/Makefile.in patched/src/user_interface/widgets/Makefile.in
--- orig/src/user_interface/widgets/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/user_interface/widgets/Makefile.in	2014-01-25 23:01:57.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,25 +76,30 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/user_interface/widgets
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwwidgets_a_AR = $(AR) $(ARFLAGS)
 libcdwwidgets_a_LIBADD =
 am__objects_1 = cdw_dropdown.$(OBJEXT) cdw_button.$(OBJEXT) \
 	cdw_checkbox.$(OBJEXT) cdw_dialog.$(OBJEXT) \
-	cdw_input_line.$(OBJEXT)
+	cdw_input_line.$(OBJEXT) cdw_safe_input_line.$(OBJEXT) \
+	cdw_dynamic_label.$(OBJEXT)
 am_libcdwwidgets_a_OBJECTS = $(am__objects_1)
 libcdwwidgets_a_OBJECTS = $(am_libcdwwidgets_a_OBJECTS)
 libcdwwidgets_check_a_AR = $(AR) $(ARFLAGS)
@@ -59,26 +108,75 @@
 	libcdwwidgets_check_a-cdw_button.$(OBJEXT) \
 	libcdwwidgets_check_a-cdw_checkbox.$(OBJEXT) \
 	libcdwwidgets_check_a-cdw_dialog.$(OBJEXT) \
-	libcdwwidgets_check_a-cdw_input_line.$(OBJEXT)
+	libcdwwidgets_check_a-cdw_input_line.$(OBJEXT) \
+	libcdwwidgets_check_a-cdw_safe_input_line.$(OBJEXT) \
+	libcdwwidgets_check_a-cdw_dynamic_label.$(OBJEXT)
 am_libcdwwidgets_check_a_OBJECTS = $(am__objects_2)
 libcdwwidgets_check_a_OBJECTS = $(am_libcdwwidgets_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwwidgets_a_SOURCES) $(libcdwwidgets_check_a_SOURCES)
 DIST_SOURCES = $(libcdwwidgets_a_SOURCES) \
 	$(libcdwwidgets_check_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -173,7 +271,9 @@
 	cdw_button.c cdw_button.h \
 	cdw_checkbox.c cdw_checkbox.h \
 	cdw_dialog.c cdw_dialog.h \
-	cdw_input_line.c cdw_input_line.h
+	cdw_input_line.c cdw_input_line.h \
+	cdw_safe_input_line.c cdw_safe_input_line.h \
+	cdw_dynamic_label.c cdw_dynamic_label.h
 
 
 # _FILE_OFFSET_BITS=64 - large file support (>2GB on 32-bit systems);
@@ -291,14 +391,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwwidgets.a: $(libcdwwidgets_a_OBJECTS) $(libcdwwidgets_a_DEPENDENCIES) $(EXTRA_libcdwwidgets_a_DEPENDENCIES) 
-	-rm -f libcdwwidgets.a
-	$(libcdwwidgets_a_AR) libcdwwidgets.a $(libcdwwidgets_a_OBJECTS) $(libcdwwidgets_a_LIBADD)
-	$(RANLIB) libcdwwidgets.a
+	$(AM_V_at)-rm -f libcdwwidgets.a
+	$(AM_V_AR)$(libcdwwidgets_a_AR) libcdwwidgets.a $(libcdwwidgets_a_OBJECTS) $(libcdwwidgets_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwwidgets.a
+
 libcdwwidgets_check.a: $(libcdwwidgets_check_a_OBJECTS) $(libcdwwidgets_check_a_DEPENDENCIES) $(EXTRA_libcdwwidgets_check_a_DEPENDENCIES) 
-	-rm -f libcdwwidgets_check.a
-	$(libcdwwidgets_check_a_AR) libcdwwidgets_check.a $(libcdwwidgets_check_a_OBJECTS) $(libcdwwidgets_check_a_LIBADD)
-	$(RANLIB) libcdwwidgets_check.a
+	$(AM_V_at)-rm -f libcdwwidgets_check.a
+	$(AM_V_AR)$(libcdwwidgets_check_a_AR) libcdwwidgets_check.a $(libcdwwidgets_check_a_OBJECTS) $(libcdwwidgets_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwwidgets_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -310,117 +412,138 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_checkbox.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_dialog.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_dropdown.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_dynamic_label.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_input_line.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cdw_safe_input_line.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwwidgets_check_a-cdw_button.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwwidgets_check_a-cdw_dynamic_label.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwwidgets_check_a-cdw_safe_input_line.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwwidgets_check_a-cdw_dropdown.o: cdw_dropdown.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dropdown.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Tpo -c -o libcdwwidgets_check_a-cdw_dropdown.o `test -f 'cdw_dropdown.c' || echo '$(srcdir)/'`cdw_dropdown.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dropdown.c' object='libcdwwidgets_check_a-cdw_dropdown.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dropdown.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Tpo -c -o libcdwwidgets_check_a-cdw_dropdown.o `test -f 'cdw_dropdown.c' || echo '$(srcdir)/'`cdw_dropdown.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dropdown.c' object='libcdwwidgets_check_a-cdw_dropdown.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dropdown.o `test -f 'cdw_dropdown.c' || echo '$(srcdir)/'`cdw_dropdown.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dropdown.o `test -f 'cdw_dropdown.c' || echo '$(srcdir)/'`cdw_dropdown.c
 
 libcdwwidgets_check_a-cdw_dropdown.obj: cdw_dropdown.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dropdown.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Tpo -c -o libcdwwidgets_check_a-cdw_dropdown.obj `if test -f 'cdw_dropdown.c'; then $(CYGPATH_W) 'cdw_dropdown.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dropdown.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dropdown.c' object='libcdwwidgets_check_a-cdw_dropdown.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dropdown.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Tpo -c -o libcdwwidgets_check_a-cdw_dropdown.obj `if test -f 'cdw_dropdown.c'; then $(CYGPATH_W) 'cdw_dropdown.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dropdown.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dropdown.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dropdown.c' object='libcdwwidgets_check_a-cdw_dropdown.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dropdown.obj `if test -f 'cdw_dropdown.c'; then $(CYGPATH_W) 'cdw_dropdown.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dropdown.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dropdown.obj `if test -f 'cdw_dropdown.c'; then $(CYGPATH_W) 'cdw_dropdown.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dropdown.c'; fi`
 
 libcdwwidgets_check_a-cdw_button.o: cdw_button.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_button.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Tpo -c -o libcdwwidgets_check_a-cdw_button.o `test -f 'cdw_button.c' || echo '$(srcdir)/'`cdw_button.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_button.c' object='libcdwwidgets_check_a-cdw_button.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_button.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Tpo -c -o libcdwwidgets_check_a-cdw_button.o `test -f 'cdw_button.c' || echo '$(srcdir)/'`cdw_button.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_button.c' object='libcdwwidgets_check_a-cdw_button.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_button.o `test -f 'cdw_button.c' || echo '$(srcdir)/'`cdw_button.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_button.o `test -f 'cdw_button.c' || echo '$(srcdir)/'`cdw_button.c
 
 libcdwwidgets_check_a-cdw_button.obj: cdw_button.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_button.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Tpo -c -o libcdwwidgets_check_a-cdw_button.obj `if test -f 'cdw_button.c'; then $(CYGPATH_W) 'cdw_button.c'; else $(CYGPATH_W) '$(srcdir)/cdw_button.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_button.c' object='libcdwwidgets_check_a-cdw_button.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_button.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Tpo -c -o libcdwwidgets_check_a-cdw_button.obj `if test -f 'cdw_button.c'; then $(CYGPATH_W) 'cdw_button.c'; else $(CYGPATH_W) '$(srcdir)/cdw_button.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_button.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_button.c' object='libcdwwidgets_check_a-cdw_button.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_button.obj `if test -f 'cdw_button.c'; then $(CYGPATH_W) 'cdw_button.c'; else $(CYGPATH_W) '$(srcdir)/cdw_button.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_button.obj `if test -f 'cdw_button.c'; then $(CYGPATH_W) 'cdw_button.c'; else $(CYGPATH_W) '$(srcdir)/cdw_button.c'; fi`
 
 libcdwwidgets_check_a-cdw_checkbox.o: cdw_checkbox.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_checkbox.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Tpo -c -o libcdwwidgets_check_a-cdw_checkbox.o `test -f 'cdw_checkbox.c' || echo '$(srcdir)/'`cdw_checkbox.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_checkbox.c' object='libcdwwidgets_check_a-cdw_checkbox.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_checkbox.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Tpo -c -o libcdwwidgets_check_a-cdw_checkbox.o `test -f 'cdw_checkbox.c' || echo '$(srcdir)/'`cdw_checkbox.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_checkbox.c' object='libcdwwidgets_check_a-cdw_checkbox.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_checkbox.o `test -f 'cdw_checkbox.c' || echo '$(srcdir)/'`cdw_checkbox.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_checkbox.o `test -f 'cdw_checkbox.c' || echo '$(srcdir)/'`cdw_checkbox.c
 
 libcdwwidgets_check_a-cdw_checkbox.obj: cdw_checkbox.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_checkbox.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Tpo -c -o libcdwwidgets_check_a-cdw_checkbox.obj `if test -f 'cdw_checkbox.c'; then $(CYGPATH_W) 'cdw_checkbox.c'; else $(CYGPATH_W) '$(srcdir)/cdw_checkbox.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_checkbox.c' object='libcdwwidgets_check_a-cdw_checkbox.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_checkbox.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Tpo -c -o libcdwwidgets_check_a-cdw_checkbox.obj `if test -f 'cdw_checkbox.c'; then $(CYGPATH_W) 'cdw_checkbox.c'; else $(CYGPATH_W) '$(srcdir)/cdw_checkbox.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_checkbox.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_checkbox.c' object='libcdwwidgets_check_a-cdw_checkbox.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_checkbox.obj `if test -f 'cdw_checkbox.c'; then $(CYGPATH_W) 'cdw_checkbox.c'; else $(CYGPATH_W) '$(srcdir)/cdw_checkbox.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_checkbox.obj `if test -f 'cdw_checkbox.c'; then $(CYGPATH_W) 'cdw_checkbox.c'; else $(CYGPATH_W) '$(srcdir)/cdw_checkbox.c'; fi`
 
 libcdwwidgets_check_a-cdw_dialog.o: cdw_dialog.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dialog.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Tpo -c -o libcdwwidgets_check_a-cdw_dialog.o `test -f 'cdw_dialog.c' || echo '$(srcdir)/'`cdw_dialog.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dialog.c' object='libcdwwidgets_check_a-cdw_dialog.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dialog.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Tpo -c -o libcdwwidgets_check_a-cdw_dialog.o `test -f 'cdw_dialog.c' || echo '$(srcdir)/'`cdw_dialog.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dialog.c' object='libcdwwidgets_check_a-cdw_dialog.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dialog.o `test -f 'cdw_dialog.c' || echo '$(srcdir)/'`cdw_dialog.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dialog.o `test -f 'cdw_dialog.c' || echo '$(srcdir)/'`cdw_dialog.c
 
 libcdwwidgets_check_a-cdw_dialog.obj: cdw_dialog.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dialog.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Tpo -c -o libcdwwidgets_check_a-cdw_dialog.obj `if test -f 'cdw_dialog.c'; then $(CYGPATH_W) 'cdw_dialog.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dialog.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dialog.c' object='libcdwwidgets_check_a-cdw_dialog.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dialog.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Tpo -c -o libcdwwidgets_check_a-cdw_dialog.obj `if test -f 'cdw_dialog.c'; then $(CYGPATH_W) 'cdw_dialog.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dialog.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dialog.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dialog.c' object='libcdwwidgets_check_a-cdw_dialog.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dialog.obj `if test -f 'cdw_dialog.c'; then $(CYGPATH_W) 'cdw_dialog.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dialog.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dialog.obj `if test -f 'cdw_dialog.c'; then $(CYGPATH_W) 'cdw_dialog.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dialog.c'; fi`
 
 libcdwwidgets_check_a-cdw_input_line.o: cdw_input_line.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_input_line.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Tpo -c -o libcdwwidgets_check_a-cdw_input_line.o `test -f 'cdw_input_line.c' || echo '$(srcdir)/'`cdw_input_line.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_input_line.c' object='libcdwwidgets_check_a-cdw_input_line.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_input_line.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Tpo -c -o libcdwwidgets_check_a-cdw_input_line.o `test -f 'cdw_input_line.c' || echo '$(srcdir)/'`cdw_input_line.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_input_line.c' object='libcdwwidgets_check_a-cdw_input_line.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_input_line.o `test -f 'cdw_input_line.c' || echo '$(srcdir)/'`cdw_input_line.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_input_line.o `test -f 'cdw_input_line.c' || echo '$(srcdir)/'`cdw_input_line.c
 
 libcdwwidgets_check_a-cdw_input_line.obj: cdw_input_line.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_input_line.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Tpo -c -o libcdwwidgets_check_a-cdw_input_line.obj `if test -f 'cdw_input_line.c'; then $(CYGPATH_W) 'cdw_input_line.c'; else $(CYGPATH_W) '$(srcdir)/cdw_input_line.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_input_line.c' object='libcdwwidgets_check_a-cdw_input_line.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_input_line.obj `if test -f 'cdw_input_line.c'; then $(CYGPATH_W) 'cdw_input_line.c'; else $(CYGPATH_W) '$(srcdir)/cdw_input_line.c'; fi`
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_input_line.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Tpo -c -o libcdwwidgets_check_a-cdw_input_line.obj `if test -f 'cdw_input_line.c'; then $(CYGPATH_W) 'cdw_input_line.c'; else $(CYGPATH_W) '$(srcdir)/cdw_input_line.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_input_line.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_input_line.c' object='libcdwwidgets_check_a-cdw_input_line.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_input_line.obj `if test -f 'cdw_input_line.c'; then $(CYGPATH_W) 'cdw_input_line.c'; else $(CYGPATH_W) '$(srcdir)/cdw_input_line.c'; fi`
+
+libcdwwidgets_check_a-cdw_safe_input_line.o: cdw_safe_input_line.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_safe_input_line.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_safe_input_line.Tpo -c -o libcdwwidgets_check_a-cdw_safe_input_line.o `test -f 'cdw_safe_input_line.c' || echo '$(srcdir)/'`cdw_safe_input_line.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_safe_input_line.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_safe_input_line.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_safe_input_line.c' object='libcdwwidgets_check_a-cdw_safe_input_line.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_safe_input_line.o `test -f 'cdw_safe_input_line.c' || echo '$(srcdir)/'`cdw_safe_input_line.c
+
+libcdwwidgets_check_a-cdw_safe_input_line.obj: cdw_safe_input_line.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_safe_input_line.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_safe_input_line.Tpo -c -o libcdwwidgets_check_a-cdw_safe_input_line.obj `if test -f 'cdw_safe_input_line.c'; then $(CYGPATH_W) 'cdw_safe_input_line.c'; else $(CYGPATH_W) '$(srcdir)/cdw_safe_input_line.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_safe_input_line.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_safe_input_line.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_safe_input_line.c' object='libcdwwidgets_check_a-cdw_safe_input_line.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_safe_input_line.obj `if test -f 'cdw_safe_input_line.c'; then $(CYGPATH_W) 'cdw_safe_input_line.c'; else $(CYGPATH_W) '$(srcdir)/cdw_safe_input_line.c'; fi`
+
+libcdwwidgets_check_a-cdw_dynamic_label.o: cdw_dynamic_label.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dynamic_label.o -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dynamic_label.Tpo -c -o libcdwwidgets_check_a-cdw_dynamic_label.o `test -f 'cdw_dynamic_label.c' || echo '$(srcdir)/'`cdw_dynamic_label.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dynamic_label.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dynamic_label.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dynamic_label.c' object='libcdwwidgets_check_a-cdw_dynamic_label.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dynamic_label.o `test -f 'cdw_dynamic_label.c' || echo '$(srcdir)/'`cdw_dynamic_label.c
+
+libcdwwidgets_check_a-cdw_dynamic_label.obj: cdw_dynamic_label.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwwidgets_check_a-cdw_dynamic_label.obj -MD -MP -MF $(DEPDIR)/libcdwwidgets_check_a-cdw_dynamic_label.Tpo -c -o libcdwwidgets_check_a-cdw_dynamic_label.obj `if test -f 'cdw_dynamic_label.c'; then $(CYGPATH_W) 'cdw_dynamic_label.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dynamic_label.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwwidgets_check_a-cdw_dynamic_label.Tpo $(DEPDIR)/libcdwwidgets_check_a-cdw_dynamic_label.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dynamic_label.c' object='libcdwwidgets_check_a-cdw_dynamic_label.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwwidgets_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwwidgets_check_a-cdw_dynamic_label.obj `if test -f 'cdw_dynamic_label.c'; then $(CYGPATH_W) 'cdw_dynamic_label.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dynamic_label.c'; fi`
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -432,15 +555,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -449,6 +568,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -590,18 +724,19 @@
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean \
-	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES ctags \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # used by flymake
diff -Naur orig/src/utilities/cdw_cdll.c patched/src/utilities/cdw_cdll.c
--- orig/src/utilities/cdw_cdll.c	2012-02-26 15:21:25.000000000 +0100
+++ patched/src/utilities/cdw_cdll.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdbool.h>
@@ -877,5 +877,3 @@
 
 
 #endif /* #ifdef CDW_UNIT_TEST_CODE */
-
-
diff -Naur orig/src/utilities/cdw_cdll.h patched/src/utilities/cdw_cdll.h
--- orig/src/utilities/cdw_cdll.h	2010-05-28 23:49:38.000000000 +0200
+++ patched/src/utilities/cdw_cdll.h	2014-03-13 22:17:39.000000000 +0100
@@ -26,7 +26,6 @@
 
 cdw_rv_t cdw_cdll_append(cdw_cdll_t *head, void *data);
 cdw_rv_t cdw_cdll_remove(cdw_cdll_t **head, size_t i);
-// void *cdw_cdll_get_ith(cdw_cdll_t *head, size_t i);
 void *cdw_cdll_ith_data(cdw_cdll_t *head, size_t i);
 
 
diff -Naur orig/src/utilities/cdw_debug.h patched/src/utilities/cdw_debug.h
--- orig/src/utilities/cdw_debug.h	2010-06-12 21:11:58.000000000 +0200
+++ patched/src/utilities/cdw_debug.h	2014-03-24 22:25:57.000000000 +0100
@@ -3,13 +3,17 @@
 
 #include <assert.h>
 #include <stdio.h>
+#include <errno.h>
+#include <string.h>
+
+#include "cdw_ncurses.h"
 
 /**
- * \file cdw_debug.h
- * \brief Utilities used during development phase to print debug messages
- *
- * Some utilities that can replace calls to fprintf(stderr, ...).
- */
+   \file cdw_debug.h
+   \brief Utilities used during development phase to print debug messages
+
+   Some utilities that can replace calls to fprintf(stderr, ...).
+*/
 
 
 
@@ -30,7 +34,7 @@
  * on variable argument lists in macros (it requires C99).
  */
 #ifndef NDEBUG
-#define cdw_vdm(...) fprintf(stderr, "%s():%d: ", __func__, __LINE__); fprintf(stderr, __VA_ARGS__);
+#define cdw_vdm(...) fprintf(stderr, "%s():%d: ", __func__, __LINE__); fprintf(stderr, __VA_ARGS__); fflush(stderr);
 #else
 #define cdw_vdm(...)
 #endif
@@ -44,6 +48,49 @@
 
 
 
+
+
+/**
+  \brief Print debug message for ncurses return values - verbose version
+
+  This macro behaves much like fprintf(stderr, ...) function,
+  caller only have to provide format string with converesion specifiers
+  and list of arguments for this format string.
+
+  Each message is preceeded with name of function that called the macro.
+
+  See "C: A Reference Manual", chapter 3.3.10 for more information
+  on variable argument lists in macros (it requires C99).
+*/
+#ifndef NDEBUG
+#define cdw_vdm_n(m_fname, m_rv, ...)					\
+	{								\
+		int m_e = errno;					\
+		fprintf(stderr, "%s():%d: ", __func__, __LINE__);	\
+		if (m_rv == E_OK) {					\
+			fprintf(stderr, "INFO: %s() returns E_OK %s\n", m_fname, __VA_ARGS__); \
+		} else {						\
+			fprintf(stderr, "ERROR: %s() returns %s %s\n", m_fname, cdw_ncurses_error_string(rv), __VA_ARGS__); \
+			if (m_rv == E_SYSTEM_ERROR) {			\
+				fprintf(stderr, "%s():%d: ", __func__, __LINE__); \
+				fprintf(stderr, "ERROR: %s(): error = %s\n", m_fname, strerror(m_e)); \
+			}						\
+		}							\
+		fflush(stderr);						\
+	}
+#else
+#define cdw_vdm_n(m_fname, m_rv, ...)
+#endif
+
+
+
+
+
+/** \brief Print debug message for ncurses return values - silent version */
+#define cdw_sdm_n(...)
+
+
+
 
 
 /**
diff -Naur orig/src/utilities/cdw_dll.c patched/src/utilities/cdw_dll.c
--- orig/src/utilities/cdw_dll.c	2012-02-26 15:19:06.000000000 +0100
+++ patched/src/utilities/cdw_dll.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 
@@ -1200,4 +1200,3 @@
 
 
 #endif /* CDW_UNIT_TEST_CODE */
-
diff -Naur orig/src/utilities/cdw_logging.c patched/src/utilities/cdw_logging.c
--- orig/src/utilities/cdw_logging.c	2012-02-26 15:21:58.000000000 +0100
+++ patched/src/utilities/cdw_logging.c	2014-03-13 22:17:39.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdio.h>
@@ -22,8 +22,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
 
-#include "config.h"
 #include "cdw_config.h"
 #include "gettext.h"
 #include "cdw_logging.h"
@@ -35,6 +35,7 @@
 #include "cdw_debug.h"
 #include "cdw_utils.h"
 
+#include "config_cdw.h"
 
 
 
@@ -53,35 +54,22 @@
 
 extern cdw_config_t global_config;
 
-/** \brief Default name of application log file */
+/* Default name of application log file. */
 const char *cdw_log_file_name = "cdw.log";
 
-
-/* *** definitions for logging module *** */
-
-/** \brief Application's log file */
+/* Application's log file. */
 static FILE *log_file = (FILE *) NULL;
 
-static bool full_path_silently_modified = false; /* was the path cleared (free()d set to NULL) */
-
-static void cdw_logging_display_problem(int problem);
 
 static cdw_rv_t cdw_logging_search_for_default_full_path(void);
-static cdw_rv_t cdw_logging_ask_for_dir_path(int problem);
+static cdw_rv_t cdw_logging_ask_for_dir_path(void);
 
 static cdw_rv_t cdw_logging_check_available_space(void);
 static void cdw_logging_path_reset_message(void);
+static void cdw_logging_no_space_message(void);
 
 static void cdw_logging_handle_old_log_file(void);
 
-/* constants used when dealing with problems when log file is initialized */
-#define INVALID_PATH 1
-#define NO_SPACE 2
-#define EMPTY_PATH 3
-#define GEN_ERROR 4
-
-
-
 
 
 /**
@@ -104,89 +92,65 @@
    the path to new value.
 
    If log file already existed then file is truncated to zero at opening.
-   Correct full path to log file is stored in config.log_full_path
+   Correct full path to log file is stored in config.general.log_fullpath
 
    \return CDW_OK if path is set correctly
    \return CDW_NO if user cancels entering new path or user didn't enter correct path in n tries
 */
-cdw_rv_t cdw_logging_init(void)
+cdw_rv_t cdw_logging_module_init(void)
 {
+	log_file = (FILE *) NULL;
 
 	cdw_logging_handle_old_log_file();
-	/*
-	loop
-		if (path correct) {
-			open
-			if (open = success)
-				check space
-				if (check space = success)
-					return CDW_OK;
-				else ask user (no space, new disc);
-			else ask user (path invalid)
-		else ask user (path invalid)
-	end loop
-	*/
 
-	full_path_silently_modified = false;
+	if (!global_config.general.log_fullpath
+	    || !strlen(global_config.general.log_fullpath)) {
+
+		cdw_rv_t crv = cdw_logging_search_for_default_full_path();
+		if (crv != CDW_OK) {
+			return CDW_NO;
+		}
+
+		cdw_logging_path_reset_message();
+	}
+
+	/* At this point we should have a non-empty path. The code
+	   below will attempt to use it. */
 
-	int i = 0;
 	int n = 5;
-	for (i = 0; i < n; i++) {
-		int problem = 0;
-		cdw_rv_t crv;
-		if ((global_config.log_full_path != (char *) NULL) && strlen(global_config.log_full_path)) {
-			log_file = fopen(global_config.log_full_path, "w+");
-			if (log_file != (FILE *) NULL) {
-				crv = cdw_logging_check_available_space();
+	for (int i = 0; i < n; i++) {
+
+		errno = 0;
+		log_file = fopen(global_config.general.log_fullpath, "w+");
+		int e = errno;
+		if (log_file) {
+			cdw_rv_t crv = cdw_logging_check_available_space();
 				if (crv == CDW_OK) {
-					if (full_path_silently_modified) {
-						cdw_logging_path_reset_message();
-						full_path_silently_modified = false;
-					}
 					rewind(log_file);
 					return CDW_OK;
 				} else {
 					fclose(log_file);
 					log_file = (FILE *) NULL;
 
-					cdw_vdm ("no space available for this log file: \"%s\"\n", global_config.log_full_path);
-					problem = NO_SPACE;
+					cdw_logging_no_space_message();
+
+					cdw_vdm ("ERROR: no space available for this log file: \"%s\"\n", global_config.general.log_fullpath);
+					e = ENOSPC;
 				}
-			} else {
-				cdw_vdm ("log file path is invalid: \"%s\"\n", global_config.log_full_path);
-				problem = INVALID_PATH;
-			}
 		} else {
-			cdw_vdm ("log file is null or empty: \"%s\"\n", global_config.log_full_path);
-			problem = EMPTY_PATH;
+			cdw_vdm ("ERROR: failed to open log file: \"%s\"\n", strerror(e));
+		}
 
+		if (e) {
+			cdw_fs_errno_handler(e);
 		}
 
 		if (i == n - 1) {
-			cdw_logging_display_problem(problem);
 			return CDW_ERROR;
 		}
 
-		if (problem == EMPTY_PATH
-		    || (i == 0 && problem == INVALID_PATH)) {
-			/* returns CDW_OK, CDW_NO, CDW_ERROR */
-			crv = cdw_logging_search_for_default_full_path();
-		} else {
-			/* returns CDW_OK, CDW_CANCEL, CDW_MEM_ERROR */
-			crv = cdw_logging_ask_for_dir_path(problem);
-		}
-
-		if (crv == CDW_OK) {
-			full_path_silently_modified = true;
-		} else if (crv == CDW_NO) {
-			/* log_search_for_default_full_path() can't find
-			   default path, ask user for path */
-			problem = INVALID_PATH;
-		} else if (crv == CDW_CANCEL) {
-			/* user pressed Escape key when asked for path */
-			return CDW_NO;
-		} else { /* crv == CDW_ERROR */
-			cdw_logging_display_problem(GEN_ERROR);
+		cdw_rv_t crv = cdw_logging_ask_for_dir_path();
+		if (crv != CDW_OK) {
 			return CDW_NO;
 		}
 	}
@@ -199,19 +163,20 @@
 
 
 /**
- * \brief Deallocate all resources opened by logging module
- *
- * Close log file, clean up all other logging resources
+   \brief Deallocate all resources opened by logging module
+
+   Close log file, clean up all other logging resources.
  */
-void cdw_logging_clean(void)
+void cdw_logging_module_clean(void)
 {
-	if (log_file != (FILE *) NULL) {
+	if (log_file) {
 		fflush(log_file);
 		fclose(log_file);
 		log_file = (FILE *) NULL;
 	}
 
-	/* note that config.log_full_path is free()d somewhere else */
+	/* Note that config.general.log_fullpath is free()d somewhere
+	   else. */
 
 	return;
 }
@@ -221,21 +186,21 @@
 
 
 /**
- * \brief Print message to log file
- *
- * printf()-like function that writes given format string and all
- * following arguments to log file.
- *
- * Function created to hide FILE *log_file from user and to provide
- * convenient way of writing to log.
- *
- * Function calls fflush() for file.
- *
- * \param format - format string of message that you want to print to log
+   \brief Print message to log file
+
+   printf()-like function that writes given format string and all
+   following arguments to log file.
+
+   Function created to hide FILE *log_file from user and to provide
+   convenient way of writing to log.
+
+   Function calls fflush() for file.
+
+   \param format - format string of message that you want to print to log
  */
 void cdw_logging_write(const char *format, ...)
 {
-	cdw_assert (log_file != (FILE *) NULL, "log file is not open when trying to write to it\n");
+	cdw_assert (log_file, "ERROR: log file is not open when trying to write to it\n");
 
 	va_list ap;
 	va_start(ap, format);
@@ -253,16 +218,16 @@
 
 
 /**
- * \brief Write some separator between parts of log file
- *
- * Current implementation of log file appends more and more data for
- * every task performed during one cdw session. This can make the log
- * file very long and hard to browse. Inserting some separator
- * between log file parts can make it easier to browse log file.
+   \brief Write some separator between parts of log file
+
+   Current implementation of log file appends more and more data for
+   every task performed during one cdw session. This can make the log
+   file very long and hard to browse. Inserting some separator between
+   log file parts can make it easier to browse log file.
  */
 void cdw_logging_write_separator(void)
 {
-	cdw_assert (log_file != (FILE *) NULL, "log file is not open when trying to write to it\n");
+	cdw_assert (log_file, "ERROR: log file is not open when trying to write to it\n");
 
 	fprintf(log_file, "\n\n");
 	/* 2TRANS: this is header printed in log file;
@@ -289,11 +254,11 @@
    to log file.
 
    Log file name is CDW_LOG_FILE_NAME ("cdw.log"). If function succeeds
-   then full path to log file is copied to config.log_full_path. Otherwise
-   config.log_full_path is set to NULL.
+   then full path to log file is copied to config.general.log_fullpath. Otherwise
+   config.general.log_fullpath is set to NULL.
 
    The function does not try to open the file, it just tries to set
-   config.log_full_path;
+   config.general.log_fullpath;
 
    \return CDW_ERROR if malloc() fails
    \return CDW_NO if function failed to set path to log file
@@ -304,11 +269,11 @@
 #if 0
 	/* log file should be in user home dir by default */
 	const char *dir_path = cdw_fs_get_home_dir_fullpath();
-	if (dir_path == (char *) NULL) {
+	if (!dir_path) {
 		dir_path = cdw_fs_get_tmp_dir_fullpath();
 		/* log_init() should be called after
 		   tmp dir is set, but let's check just in case */
-		if (dir_path == (char *) NULL) {
+		if (!dir_path) {
 			/* there was no HOME dir, and now it turned
 			    out that there is no tmp dir :( */
 			return CDW_NO;
@@ -322,14 +287,14 @@
 #endif
 	const char *dir = cdw_config_get_config_dir();
 	char *tmp = cdw_string_concat(dir, cdw_log_file_name, (char *) NULL);
-	if (tmp == (char *) NULL) {
+	if (!tmp) {
 		return CDW_ERROR;
 	} else {
-		if (global_config.log_full_path != (char *) NULL) {
-			free(global_config.log_full_path);
-			global_config.log_full_path = (char *) NULL;
+		if (global_config.general.log_fullpath) {
+			free(global_config.general.log_fullpath);
+			global_config.general.log_fullpath = (char *) NULL;
 		}
-		global_config.log_full_path = tmp;
+		global_config.general.log_fullpath = tmp;
 		return CDW_OK;
 	}
 }
@@ -339,18 +304,19 @@
 
 
 /**
- * \brief Display information about resetting log file path
- *
- * This function displays dialog box informing about resetting full
- * path to log file in cdw configuration. It should be used when during
- * search for log file the log file path was reset from it's previous
- * to new value, or when the path was set form empty path to non-empty
- * path.
- *
- * Reason for using this function is that log file path is important
- * parameter and user must be informed about any changes.
- *
- * The function was created to avoid shifting code too much to the right side ;)
+   \brief Display information about resetting log file path
+
+   This function displays dialog box informing about resetting full
+   path to log file in cdw configuration. It should be used when
+   during search for log file the log file path was reset from it's
+   previous to new value, or when the path was set form empty path to
+   non-empty path.
+
+   Reason for using this function is that log file path is important
+   parameter and user must be informed about any changes.
+
+   The function was created to avoid shifting code too much to the
+   right side ;)
  */
 void cdw_logging_path_reset_message(void)
 {
@@ -360,67 +326,69 @@
 			   _("Path to CDW log file has been reset. You may want to check current path in Configuration -> Log."),
 			   CDW_BUTTONS_OK, CDW_COLORS_DIALOG);
 
+	return;
 }
 
 
 
 
 
-/**
- * \brief Display dialog window in which user can enter path to
- * directory where log file will be put
- *
- * Display dialog box where user can enter new path to directory.
- *
- * If user entered new path, the function appends log file name to it
- * and puts result to config.log_full_path.
- * Otherwise config.log_full_path is not modified in any way.
- *
- * \param problem - identifier of problem, defined values are NO_SPACE, EMPTY_PATH, INVALID_PATH
- *
- * \return CDW_OK if user entered valid path
- * \return CDW_CANCEL if user canceled entering the path, or the path was invalid in n tries
- * \return CDW_ERROR on malloc errors
- */
-cdw_rv_t cdw_logging_ask_for_dir_path(int problem)
+void cdw_logging_no_space_message(void)
 {
-	char *message = (char *) NULL;
-	if (problem == NO_SPACE) {
-		/* 2TRANS: this is message in dialog window */
-		message = _("Enter path to directory on another device.");
-	} else if (problem == EMPTY_PATH) {
-		/* 2TRANS: this is message in dialog window */
-		message = _("Enter non-empty path to initial (e.g. Home) directory.");
-	} else { /* problem == INVALID_PATH */
+	/* 2TRANS: this is title of dialog window */
+	cdw_buttons_dialog(_("Error"),
 		/* 2TRANS: this is message in dialog window */
-		message = _("Enter valid path to directory to store cdw log file.");
+			   _("No space left on current device for cdw log file. Select directory on another device."),
+			   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
+
+	return;
 	}
-	char *buffer = (char *) NULL;
+
+
+
+
+
+/**
+   \brief Display dialog window in which user can enter path to directory where log file will be put
+
+   Display dialog box where user can enter new path to directory.
+
+   If user entered new path, the function appends log file name to it
+   and puts result to config.general.log_fullpath.  Otherwise
+   config.general.log_fullpath is not modified in any way.
+
+   \return CDW_OK if user entered valid path
+   \return CDW_CANCEL if user canceled entering the path, or the path was invalid in n tries
+   \return CDW_ERROR on malloc errors
+*/
+cdw_rv_t cdw_logging_ask_for_dir_path(void)
+{
+	char *buffer = strdup(cdw_fs_get_tmp_dir_fullpath());
 	/* 2TRANS: this is title of dialog window */
 	cdw_rv_t crv = cdw_fs_ui_file_picker(_("Configuring cdw..."),
-					     message,
+					     _("Enter valid path to directory on non-empty device."),
 					     &(buffer),
 					     CDW_FS_DIR, R_OK | W_OK, CDW_FS_EXISTING);
 
 	if (crv == CDW_OK) {
-		char *tmp = cdw_string_concat(buffer, cdw_log_file_name, (char *) NULL);
+		char *tmp = cdw_string_concat(buffer, "/", cdw_log_file_name, (char *) NULL);
 		free(buffer);
 		buffer = (char *) NULL;
-		if (tmp == (char *) NULL) {
+		if (!tmp) {
 			return CDW_ERROR;
 		} else {
-			if (global_config.log_full_path != (char *) NULL) {
-				free(global_config.log_full_path);
-				global_config.log_full_path = (char *) NULL;
+			if (global_config.general.log_fullpath) {
+				free(global_config.general.log_fullpath);
+				global_config.general.log_fullpath = (char *) NULL;
 			}
-			global_config.log_full_path = tmp;
+			global_config.general.log_fullpath = tmp;
 			return CDW_OK;
 		}
 	} else {
 		/* cdw_fs_ui_file_picker() does not allocate path if
 		   user pressed ESCAPE, but it allocates memory for
 		   empty string when user clears input field */
-		if (buffer != (char *) NULL) {
+		if (buffer) {
 			free(buffer);
 			buffer = (char *) NULL;
 		}
@@ -433,46 +401,6 @@
 
 
 /**
- * \brief Display message about current problem with initializing log path
- *
- * Display dialog box informing about specific problem with given path.
- *
- * \param problem - identifier of problem, defined values are NO_SPACE, EMPTY_PATH, INVALID_PATH
- */
-void cdw_logging_display_problem(int problem)
-{
-	if (problem == NO_SPACE) {
-		/* 2TRANS: this is title of dialog window */
-		cdw_buttons_dialog(_("Error"),
-				   /* 2TRANS: this is message in dialog window */
-				   _("Too little space left on disc, can't write to log file."),
-				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-	} else if (problem == EMPTY_PATH) {
-		/* 2TRANS: this is title of dialog window */
-		cdw_buttons_dialog(_("Error"),
-				   /* 2TRANS: this is message in dialog window */
-				   _("Path to log file is empty, can't open file."),
-				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-	} else if (problem == INVALID_PATH) {
-		/* 2TRANS: this is title of dialog window */
-		cdw_buttons_dialog(_("Error"),
-				   /* 2TRANS: this is message in dialog window */
-				   _("Path to log file is invalid, can't open file"),
-				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-	} else { /* problem == GEN_ERROR */
-		/* 2TRANS: this is title of dialog window */
-		cdw_buttons_dialog(_("Error"),
-				   /* 2TRANS: this is message in dialog window */
-				   _("cdw can't configure its log file. Please restart the program."),
-				   CDW_BUTTONS_OK, CDW_COLORS_ERROR);
-	}
-}
-
-
-
-
-
-/**
  * \brief Check if there is enough space on a device to store log file
  *
  * Try to write to log file some amount of data. If writing fails then return
@@ -492,18 +420,18 @@
 cdw_rv_t cdw_logging_check_available_space(void)
 {
 	bool failed = false;
-	if (log_file == (FILE *) NULL) {
+	if (!log_file) {
 		return CDW_ERROR;
 	}
 
-	char buffer[1000];
-	int i = 0;
-	for (i = 0; i < 1000; i++) {
+#define BUFFER_SIZE 1000
+	char buffer[BUFFER_SIZE];
+	for (int i = 0; i < BUFFER_SIZE; i++) {
 		buffer[i] = 'a';
 	}
-	buffer[i - 1] = '\0';
+	buffer[BUFFER_SIZE - 1] = '\0';
 
-	for (i = 0; i < 50; i++) {
+	for (int i = 0; i < 50; i++) {
 		int a = fprintf(log_file, "%s\n", buffer);
 		int b = fflush(log_file);
 		if (a < 0) {
@@ -516,7 +444,7 @@
 		}
 	}
 
-	freopen(global_config.log_full_path, "w+", log_file); /* reset file size to zero */
+	freopen(global_config.general.log_fullpath, "w+", log_file); /* reset file size to zero */
 
 	if (failed) {
 		return CDW_ERROR;
@@ -529,17 +457,16 @@
 
 
 
-
 /**
- * \brief Display log file
- *
- * Wrapper using file_display() and local FILE *log_file variable
- * to simplify displaying log file: callers don't have to use
- * config.log_full_path anymore.
- *
- * \p title may be empty string or NULL.
- *
- * \param title - title of window in which log file will be displayed
+   \brief Display log file
+
+   Wrapper using file_display() and local FILE *log_file variable to
+   simplify displaying log file: callers don't have to use
+   config.general.log_fullpath anymore.
+
+   \p title may be empty string or NULL.
+
+   \param title - title of window in which log file will be displayed
  */
 cdw_rv_t cdw_logging_display_log(const char *title)
 {
@@ -568,7 +495,7 @@
 
    Wrapper using file_display() and local FILE *log_file variable
    to simplify displaying log file: callers don't have to use
-   config.log_full_path anymore. "conditional" means that the log
+   config.general.log_fullpath anymore. "conditional" means that the log
    is displayed only if "show log after write" checkbox in configuration
    window is checked.
 
@@ -578,7 +505,7 @@
 */
 cdw_rv_t cdw_logging_display_log_conditional(const char *title)
 {
-	if (global_config.showlog) {
+	if (global_config.general.show_log) {
 		return cdw_logging_display_log(title);
 	} else {
 		return CDW_OK;
@@ -599,12 +526,12 @@
 void cdw_logging_handle_old_log_file(void)
 {
 	const char *dir = cdw_fs_get_home_dir_fullpath();
-	if (dir == (char *) NULL) {
+	if (!dir) {
 		return;
 	}
 
 	char *fullpath = cdw_string_concat(dir, ".cdw.log", (char *) NULL);
-	if (fullpath == (char *) NULL) {
+	if (!fullpath) {
 		cdw_vdm ("ERROR: failed to concatenate path\n");
 		return;
 	}
@@ -617,7 +544,7 @@
 
 
 	FILE *file = fopen(fullpath, "r");
-	if (file == (FILE *) NULL) {
+	if (!file) {
 		cdw_vdm ("ERROR: failed to open file \"%s\"\n", fullpath);
 		free(fullpath);
 		fullpath = (char *) NULL;
@@ -626,10 +553,10 @@
 	bool found = false;
 	for (int i = 0; i < 100; i++) {
 		char *line = my_readline_10k(file);
-		if (line != (char *) NULL) {
+		if (line) {
 			char *ptr = strstr(line, "   ::: Log file for cdw");
 			free(line);
-			if (ptr != (char *) NULL) {
+			if (ptr) {
 				found = true;
 				break;
 			}
@@ -651,5 +578,3 @@
 
 	return;
 }
-
-
diff -Naur orig/src/utilities/cdw_logging.h patched/src/utilities/cdw_logging.h
--- orig/src/utilities/cdw_logging.h	2009-10-10 23:37:59.000000000 +0200
+++ patched/src/utilities/cdw_logging.h	2014-03-01 23:25:15.000000000 +0100
@@ -3,8 +3,8 @@
 
 #include "main.h"
 
-cdw_rv_t cdw_logging_init(void);
-void cdw_logging_clean(void);
+cdw_rv_t cdw_logging_module_init(void);
+void     cdw_logging_module_clean(void);
 
 void cdw_logging_write(const char *format, ...);
 void cdw_logging_write_separator(void);
diff -Naur orig/src/utilities/cdw_regex.c patched/src/utilities/cdw_regex.c
--- orig/src/utilities/cdw_regex.c	2012-02-26 15:21:53.000000000 +0100
+++ patched/src/utilities/cdw_regex.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #include <stdio.h>
@@ -221,4 +221,3 @@
 		return len;
 	}
 }
-
diff -Naur orig/src/utilities/cdw_string.c patched/src/utilities/cdw_string.c
--- orig/src/utilities/cdw_string.c	2012-03-27 21:27:14.000000000 +0200
+++ patched/src/utilities/cdw_string.c	2014-03-22 18:03:16.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _GNU_SOURCE /* needed by isblank(), see 'man isblank' */
@@ -683,7 +683,7 @@
 {
 	size_t len = strlen(string);
 	if (len == 0) {
-		cdw_vdm ("INFO: returning 0 for empty string\n");
+		cdw_sdm ("INFO: returning 0 for empty string\n");
 		return 0;
 	}
 
@@ -697,7 +697,7 @@
 	}
 
 	if (string[0] == '\n') {
-		cdw_vdm ("INFO: returning 1 for '\n' string\n");
+		cdw_sdm ("INFO: returning 1 for '\n' string\n");
 		return 1;
 	}
 
@@ -705,7 +705,7 @@
 	   for first occurrence of the char in string */
 	for (size_t j = 0; j < range; j++) {
 		if (string[j] == '\n') {
-			cdw_vdm ("INFO: returning %zd on '\n' (\"%s\")\n", j, string);
+			cdw_sdm ("INFO: returning %zd on '\n' (\"%s\")\n", j, string);
 			return j;
 		}
 	}
@@ -715,17 +715,17 @@
 		cdw_vdm ("INFO: returning 0 on zero range\n");
 		return 0;
 	} else if (len == chars_max) {
-		cdw_vdm ("INFO: returning %zd on len == chars_max (\"%s\")\n", len, string);
+		cdw_sdm ("INFO: returning %zd on len == chars_max (\"%s\")\n", len, string);
 		return len;
 	} else if (len < chars_max) {
-		cdw_vdm ("INFO: returning %zd on len < chars_max (\"%s\")\n", len, string);
+		cdw_sdm ("INFO: returning %zd on len < chars_max (\"%s\")\n", len, string);
 		return len;
 	} else {
 		;
 	}
 
 	if (len > chars_max && isspace(string[chars_max])) {
-		cdw_vdm ("INFO: returning %zd on ending space (\"%s\")\n", chars_max, string);
+		cdw_sdm ("INFO: returning %zd on ending space (\"%s\")\n", chars_max, string);
 		return chars_max;
 	}
 
@@ -742,7 +742,7 @@
 		}
 	}
 
-	cdw_vdm ("INFO len of string \"%s\" is %zd (chars max = %zd)\n", string, i, chars_max);
+	cdw_sdm ("INFO len of string \"%s\" is %zd (chars max = %zd)\n", string, i, chars_max);
 
 	return i;
 }
@@ -822,7 +822,7 @@
 
 	retval[out_len] = '\0';
 
-	cdw_vdm ("INFO: returning %zd lines in \"%s\"\n", n_lines, retval);
+	cdw_sdm ("INFO: returning %zd lines in \"%s\"\n", n_lines, retval);
 
 	return retval;
 }
@@ -918,7 +918,7 @@
 		}
 	}
 
-	cdw_vdm ("INFO: returning %zd for \"%s\"\n", n_lines == 0 ? 1 : n_lines, string);
+	cdw_sdm ("INFO: returning %zd for \"%s\"\n", n_lines == 0 ? 1 : n_lines, string);
 	/* there should be at least one line, always;
 	   but we shouldn't do here 'return ++n_lines' */
 	return n_lines == 0 ? 1 : n_lines;
@@ -946,7 +946,7 @@
 		n_lines++;
 	}
 
-	cdw_vdm ("INFO: returning %zd for \"%s\"\n", n_lines == 0 ? 1 : n_lines, string);
+	cdw_sdm ("INFO: returning %zd for \"%s\"\n", n_lines == 0 ? 1 : n_lines, string);
 	return n_lines;
 }
 
@@ -983,6 +983,39 @@
 
 
 
+/**
+   \brief Delete a C string
+
+   Deallocate a string pointed to by \p string. Set the string pointer
+   (but not the pointer to pointer) to NULL.
+
+   The function is intended to replace the following pattern:
+
+   if (string) {
+           free(string);
+	   string = (char *) NULL;
+   }
+
+   There are so many places where I deallocate string this way that I
+   finally decided to make a wrapper for it.
+
+   \param string - pointer to string to free
+*/
+void cdw_string_delete(char **string)
+{
+	cdw_assert (string, "ERROR: function argument is NULL\n");
+
+	if (*string) {
+		free(*string);
+		*string = (char *) NULL;
+	}
+	return;
+}
+
+
+
+
+
 //#define CDW_UNIT_TEST_CODE
 #ifdef CDW_UNIT_TEST_CODE
 
@@ -1003,7 +1036,7 @@
 static void test_cdw_string_concat(void);
 static void test_cdw_string_append(void);
 static void test_cdw_string_get_bool_value(void);
-static void test_cdw_string_get_words_end(void);
+//static void test_cdw_string_get_words_end(void);
 static void test_cdw_string_get_line_end(void);
 static void test_cdw_string_get_line_len(void);
 static void test_cdw_string_wrap(void);
@@ -1784,7 +1817,7 @@
 		int rv = strcmp(output, test_data[i].expected_result);
 		if (rv) {
 			fprintf(stderr, "ERROR: failed at testcase #%d\n", i);
-			for (int k = 0; k < test_data[i].max_width; k++) {
+			for (unsigned int k = 0; k < test_data[i].max_width; k++) {
 				fprintf(stderr, "o");
 			}
 			fprintf(stderr, "\n");
@@ -1929,7 +1962,7 @@
 	int i = 0;
 	while (input_data[i].string) {
 		size_t rv = cdw_string_count_lines_new(input_data[i].string, input_data[i].width_max);
-		cdw_assert (rv == input_data[i].expected_value, "ERROR: failed at test #%d (rv = %d, expected %d)\n", i, rv, input_data[i].expected_value);
+		cdw_assert (rv == input_data[i].expected_value, "ERROR: failed at test #%d (rv = %zd, expected %zd)\n", i, rv, input_data[i].expected_value);
 
 		i++;
 	}
@@ -1940,51 +1973,3 @@
 }
 
 #endif /* #ifdef CDW_UNIT_TEST_CODE */
-
-
-
-
-/* unused code */
-
-#if 0
-
-char *cdw_string_wrap_old(const char *string, size_t width_max, int align)
-{
-	/* Input text buffer may have arbitrary length, but output text
-	   buffer's length must be a multiple of width_max. */
-	size_t n_lines = cdw_string_count_lines(string, width_max);
-	size_t out_len = width_max * n_lines;
-	char *retval = malloc(out_len + 1);
-	memset(retval, ' ', out_len + 1);
-
-	const char *input = string;
-	char *output = retval;
-
-	/* copy text from input to output */
-	while (1) {
-		/* function returns zero-based index */
-		size_t line_len = cdw_string_get_line_end(input, width_max);
-		if (!line_len) {
-			break;
-		}
-		line_len++;
-
-		size_t begin = cdw_string_wrap_start(width_max, line_len, align);
-		snprintf(output + begin, line_len + 1, "%s", input);
-
-		output[begin + line_len] = ' '; /* overwrite trailing NUL, we don't want to end the string just yet */
-
-		input = input + line_len;
-		output = output + width_max;
-
-		if (isspace(*input)) {
-			input++;
-		}
-	}
-
-	retval[out_len] = '\0';
-
-	return retval;
-}
-
-#endif
diff -Naur orig/src/utilities/cdw_string.h patched/src/utilities/cdw_string.h
--- orig/src/utilities/cdw_string.h	2012-02-17 23:01:27.000000000 +0100
+++ patched/src/utilities/cdw_string.h	2014-03-22 17:56:06.000000000 +0100
@@ -8,6 +8,7 @@
 
 #define CDW_STRING_UNSAFE_CHARS_STRING "&!*`'|^\\;\"$"
 
+void cdw_string_delete(char **string);
 
 char *cdw_string_rtrim(char *str);
 char *cdw_string_ltrim(char *str);
diff -Naur orig/src/utilities/cdw_sys.c patched/src/utilities/cdw_sys.c
--- orig/src/utilities/cdw_sys.c	2012-03-03 21:08:55.000000000 +0100
+++ patched/src/utilities/cdw_sys.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #define _POSIX_SOURCE /* struct sigaction */
@@ -28,9 +28,11 @@
 #include <unistd.h> /* access() */
 #include <errno.h>
 
+#if 0
 /* wait() */
 #include <sys/types.h>
 #include <sys/wait.h>
+#endif
 
 #include "cdw_sys.h"
 #include "gettext.h"
@@ -60,7 +62,10 @@
 static void cdw_sys_sigwinch_handler(int signal_number);
 static void cdw_sys_sigchild_handler(__attribute__((unused)) int signal_number);
 
+#if 0
 static sig_atomic_t child_exit_status;
+#endif
+
 static sig_atomic_t cdw_sys_signal_number;
 
 static cdw_rv_t cdw_sys_check_file_system_support_via_proc_fs(cdio_fs_t cdio_fs);
@@ -157,11 +162,18 @@
 */
 void cdw_sys_sigchild_handler(__attribute__((unused)) int signal_number)
 {
+#if 0
+	/* Stopped/terminated child process will be handled by
+	   cdw_thread.c/run_command()/wait(). We will need to capture
+	   return code of child processes, and it's more convenient to
+	   call wait() in there. */
+
+
 	/* clean child process */
 	int status;
 	wait(&status);
 	child_exit_status = status;
-
+#endif
 	return;
 }
 
diff -Naur orig/src/utilities/cdw_sys.h patched/src/utilities/cdw_sys.h
--- orig/src/utilities/cdw_sys.h	2012-02-17 23:01:04.000000000 +0100
+++ patched/src/utilities/cdw_sys.h	2014-01-19 20:49:59.000000000 +0100
@@ -4,6 +4,8 @@
 #include <cdio/cdio.h>
 #include <cdio/cd_types.h> /* cdio_fs_t */
 
+#include "config_cdw_undefine.h"
+
 #include "main.h"
 
 cdw_rv_t cdw_sys_check_file_system_support(cdio_fs_t cdio_fs);
diff -Naur orig/src/utilities/cdw_utils.c patched/src/utilities/cdw_utils.c
--- orig/src/utilities/cdw_utils.c	2012-03-06 20:31:31.000000000 +0100
+++ patched/src/utilities/cdw_utils.c	2014-03-20 22:56:18.000000000 +0100
@@ -1,6 +1,6 @@
 /* cdw
  * Copyright (C) 2002 Varkonyi Balazs
- * Copyright (C) 2007 - 2012 Kamil Ignacak
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #define _GNU_SOURCE /* getopt_long() */
 #include <string.h>
@@ -29,13 +29,13 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 
-#include "config.h"
 #include "cdw_logging.h"
 #include "gettext.h"
 #include "cdw_drive.h"
 #include "cdw_utils.h"
 #include "cdw_debug.h"
 
+#include "config_cdw.h"
 
 
 static void cdw_utils_print_version(void);
@@ -946,4 +946,3 @@
 
 
 #endif /* #ifdef CDW_UNIT_TEST_CODE */
-
diff -Naur orig/src/utilities/cdw_utils.h patched/src/utilities/cdw_utils.h
--- orig/src/utilities/cdw_utils.h	2012-02-05 22:23:30.000000000 +0100
+++ patched/src/utilities/cdw_utils.h	2014-01-19 20:49:59.000000000 +0100
@@ -6,6 +6,8 @@
 #include <cdio/cdio.h> /* lsn_t */
 #include "cdw_cdio.h"
 
+#include "config_cdw_undefine.h"
+
 #include "main.h"
 
 
diff -Naur orig/src/utilities/Makefile.in patched/src/utilities/Makefile.in
--- orig/src/utilities/Makefile.in	2012-02-26 15:53:41.000000000 +0100
+++ patched/src/utilities/Makefile.in	2014-01-19 20:51:29.000000000 +0100
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -32,20 +76,24 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/Makefile.cdw.am
+DIST_COMMON = $(top_srcdir)/Makefile.cdw.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/depcomp
 subdir = src/utilities
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/config_cdw.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
 libcdwutilities_a_AR = $(AR) $(ARFLAGS)
 libcdwutilities_a_LIBADD =
 am__objects_1 = cdw_sys.$(OBJEXT) cdw_cdll.$(OBJEXT) cdw_dll.$(OBJEXT) \
@@ -65,24 +113,71 @@
 am_libcdwutilities_check_a_OBJECTS = $(am__objects_2)
 libcdwutilities_check_a_OBJECTS =  \
 	$(am_libcdwutilities_check_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libcdwutilities_a_SOURCES) \
 	$(libcdwutilities_check_a_SOURCES)
 DIST_SOURCES = $(libcdwutilities_a_SOURCES) \
 	$(libcdwutilities_check_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
@@ -298,14 +393,16 @@
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
 libcdwutilities.a: $(libcdwutilities_a_OBJECTS) $(libcdwutilities_a_DEPENDENCIES) $(EXTRA_libcdwutilities_a_DEPENDENCIES) 
-	-rm -f libcdwutilities.a
-	$(libcdwutilities_a_AR) libcdwutilities.a $(libcdwutilities_a_OBJECTS) $(libcdwutilities_a_LIBADD)
-	$(RANLIB) libcdwutilities.a
+	$(AM_V_at)-rm -f libcdwutilities.a
+	$(AM_V_AR)$(libcdwutilities_a_AR) libcdwutilities.a $(libcdwutilities_a_OBJECTS) $(libcdwutilities_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwutilities.a
+
 libcdwutilities_check.a: $(libcdwutilities_check_a_OBJECTS) $(libcdwutilities_check_a_DEPENDENCIES) $(EXTRA_libcdwutilities_check_a_DEPENDENCIES) 
-	-rm -f libcdwutilities_check.a
-	$(libcdwutilities_check_a_AR) libcdwutilities_check.a $(libcdwutilities_check_a_OBJECTS) $(libcdwutilities_check_a_LIBADD)
-	$(RANLIB) libcdwutilities_check.a
+	$(AM_V_at)-rm -f libcdwutilities_check.a
+	$(AM_V_AR)$(libcdwutilities_check_a_AR) libcdwutilities_check.a $(libcdwutilities_check_a_OBJECTS) $(libcdwutilities_check_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libcdwutilities_check.a
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -329,137 +426,126 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcdwutilities_check_a-cdw_utils.Po@am__quote@
 
 .c.o:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 libcdwutilities_check_a-cdw_sys.o: cdw_sys.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_sys.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Tpo -c -o libcdwutilities_check_a-cdw_sys.o `test -f 'cdw_sys.c' || echo '$(srcdir)/'`cdw_sys.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_sys.c' object='libcdwutilities_check_a-cdw_sys.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_sys.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Tpo -c -o libcdwutilities_check_a-cdw_sys.o `test -f 'cdw_sys.c' || echo '$(srcdir)/'`cdw_sys.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_sys.c' object='libcdwutilities_check_a-cdw_sys.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_sys.o `test -f 'cdw_sys.c' || echo '$(srcdir)/'`cdw_sys.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_sys.o `test -f 'cdw_sys.c' || echo '$(srcdir)/'`cdw_sys.c
 
 libcdwutilities_check_a-cdw_sys.obj: cdw_sys.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_sys.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Tpo -c -o libcdwutilities_check_a-cdw_sys.obj `if test -f 'cdw_sys.c'; then $(CYGPATH_W) 'cdw_sys.c'; else $(CYGPATH_W) '$(srcdir)/cdw_sys.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_sys.c' object='libcdwutilities_check_a-cdw_sys.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_sys.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Tpo -c -o libcdwutilities_check_a-cdw_sys.obj `if test -f 'cdw_sys.c'; then $(CYGPATH_W) 'cdw_sys.c'; else $(CYGPATH_W) '$(srcdir)/cdw_sys.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_sys.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_sys.c' object='libcdwutilities_check_a-cdw_sys.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_sys.obj `if test -f 'cdw_sys.c'; then $(CYGPATH_W) 'cdw_sys.c'; else $(CYGPATH_W) '$(srcdir)/cdw_sys.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_sys.obj `if test -f 'cdw_sys.c'; then $(CYGPATH_W) 'cdw_sys.c'; else $(CYGPATH_W) '$(srcdir)/cdw_sys.c'; fi`
 
 libcdwutilities_check_a-cdw_cdll.o: cdw_cdll.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_cdll.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Tpo -c -o libcdwutilities_check_a-cdw_cdll.o `test -f 'cdw_cdll.c' || echo '$(srcdir)/'`cdw_cdll.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdll.c' object='libcdwutilities_check_a-cdw_cdll.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_cdll.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Tpo -c -o libcdwutilities_check_a-cdw_cdll.o `test -f 'cdw_cdll.c' || echo '$(srcdir)/'`cdw_cdll.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdll.c' object='libcdwutilities_check_a-cdw_cdll.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_cdll.o `test -f 'cdw_cdll.c' || echo '$(srcdir)/'`cdw_cdll.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_cdll.o `test -f 'cdw_cdll.c' || echo '$(srcdir)/'`cdw_cdll.c
 
 libcdwutilities_check_a-cdw_cdll.obj: cdw_cdll.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_cdll.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Tpo -c -o libcdwutilities_check_a-cdw_cdll.obj `if test -f 'cdw_cdll.c'; then $(CYGPATH_W) 'cdw_cdll.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdll.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_cdll.c' object='libcdwutilities_check_a-cdw_cdll.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_cdll.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Tpo -c -o libcdwutilities_check_a-cdw_cdll.obj `if test -f 'cdw_cdll.c'; then $(CYGPATH_W) 'cdw_cdll.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdll.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_cdll.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_cdll.c' object='libcdwutilities_check_a-cdw_cdll.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_cdll.obj `if test -f 'cdw_cdll.c'; then $(CYGPATH_W) 'cdw_cdll.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdll.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_cdll.obj `if test -f 'cdw_cdll.c'; then $(CYGPATH_W) 'cdw_cdll.c'; else $(CYGPATH_W) '$(srcdir)/cdw_cdll.c'; fi`
 
 libcdwutilities_check_a-cdw_dll.o: cdw_dll.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_dll.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Tpo -c -o libcdwutilities_check_a-cdw_dll.o `test -f 'cdw_dll.c' || echo '$(srcdir)/'`cdw_dll.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dll.c' object='libcdwutilities_check_a-cdw_dll.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_dll.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Tpo -c -o libcdwutilities_check_a-cdw_dll.o `test -f 'cdw_dll.c' || echo '$(srcdir)/'`cdw_dll.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dll.c' object='libcdwutilities_check_a-cdw_dll.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_dll.o `test -f 'cdw_dll.c' || echo '$(srcdir)/'`cdw_dll.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_dll.o `test -f 'cdw_dll.c' || echo '$(srcdir)/'`cdw_dll.c
 
 libcdwutilities_check_a-cdw_dll.obj: cdw_dll.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_dll.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Tpo -c -o libcdwutilities_check_a-cdw_dll.obj `if test -f 'cdw_dll.c'; then $(CYGPATH_W) 'cdw_dll.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dll.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_dll.c' object='libcdwutilities_check_a-cdw_dll.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_dll.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Tpo -c -o libcdwutilities_check_a-cdw_dll.obj `if test -f 'cdw_dll.c'; then $(CYGPATH_W) 'cdw_dll.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dll.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_dll.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_dll.c' object='libcdwutilities_check_a-cdw_dll.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_dll.obj `if test -f 'cdw_dll.c'; then $(CYGPATH_W) 'cdw_dll.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dll.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_dll.obj `if test -f 'cdw_dll.c'; then $(CYGPATH_W) 'cdw_dll.c'; else $(CYGPATH_W) '$(srcdir)/cdw_dll.c'; fi`
 
 libcdwutilities_check_a-cdw_string.o: cdw_string.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_string.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_string.Tpo -c -o libcdwutilities_check_a-cdw_string.o `test -f 'cdw_string.c' || echo '$(srcdir)/'`cdw_string.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_string.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_string.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_string.c' object='libcdwutilities_check_a-cdw_string.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_string.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_string.Tpo -c -o libcdwutilities_check_a-cdw_string.o `test -f 'cdw_string.c' || echo '$(srcdir)/'`cdw_string.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_string.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_string.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_string.c' object='libcdwutilities_check_a-cdw_string.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_string.o `test -f 'cdw_string.c' || echo '$(srcdir)/'`cdw_string.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_string.o `test -f 'cdw_string.c' || echo '$(srcdir)/'`cdw_string.c
 
 libcdwutilities_check_a-cdw_string.obj: cdw_string.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_string.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_string.Tpo -c -o libcdwutilities_check_a-cdw_string.obj `if test -f 'cdw_string.c'; then $(CYGPATH_W) 'cdw_string.c'; else $(CYGPATH_W) '$(srcdir)/cdw_string.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_string.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_string.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_string.c' object='libcdwutilities_check_a-cdw_string.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_string.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_string.Tpo -c -o libcdwutilities_check_a-cdw_string.obj `if test -f 'cdw_string.c'; then $(CYGPATH_W) 'cdw_string.c'; else $(CYGPATH_W) '$(srcdir)/cdw_string.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_string.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_string.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_string.c' object='libcdwutilities_check_a-cdw_string.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_string.obj `if test -f 'cdw_string.c'; then $(CYGPATH_W) 'cdw_string.c'; else $(CYGPATH_W) '$(srcdir)/cdw_string.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_string.obj `if test -f 'cdw_string.c'; then $(CYGPATH_W) 'cdw_string.c'; else $(CYGPATH_W) '$(srcdir)/cdw_string.c'; fi`
 
 libcdwutilities_check_a-cdw_utils.o: cdw_utils.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_utils.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Tpo -c -o libcdwutilities_check_a-cdw_utils.o `test -f 'cdw_utils.c' || echo '$(srcdir)/'`cdw_utils.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_utils.c' object='libcdwutilities_check_a-cdw_utils.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_utils.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Tpo -c -o libcdwutilities_check_a-cdw_utils.o `test -f 'cdw_utils.c' || echo '$(srcdir)/'`cdw_utils.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_utils.c' object='libcdwutilities_check_a-cdw_utils.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_utils.o `test -f 'cdw_utils.c' || echo '$(srcdir)/'`cdw_utils.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_utils.o `test -f 'cdw_utils.c' || echo '$(srcdir)/'`cdw_utils.c
 
 libcdwutilities_check_a-cdw_utils.obj: cdw_utils.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_utils.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Tpo -c -o libcdwutilities_check_a-cdw_utils.obj `if test -f 'cdw_utils.c'; then $(CYGPATH_W) 'cdw_utils.c'; else $(CYGPATH_W) '$(srcdir)/cdw_utils.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_utils.c' object='libcdwutilities_check_a-cdw_utils.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_utils.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Tpo -c -o libcdwutilities_check_a-cdw_utils.obj `if test -f 'cdw_utils.c'; then $(CYGPATH_W) 'cdw_utils.c'; else $(CYGPATH_W) '$(srcdir)/cdw_utils.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_utils.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_utils.c' object='libcdwutilities_check_a-cdw_utils.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_utils.obj `if test -f 'cdw_utils.c'; then $(CYGPATH_W) 'cdw_utils.c'; else $(CYGPATH_W) '$(srcdir)/cdw_utils.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_utils.obj `if test -f 'cdw_utils.c'; then $(CYGPATH_W) 'cdw_utils.c'; else $(CYGPATH_W) '$(srcdir)/cdw_utils.c'; fi`
 
 libcdwutilities_check_a-cdw_logging.o: cdw_logging.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_logging.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Tpo -c -o libcdwutilities_check_a-cdw_logging.o `test -f 'cdw_logging.c' || echo '$(srcdir)/'`cdw_logging.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_logging.c' object='libcdwutilities_check_a-cdw_logging.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_logging.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Tpo -c -o libcdwutilities_check_a-cdw_logging.o `test -f 'cdw_logging.c' || echo '$(srcdir)/'`cdw_logging.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_logging.c' object='libcdwutilities_check_a-cdw_logging.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_logging.o `test -f 'cdw_logging.c' || echo '$(srcdir)/'`cdw_logging.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_logging.o `test -f 'cdw_logging.c' || echo '$(srcdir)/'`cdw_logging.c
 
 libcdwutilities_check_a-cdw_logging.obj: cdw_logging.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_logging.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Tpo -c -o libcdwutilities_check_a-cdw_logging.obj `if test -f 'cdw_logging.c'; then $(CYGPATH_W) 'cdw_logging.c'; else $(CYGPATH_W) '$(srcdir)/cdw_logging.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_logging.c' object='libcdwutilities_check_a-cdw_logging.obj' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_logging.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Tpo -c -o libcdwutilities_check_a-cdw_logging.obj `if test -f 'cdw_logging.c'; then $(CYGPATH_W) 'cdw_logging.c'; else $(CYGPATH_W) '$(srcdir)/cdw_logging.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_logging.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_logging.c' object='libcdwutilities_check_a-cdw_logging.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_logging.obj `if test -f 'cdw_logging.c'; then $(CYGPATH_W) 'cdw_logging.c'; else $(CYGPATH_W) '$(srcdir)/cdw_logging.c'; fi`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_logging.obj `if test -f 'cdw_logging.c'; then $(CYGPATH_W) 'cdw_logging.c'; else $(CYGPATH_W) '$(srcdir)/cdw_logging.c'; fi`
 
 libcdwutilities_check_a-cdw_regex.o: cdw_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_regex.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Tpo -c -o libcdwutilities_check_a-cdw_regex.o `test -f 'cdw_regex.c' || echo '$(srcdir)/'`cdw_regex.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_regex.c' object='libcdwutilities_check_a-cdw_regex.o' libtool=no @AMDEPBACKSLASH@
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_regex.o -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Tpo -c -o libcdwutilities_check_a-cdw_regex.o `test -f 'cdw_regex.c' || echo '$(srcdir)/'`cdw_regex.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_regex.c' object='libcdwutilities_check_a-cdw_regex.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_regex.o `test -f 'cdw_regex.c' || echo '$(srcdir)/'`cdw_regex.c
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_regex.o `test -f 'cdw_regex.c' || echo '$(srcdir)/'`cdw_regex.c
 
 libcdwutilities_check_a-cdw_regex.obj: cdw_regex.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_regex.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Tpo -c -o libcdwutilities_check_a-cdw_regex.obj `if test -f 'cdw_regex.c'; then $(CYGPATH_W) 'cdw_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_regex.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cdw_regex.c' object='libcdwutilities_check_a-cdw_regex.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_regex.obj `if test -f 'cdw_regex.c'; then $(CYGPATH_W) 'cdw_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_regex.c'; fi`
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libcdwutilities_check_a-cdw_regex.obj -MD -MP -MF $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Tpo -c -o libcdwutilities_check_a-cdw_regex.obj `if test -f 'cdw_regex.c'; then $(CYGPATH_W) 'cdw_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_regex.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Tpo $(DEPDIR)/libcdwutilities_check_a-cdw_regex.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cdw_regex.c' object='libcdwutilities_check_a-cdw_regex.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcdwutilities_check_a_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libcdwutilities_check_a-cdw_regex.obj `if test -f 'cdw_regex.c'; then $(CYGPATH_W) 'cdw_regex.c'; else $(CYGPATH_W) '$(srcdir)/cdw_regex.c'; fi`
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -471,15 +557,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -488,6 +570,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -629,18 +726,19 @@
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean \
-	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES ctags \
-	distclean distclean-compile distclean-generic distclean-tags \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+	clean-checkLIBRARIES clean-generic clean-noinstLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
 
 
 # used by flymake
diff -Naur orig/tools/cdwdic.c patched/tools/cdwdic.c
--- orig/tools/cdwdic.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/tools/cdwdic.c	2014-04-06 23:08:43.000000000 +0200
@@ -0,0 +1,630 @@
+/* cdw
+ * Copyright (C) 2002 Varkonyi Balazs
+ * Copyright (C) 2007 - 2014 Kamil Ignacak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <stdio.h>
+#include <ncurses.h>
+#include <menu.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <libintl.h>
+#include <locale.h>
+#include <nl_types.h>
+#include <time.h>
+#include "config.h"
+#include "../src/options.h"
+
+#ifdef HAVE_LIBMYSQLCLIENT
+#include <mysql/mysql.h>
+
+MYSQL mysql;
+MYSQL_RES *result;
+MYSQL_ROW row;
+
+#endif
+
+#ifdef HAVE_LIBSQLITE
+#include <sqlite.h>
+typedef struct SQLITE_RST {
+    char **result;
+    int nrow;
+    int ncol;
+} SQLITE_RES;
+
+sqlite *sqlite_db;
+int rc;
+char *errmsg = 0;
+SQLITE_RES *result;
+#endif
+
+int size, i;
+char query[255];
+struct conf config;
+
+int none(struct dirent *unused)
+{
+    if (strcmp(unused->d_name,".") && strcmp(unused->d_name,"..")) {
+	return 1;
+    }
+    else
+	return 0;
+}
+char *cdbpass;
+
+#ifdef HAVE_LIBMYSQLCLIENT
+int scan_content(char *dir, MYSQL mysql, int cd_id, int dirlength)
+#endif
+#ifdef HAVE_LIBSQLITE
+int scan_content(char *dir, sqlite *sqlite_db, int cd_id, int dirlength)
+#endif
+{
+    struct dirent **eps;
+    struct stat *finfo;
+    int n, ok, cnt, type;
+    char *dname, *ch, *date[25], insertdir[200];
+    struct tm *filetime;
+    time_t fitime;
+    char query[500];
+
+#ifdef HAVE_LIBMYSQLCLIENT
+    MYSQL_RES *result;
+#endif
+    n = scandir(dir, &eps, (void *)none, alphasort);
+    if (n>=0) {
+	for (cnt=0; cnt<n; ++cnt){
+    	    ch=(char *) malloc(strlen(eps[cnt]->d_name)+strlen(dir)+4);
+	    sprintf(ch,"%s/%s",dir,eps[cnt]->d_name);
+	    finfo=(struct stat *)malloc(sizeof(finfo)+100);
+	    ok=lstat(ch,finfo);
+	    type=S_ISLNK(finfo->st_mode);
+	    if ( (eps[cnt]->d_type=DT_DIR) && (type==0) )
+#ifdef HAVE_LIBMYSQLCLIENT
+		scan_content(ch, mysql, cd_id, dirlength);
+#endif
+#ifdef HAVE_LIBSQLITE
+		scan_content(ch, sqlite_db, cd_id, dirlength);
+#endif
+	    if (ok=stat(ch,finfo)!=0);
+	    else {
+		fitime=finfo->st_mtime;
+		filetime=localtime(&fitime);
+		strftime((char *)date, 25, "%Y-%m-%d", filetime);
+
+		if (strlen(dir)!=dirlength){
+		    strcpy((char *)insertdir, dir+dirlength+1);
+		    sprintf(query, "INSERT INTO content (file, size, date, cd_id) VALUES (\"%s/%s\",'%d','%s', %d);", insertdir, eps[cnt]->d_name, finfo->st_size, date, cd_id);
+		} else
+		    sprintf(query, "INSERT INTO content (file, size, date, cd_id) VALUES (\"%s\",'%d','%s', %d);", eps[cnt]->d_name, finfo->st_size, date, cd_id);
+#ifdef HAVE_LIBMYSQLCLIENT
+		if (mysql_query(&mysql, query)) {
+		    fprintf(stderr, "Failed: %s\n", mysql_error(&mysql));
+		    return 1;
+		}
+#endif
+#ifdef HAVE_LIBSQLITE
+		rc=sqlite_exec(sqlite_db, query, NULL, 0, &errmsg);
+		if (rc!=SQLITE_OK){
+		    fprintf(stderr, "%s\n", errmsg);
+		}
+#endif
+	    }
+	    free(finfo);
+    	    free(ch);
+	}
+    }
+    return size;
+}
+
+int connect_database()
+{
+	char message[200];
+#ifdef HAVE_LIBMYSQLCLIENT
+	mysql_init(&mysql);
+	if (!mysql_real_connect(&mysql, config.cdbhost, config.cdbuser, cdbpass, "cdw", 0, NULL, 0)){
+		sprintf(message, "%s", mysql_error(&mysql));
+		//dialogbox("Error", message, 0);
+		fprintf(stderr, "%s", message);
+		return 1;
+	}
+#endif
+#ifdef HAVE_LIBSQLITE
+	sqlite_db=sqlite_open(config.sqlite_file, 0, &errmsg);
+	if (!sqlite_db) {
+	    fprintf(stderr, "%s\n", errmsg);
+	    return 1;
+	}
+#endif
+	return 0;
+}
+
+int add_content(char *dir, int cd_id)
+{
+    if (connect_database()==0){
+#ifdef HAVE_LIBMYSQLCLIENT
+	scan_content(dir, mysql, cd_id, strlen(dir));
+	mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	scan_content(dir, sqlite_db, cd_id, strlen(dir));
+	sqlite_close(sqlite_db);
+#endif
+    }
+}
+
+static int query_content_callback(void *notused, int argc, char **argv, char **colname)
+{
+    printf("%s. %s: %s\n", argv[0], argv[1], argv[2]);
+    return 0;
+}
+
+int query_content(char *type, char *disk, char *dir)
+{
+    if (connect_database()==0){
+	sprintf(query, "SELECT cd.number, cd.name, content.file, content.size, content.date, type.name FROM content LEFT JOIN cd ON content.cd_id=cd.cd_id left join type on cd.type=type.type_id WHERE content.cd_id>0");
+	if (strcmp(dir, "*")!=0){
+	    sprintf(query, "%s AND UPPER(content.file) LIKE UPPER(\"%s/%%\")", query, dir);
+	}
+	if (strcmp(disk,"*")!=0){
+	    sprintf(query, "%s AND cd.name=\"%s\"", query, disk);
+	}
+	if (strcmp(type,"*")!=0){
+	    sprintf(query, "%s AND type.name=\"%s\"", query, type);
+	}
+	sprintf(query, "%s ORDER BY cd.number, cd.name", query);
+#ifdef HAVE_LIBMYSQLCLIENT
+	if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed: %s\n", mysql_error(&mysql));
+		return 1;
+	} else {
+	    result=mysql_store_result(&mysql);
+	    while (row=mysql_fetch_row(result)){
+    		printf("%s. %s: %s\n", row[0], row[1], row[2]);
+	    }
+	}
+	mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	rc=sqlite_exec(sqlite_db, query, query_content_callback, 0, &errmsg);
+	if (rc!=SQLITE_OK){
+	    fprintf(stderr, "%s\n", errmsg);
+	}
+	sqlite_close(sqlite_db);
+#endif
+    }
+}
+
+int search_content(char *file, char *type, char *disk, char *dir)
+{
+    int i;
+
+    if (connect_database()==0){
+	sprintf(query, "SELECT cd.number, cd.name, content.file, content.size, content.date, type.name FROM content LEFT JOIN cd ON content.cd_id=cd.cd_id left join type on cd.type=type.type_id WHERE content.cd_id>0");
+#ifdef HAVE_LIBMYSQLCLIENT
+	if (strcmp(dir, "*")!=0){
+	    sprintf(query, "%s AND content.file REGEXP '%s'", query, dir);
+	}
+	if (strcmp(file, "*")!=0){
+	    sprintf(query, "%s AND content.file REGEXP '%s'", query, file);
+	}
+	if (strcmp(disk,"*")!=0){
+	    sprintf(query, "%s AND cd.name=\"%s\"", query, disk);
+	}
+	if (strcmp(type,"*")!=0){
+	    sprintf(query, "%s AND type.name=\"%s\"", query, type);
+	}
+	sprintf(query, "%s ORDER BY cd.number, cd.name", query);
+	if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed: %s\n", mysql_error(&mysql));
+		return 1;
+	} else {
+	    result=mysql_store_result(&mysql);
+	    while (row=mysql_fetch_row(result)){
+    		printf("%s. %s: %s\n", row[0], row[1], row[2]);
+	    }
+	}
+	mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	if (strcmp(dir, "*")!=0){
+	    sprintf(query, "%s AND content.file LIKE '%%%s%%'", query, dir);
+	}
+	if (strcmp(file, "*")!=0){
+	    sprintf(query, "%s AND content.file LIKE '%%%s%%'", query, file);
+	}
+	if (strcmp(disk,"*")!=0){
+	    sprintf(query, "%s AND cd.name=\"%s\"", query, disk);
+	}
+	if (strcmp(type,"*")!=0){
+	    sprintf(query, "%s AND type.name=\"%s\"", query, type);
+	}
+	sprintf(query, "%s ORDER BY cd.number, cd.name", query);
+	rc=sqlite_exec(sqlite_db, query, query_content_callback, 0, &errmsg);
+	if (rc!=SQLITE_OK){
+	    fprintf(stderr, "%s\n", errmsg);
+	}
+	sqlite_close(sqlite_db);
+#endif
+    }
+}
+
+int add_disk(char *cdname, int no, int type, char *date)
+{
+    if (connect_database()==0){
+	sprintf(query, "INSERT INTO cd (name, number, type, date) VALUES (\"%s\",%d,%d, '%s');", cdname, no, type, date);
+#ifdef HAVE_LIBMYSQLCLIENT
+	if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed: %s\n", mysql_error(&mysql));
+		return 1;
+	}
+	i=mysql_insert_id(&mysql);
+	mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	rc=sqlite_exec(sqlite_db, query, NULL, 0, &errmsg);
+	i=sqlite_last_insert_rowid(sqlite_db);
+	if (rc!=SQLITE_OK){
+	    fprintf(stderr, "%s\n", errmsg);
+	}
+	sqlite_close(sqlite_db);
+#endif
+    }
+    return i;
+}
+
+static int query_disk_callback(void *notused, int argc, char **argv, char **colname)
+{
+    printf("%s. %s\t[%s] (%s)\n", argv[2], argv[1], argv[3], argv[4]);
+    return 0;
+}
+
+int query_disk(char *cdname, int no, char *type)
+{
+    if (connect_database()==0){
+	sprintf(query, "SELECT cd.cd_id, cd.name, cd.number, type.name, cd.date FROM cd LEFT JOIN type ON cd.type=type.type_id WHERE cd.cd_id>0");
+	if (strcmp(cdname, "*")!=0){
+	    sprintf(query, "%s AND UPPER(cd.name) LIKE UPPER(\"%%%s%%\")", query, cdname);
+	}
+	if (no!=0){
+	    sprintf(query, "%s AND cd.number=%d", query, no);
+	}
+	if (strcmp(type, "*")!=0){
+	    sprintf(query, "%s AND type.name=\"%s\"", query, type);
+	}
+	sprintf(query, "%s ORDER BY cd.number, cd.name", query);
+#ifdef HAVE_LIBMYSQLCLIENT
+	if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed: %s\n", mysql_error(&mysql));
+		return 1;
+	} else {
+	    result=mysql_store_result(&mysql);
+	    while (row=mysql_fetch_row(result)){
+		fprintf(stdout, "%s. %s\t[%s] (%s)\n", row[2], row[1], row[3], row[4]);
+	    }
+	}
+	mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	rc=sqlite_exec(sqlite_db, query, query_disk_callback, 0, &errmsg);
+	if (rc!=SQLITE_OK){
+	    fprintf(stderr, "%s\n", errmsg);
+	}
+	sqlite_close(sqlite_db);
+#endif
+    }
+}
+
+int add_type(char *type)
+{
+    if (connect_database()==0){
+	sprintf(query, "INSERT INTO type (name) VALUES (\"%s\");", type);
+#ifdef HAVE_LIBMYSQLCLIENT
+	if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed: %s\n", mysql_error(&mysql));
+		return 1;
+	}
+	mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	rc=sqlite_exec(sqlite_db, query, NULL, 0, &errmsg);
+	if (rc!=SQLITE_OK){
+	    fprintf(stderr, "%s\n", errmsg);
+	}
+	sqlite_close(sqlite_db);
+#endif
+    }
+}
+/*
+int query_type(char *type)
+{
+    if (connect_database()==0){
+        sprintf(query, "SELECT type.type_id, type.name FROM type", type);
+	if (strcmp(type, "*")!=0){
+	    sprintf(query, "%s WHERE UPPER(type.name)=UPPER(\"%s\")", query, type);
+	}
+	sprintf(query, "%s ORDER BY type.type_id", query);
+#ifdef HAVE_LIBMYSQLCLIENT
+	if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed: %s\n", mysql_error(&mysql));
+		return 1;
+	} else {
+	    result=mysql_store_result(&mysql);
+	}
+	mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	rc=sqlite_exec(sqlite_db, query, NULL, 0, &errmsg);
+	if (rc!=SQLITE_OK){
+	    fprintf(stderr, "%s\n", errmsg);
+	}
+	sqlite_close(sqlite_db);
+#endif
+    }
+}
+*/
+static int switch_type_callback(void *retval, int argc, char **argv, char **colname)
+{
+    int *i = (int *)retval;
+    printf("argv: %s\n", argv[0]);
+    *i=(argv[0] ? atoi(argv[0]) : 0);
+    return 0;
+}
+
+int switch_type(char *type)
+{
+	int i;
+	//SQLITE_RES *result;
+	//char **result_set;
+	//int nrow;
+	//int ncol;
+
+	if (connect_database()==0){
+    	    sprintf(query, "SELECT type.type_id, type.name FROM type WHERE UPPER('%s')=UPPER(type.name) ORDER BY type.type_id", type);
+#ifdef HAVE_LIBMYSQLCLIENT
+	    if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed: %s\n", mysql_error(&mysql));
+		return 1;
+	    } else {
+		result=mysql_store_result(&mysql);
+		if (mysql_num_rows(result)>0){
+		    row=mysql_fetch_row(result);
+		    i=atoi(row[0]);
+		} else {
+		    i=0;
+		}
+	    }
+	    mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	//rc=sqlite_exec(sqlite_db, query, switch_type_callback, &i, &errmsg);
+	result=(SQLITE_RES *)malloc(sizeof(SQLITE_RES));
+	rc=sqlite_get_table(sqlite_db, query, &result->result, &result->nrow, &result->ncol, &errmsg);
+	if (rc!=SQLITE_OK){
+	    fprintf(stderr, "Failed: %s\n", errmsg);
+	    return 1;
+	}
+	if (result->nrow>0) {
+	    printf("Rows: %d\nCols: %d\nResult[4]: %s\n", result->nrow, result->ncol, result->result[2]);
+	    i=atoi(result->result[2]);
+	} else i=0;
+	sqlite_free_table(result->result);
+	free(result);
+	sqlite_close(sqlite_db);
+#endif
+	}
+	printf("Return value: %d\n", i);
+	return i;
+}
+
+static int delete_disk_callback(void *notused, int argc, char **argv, char **colname)
+{
+    i=atoi(argv[0]);
+    return i;
+}
+
+int delete_disk(char *cdname, int no, char *type)
+{
+	int *retval, type_no;
+
+	type_no=switch_type(type);
+	if (connect_database()==0){
+	    sprintf(query, "SELECT cd.cd_id FROM cd WHERE UPPER(cd.name)=UPPER(\"%s\") AND cd.number=%d AND cd.type=%d", cdname, no, type_no);
+#ifdef HAVE_LIBMYSQLCLIENT
+	    if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed_sel_disk: %s\n", mysql_error(&mysql));
+		return 1;
+	    } else {
+		result=mysql_store_result(&mysql);
+		row=mysql_fetch_row(result);
+		retval=atoi(row[0]);
+	    }
+	    mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	    rc=sqlite_exec(sqlite_db, query, switch_type_callback, &retval, &errmsg);
+	    if (rc!=SQLITE_OK){
+		fprintf(stderr, "%s\n", errmsg);
+	    }
+	    sqlite_close(sqlite_db);
+#endif
+	}
+	if (connect_database()==0){
+	    sprintf(query, "DELETE FROM cd WHERE UPPER(cd.name)=UPPER(\"%s\") AND cd.number=%d AND cd.type=%d", cdname, no, type_no);
+#ifdef HAVE_LIBMYSQLCLIENT
+	    if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed_del_disk: %s\n", mysql_error(&mysql));
+		return 1;
+	    }
+	    mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	    rc=sqlite_exec(sqlite_db, query, NULL, 0, &errmsg);
+	    if (rc!=SQLITE_OK){
+		fprintf(stderr, "%s\n", errmsg);
+	    }
+	    sqlite_close(sqlite_db);
+#endif
+	}
+	return *retval;
+}
+
+int delete_content(int cd_id)
+{
+	if (connect_database()==0){
+	    sprintf(query, "DELETE FROM content WHERE content.cd_id=%d", cd_id);
+#ifdef HAVE_LIBMYSQLCLIENT
+	    if (mysql_query(&mysql, query)) {
+		fprintf(stderr, "Failed_del_content: %s\n", mysql_error(&mysql));
+		return 1;
+	    }
+	    mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	    rc=sqlite_exec(sqlite_db, query, NULL, 0, &errmsg);
+	    if (rc!=SQLITE_OK){
+		fprintf(stderr, "%s\n", errmsg);
+	    }
+	    sqlite_close(sqlite_db);
+#endif
+	}
+}
+
+// MUST REVIEW LATER
+int delete_type(char *type)
+{
+    int type_no;
+    int cds[1000], i=0, z;
+
+    type_no=switch_type(type);
+    if (connect_database()==0){
+        sprintf(query, "DELETE FROM type WHERE type.type_id=%d", type_no);
+#ifdef HAVE_LIBMYSQLCLIENT
+        if (mysql_query(&mysql, query)) {
+    	    fprintf(stderr, "Failed_del_content: %s\n", mysql_error(&mysql));
+	    return 1;
+	}
+	mysql_close(&mysql);
+#endif
+#ifdef HAVE_LIBSQLITE
+	rc=sqlite_exec(sqlite_db, query, NULL, 0, &errmsg);
+	if (rc!=SQLITE_OK){
+	    fprintf(stderr, "%s\n", errmsg);
+	}
+	sqlite_close(sqlite_db);
+#endif
+    }
+    if (connect_database()==0){
+	sprintf(query, "SELECT cd.cd_id FROM cd WHERE cd.type=%d", type_no);
+#ifdef HAVE_LIBMYSQLCLIENT
+	if (mysql_query(&mysql, query)) {
+	    fprintf(stderr, "Failed_sel_disk: %s\n", mysql_error(&mysql));
+	    return 1;
+	} else {
+	    result=mysql_store_result(&mysql);
+	    i=0;
+	    while (row=mysql_fetch_row(result)){
+		cds[i]=atoi(row[0]);
+		i++;
+	    }
+	}
+	mysql_close(&mysql);
+#endif
+    }
+    if (connect_database()==0){
+    	sprintf(query, "DELETE FROM cd WHERE cd.type=%d", type_no);
+#ifdef HAVE_LIBMYSQLCLIENT
+    	if (mysql_query(&mysql, query)) {
+    	    fprintf(stderr, "Failed_del_content: %s\n", mysql_error(&mysql));
+	    return 1;
+	}
+	mysql_close(&mysql);
+#endif
+    }
+    for (z=0; z<i; z++){
+	if (connect_database()==0){
+    	    sprintf(query, "DELETE FROM content WHERE content.cd_id=%d", cds[z]);
+#ifdef HAVE_LIBMYSQLCLIENT
+    	    if (mysql_query(&mysql, query)) {
+    		fprintf(stderr, "Failed_del_content: %s\n", mysql_error(&mysql));
+		return 1;
+	    }
+	    mysql_close(&mysql);
+#endif
+	}
+    }
+}
+
+main(int argc, int argv[]){
+#ifdef HAVE_LIBMYSQLCLIENT
+	MYSQL_ROW row;
+	MYSQL_RES *result;
+	MYSQL connection;
+#endif
+	int num;
+	int i, ch;
+
+#ifdef HAVE_LIBMYSQLCLIENT
+	cdbpass=getpass(gettext("Enter password: "));
+#endif
+#ifdef HAVE_LIBSQLITE
+	result=(SQLITE_RES *)malloc(sizeof(SQLITE_RES));
+#endif
+	read_conf();
+	if ( argc>1 ) {
+	    if (strcmp((char *)argv[1],"add")==0){
+		int id;
+		printf("Add disk...");
+		if (switch_type((char *)argv[4])==0){
+		    printf("Type added: %s\n", argv[4]);
+		    add_type((char *)argv[4]);
+		}
+		id=add_disk((char *)argv[2], atoi(argv[3]), switch_type((char *)argv[4]), (char *)argv[5]);
+		add_content(config.mountpoint, id);
+		printf("done\n");
+	    }
+	    if (strcmp((char *)argv[1],"search")==0){
+		search_content((char *)argv[2], "*", "*", "*");
+	    }
+	    if (strcmp((char *)argv[1],"show")==0){
+		query_content("*", (char *)argv[2], "*");
+	    }
+	    if (strcmp((char *)argv[1],"delete")==0){
+		int cd_id;
+		cd_id=delete_disk((char *)argv[2], atoi(argv[3]), (char *)argv[4]);
+		delete_content(cd_id);
+	    }
+	    if (strcmp((char *)argv[1],"list")==0){
+		if (argc==2) {
+		    query_disk("*", 0, "*");
+		} else {
+		    if (strcmp((char *)argv[2],"-c")==0){
+			query_disk("*", 0, (char *)argv[3]);
+		    }
+		}
+//		query_content("*", 0);
+	    }
+	} else {
+	    printf("Usage: %s [options] command\n", argv[0]);
+	    printf("  add     <name> <no> <category> <date>   - add a new disk to the catalog\n");
+	    printf("  search  <string>                        - search files in the catalog\n");
+	    printf("  show    <name>                          - show the contents of disk\n");
+	    printf("  list    [-c <category>]                 - list disknames\n");
+	}
+}
diff -Naur orig/tools/Makefile.am patched/tools/Makefile.am
--- orig/tools/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ patched/tools/Makefile.am	2004-02-07 14:16:01.000000000 +0100
@@ -0,0 +1,30 @@
+## Makefile.am -- Process this file with automake to produce Makefile.in
+## Copyright (C) 2000 Gary V. Vaughan
+##
+## This program is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with this program; if not, write to the Free Software
+## Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+if MYSQL_SUPPORT
+MAINTAINERCLEANFILES = Makefile.in
+bin_PROGRAMS	= cdwdic
+cdwdic_SOURCES	= cdwdic.c
+cdwdic_LDFLAGS	= ../src/color.o ../src/options.o
+else 
+if SQLITE_SUPPORT
+MAINTAINERCLEANFILES = Makefile.in
+bin_PROGRAMS	= cdwdic
+cdwdic_SOURCES	= cdwdic.c
+cdwdic_LDFLAGS	= ../src/color.o ../src/options.o
+endif
+endif
