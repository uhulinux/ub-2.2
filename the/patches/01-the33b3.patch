diff -Naurd orig/calc.c mod/calc.c
--- orig/calc.c	1970-01-01 01:00:00.000000000 +0100
+++ mod/calc.c	2009-03-09 10:58:00.000000000 +0100
@@ -0,0 +1,687 @@
+#define HAVE_CALCULATOR
+#include <string.h>
+/*#define TEST*/
+
+
+#ifdef TEST
+#include <errno.h>
+char *itoa(int value, char *string, int radix)
+{
+  char tmp[33];
+  char *tp = tmp;
+  int i;
+  unsigned v;
+  int sign;
+  char *sp;
+  if (radix > 36 || radix <= 1)
+  {
+    errno = EDOM;
+    return 0;
+  }
+  sign = (radix == 10 && value < 0);
+  if (sign)
+    v = -value;
+  else
+    v = (unsigned)value;
+  while (v || tp == tmp)
+  {
+    i = v % radix;
+    v = v / radix;
+    if (i < 10)
+      *tp++ = i+'0';
+    else
+      *tp++ = i + 'a' - 10;
+  }
+  if (string == 0)
+    string = (char *)malloc((tp-tmp)+sign+1);
+  sp = string;
+  if (sign)
+    *sp++ = '-';
+  while (tp > tmp)
+    *sp++ = *--tp;
+  *sp = 0;
+  return string;
+}
+#endif
+/*****************************************************************************
+
+ Advanced parser. It supports all the functions found in ML's parser and also
+ definition of variables, functions and loops.
+ Created by Burton Radons <loth@pacificcoast.net>.
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <math.h>
+#include <setjmp.h>
+#include <stdio.h>
+#include <stdlib.h>
+#define Uses_string
+
+#ifdef HAVE_CALCULATOR
+
+#define isprenum(STR) (STR == '.' || (STR >= '0' && STR <= '9'))
+#define isprevar(STR) (STR == '_' || (STR >= 'a' && STR <= 'z') || (STR >= 'A' && STR <= 'Z'))
+#define isintvar(STR) (isprevar (STR) || (STR >= '0' && STR <= '9'))
+#define isexpr(STR)   (!isintvar (STR))
+
+#define resize(PTR, LEN) ((PTR) = realloc (PTR, sizeof (*(PTR)) * (LEN)))
+#define matchlen(NAME) ((int) (end - top) == (len = strlen (NAME)) && !strncasecmp (top, NAME, len))
+#define opsdo(NAME, LEN, EXPR) if (matchops (NAME, LEN)) EXPR
+#define findtop() for (top = str; isintvar (*str); str ++); end = str;
+#define matchops(NAME, LEN) (!strncmp (ops, NAME, LEN) && skipops (LEN))
+
+#define ltype long long
+#define lprint "ll"
+
+#define ftype long double
+#define fprint "L"
+
+static char *str = NULL;
+static char ops [16];
+static ftype arg [16];
+static int cfun = -1;
+static jmp_buf jmp;
+static char *ret;
+static int pradix;
+
+static char form[] = "%.10"fprint"g";
+#define DEFFUN1 "min(a,b)=a<b?a:b; max(a,b)=a>b?a:b"
+#define DEFFUN2 "sgn(x) = x<0?-1:(1-(0==x))"
+#define DEFFUN3 "root(x,y)= y**(1/x)"
+#define DEFFUN4 "PI=4*atan(1); E=exp(1)"
+#define DEFFUN5 "PHI=(sqrt(5)+1)/2"
+#define DEFFUN6 "DEG=180/(4*atan(1))"
+#define DEFFUN7 "rad(x) = x?(x*(4*atan(1)))/180:0"
+#define DEFFUN8 "lg(x,y)=(x!=1)?log(y)/log(x):1/0"
+#define DEFFUN9 "int(x) =x<0?ceil(x):floor(x)"
+#define DEFFU10 "frac(x)=x%1; div(a,b)=int(a/b)"
+#define DEFFU11 "fact(x)=x>0?x*fact(x-1):1"
+#define DEFFU12 "binom(a,b)=fact(a)/(fact(b)*fact(a-b))"
+#define DEFFU13 "sec(x)=1/cos(x), csec(x)=1/sin(x)"
+#define DEFFU14 "ctg(x)=cos(x)/sin(x)"
+#define DEFFU15 "cth(x)=(exp(2*x)+1)/(exp(2*x)-1)"
+#define DEFFU16 "acth(x)=0.5*log((x+1)/(x-1))"
+#define DEFFU17 "ln(x)=log(x); iif(a,b,c)=(a!=0)?b:c"
+#define DEFFU18 "GAMMA=.57721566490153286060"
+#define DEFFU19 "RAD =0.01745329251994329576"
+#define DEFFU20 "maxint=18446744073709551615."
+/*#define DEFFU20 "maxint=0x7fffffff; minint=-maxint"*/
+#define CDEF_NUM 20
+#define CHLP_NUM 24
+#define PREC_NUM 17
+
+char *calchlp[CHLP_NUM] =
+{
+"Operators:                   Functions:",
+"(in decreasing precedence)    abs,int,frac,min,max,sgn,ceil,floor,round,mod,div",
+"                              sin,cos,tan,sinh,cosh,tanh,asin,acos,atan",
+"   ~ unary not                atn2,asinh,acosh,atanh,sec,csec,ctg,cth,acth",
+"   - unary minus              lg,ln,log,log10,exp,pow,sqrt,root,cbrt,hypot",
+"-------                       pi,e,phi,gamma,deg,rad,gcd,lcm,fact,binom,prec",
+"  ** power                    bin,oct,dec,hex - Radix conversion.",
+"-------",
+"   * multiplication          Previous: '=',  Separator: ';'",
+"   / division                Help: 'help',  Quit: 'exit'",
+"   % modulo",
+"-------                      Examples: (defined)",
+"   + plus                     "DEFFUN1,
+"   - binary minus             "DEFFUN2,
+"-------                       "DEFFUN3,
+"  << shift left               "DEFFUN4,
+"  >> shift right              "DEFFUN5,
+"-------                       "DEFFUN6,
+"   & logical and              "DEFFUN7,
+"-------                       "DEFFUN8,
+"   ^ logical xor              "DEFFUN9,
+"-------                       "DEFFU10,
+"   | logical or               "DEFFU11,
+""
+};
+
+char *calcdef[CDEF_NUM+1] = { DEFFUN1, DEFFUN2, DEFFUN3, DEFFUN4, DEFFUN5,
+  DEFFUN6, DEFFUN7, DEFFUN8, DEFFUN9, DEFFU10, DEFFU11, DEFFU12, DEFFU13,
+  DEFFU14, DEFFU15, DEFFU16, DEFFU17, DEFFU18, DEFFU19, DEFFU20 };
+
+typedef ftype (*bfuntype) (ftype a);
+#define easy(NAME) static ftype fun_##NAME (ftype a) { return NAME (a); }
+easy (sin); easy (cos); easy (tan); easy (sinh); easy (cosh); easy (tanh);
+easy (asin); easy (acos); easy (atan); easy (log); easy (log10); easy (exp);
+easy (abs); easy (sqrt); easy (ceil); easy (floor);
+easy (acosh); easy (asinh); easy (atanh); easy (cbrt);
+#undef easy
+#define easy(NAME, RADIX) static ftype fun_##NAME (ftype a) { pradix = RADIX; return a; }
+easy (bin, 2); easy (oct, 8); easy (dec, 10); easy (hex, 16);
+#undef easy
+
+typedef ftype (*bfu2type) (ftype a, ftype b);
+#define easy(NAME) static ftype fun_##NAME(ftype a,ftype b) {return NAME(a,b);}
+easy(pow); easy(atan2); easy(hypot);
+#undef easy
+
+static ftype fun_prec(ftype a)
+{
+  unsigned short dec;
+  char *fstr = form;
+  dec = (unsigned short) a;
+  if (dec<PREC_NUM)
+  {
+    fstr += 2;
+    sprintf(fstr, "%02d", dec);
+    strcat(form, fprint"g");
+    return 0.;
+  }
+  return (-1.);
+}
+
+static long int lko(long int a, long int b)
+{
+  if (a==b) return a;
+  if (a<b) return lko(a,b-a);
+  return lko(a-b,b);
+}
+
+static ftype fun_gcd(ftype aa, ftype bb)
+{
+  long int a,b;
+  if (aa!=(aa-fmod(aa,1)) || bb!=(bb-fmod(bb,1)))
+    return 0.;
+  a = (int) abs(aa);
+  b = (int) abs(bb);
+  return (ftype) lko(a,b);
+}
+
+static ftype fun_lcm(ftype aa, ftype bb)
+{
+  long int a,b;
+  if (aa!=(aa-fmod(aa,1)) || bb!=(bb-fmod(bb,1)))
+    return 0.;
+  a = (int) abs(aa);
+  b = (int) abs(bb);
+  return ((a*b)/lko(a,b));
+}
+
+static ftype fun_mod(ftype a, ftype b)
+{
+  return fmod(a,b);
+}
+
+static ftype fun_round(ftype a, ftype b)
+{
+  int dec = (int)b;
+  return floor(a*pow(10.,dec)+.5)/pow(10.,dec);
+}
+
+static char *bfunn [] =
+  { "sin", "cos", "tan", "sinh", "cosh", "tanh", "asin", "acos",
+    "atan", "log", "log10", "exp", "abs", "sqrt", "ceil", "floor",
+    "bin", "oct", "dec", "hex", "acosh", "asinh", "atanh", "cbrt",
+    "prec", "pow", "mod", "round", "atan2", "hypot", "gcd", "lcm" };
+static bfuntype bfunp [] =
+  { fun_sin, fun_cos, fun_tan, fun_sinh, fun_cosh, fun_tanh, fun_asin,
+    fun_acos, fun_atan, fun_log, fun_log10, fun_exp, fun_abs, fun_sqrt,
+    fun_ceil, fun_floor, fun_bin, fun_oct, fun_dec, fun_hex, fun_acosh,
+    fun_asinh, fun_atanh, fun_cbrt, fun_prec,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+static bfu2type bfun2 [] =
+  { fun_pow, fun_mod, fun_round, fun_atan2, fun_hypot, fun_gcd, fun_lcm };
+#define bnfun (int) (sizeof (bfunn) / sizeof (*bfunn))
+#define bnfu2 (int) (7 - bnfun)
+
+static char **funn = NULL;
+static char ***funa = NULL; /* Arguments name-list for temporary binding */
+static char **func = NULL; /* Function contents */
+static int nfun = 0;
+
+static char **varn = NULL;
+static ftype *varv = NULL;
+static int nvar = 0;
+
+static ftype expr (void);
+
+static void error (char *str)
+{
+   strcpy (ret, str);
+   longjmp (jmp, 1);
+}
+
+static char *My_strndup (char *ptr, int len)
+{
+   char *dat = malloc (len + 1);
+   memmove (dat, ptr, len);
+   dat [len] = '\0';
+   return dat;
+}
+
+static void skipspace (void)
+{
+   // The cast is a workaround for a bug in Solaris 9 for SPARC
+   while (isspace ((int)*str))
+      str ++;
+}
+
+static int skipops (int cnt)
+{
+   while (cnt --)
+   {
+      skipspace ();
+      str ++;
+   }
+   return 1;
+}
+
+static char *readops (void)
+{
+   char *top = str;
+   char *ptr = ops;
+   while (1)
+   {
+      skipspace ();
+      if (*str == '\0' || isintvar (*str))
+         break;
+      *ptr ++ = *str ++;
+   }
+   *ptr = '\0';
+   str = top;
+   return ops;
+}
+
+static ftype *findvar (char *top, char *end)
+{
+   int c, len;
+   if (cfun != -1)
+   {
+      for (c = 0; funa [cfun] [c] != NULL; c ++)
+         if (!strncasecmp (funa [cfun] [c], top, (int) (end - top)))
+            return &arg [c];
+   }
+   for (c = 0; c < nvar; c ++)
+      if (matchlen (varn [c]))
+         break;
+   if (c >= nvar)
+   {
+      resize (varn, c + 1);
+      resize (varv, c + 1);
+      varn [c] = My_strndup (top, (int) (end - top));
+      varv [c] = 0;
+      nvar ++;
+   }
+   return &varv [c];
+}
+
+static ftype readnum (void)
+{
+   ftype a [16];
+   int c, d, len;
+   char *top, *end;
+   ftype val = 0;
+   ftype val2= 0;
+   
+   skipspace ();
+   if (isprenum (*str))
+   {
+      if (*str == '0')
+      {
+         if (*++ str == 'x')
+            return strtol (str + 1, &str, 16);
+         else if (*str == 'b')
+            return strtol (str + 1, &str, 2);
+         else if (*str != '.')
+            return strtol (str, &str, 8);
+      }
+      val = strtod (str, &str);
+      if (*str == 'x')
+      {
+         if (val < 1 || val > 36)
+            error ("Radix out of range (from 2 to 36)\n");
+         val = strtol (str + 1, &str, (int) val);
+      }
+      return val;
+   }
+   else if (isexpr (*str))
+   {
+      readops ();
+           opsdo ("++", 2, { findtop (); return ++ *findvar (top, end); })
+      else opsdo ("--", 2, { findtop (); return -- *findvar (top, end); })
+      else opsdo ("-", 1, return -readnum ());
+      else opsdo ("+", 1, return readnum ());
+      else opsdo ("~", 1, return ~(ltype) readnum ());
+      else opsdo ("!", 1, return !readnum ());
+      else if (matchops ("(", 1))
+      {
+         ftype val = expr ();
+         while (*str == ',')
+            str ++, val = expr ();
+         readops ();
+         if (!matchops (")", 1))
+            error ("Unbalanced or illegal expression");
+         return val;
+      }
+   }
+   else if (isprevar (*str))
+   {
+      findtop ();
+      for (c = 0; c < bnfun; c ++)
+         if (matchlen (bfunn [c]))
+         {
+            readops ();
+            if (!matchops ("(", 1))
+               error ("Expected (");
+            val = expr ();
+            readops ();
+            if (bfunp[c] != NULL)
+            {
+              if (!matchops (")", 1))
+                 error ("Too many arguments");
+              return bfunp [c] (val);
+            }
+            else
+            {
+              if (!matchops (",", 1))
+                 error ("Expected ,");
+              val2 = expr ();
+              readops ();
+              if (!matchops (")", 1))
+                 error ("Too many arguments");
+              return bfun2[c+bnfu2](val, val2);
+            }
+         }
+
+      readops ();
+      if (matchops ("(", 1))
+      {
+         char *ostr;
+         int ocfun;
+         ftype val;
+
+         for (c = 0; str [c] != '('; c ++)
+            if (str [c] == ')')
+            {
+               str += c;
+               readops ();
+               str -= c;
+               if (ops [1] == '=' && ops [2] != '=')
+               {
+                  for (c = 0; c < nfun; c ++)
+                     if (matchlen (funn [c]))
+                        goto redef;
+                  goto newdef;
+               }
+               break;
+            }
+         for (c = 0; c < nfun; c ++)
+            if (matchlen (funn [c]))
+            {
+               for (d = 0; funa [c] [d] != NULL; d ++)
+               {
+                  a [d] = arg [d];
+                  arg [d] = expr ();
+                  readops ();
+                  if (!matchops (funa [c] [d + 1] != NULL ? "," : ")", 1))
+                     error ("Too few or too many arguments");
+               }
+               if (d == 0)
+               {
+                  readops ();
+                  if (!matchops (")", 1))
+                     error ("Expected )");
+               }
+               ostr = str;   str = func [c];
+               ocfun = cfun; cfun = c;
+               val = expr ();
+               while (*str == ',')
+                  str ++, val = expr ();
+               str = ostr;   cfun = ocfun;
+               while (d --)
+                  arg [d] = a [d];
+               return val;
+            }
+
+      newdef:
+         resize (funn, c + 1);
+         resize (funa, c + 1);
+         resize (func, c + 1);
+      redef:
+         funn [c] = My_strndup (top, (int) (end - top));
+         funa [c] = NULL;
+
+         readops (); d = 0;
+         if (!matchops (")", 1))
+         while (1)
+         {
+            for (top = str; isintvar (*str); str ++);
+            resize (funa [c], d + 1);
+            funa [c] [d] = My_strndup (top, (int) (str - top));
+            readops ();
+            d ++;
+            if (matchops (")", 1))
+               break;
+            else if (!matchops (",", 1))
+               error ("Broken command");
+         }
+
+         readops ();
+         if (!matchops ("=", 1))
+            error ("Expected =");
+         resize (funa [c], d + 1);
+         funa [c] [d] = NULL;
+         func [c] = strdup (str);
+         if (c >= nfun)
+            nfun ++;
+         str += strlen (str) - 1;
+         return 0;
+      }
+      else
+      {
+         ftype *vp = findvar (top, end);
+              opsdo ("=", 1, return *vp = expr ());
+         else opsdo ("+=", 2, return *vp += expr ());
+         else opsdo ("-=", 2, return *vp -= expr ());
+         else opsdo ("*=", 2, return *vp *= expr ());
+         else opsdo ("/=", 2, return *vp /= expr ());
+         else opsdo ("%=", 2, return *vp = fmod (*vp, expr ()));
+         else opsdo ("&=", 2, return *vp = (ltype) (*vp) & (ltype) expr ());
+         else opsdo ("^=", 2, return *vp = (ltype) (*vp) ^ (ltype) expr ());
+         else opsdo ("!=", 2, return *vp = (ltype) (*vp) | (ltype) expr ());
+         else opsdo ("<<=", 3, return *vp = (ltype) (*vp) << (ltype) expr ());
+         else opsdo (">>=", 3, return *vp = (ltype) (*vp) >> (ltype) expr ());
+         else opsdo ("++", 2, return (*vp) ++);
+         else opsdo ("--", 2, return (*vp) --);
+         else return *vp;
+      }
+   }
+   error ("Retarded command");
+   return 0;
+}
+
+static ftype term (int lvl)
+{
+   ftype val;
+   if (lvl -- < 0)
+      return readnum ();
+   val = term (lvl);
+   while (1)
+   {
+      readops ();
+      switch (lvl + 1)
+      {
+         case 0:
+            opsdo ("**", 2, val = pow (val, term (lvl)));
+            else
+               return val;
+            break;
+         case 1:
+                 opsdo ("*", 1, val *= term (lvl));
+            else opsdo ("/", 1, val /= term (lvl));
+            else opsdo ("%", 1, val = fmod (val, term (lvl)));
+            else return val;
+            break;
+         case 2:
+                 opsdo ("+", 1, val += term (lvl));
+            else opsdo ("-", 1, val -= term (lvl));
+            else return val;
+            break;
+         case 3:
+                 opsdo ("<<", 2, val = (ltype) val << (ltype) term (lvl));
+            else opsdo (">>", 2, val = (ltype) val >> (ltype) term (lvl));
+            else return val;
+            break;
+         case 4:
+                 opsdo ("<",  1, val = val <  term (lvl));
+            else opsdo ("<=", 2, val = val <= term (lvl));
+            else opsdo (">",  1, val = val >  term (lvl));
+            else opsdo (">=", 2, val = val >= term (lvl));
+            else return val;
+            break;
+         case 5:
+                 opsdo ("==", 2, val = val == term (lvl));
+            else opsdo ("!=", 2, val = val != term (lvl));
+            else return val;
+            break;
+         case 6:
+                 if (!strncmp (ops, "&&", 2)) return val;
+            else opsdo ("&", 1, val = (ltype) val & (ltype) term (lvl));
+            else return val;
+            break;
+         case 7:
+                 opsdo ("^", 1, val = (ltype) val ^ (ltype) term (lvl));
+            else return val;
+            break;
+         case 8:
+                 if (!strncmp (ops, "||", 2)) return val;
+            else opsdo ("|", 1, val = (ltype) val | (ltype) term (lvl));
+            else return val;
+            break;
+         case 9:
+                 opsdo ("&&", 2, val = val && term (lvl));
+            else return val;
+            break;
+         case 10:
+                 opsdo ("||", 2, val = val || term (lvl));
+            else return val;
+            break;
+         case 11:
+            if (matchops ("?", 1))
+            {
+               int c;
+               if (val)
+               {
+                  val = expr ();
+                  skipspace ();
+                  if (*str ++ != ':')
+                     error ("Expected :");
+                  for (c = 0; *str != '\0' && c >= 0; str ++)
+                     if (*str == '(') c ++;
+                     else if (*str == ')') c --;
+               }
+               else
+               {
+                  for (c = 0; *str != '\0' && c >= 0; str ++)
+                     if (*str == '?') c ++;
+                     else if (*str == ':') c --;
+                  if (str [-1] != ':')
+                     error ("Expected :");
+                  val = expr ();
+               }
+            }
+            else return val;
+      }
+   }
+}
+
+static ftype expr (void)
+{
+   return term (11);
+}
+
+static char ret_buffer[140];
+
+/* Evaluate str, printing the result to ret, return 0 on failure */
+int eval (char *_str, char **_ret)
+{
+   ftype val;
+   int c;
+   
+   pradix = 10;
+   str = _str;
+   *_ret = ret_buffer;
+   ret = ret_buffer;
+   if (setjmp (jmp))
+      return 1;
+   val = expr ();
+   while (*str == ',')
+      str ++, val = expr ();
+   if (*str != '\0' && *str != '\n')
+      error ("Broken command");
+   if (pradix == 10)
+      sprintf (ret, form, val);
+   else if (pradix == 16)
+      sprintf (ret, "0x%" lprint "X", (ltype) val);
+   else if (pradix == 8)
+      sprintf (ret, "0%" lprint "o", (ltype) val);
+   else if (pradix == 2)
+   {
+      if (val < 0)
+      {
+#ifdef TEST
+        itoa((ltype) val, ret, 2);
+        return 0;
+#else
+        error ("Negative value");
+#endif
+      }
+      ltype bin = val;
+      *ret ++ = '0';
+      *ret ++ = 'b';
+      if (bin > 0)
+         for (c = 0; bin >> c; c ++);
+      else
+         c = 64; /* Negative integers use all the bits ;-) SET */
+      if (c == 0)
+         *ret ++ = '0';
+      ret += c;
+      *ret -- = '\0';
+      for (; c--; bin >>= 1)
+         *ret -- = (bin & 1) + '0';
+   }
+   return 0;
+}
+
+void evalini()
+{
+  char *idx, *res;
+  short i;
+  char buf[133];
+  for (i=0; i<CDEF_NUM; i++)
+  {
+    strcpy((char *)buf, (char *)calcdef[i]);
+    idx = index(buf, ';');
+    while (idx != NULL)
+    {
+      idx[0] = '\0';
+      eval((char *)buf, &res);
+      idx++;
+      strcpy((char *)buf, (char *)idx);
+      idx = index(buf, ';');
+    }
+    eval((char *)buf, &res);
+  }
+}
+
+#ifdef TEST
+int main (int argc, char *argv [])
+{
+   char buf [256], *res, *s;
+   int c;
+   evalini();
+   printf ("Write expression, get answer.\n");
+   while (fgets (buf, 256, stdin) == buf)
+   {
+      eval (buf, &res);
+      printf ("   = %s\n", res);
+   }
+   return 0;
+}
+#endif /* TEST */
+
+#endif // HAVE_CALCULATOR
diff -Naurd orig/comm1.c mod/comm1.c
--- orig/comm1.c	2008-01-16 14:02:52.000000000 +0100
+++ mod/comm1.c	2009-11-06 21:48:44.000000000 +0100
@@ -42,7 +42,6 @@
 /*#define DEBUG 1*/
 
 /*man-start*********************************************************************
-
 
 ========================================================================
 COMMAND REFERENCE
@@ -366,6 +365,142 @@
    TRACE_RETURN();
    return(rc);
 }
+
+short Format(CHARTYPE *,short,bool);
+
+#ifndef to_upper
+#  define to_upper(c) (islower(c) ? toupper(c) : (c))
+#  define to_lower(c) (isupper(c) ? tolower(c) : (c))
+#endif
+
+#define ISOCTAL(c)	((c) >= '0' && (c) <= '7')
+#define OCTVALUE(c)	((c) - '0')
+
+//#ifndef isxdigit
+//#  define isxdigit(c)	(isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+//#endif
+
+#define HEXVALUE(c) \
+  ((c) >= 'a' && (c) <= 'f' ? (c)-'a'+10 : (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
+
+/* Convert STRING by expanding the escape sequences specified by the
+   ANSI C standard.  If SAWC is non-null, recognize `\c' and use that
+   as a string terminator.  If we see \c, set *SAWC to 1 before
+   returning.  LEN is the length of STRING.  FOR_ECHO is a flag that
+   means, if non-zero, that we're translating a string for `echo -e',
+   and therefore should not treat a single quote as a character that
+   may be escaped with a backslash. */
+char *
+ansicstr (string, len/*, for_echo, sawc, rlen*/)
+     char *string;
+     int len/*, for_echo, *sawc, *rlen*/;
+{
+  int c, temp;
+  char *ret, *r, *s;
+
+  if (string == 0 || *string == '\0')
+    return ((char *)NULL);
+
+  ret = (char *) malloc(len + 1);
+  for (r = ret, s = string; s && *s; )
+    {
+      c = *s++;
+      if (c != '\\' || *s == '\0')
+        *r++ = c;
+      else
+	{
+	  switch (c = *s++)
+	    {
+#if defined (__STDC__)
+	    case 'a': c = '\a'; break;
+	    case 'v': c = '\v'; break;
+#else
+	    case 'a': c = '\007'; break;
+	    case 'v': c = (int) 0x0B; break;
+#endif
+	    case 'b': c = '\b'; break;
+	    case 'e': case 'E':		/* ESC -- non-ANSI */
+	      c = '\033'; break;
+	    case 'f': c = '\f'; break;
+	    case 'n': c = '\n'; break;
+	    case 'r': c = '\r'; break;
+	    case 't': c = '\t'; break;
+	    case '0': case '1': case '2': case '3':
+	    case '4': case '5': case '6': case '7':
+	      for (temp = 2, c -= '0'; ISOCTAL (*s) && temp--; s++)
+	        c = (c * 8) + OCTVALUE (*s);
+	      break;
+	    case 'x':			/* Hex digit -- non-ANSI */
+	      for (temp = 3, c = 0; isxdigit (*s) && temp--; s++)
+	        c = (c * 16) + HEXVALUE (*s);
+	      /* \x followed by non-hex digits is passed through unchanged */
+	      if (temp == 3)
+		{
+		  *r++ = '\\';
+		  c = 'x';
+		}
+	      break;
+	    case '\\':
+	      break;
+	    case '\'':
+/*
+	      if (for_echo)
+		*r++ = '\\';
+*/
+	      break;
+	    case 'c':
+/*
+	      if (sawc)
+		{
+		  *sawc = 1;
+		  *r = '\0';
+		  if (rlen)
+		    *rlen = r - ret;
+		  return ret;
+		}
+*/
+	    default:  *r++ = '\\'; break;
+	    }
+	  *r++ = c;
+	}
+    }
+  *r = '\0';
+/*
+  if (rlen)
+    *rlen = r - ret;
+*/
+  return ret;
+}
+
+/*man-start*********************************************************************
+COMMAND
+     ansicstr - expand ANSI C escape sequences
+
+SYNTAX
+     ANSICstr [target]
+
+DESCRIPTION
+     Convert current line by expanding the escape sequences
+     specified by the ANSI C standard.
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Ansicstr(CHARTYPE *params)
+#else
+short Ansicstr(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm1.c:   Ansicstr");
+  rc = Format((DEFCHAR *)params,F_UNESC,TRUE);
+  TRACE_RETURN();
+  return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      backward - scroll backwards [n] screens
@@ -478,6 +613,590 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*****************************************************************
+ * SYSVbanner.c
+ * This is a PD version of the SYS V banner program (at least I think 
+ * it is compatible to SYS V) which I wrote to use with the clock 
+ * program written by:
+ **     DCF, Inc.
+ **     14623 North 49th Place
+ **     Scottsdale, AZ 85254
+ * and published in the net comp.sources.misc newsgroup in early July 
+ * since the BSD banner program works quite differently.
+ * There is no copyright or responsibility accepted for the use
+ * of this software.
+ * Brian Wallis, brw@jim.odr.oz, 4 July 1988
+ *****************************************************************/
+/* Changes by David Frey, david@eos.lugs.ch, 3 February 1997:
+ * 1. protoized and indented, 2. changed @ character to # 
+ */
+char *glyphs[] =
+{
+  "         ###  ### ###  # #   ##### ###   #  ##     ###  ",
+  "         ###  ### ###  # #  #  #  ## #  #  #  #    ###  ",
+  "         ###   #   # ########  #   ### #    ##      #   ",
+  "          #            # #   #####    #    ###     #    ",
+  "                     #######   #  #  # ####   # #       ",
+  "         ###           # #  #  #  # #  # ##    #        ",
+  "         ###           # #   ##### #   ### #### #       ",
+
+  "   ##    ##                                            #",
+  "  #        #   #   #    #                             # ",
+  " #          #   # #     #                            #  ",
+  " #          # ### ### #####   ###   #####           #   ",
+  " #          #   # #     #     ###           ###    #    ",
+  "  #        #   #   #    #      #            ###   #     ",
+  "   ##    ##                   #             ###  #      ",
+
+  "  ###     #    #####  ##### #      ####### ##### #######",
+  " #   #   ##   #     ##     ##    # #      #     ##    # ",
+  "# #   # # #         #      ##    # #      #          #  ",
+  "#  #  #   #    #####  ##### ####### ##### ######    #   ",
+  "#   # #   #   #            #     #       ##     #  #    ",
+  " #   #    #   #      #     #     # #     ##     #  #    ",
+  "  ###   ##### ####### #####      #  #####  #####   #    ",
+
+  " #####  #####    #     ###      #           #     ##### ",
+  "#     ##     #  # #    ###     #             #   #     #",
+  "#     ##     #   #            #     #####     #        #",
+  " #####  ######         ###   #                 #     ## ",
+  "#     #      #   #     ###    #     #####     #     #   ",
+  "#     ##     #  # #     #      #             #          ",
+  " #####  #####    #     #        #           #       #   ",
+
+  " #####    #   ######  ##### ###### ############## ##### ",
+  "#     #  # #  #     ##     ##     ##      #      #     #",
+  "# ### # #   # #     ##      #     ##      #      #      ",
+  "# # # ##     ####### #      #     ######  #####  #  ####",
+  "# #### ########     ##      #     ##      #      #     #",
+  "#     ##     ##     ##     ##     ##      #      #     #",
+  " ##### #     #######  ##### ###### ########       ##### ",
+
+  "#     #  #*#        ##    # #      #     ##     ########",
+  "#     #   #         ##   #  #      ##   ####    ##     #",
+  "#     #   #         ##  #   #      # # # ## #   ##     #",
+  "#######   #         ####    #      #  #  ##  #  ##     #",
+  "#     #   #   #     ##  #   #      #     ##   # ##     #",
+  "#     #   #   #     ##   #  #      #     ##    ###     #",
+  "#     #  ###   ##### #    # ########     ##     ########",
+
+  "######  ##### ######  ##### ########     ##     ##     #",
+  "#     ##     ##     ##     #   #   #     ##     ##  #  #",
+  "#     ##     ##     ##         #   #     ##     ##  #  #",
+  "###### #     #######  #####    #   #     ##     ##  #  #",
+  "#      #   # ##   #        #   #   #     # #   # #  #  #",
+  "#      #    # #    # #     #   #   #     #  # #  #  #  #",
+  "#       #### ##     # #####    #    #####    #    ## ## ",
+
+  "#     ##     ######## ##### #       #####    #          ",
+  " #   #  #   #      #  #      #          #   # #         ",
+  "  # #    # #      #   #       #         #  #   #        ",
+  "   #      #      #    #        #        #               ",
+  "  # #     #     #     #         #       #               ",
+  " #   #    #    #      #          #      #               ",
+  "#     #   #   ####### #####       # #####        #######",
+
+  "  ###                                                   ",
+  "  ###     ##   #####   ####  #####  ###### ######  #### ",
+  "   #     #  #  #    # #    # #    # #      #      #    #",
+  "    #   #    # #####  #      #    # #####  #####  #     ",
+  "        ###### #    # #      #    # #      #      #  ###",
+  "        #    # #    # #    # #    # #      #      #    #",
+  "        #    # #####   ####  #####  ###### #       #### ",
+
+  "                                                        ",
+  " #    #    #        # #    # #      #    # #    #  #### ",
+  " #    #    #        # #   #  #      ##  ## ##   # #    #",
+  " ######    #        # ####   #      # ## # # #  # #    #",
+  " #    #    #        # #  #   #      #    # #  # # #    #",
+  " #    #    #   #    # #   #  #      #    # #   ## #    #",
+  " #    #    #    ####  #    # ###### #    # #    #  #### ",
+
+  "                                                        ",
+  " #####   ####  #####   ####   ##### #    # #    # #    #",
+  " #    # #    # #    # #         #   #    # #    # #    #",
+  " #    # #    # #    #  ####     #   #    # #    # #    #",
+  " #####  #  # # #####       #    #   #    # #    # # ## #",
+  " #      #   #  #   #  #    #    #   #    #  #  #  ##  ##",
+  " #       ### # #    #  ####     #    ####    ##   #    #",
+
+  "                       ###     #     ###   ##    # # # #",
+  " #    #  #   # ###### #        #        # #  #  # # # # ",
+  "  #  #    # #      #  #        #        #     ## # # # #",
+  "   ##      #      #  ##                 ##        # # # ",
+  "   ##      #     #    #        #        #        # # # #",
+  "  #  #     #    #     #        #        #         # # # ",
+  " #    #    #   ######  ###     #     ###         # # # #"};
+
+int Vbanner(char *str)
+{
+  int a, b, c, len, ind;
+  char line[80];
+  len = strlen(str);
+  if (len > 10)
+    len = 10;
+  for (a = 0; a < 7; a++)
+  {
+    for (b = 0; b < len; b++)
+    {
+      if ((ind = str[b] - ' ') < 0)
+        ind = 0;
+      for (c = 0; c < 7; c++)
+      {
+         line[b * 8 + c] = glyphs[(ind / 8 * 7) + a][(ind % 8 * 7) + c];
+      }
+      line[b * 8 + 7] = ' ';
+    }
+    for (b = len * 8 - 1; b >= 0; b--)
+    {
+      if (line[b] != ' ')
+        break;
+      line[b] = '\0';
+    }
+    //puts(line);
+    Add("");
+    Replace(line);
+  }
+  //puts("");
+  Add("");
+  return 0;
+}
+
+/*
+ * The ultimative banner.
+ * Written in 1987 by Wolfgang Ocker, reccoware systems, Puchheim
+ * It's *not* fast, but nice ...
+ * Tested on OS-9/68000, SunOS
+ */
+void bannusage()
+{
+  display_error(0,"Syntax: banner [-v|-[c|d|i|s]|-h] {string} ",TRUE);
+}
+
+unsigned char charset[] = {
+  0, 0, 0, 0, 0, 0, 0, 0,
+  126, 129, 165, 129, 189, 153, 129, 126,
+  126, 255, 219, 255, 195, 231, 255, 126,
+  108, 254, 254, 254, 124, 56, 16, 0,
+  16, 56, 124, 254, 124, 56, 16, 0,
+  56, 124, 56, 254, 254, 124, 56, 124,
+  16, 16, 56, 124, 254, 124, 56, 124,
+  0, 0, 24, 60, 60, 24, 0, 0,
+  255, 255, 231, 195, 195, 231, 255, 255,
+  0, 60, 102, 66, 66, 102, 60, 0,
+  255, 195, 153, 189, 189, 153, 195, 255,
+  15, 7, 15, 125, 204, 204, 204, 120,
+  60, 102, 102, 102, 60, 24, 126, 24,
+  63, 51, 63, 48, 48, 112, 240, 224,
+  127, 99, 127, 99, 99, 103, 230, 192,
+  153, 90, 60, 231, 231, 60, 90, 153,
+  128, 224, 248, 254, 248, 224, 128, 0,
+  2, 14, 62, 254, 62, 14, 2, 0,
+  24, 60, 126, 24, 24, 126, 60, 24,
+  102, 102, 102, 102, 102, 0, 102, 0,
+  127, 219, 219, 123, 27, 27, 27, 0,
+  62, 99, 56, 108, 108, 56, 204, 120,
+  0, 0, 0, 0, 126, 126, 126, 0,
+  24, 60, 126, 24, 126, 60, 24, 255,
+  24, 60, 126, 24, 24, 24, 24, 0,
+  24, 24, 24, 24, 126, 60, 24, 0,
+  0, 24, 12, 254, 12, 24, 0, 0,
+  0, 48, 96, 254, 96, 48, 0, 0,
+  0, 0, 192, 192, 192, 254, 0, 0,
+  0, 36, 102, 255, 102, 36, 0, 0,
+  0, 24, 60, 126, 255, 255, 0, 0,
+  0, 255, 255, 126, 60, 24, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  48, 120, 120, 48, 48, 0, 48, 0,
+  108, 108, 108, 0, 0, 0, 0, 0,
+  108, 108, 254, 108, 254, 108, 108, 0,
+  48, 124, 192, 120, 12, 248, 48, 0,
+  0, 198, 204, 24, 48, 102, 198, 0,
+  56, 108, 56, 118, 220, 204, 118, 0,
+  96, 96, 192, 0, 0, 0, 0, 0,
+  24, 48, 96, 96, 96, 48, 24, 0,
+  96, 48, 24, 24, 24, 48, 96, 0,
+  0, 102, 60, 255, 60, 102, 0, 0,
+  0, 48, 48, 252, 48, 48, 0, 0,
+  0, 0, 0, 0, 0, 48, 48, 96,
+  0, 0, 0, 252, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 48, 48, 0,
+  6, 12, 24, 48, 96, 192, 128, 0,
+  124, 198, 206, 222, 246, 230, 124, 0,
+  48, 112, 48, 48, 48, 48, 252, 0,
+  120, 204, 12, 56, 96, 204, 252, 0,
+  120, 204, 12, 56, 12, 204, 120, 0,
+  28, 60, 108, 204, 254, 12, 30, 0,
+  252, 192, 248, 12, 12, 204, 120, 0,
+  56, 96, 192, 248, 204, 204, 120, 0,
+  252, 204, 12, 24, 48, 48, 48, 0,
+  120, 204, 204, 120, 204, 204, 120, 0,
+  120, 204, 204, 124, 12, 24, 112, 0,
+  0, 48, 48, 0, 0, 48, 48, 0,
+  0, 48, 48, 0, 0, 48, 48, 96,
+  24, 48, 96, 192, 96, 48, 24, 0,
+  0, 0, 252, 0, 0, 252, 0, 0,
+  96, 48, 24, 12, 24, 48, 96, 0,
+  120, 204, 12, 24, 48, 0, 48, 0,
+  124, 198, 222, 222, 222, 192, 120, 0,
+  48, 120, 204, 204, 252, 204, 204, 0,
+  252, 102, 102, 124, 102, 102, 252, 0,
+  60, 102, 192, 192, 192, 102, 60, 0,
+  248, 108, 102, 102, 102, 108, 248, 0,
+  254, 98, 104, 120, 104, 98, 254, 0,
+  254, 98, 104, 120, 104, 96, 240, 0,
+  60, 102, 192, 192, 206, 102, 62, 0,
+  204, 204, 204, 252, 204, 204, 204, 0,
+  120, 48, 48, 48, 48, 48, 120, 0,
+  30, 12, 12, 12, 204, 204, 120, 0,
+  230, 102, 108, 120, 108, 102, 230, 0,
+  240, 96, 96, 96, 98, 102, 254, 0,
+  198, 238, 254, 254, 214, 198, 198, 0,
+  198, 230, 246, 222, 206, 198, 198, 0,
+  56, 108, 198, 198, 198, 108, 56, 0,
+  252, 102, 102, 124, 96, 96, 240, 0,
+  120, 204, 204, 204, 220, 120, 28, 0,
+  252, 102, 102, 124, 108, 102, 230, 0,
+  120, 204, 224, 112, 28, 204, 120, 0,
+  252, 180, 48, 48, 48, 48, 120, 0,
+  204, 204, 204, 204, 204, 204, 252, 0,
+  204, 204, 204, 204, 204, 120, 48, 0,
+  198, 198, 198, 214, 254, 238, 198, 0,
+  198, 198, 108, 56, 56, 108, 198, 0,
+  204, 204, 204, 120, 48, 48, 120, 0,
+  254, 198, 140, 24, 50, 102, 254, 0,
+  120, 96, 96, 96, 96, 96, 120, 0,
+  192, 96, 48, 24, 12, 6, 2, 0,
+  120, 24, 24, 24, 24, 24, 120, 0,
+  16, 56, 108, 198, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 255,
+  48, 48, 24, 0, 0, 0, 0, 0,
+  0, 0, 120, 12, 124, 204, 118, 0,
+  224, 96, 96, 124, 102, 102, 220, 0,
+  0, 0, 120, 204, 192, 204, 120, 0,
+  28, 12, 12, 124, 204, 204, 118, 0,
+  0, 0, 120, 204, 252, 192, 120, 0,
+  56, 108, 96, 240, 96, 96, 240, 0,
+  0, 0, 118, 204, 204, 124, 12, 248,
+  224, 96, 108, 118, 102, 102, 230, 0,
+  48, 0, 112, 48, 48, 48, 120, 0,
+  12, 0, 12, 12, 12, 204, 204, 120,
+  224, 96, 102, 108, 120, 108, 230, 0,
+  112, 48, 48, 48, 48, 48, 120, 0,
+  0, 0, 204, 254, 254, 214, 198, 0,
+  0, 0, 248, 204, 204, 204, 204, 0,
+  0, 0, 120, 204, 204, 204, 120, 0,
+  0, 0, 220, 102, 102, 124, 96, 240,
+  0, 0, 118, 204, 204, 124, 12, 30,
+  0, 0, 220, 118, 102, 96, 240, 0,
+  0, 0, 124, 192, 120, 12, 248, 0,
+  16, 48, 124, 48, 48, 52, 24, 0,
+  0, 0, 204, 204, 204, 204, 118, 0,
+  0, 0, 204, 204, 204, 120, 48, 0,
+  0, 0, 198, 214, 254, 254, 108, 0,
+  0, 0, 198, 108, 56, 108, 198, 0,
+  0, 0, 204, 204, 204, 124, 12, 248,
+  0, 0, 252, 152, 48, 100, 252, 0,
+  28, 48, 48, 224, 48, 48, 28, 0,
+  24, 24, 24, 0, 24, 24, 24, 0,
+  224, 48, 48, 28, 48, 48, 224, 0,
+  118, 220, 0, 0, 0, 0, 0, 0,
+  0, 16, 56, 108, 198, 198, 254, 0,
+  120, 204, 192, 204, 120, 24, 12, 120,
+  0, 204, 0, 204, 204, 204, 126, 0,
+  28, 0, 120, 204, 252, 192, 120, 0,
+  126, 195, 60, 6, 62, 102, 63, 0,
+  204, 0, 120, 12, 124, 204, 126, 0,
+  224, 0, 120, 12, 124, 204, 126, 0,
+  48, 48, 120, 12, 124, 204, 126, 0,
+  0, 0, 120, 192, 192, 120, 12, 56,
+  126, 195, 60, 102, 126, 96, 60, 0,
+  204, 0, 120, 204, 252, 192, 120, 0,
+  224, 0, 120, 204, 252, 192, 120, 0,
+  204, 0, 112, 48, 48, 48, 120, 0,
+  124, 198, 56, 24, 24, 24, 60, 0,
+  224, 0, 112, 48, 48, 48, 120, 0,
+  198, 56, 108, 198, 254, 198, 198, 0,
+  48, 48, 0, 120, 204, 252, 204, 0,
+  28, 0, 252, 96, 120, 96, 252, 0,
+  0, 0, 127, 12, 127, 204, 127, 0,
+  62, 108, 204, 254, 204, 204, 206, 0,
+  120, 204, 0, 120, 204, 204, 120, 0,
+  0, 204, 0, 120, 204, 204, 120, 0,
+  0, 224, 0, 120, 204, 204, 120, 0,
+  120, 204, 0, 204, 204, 204, 126, 0,
+  0, 224, 0, 204, 204, 204, 126, 0,
+  0, 204, 0, 204, 204, 124, 12, 248,
+  195, 24, 60, 102, 102, 60, 24, 0,
+  204, 0, 204, 204, 204, 204, 120, 0,
+  24, 24, 126, 192, 192, 126, 24, 24,
+  56, 108, 100, 240, 96, 230, 252, 0,
+  204, 204, 120, 252, 48, 252, 48, 48,
+  248, 204, 204, 250, 198, 207, 198, 199,
+  14, 27, 24, 60, 24, 24, 216, 112,
+  28, 0, 120, 12, 124, 204, 126, 0,
+  56, 0, 112, 48, 48, 48, 120, 0,
+  0, 28, 0, 120, 204, 204, 120, 0,
+  0, 28, 0, 204, 204, 204, 126, 0,
+  0, 248, 0, 248, 204, 204, 204, 0,
+  252, 0, 204, 236, 252, 220, 204, 0,
+  60, 108, 108, 62, 0, 126, 0, 0,
+  56, 108, 108, 56, 0, 124, 0, 0,
+  48, 0, 48, 96, 192, 204, 120, 0,
+  0, 0, 0, 252, 192, 192, 0, 0,
+  0, 0, 0, 252, 12, 12, 0, 0,
+  195, 198, 204, 222, 51, 102, 204, 15,
+  195, 198, 204, 219, 55, 111, 207, 3,
+  24, 24, 0, 24, 24, 24, 24, 0,
+  0, 51, 102, 204, 102, 51, 0, 0,
+  0, 204, 102, 51, 102, 204, 0, 0,
+  34, 136, 34, 136, 34, 136, 34, 136,
+  85, 170, 85, 170, 85, 170, 85, 170,
+  219, 119, 219, 238, 219, 119, 219, 238,
+  24, 24, 24, 24, 24, 24, 24, 24,
+  24, 24, 24, 24, 248, 24, 24, 24,
+  24, 24, 248, 24, 248, 24, 24, 24,
+  54, 54, 54, 54, 246, 54, 54, 54,
+  0, 0, 0, 0, 254, 54, 54, 54,
+  0, 0, 248, 24, 248, 24, 24, 24,
+  54, 54, 246, 6, 246, 54, 54, 54,
+  54, 54, 54, 54, 54, 54, 54, 54,
+  0, 0, 254, 6, 246, 54, 54, 54,
+  54, 54, 246, 6, 254, 0, 0, 0,
+  54, 54, 54, 54, 254, 0, 0, 0,
+  24, 24, 248, 24, 248, 0, 0, 0,
+  0, 0, 0, 0, 248, 24, 24, 24,
+  24, 24, 24, 24, 31, 0, 0, 0,
+  24, 24, 24, 24, 255, 0, 0, 0,
+  0, 0, 0, 0, 255, 24, 24, 24,
+  24, 24, 24, 24, 31, 24, 24, 24,
+  0, 0, 0, 0, 255, 0, 0, 0,
+  24, 24, 24, 24, 255, 24, 24, 24,
+  24, 24, 31, 24, 31, 24, 24, 24,
+  54, 54, 54, 54, 55, 54, 54, 54,
+  54, 54, 55, 48, 63, 0, 0, 0,
+  0, 0, 63, 48, 55, 54, 54, 54,
+  54, 54, 247, 0, 255, 0, 0, 0,
+  0, 0, 255, 0, 247, 54, 54, 54,
+  54, 54, 55, 48, 55, 54, 54, 54,
+  0, 0, 255, 0, 255, 0, 0, 0,
+  54, 54, 247, 0, 247, 54, 54, 54,
+  24, 24, 255, 0, 255, 0, 0, 0,
+  54, 54, 54, 54, 255, 0, 0, 0,
+  0, 0, 255, 0, 255, 24, 24, 24,
+  0, 0, 0, 0, 255, 54, 54, 54,
+  54, 54, 54, 54, 63, 0, 0, 0,
+  24, 24, 31, 24, 31, 0, 0, 0,
+  0, 0, 31, 24, 31, 24, 24, 24,
+  0, 0, 0, 0, 63, 54, 54, 54,
+  54, 54, 54, 54, 255, 54, 54, 54,
+  24, 24, 255, 24, 255, 24, 24, 24,
+  24, 24, 24, 24, 248, 0, 0, 0,
+  0, 0, 0, 0, 31, 24, 24, 24,
+  255, 255, 255, 255, 255, 255, 255, 255,
+  0, 0, 0, 0, 255, 255, 255, 255,
+  240, 240, 240, 240, 240, 240, 240, 240,
+  15, 15, 15, 15, 15, 15, 15, 15,
+  255, 255, 255, 255, 0, 0, 0, 0,
+  0, 0, 118, 220, 200, 220, 118, 0,
+  0, 120, 204, 248, 204, 248, 192, 192,
+  0, 252, 204, 192, 192, 192, 192, 0,
+  0, 254, 108, 108, 108, 108, 108, 0,
+  252, 204, 96, 48, 96, 204, 252, 0,
+  0, 0, 126, 216, 216, 216, 112, 0,
+  0, 102, 102, 102, 102, 124, 96, 192,
+  0, 118, 220, 24, 24, 24, 24, 0,
+  252, 48, 120, 204, 204, 120, 48, 252,
+  56, 108, 198, 254, 198, 108, 56, 0,
+  56, 108, 198, 198, 108, 108, 238, 0,
+  28, 48, 24, 124, 204, 204, 120, 0,
+  0, 0, 126, 219, 219, 126, 0, 0,
+  6, 12, 126, 219, 219, 126, 96, 192,
+  56, 96, 192, 248, 192, 96, 56, 0,
+  120, 204, 204, 204, 204, 204, 204, 0,
+  0, 252, 0, 252, 0, 252, 0, 0,
+  48, 48, 252, 48, 48, 0, 252, 0,
+  96, 48, 24, 48, 96, 0, 252, 0,
+  24, 48, 96, 48, 24, 0, 252, 0,
+  14, 27, 27, 24, 24, 24, 24, 24,
+  24, 24, 24, 24, 24, 216, 216, 112,
+  48, 48, 0, 252, 0, 48, 48, 0,
+  0, 118, 220, 0, 118, 220, 0, 0,
+  56, 108, 108, 56, 0, 0, 0, 0,
+  0, 0, 0, 24, 24, 0, 0, 0,
+  0, 0, 0, 0, 24, 0, 0, 0,
+  15, 12, 12, 12, 236, 108, 60, 28 };
+
+char bannline[256];
+short banncnt;
+
+outline(outchar, outbyte, dblsize, bannerchar, samechar)
+  char outchar, outbyte, bannerchar;
+  int  dblsize, samechar;
+{
+  int bc, j;
+  for (bc = 7; bc >= 0; bc--)
+    for (j = 0; j < (dblsize ? 2 : 1); j++)
+      if (outbyte & (0x01 << bc))
+///*        putchar((samechar) ? outchar : bannerchar);*/
+      {
+        if (samechar)
+          bannline[banncnt] = outchar;
+        else
+          bannline[banncnt] = bannerchar;
+        banncnt++;
+      }
+      else
+///*        putchar(' ');*/
+      {
+        bannline[banncnt] = ' ';
+        banncnt++;
+      }
+}
+
+int bannstr(string)
+  char *string;
+{
+  char          *str;
+  int           linenum, chnum, i, j, k, count;
+  unsigned char ch;
+  int           ch_off;
+  unsigned char *ch_addr;
+  unsigned char *font;
+  int           italic, dblsize, samechar, sysv;
+  char          bannerchar;
+
+  italic     = dblsize = samechar = sysv = FALSE;
+  bannerchar = '*';
+  font       = charset;
+  str        = string;
+  if (string[0] == '-')
+  {
+    for (j = 1; (string[j] != ' ') && (j < strlen(string)); j++)
+    {
+      switch(tolower(string[j]))
+      {
+        case '?':
+        case 'h':
+          bannusage();
+          return(1);
+        case 'i': 	/* italic printing */
+          italic = TRUE;
+          break;          
+        case 'd': 	/* double sized characters */
+          dblsize = TRUE;
+          break;
+        case 's': 	/* use character to build large char, e.g.*/
+          samechar = TRUE;
+          break;
+        case 'v': 	/* SYS V */
+          sysv = TRUE;
+          break;
+        case 'c': 	/* character for banner */
+          j += string[j+1] == '=' ? 2 : 1;
+          bannerchar = string[j];
+          break;
+        default:
+          bannusage();
+          display_error(0,"banner: unknown option", TRUE);
+          return(1);
+      }
+    }
+    j++;
+    str = &string[j];
+    if (sysv)
+    {
+      Vbanner(str);
+      while ((i = strlen(str)) > 10)
+      {
+        str += 10;
+        Vbanner(str);
+      }
+      return 0;
+    }
+  }
+  while (TRUE)
+  {
+    for (linenum = 0; linenum < 8; linenum++) 	/* 8 lines per char */
+    {
+      for (j = 0; j < (dblsize ? 2 : 1); j++)
+      {
+        banncnt = 0;
+///*      putchar('\n');*/
+        if (italic) 	/* shift for italics */
+          for (k = linenum; k < 7; k++)
+///*          fputs(dblsize ? "  " : " ", stdout);*/
+          {
+            if (dblsize)
+            {
+              bannline[banncnt] = ' ';
+              banncnt++;
+            }
+            bannline[banncnt] = ' ';
+            banncnt++;
+          }
+        for (chnum = 0; chnum < strlen(str); chnum++)
+        {
+          ch      = str[chnum];
+          ch_off  = (int) ch * 8;
+          ch_addr = font + ch_off + linenum;
+          outline(ch, *ch_addr, dblsize, bannerchar, samechar);
+          if (banncnt > (dblsize ? 240 : 248))
+            break;
+        }
+        bannline[banncnt] = '\0';
+        Add("");
+        Replace(bannline);
+      }
+    }
+    if (banncnt > 240)
+      str += (dblsize ? 16 : 32);
+    else
+      break;
+  }
+///*  putchar('\n');*/
+  return 0;
+}
+/*man-start*********************************************************************
+COMMAND
+     banner - insert banner to current line
+
+SYNTAX
+     BANNER [-v|-[c|d|i|s]] {string}
+
+DESCRIPTION
+     Options:
+       -c=<char> use character
+       -d        double size
+       -i        prints italic
+       -s        use same character
+       -v        use SYS V classic (split when length = 10)
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Banner(CHARTYPE *params)
+#else
+short Banner(params)
+CHARTYPE *params;
+#endif
+{
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm1.c:   Banner");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(3,(CHARTYPE *)params,FALSE);
+    bannusage();
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  rc = bannstr(params);
+  TRACE_RETURN();
+  return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      bottom - move to the bottom of the file
@@ -546,6 +1265,174 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     calc - interactive calculator
+
+SYNTAX
+     CALC
+
+SEE ALSO
+     <EVAL>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+extern void evalini();
+extern char *calchlp[];
+#ifdef HAVE_PROTO
+short Calc(CHARTYPE *params)
+#else
+short Calc(params)
+CHARTYPE *params;
+#endif
+{
+#define CHLP_NUM 24
+  WINDOW *fw=NULL, *dw=NULL, *cw=NULL, *lw=NULL;
+  short height=0,width=0,y=0,x=0;
+  CHARTYPE buf[133], last[133], clp[66];
+  CHARTYPE *idx=NULL, *res=NULL;
+  unsigned short i=0, j=0;
+  bool exit=FALSE;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm1.c:   Calc");
+  if (strcmp((DEFCHAR *)params,"") != 0)
+  {
+    display_error(1,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  height = terminal_lines/2;
+  width = terminal_cols/2;
+  y = height/2;
+  x = width/2;
+  fw = newwin(height,width,y,x);
+  if (fw == NULL)
+  {
+    display_error( 30, (CHARTYPE *)"", FALSE );
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  wattrset(fw,set_colour(CURRENT_FILE->attr+ATTR_DIVIDER));
+  wclrtobot(fw);
+  box(fw,0,0);
+  wnoutrefresh(fw);
+  height -= 2;
+  width -= 2;
+  y++;
+  x++;
+  dw = newwin(height,width,y,x);
+  if (dw == NULL)
+  {
+    delwin(fw);
+    display_error( 30, (CHARTYPE *)"", FALSE );
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  scrollok(dw,TRUE);
+  wattrset(dw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+  wclrtobot(dw);
+  wnoutrefresh(dw);
+  evalini();
+  i = 0;
+  wmove(dw,0,1);
+  waddstr(dw,"Type expression, 'help' or 'exit'.");
+  dialogw = TRUE;
+  while (!exit)
+  {
+    if (buf[0] == '=')
+      strcpy((DEFCHAR *)buf, (DEFCHAR *)last);
+    else
+    {
+      strcpy((DEFCHAR *)buf, "");
+      i++;
+    }
+    if (i==height)
+    {
+      scroll(dw);
+      i--;
+    }
+    wmove(dw,i,0);
+    wrefresh(dw);
+    lw = newwin(1,width,y+i,x);
+    if (lw != NULL)
+    {
+      cw = CURRENT_WINDOW_COMMAND;
+      CURRENT_WINDOW_COMMAND = lw;
+      wattrset(lw, set_colour(CURRENT_FILE->attr+ATTR_DIALOG));
+      rc = readv_cmdline(buf, lw, 1);
+      memcpy((DEFCHAR *)buf, (DEFCHAR *)cmd_rec, cmd_rec_len);
+      buf[cmd_rec_len] = '\0';
+      if (buf[0]=='\0' && last[0]=='\0')
+        strcpy(buf, "exit");
+      if (buf[0] != '=')
+        strcpy((DEFCHAR *)last, (DEFCHAR *)buf);
+      CURRENT_WINDOW_COMMAND = cw;
+      delwin(lw);
+    }
+    if (buf[0] == '=')
+      continue;
+    if (strcmp(buf, "exit")==0)
+    {
+      exit = TRUE;
+#if defined(PDC_CLIP_SUCCESS)
+      if ((char *)res != NULL)
+      {
+        strcpy((DEFCHAR *)clp, (DEFCHAR *)"PUT ");
+        strcpy(&clp[4], (DEFCHAR *)res);
+        Clipboard((DEFCHAR *)clp);
+      }
+#endif
+    }
+    if (strcmp(buf, "help")==0)
+    {
+      wclear(stdscr);
+      attrset(A_BOLD);
+      for (j=0; j<CHLP_NUM; j++)
+        mvaddstr(j,0,(DEFCHAR *)calchlp[j]);
+      attrset(A_NORMAL);
+      while ((j=my_getch(stdscr)) == 0);
+      refresh();
+      THERefresh((CHARTYPE *)"");
+      box(fw,0,0);
+      wnoutrefresh(fw);
+      redrawwin(dw);
+      continue;
+    }
+    idx = index(buf, ';');
+    while (idx != NULL)
+    {
+      idx[0] = '\0';
+      eval((DEFCHAR *)buf, &res);
+      idx++;
+      strcpy((DEFCHAR *)buf, (DEFCHAR *)idx);
+      idx = index(buf, ';');
+    }
+    eval((DEFCHAR *)buf, &res);
+    strcpy((DEFCHAR *)buf, (DEFCHAR *)last);
+    wmove(dw,i,0);
+    waddstr(dw, buf);
+    wmove(dw,i,0);
+    scroll(dw);
+    waddstr(dw, " =");
+    waddstr(dw, res);
+  }
+  dialogw = FALSE;
+  delwin(dw);
+  delwin(fw);
+  wmove(CURRENT_WINDOW_COMMAND,0,0);
+  my_wclrtoeol(CURRENT_WINDOW_COMMAND);
+  memset(cmd_rec,' ',max_line_length);
+  cmd_rec_len = 0;
+  wmove(CURRENT_WINDOW_COMMAND,0,0);
+  CURRENT_VIEW->cmdline_col = -1;
+  THERefresh((CHARTYPE *)"");
+  restore_THE();
+  TRACE_RETURN();
+  return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      cancel - quit from all unaltered files in the ring
@@ -873,6 +1760,719 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     center - center text in target area between current MARGINs
+
+SYNTAX
+     CEnter [target]
+
+SEE ALSO
+     <LEFTADJUST>, <RIGHTADJUST>, <JUSTIFY>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Center(CHARTYPE *params)
+#else
+short Center(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm1.c:   center");
+ rc = Format(params,0,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
+#define ZEROLEN(string) (*string == '\0')
+#ifdef HAVE_PROTO
+void JustFill(char *s, int size)
+#else
+void JustFill(s, size)
+char *s;
+int size;
+#endif
+{
+ static int fromleft = 0;       /* alternate sides */
+ char *cp;
+ int blanks = size - strlen(s);
+ if (blanks < 0) return;
+ fromleft++;
+ if (strchr(s, ' ') == NULL) return;    /* cant justify single word line */
+ if (fromleft & 1)   /* insert from left */
+ {
+   while (blanks)
+   {
+     cp = s;    /* start at left edge */
+     while (blanks)
+     {
+       while (*cp != ' ' && !ZEROLEN(cp)) cp++; /* find a blank */
+       if (ZEROLEN(cp)) break;  /* need another pass */
+       memmove(cp+1, cp, strlen(cp)+1); /* insert a space */
+       while (*++cp == ' ');    /* skip past spaces */
+       blanks--;
+     }
+   }
+ }
+ else  /* insert from right */
+ {
+   while (blanks)
+   {
+     cp = s + strlen(s) - 1;    /* start at right edge */
+     while (blanks)
+     {
+       while (*cp != ' ' && cp >= s) cp--;      /* find a blank */
+       if (cp < s) break;       /* need another pass */
+       memmove(cp+1, cp, strlen(cp)+1); /* insert a space */
+       while (*--cp == ' ');    /* skip past spaces */
+       blanks--;
+     }
+   }
+ }
+}
+
+#ifdef HAVE_PROTO
+void lv1ws(char *str)
+#else
+void lv1ws(str)
+char *str;
+#endif
+{
+  char *ibuf, *obuf;
+  int i, cnt;
+  if (str)
+  {
+    ibuf = obuf = str;
+    i = cnt = 0;
+    while(*ibuf)
+    {
+      if(isspace(*ibuf) && cnt)
+         ibuf++;
+      else
+      {
+        if (!isspace(*ibuf))
+          cnt = 0;
+        else
+        {
+          *ibuf = ' ';
+          cnt = 1;
+        }
+        obuf[i++] = *ibuf++;
+      }
+    }
+    obuf[i] = '\0';
+  }
+}
+
+#ifdef HAVE_PROTO
+short Format(CHARTYPE *params, short frm, bool aalt)
+#else
+short Format(params, frm, aalt)
+CHARTYPE *params;
+short frm;
+bool aalt;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ LINETYPE num_lines=0L,true_line=0L,num_actual_lines=0L,i=0L,num_file_lines=0L;
+ short direction=0;
+ LINE *curr=NULL;
+ LENGTHTYPE start_col=0,end_col=0;
+ CHARTYPE *tmpstr=NULL;
+ TARGET target;
+ short target_type=TARGET_NORMAL|TARGET_BLOCK_CURRENT|TARGET_ALL;
+ bool lines_based_on_scope=TRUE;
+ bool adjust_alt=FALSE;
+ bool incomm;
+ bool inbox=FALSE;
+ int leftborder, rightborder;
+ int leftcol, rightcol;
+ register int j;
+ int k,l;
+ char k0, k1, k2;
+ CHARTYPE *ptr=NULL;
+ char tmplst[12]="";
+ short rc=RC_OK;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm1.c:   format");
+ incomm = (bool)(CURRENT_VIEW->current_window == WINDOW_COMMAND);
+ if (strcmp("",(DEFCHAR *)params) == 0)
+    params = (CHARTYPE *)"+1";
+ leftborder = CURRENT_VIEW->margin_left;
+ rightborder= CURRENT_VIEW->margin_right;
+ initialise_target(&target);
+ if ((rc = validate_target(params,&target,target_type,get_true_line(TRUE),TRUE,TRUE)) != RC_OK)
+ {
+    free_target(&target);
+    TRACE_RETURN();
+    return(rc);
+ }
+ post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+ /*
+  * Determine in which direction we are working.
+  */
+ if (target.num_lines < 0L)
+ {
+    direction = DIRECTION_BACKWARD;
+    num_lines = target.num_lines * (-1L);
+ }
+ else
+ {
+    direction = DIRECTION_FORWARD;
+    num_lines = target.num_lines;
+ }
+ true_line = target.true_line;
+ /*
+  * If the target is BLOCK set the left and right margins to be the
+  * margins of the BOX BLOCK, otherwise use ZONE settings.
+  */
+ start_col = CURRENT_VIEW->zone_start-1;
+ end_col = CURRENT_VIEW->zone_end-1;
+ if (target.rt[0].target_type == TARGET_BLOCK_CURRENT)
+ {
+    num_lines = MARK_VIEW->mark_end_line-MARK_VIEW->mark_start_line+1L;
+    true_line = MARK_VIEW->mark_start_line;
+    direction = DIRECTION_FORWARD;
+    lines_based_on_scope = FALSE;
+//  if (MARK_VIEW->mark_type != M_LINE)
+//  {
+//     start_col = MARK_VIEW->mark_start_col-1;
+//     end_col   = MARK_VIEW->mark_end_col-1;
+//  }
+    if (MARK_VIEW->mark_type == M_BOX)
+    {
+       leftborder = MARK_VIEW->mark_start_col;
+       rightborder= MARK_VIEW->mark_end_col;
+    }
+ }
+ /*
+  * Find the current LINE pointer for the true_line.
+  * This is the first line to format.
+  */
+ curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+ /*
+  * Change the case for the target lines and columns...
+  */
+ for (i=0L,num_actual_lines=0L;;i++)
+ {
+    if (lines_based_on_scope)
+    {
+       if (num_actual_lines == num_lines)
+          break;
+    }
+    else
+    {
+       if (num_lines == i)
+          break;
+    }
+    rc = processable_line(CURRENT_VIEW,true_line+(LINETYPE)(i*direction),curr);
+    switch(rc)
+    {
+       case LINE_SHADOW:
+          break;
+/*     case LINE_TOF_EOF: MH12 */
+       case LINE_TOF:
+       case LINE_EOF:
+          num_actual_lines++;
+          break;
+       default:
+          if ((tmpstr = (CHARTYPE *)(*the_malloc)(max_line_length)) == NULL)
+          {
+            display_error(30,(CHARTYPE *)"",FALSE);
+            TRACE_RETURN();
+            return(RC_OUT_OF_MEMORY);
+          }
+          tmpstr[0] = '\0';
+          if (frm>F_UNESC)
+          {
+            for (j=0; j<curr->length; j++)
+            {
+              if (curr->line[j] == 0)
+                curr->line[j] = ' ';
+            }
+          }
+          add_to_recovery_list(curr->line,curr->length);
+//        if ( MARK_VIEW
+//        &&  ( MARK_VIEW->mark_type == M_STREAM || MARK_VIEW->mark_type == M_CUA ) )
+//        {
+//           int mystart=0,myend=curr->length-1;
+//           if (true_line + i == MARK_VIEW->mark_start_line)
+//              mystart = start_col;
+//           if (true_line + i == MARK_VIEW->mark_end_line)
+//              myend = end_col;
+//        }
+          switch(frm)
+          {
+             case F_CENTER:
+                k = rightborder - leftborder;
+                l = curr->length;
+                j = 0;
+                while (isspace(curr->line[j]))
+                {
+                  j++;
+                }
+                l -= j;
+                if ((k > 0) && (l <= k))
+                {
+                  k = (int)((k-l)/2) + leftborder;
+                  for (j=1; j<=k; j++)
+                  {
+/*                    strcat(tmpstr,(CHARTYPE *)" ");*/
+                    tmpstr[j-1] = ' ';
+                    tmpstr[j] = 0;
+                  }
+                }
+                strcat(tmpstr,curr->line+(curr->length-l));
+                break;
+             case F_LEFT:
+             case F_UNJUST:
+                for (j=1; j<leftborder; j++)
+                {
+                  tmpstr[j-1] = ' ';
+                  tmpstr[j] = 0;
+                }
+                j = 0;
+                while (isspace(curr->line[j])
+                       && (j<min(curr->length,end_col+1)))
+                {
+                  j++;
+                }
+                strcat(tmpstr,curr->line+j);
+                if (frm==F_UNJUST)
+                {
+                  while (tmpstr[j]!=0)
+                  {
+                    if (isspace(tmpstr[j]))
+                    {
+                      while (isspace(tmpstr[j+1]))
+                      {
+                        strcpy(tmpstr+j,tmpstr+j+1);
+                      }
+                    }
+                    j++;
+                  }
+                }
+                break;
+             case F_RIGHT:
+                k = rightborder - curr->length;
+                if (k > 0)
+                {
+                  for (j=0; j<k; j++)
+                  {
+                    tmpstr[j] = ' ';
+                    tmpstr[j+1] = 0;
+                  }
+                }
+                strcat(tmpstr,curr->line);
+                break;
+             case F_TRUNC:
+                strcpy(tmpstr,curr->line);
+                j = curr->length-1;
+                // while ((j>=0) && isspace(tmpstr[j]))
+                while ((j>=0) && (tmpstr[j]==' ' || tmpstr[j]=='\t'))
+                {
+                  tmpstr[j] = 0;
+                  j--;
+                }
+                break;
+             case F_JUST:
+                k = rightborder - leftborder;
+                l = curr->length;
+                if (l == 0)
+                {
+                  strcpy(tmpstr,curr->line);
+                  break;
+                }
+                j = 0;
+                while (isspace(curr->line[j++])) ;
+                l -= j;
+                if ((k > 0) && (l <= k))
+                {
+                  for (j=1; j<leftborder; j++)
+                  {
+                    tmpstr[j-1] = ' ';
+                    tmpstr[j] = 0;
+                  }
+                  j = 0;
+                  while (isspace(curr->line[j])
+                         && (j<min(curr->length,end_col+1)))
+                  {
+                    j++;
+                  }
+                  strcat(tmpstr,curr->line+j);
+                  JustFill(tmpstr+leftborder,k);
+                }
+                else
+                  strcpy(tmpstr,curr->line);
+                break;
+             case F_1SPC:
+                strcpy(tmpstr,curr->line);
+                lv1ws(tmpstr);
+                break;
+             case F_TOBIN:
+             case F_TODEC:
+             case F_TOHEX:
+                if (frm==F_TOBIN)
+                  l = 2;
+                else if (frm==F_TODEC)
+                  l = 10;
+                else
+                  l = 16;
+                for (j=0; j<curr->length; j++)
+                {
+                  if ((strlen(tmpstr)+13) > max_line_length)
+                  {
+                    strcpy(tmpstr,curr->line);
+                    break;
+                  }
+                  itoa_dj(curr->line[j], tmplst, l);
+                  strcat(tmplst, ", ");
+                  if (l==2)
+                    strcat(tmpstr, "0b");
+                  if (l==16)
+                    strcat(tmpstr, "0x");
+                  strcat(tmpstr, tmplst);
+                }
+                break;
+             case F_TOCHR:
+                ptr = curr->line;
+                if (isdigit(ptr[0]) &&
+                    ((isdigit(ptr[1]) || ptr[1]==',')
+                     || (ptr[0]=='0' && (ptr[1]=='x' || ptr[1]=='b'))))
+                {
+                  do
+                  {
+                    while ((ptr<(curr->line+curr->length)) && (ptr[0]==' '))
+                      ptr++;
+                    // j = atoi(ptr);
+                    if (ptr[1]=='b')
+                    {
+                      ptr += 2;
+                      j = strtol(ptr, NULL, 2);
+                    }
+                    else
+                      j = strtol(ptr, NULL, 0);
+                    tmplst[0] = (char)j;
+                    tmplst[1] = 0;
+                    strcat(tmpstr, tmplst);
+                    while ((ptr<(curr->line+curr->length)) && (ptr[0]!=','))
+                      ptr++;
+                    if (ptr[0]==',')
+                      ptr++;
+                  } while (ptr<(curr->line+curr->length));
+                }
+                else
+                  strcpy(tmpstr,curr->line);
+                break;
+             case F_UNESC:
+                tmpstr = ansicstr(curr->line, curr->length);
+                break;
+             case F_REV:
+                leftcol = 0;
+                rightcol= curr->length-1;
+                if (MARK_VIEW
+                && (MARK_VIEW->mark_type == M_BOX))
+                {
+                  if ((true_line + i) >= MARK_VIEW->mark_start_line
+                  && (true_line + i) <= MARK_VIEW->mark_end_line)
+                  {
+                    leftcol = leftborder-1;
+                    rightcol= rightborder-1;
+                    strcpy(tmpstr,curr->line);
+                  }
+                }
+                for (j=leftcol, k=rightcol; j<=rightcol; j++, k--)
+                {
+                  tmpstr[j] = curr->line[k];
+                }
+                if (j >= curr->length)
+                  tmpstr[j] = '\0';
+                break;
+             case F_UTF:
+                leftcol = 0;
+                rightcol= curr->length-1;
+                inbox = FALSE;
+                if (MARK_VIEW
+                && (MARK_VIEW->mark_type == M_BOX))
+                {
+                  if ((true_line + i) >= MARK_VIEW->mark_start_line
+                  && (true_line + i) <= MARK_VIEW->mark_end_line)
+                  {
+                    leftcol = leftborder-1;
+                    rightcol= rightborder-1;
+                    strcpy(tmpstr,curr->line);
+                    inbox = TRUE;
+                  }
+                }
+                for (j=leftcol, k=leftcol; k<=rightcol; j++, k++)
+                {
+                  k0 = curr->line[k];
+                  switch(k0)
+                  {
+                    case 0xC1:
+                    case 0xB5:
+                      k1 = 0xC3;
+                      k2 = 0x81;
+                      break;
+                    case 0xE1:
+                    case 0xA0:
+                      k1 = 0xC3;
+                      k2 = 0xA1;
+                      break;
+                    case 0xC9:
+                    case 0x90:
+                      k1 = 0xC3;
+                      k2 = 0x89;
+                      break;
+                    case 0xE9:
+                    case 0x82:
+                      k1 = 0xC3;
+                      k2 = 0xA9;
+                      break;
+                    case 0xCD:
+                    case 0x8C:
+                      k1 = 0xC3;
+                      k2 = 0x8D;
+                      break;
+                    case 0xED:
+                    case 0xA1:
+                      k1 = 0xC3;
+                      k2 = 0xAD;
+                      break;
+                    case 0xD3:
+                    case 0xE0:
+                      k1 = 0xC3;
+                      k2 = 0x93;
+                      break;
+                    case 0xF3:
+                    case 0xA2:
+                      k1 = 0xC3;
+                      k2 = 0xB3;
+                      break;
+                    case 0xD6:
+                    case 0x99:
+                      k1 = 0xC3;
+                      k2 = 0x96;
+                      break;
+                    case 0xF6:
+                    case 0x94:
+                      k1 = 0xC3;
+                      k2 = 0xB6;
+                      break;
+                    case 0xD5:
+                    case 0x8A:
+                      k1 = 0xC5;
+                      k2 = 0x90;
+                      break;
+                    case 0xF5:
+                    case 0x8B:
+                      k1 = 0xC5;
+                      k2 = 0x91;
+                      break;
+                    case 0xDA:
+                      k1 = 0xC3;
+                      k2 = 0x9A;
+                      break;
+                    case 0xFA:
+                    case 0xA3:
+                      k1 = 0xC3;
+                      k2 = 0xBA;
+                      break;
+                    case 0xDC:
+                    case 0x9A:
+                      k1 = 0xC3;
+                      k2 = 0x9C;
+                      break;
+                    case 0xFC:
+                    case 0x81:
+                      k1 = 0xC3;
+                      k2 = 0xBC;
+                      break;
+                    case 0xDB:
+                    case 0xEB:
+                      k1 = 0xC5;
+                      k2 = 0xB0;
+                      break;
+                    case 0xFB:                    
+                      k1 = 0xC5;
+                      k2 = 0xB1;
+                      break;
+                    default:
+                      k1 = k0;
+                      k2 = 0x0;
+                      break;
+                  }
+                  tmpstr[j] = k1;
+                  if (k2 != 0)
+                  {
+                    j++;
+                    tmpstr[j] = k2;
+                    l++;
+                  }
+                }
+                if (inbox)
+                {
+                  for (; k<curr->length; j++, k++)
+                    tmpstr[j] = curr->line[k];
+                }
+                else
+                  tmpstr[j] = '\0';
+                break;
+             case F_LAT:
+                leftcol = 0;
+                rightcol= curr->length-1;
+                inbox = FALSE;
+                if (MARK_VIEW
+                && (MARK_VIEW->mark_type == M_BOX))
+                {
+                  if ((true_line + i) >= MARK_VIEW->mark_start_line
+                  && (true_line + i) <= MARK_VIEW->mark_end_line)
+                  {
+                    leftcol = leftborder-1;
+                    rightcol= rightborder-1;
+                    strcpy(tmpstr,curr->line);
+                    inbox = TRUE;
+                  }
+                }
+                for (j=leftcol, k=leftcol; k<=rightcol; j++, k++)
+                {
+                  k0 = curr->line[k];
+                  k1 = curr->line[k+1];
+                  k2 = k0;
+                  if (k0 == 0xC3)
+                  {
+                    switch(k1)
+                    {
+                      case 0x81:
+                        k2 = 0xC1;
+                        break;
+                      case 0xA1:
+                        k2 = 0xE1;
+                        break;
+                      case 0x89:
+                        k2 = 0xC9;
+                        break;
+                      case 0xA9:
+                        k2 = 0xE9;
+                        break;
+                      case 0x8D:
+                        k2 = 0xCD;
+                        break;
+                      case 0xAD:
+                        k2 = 0xED;
+                        break;
+                      case 0x93:
+                        k2 = 0xD3;
+                        break;
+                      case 0xB3:
+                        k2 = 0xF3;
+                        break;
+                      case 0x96:
+                        k2 = 0xD6;
+                        break;
+                      case 0xB6:
+                        k2 = 0xF6;
+                        break;
+                      case 0x9A:
+                        k2 = 0xDA;
+                        break;
+                      case 0xBA:
+                        k2 = 0xFA;
+                        break;
+                      case 0x9C:
+                        k2 = 0xDC;
+                        break;
+                      case 0xBC:
+                        k2 = 0xFC;
+                        break;
+                      default:
+                        k2 = k0;
+                        break;
+                    }
+                    k++;
+                  }
+                  else
+                  {
+                    if (k0 == 0xC5)
+                    {
+                      switch(k1)
+                      {
+                        case 0x90:
+                          k2 = 0xD5;
+                          break;
+                        case 0x91:
+                          k2 = 0xF5;
+                          break;
+                        case 0xB0:
+                          k2 = 0xDB;
+                          break;
+                        case 0xB1:
+                          k2 = 0xFB;
+                          break;
+                        default:
+                          k2 = k0;
+                          break;
+                      }
+                      k++;
+                    }
+                  }
+                  tmpstr[j] = k2;
+                }
+                if (!inbox)
+                  tmpstr[j] = '\0';
+                else
+                {
+                  for (; k<=curr->length; j++, k++)
+                    tmpstr[j] = curr->line[k];
+                }
+                break;
+             default:
+                break;
+          }
+          THEcursor_goto(true_line+(LINETYPE)(i*direction),1);
+          Replace(tmpstr);
+          (*the_free)(tmpstr);
+          if (rc && aalt)
+          {
+             adjust_alt = TRUE;
+             curr->flags.changed_flag = TRUE;
+          }
+          num_actual_lines++;
+          break;
+    }
+    /*
+     * Proceed to the next record, even if the current record not in scope.
+     */
+    if (direction == DIRECTION_FORWARD)
+       curr = curr->next;
+    else
+       curr = curr->prev;
+    num_file_lines += (LINETYPE)direction;
+    if (curr == NULL)
+       break;
+ }
+ /*
+  * Increment the alteration counts if any lines changed...
+  */
+ if (adjust_alt)
+    increment_alt(CURRENT_FILE);
+ /*
+  * Display the new screen...
+  */
+ THEcursor_goto(true_line,1);
+ if (incomm)
+    THEcursor_cmdline(1);
+ pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+ resolve_current_and_focus_lines(CURRENT_VIEW,true_line,num_file_lines,direction,TRUE,FALSE);
+ TRACE_RETURN();
+ return(RC_OK);
+}
+
 /*man-start*********************************************************************
 COMMAND
      cfirst - move column pointer to beginning of zone
@@ -1177,6 +2777,187 @@
    TRACE_RETURN();
    return(rc);
 }
+
+#if defined(PDC_CLIP_SUCCESS)
+/*man-start*********************************************************************
+COMMAND
+     clp - copy/cut/paste/clear clipboard
+
+SYNTAX
+     CLP params
+
+DESCRIPTION
+     Append COPY     Append current selection to clipboard
+
+     Append CUT      Cut current selection, appending to clipboard
+
+     Append PUT txt  Append specified text to clipboard
+
+     CLEAR           Empty the clipboard
+
+     COPY            Copy current selection to clipboard
+
+     CUT             Cut current selection to clipboard
+
+     PASTE           Paste from clipboard
+
+     PUT txt         Put specified text into clipboard
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <CLIPBOARD>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#define CLPACPY 1
+#define CLPACUT 2
+#define CLPAPUT 3
+#define CLPCLR 4
+#define CLPCPY 5
+#define CLPCUT 6
+#define CLPPAST 7
+#define CLPPUT 8
+#ifdef HAVE_PROTO
+short Clipboard(CHARTYPE *params)
+#else
+short Clipboard(params)
+CHARTYPE *params;
+#endif
+{
+  CHARTYPE *tok=NULL;
+  CHARTYPE *tmp=NULL;
+  CHARTYPE *txt=NULL;
+  CHARTYPE *pnt1=NULL, *pnt2=NULL;
+  long len1=0L, len2=0L;
+  short parlen=0, txtlen=0;
+  short i=0;
+  short mode=0;
+  bool append=FALSE;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm1.c:   clp");
+  parlen = strlen(params);
+  for (tok=strtok(params," "), i=1; tok; tok=strtok(0," "), i++)
+  {
+    if (i==1 && strcasecmp("APPEND",tok)>=0)
+      append = TRUE;
+    if (i==2 && append)
+    {
+      if (strcasecmp(tok,"COPY")==0)
+        mode = CLPACPY;
+      if (strcasecmp(tok,"CUT")==0)
+        mode = CLPACUT;
+      if (strcasecmp(tok,"PUT")==0)
+        mode = CLPAPUT;
+    }
+    if (i==1 && !append)
+    {
+      if (strcasecmp(tok,"CLEAR")==0)
+        mode = CLPCLR;
+      if (strcasecmp(tok,"COPY")==0)
+        mode = CLPCPY;
+      if (strcasecmp(tok,"CUT")==0)
+        mode = CLPCUT;
+      if (strcasecmp(tok,"PASTE")==0)
+        mode = CLPPAST;
+      if (strcasecmp(tok,"PUT")==0)
+        mode = CLPPUT;
+    }
+    if ((append && i==3 && mode==CLPAPUT)
+        || (!append && i==2 && mode==CLPPUT))
+    {
+      txt=tok;
+      parlen -= (short)(tok-params);
+      txtlen = strlen(txt);
+      if (parlen>txtlen)
+      {
+        txt[txtlen] = ' ';
+        txtlen = strlen(txt);
+      }
+      break;
+    }
+    if ((!append && mode!=CLPPUT && i==2)
+        || (append && mode!=CLPAPUT && i==3))
+    {
+      mode = 0;
+      params=tok;
+      break;
+    }
+  } //for
+  if (append)
+  {
+    PDC_getclipboard((DEFCHAR **)&pnt1, &len1);
+  }
+  switch(mode)
+  {
+    case 0:
+      display_error(1,params,FALSE);
+      TRACE_RETURN();
+      return(RC_INVALID_OPERAND);
+      break;
+    case CLPACPY:
+    case CLPACUT:
+      execute_put("block clip:",(bool)(mode==CLPACUT));
+      PDC_getclipboard((DEFCHAR **)&pnt2, &len2);
+      if ((tmp = (CHARTYPE *)(*the_malloc)(len1+len2+1)) == NULL)
+      {
+        display_error(30,(CHARTYPE *)"",FALSE);
+        TRACE_RETURN();
+        return(RC_OUT_OF_MEMORY);
+      }
+      if (pnt1==NULL)
+        strcpy(tmp, pnt2);
+      else
+      {
+        strcpy(tmp, pnt1);
+        strcat(tmp, pnt2);
+      }
+      rc = PDC_setclipboard((DEFCHAR *)tmp, len1+len2);
+      (*the_free)(tmp);
+      break;
+    case CLPAPUT:
+      if ((tmp = (CHARTYPE *)(*the_malloc)(len1+txtlen+1)) == NULL)
+      {
+        display_error(30,(CHARTYPE *)"",FALSE);
+        TRACE_RETURN();
+        return(RC_OUT_OF_MEMORY);
+      }
+      if (pnt1==NULL)
+        strcpy(tmp, txt);
+      else
+      {
+        strcpy(tmp, pnt1);
+        strcat(tmp, txt);
+      }
+      rc = PDC_setclipboard((DEFCHAR *)tmp, len1+txtlen);
+      (*the_free)(tmp);
+      break;
+    case CLPCLR:
+      rc = PDC_clearclipboard();
+      break;
+    case CLPCPY:
+      rc = execute_put("block clip:",FALSE);
+      break;
+    case CLPCUT:
+      rc = execute_put("block clip:",TRUE);
+      break;
+    case CLPPAST:
+      rc = Get("clip: line");
+      break;
+    case CLPPUT:
+      rc = PDC_setclipboard((DEFCHAR *)txt, txtlen);
+      break;
+    default:
+      break;
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+#endif
+
 /*man-start*********************************************************************
 COMMAND
      clocate - move the column pointer
diff -Naurd orig/comm2.c mod/comm2.c
--- orig/comm2.c	2007-12-11 21:28:32.000000000 +0100
+++ mod/comm2.c	2009-03-11 15:46:00.000000000 +0100
@@ -704,6 +704,158 @@
 
 /*man-start*********************************************************************
 COMMAND
+     ebcdic - convert the target from ASCII to EBCDIC
+
+SYNTAX
+     EBCDIC [target]
+
+SEE ALSO
+     <TOASCII>, <TOHEX>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Ebcdic(CHARTYPE *params)
+#else
+short Ebcdic(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+   LINETYPE num_lines=0L,true_line=0L,num_actual_lines=0L,i=0L,num_file_lines=0L;
+   short  direction=0;
+   LINE *curr=NULL;
+   LENGTHTYPE start_col=0,end_col=0;
+   short rc=RC_OK;
+   TARGET target;
+   short target_type=TARGET_NORMAL|TARGET_BLOCK_CURRENT|TARGET_ALL;
+   bool lines_based_on_scope=TRUE;
+   bool adjust_alt=FALSE;
+/*--------------------------- processing ------------------------------*/
+   TRACE_FUNCTION("comm2.c:   Ebcdic");
+   if (strcmp("",(DEFCHAR *)params) == 0)
+      params = (CHARTYPE *)"+1";
+   initialise_target(&target);
+   if ((rc = validate_target(params,&target,target_type,get_true_line(TRUE),TRUE,TRUE)) != RC_OK)
+   {
+      free_target(&target);
+      TRACE_RETURN();
+      return(rc);
+   }
+   post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+   /*
+    * Determine in which direction we are working.
+    */
+   if (target.num_lines < 0L)
+   {
+      direction = DIRECTION_BACKWARD;
+      num_lines = target.num_lines * (-1L);
+   }
+   else
+   {
+      direction = DIRECTION_FORWARD;
+      num_lines = target.num_lines;
+   }
+   true_line = target.true_line;
+   /*
+    * If the target is BLOCK set the left and right margins to be the
+    * margins of the BOX BLOCK, otherwise use ZONE settings.
+    */
+   start_col = CURRENT_VIEW->zone_start-1;
+   end_col = CURRENT_VIEW->zone_end-1;
+   if (target.rt[0].target_type == TARGET_BLOCK_CURRENT)
+   {
+      num_lines = MARK_VIEW->mark_end_line-MARK_VIEW->mark_start_line+1L;
+      true_line = MARK_VIEW->mark_start_line;
+      direction = DIRECTION_FORWARD;
+      lines_based_on_scope = FALSE;
+      if (MARK_VIEW->mark_type != M_LINE)
+      {
+         start_col = MARK_VIEW->mark_start_col-1;
+         end_col   = MARK_VIEW->mark_end_col-1;
+      }
+   }
+   /*
+    * Find the current LINE pointer for the true_line.
+    * This is the first line to change.
+    */
+   curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+   /*
+    * Change the case for the target lines and columns...
+    */
+   for (i=0L,num_actual_lines=0L;;i++)
+   {
+      if (lines_based_on_scope)
+      {
+         if (num_actual_lines == num_lines)
+            break;
+      }
+      else
+      {
+         if (num_lines == i)
+            break;
+      }
+      rc = processable_line(CURRENT_VIEW,true_line+(LINETYPE)(i*direction),curr);
+      switch(rc)
+      {
+         case LINE_SHADOW:
+            break;
+/*       case LINE_TOF_EOF: MH12 */
+         case LINE_TOF:
+         case LINE_EOF:
+            num_actual_lines++;
+            break;
+         default:
+            add_to_recovery_list(curr->line,curr->length);
+            if ( MARK_VIEW
+            &&  ( MARK_VIEW->mark_type == M_STREAM || MARK_VIEW->mark_type == M_CUA ) )
+            {
+               int mystart=0,myend=curr->length-1;
+               if (true_line + i == MARK_VIEW->mark_start_line)
+                  mystart = start_col;
+               if (true_line + i == MARK_VIEW->mark_end_line)
+                  myend = end_col;
+               asc2ebc(curr->line,curr->length,mystart,myend);
+            }
+            else
+               asc2ebc(curr->line,curr->length,start_col,end_col);
+            if (rc)
+            {
+               adjust_alt = TRUE;
+               curr->flags.changed_flag = TRUE;
+            }
+            num_actual_lines++;
+            break;
+      }
+      /*
+       * Proceed to the next record, even if the current record not in scope.
+       */
+      if (direction == DIRECTION_FORWARD)
+         curr = curr->next;
+      else
+         curr = curr->prev;
+      num_file_lines += (LINETYPE)direction;
+      if (curr == NULL)
+         break;
+   }
+   /*
+    * Increment the alteration counts if any lines changed...
+    */
+   if (adjust_alt)
+      increment_alt(CURRENT_FILE);
+   /*
+    * Display the new screen...
+    */
+   pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+   resolve_current_and_focus_lines(CURRENT_VIEW,true_line,num_file_lines,direction,TRUE,FALSE);
+   TRACE_RETURN();
+   return(RC_OK);
+}
+
+/*man-start*********************************************************************
+COMMAND
      edit - edit another file or switch to next file
 
 SYNTAX
@@ -1027,6 +1179,81 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     eval - store value to editv variable
+
+SYNTAX
+     EVAL variable expression
+
+DESCRIPTION
+     evaluate and set EVALERR variable 0 or 1 when error
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <CALC>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+extern void evalini();
+#ifdef HAVE_PROTO
+short Eval(CHARTYPE *params)
+#else
+short Eval(params)
+CHARTYPE *params;
+#endif
+{
+  char buf[MAX_COMMAND_LENGTH];
+  CHARTYPE *beg, *idx, *res;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm2.c:   Eval");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(3,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  evalini();
+  strcpy((DEFCHAR *)buf, params);
+  beg = index(buf, ' ');
+  if (beg != NULL)
+  {
+    beg++;
+    idx = index(beg, ';');
+    while (idx != NULL)
+    {
+      idx[0] = '\0';
+      eval((DEFCHAR *)beg, &res);
+      idx++;
+      strcpy((DEFCHAR *)beg, (DEFCHAR *)idx);
+      idx = index(beg, ';');
+    }
+    eval((DEFCHAR *)beg, &res);
+    if (res[0] > '@')
+      idx[0] = '\0';
+    else
+      strcpy((DEFCHAR *)beg, res);
+  }
+  else
+  {
+    display_error(3,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if (isalpha(res[0]))
+    execute_editv(EDITV_SETL,FALSE,(DEFCHAR *)"evalerr 1");
+  else
+    execute_editv(EDITV_SETL,FALSE,(DEFCHAR *)"evalerr 0");
+  rc = execute_editv(EDITV_SETL,FALSE,(DEFCHAR *)buf);
+  TRACE_RETURN();
+  return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      expand - expand tab characters to spaces
@@ -1497,6 +1724,322 @@
    TRACE_RETURN();
    return(rc);
 }
+
+
+/*man-start*********************************************************************
+COMMAND
+     flow - Wordwrap and justify text in all paragraphs in target area
+
+SYNTAX
+     FLOW [target|-]
+
+DESCRIPTION
+     If no target is specified, format a paragraph.
+     '-' specifies <UNJUST>.
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Flow(CHARTYPE *params)
+#else
+short Flow(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ LINETYPE num_lines=0L,true_line=0L,num_actual_lines=0L,i=0L,num_file_lines=0L;
+ short  direction=0;
+ LINE *curr=NULL;
+ LENGTHTYPE start_col=0,end_col=0;
+ short rc=RC_OK;
+ TARGET target;
+ short target_type=TARGET_NORMAL|TARGET_BLOCK_CURRENT|TARGET_ALL;
+ bool lines_based_on_scope=TRUE;
+/* bool adjust_alt=FALSE;*/
+ bool incomm, nojust;
+ short save_mleft=0;
+ register unsigned int j;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm2.c:   Flow");
+ incomm = (bool)(CURRENT_VIEW->current_window == WINDOW_COMMAND);
+ if (strcmp("",(DEFCHAR *)params) == 0)
+   params = (CHARTYPE *)"blank";
+ if (strcmp("-",(DEFCHAR *)params) == 0)
+ {
+   params = (CHARTYPE *)"blank";
+   nojust = TRUE;
+ }
+ else
+   nojust = FALSE;
+ initialise_target(&target);
+ if ((rc = validate_target(params,&target,target_type,get_true_line(TRUE),TRUE,TRUE)) != RC_OK)
+ {
+    free_target(&target);
+    TRACE_RETURN();
+    return(rc);
+ }
+ post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+ /*
+  * Determine in which direction we are working.
+  */
+ if (target.num_lines < 0L)
+ {
+    display_error(0,(CHARTYPE *)"Invalid direction",FALSE);
+    free_target(&target);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+/*    direction = DIRECTION_BACKWARD;*/
+/*    num_lines = target.num_lines * (-1L);*/
+ }
+ else
+ {
+    direction = DIRECTION_FORWARD;
+    num_lines = target.num_lines;
+ }
+ true_line = target.true_line;
+ /*
+  * If the target is BLOCK set the left and right margins to be the
+  * margins of the BOX BLOCK, otherwise use ZONE settings.
+  */
+ start_col = CURRENT_VIEW->zone_start-1;
+ end_col = CURRENT_VIEW->zone_end-1;
+ if (target.rt[0].target_type == TARGET_BLOCK_CURRENT)
+ {
+    num_lines = MARK_VIEW->mark_end_line-MARK_VIEW->mark_start_line+1L;
+    true_line = MARK_VIEW->mark_start_line;
+    direction = DIRECTION_FORWARD;
+    lines_based_on_scope = FALSE;
+ }
+ /*
+  * Find the current LINE pointer for the true_line.
+  * This is the first line to change.
+  */
+ curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+ /*
+  * Process target lines
+  */
+ for (i=0L,num_actual_lines=0L;;i++)
+ {
+    if (lines_based_on_scope)
+    {
+       if (num_actual_lines == num_lines)
+          break;
+    }
+    else
+    {
+       if (num_lines == i)
+          break;
+    }
+    rc = processable_line(CURRENT_VIEW,true_line+(LINETYPE)(i*direction),curr);
+    switch(rc)
+    {
+       case LINE_SHADOW:
+          break;
+/*       case LINE_TOF_EOF: MH12 */
+       case LINE_TOF:
+       case LINE_EOF:
+          num_actual_lines++;
+          break;
+       default:
+          if (curr->length == 0)
+            break;
+          save_mleft = CURRENT_VIEW->margin_left;
+          if ((i==0) || (curr->prev->length==0))
+          {
+            if (CURRENT_VIEW->margin_indent_offset_status)
+              CURRENT_VIEW->margin_left += CURRENT_VIEW->margin_indent;
+            else
+              CURRENT_VIEW->margin_left = CURRENT_VIEW->margin_indent;
+          }
+          THEcursor_goto(true_line+(LINETYPE)(i),1);
+          Format((DEFCHAR *)"",F_LEFT,FALSE);
+          j = curr->length-1;
+          while ((j>=0) && isspace(curr->line[j]))
+          {
+            curr->line[j] = 0;
+            j--;
+          }
+          j = CURRENT_VIEW->margin_right;
+          if (curr->length > j)
+          {
+            while (!isspace(curr->line[j-1])
+                   && (j>CURRENT_VIEW->margin_left))
+            {
+              j--;
+            }
+            CURRENT_VIEW->margin_left = save_mleft;
+            if (j<=CURRENT_VIEW->margin_left)
+            {
+              break;
+            }
+            THEcursor_goto(true_line+(LINETYPE)(i),j);
+            execute_split_join(SPLTJOIN_SPLIT,FALSE,TRUE);
+            num_lines++;
+            THEcursor_goto(true_line+(LINETYPE)(i+1),1);
+            Format((DEFCHAR *)"",F_LEFT,FALSE);
+            if ((curr->next->next->length > 0)
+                && strcmp(curr->next->next->line,BOTTOM_OF_FILE) != 0)
+            {
+              while ((curr->next->next->length>0)
+                     && (curr->next->length<CURRENT_VIEW->margin_right))
+              {
+                Sos_endchar((DEFCHAR *)"");
+                THEcursor_right(CURSOR_ESCREEN,FALSE);
+                execute_split_join(SPLTJOIN_JOIN,FALSE,TRUE);
+                j = curr->next->length;
+                if (j>0) {j--;}
+                while ((j>=0) && isspace(curr->next->line[j]))
+                {
+                  curr->next->line[j] = 0;
+                  j--;
+                }
+                num_lines--;
+              }
+            }
+            THEcursor_goto(true_line+(LINETYPE)(i),1);
+          }
+          if ((i==0) || (curr->prev->length==0))
+          {
+            if (CURRENT_VIEW->margin_indent_offset_status)
+              CURRENT_VIEW->margin_left += CURRENT_VIEW->margin_indent;
+            else
+              CURRENT_VIEW->margin_left = CURRENT_VIEW->margin_indent;
+          }
+          if (curr->next->length > 0)
+          {
+            if ((nojust==FALSE) && (curr->length > 0)
+                && (curr->length < CURRENT_VIEW->margin_right))
+            {
+              Format((DEFCHAR *)"",F_JUST,FALSE);
+            }
+          }
+          else
+          {
+            Format((DEFCHAR *)"",F_LEFT,FALSE);
+          }
+          CURRENT_VIEW->margin_left = save_mleft;
+/*          adjust_alt = TRUE;*/
+/*          curr->flags.changed_flag = TRUE;*/
+          num_actual_lines++;
+          break;
+    }
+    /*
+     * Proceed to the next record, even if the current record not in scope.
+     */
+/*    if (direction == DIRECTION_FORWARD)*/
+       curr = curr->next;
+/*    else*/
+/*       curr = curr->prev;*/
+    num_file_lines += (LINETYPE)direction;
+    if (curr == NULL)
+       break;
+ }
+ /*
+  * Increment the alteration counts if any lines changed...
+  */
+/* if (adjust_alt)*/
+/*    increment_alt(CURRENT_FILE);*/
+ /*
+  * Display the new screen...
+  */
+ THEcursor_goto(true_line+(LINETYPE)(num_lines+1),1);
+ execute_makecurr(CURRENT_VIEW->focus_line);
+ if (incomm)
+   THEcursor_cmdline(1);
+ pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+ resolve_current_and_focus_lines(CURRENT_VIEW,true_line,num_file_lines,direction,TRUE,FALSE);
+ TRACE_RETURN();
+ return(RC_OK);
+}
+
+/*man-start*********************************************************************
+COMMAND
+     forcesave - save protected (readonly) file
+
+SYNTAX
+     FORCESAVE
+
+DESCRIPTION
+     The FORCESAVE command writes the current file to disk.
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Fsave(CHARTYPE *params)
+#else
+short Fsave(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ short rc=RC_OK;
+ CHARTYPE *write_fname=NULL;
+ short len_params=0;
+ bool writable=FALSE;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm2.c:   Fsave");
+ len_params = strlen((DEFCHAR *)params);
+ post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+ if (CURRENT_FILE->save_alt == 0 && strcmp(params,"") == 0)
+ {
+   TRACE_RETURN();
+   return(rc);
+ }
+ if ((write_fname = (CHARTYPE *)(*the_malloc)(MAX_FILE_NAME)) == NULL)
+ {
+   display_error(30,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_OUT_OF_MEMORY);
+ }
+ if (len_params == 0)
+ {
+   strcpy((DEFCHAR *)write_fname,(DEFCHAR *)CURRENT_FILE->fpath);
+   strcat((DEFCHAR *)write_fname,(DEFCHAR *)CURRENT_FILE->fname);
+ }
+ else
+ {
+   the_free(write_fname);
+   display_error(1,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ writable = (access(write_fname,W_OK)==0);
+ if (!writable)
+   chmod(write_fname, S_IWUSR|S_IRUSR);
+ rc = save_file(CURRENT_FILE,params,TRUE,CURRENT_FILE->number_lines,1L,NULL,FALSE,0,max_line_length,TRUE,FALSE,FALSE);
+ if (!writable)
+   chmod(write_fname, S_IRUSR);
+ the_free(write_fname);
+ if (rc != RC_OK)
+ {
+   TRACE_RETURN();
+   return(rc);
+ }
+/*---------------------------------------------------------------------*/
+/* Only set the alteration count to zero if save was successful.       */
+/*---------------------------------------------------------------------*/
+ CURRENT_FILE->autosave_alt = CURRENT_FILE->save_alt = 0;
+/*---------------------------------------------------------------------*/
+/* If autosave is on at the time of SSaving, remove the .aus file...   */
+/*---------------------------------------------------------------------*/
+ if (CURRENT_FILE->autosave > 0)
+    rc = remove_aus_file(CURRENT_FILE);
+ TRACE_RETURN();
+ return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      forward - scroll forwards [n] screens
@@ -1608,6 +2151,193 @@
    TRACE_RETURN();
    return(rc);
 }
+
+#include <glob.h>
+#ifdef HAVE_PROTO
+short SearchFile(CHARTYPE *fname, CHARTYPE *str, bool x)
+#else
+short SearchFile(fname)
+CHARTYPE *fname, *str;
+bool x;
+#endif
+{
+#define MAX_FSTR 120
+ char c_hi[] = "\x00";
+ char c_lo[] = "AAAEEIIIIOOOOOOOOUUUUUUUUAAAAEEIIOOOOOOOUUUUUU\x00";
+ short k = (int) &c_hi;
+ FILE *InFile;
+ char fstr[MAX_FSTR+2];
+ char c;
+ register short i;
+ short j, l;
+ short rc = -1;
+ j = strlen(str)-2;
+ if (j > MAX_FSTR)
+    j = MAX_FSTR;
+ strncpy(fstr, str, j+1);
+ if (!x)
+ {
+   for (i=1; i<(j+1); i++)
+   {
+     l = (int) index(c_hi,fstr[i]);
+     if (l != NULL)
+     {
+       l -= k;
+       fstr[i] = c_lo[l];
+     }
+     else
+       fstr[i] = toupper(fstr[i]);
+   }
+ }
+ if ( (InFile = fopen( fname, "rb")) != NULL )
+ {
+   i = 1;
+   while (!feof(InFile))
+   {
+     c = fgetc(InFile);
+     if (!x)
+     {
+       l = (int) index(c_hi,c);
+       if (l != NULL)
+       {
+         l -= k;
+         c = c_lo[l];
+       }
+       c = toupper(c);
+     }
+     if (c == fstr[i])
+     {
+       i++;
+       if (i > j)
+       {
+         rc = RC_OK;
+         break;
+       }
+     }
+     else
+       i = 1;
+   }
+   fclose( InFile );
+ }
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     fsearch - find str in files
+
+SYNTAX
+     FSEARCH [C] /string/ files
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short FSearch(CHARTYPE *params)
+#else
+short FSearch(params)
+CHARTYPE *params;
+#endif
+{
+ #define SEARCH_PARAMS 11
+ unsigned short num_params=0;
+ CHARTYPE *word[SEARCH_PARAMS+1];
+ CHARTYPE *wpars[SEARCH_PARAMS];
+ CHARTYPE strip[SEARCH_PARAMS];
+ CHARTYPE *fn=NULL;
+ CHARTYPE *beg=NULL;
+ CHARTYPE *end=NULL;
+ register short i,k;
+ short len;
+ short j=0;
+ glob_t glob_results;
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm4.c:   FSearch");
+ beg = strpbrk(params,"/'\"|");
+ if (beg!=NULL)
+ {
+   end = strpbrk(beg+1,"/'\"|");
+   if (end!=NULL)
+   {
+/*     beg[0]=' ';*/
+/*     end[0]=' ';*/
+     beg++;
+     end--;
+     while (beg<end)
+     {
+       if (beg[0]==' ')
+         beg[0] = 0xFF;
+       beg++;
+     }
+   }
+ }
+ for (i=0;i<SEARCH_PARAMS;i++)
+   strip[i]=STRIP_BOTH;
+ num_params = param_split(params,word,SEARCH_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+ if (num_params < 2)
+ {
+   display_error(3,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ if (num_params >= SEARCH_PARAMS)
+ {
+   display_error(2,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ if (strlen(word[0]) == 1)
+   j = ((toupper(word[0][0])=='C')?1:0);
+ len = strlen(word[j]);
+ if (len < 3)
+ {
+   display_error(1,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ for (i=0; i<len; i++)
+ {
+   if (word[j][i]==0xFF)
+     word[j][i] = ' ';
+ }
+ word[j][len] = '\0';
+ for (i=0;i<=num_params;i++)
+ {
+   if ((wpars[i] = (CHARTYPE *)(*the_malloc)(MAX_FILE_NAME)) == NULL)
+   {
+     display_error(30,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_OUT_OF_MEMORY);
+   }
+   strcpy(wpars[i],word[i]);
+ }
+ for (i=j+1; i<=num_params; i++)
+ {
+   glob(wpars[i], GLOB_NOCHECK, 0, &glob_results);
+   for (k=0; k<glob_results.gl_pathc; k++)
+   {
+     fn = glob_results.gl_pathv[k];
+     rc = SearchFile(fn,(CHARTYPE *)wpars[j],(bool)j);
+     if (rc == RC_OK)
+     {
+       display_error(0,fn,TRUE);
+       rc = EditFile((CHARTYPE *)fn,FALSE);
+       if (rc == RC_OK)
+       {
+         wpars[len+1] = '\0';
+         rc = execute_locate((CHARTYPE *)wpars[j], FALSE, THE_NOT_SEARCH_SEMANTICS, NULL);
+         if (rc != RC_OK)
+           (void)Qquit((CHARTYPE *)"");
+       }
+     }
+   }
+   globfree(&glob_results);
+ }
+ for (i=0;i<=num_params;i++)
+   (*the_free)(wpars[i]);
+ TRACE_RETURN();
+ return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      fup - locate backwards the line which begins with the supplied string
@@ -2022,6 +2752,196 @@
    TRACE_RETURN();
    return(rc);
 }
+
+extern bool HuSortCase;
+/*man-start*********************************************************************
+COMMAND
+     hlowercase - change to lowercase using high (Hun) characters
+
+SYNTAX
+     HLOWercase [target]
+
+DESCRIPTION
+     The HLOWERCASE command same as LOWERCASE,
+     with following conversions:
+
+     8F/143 - A0/160
+     90/144 - 82/130
+     8C/140 - A1/161
+     95/149 - A2/162
+     99/153 - 94/148
+     A7/167 - 93/147
+     97/151 - A3/163
+     9A/154 - 81/129
+     98/152 - 96/150
+     C1/193 - E1/225
+     C9/201 - E9/233
+     CD/205 - ED/237
+     D3/211 - F3/243
+     D6/214 - F6/246
+     D5/213 - F5/245
+     DA/218 - FA/250
+     DC/220 - FC/252
+     DB/219 - FB/251
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <LOWERCASE>, <HUPPERCASE>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short HLowercase(CHARTYPE *params)
+#else
+short HLowercase(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm2.c:  HLowercase");
+ HuSortCase = TRUE;
+ rc = execute_change_case(params,CASE_LOWER);
+ HuSortCase = FALSE;
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     huppercase - change to uppercase using high (Hun) characters
+
+SYNTAX
+     HUPPercase [target]
+
+DESCRIPTION
+     The HUPPERCASE command same as UPPERCASE,
+     with following conversions:
+
+     A0/160 - 8F/143
+     82/130 - 90/144
+     A1/161 - 8C/140
+     A2/162 - 95/149
+     94/148 - 99/153
+     93/147 - A7/167
+     A3/163 - 97/151
+     81/129 - 9A/154
+     96/150 - 98/152
+     E1/225 - C1/193
+     E9/233 - C9/201
+     ED/237 - CD/205
+     F3/243 - D3/211
+     F6/246 - D6/214
+     F5/245 - D5/213
+     FA/250 - DA/218
+     FC/252 - DC/220
+     FB/251 - DB/219
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <UPPERCASE>, <HLOWERCASE>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short HUppercase(CHARTYPE *params)
+#else
+short HUppercase(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm2.c:  HUppercase");
+ HuSortCase = TRUE;
+ rc = execute_change_case(params,CASE_UPPER);
+ HuSortCase = FALSE;
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     hsort - sort selected lines using high (Hun) characters
+
+SYNTAX
+     HSORT [O] target [[sort field 1] [...] [sort field 10]]
+
+DESCRIPTION
+     The HSORT command same as SORT command,
+     with following conversions:
+
+     8F/143 - A ; C1/193 - A
+     90/144 - E ; C9/201 - E
+     8C/140 - I ; EE/238 - I
+     8D/141 - I ; CD/205 - I
+     95/149 - O ; D3/211 - O
+     99/153 - O ; D6/214 - O
+     A7/167 - O ; D5/213 - O
+     97/151 - U ; DA/218 - U
+     9A/154 - U ; DC/220 - U
+     98/152 - U ; DB/219 - U
+     A0/160 - a ; E1/225 - a
+     84/132 - a ; E4/228 - a
+     82/130 - e ; E9/233 - e
+     A1/161 - i ; ED/237 - i
+     A2/162 - o ; F3/243 - o
+     94/148 - o ; F6/246 - o
+     93/147 - o ; F5/245 - o
+     A3/163 - u ; FA/250 - u
+     81/129 - u ; FC/252 - u
+     96/150 - u ; FB/251 - u
+
+     The first optional parameter 'O' sets the sensitive order.
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <SORT>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+extern bool HuSortFlag;
+extern bool HuSortCase;
+#ifdef HAVE_PROTO
+short HSort(CHARTYPE *params)
+#else
+short HSort(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ short rc=RC_OK;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm2.c:   HSort");
+ if (params[0]=='o' || params[0]=='O')
+   {
+     HuSortCase = TRUE;
+     params[0] = ' ';
+   }
+ else
+   {
+     HuSortCase = FALSE;
+   }
+ post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+ HuSortFlag = TRUE;
+ rc = execute_sort(params);
+ HuSortFlag = FALSE;
+ pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+ build_screen(current_screen);
+ display_screen(current_screen);
+ TRACE_RETURN();
+ return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      input - insert the command line contents into the file
@@ -2191,3 +3111,31 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     justify - justify text in target area to current MARGINs
+
+SYNTAX
+     JUSTify [target]
+
+SEE ALSO
+     <UNJUST>, <FLOW>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Justify(CHARTYPE *params)
+#else
+short Justify(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm2.c:   justify");
+ rc = Format(params,F_JUST,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
diff -Naurd orig/comm3.c mod/comm3.c
--- orig/comm3.c	2007-12-11 21:28:32.000000000 +0100
+++ mod/comm3.c	2009-03-11 15:58:00.000000000 +0100
@@ -67,6 +67,112 @@
 
 /*man-start*********************************************************************
 COMMAND
+     lcompress - reduce leading spaces to tabs
+
+SYNTAX
+     LCOMPress [target]
+
+SEE ALSO
+     <LEXPAND>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+bool lefttabconv=FALSE;
+#ifdef HAVE_PROTO
+short Lcompress(CHARTYPE *params)
+#else
+short Lcompress(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   Lcompress");
+  lefttabconv=TRUE;
+  rc = execute_expand_compress(params,FALSE,TRUE,TRUE,TRUE);
+  lefttabconv=FALSE;
+  TRACE_RETURN();
+  return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     ledit - edit files from specified listfile
+
+SYNTAX
+     LEDIT file
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#include <glob.h>
+#ifdef HAVE_PROTO
+short Ledit(CHARTYPE *params)
+#else
+short Ledit(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+  CHARTYPE buf[MAX_FILE_NAME+1];
+  CHARTYPE **fnpar=NULL;
+  FILE *InFile;
+  int key=0;
+  register short i;
+  glob_t glob_results;
+  short rc=RC_OK;
+  TRACE_FUNCTION( "comm3.c:   Ledit" );
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(3,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if ( (InFile = fopen(params, "rb")) != NULL )
+  {
+    file_list_msg = FALSE;
+    while (!feof(InFile))
+    {
+      if (fgets(buf,MAX_FILE_NAME,InFile) != NULL)
+      {
+        short fnlen = strlen(buf);
+        if (buf[fnlen-2] < 32)
+            buf[fnlen-2] = 0;
+        if (buf[fnlen-1] < 32)
+            buf[fnlen-1] = 0;
+        glob(buf, GLOB_NOCHECK, 0, &glob_results);
+        for (i = 0; i<glob_results.gl_pathc; i++)
+        {
+          fnpar = (CHARTYPE *)glob_results.gl_pathv[i];
+          if (access((DEFCHAR *)fnpar,F_OK) != (-1))
+          {
+            Wedit((CHARTYPE *)fnpar);
+            display_error(0,(CHARTYPE *)fnpar,FALSE);
+            rc = RC_OK;
+          }
+          else
+          {
+            display_error(9,(CHARTYPE *)fnpar,FALSE);
+            key = my_getch(stdscr);
+          }
+        }
+        globfree(&glob_results);
+      }
+    }
+    fclose( InFile );
+    file_list_msg = TRUE;
+  }
+  else
+  {
+    display_error(9,(CHARTYPE *)params,FALSE);
+    rc = RC_FILE_NOT_FOUND;
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+
+/*man-start*********************************************************************
+COMMAND
      left - scroll the screen to the left
 
 SYNTAX
@@ -153,6 +259,143 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     leftadjust - left-adjust text in target area: 1st non-blank to left margin
+
+SYNTAX
+     LEFTAdjust [target]
+
+SEE ALSO
+     <CENTER>, <RIGHTADJUST>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Leftad(CHARTYPE *params)
+#else
+short Leftad(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm3.c:   leftad");
+ rc = Format(params,F_LEFT,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     lexpand - expand leading tab characters to spaces
+
+SYNTAX
+     LEXPand [target]
+
+SEE ALSO
+     <LCOMPRESS>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Lexpand(CHARTYPE *params)
+#else
+short Lexpand(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   Lexpand");
+  lefttabconv=TRUE;
+  rc = execute_expand_compress(params,TRUE,TRUE,TRUE,TRUE);
+  lefttabconv=FALSE;
+  TRACE_RETURN();
+  return(rc);
+}
+
+/*man-start*********************************************************************
+COMMAND
+     linesep - split current line delimited by parameter
+
+SYNTAX
+     LINESEP [str]
+
+SEE ALSO
+     <SPLTTOK>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Linesep(CHARTYPE *params)
+#else
+short Linesep(params)
+CHARTYPE *params;
+#endif
+{
+  LINE *curr=NULL;
+  LINETYPE true_line=0L;
+  CHARTYPE *tok, *tmp, *str;
+  CHARTYPE *parpos;
+  char spac[]=" ";
+  short len=0;
+  TRACE_FUNCTION("comm3.c:   Linesep");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    parpos = spac;
+  }
+  else
+  {
+    parpos = params;
+    len = strlen(params);
+    if (len>1 && params[0]==params[len-1])
+    {
+      params[len-1] = 0;
+      parpos++;
+    }
+  }
+  true_line = CURRENT_VIEW->current_line;
+  if (VIEW_TOF(CURRENT_VIEW,true_line) || VIEW_BOF(CURRENT_VIEW,true_line))
+  {
+    display_error(38,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_ENVIRON);
+  }
+  post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+  curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+  len = strlen(curr->line);
+  if ((tmp = (CHARTYPE *)(*the_malloc)(len+1)) == NULL)
+  {
+    display_error(30,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  str = tmp;
+  strcpy(tmp,curr->line);
+  len = strlen(parpos);
+  tok = strstr(tmp,parpos);
+  if (tok)
+  {
+    do
+    {
+      tok = strstr(tmp,parpos);
+      if (tok)
+        tok[0] = '\0';
+      insert_new_line((CHARTYPE *)"",0,1,get_true_line(TRUE),TRUE,FALSE,TRUE,CURRENT_VIEW->display_low,TRUE,FALSE);
+      advance_current_or_focus_line(1);
+      Replace((CHARTYPE *)tmp);
+      tmp = tok+len;
+    } while (tok);
+  }
+  advance_current_or_focus_line(1);
+  (*the_free)(str);
+  TRACE_RETURN();
+  return(RC_OK);
+}
+
 /*man-start*********************************************************************
 COMMAND
      locate - search for a target
@@ -929,6 +1172,137 @@
    TRACE_RETURN();
    return(RC_OK);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     merge - combine two sets of lines, overlay 2nd on 1st at colno
+
+SYNTAX
+     MERGE target1 target2 [c]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Merge(CHARTYPE *params)
+#else
+short Merge(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+#define MERGE_PARAMS 3
+  CHARTYPE *word[MERGE_PARAMS+1];
+  CHARTYPE strip[MERGE_PARAMS];
+  unsigned short num_params=0;
+  int i=0,j=0;
+  LINETYPE start_line=0L, dest_line=0L;
+  LINE *curr=NULL;
+  TARGET target1;
+  short target_type1=TARGET_NORMAL;
+  short target_num_lines=0;
+  char numlines[9] = "";
+  char startlin[10]= ":";
+  char destlin[10] = ":";
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   Merge");
+  strip[0]=STRIP_BOTH;
+  strip[1]=STRIP_BOTH;
+  strip[2]=STRIP_BOTH;
+  num_params = param_split(params,word,MERGE_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+  if (num_params == 0)
+  {
+     display_error(3,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_INVALID_OPERAND);
+  }
+  if (num_params > 3)
+  {
+     display_error(2,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_INVALID_OPERAND);
+  }
+  if (num_params > 1)
+  {
+    start_line = CURRENT_VIEW->current_line;
+    if (start_line == 0 || start_line > CURRENT_FILE->number_lines)
+    {
+      display_error(0,(CHARTYPE *)"Invalid current line",FALSE);
+      TRACE_RETURN();
+      return(RC_INVALID_OPERAND);
+    }
+    itoa_dj(start_line, startlin+1, 10);
+    if (num_params==3)
+    {
+      CURRENT_VIEW->current_column = atoi(word[2]);
+      if (CURRENT_VIEW->current_window != WINDOW_COMMAND)
+        THEcursor_column();
+    }
+    initialise_target(&target1);
+    if ((rc=validate_target(word[0],&target1,target_type1,get_true_line(TRUE),TRUE,TRUE))==RC_OK)
+    {
+      target_num_lines = abs(target1.num_lines);
+      start_line = target1.true_line;
+      itoa_dj(target_num_lines-1, numlines, 10);
+    }
+    rc = execute_locate((CHARTYPE *)word[1], TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+    if (rc != RC_OK)
+    {
+      target_num_lines = 0;
+    }
+    free_target(&target1);
+    if (target_num_lines > 0)
+    {
+      dest_line = CURRENT_VIEW->current_line;
+      itoa_dj(dest_line, destlin+1, 10);
+      curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,start_line,CURRENT_FILE->number_lines);
+      for (i=0; i<target_num_lines; i++)
+      {
+        rc = processable_line(CURRENT_VIEW,start_line+i,curr);
+        switch(rc)
+        {
+           case LINE_SHADOW:
+              break;
+           case LINE_TOF:
+           case LINE_EOF:
+              break;
+           default:
+              break;
+        }
+        rc = execute_locate((CHARTYPE *)destlin, TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+        if (rc == RC_OK)
+        {
+          for (j=0; j<i; j++)
+          {
+            THENext((CHARTYPE *)"");
+          }
+          if (num_params==3)
+          {
+            CURRENT_VIEW->current_column = atoi(word[2]);
+          }
+          rc = column_command((CHARTYPE *)curr->line ,COLUMN_COVERLAY);
+        }
+        curr = curr->next;
+      } //for
+      (void)execute_locate((CHARTYPE *)startlin, TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+      (void)DeleteLine((CHARTYPE *)word[0]);
+      (void)execute_locate((CHARTYPE *)word[1], TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+      if (start_line > CURRENT_VIEW->current_line)
+      {
+        THENext((CHARTYPE *)numlines);
+      }
+    }
+    else
+    {
+      display_error(17,(CHARTYPE *)"",FALSE);
+      TRACE_RETURN();
+      return(RC_TARGET_NOT_FOUND);
+    }
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      modify - display current SET command for alteration
@@ -1017,6 +1391,11 @@
    LINETYPE start_line=0L,end_line=0L,num_lines=0L,dest_line=0L,lines_affected=0L;
    VIEW_DETAILS *old_mark_view=NULL;
 
+   TARGET target1;
+   short target_type1=TARGET_NORMAL;
+   LINETYPE target_abs_lines=0L;
+   char numlines[9] = "";
+   char startlin[10]= ":";
    TRACE_FUNCTION("comm3.c:   THEMove");
    /*
     * This command invalid if source file is readonly...
@@ -1048,6 +1427,48 @@
       TRACE_RETURN();
       return(RC_INVALID_OPERAND);
    }
+   if (num_params == 2
+   && equal((CHARTYPE *)"block",word[0],5) == FALSE)
+   {
+     start_line = CURRENT_VIEW->current_line;
+     if (start_line == 0 || start_line > CURRENT_FILE->number_lines)
+     {
+       display_error(0,(CHARTYPE *)"Invalid current line",FALSE);
+       TRACE_RETURN();
+       return(RC_INVALID_OPERAND);
+     }
+     itoa_dj(start_line, startlin+1, 10);
+     initialise_target(&target1);
+     if ((rc=validate_target(word[0],&target1,target_type1,get_true_line(TRUE),TRUE,TRUE))==RC_OK)
+     {
+       target_abs_lines = abs(target1.num_lines);
+       itoa_dj(target_abs_lines, numlines, 10);
+     }
+     free_target(&target1);
+     rc = Copy((CHARTYPE *)params);
+     if (rc == RC_OK)
+     {
+       (void)Locate((CHARTYPE *)word[1]);
+       if (start_line > CURRENT_VIEW->current_line)
+       {
+         (void)execute_locate((CHARTYPE *)startlin, TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+         (void)THENext((CHARTYPE *)"");
+       }
+       else
+         (void)execute_locate((CHARTYPE *)startlin, TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+       rc = DeleteLine((CHARTYPE *)word[0]);
+       if (rc == RC_OK)
+       {
+         (void)Locate((CHARTYPE *)word[1]);
+         (void)THENext((CHARTYPE *)numlines);
+       }
+       TRACE_RETURN();
+       return(rc);
+     }
+     display_error(17,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_TARGET_NOT_FOUND);
+   }
    /*
     * Test for valid parameters...
     */
@@ -1549,6 +1970,31 @@
    TRACE_RETURN();
    return(RC_OK);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     onespace - makes all whitespace single spaces (as KEDIT RBLANK macro)
+
+SYNTAX
+     ONEspace [target]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Onespc(CHARTYPE *params)
+#else
+short Onespc(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm3.c:   onesp");
+ rc = Format(params,F_1SPC,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      os - execute an operating system command
diff -Naurd orig/comm4.c mod/comm4.c
--- orig/comm4.c	2007-12-13 21:39:13.000000000 +0100
+++ mod/comm4.c	2009-11-02 22:55:50.000000000 +0100
@@ -124,9 +124,25 @@
 /***********************************************************************/
 {
    short rc=RC_OK;
+   bool samescr=FALSE;
+   bool vertical;
 
    TRACE_FUNCTION("comm4.c:   Popup");
+   if (display_screens > 1
+   &&  SCREEN_FILE(0) == SCREEN_FILE(1))
+   {
+     samescr=TRUE;
+     vertical = !horizontal;
+     THEScreen((CHARTYPE *)"1");
+   }
    rc = prepare_popup( params );
+   if (samescr)
+   {
+     if (vertical)
+       THEScreen((CHARTYPE *)"2 v");
+     else
+       THEScreen((CHARTYPE *)"2");
+   }
    TRACE_RETURN();
    return(rc);
 }
@@ -1672,6 +1688,29 @@
 }
 /*man-start*********************************************************************
 COMMAND
+     reverse - reverse order of chars
+
+SYNTAX
+     REVerse [target]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Reverse(CHARTYPE *params)
+#else
+short Reverse(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm4.c:   reverse");
+ rc = Format(params,F_REV,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
      rexx - execute Rexx instructions
 
 SYNTAX
@@ -1739,6 +1778,53 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     ringcmd - execute a command on all files in the ring
+
+SYNTAX
+     RINGCMD command [# command [...]]
+
+SEE ALSO
+     <ENTER>, <COMMAND>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Ringcmd(CHARTYPE *params)
+#else
+short Ringcmd(params)
+CHARTYPE *params;
+#endif
+{
+ bool le_status;
+ VIEW_DETAILS *save_curr;
+ short i, j=number_of_files;
+ TRACE_FUNCTION("comm4.c:   Ringcmd");
+ if (strcmp((DEFCHAR *)params,"") == 0)
+ {
+   display_error(3,(CHARTYPE *)params,FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ for (i=0; i<j; i++)
+ {
+   save_curr = CURRENT_VIEW;
+   le_status=CURRENT_VIEW->linend_status;
+   command_line((CHARTYPE *)"linend on",TRUE);
+   command_line((CHARTYPE *)params,TRUE);
+   if (save_curr == CURRENT_VIEW)
+   {
+     CURRENT_VIEW->linend_status = le_status;
+     Nextwindow((CHARTYPE *)"");
+   }
+ }
+ TRACE_RETURN();
+ return(RC_OK);
+}
+
 /*man-start*********************************************************************
 COMMAND
      rgtleft - scroll the screen to the left or right
@@ -1896,6 +1982,34 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     rightadjust - right-justify text in target area to right MARGIN column
+
+SYNTAX
+     RIGHTAdjust [target]
+
+SEE ALSO
+     <CENTER>, <LEFTADJUST>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Rightad(CHARTYPE *params)
+#else
+short Rightad(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm4.c:   rightad");
+ rc = Format(params,F_RIGHT,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      save - save changes to current file
@@ -1954,6 +2068,188 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     sayf -  store formatted text to editv variable
+
+SYNTAX
+     SAYF variable formstr [params...]
+
+DESCRIPTION %
+     '+'  force a '+' sign on positive numbers
+
+     '0'  to pad numbers with leading zeros
+
+     'c'  single character
+
+     'd' 'D' 'i'  signed integer
+
+     'e' 'E' 'f' 'g' 'G'  floating point number
+
+     's'  string
+
+     'u' 'U'  unsigned integer
+
+     'x' 'X'  unsigned integer, in base 16
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Sayf(CHARTYPE *params)
+#else
+short Sayf(params)
+CHARTYPE *params;
+#endif
+{
+#define SAYF_PARAMS 9
+#define PAR_LEN 256
+  CHARTYPE *word[SAYF_PARAMS+1];
+  CHARTYPE p[SAYF_PARAMS+1][PAR_LEN];
+  CHARTYPE strip[SAYF_PARAMS];
+  CHARTYPE buff[3000];
+  CHARTYPE *beg=NULL;
+  CHARTYPE *end=NULL;
+  LINE *curr=NULL;
+  unsigned short num_params=0;
+  long numl;
+  float numf;
+  short i=0, j=0, k=0;
+  bool ok=TRUE;
+  TRACE_FUNCTION("comm4.c:   Sayf");
+  beg = strpbrk(params,"/'\"|");
+  if (beg!=NULL)
+  {
+    end = strpbrk(beg+1,"/'\"|");
+    if (end!=NULL)
+    {
+      beg[0]=' ';
+      end[0]=' ';
+      beg++;
+      end--;
+      while (beg<end)
+      {
+        if (beg[0]==' ')
+          beg[0] = 0xFF;
+        beg++;
+      }
+    }
+  }
+  for (i=0;i<SAYF_PARAMS;i++)
+    strip[i]=STRIP_BOTH;
+  num_params = param_split(params,word,SAYF_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+  if (num_params < 2)
+  {
+    display_error(3,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  ok = (isalpha(word[0][0]) != 0);
+  for (i=1; i<strlen(word[0]); i++)
+  {
+    if (isalnum(word[0][i]) == 0)
+      ok = FALSE;
+  }
+  if (!ok)
+  {
+    display_error(1,(CHARTYPE *)word[0],FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  for (i=0;i<num_params;i++)
+  {
+    strcpy(p[i],word[i]);
+  }
+  word[0] = make_upper(word[0]);
+  for (i=0; i<strlen(word[1]); i++)
+  {
+    if (word[1][i]==0xFF)
+      word[1][i] = ' ';
+  }
+  j = 1;
+  for (i=0; i<strlen(word[1]); i++)
+  {
+    if (word[1][i]=='%')
+    {
+      strcpy(buff,&word[1][i]);
+      if (buff[1]=='+' || buff[1]=='0')
+      {
+        k = strcspn(buff,"cdefgisuxDEGUX");
+        buff[k+1] = 0;
+        i += k;
+      }
+      else
+      {
+        buff[2] = 0;
+        i++;
+      }
+      j++;
+      if (j>SAYF_PARAMS)
+      {
+        break;
+      }
+      if (word[1][i] == '%')
+        j--;
+      else
+      {
+        p[1][i] = 's';
+        word[j] = make_upper(word[j]);
+        curr = lll_locate(editv,word[j]);
+        if (curr!=NULL)
+          word[j] = curr->line;
+        else
+        {
+          execute_editv(EDITV_PUT,FALSE,word[j]);
+          curr = lll_locate(editv,word[j]);
+          if (curr!=NULL)
+            word[j] = curr->line;
+        }
+        strcpy(p[j],word[j]);
+      }
+      switch (word[1][i])
+      {
+        case 'c':
+          p[j][1] = 0;
+          break;
+        case 'd':
+        case 'D':
+        case 'i':
+        case 'u':
+        case 'U':
+        case 'x':
+        case 'X':
+          sscanf((CHARTYPE *)p[j],"%D",&numl);
+          sprintf(p[j],buff,numl);
+          break;
+        case 'e':
+        case 'E':
+        case 'f':
+        case 'g':
+        case 'G':
+          sscanf((CHARTYPE *)p[j],"%f",&numf);
+          sprintf(p[j],buff,numf);
+          break;
+      }
+    }
+  }
+  strcpy(buff,word[0]);
+  i = strlen(buff);
+  buff[i] = ' ';
+  i++;
+  sprintf(buff+i,p[1],p[2],p[3],p[4],p[5],p[6],p[7],p[8],p[9]);
+  for (; buff[i]!=0; i++)
+    if (buff[i] == 0xFF)
+      buff[i] = ' ';
+  execute_editv(EDITV_SETL,FALSE,buff);
+  TRACE_RETURN();
+  return(RC_OK);
+}
+
 /*man-start*********************************************************************
 COMMAND
      schange - selectively change strings
@@ -2355,6 +2651,7 @@
      A 'sort field' specification consists of:
 
           order flag   - [Ascending|Descending]
+                         (or if numeric: [AN|DN])
           left column  - left column of field to sort on
           right column - right column of field to sort on
 
@@ -2612,6 +2909,82 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     splttok - retrieves tokens from current line which are delimited by
+               characters from parameter, then add to new lines
+
+SYNTAX
+     SPLTTOK [char/s/]
+
+SEE ALSO
+     <LINESEP>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Splttok(CHARTYPE *params)
+#else
+short Splttok(params)
+CHARTYPE *params;
+#endif
+{
+  LINE *curr=NULL;
+  LINETYPE true_line=0L;
+  CHARTYPE *tok;
+  CHARTYPE *tmp;
+  CHARTYPE *parpos;
+  char spac[]=" ";
+  short len=0;
+  TRACE_FUNCTION("comm4.c:   Splttok");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    parpos = spac;
+  }
+  else
+  {
+    parpos = params;
+    len = strlen(params);
+    if (len>1 && params[0]==params[len-1])
+    {
+      params[len-1] = 0;
+      parpos++;
+    }
+  }
+  true_line = CURRENT_VIEW->current_line;
+  if (VIEW_TOF(CURRENT_VIEW,true_line) || VIEW_BOF(CURRENT_VIEW,true_line))
+  {
+    display_error(38,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_ENVIRON);
+  }
+  post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+  curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+  len = strlen(curr->line);
+  if ((tmp = (CHARTYPE *)(*the_malloc)(len+1)) == NULL)
+  {
+    display_error(30,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  strcpy(tmp,curr->line);
+  for (tok=strtok(tmp,parpos); tok; tok=strtok(0,parpos))
+  {
+    if (strcmp(tok,curr->line) != 0)
+    {
+      insert_new_line((CHARTYPE *)"",0,1,get_true_line(TRUE),TRUE,FALSE,TRUE,CURRENT_VIEW->display_low,TRUE,FALSE);
+      advance_current_or_focus_line(1);
+      Replace((CHARTYPE *)tok);
+    }
+  }
+  advance_current_or_focus_line(1);
+  (*the_free)(tmp);
+  TRACE_RETURN();
+  return(RC_OK);
+}
+
 /*man-start*********************************************************************
 COMMAND
      ssave - force SAVE to specified file
diff -Naurd orig/comm5.c mod/comm5.c
--- orig/comm5.c	2008-01-16 14:02:52.000000000 +0100
+++ mod/comm5.c	2009-11-05 20:02:49.000000000 +0100
@@ -1017,6 +1017,111 @@
 
 /*man-start*********************************************************************
 COMMAND
+     tobin - convert to binary list
+
+SYNTAX
+     TOBIN [target]
+
+SEE ALSO
+     <TODEC>, <TOHEX>, <TOCHR>, <EBCDIC>, <TOASCII>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Tobin(CHARTYPE *params)
+#else
+short Tobin(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   tobin");
+ rc = Format(params,F_TOBIN,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     tochr - convert from list
+
+SYNTAX
+     TOCHR [target]
+
+SEE ALSO
+     <TOBIN>, <TODEC>, <TOHEX>, <EBCDIC>, <TOASCII>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Tochr(CHARTYPE *params)
+#else
+short Tochr(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   tochr");
+ rc = Format(params,F_TOCHR,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     todec - convert to decimal list
+
+SYNTAX
+     TODEC [target]
+
+SEE ALSO
+     <TOBIN>, <TOCHR>, <TOHEX>, <EBCDIC>, <TOASCII>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Todec(CHARTYPE *params)
+#else
+short Todec(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   todec");
+ rc = Format(params,F_TODEC,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     tohex - convert to hexadecimal list
+
+SYNTAX
+     TOHEX [target]
+
+SEE ALSO
+     <TOBIN>, <TODEC>, <TOCHR>, <EBCDIC>, <TOASCII>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Tohex(CHARTYPE *params)
+#else
+short Tohex(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   tohex");
+ rc = Format(params,F_TOHEX,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
+/*man-start*********************************************************************
+COMMAND
      top - move to the top of the file
 
 SYNTAX
@@ -1082,6 +1187,58 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     truncate - remove trailing blanks
+
+SYNTAX
+     TRUNCate [target]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Truncate(CHARTYPE *params)
+#else
+short Truncate(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   truncate");
+ rc = Format(params,F_TRUNC,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
+/*man-start*********************************************************************
+COMMAND
+     unjust - left-adjust text and compress blanks
+
+SYNTAX
+     UNJUST [target]
+
+SEE ALSO
+     <JUSTIFY>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Unjust(CHARTYPE *params)
+#else
+short Unjust(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   unjust");
+ rc = Format(params,F_UNJUST,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      up - move backward in the file a number of lines
@@ -1182,6 +1339,420 @@
    TRACE_RETURN();
    return(rc);
 }
+
+/*man-start*********************************************************************
+COMMAND
+     utf - convert Latin-2 to UTF-8
+
+SYNTAX
+     UTF [target]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Utf(CHARTYPE *params)
+#else
+short Utf(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm4.c:   utf");
+ rc = Format(params,F_UTF,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     noutf - convert UTF-8 to Latin-2
+
+SYNTAX
+     NOUTF [target]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Noutf(CHARTYPE *params)
+#else
+short Noutf(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm4.c:   noutf");
+ rc = Format(params,F_LAT,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
+#include <glob.h>
+bool file_list_msg = TRUE;
+/*man-start*********************************************************************
+COMMAND
+     wedit - edit files specifyed with wildcard
+
+SYNTAX
+     Wedit files
+
+SEE ALSO
+     <FSEARCH>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Wedit(CHARTYPE *params)
+#else
+short Wedit(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ #define WED_PARAMS 11
+ unsigned short num_params=0;
+ CHARTYPE *word[WED_PARAMS+1];
+ CHARTYPE *wpars[WED_PARAMS];
+ CHARTYPE strip[WED_PARAMS];
+ register short i,j;
+ glob_t glob_results;
+ short rc=RC_OK;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm5.c:   Wedit");
+ for (i=0;i<WED_PARAMS;i++)
+   strip[i]=STRIP_BOTH;
+ num_params = param_split(params,word,WED_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+ if (num_params == 0)
+ {
+   display_error(3,(CHARTYPE *)"Specify with wildcard!",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ if (num_params >= WED_PARAMS)
+ {
+   display_error(2,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ for (i=0;i<num_params;i++)
+ {
+   if ((wpars[i] = (CHARTYPE *)(*the_malloc)(MAX_FILE_NAME)) == NULL)
+   {
+     display_error(30,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_OUT_OF_MEMORY);
+   }
+   strcpy(wpars[i],word[i]);
+ }
+ for (i=0;i<num_params;i++)
+ {
+   glob(wpars[i], GLOB_NOCHECK, 0, &glob_results);
+   for (j = 0; j<glob_results.gl_pathc; j++)
+   {
+     rc = EditFile((CHARTYPE *)glob_results.gl_pathv[j],FALSE);
+     //if ((rc == RC_OK) && file_list_msg)
+     //{
+     //  display_error(0,glob_results.gl_pathv[j],TRUE);
+     //}
+   }
+   globfree(&glob_results);
+   the_free(wpars[i]);
+ }
+ TRACE_RETURN();
+ return(rc);
+}
+
+/*man-start*********************************************************************
+COMMAND
+     window - get keypress or menu selection to edit variable
+
+SYNTAX
+     WINDow [MENU] </Y/X/str>[/str...]
+
+DESCRIPTION
+     Creates a new window with the Y and X position, writes the string(s),
+     and set WINDKEY edit-variable from the pressed key, or
+     WINDNUM & WINDSTR from the selected menu item.
+
+SEE ALSO
+     <EDITV>, <POPUP>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Wind(CHARTYPE *params)
+#else
+short Wind(params)
+CHARTYPE *params;
+#endif
+{
+#define MAX_LEN 256
+#define MAX_LIN 50
+  WINDOW *fw=NULL, *dw=NULL;
+  short height=0,width=0,y=0,x=0;
+  short i,j,k;
+  bool menu = FALSE;
+  bool loop = TRUE;
+  CHARTYPE *strs[MAX_LIN];
+  char pstr[MAX_LEN];
+  char windkey[9] = "";
+  char del[1] = "";
+  char u = '\0';
+  char *tok;
+  LINE *curr=NULL;
+  CHARTYPE *p=NULL,*str=NULL;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm5.c:   Wind");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(0,(DEFCHAR *)"Usage: WINDow [MENU] </Y/X/str>[/str...]",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if (strcmp((DEFCHAR *)params,"MENU") > 0)
+  {
+    menu = TRUE;
+    strcpy(pstr, &params[5]);
+  }
+  else
+    strcpy(pstr, params);
+  for (i=0; i<MAX_LIN; i++)
+    strs[i] = NULL;
+  i = 0;
+  j = 0;
+  del[0] = pstr[0];
+  del[1] = '\0';
+  for (tok=strtok(pstr,del); tok; tok=strtok(0,del))
+  {
+    switch(i)
+    {
+      case 0:
+        y = atoi(tok);
+        break;
+      case 1:
+        x = atoi(tok);
+        break;
+      case MAX_LIN:
+        tok = NULL;
+        break;
+      default:
+        if ((strs[i-2] = (CHARTYPE *)(*the_malloc)(MAX_LEN)) == NULL)
+        {
+          display_error(30,(CHARTYPE *)"",FALSE);
+          TRACE_RETURN();
+          return(RC_OUT_OF_MEMORY);
+        }
+        k = strlen(tok);
+        if (k > j)
+          j = k;
+        strcpy(strs[i-2],tok);
+        break;
+    }
+    i++;
+  }
+  if (i < 3)
+  {
+    display_error(1,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  else
+  {
+    if (i > terminal_lines)
+      i = terminal_lines;
+    else if (i > MAX_LIN)
+      i = MAX_LIN;
+  }
+  height = i;
+  width = j+2;
+  fw = newwin(height,width,y,x);
+  if (fw == NULL)
+  {
+    display_error( 30, (CHARTYPE *)"", FALSE );
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+#ifdef HAVE_WBKGD
+  wbkgd(fw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+#else
+  wattrset(fw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+  wmove(fw,0,0);
+  wclrtobot(fw);
+#endif
+#if defined(HAVE_BOX)
+  wattrset(fw,set_colour(CURRENT_FILE->attr+ATTR_DIVIDER));
+  box(fw,0,0);
+#endif
+  wnoutrefresh(fw);
+  height -= 2;
+  width -= 2;
+  y++;
+  x++;
+  dw = newwin(height,width,y,x);
+  if (dw == NULL)
+  {
+    delwin(fw);
+    display_error( 30, (CHARTYPE *)"", FALSE );
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  scrollok(dw,FALSE);
+  wattrset(dw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+  wclrtobot(dw);
+  wnoutrefresh(dw);
+  draw_cursor(FALSE);
+  if (menu)
+  {
+    strcpy(pstr,(DEFCHAR *)"WINDNUM");
+    p = make_upper(pstr);
+    curr = lll_locate(editv, p);
+    if ( curr
+    &&   curr->line )
+    {
+       str = curr->line;
+       j = atoi(str);
+       j--;
+       if (j >= height || j < 0)
+         j = 0;
+    }
+    else
+       j = 0;
+    k = 0;
+    while (loop)
+    {
+      wattrset(dw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+      wclrtobot(dw);
+      for (i=0; i<height; i++)
+      {
+        wmove(dw,i,0);
+        waddstr(dw, strs[i]);
+        if (strlen(strs[i]) < width)
+          my_wclrtoeol(dw);
+      }
+      wattrset(dw,set_colour(CURRENT_FILE->attr+ATTR_CURLINE));
+      wmove(dw,j,0);
+      waddstr(dw, strs[j]);
+      if (strlen(strs[j]) < width)
+        my_wclrtoeol(dw);
+      wrefresh(dw);
+      k = wgetch(stdscr);
+#if defined(PDCURSES_MOUSE_ENABLED) || defined(NCURSES_MOUSE_VERSION)
+      if (k == KEY_MOUSE)
+      {
+         int b,ba,bm,my,mx;
+         get_mouse_info(&b,&ba,&bm);
+         if (b != 1
+         ||  ba == BUTTON_PRESSED)
+            continue;
+         wmouse_position(dw, &my, &mx);
+         if (my != -1
+         &&  mx != -1)
+         {
+           if (my == j)
+             k = KEY_ENTER;
+           j = my;
+         }
+      }
+#endif
+      switch(k)
+      {
+        case KEY_UP:
+          if (j>0)
+            j--;
+          else
+            j = height-1;
+          break;
+        case KEY_DOWN:
+          if (j<(height-1))
+            j++;
+          else
+            j = 0;
+          break;
+        case KEY_HOME:
+        case KEY_PPAGE:
+          j = 0;
+          break;
+        case KEY_END:
+        case KEY_NPAGE:
+          j = height-1;
+          break;
+        case KEY_EXIT:
+        case KEY_UNDO:
+        case 27:
+          j = -1;
+        case KEY_ENTER:
+        case 10:
+        case 13:
+          loop = FALSE;
+          break;
+        default:
+          break;
+      }
+      if (k > 0x1F && k < 0x100)
+      {
+        u = toupper(k);
+        i = j+1;
+        for (; i<height && toupper(strs[i][0])!=u; i++)
+        {
+        }
+        if (i<height)
+          j = i;
+        else
+        {
+          i = 0;
+          for (; i<j && toupper(strs[i][0])!=u; i++)
+          {
+          }
+          if (i<j)
+            j = i;
+        }
+      }
+    }
+    itoa_dj(j+1, windkey, 10);
+    strcpy(pstr,(DEFCHAR *)"WINDNUM ");
+    strcat(pstr, windkey);
+    execute_editv(EDITV_SETL,FALSE,pstr);
+    strcpy(pstr,(DEFCHAR *)"WINDSTR ");
+    if (j != -1)
+      strcat(pstr, strs[j]);
+    rc = execute_editv(EDITV_SETL,FALSE,pstr);
+  }
+  else
+  {
+    for (i=0; i<height; i++)
+    {
+      wmove(dw,i,0);
+      waddstr(dw, strs[i]);
+      if (strlen(strs[i]) < width)
+        my_wclrtoeol(dw);
+    }
+    wrefresh(dw);
+    i = my_getch(stdscr);
+    strcpy(windkey,(DEFCHAR *)"WINDKEY ?");
+    windkey[8] = (char)i;
+    rc = execute_editv(EDITV_SETL,FALSE,windkey);
+  }
+  delwin(dw);
+  delwin(fw);
+  wmove(CURRENT_WINDOW_COMMAND,0,0);
+  my_wclrtoeol(CURRENT_WINDOW_COMMAND);
+  wmove(CURRENT_WINDOW_COMMAND,0,0);
+  CURRENT_VIEW->cmdline_col = -1;
+  THERefresh((CHARTYPE *)"");
+  draw_cursor(TRUE);
+  restore_THE();
+  for (i=0; i<MAX_LIN; i++)
+  {
+    if (strs[i] != NULL)
+      the_free(strs[i]);
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+
 /*man-start*********************************************************************
 COMMAND
      xedit - edit another file or switch to next file
diff -Naurd orig/command.h mod/command.h
--- orig/command.h	2007-05-14 02:47:22.000000000 +0200
+++ mod/command.h	2009-11-05 20:07:03.000000000 +0100
@@ -548,5 +548,57 @@
  {(CHARTYPE *)"the",         3,  (-1),            Xedit,            TRUE, FALSE,FALSE,TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,FALSE,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
  {(CHARTYPE *)"untaa",       5,  (-1),            Untaa,            TRUE, TRUE, FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* commset2.c */
  {(CHARTYPE *)"zone",        1,  (-1),            Zone,             TRUE, TRUE, FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* commset2.c */
+ {(CHARTYPE *)"ansicstr",    5,  (-1),            Ansicstr,         FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"banner",      6,  (-1),            Banner,           FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"calc",        4,  (-1),            Calc,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"center",      2,  (-1),            Center,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+#if defined(PDC_CLIP_SUCCESS)
+ {(CHARTYPE *)"clp",         3,  (-1),            Clipboard,        TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+#endif
+ {(CHARTYPE *)"ebcdic",      6,  (-1),            Ebcdic,           FALSE,FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"eval",        4,  (-1),            Eval,             TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"flow",        4,  (-1),            Flow,             TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"forcesave",   9,  (-1),            Fsave,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"fsearch",     7,  (-1),            FSearch,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"hlowercase",  4,  (-1),            HLowercase,       TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"hsort",       5,  (-1),            HSort,            TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"huppercase",  4,  (-1),            HUppercase,       TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"justify",     4,  (-1),            Justify,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"lcompress",   5,  (-1),            Lcompress,        TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_NONE,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"ledit",       5,  (-1),            Ledit,            TRUE, FALSE,FALSE,TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,FALSE,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"leftadjust",  5,  (-1),            Leftad,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"lexpand",     4,  (-1),            Lexpand,          TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"linesep",     7,  (-1),            Linesep,          TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"merge",       5,  (-1),            Merge,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"noutf",       5,  (-1),            Noutf,            TRUE, FALSE,FALSE,TRUE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"onespace",    3,  (-1),            Onespc,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"reverse",     3,  (-1),            Reverse,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"rightadjust", 6,  (-1),            Rightad,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"ringcmd",     7,  (-1),            Ringcmd,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"sayf",        4,  (-1),            Sayf,             TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"splttok",     7,  (-1),            Splttok,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"tobin",       5,  (-1),            Tobin,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"tochr",       5,  (-1),            Tochr,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"todec",       5,  (-1),            Todec,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"tohex",       5,  (-1),            Tohex,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"truncate",    5,  (-1),            Truncate,         TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"unjust",      6,  (-1),            Unjust,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"utf",         3,  (-1),            Utf,              TRUE, FALSE,FALSE,TRUE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"wedit",       1,  (-1),            Wedit,            TRUE, FALSE,FALSE,TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,FALSE,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"window",      4,  (-1),            Wind,             TRUE, FALSE,FALSE,TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,FALSE,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"copy",        0,  ALT_C,           Copy,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"block reset"},  /* comm1.c */
+ {(CHARTYPE *)"copy",        0,  ALT_K,           Copy,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"block"},  /* comm1.c */
+ {(CHARTYPE *)"delete",      0,  ALT_G,           DeleteLine,       FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_NONE         ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"block"}, /* comm2.c */
+ {(CHARTYPE *)"duplicate",   0,  ALT_D,           Duplicate,        TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)"1 BLOCK"},  /* comm2.c */
+ {(CHARTYPE *)"fillbox",     4,  ALT_F,           Fillbox,          FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"mark",        0,  ALT_L,           Mark,             FALSE,FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_NONE         ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"line"},  /* comm3.c */
+ {(CHARTYPE *)"mark",        0,  ALT_B,           Mark,             FALSE,FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_NONE         ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"box"},  /* comm3.c */
+ {(CHARTYPE *)"move",        4,  ALT_M,           THEMove,          FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"block reset"},  /* comm3.c */
+ {(CHARTYPE *)"overlaybox",  8,  ALT_O,           Overlaybox,       FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""}, /* comm3.c */
+ {(CHARTYPE *)"reset",       0,  ALT_U,           Reset,            FALSE,FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)"block"},  /* comm4.c */
+ {(CHARTYPE *)"delword",     4,  ALT_W,           Sos_delword,      FALSE,FALSE,TRUE, TRUE, FALSE,STRIP_BOTH,TRUE, FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* commsos.c */
+ {(CHARTYPE *)"edit",        4,  ALT_X,           Sos_edit,         FALSE,FALSE,TRUE, TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* commsos.c */
+ {(CHARTYPE *)"split",       2,  ALT_S,           Split,            FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"aligned cursor"},  /* comm4.c */
+ {(CHARTYPE *)"join",        1,  ALT_J,           Join,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"aligned cursor"},  /* comm2.c */
  {NULL,                      0,  (-1),            NULL,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_NONE,FALSE,FALSE,TRUE ,CUA_NONE         ,THIGHLIGHT_NONE         ,(CHARTYPE *)""}
 };
diff -Naurd orig/commset1.c mod/commset1.c
--- orig/commset1.c	2008-02-29 01:56:44.000000000 +0100
+++ mod/commset1.c	2009-03-11 16:20:00.000000000 +0100
@@ -5916,6 +5916,23 @@
       return(RC_INVALID_OPERAND);
    }
    strcpy( (DEFCHAR *)the_macro_path, (DEFCHAR *)the_macro_path_buf );
+#if defined(UNIX)
+# define PATH_END "/:."
+# define PATH_END2 ":."
+#else
+# define PATH_END "/;."
+# define PATH_END2 ";."
+#endif
+   if (strcmp((DEFCHAR *)(the_macro_path+len-3),PATH_END) != 0)
+   {
+     if ((char)the_macro_path[len-1] != '/')
+     {
+       strcat((DEFCHAR *)the_macro_path,"/");
+       len++;
+     }
+     strcat((DEFCHAR *)the_macro_path,PATH_END2);
+     len += 2;
+   }
    /*
     * Count the number of PATH_DELIM in the buffer to determine
     * how many pointers to allocate.
diff -Naurd orig/commset2.c mod/commset2.c
--- orig/commset2.c	2008-02-29 01:56:44.000000000 +0100
+++ mod/commset2.c	2009-03-11 16:23:00.000000000 +0100
@@ -1866,7 +1866,7 @@
 /***********************************************************************/
 {
 #define SCR_PARAMS  3
-#define SCR_MIN_LINES 3
+#define SCR_MIN_LINES 4
    CHARTYPE *word[SCR_PARAMS+1];
    CHARTYPE strip[SCR_PARAMS];
    register short i=0;
@@ -1985,7 +1985,7 @@
    }
    else
    {
-      if (!valid_positive_integer(word[0]))
+      if (!valid_positive_integer(word[0]) || (*word[0]=='0'))
       {
          display_error(1,word[0],FALSE);
          TRACE_RETURN();
diff -Naurd orig/commutil.c mod/commutil.c
--- orig/commutil.c	2008-01-07 22:19:25.000000000 +0100
+++ mod/commutil.c	2009-03-11 16:34:00.000000000 +0100
@@ -2968,6 +2968,8 @@
    bool tabs_exhausted=FALSE;
    bool state=FALSE;
    LENGTHTYPE tabcol=0;
+   bool more=TRUE;
+   short k=0;
 
    TRACE_FUNCTION("commutil.c:tabs_convert");
    /*
@@ -2977,7 +2979,7 @@
    {
       for (i=0,j=0;i<curr->length;i++)
       {
-         if (curr->line[i] == '\t')
+         if (curr->line[i] == '\t' && more)
          {
             if (use_tabs)
             {
@@ -3022,6 +3024,11 @@
             trec[j++] = curr->line[i];
             if (j >= max_line_length)
               break;
+            if (lefttabconv)
+            {
+              if (more)
+                more = isspace(curr->line[i]);
+            }
          }
       }
       /*
@@ -3048,6 +3055,15 @@
    }
    else
    {
+      if (lefttabconv)
+      {
+        for (k=0; (k<curr->length) && isspace(curr->line[k]); k++)
+          {
+          }
+        k++;
+      }
+      else
+        k=curr->length;
       for (i=(curr->length)-1,j=0;i>(-1);i--)
       {
          switch(state)
@@ -3055,7 +3071,7 @@
             case STATE_NORMAL:
                trec[j++] = *(curr->line+i);
                if (is_tab_col(i+1)
-               &&  i != 0)
+               &&  i != 0 && i<k)
                {
                   if (*(curr->line+(i-1)) == ' ')
                   {
@@ -4002,6 +4018,7 @@
    int key=0;
    short rc=RC_OK;
    CHARTYPE buf[3];
+   register short i;
 
    TRACE_FUNCTION("commutil.c:readv_cmdline");
    if ( CURRENT_WINDOW_COMMAND == (WINDOW *)NULL )
@@ -4012,6 +4029,14 @@
    }
    buf[1] = '\0';
    Cmsg(initial);
+   if (dialogw)
+   {
+     i = strlen((DEFCHAR *)initial);
+     for (; (DEFCHAR *)initial[i-1]==' ' && i>=0; i--)
+     {
+     }
+     start_col = i;
+   }
    if ( start_col == -1 )
       THEcursor_cmdline( (short)(strlen( (DEFCHAR *)initial ) + 1 ) );
    else
@@ -4031,6 +4056,28 @@
          continue;
 #endif
 #if defined(PDCURSES_MOUSE_ENABLED) || defined(NCURSES_MOUSE_VERSION)
+      if (key==9 && dialogw)
+      {
+        rc = RC_READV_TERM;
+        break;
+      }
+      switch(key)
+      {
+        case PADSLASH:
+          key = '/';
+          break;
+        case PADSTAR:
+          key = '*';
+          break;
+        case PADMINUS:
+          key = '-';
+          break;
+        case PADPLUS:
+          key = '+';
+          break;
+        default:
+          break;
+      }
       if (key == KEY_MOUSE)
       {
          int b,ba,bm,y,x;
diff -Naurd orig/config.h.in mod/config.h.in
--- orig/config.h.in	2008-02-29 01:56:44.000000000 +0100
+++ mod/config.h.in	2010-01-21 22:09:06.000000000 +0100
@@ -209,7 +209,8 @@
 #undef HAVE_MKFIFO
 
 /* Define if you have the rename function.  */
-#undef HAVE_RENAME
+//#undef HAVE_RENAME
+#define HAVE_RENAME 1
 
 /* Define if you have the lstat function.  */
 #undef HAVE_LSTAT
diff -Naurd orig/default.c mod/default.c
--- orig/default.c	2007-05-14 02:24:17.000000000 +0200
+++ mod/default.c	2009-03-11 16:40:00.000000000 +0100
@@ -85,6 +85,8 @@
  CHARTYPE BACKUP_SUFFIXx[101];
  int COMMANDCALLSx=0;
  int FUNCTIONCALLSx=0;
+ bool HuSortFlag=FALSE;
+ bool HuSortCase=FALSE;
 
 /*--------------------------- regular expression syntaxes -------------*/
 struct regexp_syntax _THE_FAR regexp_syntaxes[] =
@@ -115,49 +117,226 @@
 {
    { (CHARTYPE *)"*REXX.TLD",
      (CHARTYPE *)"REXX",
-     (CHARTYPE *)"* REXX\n:case\nignore\n:option\nrexx\nfunction ( noblank\n:number\nrexx\n:identifier\n[a-zA-Z!?_@#$.] [a-zA-Z0-9.!?_@#$]\n" \
-         ":string\nsingle\ndouble\n:comment\npaired /* */ nest\nline -- any\n"                                           \
-         ":label\ndelimiter : any\n:match\n( )\ndo,select end when,otherwise\n:header\nline #! column 1\n"               \
-         ":keyword\naddress type 5\narg type 7\nby type 2\ncall type 5\ncaseless type 2\ndigits type 2\ndo type 5\ndrop type 1\n"         \
-         "else type 1\nend type 1\nengineering type 2\nexit type 1\nexpose type 2\nfor type 2\nforever type 2\n"         \
-         "form type 2\nfuzz type 2\nhalt\nif type 1\ninterpret type 1\niterate type 1\nleave type 1\nlower type 2\nname type 2\nnop type 1\n"  \
-         "novalue\nnumeric type 5\noff type 2\non type 2\noptions type 1\notherwise type 1\nparse type 5\nprocedure type 5\n"     \
-         "pull type 7\npush type 1\nqueue type 1\nreturn type 1\nsay type 1\nscientific type 2\nselect type 1\n"         \
-         "signal type 5\nsource type 2\nsyntax\nto type 2\nthen type 1\ntrace type 5\nuntil type 2\nupper type 2\nvalue type 2\n"  \
-         "var type 2\nversion type 2\nwhen type 1\nwhile type 2\nwith type 2\nstem type 2\noutput type 2\ninput type 2\n"\
-         "error type 2\nappend type 2\nreplace type 2\nnormal type 2\nstream type 2\ndefault type 1\n"                   \
-         "command type 2 alt e\nsystem type 2 alt e\nos2environment type 2 alt e\nenvironment type 2 alt e\n"            \
-         "cmd type 2 alt e\npath type 2 alt e\nregina type 2 alt e\nrexx type 2 alt e\n"                                 \
-         ".line alt e\n.mn alt e\n.rc alt e\n.result alt e\n.rs alt e\n.sigl alt e\n"                                    \
-         ":function\n"                                                                                                   \
-         "abbrev\ncenter\ncentre\nchangestr\ncompare\ncopies\ncountstr\ndatatype\ndelstr\ndelword\nbeep\ndirectory\n"            \
-         "insert\nlastpos\nleft\nlength\nlower\noverlay\npos\nreverse\nright\nspace\nstrip\nsubstr\n"                           \
-         "subword\ntranslate\nverify\nword\nwordindex\nwordlength\nwordpos\nwords\nxrange\n"                             \
-         "abs\nformat\nmax\nmin\nsign\ntrunc\naddress\narg\ncondition\ndigits\nerrortext\nform\n"                        \
-         "fuzz\nsourceline\ntrace\nb2x\nbitand\nbitor\nbitxor\nc2d\nc2x\nd2c\nd2x\nx2b\nx2c\nx2d\n"                      \
-         "charin\ncharout\nchars\nlinein\nlineout\nlines\nqualify\nstream\ndate\nqueued\nrandom\n"                       \
-         "symbol\ntime\nupper\nvalue\nrxfuncdrop\nrxfuncerrmsg\nrxfuncadd\nrxfuncquery\nrxqueue\n"                              \
-         ":postcompare\nclass [-\\/\\+\\=\\*\\<\\>|%&,] alt w\n"
+     (CHARTYPE *)"* REXX\n:case\nignore\n" \
+":option\nrexx\nfunction ( noblank default alt 4\n" \
+":number\nrexx\n" \
+":identifier\n[a-zA-Z!?_@#$.] [a-zA-Z0-9.!?_@#$]\n" \
+":string\nsingle\ndouble\n" \
+":comment\npaired /* */ nest\nline -- any\n" \
+":label\ndelimiter : any\n" \
+":match\n( )\ndo,select end when,otherwise\n" \
+":header\nline #! column 1\nline :: any\n" \
+":keyword\naddress type 5\narg type 7\nby type 2\ncall type 5\n" \
+"caseless type 2\ndigits type 2\ndo type 5\ndrop type 1\n" \
+"else type 1\nend type 1\nengineering type 2\nexit type 1\nexpose type 2\n" \
+"failure\nfor type 2\nforever type 2\nform type 2\nfuzz type 2\nhalt\n" \
+"if type 1\ninterpret type 1\niterate type 1\nleave type 1\nloop type 1\n" \
+"lower type 2\nname type 2\nnop type 1\nnovalue\nnumeric type 5\noff type 2\n" \
+"on type 2\noptions type 1\notherwise type 1\nparse type 5\nprocedure type 5\n" \
+"pull type 7\npush type 1\nqueue type 1\nreturn type 1\nsay type 1\n" \
+"scientific type 2\nselect type 1\nsignal type 5\nsource type 2\nsyntax\n" \
+"to type 2\nthen type 1\ntrace type 5\nuntil type 2\nupper type 2\nvalue type 2\n" \
+"var type 2\nversion type 2\nwhen type 1\nwhile type 2\nwith type 2\nstem type 2\n" \
+"output type 2\ninput type 2\nerror type 2\nappend type 2\nreplace type 2\n" \
+"normal type 2\nstream type 2\ndefault type 1\ncommand type 2 alt e\n" \
+"system type 2 alt e\nos2environment type 2 alt e\nenvironment type 2 alt e\n" \
+"cmd type 2 alt e\npath type 2 alt e\nregina type 2 alt e\nrexx type 2 alt e\n" \
+":function\n" \
+"abbrev\nabs\naddress\narg\nb2x\nbeep\nbitand\nbitor\nbitxor\nc2d\nc2x\ncenter\n" \
+"centre\nchangestr\ncharin\ncharout\nchars\ncompare\ncondition\ncopies\ncountstr\n" \
+"d2c\nd2x\ndatatype\ndate\ndelstr\ndelword\ndigits\ndirectory\nerrortext\nform\n" \
+"format\nfuzz\ninsert\nlastpos\nleft\nlength\nlinein\nlineout\nlines\nlower\n" \
+"max\nmin\noverlay\npos\nqualify\nqueued\nrandom\nreverse\nright\nrxfuncdrop\n" \
+"rxfuncerrmsg\nrxfuncadd\nrxfuncquery\nrxqueue\nsign\nsourceline\nspace\nstream\n" \
+"strip\nsubstr\nsubword\nsymbol\ntime\ntrace\ntranslate\ntrunc\nupper\nvalue\n" \
+"verify\nword\nwordindex\nwordlength\nwordpos\nwords\nx2b\nx2c\nx2d\nxrange\n\n" \
+":postcompare\nclass [-\\/\\+\\=\\*\\<\\>|%&,] alt w\n" \
+"class [Aa]lt\\. alt 3\nclass [Aa]rb[Cc]har\\. alt 3\nclass [Aa]uto[Cc]ol[ou]r\\. alt 3\nclass [Aa]uto[Ss]ave\\. alt 3\n" \
+"class [Aa]uto[Ss]croll\\. alt 3\nclass [Bb]ackup\\. alt 3\nclass [Bb]eep\\. alt 3\nclass [Bb]lock\\. alt 3\nclass [Cc]ase\\. alt 3\n" \
+"class [Cc]lear[Ee]rror[Kk]ey\\. alt 3\nclass [Cc]lear[Ss]creen\\. alt 3\nclass [Cc]lock\\. alt 3\nclass [Cc]md[Aa]rrows\\. alt 3\n" \
+"class [Cc]md[Ll]ine\\. alt 3\nclass [Cc]ol[ou]r\\. alt 3\nclass [Cc]ol[ou]ring\\. alt 3\nclass [Cc]olumn\\. alt 3\nclass [Cc]ompat\\. alt 3\n" \
+"class [Cc]tl[Cc]har\\. alt 3\nclass [Cc]ur[Ll]ine\\. alt 3\nclass [Cc]ursor\\. alt 3\nclass [Cc]ursorstay\\. alt 3\nclass [Dd]efine\\. alt 3\n" \
+"class [Dd]efsort\\. alt 3\nclass [Dd]ialog\\. alt 3\nclass [Dd]ir[Ff]ileid\\. alt 3\nclass [Dd]ir[Ii]nclude\\. alt 3\nclass [Dd]isplay\\. alt 3\n" \
+"class [Ee]col[ou]r\\. alt 3\nclass [Ee][Ff]ileid\\. alt 3\nclass [Ee][Oo][Ff]\\. alt 3\nclass [Ee]olout\\. alt 3\nclass [Ee]quiv[Cc]har\\. alt 3\n" \
+"class [Ee]t[Mm]ode\\. alt 3\nclass [Ff][Ee]xt\\. alt 3\nclass [Ff]ield\\. alt 3\nclass [Ff]ield[Ww]ord\\. alt 3\nclass [Ff]ile[Nn]ame\\. alt 3\nclass [Ff]ile[Ss]tatus\\. alt 3\n" \
+"class [Ff][Mm]ode\\. alt 3\nclass [Ff][Nn]ame\\. alt 3\nclass [Ff][Pp]ath\\. alt 3\nclass [Ff][Tt]ype\\. alt 3\nclass [Ff]ull[Ff][Nn]ame\\. alt 3\n" \
+"class [Gg]et[Ee]nv\\. alt 3\nclass [Hh]eader\\. alt 3\nclass [Hh]ex\\. alt 3\nclass [Hh]ex[Dd]isplay\\. alt 3\nclass [D]hex[Ss]how\\. alt 3\n" \
+"class [Hh]igh[Ll]ight\\. alt 3\nclass [Ii]d[Ll]ine\\. alt 3\nclass [Ii]mp[Mm]acro\\. alt 3\nclass [Ii]mpos\\. alt 3\nclass [Ii]nput[Mm]ode\\. alt 3\n" \
+"class [Ii]nsert[Mm]ode\\. alt 3\nclass [Ll]ast[Kk]ey\\. alt 3\nclass [Ll]ast[Mm]sg\\. alt 3\nclass [Ll]ast[Rr][Cc]\\. alt 3\nclass [Ll]ine\\. alt 3\n" \
+"class [Ll]ine[Ff]lag\\. alt 3\nclass [Ll]in[Ee]nd\\. alt 3\nclass [Ll][Ss]creen\\. alt 3\nclass [Mm]acro\\. alt 3\nclass [Mm]acro[Ee]xt\\. alt 3\n" \
+"class [Mm]acro[Pp]ath\\. alt 3\nclass [Mm]argins\\. alt 3\nclass [Mm]onitor\\. alt 3\nclass [Mm]ouse\\. alt 3\nclass [Mm]sg[Ll]ine\\. alt 3\n" \
+"class [Mm]sg[Mm]ode\\. alt 3\nclass [Nn]b[Ff]ile\\. alt 3\nclass [Nn]b[Ss]cope\\. alt 3\nclass [Nn]ew[Ll]ines\\. alt 3\nclass [Nn]on[Dd]isp\\. alt 3\n" \
+"class [Nn]umber\\. alt 3\nclass [Pp]age[Ww]rap\\. alt 3\nclass [Pp]arser\\. alt 3\nclass [Pp]ending\\. alt 3\n" \
+"class [Pp]oint\\. alt 3\nclass [Pp]opup\\. alt 3\nclass [Pp]osition\\. alt 3\nclass [Pp]refix\\. alt 3\nclass [Pp]rinter\\. alt 3\n" \
+"class [Rr]ead[Oo]nly\\. alt 3\nclass [Rr]eadv\\. alt 3\nclass [Rr]eprofile\\. alt 3\nclass [Rr]eserved\\. alt 3\nclass [Rr][Ee][Xx][Xx]\\. alt 3\n" \
+"class [Rr]exx[Oo]utput\\. alt 3\nclass [Rr]ing\\. alt 3\nclass [Ss]cale\\. alt 3\nclass [Ss]cope\\. alt 3\nclass [Ss]creen\\. alt 3\n" \
+"class [Ss]elect\\. alt 3\nclass [Ss]hadow\\. alt 3\nclass [Ss]how[Kk]ey\\. alt 3\nclass [Ss]ize\\. alt 3\nclass [Ss]tatus[Ll]ine\\. alt 3\n" \
+"class [Ss]tay\\. alt 3\nclass [Ss]ynonym\\. alt 3\nclass [Tt]ab[Kk]ey\\. alt 3\nclass [Tt]ab[Ll]ine\\. alt 3\nclass [Tt]abs\\. alt 3\n" \
+"class [Tt]abs[Ii]n\\. alt 3\nclass [Tt]abs[Oo]ut\\. alt 3\nclass [Tt]arget[Ss]ave\\. alt 3\nclass [Tt]erminal\\. alt 3\nclass [Tt]highlight\\. alt 3\n" \
+"class [Tt]ime[Cc]heck\\. alt 3\nclass [Tt][Oo][Ff]\\. alt 3\nclass [Tt]of[Ee]of\\. alt 3\nclass [Tt]railing\\. alt 3\nclass [Tt]ype[Aa]head\\. alt 3\n" \
+"class [Uu]ndoing\\. alt 3\nclass [Uu]ntaa\\. alt 3\nclass [Vv]er[Ss]hift\\. alt 3\nclass [Vv]erify\\. alt 3\nclass [Ww]idth\\. alt 3\n" \
+"class [Ww]ord[Ww]rap\\. alt 3\nclass [Ww]rap\\. alt 3\nclass [Xx]terminal\\. alt 3\nclass [Zz]zone\\. alt 3\n"
    },
    { (CHARTYPE *)"*C.TLD",
      (CHARTYPE *)"C",
-     (CHARTYPE *)"* C\n:case\nrespect\n:option\npreprocessor #\n:number\nc\n:identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n"       \
-         ":string\nsingle backslash\ndouble backslash\n:comment\npaired /* */ nonest\nline // any\n"                     \
-         ":label\ndelimiter : column 1\n:match\n( )\n{ }\n#ifdef,#if,#ifndef #endif #else,#elif,#elseif\n"               \
-         ":keyword\n#define\n#elif\n#else\n#endif\n#error\n#if\n#ifdef\n#ifndef\n#include\n#line\n#pragma\n#undef\n"     \
-         "auto\nbool\nbreak\ncase\nchar\nconst\ncontinue\ndefault\ndefined alt f\ndelete\ndo\ndouble\nelse\nenum\n"      \
-         "extern\nfloat\nfor\ngoto\nif\nint\nlong\nnew\nregister\nreturn\nshort\nsigned\nsizeof\nstatic\nstruct\n"       \
-         "switch\nthis\ntypedef\nunion\nunsigned\nvoid\nvolatile\nwhile\nclass\nprivate\npublic\n"                             \
+     (CHARTYPE *)"* C\n:case\nrespect\n" \
+         ":option\npreprocessor #\nfunction ( blank default alt 4\n" \
+         ":number\nc\n:identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":string\nsingle backslash\ndouble backslash\n" \
+         ":comment\npaired /* */ nonest\nline // any\n"  \
+         ":label\ndelimiter : column 1\n" \
+         ":match\n( )\n{ }\n#ifdef,#if,#ifndef #endif #else,#elif,#elseif\n" \
+         ":keyword\n#define\n#elif\n#else\n#endif\n#error\n#if\n#ifdef\n" \
+         "#ifndef\n#include\n#line\n#pragma\n#undef\n" \
+         "asm\nauto\nbool\nbreak\ncase\ncatch\nchar\nclass\n\nconst\n" \
+         "continue\ndefault\ndefined alt f\ndelete\ndo\ndouble\nelse\n" \
+         "enum\nexcept\nextern\nfar\nfinally\nfloat\nfor\nfriend\n" \
+         "goto\nhuge\nif\ninline\nint\nlong\nnear\nnew\noperator\n" \
+         "private\nprotected\npublic\nregister\nreturn\nshort\nsigned\n" \
+         "sizeof\nstatic\nstruct\nswitch\ntemplate\nthis\nthrow\ntry\n" \
+         "typedef\nunion\nunsigned\nvoid\nvolatile\nwhile\n" \
+":function\nabort\nabs\nacos\nasctime\nasin\nassert\natan\natan2\natexit\n" \
+"atof\natoi\natol\nbsearch\ncalloc\nceil\nclearerr\nclock\ncos\ncosh\n" \
+"ctime\nctype\ndifftime\ndiv\nexit\nexp\nfabs\nfclose\nfeof\nferror\n" \
+"fflush\nfgetc\nfgetpos\nfgets\nfloor\nfmod\nfopen\nfprintf\nfputc\nfputs\n" \
+"fread\nfree\nfreopen\nfrexp\nfscanf\nfseek\nfsetpos\nftell\nfwrite\n" \
+"getc\ngetchar\ngetenv\ngets\ngmtime\nisalnum\nisalpha\nisascii\niscntrl\n" \
+"isdigit\nisgraph\nislower\nisprint\nispunct\nisspace\nisupper\nisxdigit\n" \
+"labs\nldexp\nldiv\nlocaltime\nlog\nlog10\nlongjmp\nmalloc\nmemchr\n" \
+"memcmp\nmemcpy\nmemmove\nmemset\nmktime\nmodf\nperror\npow\nprintf\nputc\n" \
+"putchar\nputs\nqsort\nraise\nrand\nrealloc\nremove\nrewind\nscanf\n"\ 
+"setbuf\nsetjmp\nsetvbuf\nsignal\nsin\nsinh\nsprintf\nsqrt\nsrand\nsscanf\n" \
+"strcat\nstrchr\nstrcmp\nstrcoll\nstrcpy\nstrcspn\nstrerror\nstrftime\n" \
+"strlen\nstrncat\nstrncmp\nstrncpy\nstrpbrk\nstrrchr\nstrspn\nstrstr\n" \
+"strtod\nstrtok\nstrtol\nstrtoul\nstrxfrm\nsystem\ntan\ntanh\ntime\n" \
+"tmpfile\ntmpnam\ntolower\ntoupper\nungetc\nva_arg\nva_end\nva_start\n" \
+"vfprintf\nvprintf\nvsprintf\n"
          ":postcompare\nclass [-\\/\\+\\=\\*\\<\\>|%&!,] alt x\n"
    },
    { (CHARTYPE *)"*SH.TLD",
      (CHARTYPE *)"SH",
-     (CHARTYPE *)"* SH\n:case\nrespect\n:number\nc\n"       \
-         ":string\nsingle backslash\ndouble backslash\n:identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n"                            \
-         ":comment\nline # any\n:header\nline #! column 1\n"                                                                                        \
-         ":keyword\nif\nfi\nelif\nfor\nuntil\ncase\nesac\nwhile\nthen\nelse\ntest alt 4\nshift alt 4\ndo\ndone\nin\n"          \
-         "continue alt 4\nbreak alt 4\ncd alt 4\necho alt 4\neval alt 4\nexec alt 4\n" \
-         "exit alt 4\nexport alt 4\ngetopts alt 4\nset alt 4\nunset alt 4\ntrap alt 4\n"
+     (CHARTYPE *)"* SH\n:case\nrespect\n:number\nc\n" \
+":string\nsingle backslash\ndouble backslash\n" \
+":identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+":comment\nline # any\n:header\nline #! column 1\n" \
+":keyword\nbreak alt 4\ncase\ncd alt 4\ncontinue alt 4\ndo\ndone\n" \
+"echo alt 4\nelif\nelse\nesac\neval alt 4\nexec alt 4\nexit alt 4\n" \
+"export alt 4\nfi\nfor\nfunction alt r\ngetopts alt 4\nif\nin\nset alt 4\n" \
+"shift alt 4\ntest alt 4\nthen\ntrap alt 4\nunset alt 4\nuntil\nwhile\n\n"
+   },
+   { (CHARTYPE *)"*PERL.TLD",
+     (CHARTYPE *)"PERL",
+     (CHARTYPE *)"* PERL\n:case\nrespect\n" \
+         ":option\npreprocessor #\nfunction ( blank default alt 4\n" \
+         ":number\nc\n:identifier\n[\$] [a-zA-Z0-9_]\n" \
+         ":string\nsingle\ndouble\n" \
+         ":comment\nline # any\n:header\nline #! column 1\n" \
+         ":match\n( )\n{ }\n[ ]\n" \
+":keyword\nBEGIN\nEND\nCORE\n__END__\n__FILE__\n__LINE__\nAUTOLOAD\nDESTROY"\
+"\nabs\naccept\nalarm\nand\natan2\nbind\nbinmode\nbless\ncaller\nchdir\nchmod"\
+"\nchomp\nchop\nchown\nchr\nchroot\nclose\nclosedir\ncmp\nconnect\ncontinue\ncos"\
+"\ncrypt\ndbmclose\ndbmopen\ndefined\ndelete\ndie\ndo\ndump\neach\nelse\nelsif"\
+"\nendgrent\nendhostent\nendnetent\nendprotoent\nendpwent\nendservent\neof"\
+"\neq\neval\nexec\nexists\nexit\nexp\nfcntl\nfileno\nflock\nfor\nforeach\nfork"\
+"\nformat\nformline\nge\ngetc\ngetgrent\ngetgrgid\ngetgrnam\ngethostbyaddr"\
+"\ngethostbyname\ngethostent\ngetlogin\ngetnetbyaddr\ngetnetbyname"\
+"\ngetnetent\ngetpeername\ngetpgrp\ngetppid\ngetpriority\ngetprotobyname"\
+"\ngetprotobynumber\ngetprotoent\ngetpwent\ngetpwnam\ngetpwuid"\
+"\ngetservbyname\ngetservbyport\ngetservent\ngetsockname\ngetsockopt"\
+"\nglob\ngmtime\ngoto\ngrep\ngt\nhex\nif\nindex\nint\nioctl\njoin\nkeys\nkill"\
+"\nlast\nlc\nlcfirst\nle\nlength\nlink\nlisten\nlocal\nlocaltime\nlog\nlstat"\
+"\nlt\nm\nmap\nmkdir\nmsgctl\nmsgget\nmsgrcv\nmsgsnd\nmy\nne\nnext\nno\nnot\noct"\
+"\nopen\nopendir\nor\nord\npack\npackage\npipe\npop\npos\nprint\nprintf\npush\nq"\
+"\nqq\nquotemeta\nqw\nqx\nrand\nread\nreaddir\nreadline\nreadlink\nreadpipe"\
+"\nrecv\nredo\nref\nrename\nrequire\nreset\nreturn\nreverse\nrewinddir\nrindex"\
+"\nrmdir\ns\nscalar\nseek\nseekdir\nselect\nsemctl\nsemget\nsemop\nsend\nsetgrent"\
+"\nsethostent\nsetnetent\nsetpgrp\nsetpriority\nsetprotoent\nsetpwent"\
+"\nsetservent\nsetsockopt\nshift\nshmctl\nshmget\nshmread\nshmwrite\nshutdown"\
+"\nsin\nsleep\nsocket\nsocketpair\nsort\nsplice\nsplit\nsprintf\nsqrt\nsrand"\
+"\nstat\nstudy\nsub\nsubstr\nsymlink\nsyscall\nsysread\nsystem\nsyswrite\ntell"\
+"\ntelldir\ntie\ntime\ntimes\ntr\ntruncate\nuc\nucfirst\numask\nundef\nunless"\
+"\nunlink\nunpack\nunshift\nuntie\nuntil\nuse\nutime\nvalues\nvec\nwait\nwaitpid"\
+"\nwantarray\nwarn\nwhile\nwrite\nx\nxor\ny"
+   },
+   { (CHARTYPE *)"*JAVA.TLD",
+     (CHARTYPE *)"JAVA",
+     (CHARTYPE *)"* JAVA" \
+      ":case\nrespect\n" \
+      ":option\nfunction ( blank default alt 4\n" \
+      ":number\nc\n" \
+      ":identifier\n[a-zA-Z_$] [a-zA-Z0-9_$]\n" \
+      ":string\nsingle backslash\ndouble backslash\n" \
+      ":comment\npaired /* */ nonest\nline // any\n" \
+      ":label\ndelimiter : any\n" \
+      ":match\n( )\n{ }\n" \
+      ":keyword\nabstract\nboolean\nbreak\nbyte\ncase\ncatch\nchar\nclass\n" \
+      "const\ncontinue\ndefault\ndo\ndouble\nelse\nextends\nfinal\nfinally\n" \
+      "float\nfor\ngoto\nif\nimplements\nimport\ninstanceof\nint\ninterface\n" \
+      "long\nnative\nnew\npackage\nprivate\nprotected\npublic\nreturn\nshort\n" \
+      "static\nstrictfp\nsuper\nswitch\nsynchronized\nthis\nthrow\nthrows\n" \
+      "transient\ntry\nvoid\nvolatile\nwhile\n" \
+      ":function\n\n"
+   },
+   { (CHARTYPE *)"*JSCR.TLD",
+     (CHARTYPE *)"JSCR",
+     (CHARTYPE *)"* JSCR" \
+      ":case\nrespect\n" \
+      ":number\nc\n" \
+      ":option\nfunction ( blank default alt 4\n" \
+      ":identifier\n[a-zA-Z_$] [a-zA-Z0-9_]\n" \
+      ":string\nsingle backslash\ndouble backslash\n" \
+      ":comment\npaired /* */ nonest\nline // any\n" \
+      ":label\ndelimiter : firstnonblank\n" \
+      ":match\n( )\n{ }\n[ ]\n" \
+      ":keyword\nabstract\napply\narity\nArray\nboolean\nbreak\nbyte\ncall\n" \
+      "callee\ncaller\ncase\ncatch\nchar\nclass\nclassName\ncompile\nconcat\n" \
+      "const\ncontinue\ndebugger\ndefault\ndelete\ndo\ndouble\nelse\nenum\n" \
+      "exec\nexport\nextends\nfalse alt 2\nfinal\nfinally\nfloat\nfor\nfunction alt 1\n" \
+      "global\ngoto\nif\nignoreCase\nimplements\nimport\nin\nint\ninterface\n" \
+      "Infinity alt 4\njava\nJavaArray\nJavaClass\nJavaObject\nJavaPackage\n" \
+      "index\ninput\nlabel\nlastIndex\nlastMatch\nlastParen\nleftContext\n" \
+      "instanceof\nitalics\nlink\nlong\nmatch\nmultiline\nMath\nNaN alt 4\n" \
+      "native\nnetscape\nnew\nnull\nNumber\nObject\npackage\nPackages\nparse\n" \
+      "pop\nprivate\nprotected\npublic\npush\nRegExp\nreplace\nreturn\nrightContext\n" \
+      "search\nshift\nshort\nsource\nsplice\nslice\nsmall\nstatic\nstrike\n" \
+      "String\nsub\nsuper\nsup\nswitch\nsynchronized\ntest\nthis\nthrow\n" \
+      "throws\ntransient\ntrue alt 2\ntry\ntypeof\nvar alt 3\nundefined alt 4\n" \
+      "unshift\nunwatch\nvoid\nvolatile\nwatch\nwhile\nwith\nform alt 7\n" \
+      "value alt 7\narguments alt 7\nconstructor alt 7\nE alt 7\nlength alt 7\n" \
+      "LN10 alt 7\nLN2 alt 7\nLOG10E alt 7\nLOG2E alt 7\nMAX_VALUE alt 7\n" \
+      "MIN_VALUE alt 7\nNEGATIVE_INFINITY alt 7\nPI alt 7\nPOSITIVE_INFINITY alt 7\n" \
+      "prototype alt 7\nSQRT1_2 alt 7\nSQRT2 alt 7\n" \
+      ":function\nalert\nescape\neval\nisFinite\nisNaN\nnumber\nparsefloat\n" \
+      "parseint\nstring\nunescape\nclick\nchange\nblur\nfocus\nabs\nacos\n" \
+      "asin\natan\natan2\natend\nceil\ncharAt\ncharCodeAt\ncos\nDate\nexp\n" \
+      "floor\nfromCharCode\ngetDate\ngetDay\ngetFullYear\ngetHours\ngetMilliseconds\n" \
+      "getMinutes\ngetMonth\ngetSeconds\ngetTime\ngetTimezoneOffset\ngetUTCDate\n" \
+      "getUTCDay\ngetUTCFullYear\ngetUTCHours\ngetUTCMilliseconds\ngetUTCMinutes\n" \
+      "getUTCMonth\ngetUTCSeconds\ngetYear\nindexOf\nitem\njoin\nlastIndexOf\n" \
+      "log\nmax\nmin\nmovefirst\nmovenext\nparse\nparseFloat\nparseInt\n" \
+      "pow\nrandom\nreverse\nround\nsetDate\nsetFullYear\nsetHours\nsetMilliseconds\n" \
+      "setMinutes\nsetMonth\nsetSeconds\nsetTime\nsetUTCDate\nsetUTCFullYear\n" \
+      "setUTCHours\nsetUTCMilliseconds\nsetUTCMinutes\nsetUTCMonth\nsetUTCSeconds\n" \
+      "setUTCTime\nsetyear\nsin\nsort\nsplit\nsqrt\nsubstr\nsubstring\nsun\n" \
+      "tan\ntoGMTString\ntoLocaleString\ntoLowerCase\ntoSource\ntoString\n" \
+      "toUpperCase\ntoUTCString\nUTC\nvalueOf\n\n"
+   },
+   { (CHARTYPE *)"*SPEC.TLD",
+     (CHARTYPE *)"SPEC",
+     (CHARTYPE *)"* SPEC" \
+            ":case\nignore\n" \
+            ":identifier\n[a-zA-Z_{] [a-zA-Z0-9_{}:]\n" \
+            ":comment\nline dnl any\nline # any\n" \
+            ":header\nline % column 1\n" \
+":keyword\nautoprov: alt 5\nautoreq: alt 5\nautoreqprov: alt 5\n" \
+"buildroot: alt 5\nconflicts: alt 5\nepoch: alt 5\nexcludearch: alt 5\n" \
+"excludeos: alt 5\nexclusivearch: alt 5\nexclusiveos: alt 5\ngroup: alt 5\n" \
+"icon: alt 5\nlicense: alt 5\nname: alt 5\nnopatch: alt 5\nnosource: alt 5\n" \
+"packager: alt 5\npatch: alt 5\nprefix: alt 5\nprovides: alt 5\n" \
+"release: alt 5\nrequires: alt 5\nsource: alt 5\nsummary: alt 5\n" \ 
+"url: alt 5\nvendor: alt 5\nversion: alt 5\n{_tmppath}\n{buildroot}\n" \
+"{group}\n{license}\n{name}\n{packager}\n{prefix}\n{provides}\n{release}\n" \
+"{source}\n{summary}\n{url}\n{vendor}\n{version}\n\n"
    },
    { (CHARTYPE *)"*TLD.TLD",
      (CHARTYPE *)"TLD",
@@ -173,22 +352,242 @@
          ":string\ndouble\n" \
          ":comment\npaired <! > nonest\n" \
          ":markup\ntag < >\nreference & ;\n"
+/*
+":keyword\n<a\n<script\n</script\nhref\n<img\nsrc\n<pre\n<p\n</p\n</a\n<br"       \
+"\n<b\n</b\n</pre\n<xmp\n</xmp\n<table\n</table\n<table\n<center\n</center"       \
+"\n<i\n</i\n<h1\n</h1\n<h2\n</h2\n<h3\n</h3\n<h4\n</h4\n<h5\n</h5\n<h6\n</h6"     \
+"\n<td\n</td\n<tr\n</tr\n<li\n</li\n<menu\n</menu\n<u\n</u\n<font\n</font\n<hr"   \
+"\n<title\n</title\n<html\n</html\n<head\n</head\n<meta\nwidth\nheight\n<body"    \
+"\n</body\nalign\nvalign\n<applet\n<param\nname\nvalue\narchive\ncode\ncodebase"  \
+"\n</applet\nalt\nismap\nborder\nface\nsize\ntarget\ncellspacing\nhspace\nvspace" \
+"\ncellpadding\nbgcolor\ncolor\nnowrap\ncenter\nbottom\nleft\nright\ncolspan"     \
+"\n<form\n</form\nmethode\npost\naction\n<input\ntype\ntop\n_top\n<tt\n</tt"      \
+"\ncontent\n<map\n</map\n<area\nshape\ncoords\nnohref\nonclick\nonmouseover"      \
+"\nrowspan\n<blockquote\n</blockquote\n<em\n</em\ntext\nlink\nvlink\n<ul\n</ul"   \
+"\n<ol\n</ol\nmethod\nenctype\nmaxlength\n<textarea\nrows\ncols\n</textarea"      \
+"\n<dl\n</dl\n<dt\n<option\n<select\n</select\nselected\nonUnLoad\n<sup\n</sup"   \
+"\nbackground\nscrolling\nnoresize\nframeborder\nonload\nalink\nlanguage"         \
+"\n<div\n</div\n<frameset\n</frameset\n<noframes\n</noframes\n<frame\n</frame"    \
+"\n<strong\n</strong\n<dd\n<base\n<cite\n</cite\n<code\n</code\n</option\n<nobr"  \
+"\nhttp-equiv\n<sub\n</sub\n<th\n</th\n<blink\n</blink\n<noscript\n</noscript"    \
+"\nstyle\nclear\n<link\n<style\n</style\n<col\n<colgroup\n</colgroup"             \
+"\n<tbody\n</tbody\n<thead\n</thead\n<tfoot\n</tfoot\nrel\nrev"
+*/
    },
    { (CHARTYPE *)"*DIR.TLD",
      (CHARTYPE *)"DIR",
      (CHARTYPE *)"* DIR\n" \
-         ":case\nignore\n" \
-         ":directory\n" \
-         "directory alt a\n" \
-         "executable\n" \
-         "link\n" \
-         "extensions .bak alt 8\n" \
-         "extensions .the alt 1\n" \
-         "extensions .c .cc .cpp .h .hpp alt 2\n" \
-         "extensions .rex .rexx .cmd alt 3\n" \
-         "extensions .exe .dll alt 6\n" \
-         "extensions .zip .Z .gz .tgz alt w\n" \
-         "extensions Makefile .mak alt 4\n"
+         ":column\nexclude 1 38\n" \
+         ":postcompare\ntext -> alt 1\n" \
+         "class .*\\.bak$ alt 8\n" \
+         "class .*Makefile alt 4\n" \
+         "class .*makefile.*$ alt 4\n" \
+         "class .*\\.mak$ alt 4\n" \
+         "class .*\\.[eE][xX][eE]$ alt 6\n" \
+         "class .*\\.dll$ alt 6\n" \
+         "class .*\\.[cC][oO][mM]$ alt 6\n" \
+         "class .*\\.[bB][aA][tT]$ alt 6\n" \
+         "class .*\\.[cC]$ alt 2\n" \
+         "class .*\\.[cC][cC]$ alt 2\n" \
+         "class .*\\.[cC][pP][pP]$ alt 2\n" \
+         "class .*\\.[hH]$ alt 2\n" \
+         "class .*\\.[hH][pP][pP]$ alt 2\n" \
+         "class .*\\.[pP][aA][sS]$ alt 2\n" \
+         "class .*\\.[aA][sS][mM]$ alt 2\n" \
+         "class .*\\.[tT][hH][eE]$ alt 1\n" \
+         "class .*\\.rexx$ alt 3\n" \
+         "class .*\\.rex$ alt 3\n" \
+         "class .*\\.cmd$ alt 3\n" \
+         "class .*\\.[bB][aA][kK]$ alt 8\n" \
+         "class .*\\.[zZ][iI][pP]$ alt 5\n" \
+         "class .*\\.Z$ alt 5\n"   \
+         "class .*\\.gz$ alt 5\n"  \
+         "class .*\\.tgz$ alt 5\n"
+   },
+   { (CHARTYPE *)"*ASM.TLD",
+     (CHARTYPE *)"ASM",
+     (CHARTYPE *)"* ASM\n:case\nignore\n" \
+         ":option\npreprocessor #\nfunction ( noblank\n" \
+         ":number\nc\n:identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":string\nsingle\ndouble\n:comment\nline ; any\n" \
+         ":label\n* column 1\n:header\nline ; firstnonblank\n" \
+         ":keyword\naaa\naad\naam\naas\nadc\nadd\nah\nal\nalign\nalpha\n" \
+         "and\narpl\nassume\nax\nbh\nbl\nbound\nbp\nbsf\nbsr\nbswap\nbt\n" \
+         "btc\nbtr\nbts\nbx\nbyte\ncall\ncbw\ncdq\nch\ncl\nclc\ncld\ncli\n" \
+         "clts\ncmc\ncmp\ncmps\ncmpsb\ncmpsd\ncmpsw\ncmpxchg\ncode\ncomm\n" \
+         "con\nconst\ncr0\ncr2\ncr3\ncref\ncs\ncwd\ncwde\ncx\ndaa\ndas\n" \
+         "data\ndb\ndd\ndec\ndf\ndh\ndi\ndiv\ndl\ndosseg\ndq\ndr0\ndr1\ndr2\n" \
+         "dr3\ndr6\ndr7\nds\ndt\ndup\ndw\ndword\ndx\neax\nebp\nebx\necx\n" \
+         "edi\nedx\neip\nelse\nend\nendif\nendm\nendp\nends\nenter\neq\nequ\n" \
+         "err\nerr1\nerr2\nerrb\nerrdef\nerrdif\nerrdifi\nerre\nerridn\n" \
+         "erridni\nerrnb\nerrndef\nerrnz\nes\nesc\nesi\nesp\neven\nexitm\n" \
+         "extrn\nf2xm1\nfabs\nfadd\nfaddp\nfar\nfardata\nfbld\nfbstp\nfchs\n" \
+         "fcom\nfcomp\nfcompp\nfcos\nfdiv\nfdivp\nfdivr\nfdivrp\nfiadd\nfidiv\n" \
+         "fild\nfimul\nfinit\nfist\nfistp\nfisub\nfld\nfld1\nfldcw\nfldl2e\n"\
+         "fldl2t\nfldpi\nfldz\nfmul\nfmulp\nfmulr\nfmulrp\nfninit\nfnsave\n" \
+         "fnstsw\nfprem\nfpatan\nfptan\nfrndint\nfs\nfscale\nfsin\nfsincos\n"\
+         "fsqrt\nfst\nfstcw\nfstp\nfstsw\nfsub\nfsubp\nfsubrp\nftst\nfwait\n" \
+         "fword\nfxam\nfxch\nfyl2x\nge\ngroup\ngs\ngt\nhigh\n" \
+         "hlt\nidiv\nif\nif1\nif2\nifb\nifdef\nifdif\nifdifi\nife\nifidn\n" \
+         "ifidni\nifnb\nifndef\nimul\nin\ninc\ninclude\nincludelib\nins\n" \
+         "insb\ninsd\ninsw\nint\ninto\ninvd\ninvlpg\nip\niret\niretd\nirpc\n" \
+         "ja\njae\njb\njbe\njc\njcxz\nje\njecxz\njg\njge\njl\njle\njmp\njna\n" \
+         "jnae\njnb\njnbe\njnc\njne\njng\njnge\njnl\njnle\njno\njnp\njns\n" \
+         "jnz\njo\njp\njpe\njpo\njs\njz\nlabel\nlahf\nlall\nlar\nlds\nle\n" \
+         "lea\nleave\nlength\nles\nlfcond\nlfs\nlgdt\nlgs\nlidt\nline\nlist\n" \
+         "lldt\nlmsw\nlocal\nlock\nlods\nlodsb\nlodsd\nlodsw\nloop\nloope\n" \
+         "loopne\nloopnz\nloopz\nlow\nlsl\nlss\nlt\nltr\nmacro\nmask\nmod\n" \
+         "model\nmov\nmovs\nmovsb\nmovsd\nmovsw\nmovsx\nmovzx\nmul\nname\n" \
+         "ne\nnear\nneg\nnop\nnot\nnothing\noffset\nor\norg\nout\nouts\n" \
+         "outsb\noutsd\noutsw\npage\npop\npopa\npopad\npopf\nproc\nptr\n" \
+         "public\npurge\npush\npusha\npushad\npushf\nqword\nradix\nrcl\n" \
+         "rcr\nrecord\nrep\nrepe\nrepne\nrepnz\nrept\nrepz\nret\nretf\n" \
+         "retn\nrol\nror\nsahf\nsal\nsar\nsbb\nscas\nscasb\nscasd\nscasw\n" \
+         "seg\nsegcs\nsegds\nseges\nsegfs\nseggs\nsegment\nsegss\nseq\n" \
+         "setae\nsetb\nsetbe\nsetc\nsete\nsetg\nsetge\nsetl\nsetle\nsetna\n" \
+         "setnae\nsetnb\nsetnc\nsetne\nsetng\nsetnge\nsetnl\nsetnle\nsetno\n" \
+         "setnp\nsetns\nsetnz\nseto\nsetp\nsetpe\nsetpo\nsets\nsetz\nsfcond\n" \
+         "sgdt\nshl\nshld\nshort\nshr\nshrd\nsi\nsidt\nsize\nsldt\nsmsw\n" \
+         "sp\nss\nstack\nstc\nstd\nsti\nstos\nstosb\nstosd\nstosw\nstr\n" \
+         "struc\nsub\nsubttl\ntbyte\ntest\ntfcond\nthis\ntitle\ntr4\ntr5\n" \
+         "tr6\ntr7\ntype\nverr\nverw\nwait\nwbinvd\nwidth\nword\nxall\n" \
+         "xchg\nxcref\nxlat\nxlatb\nxlist\nxor\n"
+   },
+   { (CHARTYPE *)"*BAT.TLD",
+     (CHARTYPE *)"BAT",
+     (CHARTYPE *)"* BAT\n:case\nignore\n" \
+         ":option\npreprocessor @\npreprocessor %\n" \
+         ":identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":string\nsingle\ndouble\n\n:comment\nline rem firstnonblank\n" \
+         ":header\nline : column 1\n"
+         ":keyword\nbreak\ncall\ncd\nchcp\nchdir\ncls\ncopy\ndate\ndel\n" \
+         "delete\ndir\necho\nerase\nexit\nfor\ngoto\nif\nlh\nloadhigh\nmd\n" \
+         "mkdir\npath\npause\nprompt\nrd\nren\nrename\nrmdir\nset\nshift\n" \
+         "time\ntype\nver\nverify\nvol"
+   },
+   { (CHARTYPE *)"*PASCAL.TLD",
+     (CHARTYPE *)"PASCAL",
+     (CHARTYPE *)"* PAS\n:case\nignore\n" \
+         ":option\npreprocessor #\nfunction ( blank\n" \
+         ":number\nC\n:string\nsingle\n" \
+         ":identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":comment\npaired (* *) nonest\npaired { } nonest\nline // any\n" \
+         ":header\nline program firstnonblank\nline unit firstnonblank\n" \
+         "line interface firstnonblank\nline implementation firstnonblank\n" \
+         "line procedure firstnonblank\nline function firstnonblank\n" \
+         ":label\n* Borland!\ndelimiter @ firstnonblank\n" \
+         ":match\n(. .)\n( )\n[ ]\n" \
+         ":keyword\nand\narray\nbegin\ncase\nconst\ndiv\ndo\ndownto\n" \
+         "else\nend\nfile\nfor\nfunction\ngoto\nif\nin\nlabel\nmod\n" \
+         "nil\nnot\nof\nor\npacked\nprocedure\nprogram\nrecord\nrepeat\n" \
+         "set\nthen\nto\ntype\nuntil\nvar\nwhile\nwith\n" \
+         "boolean\nbyte\nchar\nextended\ninteger\nlongint\npointer\nreal\n" \
+         "shortint\nstring\nword\ntrue\nfalse\nasm\nbreak\nconstructor\n" \
+         "continue\ndestructor\nexit\nexports\nhalt\nimplementation\n" \
+         "inherited\ninline\ninterface\nlibrary\nobject\nprivate\npublic\n" \
+         "shl\nshr\nunit\nuses\nxor\n" \
+         "absolute\nabstract\nassembler\nexternal\nforward\ninterrupt\n" \
+         "read\nreadln\nvirtual\nwrite\nwriteln\n" \
+         ":function\nabs\naddr\nappend\narctan\nassign\nassigned\nchr\n" \
+         "close\nconcat\ncopy\ncos\ndec\ndelete\ndispose\ndouble\neof\neoln\n" \
+         "exp\nfillchar\nflush\nfrac\nfreemem\ngetmem\nhi\ninc\ninsert\nint\n" \
+         "ioresult\nlength\nln\nlo\nmark\nmaxavail\nmaxint\nmaxlongint\nmem\n" \
+         "memavail\nmemw\nmove\nnew\nodd\nofs\nord\nparamcount\nparamstr\n" \
+         "pchar\npi\nport\nportw\npos\npred\nptr\nrandom\nrandomize\nrelease\n" \
+         "reset\nrewrite\nround\nseek\nsettextbuf\nsin\nsizeof\nsqr\nsqrt\n" \
+         "str\nsucc\nswap\ntext\ntrunc\ntypeof\nupcase\nval\n"
+   },
+   { (CHARTYPE *)"*FOX.TLD",
+     (CHARTYPE *)"FOX",
+     (CHARTYPE *)"* FOX\n:case\nignore\n" \
+         ":option\npreprocessor #\nfunction ( blank\n" \
+         ":number\nc\n:identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":string\nsingle\ndouble\n" \
+         ":comment\nline * firstnonblank\nline && any\n" \
+/*         "line note firstnonblank\nline NOTE firstnonblank\npaired text endtext\n" \*/
+         "line note firstnonblank\nline NOTE firstnonblank\n" \
+         ":label\n* delimiter : column 1\n" \
+         ":header\nline # firstnonblank\nline proc firstnonblank\n" \
+         "line func firstnonblank\nline PROC firstnonblank\nline FUNC firstnonblank\n" \
+         ":keyword\nacce\naccept\nacti\nactiv\nactiva\nactivat\nactivate\n" \
+         "appe\nappen\nappend\nassist\naverage\nblank\nbox\nbrow\nbrows\n" \
+         "browse\ncalculate\ncall\ncancel\ncase\nchange\nclea\nclear\nclos\n" \
+         "close\ncont\nconti\ncontin\ncontinu\ncontinue\ncopy\ncoun\ncount\n" \
+         "crea\ncreat\ncreate\ndeac\ndeact\ndeacti\ndeactiv\ndeactiva\n" \
+         "deactivat\ndeactivate\ndecl\ndecla\ndeclar\ndeclare\ndefi\ndefin\n" \
+         "define\ndele\ndelet\ndelete\ndime\ndimen\ndimens\ndimensi\ndimensio\n" \
+         "dimension\ndir\ndirectory\ndisp\ndisplay\ndo\nedit\neject\nelse\n" \
+         "endc\nendca\nendcas\nendcase\nendd\nenddo\nendfor\nendi\nendif\n" \
+         "endprintjob\nendscan\nendtext\neras\nerase\nexit\nexport\nexternal\n" \
+         "fill\nfind\nflush\nfor\nfunction\ngath\ngathe\ngather\nget\n" \
+         "getexpr\ngo\ngoto\nhelp\nhide\nif\nimport\ninde\nindex\n" \
+         "inpu\ninput\ninse\ninser\ninsert\njoin\nkeyb\nkeyboard\nlabel\n" \
+         "list\nload\nloca\nlocat\nlocate\nmenu\nmodi\nmodif\nmodify\n" \
+         "move\nnext\nnote\non\nother\notherwise\npack\npara\nparam\n" \
+         "parameter\nparameters\nplay\npop\nprintjob\npriv\npriva\nprivat\n" \
+         "private\nprocedure\nprom\npromp\nprompt\npubl\npubli\npublic\n" \
+         "push\nquit\nread\nreca\nrecal\nrecall\nrein\nreind\nreinde\nreindex\n" \
+         "rele\nrelea\nreleas\nrelease\nrename\nrepl\nrepla\nreplac\nreplace\n" \
+         "repo\nrepor\nreport\nrest\nresto\nrestor\nrestore\nresume\n" \
+         "retr\nretry\nretu\nretur\nreturn\nrun\nsave\nsay\nscan\n" \
+         "scat\nscatt\nscatte\nscatter\nscroll\nseek\nsele\nselec\nselect\n" \
+         "set\nshow\nsize\nskip\nsort\nstor\nstore\nsum\nsusp\nsuspend\n" \
+         "text\nto\ntotal\ntype\nunlock\nupdate\nuse\nwait\nwhil\nwhile\n" \
+         "zap\nzoom\n:function\nabs\nacopy\nacos\nadel\nadir\naelement\n" \
+         "afields\nains\nalen\nalias\nallt\nalltr\nalltri\nalltrim\nasc\n" \
+         "ascan\nasin\nasort\nasub\nasubscript\nat\natan\natc\natcline\n" \
+         "atline\natn2\nbar\nbarcount\nbarprompt\nbetween\nbof\ncaps\n" \
+         "capslock\ncdow\ncdx\nceil\nceiling\nchr\nchrsaw\nchrtran\ncmonth\n" \
+         "cntbar\ncntpad\ncol\ncos\nctod\ncurdir\ndate\nday\ndbf\ndele\n" \
+         "deleted\ndescending\ndifference\ndiskspace\ndmy\ndow\ndtoc\ndtor\n" \
+         "dtos\nempty\neof\nerror\nevaluate\nexp\nfchsize\nfclose\nfcount\n" \
+         "fcreate\nfdate\nfeof\nferror\nfflush\nfgets\nfield\nfile\nfilter\n" \
+         "fklabel\nfkmax\nfldlist\nflock\nfloor\nfopen\nfor\nfound\nfputs\n" \
+         "fread\nfseek\nfsize\nftime\nfullpath\nfv\nfwrite\ngetbar\ngetdir\n" \
+         "getenv\ngetfile\ngetpad\ngomonth\nheader\nhome\niif\ninkey\ninlist\n" \
+         "insmode\nint\nisal\nisalpha\nisbl\nisblank\niscolo\niscolor\nisdig\n" \
+         "isdigit\nislow\nislower\nisread\nisreadonly\nisuppe\nisupper\nkey\n" \
+         "keymatch\nlastkey\nleft\nlen\nlike\nlineno\nlocfile\nlock\nlog\n" \
+         "log10\nlookup\nlowe\nlower\nltri\nltrim\nlupdate\nmax\nmcol\nmdown\n" \
+         "mdx\nmdy\nmemlin\nmemline\nmemlines\nmemory\nmenu\nmessage\nmin\n" \
+         "mlin\nmline\nmod\nmonth\nmrkbar\nmrkpad\nmrow\nmwindow\nndx\n" \
+         "normalize\nnumlock\nobjnum\nobjvar\noccurs\non\norder\nos\npad\n" \
+         "padc\npadl\npadr\npara\nparam\nparameter\nparameters\npayment\n" \
+         "pcol\npi\npopup\nprint\nprintstat\nprintstatus\nprmbar\nprmpad\n" \
+         "prog\nprogram\nprompt\nprop\nproper\nprow\nprtinfo\nputfile\npv\n" \
+         "rand\nrat\nratl\nratli\nratlin\nratline\nrdlevel\nreadkey\n" \
+         "reccou\nreccount\nrecno\nrecsiz\nrecsize\nrela\nrelation\n" \
+         "repl\nrepli\nreplicate\nright\nrlock\nround\nrow\nrtod\nrtrim\n" \
+         "scheme\nscols\nsecond\nseconds\nseek\nselect\nset\nsign\nsin\n" \
+         "skpbar\nskppad\nsoundex\nspac\nspace\nsqrt\nsrows\nstr\nstrtran\n" \
+         "stuff\nsubs\nsubst\nsubstr\nsys\ntag\ntagcount\ntagno\ntan\n" \
+         "target\ntime\ntran\ntrans\ntransform\ntrim\ntxtwidth\ntype\n" \
+         "unique\nupdated\nuppe\nupper\nused\nval\nvarread\nversion\n" \
+         "wborder\nwchild\nwcols\nwexist\nwlast\nwlcol\nwlrow\nwmax\n" \
+         "wmaximum\nwmin\nwminimum\nwontop\nwoutput\nwparent\nwread\n" \
+         "wrows\nwtitle\nwvisible\nyear\n:match\n( )\n"
+   },
+   { (CHARTYPE *)"*MAK.TLD",
+     (CHARTYPE *)"MAK",
+     (CHARTYPE *)"* MAK\n:case\nrespect\n" \
+         ":string\nsingle backslash\ndouble backslash\n" \
+         ":identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":comment\nline # any\n" \
+/*         ":label\ndelimiter : firstnonblank\n" \*/
+         ":postcompare\nclass \$([a-zA-Z0-9_\*@]*) alt w\n"
+         "class ^[a-zA-Z0-9_.]*: alt 1\n" \
+         "class ^[a-zA-Z0-9_]*= alt 2\n" \
+":keyword\n.DEFAULT\n.DELETE_ON_ERROR\n.EXPORT_ALL_VARIABLES\n.IGNORE" \
+"\n.INTERMEDIATE\n.PHONY\n.POSIX\n.PRECIOUS\n.SECONDARY\n.SILENT\n.SUFFIXES" \
+"\nAR\nARFLAGS\nAS\nASFLAGS\nCC\nCFLAGS\nCO\nCOFLAGS\nCOMSPEC\nCPP\nCPPFLAGS" \
+"\nCTANGLE\nCWEAVE\nCXX\nCXXFLAGS\nFC\nFFLAGS\nGET\nGFLAGS\nGPATH\nLDFLAGS" \
+"\nLEX\nLFLAGS\nMAKE\nMAKECMDGOALS\nMAKEFILES\nMAKEFLAGS\nMAKEINFO\nMAKELEVEL" \
+"\nMAKEOVERRIDES\nMFLAGS\nOUTPUT_OPTION\nPC\nPFLAGS\nRFLAGS\nRM\nSHELL" \
+"\nSUFFIXES\nTANGLE\nTEX\nTEXI2DVI\nVPATH\nWEAVE\nYACC\nYACCR\nYFLAGS" \
+"\naddprefix\naddsuffix\nbasename\ndefine\ndir\nelse\nendef\nendif\nexport" \
+"\nfilter\nfilter-out\nfindstring\nfirstword\nforeach\nifdef\nifeq\nifndef" \
+"\nifneq\ninclude\njoin\nnotdir\norigin\noverride\npatsubst\nshell\nsort\nstrip"\
+"\nsubst\nsuffix\nunexport\nvpath\nwildcard\nword\nwordlist\nwords"
    },
    {
      NULL, NULL
@@ -212,6 +611,8 @@
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.c"    , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.cc"   , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.cpp"  , NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.cxx"  , NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.tcc"  , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.h"    , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.hpp"  , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"REXX", (CHARTYPE*)"*.cmd"  , NULL  ,0, NULL },
@@ -230,6 +631,24 @@
    { NULL,NULL,(CHARTYPE*)"SH",   NULL    ,(CHARTYPE*)"ksh"   ,3, NULL },
    { NULL,NULL,(CHARTYPE*)"SH",   NULL    ,(CHARTYPE*)"bash"  ,4, NULL },
    { NULL,NULL,(CHARTYPE*)"SH",   NULL    ,(CHARTYPE*)"zsh"   ,3, NULL },
+   { NULL,NULL,(CHARTYPE*)"ASM",  (CHARTYPE*)"*.asm",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"ASM",  (CHARTYPE*)"*.inc",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"ASM",  (CHARTYPE*)"*.s",     NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"BAT",  (CHARTYPE*)"*.bat",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"PASCAL", (CHARTYPE*)"*.pas", NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"FOX",  (CHARTYPE*)"*.prg",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"MAK",  (CHARTYPE*)"*.mak",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"MAK",  (CHARTYPE*)"makefile",NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"MAK",(CHARTYPE*)"makefile.*",NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"HTML", (CHARTYPE*)"*.sht"  , NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"HTML", (CHARTYPE*)"*.shtml", NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"PERL", (CHARTYPE*)"*.pl",    NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"PERL", (CHARTYPE*)"*.pm",    NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"JAVA", (CHARTYPE*)"*.j",     NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"JAVA", (CHARTYPE*)"*.jav",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"JAVA", (CHARTYPE*)"*.java",  NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"JSCR", (CHARTYPE*)"*.js",    NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"SPEC", (CHARTYPE*)"*.spec",  NULL  ,0, NULL },
    { NULL,NULL,NULL,              NULL    , NULL              ,0, NULL }
 };
 
diff -Naurd orig/execute.c mod/execute.c
--- orig/execute.c	2007-12-13 21:42:54.000000000 +0100
+++ mod/execute.c	2009-03-11 17:11:00.000000000 +0100
@@ -39,6 +39,14 @@
 #include <the.h>
 #include <proto.h>
 
+#define PREV   (QUIT-1)
+#define PREVOK (PREV-1)
+#define HAVE_DERWIN 1
+#if defined(DOS)
+# define ACS_DARROW	(chtype)''
+# define ACS_UARROW	(chtype)''
+#endif
+
 /***********************************************************************/
 #ifdef HAVE_PROTO
 static short selective_change(TARGET *target,CHARTYPE *old_str,LENGTHTYPE len_old_str,CHARTYPE *new_str,
@@ -124,12 +132,12 @@
        * string to be changed
        */
       if ( CURRENT_VIEW->thighlight_on )
-         CURRENT_VIEW->thighlight_target.rt[0].length = (changed) ? len_new_str : len_old_str;
+         CURRENT_VIEW->thighlight_target.rt[0].found_length = (changed) ? len_new_str : len_old_str;
       display_screen(current_screen);
       if (changed)
-         display_prompt((CHARTYPE *)"Press 'N' for next,'C' to undo 'Q' to quit");
+         display_prompt((CHARTYPE *)"Press 'N' for next, 'C' to undo, 'P' to prev, 'Q' to quit");
       else
-         display_prompt((CHARTYPE *)"Press 'N' for next,'C' to change 'Q' to quit");
+         display_prompt((CHARTYPE *)"Press 'N' for next, 'C' to change, 'P' to prev, 'Q' to quit");
       wmove(CURRENT_WINDOW_FILEAREA,y,x);
       wrefresh(CURRENT_WINDOW_FILEAREA);
 
@@ -137,6 +145,13 @@
       clear_msgline(-1);
       switch(key)
       {
+         case 'P':
+         case 'p':
+            if (changed)
+               rc = PREVOK;
+            else
+               rc = PREV;
+            break;
          case 'N':
          case 'n':
             if (changed)
@@ -215,6 +230,9 @@
    CHARTYPE *params;
    short save_target_type=TARGET_RELATIVE;
    LENGTHTYPE str_length=0;
+   bool previous=FALSE;
+   bool reverse =FALSE;
+   short loc2=0;
 
    TRACE_FUNCTION("execute.c: execute_change_command");
    /*
@@ -338,6 +356,11 @@
    curr = lll_find( CURRENT_FILE->first_line, CURRENT_FILE->last_line, true_line, CURRENT_FILE->number_lines );
    for ( i = 0L, num_actual_lines = 0L; ; i++ )
    {
+      if (previous)
+      {
+        num_actual_lines -= 2;
+        i -=2;
+      }
       if ( lines_based_on_scope )
       {
          if ( num_actual_lines == abs_num_lines )
@@ -415,6 +438,22 @@
                                  CURRENT_VIEW->arbchar_single,
                                  CURRENT_VIEW->arbchar_multiple,
                                  &str_length );
+                  reverse = FALSE;
+                  if (previous)
+                  {
+                    loc2= memfind(rec+real_start,new_str,(real_end-real_start+1),
+                                len_new_str,
+                                (CURRENT_VIEW->case_change == CASE_IGNORE) ? TRUE : FALSE,
+                                CURRENT_VIEW->arbchar_status,
+                                CURRENT_VIEW->arbchar_single,
+                                CURRENT_VIEW->arbchar_multiple,
+                                &str_length);
+                    if (loc2 > loc)
+                    {
+                      loc = loc2;
+                      reverse = TRUE;
+                    }
+                  }
                }
                if ( loc != (-1) )
                {
@@ -440,11 +479,26 @@
                      else
                      {
                        /* selective */
+                        if (previous)
+                        {
+                          direction = (direction==DIRECTION_FORWARD) ? DIRECTION_BACKWARD : DIRECTION_FORWARD;
+                          previous = FALSE;
+                        }
+                        if (reverse)
+                          selective_rc = selective_change(&target,new_str,len_new_str,old_str,len_old_str,
+                                                        true_line,last_true_line,start_col);
+                        else
                         selective_rc = selective_change( &target, old_str, len_old_str, new_str, len_new_str,
                                                          true_line, last_true_line, start_col );
                         last_true_line = true_line;
                         switch( selective_rc )
                         {
+                           case PREVOK:
+                              if (!previous)
+                              {
+                                direction = (direction==DIRECTION_FORWARD) ? DIRECTION_BACKWARD : DIRECTION_FORWARD;
+                                previous = TRUE;
+                              }
                            case QUITOK:
                            case RC_OK:
                               start_col += len_new_str;
@@ -456,6 +510,12 @@
                                  loc = (-1);
                               }
                               break;
+                           case PREV:
+                              if (!previous)
+                              {
+                                direction = (direction==DIRECTION_FORWARD) ? DIRECTION_BACKWARD : DIRECTION_FORWARD;
+                                previous = TRUE;
+                              }
                            case SKIP:
                               start_col += len_old_str;
                               break;
@@ -1120,6 +1180,11 @@
 }
 
 /***********************************************************************/
+ extern bool HuSortCase;
+ char chr_lo[] = "";
+ char chr_hi[] = "";
+ char chr_utflo[] = "";
+ char chr_utfhi[] = "";
 #ifdef HAVE_PROTO
 static bool change_case(CHARTYPE *str,LENGTHTYPE start,LENGTHTYPE end,CHARTYPE which_case)
 #else
@@ -1134,6 +1199,7 @@
  */
 {
    LENGTHTYPE i;
+   register int j,k;
    bool altered=FALSE;
 
    TRACE_FUNCTION("execute.c: change_case");
@@ -1147,6 +1213,33 @@
                *(str+i) = toupper(*(str+i));
                altered = TRUE;
             }
+            else
+              if (HuSortCase)
+              {
+                if (str[i] == 195 || str[i] == 197)
+                {
+                  i++;
+                  j = (int) &chr_utflo;
+                  k = (int) index(chr_utflo, *(str+i));
+                  if (k>0)
+                  {
+                    k -= j;
+                    *(str+i) = (char) chr_utfhi[k];
+                    altered = TRUE;
+                  }
+                }
+                else
+                {
+                  j = (int) &chr_lo;
+                  k = (int) index(chr_lo, *(str+i));
+                  if (k>0)
+                  {
+                    k -= j;
+                    *(str+i) = (char) chr_hi[k];
+                    altered = TRUE;
+                  }
+                }
+              }
             break;
          case CASE_LOWER:
             if (isupper(*(str+i)))
@@ -1154,6 +1247,33 @@
                *(str+i) = tolower(*(str+i));
                altered = TRUE;
             }
+            else
+              if (HuSortCase)
+              {
+                if (str[i] == 195 || str[i] == 197)
+                {
+                  i++;
+                  j = (int) &chr_utfhi;
+                  k = (int) index(chr_utfhi, *(str+i));
+                  if (k>0)
+                  {
+                    k -= j;
+                    *(str+i) = (char) chr_utflo[k];
+                    altered = TRUE;
+                  }
+                }
+                else
+                {
+                  j = (int) &chr_hi;
+                  k = (int) index(chr_hi, *(str+i));
+                  if (k>0)
+                  {
+                    k -= j;
+                    *(str+i) = (char) chr_lo[k];
+                    altered = TRUE;
+                  }
+                }
+              }
             break;
       }
    }
@@ -2425,6 +2545,11 @@
    bool allow_interactive=FALSE;
    CHARTYPE *tmpfilename=NULL;
    CHARTYPE *tmpargs=NULL;
+#if defined(DOS)
+#define BUFFER_LEN  BUFSIZ
+   FILE *InFile, *OutFile;      // file declaration
+   CHARTYPE *rbuffer = NULL;    // Read Buffer
+#endif
 
    TRACE_FUNCTION("execute.c: execute_macro");
    /*
@@ -2478,6 +2603,35 @@
       TRACE_RETURN();
       return(RC_OUT_OF_MEMORY);
    }
+#if defined(DOS)
+   if (allow_interactive)
+   {
+     strcpy(macroname, "$tracef$.the");
+     if ( (OutFile = fopen( macroname, "wt")) != NULL )  // create file
+     {
+       if ( (InFile = fopen( tmpfilename, "rt")) != NULL )   // open file
+       {
+         if ((rbuffer = (CHARTYPE *)(*the_malloc)((BUFFER_LEN+1)*sizeof(CHARTYPE))) != NULL)
+         {
+           fputs( "Trace ?All\n", OutFile );
+           while( fgets( rbuffer, BUFFER_LEN, InFile ) != NULL )
+           {
+             if (strnicmp(rbuffer, "trace o", 7) == 0)
+             {
+               rbuffer[6] = 'a';
+             }
+             fputs( rbuffer, OutFile );
+           }
+           fclose( InFile );
+           fflush( OutFile );
+           (*the_free)(rbuffer);
+         }
+       }
+       fclose( OutFile );
+     }
+     strcpy(tmpfilename, macroname);
+   }
+#endif //DOS
    /*
     * Find the fully qualified file name for the supplied macro name.
     */
@@ -2557,6 +2711,12 @@
       if (rc == RC_NOREXX_ERROR)
          display_error( 52, (CHARTYPE *)"", FALSE );
    }
+#if defined(DOS)
+   if (allow_interactive)
+   {
+     remove("$tracef$.the");
+   }
+#endif //GYMOD
    /*
     * Set in_macro = FALSE to indicate we are out of the macro and do a
     * show_page() now as long as there are still file(s) in the ring.
@@ -4004,6 +4164,7 @@
 }
 
 /***********************************************************************/
+bool dialogw=FALSE;
 #ifdef HAVE_PROTO
 short execute_dialog(CHARTYPE *prompt, CHARTYPE *title, CHARTYPE *initial, bool editfield,short button, short default_button,CHARTYPE *stemname, short icon, bool alert)
 #else
@@ -4289,7 +4450,9 @@
           * an exit key is pressed. On exit make the first button active.
           */
          draw_cursor(TRUE);
+         dialogw = TRUE;
          rc = readv_cmdline( editfield_buf, dialog_win, editfield_col );
+         dialogw = FALSE;
          memcpy( (DEFCHAR *)editfield_buf, (DEFCHAR *)cmd_rec, cmd_rec_len );
          editfield_buf[cmd_rec_len] = '\0';
          in_editfield = FALSE;
@@ -5045,6 +5208,10 @@
    int x_offset=0,y_offset=0;
    int x_overlap,y_overlap;
    int offset_lines=0,scroll_lines;
+   #define KBCMAX 20
+   int l, k=0;
+   char kbuf[KBCMAX+1] = {0};
+   char ukey;
 
    TRACE_FUNCTION("execute.c: execute_popup");
 
@@ -5128,22 +5295,34 @@
 #if defined(HAVE_BOX)
       wattrset(dialog_win,set_colour(CURRENT_FILE->attr+ATTR_DIVIDER));
       box(dialog_win,0,0);
+      if (k>0)
+      {
+        for (l=0; l<k; l++)
+        {
+          wmove(dialog_win,height-1,l+2);
+          waddch(dialog_win,kbuf[l]);
+        }
+      }
       if ( height != pad_height )
       {
-         wmove(dialog_win,0,width-1);
-         waddch(dialog_win,' ');
-         wmove(dialog_win,1,width-1);
+         if (y_offset!=0)
+         {
+           wmove(dialog_win,1,width-1);
 #ifdef ACS_UARROW
-         waddch( dialog_win, A_ALTCHARSET|ACS_UARROW );
+           waddch(dialog_win, A_ALTCHARSET|ACS_UARROW );
 #else
-         waddch(dialog_win,'^');
+           waddch(dialog_win,'^');
 #endif
-         wmove(dialog_win,height-2,width-1);
+         }
+         if (y_offset<(num_args-height+2))
+         {
+           wmove(dialog_win,height-2,width-1);
 #ifdef ACS_DARROW
-         waddch( dialog_win, A_ALTCHARSET|ACS_DARROW );
+           waddch(dialog_win, A_ALTCHARSET|ACS_DARROW );
 #else
-         waddch(dialog_win,'v');
+           waddch(dialog_win,'v');
 #endif
+         }
       }
       if ( width != pad_width )
       {
@@ -5213,6 +5392,8 @@
          continue;
 #endif
 #if defined(PDCURSES_MOUSE_ENABLED) || defined(NCURSES_MOUSE_VERSION)
+      if ((key=='q') && (popup_escape_key != -1))
+        key = 'Q';
       if (key == KEY_MOUSE)
       {
          int b,ba,bm,y,x;
@@ -5233,12 +5414,109 @@
              */
             break;
          }
+         if (y == 0)
+         {
+           if (highlighted_line>0)
+           {
+             if ( y_overlap )
+             {
+               highlighted_line -=(height-3);
+               if (highlighted_line<0)
+               {
+                 y_offset = 0;
+                 highlighted_line = 0;
+               }
+               else
+               {
+                 y_offset -= (height-3);
+                 if (y_offset<0)
+                   y_offset = 0;
+               }
+             }
+             else
+             {
+               highlighted_line--;
+               if (highlighted_line<y_offset)
+                 y_offset--;
+             }
+           }
+           offset_lines = 1;
+           scroll_lines = 0;
+           if (args[highlighted_line][0] == '-')
+           {
+              offset_lines = get_non_seperator_line( highlighted_line, num_args, args, -1 );
+              if ( offset_lines == 0 )
+                 highlighted_line++;
+              else
+              {
+                 highlighted_line -= offset_lines;
+                 scroll_lines = offset_lines;
+              }
+           }
+           if ( y_overlap )
+           {
+              if ( highlighted_line+1 <= y_offset
+              &&   y_offset )
+                 y_offset -= 1+scroll_lines;
+           }
+           continue;
+         }
+         if (y > (height-2))
+         {
+           if ( y_overlap )
+           {
+             highlighted_line +=(height-3);
+             if (highlighted_line>=num_args)
+             {
+               highlighted_line = num_args-1;
+             }
+             y_offset += (height-3);
+             if (y_offset > (num_args-height+2))
+               y_offset = (num_args-height+2);
+           }
+           else
+           {
+             if (highlighted_line<(num_args-1))
+             {
+               highlighted_line++;
+               if ((highlighted_line-y_offset)>(height-3))
+                 y_offset++;
+             }
+           }
+           offset_lines = 1;
+           scroll_lines = 0;
+           if (args[highlighted_line][0] == '-')
+           {
+              offset_lines = get_non_seperator_line( highlighted_line, num_args, args, 1 );
+              if ( offset_lines == 0 )
+                 highlighted_line--;
+              else
+              {
+                 highlighted_line += offset_lines;
+                 scroll_lines = offset_lines;
+              }
+           }
+           if ( y_overlap )
+           {
+              if ( highlighted_line + 2 >= y_offset + height
+              &&   y_offset < y_overlap )
+                 y_offset += 1+scroll_lines;
+           }
+           continue;
+         }
+         if (y != (highlighted_line-y_offset+1))
+         {
+           if ((args[y_offset+y-1][0]) != '-')
+             highlighted_line = y_offset+y-1;
+           continue;
+         }
          /*
           * Check that the mouse is clicked on a valid item
           */
          if (y > 0 && y < height && x > 0 && x < width)
          {
             i = y-1;
+            i += y_offset;
          }
          else
          {
@@ -5284,7 +5562,8 @@
 #endif
                if ( ++highlighted_line >= num_args )
                {
-                  highlighted_line = num_args - 1;
+                  highlighted_line = 0;
+                  y_offset = 0;
                   break;
                }
                offset_lines = 1;
@@ -5307,11 +5586,14 @@
                      y_offset += 1+scroll_lines;
                }
                break;
+            case KEY_BTAB:
 #if defined(KEY_UP)
             case KEY_UP:
                if (--highlighted_line < 0 )
                {
-                  highlighted_line = 0;
+                  highlighted_line = num_args-1;
+                  if ( y_overlap )
+                     y_offset = num_args-height+2;
                   break;
                }
                offset_lines = 1;
@@ -5361,12 +5643,100 @@
             case 'q':
                time_to_quit = TRUE;
                break;
+            case KEY_HOME:
+               highlighted_line = 0;
+               y_offset = 0;
+               break;
+            case KEY_END:
+               highlighted_line = num_args-1;
+               if ( y_overlap )
+                  y_offset = num_args-height+2;
+               break;
+            case KEY_PPAGE:
+               highlighted_line -=(height-3);
+               if (highlighted_line<0)
+               {
+                 y_offset = 0;
+                 highlighted_line = 0;
+               }
+               else
+               {
+                 if ( y_overlap )
+                 {
+                   y_offset -= (height-3);
+                   if (y_offset<0)
+                     y_offset = 0;
+                 }
+               }
+               break;
+            case KEY_NPAGE:
+               highlighted_line +=(height-3);
+               if (highlighted_line>=num_args)
+               {
+                 highlighted_line = num_args-1;
+               }
+               if ( y_overlap )
+               {
+                 y_offset += (height-3);
+                 if (y_offset > (num_args-height+2))
+                    y_offset = (num_args-height+2);
+               }
+               break;
             default:
                if ( key == popup_escape_key )
                   time_to_quit = TRUE;
                break;
 
          }
+         if ((key > 0x1F && key < 0x100)
+             && (key != 'q' || key != popup_escape_key ))
+         {
+           ukey = toupper(key);
+           j = highlighted_line;
+           for (; j<num_args && toupper(args[j][k])!=ukey; j++)
+           {
+           }
+           if (j<num_args)
+           {
+             for (l=0; l<k && toupper(args[j][l])==kbuf[l]; l++)
+             {
+             }
+             if (l<k)
+               j = num_args;
+           }
+           if (j<num_args)
+           {
+             highlighted_line = j;
+             if ( y_overlap && j>(height-3) )
+                y_offset = j-height+3;
+             if ((k<KBCMAX) && (k<(width-4)))
+             {
+               kbuf[k] = ukey;
+               k++;
+             }
+           }
+           else
+           {
+             k=0;
+             for (j=0; j<num_args && toupper(args[j][0])!=ukey; j++)
+             {
+             }
+             if (j<num_args)
+             {
+               y_offset = 0;
+               highlighted_line = j;
+               if ( y_overlap && j>(height-3) )
+                  y_offset = j-height+3;
+               kbuf[0] = ukey;
+               k++;
+             }
+           }
+         }
+         else
+         {
+           kbuf[0]=0;
+           k=0;
+         }
          if ( time_to_quit )
             break;
       }
diff -Naurd orig/getch.c mod/getch.c
--- orig/getch.c	2007-08-04 03:35:44.000000000 +0200
+++ mod/getch.c	2009-03-12 07:48:00.000000000 +0100
@@ -307,6 +307,57 @@
                              state = NORMAL;
                   }
                   break;
+
+/*===vvvv==stk 02/2003M==vvvv===*/
+               /* Create some strings to be used by a Linux keymap and  */
+               /*  have THE be able to recognise 'em...                 */
+               case '@':
+                       switch (fkeycount) {
+                       /* A-F1-A-F12 */
+                       case 37: case 38: case 39: case 40: case 41:
+                       case 42: case 43: case 44: case 45: case 46:
+                       case 47: case 48:
+                               return KEY_A_F1 + (fkeycount - 37);
+
+                       /* A-[cursor keypad key] */
+                       case 478: return ALT_DEL;
+                       case 479: return ALT_INS;
+                       case 486: return ALT_HOME;
+                       case 487: return ALT_PGUP;
+                       case 488: return ALT_PGDN;
+                       case 489: return ALT_END;
+                       case 490: return ALT_UP;
+                       case 491: return ALT_DOWN;
+                       case 492: return ALT_RIGHT;
+                       case 493: return ALT_LEFT;
+
+                       /* A-[numeric keypad key] */
+                       case 461: return ALT_PADENTER;
+                       case 472: return ALT_PADPLUS;
+                       case 473: return ALT_PADMINUS;
+                       case 474: return ALT_PADSLASH;
+                       case 475: return ALT_PADSTAR;
+                       case 476: return ALT_PADSTOP;
+
+                       /* more A-[numeric keypad key]...           */
+                       /*  (In the keymap I only bother with       */
+                       /*  "zero " and the "arrows" [2, 4, 6, 8])  */
+                       case 517: return ALT_PAD0;
+                       case 518: return ALT_PAD1;
+                       case 519: return ALT_PAD2;
+                       case 520: return ALT_PAD3;
+                       case 521: return ALT_PAD4;
+                       case 522: return ALT_PAD5;
+                       case 523: return ALT_PAD6;
+                       case 524: return ALT_PAD7;
+                       case 525: return ALT_PAD8;
+                       case 526: return ALT_PAD9;
+                       default:
+                               state = NORMAL;
+                               }
+                       break;
+/*===^^^^==stk 02/2003M==^^^^===*/
+
                case '[':
                   state = BRACK;
                   break;
@@ -355,6 +406,73 @@
                   fkeycount = 0;
                   break;
 
+/*===vvvv==stk 02/2003M==vvvv===*/
+#define HIGHBIT 0200 
+               /* let's use octal format, to make life easier for    */
+               /*  keymap-fiddlers...                                */
+               case HIGHBIT: /*<--- useless label? Helps make the    */
+                             /*  (il)logic clear... I'm not a Real   */
+                             /*  C Programmer yet ;-) Just glad this */
+                             /*  works!                              */
+                       /* A-[special key] */
+                       case 0207: return ALT_ESC; 
+                       case 0210: return ALT_BKSP; 
+                       case 0211: return ALT_TAB; 
+                       case 0215: return ALT_ENTER; 
+                       /* A-0-A-9 */
+                       /* loop here?... */
+                       case 0251: return ALT_0;   
+                       case 0241: return ALT_1;   
+                       case 0300: return ALT_2;   
+                       case 0243: return ALT_3;   
+                       case 0244: return ALT_4;   
+                       case 0245: return ALT_5;   
+                       case 0336: return ALT_6;   
+                       case 0246: return ALT_7;   
+                       case 0252: return ALT_8;   
+                       case 0250: return ALT_9;   
+                       /* A-[punct] */
+                       case 0247: return ALT_FQUOTE;  
+                       case 0253: return ALT_EQUAL;   
+                       case 0254: return ALT_COMMA;   
+                       case 0256: return ALT_STOP;    
+                       case 0257: return ALT_FSLASH;  
+                       case 0273: return ALT_SEMICOLON; 
+                       case 0333: return ALT_LBRACKET;
+                       case 0334: return ALT_BSLASH;  
+                       case 0335: return ALT_RBRACKET;
+                       case 0337: return ALT_MINUS;   
+                       case 0340: return ALT_BQUOTE;
+                       /* A-A-A-Z */                  
+                       /* another potential loop, I daresay... */
+                       case 0341: return ALT_A;       
+                       case 0342: return ALT_B;       
+                       case 0343: return ALT_C;       
+                       case 0344: return ALT_D;       
+                       case 0345: return ALT_E;       
+                       case 0346: return ALT_F;       
+                       case 0347: return ALT_G;       
+                       case 0350: return ALT_H;       
+                       case 0351: return ALT_I;       
+                       case 0352: return ALT_J;       
+                       case 0353: return ALT_K;       
+                       case 0354: return ALT_L;       
+                       case 0355: return ALT_M;       
+                       case 0356: return ALT_N;       
+                       case 0357: return ALT_O;       
+                       case 0360: return ALT_P;       
+                       case 0361: return ALT_Q;       
+                       case 0362: return ALT_R;       
+                       case 0363: return ALT_S;       
+                       case 0364: return ALT_T;       
+                       case 0365: return ALT_U;       
+                       case 0366: return ALT_V;       
+                       case 0367: return ALT_W;       
+                       case 0370: return ALT_X;       
+                       case 0371: return ALT_Y;       
+                       case 0372: return ALT_Z;       
+/*===^^^^==stk 02/2003M==^^^^===*/            
+
                default:
                   return (c);
             }
diff -Naurd orig/getch.h mod/getch.h
--- orig/getch.h	2004-08-03 09:25:21.000000000 +0200
+++ mod/getch.h	2009-03-11 12:20:00.000000000 +0100
@@ -651,3 +651,151 @@
 #define KEY_A_DB2      0x42a
 #define KEY_A_DB3      0x42b
 
+# define PADSLASH        0x1ca   /* slash on keypad               */
+# define PADSTAR         0x1cf   /* star on keypad                */
+# define PADMINUS        0x1d0   /* minus on keypad               */
+# define PADPLUS         0x1d1   /* plus on keypad                */
+/* PDCurses specific key definitions */
+# define KEY_A1          0x1c1   /* upper left on Virtual keypad  */
+# define KEY_A2          0x1c2   /* upper middle on Virt. keypad  */
+# define KEY_A3          0x1c3   /* upper right on Vir. keypad    */
+# define KEY_B1          0x1c4   /* middle left on Virt. keypad   */
+# define KEY_B2          0x1c5   /* center on Virt. keypad        */
+# define KEY_B3          0x1c6   /* middle right on Vir. keypad   */
+# define KEY_C1          0x1c7   /* lower left on Virt. keypad    */
+# define KEY_C2          0x1c8   /* lower middle on Virt. keypad  */
+# define KEY_C3          0x1c9   /* lower right on Vir. keypad    */
+# define PADSLASH        0x1ca   /* slash on keypad               */
+# define PADENTER        0x1cb   /* enter on keypad               */
+# define CTL_PADENTER    0x1cc   /* ctl-enter on keypad           */
+# define ALT_PADENTER    0x1cd   /* alt-enter on keypad           */
+# define PADSTOP         0x1ce   /* stop on keypad                */
+# define PADSTAR         0x1cf   /* star on keypad                */
+# define PADMINUS        0x1d0   /* minus on keypad               */
+# define PADPLUS         0x1d1   /* plus on keypad                */
+# define CTL_PADSTOP     0x1d2   /* ctl-stop on keypad            */
+# define CTL_PADCENTER   0x1d3   /* ctl-enter on keypad           */
+# define CTL_PADPLUS     0x1d4   /* ctl-plus on keypad            */
+# define CTL_PADMINUS    0x1d5   /* ctl-minus on keypad           */
+# define CTL_PADSLASH    0x1d6   /* ctl-slash on keypad           */
+# define CTL_PADSTAR     0x1d7   /* ctl-star on keypad            */
+# define ALT_PADPLUS     0x1d8   /* alt-plus on keypad            */
+# define ALT_PADMINUS    0x1d9   /* alt-minus on keypad           */
+# define ALT_PADSLASH    0x1da   /* alt-slash on keypad           */
+# define ALT_PADSTAR     0x1db   /* alt-star on keypad            */
+# define ALT_PADSTOP     0x1dc   /* alt-stop on keypad            */
+# define CTL_INS         0x1dd   /* ctl-insert                    */
+# define ALT_DEL         0x1de   /* alt-delete                    */
+# define ALT_INS         0x1df   /* alt-insert                    */
+# define CTL_UP          0x1e0   /* ctl-up arrow                  */
+# define CTL_DOWN        0x1e1   /* ctl-down arrow                */
+# define CTL_TAB         0x1e2   /* ctl-tab                       */
+# define ALT_TAB         0x1e3   /* alt-tab                       */
+# define ALT_MINUS       0x1e4   /* alt-minus                     */
+# define ALT_EQUAL       0x1e5   /* alt-equal                     */
+# define ALT_HOME        0x1e6   /* alt-home                      */
+# define ALT_PGUP        0x1e7   /* alt-pgup                      */
+# define ALT_PGDN        0x1e8   /* alt-pgdn                      */
+# define ALT_END         0x1e9   /* alt-end                       */
+# define ALT_UP          0x1ea   /* alt-up arrow                  */
+# define ALT_DOWN        0x1eb   /* alt-down arrow                */
+# define ALT_RIGHT       0x1ec   /* alt-right arrow               */
+# define ALT_LEFT        0x1ed   /* alt-left arrow                */
+# define ALT_ENTER       0x1ee   /* alt-enter                     */
+# define ALT_ESC         0x1ef   /* alt-escape                    */
+# define ALT_BQUOTE      0x1f0   /* alt-back quote                */
+# define ALT_LBRACKET    0x1f1   /* alt-left bracket              */
+# define ALT_RBRACKET    0x1f2   /* alt-right bracket             */
+# define ALT_SEMICOLON   0x1f3   /* alt-semi-colon                */
+# define ALT_FQUOTE      0x1f4   /* alt-forward quote             */
+# define ALT_COMMA       0x1f5   /* alt-comma                     */
+# define ALT_STOP        0x1f6   /* alt-stop                      */
+# define ALT_FSLASH      0x1f7   /* alt-forward slash             */
+# define ALT_BKSP        0x1f8   /* alt-backspace                 */
+# define CTL_BKSP        0x1f9   /* ctl-backspace                 */
+# define PAD0            0x1fa   /* ctl-keypad 0                  */
+# define CTL_PAD0        0x1fb   /* ctl-keypad 0                  */
+# define CTL_PAD1        0x1fc   /* ctl-keypad 1                  */
+# define CTL_PAD2        0x1fd   /* ctl-keypad 2                  */
+# define CTL_PAD3        0x1fe   /* ctl-keypad 3                  */
+# define CTL_PAD4        0x1ff   /* ctl-keypad 4                  */
+# define CTL_PAD5        0x200   /* ctl-keypad 5                  */
+# define CTL_PAD6        0x201   /* ctl-keypad 6                  */
+# define CTL_PAD7        0x202   /* ctl-keypad 7                  */
+# define CTL_PAD8        0x203   /* ctl-keypad 8                  */
+# define CTL_PAD9        0x204   /* ctl-keypad 9                  */
+# define ALT_PAD0        0x205   /* ctl-keypad 0                  */
+# define ALT_PAD1        0x206   /* ctl-keypad 1                  */
+# define ALT_PAD2        0x207   /* ctl-keypad 2                  */
+# define ALT_PAD3        0x208   /* ctl-keypad 3                  */
+# define ALT_PAD4        0x209   /* ctl-keypad 4                  */
+# define ALT_PAD5        0x20a   /* ctl-keypad 5                  */
+# define ALT_PAD6        0x20b   /* ctl-keypad 6                  */
+# define ALT_PAD7        0x20c   /* ctl-keypad 7                  */
+# define ALT_PAD8        0x20d   /* ctl-keypad 8                  */
+# define ALT_PAD9        0x20e   /* ctl-keypad 9                  */
+# define CTL_DEL         0x20f   /* clt-delete                    */
+# define ALT_BSLASH      0x210   /* alt-back slash                */
+# define CTL_ENTER       0x211   /* ctl-enter                     */
+# define SHF_PADENTER    0x212   /* shift-enter on keypad         */
+# define SHF_PADSLASH    0x213   /* shift-slash on keypad         */
+# define SHF_PADSTAR     0x214   /* shift-star  on keypad         */
+# define SHF_PADPLUS     0x215   /* shift-plus  on keypad         */
+# define SHF_PADMINUS    0x216   /* shift-minus on keypad         */
+# define SHF_UP          0x217   /* shift-up on keypad            */
+# define SHF_DOWN        0x218   /* shift-down on keypad          */
+# define SHF_IC          0x219   /* shift-insert on keypad        */
+# define SHF_DC          0x21a   /* shift-delete on keypad        */
+# define KEY_MOUSE       0x21b   /* "mouse" key                   */
+# define KEY_SHIFT_L     0x21c   /* Left-shift                    */
+# define KEY_SHIFT_R     0x21d   /* Right-shift                   */
+# define KEY_CONTROL_L   0x21e   /* Left-control                  */
+# define KEY_CONTROL_R   0x21f   /* Right-control                 */
+# define KEY_ALT_L       0x220   /* Left-alt                      */
+# define KEY_ALT_R       0x221   /* Right-alt                     */
+# define KEY_RESIZE      0x222   /* Window resize                 */
+# define KEY_SUP         0x223   /* Shifted up arrow              */
+# define KEY_SDOWN       0x224   /* Shifted down arrow            */
+# define KEY_MAX         0x224   /* Maximum curses key            */
+#define ALT_0           0x197 
+#define ALT_1           0x198 
+#define ALT_2           0x199 
+#define ALT_3           0x19a 
+#define ALT_4           0x19b 
+#define ALT_5           0x19c 
+#define ALT_6           0x19d 
+#define ALT_7           0x19e 
+#define ALT_8           0x19f 
+#define ALT_9           0x1a0 
+#define ALT_A           0x1a1 
+#define ALT_B           0x1a2 
+#define ALT_C           0x1a3 
+#define ALT_D           0x1a4 
+#define ALT_E           0x1a5 
+#define ALT_F           0x1a6 
+#define ALT_G           0x1a7 
+#define ALT_H           0x1a8 
+#define ALT_I           0x1a9 
+#define ALT_J           0x1aa 
+#define ALT_K           0x1ab 
+#define ALT_L           0x1ac 
+#define ALT_M           0x1ad 
+#define ALT_N           0x1ae 
+#define ALT_O           0x1af 
+#define ALT_P           0x1b0 
+#define ALT_Q           0x1b1 
+#define ALT_R           0x1b2 
+#define ALT_S           0x1b3 
+#define ALT_T           0x1b4 
+#define ALT_U           0x1b5 
+#define ALT_V           0x1b6 
+#define ALT_W           0x1b7 
+#define ALT_X           0x1b8 
+#define ALT_Y           0x1b9 
+#define ALT_Z           0x1ba 
+#define CTL_LEFT        0x1bb 
+#define CTL_RIGHT       0x1bc 
+#define CTL_PGUP        0x1bd 
+#define CTL_PGDN        0x1be 
+#define CTL_HOME        0x1bf 
+#define CTL_END         0x1c0 
diff -Naurd orig/key.h mod/key.h
--- orig/key.h	2008-03-24 08:10:22.000000000 +0100
+++ mod/key.h	2009-03-12 07:51:00.000000000 +0100
@@ -219,6 +219,85 @@
   {(CHARTYPE *)"NUM7"     ,KEY_A1,0},
   {(CHARTYPE *)"NUM8"     ,KEY_A2,0},
   {(CHARTYPE *)"NUM9"     ,KEY_A3,0},
+/*===vvvv==stk 02/2003==vvvv===*/
+  {(CHARTYPE *)"A-A",ALT_A,SHIFT_ALT},
+  {(CHARTYPE *)"A-B",ALT_B,SHIFT_ALT},
+  {(CHARTYPE *)"A-C",ALT_C,SHIFT_ALT},
+  {(CHARTYPE *)"A-D",ALT_D,SHIFT_ALT},
+  {(CHARTYPE *)"A-E",ALT_E,SHIFT_ALT},
+  {(CHARTYPE *)"A-F",ALT_F,SHIFT_ALT},
+  {(CHARTYPE *)"A-G",ALT_G,SHIFT_ALT},
+  {(CHARTYPE *)"A-H",ALT_H,SHIFT_ALT},
+  {(CHARTYPE *)"A-I",ALT_I,SHIFT_ALT},
+  {(CHARTYPE *)"A-J",ALT_J,SHIFT_ALT},
+  {(CHARTYPE *)"A-K",ALT_K,SHIFT_ALT},
+  {(CHARTYPE *)"A-L",ALT_L,SHIFT_ALT},
+  {(CHARTYPE *)"A-M",ALT_M,SHIFT_ALT},
+  {(CHARTYPE *)"A-N",ALT_N,SHIFT_ALT},
+  {(CHARTYPE *)"A-O",ALT_O,SHIFT_ALT},
+  {(CHARTYPE *)"A-P",ALT_P,SHIFT_ALT},
+  {(CHARTYPE *)"A-Q",ALT_Q,SHIFT_ALT},
+  {(CHARTYPE *)"A-R",ALT_R,SHIFT_ALT},
+  {(CHARTYPE *)"A-S",ALT_S,SHIFT_ALT},
+  {(CHARTYPE *)"A-T",ALT_T,SHIFT_ALT},
+  {(CHARTYPE *)"A-U",ALT_U,SHIFT_ALT},
+  {(CHARTYPE *)"A-V",ALT_V,SHIFT_ALT},
+  {(CHARTYPE *)"A-W",ALT_W,SHIFT_ALT},
+  {(CHARTYPE *)"A-X",ALT_X,SHIFT_ALT},
+  {(CHARTYPE *)"A-Y",ALT_Y,SHIFT_ALT},
+  {(CHARTYPE *)"A-Z",ALT_Z,SHIFT_ALT},
+  {(CHARTYPE *)"A-0",ALT_0,SHIFT_ALT},
+  {(CHARTYPE *)"A-1",ALT_1,SHIFT_ALT},
+  {(CHARTYPE *)"A-2",ALT_2,SHIFT_ALT},
+  {(CHARTYPE *)"A-3",ALT_3,SHIFT_ALT},
+  {(CHARTYPE *)"A-4",ALT_4,SHIFT_ALT},
+  {(CHARTYPE *)"A-5",ALT_5,SHIFT_ALT},
+  {(CHARTYPE *)"A-6",ALT_6,SHIFT_ALT},
+  {(CHARTYPE *)"A-7",ALT_7,SHIFT_ALT},
+  {(CHARTYPE *)"A-8",ALT_8,SHIFT_ALT},
+  {(CHARTYPE *)"A-9",ALT_9,SHIFT_ALT},
+  {(CHARTYPE *)"A-`",ALT_BQUOTE,SHIFT_ALT},
+  {(CHARTYPE *)"A--",ALT_MINUS,SHIFT_ALT},
+  {(CHARTYPE *)"A-=",ALT_EQUAL,SHIFT_ALT},
+  {(CHARTYPE *)"A-[",ALT_LBRACKET,SHIFT_ALT},
+  {(CHARTYPE *)"A-]",ALT_RBRACKET,SHIFT_ALT},
+  {(CHARTYPE *)"A-\\",ALT_BSLASH,SHIFT_ALT},
+  {(CHARTYPE *)"A-;",ALT_SEMICOLON,SHIFT_ALT},
+  {(CHARTYPE *)"A-'",ALT_FQUOTE,SHIFT_ALT},
+  {(CHARTYPE *)"A-,",ALT_COMMA,SHIFT_ALT},
+  {(CHARTYPE *)"A-.",ALT_STOP,SHIFT_ALT},
+  {(CHARTYPE *)"A-/",ALT_FSLASH,SHIFT_ALT},
+  {(CHARTYPE *)"A-ENTER",ALT_ENTER,SHIFT_ALT},
+  {(CHARTYPE *)"A-TAB",ALT_TAB,SHIFT_ALT},
+  {(CHARTYPE *)"A-ESC",ALT_ESC ,SHIFT_ALT},
+  {(CHARTYPE *)"A-BKSP",ALT_BKSP ,SHIFT_ALT},
+  {(CHARTYPE *)"A-HOME",ALT_HOME,SHIFT_ALT},
+  {(CHARTYPE *)"A-PGUP",ALT_PGUP,SHIFT_ALT},
+  {(CHARTYPE *)"A-PGDN",ALT_PGDN,SHIFT_ALT},
+  {(CHARTYPE *)"A-CURU",ALT_UP,SHIFT_ALT},
+  {(CHARTYPE *)"A-CURD",ALT_DOWN,SHIFT_ALT},
+  {(CHARTYPE *)"A-CURL",ALT_LEFT,SHIFT_ALT},
+  {(CHARTYPE *)"A-CURR",ALT_RIGHT,SHIFT_ALT},
+  {(CHARTYPE *)"A-END",ALT_END,SHIFT_ALT},
+  {(CHARTYPE *)"A-INS",ALT_INS,SHIFT_ALT},
+  {(CHARTYPE *)"A-DEL",ALT_DEL,SHIFT_ALT},
+  {(CHARTYPE *)"A-PLUS",ALT_PADPLUS,SHIFT_ALT},
+  {(CHARTYPE *)"A-MINUS",ALT_PADMINUS,SHIFT_ALT},
+  {(CHARTYPE *)"A-SLASH",ALT_PADSLASH,SHIFT_ALT},
+  {(CHARTYPE *)"A-STAR",ALT_PADSTAR,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUMENTER",ALT_PADENTER,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUMSTOP",ALT_PADSTOP,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM0",ALT_PAD0,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM1",ALT_PAD1,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM2",ALT_PAD2,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM3",ALT_PAD3,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM4",ALT_PAD4,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM5",ALT_PAD5,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM6",ALT_PAD6,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM7",ALT_PAD7,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM8",ALT_PAD8,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM9",ALT_PAD9,SHIFT_ALT},
+/*===^^^^==stk 02/2003==^^^^===*/
 
 #if defined(DOS) || defined(OS2) || defined(XCURSES) || defined(WIN32)
 /* normal characters */
diff -Naurd orig/Makefile.in mod/Makefile.in
--- orig/Makefile.in	2008-02-29 01:56:44.000000000 +0100
+++ mod/Makefile.in	2010-01-22 13:58:41.000000000 +0100
@@ -395,6 +395,7 @@
 
 OBJS =      \
 	box.o      \
+	calc.o \
 	colour.o   \
 	column.o   \
 	comm1.o    \
@@ -449,6 +450,9 @@
 box.o: $(srcdir)/box.c $(H1)
 	$(CC) $(CCFLAGS) -o box.o $(srcdir)/box.c
 
+calc.o: $(srcdir)/calc.c $(H1)
+	$(CC) $(CCFLAGS) -o calc.o $(srcdir)/calc.c
+
 colour.o: $(srcdir)/colour.c $(H1)
 	$(CC) $(CCFLAGS) -o colour.o $(srcdir)/colour.c
 
diff -Naurd orig/mouse.c mod/mouse.c
--- orig/mouse.c	2007-12-13 21:31:22.000000000 +0100
+++ mod/mouse.c	2009-03-12 07:58:00.000000000 +0100
@@ -525,9 +525,12 @@
    add_define(&first_mouse_define,&last_mouse_define,
             WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_PRESS|MOUSE_SHIFT,
             (CHARTYPE *)"CURSOR MOUSE#MARK LINE",FALSE,FALSE,0);
+// add_define(&first_mouse_define,&last_mouse_define,
+//          WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_PRESS|MOUSE_CONTROL,
+//          (CHARTYPE *)"CURSOR MOUSE#MARK BOX",FALSE,FALSE,0);
    add_define(&first_mouse_define,&last_mouse_define,
             WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_PRESS|MOUSE_CONTROL,
-            (CHARTYPE *)"CURSOR MOUSE#MARK BOX",FALSE,FALSE,0);
+            (CHARTYPE *)"CURSOR MOUSE#SOS EDIT",FALSE,FALSE,0);
 #if defined(NCURSES_MOUSE_VERSION)
    add_define(&first_mouse_define,&last_mouse_define,
             WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_CLICK|MOUSE_NORMAL,
diff -Naurd orig/parser.c mod/parser.c
--- orig/parser.c	2007-12-13 21:43:52.000000000 +0100
+++ mod/parser.c	2009-03-12 08:05:00.000000000 +0100
@@ -73,6 +73,8 @@
 static int number_blanks=0;
 static CHARTYPE *work;
 static char tmp[100];
+static CHARTYPE c_scrno;
+static SHOW_LINE *c_scurr;
 
 /***********************************************************************/
 #ifdef HAVE_PROTO
@@ -91,6 +93,13 @@
    CHARTYPE ch1,ch2,ch3;
 
    TRACE_FUNCTION( "parser.c:  find_comment" );
+   LENGTHTYPE vcol=0;
+   chtype string_colour;
+   vcol = SCREEN_VIEW(c_scrno)->verify_col-1;
+   if ( c_scurr->is_current_line )
+      string_colour = merge_curline_colour(fd->attr+ATTR_CURLINE,fd->ecolour+ECOLOUR_STRINGS);
+   else
+      string_colour = set_colour(fd->ecolour+ECOLOUR_STRINGS);
    for ( i = start; i < length; i++ )
    {
       ptr_start = start_delim;
@@ -106,6 +115,11 @@
       }
       if ( ch1 == ch2 )
       {
+         if (c_scurr->highlighting[i-vcol] == string_colour)
+         {
+           TRACE_RETURN();
+           return -1;
+         }
          for ( j = i; j < length; j++ )
          {
             ch2 = (fd->parser->case_sensitive) ? *ptr_start : tolower( *ptr_start );
@@ -134,6 +148,11 @@
       }
       if ( ch1 == ch2 )
       {
+         if (c_scurr->highlighting[i-vcol] == string_colour)
+         {
+           TRACE_RETURN();
+           return -1;
+         }
          for ( j = i; j < length; j++ )
          {
             ch2 = (fd->parser->case_sensitive) ? *ptr_end : tolower( *ptr_end );
@@ -173,6 +192,11 @@
    CHARTYPE ch1,ch2;
 
    TRACE_FUNCTION( "parser.c:  find_single_comments" );
+   chtype string_colour;
+   if ( scurr->is_current_line )
+      string_colour = merge_curline_colour(fd->attr+ATTR_CURLINE,fd->ecolour+ECOLOUR_STRINGS);
+   else
+      string_colour = set_colour(fd->ecolour+ECOLOUR_STRINGS);
    if ( scurr->is_cursor_line
    &&   scurr->is_cursor_line_filearea_different )
       comment_colour = merge_curline_colour( fd->attr+ATTR_CURSORLINE, fd->ecolour+ECOLOUR_COMMENTS );
@@ -237,6 +261,8 @@
             || ( state == STATE_COMMENT && *ptr == '\0'))
             {
                TRACE_RETURN();
+               if (scurr->highlighting[pos-vcol] == string_colour)
+                 return -1L;
                return (long)pos;
             }
             break;
@@ -290,6 +316,8 @@
             || ( state == STATE_COMMENT && *ptr == '\0'))
             {
                TRACE_RETURN();
+               if (scurr->highlighting[pos-vcol] == string_colour)
+                 return -1L;
                return (long)pos;
             }
             break;
@@ -309,6 +337,8 @@
                if ( ch2 == '\0' )
                {
                   TRACE_RETURN();
+                  if (scurr->highlighting[i-vcol] == string_colour)
+                    return -1L;
                   return (long)curr->column;
                }
                if ( ch2 != ch1 )
@@ -341,6 +371,8 @@
    CHARTYPE ch1,ch2;
 
    TRACE_FUNCTION( "parser.c:  parse_single_comments" );
+   c_scrno = scrno;
+   c_scurr = scurr;
    if ( scurr->is_cursor_line
    &&   scurr->is_cursor_line_filearea_different )
       comment_colour = merge_curline_colour( fd->attr+ATTR_CURSORLINE, fd->ecolour+ECOLOUR_COMMENTS );
@@ -658,6 +690,8 @@
    for ( i = 0; i < screen[scrno].rows[WINDOW_FILEAREA]; i++ )
    {
       scurr = screen[scrno].sl + i;
+      c_scrno = scrno;
+      c_scurr = scurr;
       if (scurr->line_type == LINE_LINE
       &&  scurr->length > 0)
       {
diff -Naurd orig/proto.h mod/proto.h
--- orig/proto.h	2007-12-13 21:30:50.000000000 +0100
+++ mod/proto.h	2010-01-21 22:09:28.000000000 +0100
@@ -743,3 +743,43 @@
 short Xedit Args((CHARTYPE *));
 short Xterminal Args((CHARTYPE *));
 short Zone Args((CHARTYPE *));
+short Ansicstr Args((CHARTYPE *));
+short Banner Args((CHARTYPE *));
+short Calc Args((CHARTYPE *));
+short Center Args((CHARTYPE *));
+#if defined(PDC_CLIP_SUCCESS)
+short Clipboard Args((CHARTYPE *));
+#endif
+short Ebcdic Args((CHARTYPE *));
+short Eval Args((CHARTYPE *));
+short Flow Args((CHARTYPE *));
+short Fsave Args((CHARTYPE *));
+short FSearch Args((CHARTYPE *));
+short HLowercase Args((CHARTYPE *));
+short HSort Args((CHARTYPE *));
+short HUppercase Args((CHARTYPE *));
+short Justify Args((CHARTYPE *));
+short Lcompress Args((CHARTYPE *));
+short Ledit Args((CHARTYPE *));
+short Leftad Args((CHARTYPE *));
+short Lexpand Args((CHARTYPE *));
+short Linesep Args((CHARTYPE *));
+short Merge Args((CHARTYPE *));
+short Noutf Args((CHARTYPE *));
+short Onespc Args((CHARTYPE *));
+short Reverse Args((CHARTYPE *));
+short Rightad Args((CHARTYPE *));
+short Ringcmd Args((CHARTYPE *));
+short Sayf Args((CHARTYPE *));
+short Splttok Args((CHARTYPE *));
+short Tobin Args((CHARTYPE *));
+short Tochr Args((CHARTYPE *));
+short Todec Args((CHARTYPE *));
+short Tohex Args((CHARTYPE *));
+short Truncate Args((CHARTYPE *));
+/*short Unesc Args((CHARTYPE *));*/
+short Unjust Args((CHARTYPE *));
+short Utf Args((CHARTYPE *));
+short Wedit Args((CHARTYPE *));
+short Wind Args((CHARTYPE *));
+
diff -Naurd orig/query.c mod/query.c
--- orig/query.c	2008-02-29 01:56:45.000000000 +0100
+++ mod/query.c	2009-03-12 09:23:00.000000000 +0100
@@ -1884,6 +1884,21 @@
 
 **man-end**********************************************************************/
 
+short set_boolean_value(bool, short);
+#ifdef HAVE_PROTO
+short extract_gymod_function(short number_variables,short itemno,CHARTYPE *itemargs,CHARTYPE query_type,LINETYPE argc,CHARTYPE *arg,LINETYPE arglen)
+#else
+short extract_gymod_function(number_variables,itemno,itemargs,query_type,argc,arg,arglen)
+short number_variables,itemno;
+CHARTYPE *itemargs;
+CHARTYPE query_type;
+LINETYPE argc;
+CHARTYPE *arg;
+LINETYPE arglen;
+#endif
+{
+   return set_boolean_value((bool)TRUE,(short)1);
+}
 
 /***********************************************************************/
 /* Keep the following items in alphabetic order of name.               */
@@ -2047,6 +2062,7 @@
    {(CHARTYPE *)"first",           5, 5,ITEM_FIRST_FUNCTION,         0, 1,LVL_VIEW,0,extract_first_function         },
    {(CHARTYPE *)"focuseof",        8, 8,ITEM_FOCUSEOF_FUNCTION,      0, 1,LVL_VIEW,0,extract_focuseof_function      },
    {(CHARTYPE *)"focustof",        8, 8,ITEM_FOCUSTOF_FUNCTION,      0, 1,LVL_VIEW,0,extract_focustof_function      },
+   {(CHARTYPE *)"gymod",           5, 5,ITEM_GYMOD_FUNCTION,         0, 1,LVL_GLOB,0                                                  ,extract_gymod_function         },
    {(CHARTYPE *)"inblock",         7, 7,ITEM_INBLOCK_FUNCTION,       0, 1,LVL_VIEW,0,extract_inblock_function       },
    {(CHARTYPE *)"incommand",       9, 9,ITEM_INCOMMAND_FUNCTION,     0, 1,LVL_VIEW,0,extract_incommand_function     },
    {(CHARTYPE *)"initial",         7, 7,ITEM_INITIAL_FUNCTION,       0, 1,LVL_GLOB,0,extract_initial_function       },
@@ -2350,7 +2366,7 @@
          }
       }
    }
-   mvaddstr(terminal_lines-2,0,HIT_ANY_KEY);
+   mvaddstr(terminal_lines-1,0,HIT_ANY_KEY);
    refresh();
 
    TRACE_RETURN();
diff -Naurd orig/query.h mod/query.h
--- orig/query.h	2007-12-31 07:04:07.000000000 +0100
+++ mod/query.h	2009-03-12 09:25:00.000000000 +0100
@@ -200,22 +200,23 @@
 #define ITEM_FIRST_FUNCTION                  14
 #define ITEM_FOCUSEOF_FUNCTION               15
 #define ITEM_FOCUSTOF_FUNCTION               16
-#define ITEM_INBLOCK_FUNCTION                17
-#define ITEM_INCOMMAND_FUNCTION              18
-#define ITEM_INITIAL_FUNCTION                19
-#define ITEM_INPREFIX_FUNCTION               20
-#define ITEM_INSERTMODE_FUNCTION             21
-#define ITEM_LEFTEDGE_FUNCTION               22
-#define ITEM_MODIFIABLE_FUNCTION             23
-#define ITEM_RIGHTEDGE_FUNCTION              24
-#define ITEM_RUN_OS_FUNCTION                 25
-#define ITEM_SHADOW_FUNCTION                 26
-#define ITEM_SHIFT_FUNCTION                  27
-#define ITEM_SPACECHAR_FUNCTION              28
-#define ITEM_TOF_FUNCTION                    29
-#define ITEM_TOPEDGE_FUNCTION                30
-#define ITEM_VALID_TARGET_FUNCTION           31
-#define ITEM_VERONE_FUNCTION                 32
+#define ITEM_GYMOD_FUNCTION                  17
+#define ITEM_INBLOCK_FUNCTION                18 
+#define ITEM_INCOMMAND_FUNCTION              19 
+#define ITEM_INITIAL_FUNCTION                20 
+#define ITEM_INPREFIX_FUNCTION               21 
+#define ITEM_INSERTMODE_FUNCTION             22
+#define ITEM_LEFTEDGE_FUNCTION               23
+#define ITEM_MODIFIABLE_FUNCTION             24
+#define ITEM_RIGHTEDGE_FUNCTION              25
+#define ITEM_RUN_OS_FUNCTION                 26
+#define ITEM_SHADOW_FUNCTION                 27
+#define ITEM_SHIFT_FUNCTION                  28
+#define ITEM_SPACECHAR_FUNCTION              29
+#define ITEM_TOF_FUNCTION                    30
+#define ITEM_TOPEDGE_FUNCTION                31
+#define ITEM_VALID_TARGET_FUNCTION           32
+#define ITEM_VERONE_FUNCTION                 33
 /*---------------------------------------------------------------------*/
 /* The following are item number defines for the 'other' functions.    */
 /*---------------------------------------------------------------------*/
diff -Naurd orig/sort.c mod/sort.c
--- orig/sort.c	2005-06-19 03:23:03.000000000 +0200
+++ mod/sort.c	2009-04-29 19:40:35.000000000 +0200
@@ -49,6 +49,7 @@
   CHARTYPE order;                     /* A - ascending, D - descending */
   LENGTHTYPE left_col;                                  /* left column */
   LENGTHTYPE right_col;                                /* right column */
+  bool numerical;
  };
 typedef struct sort_field SORT_FIELD;
 
@@ -59,6 +60,15 @@
 
 short num_fields;
 
+extern bool HuSortFlag;
+extern bool HuSortCase;
+char chr_hun[] = "\x00";
+char chr_bas[] = "AAAEEIIIIOOOOOOOOUUUUUUUaaaaeeiiooooooouuuuuu\x00";
+char chr_dis[] = "123121234012345671234567123412121234567123456 ";
+/*char ch_utf2[]="\x00";*/
+char ch_utfa[] = "AEIOOOUUUaeiooouuu\x00";
+char ch_utfb[] = "88889:89:9999:;9:;\x00";
+
 #ifdef HAVE_PROTO
 static int cmp(const void *,const void *);
 #else
@@ -74,6 +84,9 @@
 #endif
 /***********************************************************************/
 {
+   register int k,l;
+   float num;
+   char form[8]="%0\n";
    LENGTHTYPE i=0,j=0;
    short rc=RC_OK;
    LENGTHTYPE len=0;
@@ -90,6 +103,16 @@
        * Calculate the length of the sort field.
        */
       len = sort_fields[i].right_col - sort_fields[i].left_col + 1;
+      if (sort_fields[i].numerical==TRUE)
+      {
+        len++;
+        if (len>14)
+          len = 14;
+        (void)itoa_dj(len+1, &form[2], 10);
+        strcat(form, ".2f");
+      }
+      if (HuSortFlag && HuSortCase)
+        len *= 2;
       /*
        * Set the two temporary fields to blanks.
        */
@@ -106,6 +129,12 @@
        * contents of the sort field blank.
        */
       if (sort_fields[i].left_col <= one->length)
+       if (HuSortFlag && HuSortCase)
+       {
+         for (j=0,k=0;j<(len-1);j+=2,k++)
+           memcpy(sort_field_1+j,one->line+left_col-1+k,1);
+       }
+       else
          memcpy(sort_field_1,one->line+left_col-1,right_col-left_col+1);
       /*
        * For the next  line to be compared, extract the portion of the line
@@ -118,7 +147,418 @@
        * contents of the sort field blank.
        */
       if (sort_fields[i].left_col <= two->length)
+       if (HuSortFlag && HuSortCase)
+       {
+         for (j=0,k=0;j<(len-1);j+=2,k++)
+           memcpy(sort_field_2+j,two->line+left_col-1+k,1);
+       }
+       else
          memcpy(sort_field_2,two->line+left_col-1,right_col-left_col+1);
+     if (HuSortFlag)
+     {
+         if (sort_field_1[2] == '.'
+         && (sort_field_1[0] == 'd' || sort_field_1[0] == 'D')
+         && (sort_field_1[1] == 'r' || sort_field_1[1] == 'R'))
+         {
+           j = 3;
+           if (sort_field_1[0] == ' ')
+             j++;
+           memcpy(sort_field_1,sort_field_1+j,len-j);
+         }
+         if (sort_field_2[2] == '.'
+         && (sort_field_2[0] == 'd' || sort_field_2[0] == 'D')
+         && (sort_field_2[1] == 'r' || sort_field_2[1] == 'R'))
+         {
+           j = 3;
+           if (sort_field_2[0] == ' ')
+             j++;
+           memcpy(sort_field_2,sort_field_2+j,len-j);
+         }
+         if (HuSortCase)
+         {
+             l = (int) &chr_hun;
+             for (j=0;j<(len-2);j+=2)
+             {
+                 if (sort_field_1[j] == 195)
+                 {
+                   k = -1;
+                   switch(sort_field_1[j+2])
+                   {
+                     case 129:
+                       k = 0;
+                       break;
+                     case 137:
+                       k = 1;
+                       break;
+                     case 141:
+                       k = 2;
+                       break;
+                     case 147:
+                       k = 3;
+                       break;
+                     case 150:
+                       k = 4;
+                       break;
+                     case 154:
+                       k = 6;
+                       break;
+                     case 156:
+                       k = 7;
+                       break;
+                     case 161:
+                       k = 9;
+                       break;
+                     case 169:
+                       k = 10;
+                       break;
+                     case 173:
+                       k = 11;
+                       break;
+                     case 179:
+                       k = 12;
+                       break;
+                     case 182:
+                       k = 13;
+                       break;
+                     case 186:
+                       k = 15;
+                       break;
+                     case 188:
+                       k = 16;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != -1)
+                   {
+                     sort_field_1[j] = ch_utfa[k];
+                     sort_field_1[j+1] = ch_utfb[k];
+                     strcpy(sort_field_1+j+2,sort_field_1+j+4);
+                   }
+                 }
+                 else if (sort_field_1[j] == 197)
+                 {
+                   k = 0;
+                   switch(sort_field_1[j+2])
+                   {
+                     case 144:
+                       k = 5;
+                       break;
+                     case 145:
+                       k = 14;
+                       break;
+                     case 176:
+                       k = 8;
+                       break;
+                     case 177:
+                       k = 17;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != 0)
+                   {
+                     sort_field_1[j] = ch_utfa[k];
+                     sort_field_1[j+1] = ch_utfb[k];
+                     strcpy(sort_field_1+j+2,sort_field_1+j+4);
+                   }
+                 }
+                 else
+                 {
+                   k = (int) index(chr_hun, sort_field_1[j]);
+                   if (k>0)
+                   {
+                     k -= l;
+                     sort_field_1[j] = chr_bas[k];
+                     sort_field_1[j+1] = chr_dis[k];
+                   }
+                 }
+                 if (sort_field_2[j] == 195)
+                 {
+                   k = -1;
+                   switch(sort_field_2[j+2])
+                   {
+                     case 129:
+                       k = 0;
+                       break;
+                     case 137:
+                       k = 1;
+                       break;
+                     case 141:
+                       k = 2;
+                       break;
+                     case 147:
+                       k = 3;
+                       break;
+                     case 150:
+                       k = 4;
+                       break;
+                     case 154:
+                       k = 6;
+                       break;
+                     case 156:
+                       k = 7;
+                       break;
+                     case 161:
+                       k = 9;
+                       break;
+                     case 169:
+                       k = 10;
+                       break;
+                     case 173:
+                       k = 11;
+                       break;
+                     case 179:
+                       k = 12;
+                       break;
+                     case 182:
+                       k = 13;
+                       break;
+                     case 186:
+                       k = 15;
+                       break;
+                     case 188:
+                       k = 16;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != -1)
+                   {
+                     sort_field_2[j] = ch_utfa[k];
+                     sort_field_2[j+1] = ch_utfb[k];
+                     strcpy(sort_field_2+j+2,sort_field_2+j+4);
+                   }
+                 }
+                 else if (sort_field_2[j] == 197)
+                 {
+                   k = 0;
+                   switch(sort_field_2[j+2])
+                   {
+                     case 144:
+                       k = 5;
+                       break;
+                     case 145:
+                       k = 14;
+                       break;
+                     case 176:
+                       k = 8;
+                       break;
+                     case 177:
+                       k = 17;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != 0)
+                   {
+                     sort_field_2[j] = ch_utfa[k];
+                     sort_field_2[j+1] = ch_utfb[k];
+                     strcpy(sort_field_2+j+2,sort_field_2+j+4);
+                   }
+                 }
+                 else
+                 {
+                   k = (int) index(chr_hun, sort_field_2[j]);
+                   if (k>0)
+                   {
+                     k -= l;
+                     sort_field_2[j] = chr_bas[k];
+                     sort_field_2[j+1] = chr_dis[k];
+                   }
+                 }
+             }
+         }
+         else
+         {
+             l = (int) &chr_hun;
+             for (j=0;j<len;j++)
+             {
+                 if (sort_field_1[j] == 195)
+                 {
+                   k = -1;
+                   switch(sort_field_1[j+1])
+                   {
+                     case 129:
+                       k = 0;
+                       break;
+                     case 137:
+                       k = 1;
+                       break;
+                     case 141:
+                       k = 2;
+                       break;
+                     case 147:
+                       k = 3;
+                       break;
+                     case 150:
+                       k = 4;
+                       break;
+                     case 154:
+                       k = 6;
+                       break;
+                     case 156:
+                       k = 7;
+                       break;
+                     case 161:
+                       k = 9;
+                       break;
+                     case 169:
+                       k = 10;
+                       break;
+                     case 173:
+                       k = 11;
+                       break;
+                     case 179:
+                       k = 12;
+                       break;
+                     case 182:
+                       k = 13;
+                       break;
+                     case 186:
+                       k = 15;
+                       break;
+                     case 188:
+                       k = 16;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != -1)
+                   {
+                     sort_field_1[j] = ch_utfa[k];
+                     memcpy(sort_field_1+j+1,sort_field_1+j+2,len-(j+2));
+                   }
+                 }
+                 else if (sort_field_1[j] == 197)
+                 {
+                   k = 0;
+                   switch(sort_field_1[j+1])
+                   {
+                     case 144:
+                       k = 5;
+                       break;
+                     case 145:
+                       k = 14;
+                       break;
+                     case 176:
+                       k = 8;
+                       break;
+                     case 177:
+                       k = 17;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != 0)
+                   {
+                     sort_field_1[j] = ch_utfa[k];
+                     memcpy(sort_field_1+j+1,sort_field_1+j+2,len-(j+2));
+                   }
+                 }
+                 else
+                 {
+                   k = (int) index(chr_hun, sort_field_1[j]);
+                   if (k>0)
+                   {
+                     k -= l;
+                     sort_field_1[j] = chr_bas[k];
+                   }
+                 }
+                 if (sort_field_2[j] == 195)
+                 {
+                   k = -1;
+                   switch(sort_field_2[j+1])
+                   {
+                     case 129:
+                       k = 0;
+                       break;
+                     case 137:
+                       k = 1;
+                       break;
+                     case 141:
+                       k = 2;
+                       break;
+                     case 147:
+                       k = 3;
+                       break;
+                     case 150:
+                       k = 4;
+                       break;
+                     case 154:
+                       k = 6;
+                       break;
+                     case 156:
+                       k = 7;
+                       break;
+                     case 161:
+                       k = 9;
+                       break;
+                     case 169:
+                       k = 10;
+                       break;
+                     case 173:
+                       k = 11;
+                       break;
+                     case 179:
+                       k = 12;
+                       break;
+                     case 182:
+                       k = 13;
+                       break;
+                     case 186:
+                       k = 15;
+                       break;
+                     case 188:
+                       k = 16;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != -1)
+                   {
+                     sort_field_2[j] = ch_utfa[k];
+                     memcpy(sort_field_2+j+1,sort_field_2+j+2,len-(j+2));
+                   }
+                 }
+                 else if (sort_field_2[j] == 197)
+                 {
+                   k = 0;
+                   switch(sort_field_2[j+1])
+                   {
+                     case 144:
+                       k = 5;
+                       break;
+                     case 145:
+                       k = 14;
+                       break;
+                     case 176:
+                       k = 8;
+                       break;
+                     case 177:
+                       k = 17;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != 0)
+                   {
+                     sort_field_2[j] = ch_utfa[k];
+                     memcpy(sort_field_2+j+1,sort_field_2+j+2,len-(j+2));
+                   }
+                 }
+                 else
+                 {
+                   k = (int) index(chr_hun, sort_field_2[j]);
+                   if (k>0)
+                   {
+                     k -= l;
+                     sort_field_2[j] = chr_bas[k];
+                   }
+                 }
+             }
+         }
+     }
       /*
        * If CASE IGNORE is on for the current view, set both sort fields to
        * uppercase for the comparison.
@@ -133,6 +573,13 @@
                sort_field_2[j] = toupper(sort_field_2[j]);
          }
       }
+      if (sort_fields[i].numerical==TRUE)
+      {
+        num = atof(sort_field_1);
+        (void)sprintf(sort_field_1, form, num);
+        num = atof(sort_field_2);
+        (void)sprintf(sort_field_2, form, num);
+      }
       /*
        * If the two sort fields are equal, continue the sort with the next
        * sort field value. If the sort fields are different, return with the
@@ -249,12 +696,15 @@
           * Processing for 2 parameters; validate ordering value.
           */
          if (equal((CHARTYPE *)"ascending",word[0],1)
+         || equal((CHARTYPE *)"an",word[0],2)
+         || equal((CHARTYPE *)"dn",word[0],2)
          ||  equal((CHARTYPE *)"descending",word[0],1))
          {
             order = word[0][0];
             if (islower(order))
                order = toupper(order);
             sort_fields[0].order = order;
+            sort_fields[0].numerical = (toupper(word[0][1]) == 'N');
             break;
          }
          /*
@@ -278,12 +728,15 @@
             {
                case SF_START:
                   if (equal((CHARTYPE *)"ascending",word[i],1)
+                  || equal((CHARTYPE *)"an",word[i],2)
+                  || equal((CHARTYPE *)"dn",word[i],2)
                   ||  equal((CHARTYPE *)"descending",word[i],1))
                   {
                      order = word[i][0];
                      if (islower(order))
                         order = toupper(order);
                      sort_fields[num_fields].order = order;
+                     sort_fields[num_fields].numerical = (toupper(word[i][1]) == 'N');
                      state = SF_ORDER;
                      i++;
                      break;
@@ -371,6 +824,8 @@
    for (i=0;i<num_fields;i++)
       max_column_width = max(max_column_width,
                 sort_fields[i].right_col - sort_fields[i].left_col + 1);
+   if (HuSortFlag && HuSortCase)
+      max_column_width *=2;
    /*
     * Allocate memory for each of the temporary sort fields to the length
     * of the maximum field width.
diff -Naurd orig/the.c mod/the.c
--- orig/the.c	2008-02-29 01:56:45.000000000 +0100
+++ mod/the.c	2009-11-06 15:34:56.000000000 +0100
@@ -51,7 +51,7 @@
 # ifdef UNIX
 static RETSIGTYPE handle_signal(int);
 # endif
-static void display_info(CHARTYPE *);
+static void display_info(CHARTYPE *, char);
 static void init_signals(void);
 #else
 # ifdef UNIX
@@ -184,6 +184,8 @@
    CHARTYPE *prf_arg=(CHARTYPE *)NULL;
    CHARTYPE *local_prf=(CHARTYPE *)NULL;
    CHARTYPE *specified_prf=(CHARTYPE *)NULL;
+   CHARTYPE *specified_lsf=(CHARTYPE *)NULL;
+   CHARTYPE *specified_str=(CHARTYPE *)NULL;
 
    CHARTYPE tabkey_insert='C';
    CHARTYPE tabkey_overwrite='T';
@@ -466,6 +468,7 @@
 #if defined(XCURSES) && PDC_BUILD >= 2401
    strcat( mygetopt_opts, "X:" );
 #endif
+   strcat( mygetopt_opts, "vV@:f:" );
 
    while ((c = my_getopt( argc, argv, mygetopt_opts ) ) != EOF )
    {
@@ -625,10 +628,36 @@
             }
             break;
 #endif
+         case '@':
+            if ((specified_lsf = (CHARTYPE *)(*the_malloc)(
+                 (strlen(optarg)+1)*sizeof(CHARTYPE))) == NULL)
+            {
+              cleanup();
+              display_error(30,(CHARTYPE *)"",FALSE);
+              return(6);
+            }
+            strcpy((DEFCHAR *)specified_lsf,(DEFCHAR *)optarg);
+            break;
+         case 'f':
+            if ((specified_str = (CHARTYPE *)(*the_malloc)(
+                 (strlen(optarg)+2)*sizeof(CHARTYPE))) == NULL)
+            {
+              cleanup();
+              display_error(30,(CHARTYPE *)"",FALSE);
+              return(6);
+            }
+            if (optarg[0] == '/')
+              strcpy((DEFCHAR *)specified_str,(DEFCHAR *)"");
+            else
+              strcpy((DEFCHAR *)specified_str,(DEFCHAR *)"/");
+            strcat((DEFCHAR *)specified_str,(DEFCHAR *)optarg);
+            break;
+         case 'v':
+         case 'V':
          case 'h':
          case '?':
             cleanup();
-            display_info((CHARTYPE *)argv[0]);
+            display_info((CHARTYPE *)argv[0], c);
             return(0);
             break;
 #ifdef THE_SINGLE_INSTANCE_ENABLED
@@ -1106,6 +1135,22 @@
          return(24);
       }
       current_file_name = current_file_name->next;
+      if (specified_str != NULL)
+      {
+        in_nomsg = TRUE;
+        rc = execute_locate(specified_str, FALSE, THE_NOT_SEARCH_SEMANTICS, NULL);
+        in_nomsg = FALSE;
+        if (rc == RC_OK)
+        {
+          Sos_current((CHARTYPE *)"");
+          Clocate((CHARTYPE *)specified_str);
+        }
+      }
+   }
+   if (specified_str != NULL)
+   {
+     (*the_free)(specified_str);
+     specified_str = NULL;
    }
    first_file_name = lll_free(first_file_name);
    /*
@@ -1121,6 +1166,11 @@
     */
    in_profile = FALSE;
    been_interactive = TRUE;
+   if (specified_lsf != NULL)
+   {
+      Ledit(specified_lsf);
+      (*the_free)(specified_lsf);
+   }
    /*
     * This is where it all happens!!!
     */
@@ -1403,19 +1453,74 @@
    return(rc);
 }
 /***********************************************************************/
+char *itoa_dj(int value, char *string, int radix)
+{
+  char tmp[33];
+  char *tp = tmp;
+  int i;
+  unsigned v;
+  int sign;
+  char *sp;
+  if (radix > 36 || radix <= 1)
+  {
+    errno = EDOM;
+    return 0;
+  }
+  sign = (radix == 10 && value < 0);
+  if (sign)
+    v = -value;
+  else
+    v = (unsigned)value;
+  while (v || tp == tmp)
+  {
+    i = v % radix;
+    v = v / radix;
+    if (i < 10)
+      *tp++ = i+'0';
+    else
+      *tp++ = i + 'a' - 10;
+  }
+  if (string == 0)
+    string = (char *)malloc((tp-tmp)+sign+1);
+  sp = string;
+  if (sign)
+    *sp++ = '-';
+  while (tp > tmp)
+    *sp++ = *--tp;
+  *sp = 0;
+  return string;
+}
 #ifdef HAVE_PROTO
-static void display_info(CHARTYPE *argv0)
+static void display_info(CHARTYPE *argv0, char opt)
 #else
 static void display_info(argv0)
 CHARTYPE *argv0;
+char opt;
 #endif
 /***********************************************************************/
 {
+   CHARTYPE rsrvd[MAX_FILE_NAME+1];
    fprintf(stdout,"\nTHE %s %2s %s. All rights reserved.\n",the_version,the_release,the_copyright);
+   if (toupper(opt)=='V')
+   {
+#ifdef PDC_BUILD
+     strcpy(rsrvd, (DEFCHAR *)"PDC_????");
+     itoa_dj(PDC_BUILD, rsrvd+4, 10);
+     fprintf(stdout,"- Curses: %s\n",rsrvd);
+#endif
+#ifdef USE_REGINA
+     rexx_support = TRUE;
+     get_rexx_interpreter_version(rsrvd);
+     fprintf(stdout,"-   Rexx: %s\n",rsrvd);
+#endif
+     fprintf(stdout,"Modified: GYMOD\n");
+     fflush(stdout);
+     return;
+   }
    fprintf(stdout,"THE is distributed under the terms of the GNU General Public License \n");
    fprintf(stdout,"and comes with NO WARRANTY. See the file COPYING for details.\n");
    fprintf(stdout,"\nUsage:\n\n%s [-h?nmrsbq] [-p profile] [-a profile_arg] [-l line_num] [-c col_num] [-w width] [-u display_length] [-k[fmt]] [[dir] [file [...]]]\n",argv0);
-   fprintf(stdout,"\nwhere:\n\n");
+   fprintf(stdout,"\nwhere:\n");
    fprintf(stdout,"-h,-?                  show this message\n");
    fprintf(stdout,"-n                     do not execute a profile file\n");
    fprintf(stdout,"-m                     force display into mono\n");
@@ -1431,9 +1536,12 @@
    fprintf(stdout,"-w width               maximum width of line (default 512)\n");
    fprintf(stdout,"-u display_length      display length in non-line mode\n");
 #ifdef XCURSES
-   fprintf(stdout,"-X X11_switches        X11 switches (enclosed in \"\"\n");
+   fprintf(stdout,"-X X11_switches        X11 switches (enclosed in \"\")\n");
    fprintf(stdout,"-1[fifoname]           run in single window mode, optionally supplying FIFO name\n");
 #endif
+   fprintf(stdout,"-@ lstfile             filename of listfile for open files\n");
+   fprintf(stdout,"-f searchstring        find first occurrence of specified string\n");
+   fprintf(stdout,"-v                     output version information\n");
    fprintf(stdout,"[dir [file [...]]]     file(s) and/or directory to be edited\n\n");
    fflush(stdout);
    return;
diff -Naurd orig/the.h mod/the.h
--- orig/the.h	2008-02-29 01:56:45.000000000 +0100
+++ mod/the.h	2009-03-12 10:44:00.000000000 +0100
@@ -35,6 +35,16 @@
 
 #include "thedefs.h"
 
+#if defined(DOS)
+# define DOS 6
+# define PDCURSES_MOUSE_ENABLED 1
+#endif
+
+# define PADSLASH        0x1ca   /* slash on keypad               */
+# define PADSTAR         0x1cf   /* star on keypad                */
+# define PADMINUS        0x1d0   /* minus on keypad               */
+# define PADPLUS         0x1d1   /* plus on keypad                */
+
 #if defined(USE_XCURSES)
 #  define XCURSES
 #  include <curses.h>
diff -Naurd orig/vars.h mod/vars.h
--- orig/vars.h	2007-12-13 21:29:44.000000000 +0100
+++ mod/vars.h	2009-11-05 20:09:02.000000000 +0100
@@ -34,6 +34,25 @@
 */
 
 /* Please, include the.h first. */
+#define F_CENTER 0
+#define F_LEFT   1
+#define F_UNJUST 2
+#define F_RIGHT  3
+#define F_TRUNC  4
+#define F_JUST   5
+#define F_1SPC   6
+#define F_TOBIN  7
+#define F_TOCHR  8
+#define F_TODEC  9
+#define F_TOHEX 10
+#define F_UNESC 11
+#define F_CRYPT 12
+#define F_REV   15
+#define F_UTF   16
+#define F_LAT   17
+extern bool lefttabconv;
+extern bool dialogw;
+extern bool file_list_msg;
 
 /* commset1.c */
 extern the_header_mapping thm[];
