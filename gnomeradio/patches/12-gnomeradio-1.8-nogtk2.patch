Index: b/src/bacon-volume.c
===================================================================
--- a/src/bacon-volume.c	2012-12-03 10:14:53.474899850 +0000
+++ b/src/bacon-volume.c	2012-12-03 10:14:53.722899843 +0000
@@ -520,7 +520,7 @@
 			float step)
 {
   BaconVolumeScale *scale = g_object_new (BACON_TYPE_VOLUME_SCALE, NULL);
-  GtkObject *adj;
+  GObject *adj;
 
   adj = gtk_adjustment_new (min, min, max, step, 10 * step, 0);
   gtk_range_set_adjustment (GTK_RANGE (scale), GTK_ADJUSTMENT (adj));
Index: b/src/bacon-volume.h
===================================================================
--- a/src/bacon-volume.h	2012-12-03 10:14:49.950899955 +0000
+++ b/src/bacon-volume.h	2012-12-03 10:14:53.722899843 +0000
@@ -20,8 +20,7 @@
 #ifndef __BACON_VOLUME_BUTTON_H__
 #define __BACON_VOLUME_BUTTON_H__
 
-#include <gtk/gtkbutton.h>
-#include <gtk/gtkicontheme.h>
+#include <gtk/gtk.h>
 
 G_BEGIN_DECLS
 
Index: b/src/gui.c
===================================================================
--- a/src/gui.c	2012-12-03 10:14:53.474899850 +0000
+++ b/src/gui.c	2012-12-03 10:14:53.722899843 +0000
@@ -21,9 +21,11 @@
 /*** the gui to gnomeradio */
 
 #include <config.h>
-#include <gnome.h>
+#include <glib/gi18n.h>
 #include <libgnome-media-profiles/gnome-media-profiles.h>
 #include <gconf/gconf-client.h>
+#include <dbus/dbus-glib.h>
+#include <dbus/dbus-glib-bindings.h>
 #include <math.h>
 #include "bacon-volume.h"
 #include "gui.h"
@@ -50,7 +52,6 @@
 
 GtkWidget* mute_button, *preset_combo;
 GtkAdjustment *adj;
-GtkTooltips *tooltips;
 
 int mom_ps;
 gnomeradio_settings settings;
@@ -58,12 +59,14 @@
 gboolean main_visible;
 
 static GtkWidget *drawing_area;
-static GdkPixmap *digits, *signal_s, *stereo;
+static GdkPixbuf *digits, *signal_s, *stereo;
 static GtkWidget *freq_scale;
 static GtkWidget *rec_pixmap;
 
 static int timeout_id, bp_timeout_id = -1, bp_timeout_steps = 0;
 
+static DBusGProxy      * connect_to_session               (void);
+
 static gboolean is_first_start(void)
 {
 	GConfClient *client = gconf_client_get_default();
@@ -132,7 +135,7 @@
 	
 	data.dialog = gtk_dialog_new_with_buttons(_("Scanning"),
 		GTK_WINDOW(app), DIALOG_FLAGS, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL);
-	gtk_dialog_set_has_separator(GTK_DIALOG(data.dialog), FALSE);
+	/* gtk_dialog_set_has_separator(GTK_DIALOG(data.dialog), FALSE); */
 	gtk_window_set_resizable(GTK_WINDOW(data.dialog), FALSE);
 	
 	title_hdr = g_strconcat("<span weight=\"bold\">", _("Scanning for available stations:"), "</span>", NULL);
@@ -153,7 +156,7 @@
 	
 	radio_mute();
 	timeout_id = g_timeout_add(1000/SCAN_SPEED, (GSourceFunc)initial_frequency_scan_cb, (gpointer)&data);	
-	int response = gtk_dialog_run(GTK_DIALOG(data.dialog));
+	gtk_dialog_run(GTK_DIALOG(data.dialog));
 
 	radio_unmute();
 	if (timeout_id) {
@@ -218,7 +221,7 @@
 			break;
 			default:
 				/* We need the hide signal to get the value of the device_entry */
-				gtk_widget_hide_all(dialog);
+				gtk_widget_hide(dialog);
 				gtk_widget_destroy(dialog);
 		}
 	}
@@ -306,9 +309,9 @@
 static gboolean redraw_status_window(void)
 {
 
-	GdkWindow *real_window, *window;
-	GdkGC *gc;
-	int win_width, win_height;
+	GdkWindow *real_window;
+	cairo_t *cr;
+	int win_width;
 	int val, freq[5], signal_strength, is_stereo;
 	
 	val = (int)(rint(gtk_adjustment_get_value(adj)/STEPS * 100.0));
@@ -330,32 +333,62 @@
 	if (real_window == NULL)
 		/* UI has not been realized yet */
 		return TRUE;
-	gc = gdk_gc_new(real_window);
-	gdk_drawable_get_size(real_window, &win_width, &win_height);
+	/* gdk_drawable_get_size(real_window, &win_width, &win_height); */
+	win_width = gdk_window_get_width (real_window);
 	
 	/* use doublebuffering to avoid flickering */
-	window = gdk_pixmap_new(real_window, win_width, win_height, -1);
+	/* window = gdk_pixmap_new(real_window, win_width, win_height, -1); */
 
-	gdk_draw_rectangle(window, gc, TRUE, 0, 0, win_width, win_height);
+	cr = gdk_cairo_create (real_window);
+	cairo_set_source_rgb (cr, 1, 1, 1);
+	cairo_paint (cr);
 	
 	win_width -= 5;
 	
-	if (freq[0])	gdk_draw_drawable(window, gc, digits, freq[0] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*6, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
-	else gdk_draw_rectangle(window, gc, TRUE, win_width - DIGIT_WIDTH*6, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
+	if (freq[0]) {
+		/* gdk_draw_drawable(window, gc, digits, freq[0] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*6, 5, DIGIT_WIDTH, DIGIT_HEIGTH); */
+		gdk_cairo_set_source_pixbuf (cr, digits, win_width - DIGIT_WIDTH*6 - freq[0] * DIGIT_WIDTH, 5);
+		cairo_rectangle (cr, win_width - DIGIT_WIDTH*6, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
+		cairo_fill (cr);
+	} else {
+		cairo_rectangle(cr, win_width - DIGIT_WIDTH*6, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
+		cairo_fill (cr);
+	}
 
-	gdk_draw_drawable(window, gc, digits, freq[1] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*5, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
-	gdk_draw_drawable(window, gc, digits, freq[2] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*4, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
-	gdk_draw_drawable(window, gc, digits, 10 * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*3, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
-	gdk_draw_drawable(window, gc, digits, freq[3] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*2, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
-	gdk_draw_drawable(window, gc, digits, freq[4] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*1, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
-	gdk_draw_drawable(window, gc, signal_s, signal_strength * SIGNAL_WIDTH, 0, win_width - DIGIT_WIDTH*6-SIGNAL_WIDTH, 5, SIGNAL_WIDTH, DIGIT_HEIGTH);
-	gdk_draw_drawable(window, gc, stereo, is_stereo * STEREO_WIDTH, 0, win_width - DIGIT_WIDTH*6-SIGNAL_WIDTH-STEREO_WIDTH, 5, STEREO_WIDTH, DIGIT_HEIGTH);
+	/* gdk_draw_drawable(window, gc, digits, freq[1] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*5, 5, DIGIT_WIDTH, DIGIT_HEIGTH); */
+	gdk_cairo_set_source_pixbuf (cr, digits, win_width - DIGIT_WIDTH*5 - freq[1] * DIGIT_WIDTH, 5);
+	cairo_rectangle (cr, win_width - DIGIT_WIDTH*5, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
+	cairo_fill(cr);
+	/* gdk_draw_drawable(window, gc, digits, freq[2] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*4, 5, DIGIT_WIDTH, DIGIT_HEIGTH); */
+	gdk_cairo_set_source_pixbuf (cr, digits, win_width - DIGIT_WIDTH*4 - freq[2] * DIGIT_WIDTH, 5);
+	cairo_rectangle (cr, win_width - DIGIT_WIDTH*4, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
+	cairo_fill(cr);
+	/* gdk_draw_drawable(window, gc, digits, 10 * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*3, 5, DIGIT_WIDTH, DIGIT_HEIGTH); */
+	gdk_cairo_set_source_pixbuf (cr, digits, win_width - DIGIT_WIDTH*3 - 10 * DIGIT_WIDTH, 5);
+	cairo_rectangle (cr, win_width - DIGIT_WIDTH*3, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
+	cairo_fill(cr);
+	/* gdk_draw_drawable(window, gc, digits, freq[3] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*2, 5, DIGIT_WIDTH, DIGIT_HEIGTH); */
+	gdk_cairo_set_source_pixbuf (cr, digits, win_width - DIGIT_WIDTH*2 - freq[3] * DIGIT_WIDTH, 5);
+	cairo_rectangle (cr, win_width - DIGIT_WIDTH*2, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
+	cairo_fill(cr);
+	/* gdk_draw_drawable(window, gc, digits, freq[4] * DIGIT_WIDTH, 0, win_width - DIGIT_WIDTH*1, 5, DIGIT_WIDTH, DIGIT_HEIGTH); */
+	gdk_cairo_set_source_pixbuf (cr, digits, win_width - DIGIT_WIDTH*1 - freq[4] * DIGIT_WIDTH, 5);
+	cairo_rectangle (cr, win_width - DIGIT_WIDTH*1, 5, DIGIT_WIDTH, DIGIT_HEIGTH);
+	cairo_fill(cr);
+	/* gdk_draw_drawable(window, gc, signal_s, signal_strength * SIGNAL_WIDTH, 0, win_width - DIGIT_WIDTH*6-SIGNAL_WIDTH, 5, SIGNAL_WIDTH, DIGIT_HEIGTH); */
+	gdk_cairo_set_source_pixbuf (cr, signal_s, win_width - DIGIT_WIDTH*6-SIGNAL_WIDTH - signal_strength * SIGNAL_WIDTH, 5);
+	cairo_rectangle (cr, win_width - DIGIT_WIDTH*6-SIGNAL_WIDTH, 5, SIGNAL_WIDTH, DIGIT_HEIGTH);
+	cairo_fill(cr);
+	/* gdk_draw_drawable(window, gc, stereo, is_stereo * STEREO_WIDTH, 0, win_width - DIGIT_WIDTH*6-SIGNAL_WIDTH-STEREO_WIDTH, 5, STEREO_WIDTH, DIGIT_HEIGTH); */
+	gdk_cairo_set_source_pixbuf (cr, stereo, win_width - DIGIT_WIDTH*6-SIGNAL_WIDTH-STEREO_WIDTH - is_stereo * STEREO_WIDTH, 5);
+	cairo_rectangle (cr, win_width - DIGIT_WIDTH*6-SIGNAL_WIDTH-STEREO_WIDTH, 5, STEREO_WIDTH, DIGIT_HEIGTH);
+	cairo_fill(cr);
 
-	/* draw the pixmap to the real window */	
-	gdk_draw_drawable(real_window, gc, window, 0, 0, 0, 0, win_width + 5, win_height);
+	/* draw the pixmap to the real window */		
+	/* gdk_draw_drawable(real_window, gc, window, 0, 0, 0, 0, win_width + 5, win_height); */
 	
-	g_object_unref(G_OBJECT(gc));
-	g_object_unref(G_OBJECT(window));
+	cairo_destroy (cr);
+	/* g_object_unref(G_OBJECT(window)); */
 	
 	return TRUE;	
 }
@@ -413,11 +446,11 @@
 	else
 		buffer = g_strdup_printf(_("Gnomeradio - %.2f MHz"), freq);
 	gtk_window_set_title(GTK_WINDOW(window), buffer);
-	if (tray_icon) gtk_status_icon_set_tooltip(GTK_STATUS_ICON(tray_icon), buffer); //gtk_tooltips_set_tip(tooltips, tray_icon, buffer, NULL);
+	if (tray_icon) gtk_status_icon_set_tooltip_text(GTK_STATUS_ICON(tray_icon), buffer); //gtk_tooltips_set_tip(tooltips, tray_icon, buffer, NULL);
 	g_free(buffer);
 	
 	buffer = g_strdup_printf(_("Frequency: %.2f MHz"), freq);
-	gtk_tooltips_set_tip(tooltips, freq_scale, buffer, NULL);
+	gtk_widget_set_tooltip_text(freq_scale, buffer);	
 	g_free(buffer);
 
 	radio_set_freq(gtk_adjustment_get_value(adj)/STEPS);
@@ -425,13 +458,13 @@
 
 static void volume_value_changed_cb(BaconVolumeButton *button, gpointer user_data)
 {
-	char *text;
+	/* char *text; */
 	int vol = (int)(bacon_volume_button_get_value(BACON_VOLUME_BUTTON(mute_button)) + 0.5f);
 	
 	mixer_set_volume(vol);
 	
 /*	text = g_strdup_printf(_("Volume: %d%%"), vol);
-	gtk_tooltips_set_tip(tooltips, vol_scale, text, NULL);
+	gtk_widget_set_tooltip_text(vol_scale, text);
 	g_free(text);*/
 	
     if (tray_menu) {
@@ -484,9 +517,9 @@
 	change_frequency(data);
 	if (bp_timeout_steps < 10)
 	{
-		gtk_timeout_remove(bp_timeout_id);
-		bp_timeout_id = gtk_timeout_add(200 - 20*bp_timeout_steps,
-			(GtkFunction)change_frequency_timeout, data);
+		g_source_remove(bp_timeout_id);
+		bp_timeout_id = g_timeout_add(200 - 20*bp_timeout_steps,
+			(GSourceFunc)change_frequency_timeout, data);
 		bp_timeout_steps++; 
 	}
 	return TRUE;
@@ -494,7 +527,7 @@
 
 static void step_button_pressed_cb(GtkButton *button, gpointer data)
 {
-	bp_timeout_id = gtk_timeout_add(500, (GtkFunction)change_frequency_timeout, data);
+	bp_timeout_id = g_timeout_add(500, (GSourceFunc)change_frequency_timeout, data);
 }
 
 static void step_button_clicked_cb(GtkButton *button, gpointer data)
@@ -505,7 +538,7 @@
 static void step_button_released_cb(GtkButton *button, gpointer data)
 {
 	if (bp_timeout_id > -1)
-		gtk_timeout_remove(bp_timeout_id);
+		g_source_remove(bp_timeout_id);
 	bp_timeout_id = -1;
 	bp_timeout_steps = 0;
 }
@@ -544,25 +577,25 @@
 void scfw_button_clicked_cb(GtkButton *button, gpointer data)
 {
 	if (timeout_id) {
-		gtk_timeout_remove(timeout_id);
+		g_source_remove(timeout_id);
 		timeout_id = 0;
 		radio_unmute();
 		return;
 	}
 	radio_mute();
-	timeout_id = gtk_timeout_add(1000/SCAN_SPEED, (GtkFunction)scan_freq, (gpointer)1);	
+	timeout_id = g_timeout_add(1000/SCAN_SPEED, (GSourceFunc)scan_freq, (gpointer)1);	
 }
 
 void scbw_button_clicked_cb(GtkButton *button, gpointer data)
 {
 	if (timeout_id) {
-		gtk_timeout_remove(timeout_id);
+		g_source_remove(timeout_id);
 		timeout_id = 0;
 		radio_unmute();
 		return;
 	}
 	radio_mute();
-	timeout_id = gtk_timeout_add(1000/SCAN_SPEED, (GtkFunction)scan_freq, (gpointer)(-1));	
+	timeout_id = g_timeout_add(1000/SCAN_SPEED, (GSourceFunc)scan_freq, (gpointer)(-1));	
 }
 
 void preset_combo_set_item(gint i)
@@ -637,7 +670,6 @@
 
 static int start_recording(const gchar *destination, const char* station, const char* time)
 {
-	GtkWidget *dialog;
 	Recording* recording;
 	char *filename;
 	
@@ -666,7 +698,7 @@
 	tray_icon_items_set_sensible(FALSE);
 	
 	recording->station = g_strdup(station);
-	dialog = record_status_window(recording);
+	record_status_window(recording);
 	
 	run_status_window(recording);
 
@@ -675,7 +707,6 @@
 
 void rec_button_clicked_cb(GtkButton *button, gpointer app)
 {
-	GtkWidget *dialog;
 	char *station;
 	char time_str[100];
 	time_t t;
@@ -721,18 +752,20 @@
 	/*gtk_adjustment_set_value(volume, vol);*/
 }	
 
+/*
 static void mute_button_toggled_cb(GtkButton *button, gpointer data)
 {
 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(mute_button)))
-	{		
-		gtk_tooltips_set_tip(tooltips, mute_button, _("Unmute"), NULL);
+	{	
+		gtk_widget_set_tooltip_text(mute_button, _("Unmute"));	
 	}
 	else
 	{
-		gtk_tooltips_set_tip(tooltips, mute_button, _("Mute"), NULL);
+		gtk_widget_set_tooltip_text(mute_button, _("Mute"));
 	}
 	toggle_volume();
 }
+*/
 
 static void about_button_clicked_cb(GtkButton *button, gpointer data)
 {
@@ -763,14 +796,22 @@
 							"This version has been compiled without LIRC support.");
 #endif
 	
-	about = gnome_about_new ("Gnomeradio", VERSION, "Copyright 2001 - 2006 Jörgen Scheibengruber",
+	gtk_show_about_dialog(NULL,
+				"program-name", "Gnomeradio",
+				"version", VERSION,
+				"copyright", "Copyright 2001 - 2006 Jörgen Scheibengruber",
+				"comments", text,
+				"authors", (const char **) authors,
+				"translator-credits", strcmp("TRANSLATORS", translators) ? translators : NULL,
+				"logo", app_icon, NULL);
+	/* about = gnome_about_new ("Gnomeradio", VERSION, "Copyright 2001 - 2006 Jörgen Scheibengruber",
 							text, (const char **) authors, NULL, 
 							strcmp("TRANSLATORS", translators) ? translators : NULL, 
 							app_icon);
 
 	gtk_widget_show(about);
 	g_object_add_weak_pointer(G_OBJECT(about), (gpointer)&about);
-	g_object_add_weak_pointer(G_OBJECT(about), (gpointer)&app_icon);
+	g_object_add_weak_pointer(G_OBJECT(about), (gpointer)&app_icon); */
 }
 
 static gint delete_event_cb(GtkWidget* window, GdkEventAny* e, gpointer data)
@@ -783,7 +824,14 @@
 {
 	GError *error = NULL;
 
-	gnome_help_display(PACKAGE, topic, &error);
+	char *uri;
+
+	if (topic)
+		uri = g_strdup_printf("ghelp:gnomeradio?%s", topic);
+	else
+		uri = "ghelp:gnomeradio";
+
+	gtk_show_uri (NULL, uri, GDK_CURRENT_TIME, &error);
 	if (error)
 	{
 		GtkWidget *dialog;
@@ -815,20 +863,20 @@
 GtkWidget* gnome_radio_gui(void)
 {
 	GtkWidget *app;
-	GdkWindow *app_window;
 	GtkWidget *prefs_button, *quit_button, *scfw_button, *scbw_button;
 	GtkWidget *stfw_button, *stbw_button, *about_button, *rec_button;
 	GtkWidget *prefs_pixmap, *quit_pixmap, *scfw_pixmap, *scbw_pixmap;
 	GtkWidget *stfw_pixmap, *stbw_pixmap, *about_pixmap;
-	GtkWidget *vol_up_pixmap, *vol_down_pixmap, *freq_up_pixmap, *freq_down_pixmap;
-	GdkPixbuf *vol_up_pixbuf, *vol_down_pixbuf, *freq_up_pixbuf, *freq_down_pixbuf;
+	GtkWidget *freq_up_pixmap, *freq_down_pixmap;
+	GdkPixbuf *freq_up_pixbuf, *freq_down_pixbuf;
 	GtkWidget *hbox1, *hbox2, *vbox, *menubox, *freq_vol_box;
-	GtkWidget *vseparator1, *vseparator2, *vseparator4;
+	GtkWidget *vseparator1, *vseparator4;
 	GtkWidget *label;
 	GtkWidget *frame;
 	gchar *text;
 	
-	app = gnome_app_new(PACKAGE, _("Gnomeradio"));
+	app = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+	/* app = gnome_app_new(PACKAGE, _("Gnomeradio")); */
 
 	gtk_window_set_resizable(GTK_WINDOW(app), FALSE);
 	/*gtk_window_set_policy(GTK_WINDOW(app), FALSE, FALSE, FALSE);*/
@@ -880,8 +928,8 @@
 	adj = GTK_ADJUSTMENT(gtk_adjustment_new(SUNSHINE*STEPS, FREQ_MIN*STEPS, FREQ_MAX*STEPS+1, 1, STEPS, 1));
 /*	volume = GTK_ADJUSTMENT(gtk_adjustment_new(100, 0, 101, 1, 10, 1)); */
 	
-	preset_combo = gtk_combo_box_new_text();
-	g_signal_connect(GTK_OBJECT(preset_combo), "changed", GTK_SIGNAL_FUNC(preset_combo_change_cb), NULL);
+	preset_combo = gtk_combo_box_text_new();
+	g_signal_connect(G_OBJECT(preset_combo), "changed", G_CALLBACK(preset_combo_change_cb), NULL);
 	
 	gtk_widget_set_size_request(preset_combo, 10, -1);
 	label = gtk_label_new(_("Presets:"));
@@ -904,14 +952,15 @@
 	/*gtk_widget_set_size_request(freq_scale, 160, -1);*/
 
 	gtk_widget_realize(app);
-	app_window = gtk_widget_get_window(app);
+	gtk_widget_get_window(app);
 	drawing_area = gtk_drawing_area_new();
-	digits = gdk_pixmap_create_from_xpm_d (app_window, NULL, NULL, digits_xpm);
-	signal_s = gdk_pixmap_create_from_xpm_d (app_window, NULL, NULL, signal_xpm);
-	stereo = gdk_pixmap_create_from_xpm_d (app_window, NULL, NULL, stereo_xpm);
+	
+	digits = gdk_pixbuf_new_from_xpm_data((const char**)digits_xpm);
+	signal_s = gdk_pixbuf_new_from_xpm_data((const char**)signal_xpm);
+	stereo = gdk_pixbuf_new_from_xpm_data((const char**)stereo_xpm);
 	
 	vseparator1 = gtk_vseparator_new();
-	vseparator2 = gtk_vseparator_new();
+	/*vseparator2 = gtk_vseparator_new();*/
 	/*vseparator3 = gtk_vseparator_new();*/
 	vseparator4 = gtk_vseparator_new();
 	
@@ -963,52 +1012,52 @@
 	gtk_container_set_border_width(GTK_CONTAINER(vbox), 3);
 	gtk_container_set_border_width(GTK_CONTAINER(frame), 2);
 
-	gnome_app_set_contents(GNOME_APP(app), vbox);
+	/* gnome_app_set_contents(GNOME_APP(app), vbox); */
 
 	/*status = gnome_appbar_new(FALSE, TRUE, GNOME_PREFERENCES_NEVER);*/
 
 	/*gnome_app_set_statusbar(GNOME_APP(app), status);*/
 
-	tooltips = gtk_tooltips_new();
-
-	g_signal_connect(GTK_OBJECT(app), "delete_event", GTK_SIGNAL_FUNC(delete_event_cb), NULL);
-	g_signal_connect(GTK_OBJECT(quit_button), "clicked", GTK_SIGNAL_FUNC(quit_button_clicked_cb), NULL);
-	g_signal_connect(GTK_OBJECT(adj), "value-changed", GTK_SIGNAL_FUNC(adj_value_changed_cb), (gpointer) app);
-	g_signal_connect(GTK_OBJECT(mute_button), "value-changed", GTK_SIGNAL_FUNC(volume_value_changed_cb), NULL);
-	g_signal_connect(GTK_OBJECT(stfw_button), "pressed", GTK_SIGNAL_FUNC(step_button_pressed_cb), (gpointer)TRUE);
-	g_signal_connect(GTK_OBJECT(stbw_button), "pressed", GTK_SIGNAL_FUNC(step_button_pressed_cb), (gpointer)FALSE);
-	g_signal_connect(GTK_OBJECT(stfw_button), "clicked", GTK_SIGNAL_FUNC(step_button_clicked_cb), (gpointer)TRUE);
-	g_signal_connect(GTK_OBJECT(stbw_button), "clicked", GTK_SIGNAL_FUNC(step_button_clicked_cb), (gpointer)FALSE);
-	g_signal_connect(GTK_OBJECT(stfw_button), "released", GTK_SIGNAL_FUNC(step_button_released_cb), NULL);
-	g_signal_connect(GTK_OBJECT(stbw_button), "released", GTK_SIGNAL_FUNC(step_button_released_cb), NULL);
-	g_signal_connect(GTK_OBJECT(scfw_button), "clicked", GTK_SIGNAL_FUNC(scfw_button_clicked_cb), NULL);
-	g_signal_connect(GTK_OBJECT(scbw_button), "clicked", GTK_SIGNAL_FUNC(scbw_button_clicked_cb), NULL);
-	g_signal_connect(GTK_OBJECT(about_button), "clicked", GTK_SIGNAL_FUNC(about_button_clicked_cb), NULL);
-	g_signal_connect(GTK_OBJECT(rec_button), "clicked", GTK_SIGNAL_FUNC(rec_button_clicked_cb), (gpointer) app);
-	g_signal_connect(GTK_OBJECT(prefs_button), "clicked", GTK_SIGNAL_FUNC(prefs_button_clicked_cb), (gpointer) app);
-	g_signal_connect(GTK_OBJECT(drawing_area), "expose-event", GTK_SIGNAL_FUNC(expose_event_cb), NULL);
-
-	gtk_tooltips_set_tip(tooltips, scbw_button, _("Scan Backwards"), NULL);
-	gtk_tooltips_set_tip(tooltips, scfw_button, _("Scan Forwards"), NULL);
-	gtk_tooltips_set_tip(tooltips, stbw_button, _("0.05 MHz Backwards"), NULL);
-	gtk_tooltips_set_tip(tooltips, stfw_button, _("0.05 MHz Forwards"), NULL);
-	gtk_tooltips_set_tip(tooltips, about_button, _("About Gnomeradio"), NULL);
-	gtk_tooltips_set_tip(tooltips, rec_button, _("Record radio as Wave, OGG or MP3"), NULL);
-	gtk_tooltips_set_tip(tooltips, prefs_button, _("Edit your Preferences"), NULL);
-	gtk_tooltips_set_tip(tooltips, mute_button, _("Adjust the Volume"), NULL);
-	gtk_tooltips_set_tip(tooltips, quit_button, _("Quit"), NULL);
+	g_signal_connect(G_OBJECT(app), "delete_event", G_CALLBACK(delete_event_cb), NULL);
+	g_signal_connect(G_OBJECT(quit_button), "clicked", G_CALLBACK(quit_button_clicked_cb), NULL);
+	g_signal_connect(G_OBJECT(adj), "value-changed", G_CALLBACK(adj_value_changed_cb), (gpointer) app);
+	g_signal_connect(G_OBJECT(mute_button), "value-changed", G_CALLBACK(volume_value_changed_cb), NULL);
+	g_signal_connect(G_OBJECT(stfw_button), "pressed", G_CALLBACK(step_button_pressed_cb), (gpointer)TRUE);
+	g_signal_connect(G_OBJECT(stbw_button), "pressed", G_CALLBACK(step_button_pressed_cb), (gpointer)FALSE);
+	g_signal_connect(G_OBJECT(stfw_button), "clicked", G_CALLBACK(step_button_clicked_cb), (gpointer)TRUE);
+	g_signal_connect(G_OBJECT(stbw_button), "clicked", G_CALLBACK(step_button_clicked_cb), (gpointer)FALSE);
+	g_signal_connect(G_OBJECT(stfw_button), "released", G_CALLBACK(step_button_released_cb), NULL);
+	g_signal_connect(G_OBJECT(stbw_button), "released", G_CALLBACK(step_button_released_cb), NULL);
+	g_signal_connect(G_OBJECT(scfw_button), "clicked", G_CALLBACK(scfw_button_clicked_cb), NULL);
+	g_signal_connect(G_OBJECT(scbw_button), "clicked", G_CALLBACK(scbw_button_clicked_cb), NULL);
+	g_signal_connect(G_OBJECT(about_button), "clicked", G_CALLBACK(about_button_clicked_cb), NULL);
+	g_signal_connect(G_OBJECT(rec_button), "clicked", G_CALLBACK(rec_button_clicked_cb), (gpointer) app);
+	g_signal_connect(G_OBJECT(prefs_button), "clicked", G_CALLBACK(prefs_button_clicked_cb), (gpointer) app);
+	g_signal_connect(G_OBJECT(drawing_area), "expose-event", G_CALLBACK(expose_event_cb), NULL);
+
+	gtk_widget_set_tooltip_text(scbw_button, _("Scan Backwards"));
+	gtk_widget_set_tooltip_text(scfw_button, _("Scan Forwards"));
+	gtk_widget_set_tooltip_text(stbw_button, _("0.05 MHz Backwards"));
+	gtk_widget_set_tooltip_text(stfw_button, _("0.05 MHz Forwards"));
+	gtk_widget_set_tooltip_text(about_button, _("About Gnomeradio"));
+	gtk_widget_set_tooltip_text(rec_button, _("Record radio as Wave, OGG or MP3"));
+	gtk_widget_set_tooltip_text(prefs_button, _("Edit your Preferences"));
+	gtk_widget_set_tooltip_text(mute_button, _("Adjust the Volume"));
+	gtk_widget_set_tooltip_text(quit_button, _("Quit"));
 	text = g_strdup_printf(_("Frequency: %.2f MHz"), gtk_adjustment_get_value(adj)/STEPS);
-	gtk_tooltips_set_tip(tooltips, freq_scale, text, NULL);
+	gtk_widget_set_tooltip_text(freq_scale, text);
 	g_free(text);
 /*	text = g_strdup_printf(_("Volume: %d%%"), (gint)volume->value);
-	gtk_tooltips_set_tip(tooltips, vol_scale, text, NULL);
+	gtk_widget_set_tooltip_text(vol_scale, text);
 	g_free(text);*/
-	
+
+	gtk_widget_show_all (vbox);
+
 	return app;
 }
 
 static void
-session_die_cb(GnomeClient* client, gpointer client_data)
+session_die_cb(void)
 {
 	if (settings.mute_on_exit)
 	{
@@ -1020,13 +1069,15 @@
 	exit (0);
 }
 
+/*
 static void 
-save_session_cb(GnomeClient *client, gint phase, GnomeSaveStyle save_style,
+save_session_cb(gint phase, GnomeSaveStyle save_style,
 						gint is_shutdown, GnomeInteractStyle interact_style,
 						gint is_fast, gpointer client_data)
 {
 	save_settings();
 }
+*/
 
 static void
 gconf_error_handler(GConfClient *client, GError *error)
@@ -1041,36 +1092,36 @@
 	
 	switch (event->keyval)
 	{
-		case GDK_F1: display_help_cb(NULL);
+		case GDK_KEY_F1: display_help_cb(NULL);
 				break;
-		case GDK_m: 
+		case GDK_KEY_m: 
 				toggle_volume();
 				break;
-		case GDK_q: 
+		case GDK_KEY_q: 
 				exit_gnome_radio();
 				break;
-		case GDK_r: 
+		case GDK_KEY_r: 
 				rec_button_clicked_cb(NULL, app);
 				break;
-		case GDK_f: 
+		case GDK_KEY_f: 
 				scfw_button_clicked_cb(NULL, NULL);
 				break;
-		case GDK_b: 
+		case GDK_KEY_b: 
 				scbw_button_clicked_cb(NULL, NULL);
 				break;
-		case GDK_n: 
+		case GDK_KEY_n: 
 				change_preset(TRUE);
 				break;
-		case GDK_p: 
+		case GDK_KEY_p: 
 				change_preset(FALSE);
 				break;
-		case GDK_KP_Add:
-		case GDK_plus:	
+		case GDK_KEY_KP_Add:
+		case GDK_KEY_plus:	
 				bacon_volume_button_set_value(BACON_VOLUME_BUTTON(mute_button), vol > 95 ? 100 : vol + 5);
 				/*gtk_adjustment_set_value(volume, (volume->value > 95) ? 100 : volume->value+5);*/
 				break;
-		case GDK_minus:
-		case GDK_KP_Subtract: 
+		case GDK_KEY_minus:
+		case GDK_KEY_KP_Subtract: 
 				bacon_volume_button_set_value(BACON_VOLUME_BUTTON(mute_button), vol < 5 ? 0 : vol - 5);
 				/*gtk_adjustment_set_value(volume,(volume->value < 5) ? 0 : volume->value-5);*/
 				break;
@@ -1082,38 +1133,27 @@
 {
 	GtkWidget* app;
 	GList *ptr;
-	GnomeClient *client;
+	DBusGProxy *proxy;
 	GError *err = NULL;
-	int redraw_timeout_id;
 	gboolean do_scan = FALSE;
-#if GNOME_14 
 	GOptionContext *ctx;
 	const GOptionEntry entries[] = {
 		{ "scan", 0, 0, G_OPTION_ARG_NONE, &do_scan, N_("Scan for stations"), NULL },
 		{ NULL }
 	};
-#endif	
 	bindtextdomain(PACKAGE, GNOMELOCALEDIR);  
 	bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
 	textdomain(PACKAGE);
 
 	g_set_application_name(_("Gnomeradio"));
 	
-#if GNOME_14
     if (!g_thread_supported ()) g_thread_init(NULL);
 	ctx = g_option_context_new("- Gnomeradio");
 	g_option_context_add_main_entries(ctx, entries, GETTEXT_PACKAGE);  
 	g_option_context_add_group(ctx, gst_init_get_option_group());
 	g_option_context_set_ignore_unknown_options(ctx, TRUE);	
-#endif	
 
-	gnome_program_init(PACKAGE, VERSION, 
-					LIBGNOMEUI_MODULE, argc, argv, 
-					GNOME_PROGRAM_STANDARD_PROPERTIES,
-#if GNOME_14
-					GNOME_PARAM_GOPTION_CONTEXT, ctx,
-#endif
-					NULL);
+	gtk_init(&argc, &argv);
 	gtk_window_set_default_icon_name("gnomeradio");
 	/* Main app */
 	main_visible = FALSE;
@@ -1149,10 +1189,10 @@
 	}
 	create_tray_menu(app);
 	
-	gtk_combo_box_append_text(GTK_COMBO_BOX(preset_combo), _("manual"));
+	gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(preset_combo), _("manual"));
 	for (ptr = settings.presets; ptr; ptr = g_list_next(ptr)) {
 		preset *ps = (preset*)ptr->data;
-		gtk_combo_box_append_text(GTK_COMBO_BOX(preset_combo), ps->title);
+		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(preset_combo), ps->title);
 	}
 	preset_combo_set_item(mom_ps);
 
@@ -1182,24 +1222,21 @@
 	
 /* Connect the Session Management signals
  */
-	client = gnome_master_client();
-	g_signal_connect(GTK_OBJECT(client), "save_yourself",
-						GTK_SIGNAL_FUNC(save_session_cb), NULL);
-	g_signal_connect(GTK_OBJECT(client), "die",
-						GTK_SIGNAL_FUNC(session_die_cb), NULL);
-	g_signal_connect(GTK_OBJECT(app), "key-press-event",
-						GTK_SIGNAL_FUNC(key_press_event_cb), NULL);
+
+	proxy = connect_to_session ();
+	g_signal_connect(G_OBJECT(app), "key-press-event",
+						G_CALLBACK(key_press_event_cb), NULL);
 
 	/* Redraw the status window every 3 seconds
 	 * Necessary, because the mono/stereo reception
 	 * needs some time to be correctly detected
 	 */
-	redraw_timeout_id = gtk_timeout_add(3000, (GtkFunction)redraw_status_window, NULL);	
+	g_timeout_add(3000, (GSourceFunc)redraw_status_window, NULL);	
 
 	/* Checks if the volume has been changed by an 
 	 * external app
 	 */
-	/*gtk_timeout_add(100, (GtkFunction)poll_volume_change, NULL);*/
+	/*gtk_timeout_add(100, (GSourceFunc)poll_volume_change, NULL);*/
 
 	gtk_main();
 		
@@ -1207,9 +1244,50 @@
 	my_lirc_deinit();
 #endif
 
+	if (proxy) {
+		DBusGConnection *conn;
+		conn = (DBusGConnection *)g_object_get_data (G_OBJECT (proxy), "connection");
+		if (conn)
+			dbus_g_connection_unref (conn);
+
+		g_object_unref (proxy);
+	}
+
 	return 0;
 }
 
+static DBusGProxy * connect_to_session (void) 
+{
+	DBusGConnection *connection;
+	DBusGProxy      *proxy;
+	GError          *error = NULL;
+
+	connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+
+	if (error) {
+		g_warning ("%s", error->message);
+		g_error_free(error);
+		return NULL;
+	}
+	/* Get the current session object */
+	proxy = dbus_g_proxy_new_for_name (connection,
+					"org.gnome.SessionManager",
+					"/org/gnome/SessionManager",
+					"org.gnome.SessionManager");
+
+	if (!proxy) {
+		g_warning ("Unable to get the SessionManager.");
+		dbus_g_connection_unref (connection);
+		return NULL;
+	}
+
+	dbus_g_proxy_add_signal (proxy, "SessionOver", G_TYPE_INVALID, G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (proxy, "SessionOver", G_CALLBACK (session_die_cb), NULL, NULL);
+
+	g_object_set_data (G_OBJECT (proxy), "connection", connection);
+	return proxy;
+}
+
 static void show_message(GtkMessageType type, const char* text, const char* details)
 {
 	GtkWidget *dialog;
Index: b/src/lirc.c
===================================================================
--- a/src/lirc.c	2012-12-03 10:14:49.950899955 +0000
+++ b/src/lirc.c	2012-12-03 10:14:53.722899843 +0000
@@ -20,7 +20,8 @@
 
 #include <string.h>
 #include <fcntl.h>
-#include <gnome.h>
+#include <stdlib.h>
+#include <gtk/gtk.h>
 
 #ifdef HAVE_LIRC
 
@@ -34,7 +35,6 @@
 
 extern GtkWidget* mute_button, *preset_combo;
 extern GtkAdjustment *adj;
-extern GtkTooltips *tooltips;
 
 extern int mom_ps;
 extern gnomeradio_settings settings;
@@ -71,8 +71,12 @@
 	}
 	else if (strcasecmp (cmd, "tv") == 0)
 	{
+		gchar **argv;
 		exit_gnome_radio();
-		gnome_execute_shell(NULL, "xawtv"); 
+		g_shell_parse_argv ("xawtv", NULL, &argv, NULL);
+		g_spawn_async (NULL, argv, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, NULL, NULL);
+		g_strfreev (argv);
+		/* gnome_execute_shell(NULL, "xawtv"); */
 	}
 	else if (strcasecmp (cmd, "quit") == 0)
 	{
Index: b/src/prefs.c
===================================================================
--- a/src/prefs.c	2012-12-03 10:14:53.478899850 +0000
+++ b/src/prefs.c	2012-12-03 10:14:53.722899843 +0000
@@ -15,6 +15,7 @@
  */
 
 #include <gconf/gconf-client.h>
+#include <glib/gi18n.h>
 #include <libgnome-media-profiles/audio-profile-choose.h>
 #include <string.h>
 #include "config.h"
@@ -25,7 +26,6 @@
 
 extern GtkWidget* mute_button, *preset_combo;
 extern GtkAdjustment *adj;
-extern GtkTooltips *tooltips;
 
 extern int mom_ps;
 extern gnomeradio_settings settings;
@@ -313,7 +313,7 @@
 	gtk_adjustment_set_value(v_scb, gtk_adjustment_get_upper(v_scb));
 	
 	if (main_visible) {
-		gtk_combo_box_append_text(GTK_COMBO_BOX(preset_combo), ps->title);
+		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(preset_combo), ps->title);
 		mom_ps = g_list_length(settings.presets) - 1;
 		preset_combo_set_item(mom_ps);
 
@@ -361,7 +361,7 @@
 	gtk_list_store_remove(list_store, &iter);
 
 	if (main_visible) {
-		gtk_combo_box_remove_text(GTK_COMBO_BOX(preset_combo), *row + 1);
+		gtk_combo_box_text_remove(GTK_COMBO_BOX_TEXT(preset_combo), *row + 1);
 		if (--mom_ps < 0) mom_ps = 0;
 		if (!g_list_length(settings.presets)) mom_ps = -1;
 		preset_combo_set_item(mom_ps);
@@ -398,9 +398,9 @@
 
 static gboolean list_view_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer user_data)
 {
-	if (event->keyval == GDK_Delete)
+	if (event->keyval == GDK_KEY_Delete)
 		del_button_clicked_cb(widget, user_data);
-	if (event->keyval == GDK_Insert)
+	if (event->keyval == GDK_KEY_Insert)
 		add_button_clicked_cb(widget, user_data);
 	
 	return FALSE;
@@ -427,8 +427,8 @@
 	ps->title = g_strdup(new_val);
 
 	if (main_visible) {
-		gtk_combo_box_remove_text(GTK_COMBO_BOX(preset_combo), *row + 1);
-		gtk_combo_box_insert_text(GTK_COMBO_BOX(preset_combo), *row + 1, ps->title);
+		gtk_combo_box_text_remove(GTK_COMBO_BOX_TEXT(preset_combo), *row + 1);
+		gtk_combo_box_text_insert_text(GTK_COMBO_BOX_TEXT(preset_combo), *row + 1, ps->title);
 		mom_ps = *row;
 		preset_combo_set_item(mom_ps);
 
@@ -536,7 +536,7 @@
 	preset* ps;
 	
 	dialog = gtk_dialog_new_with_buttons(_("Gnomeradio Settings"), GTK_WINDOW(app), 
-			GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_NO_SEPARATOR,
+			GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
 			GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE, 
 			GTK_STOCK_HELP, GTK_RESPONSE_HELP,
 			NULL);
@@ -599,11 +599,11 @@
 	mixer_label = gtk_label_new(_("Mixer Source:"));
 	gtk_misc_set_alignment(GTK_MISC(mixer_label), 0.0f, 0.5f);
 	mixer_eb = gtk_event_box_new();
-	mixer_combo = gtk_combo_box_new_text();
+	mixer_combo = gtk_combo_box_text_new();
 	gtk_container_add(GTK_CONTAINER(mixer_eb), mixer_combo);
 	ptr = mixer_devs = get_mixer_recdev_list();
 	for (i = 0, active = 0; ptr; ptr = g_list_next(ptr)) {
-		gtk_combo_box_append_text(GTK_COMBO_BOX(mixer_combo), ptr->data);
+		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(mixer_combo), ptr->data);
 		if (g_str_equal(ptr->data, settings.mixer)) active = i;
 		++i;
 	}
@@ -618,15 +618,15 @@
 
 	gtk_table_attach_defaults(GTK_TABLE(settings_table), mute_on_exit_cb, 0, 2, 2, 3);
 
-	g_signal_connect(GTK_OBJECT(device_entry), "hide", GTK_SIGNAL_FUNC(device_entry_activate_cb), app);
-	g_signal_connect(GTK_OBJECT(device_entry), "activate", GTK_SIGNAL_FUNC(device_entry_activate_cb), NULL);
-	g_signal_connect(GTK_OBJECT(mixer_combo), "changed", GTK_SIGNAL_FUNC(mixer_combo_change_cb), app);
-	g_signal_connect(GTK_OBJECT(mute_on_exit_cb), "toggled", GTK_SIGNAL_FUNC(mute_on_exit_toggled_cb), NULL);
-
-	gtk_tooltips_set_tip(tooltips, device_entry, _("Specify the radio-device (in most cases /dev/radio)"), NULL);
-	gtk_tooltips_set_tip(tooltips, mixer_eb, 
-	_("Choose the mixer source (line, line1, etc.) that is able to control the volume of your radio"), NULL);
-	gtk_tooltips_set_tip(tooltips, mute_on_exit_cb, _("If unchecked, gnomeradio won't mute after exiting"), NULL);
+	g_signal_connect(G_OBJECT(device_entry), "hide", G_CALLBACK(device_entry_activate_cb), app);
+	g_signal_connect(G_OBJECT(device_entry), "activate", G_CALLBACK(device_entry_activate_cb), NULL);
+	g_signal_connect(G_OBJECT(mixer_combo), "changed", G_CALLBACK(mixer_combo_change_cb), app);
+	g_signal_connect(G_OBJECT(mute_on_exit_cb), "toggled", G_CALLBACK(mute_on_exit_toggled_cb), NULL);
+
+	gtk_widget_set_tooltip_text(device_entry, _("Specify the radio-device (in most cases /dev/radio)"));
+	gtk_widget_set_tooltip_text(mixer_eb, 
+	_("Choose the mixer source (line, line1, etc.) that is able to control the volume of your radio"));
+	gtk_widget_set_tooltip_text(mute_on_exit_cb, _("If unchecked, gnomeradio won't mute after exiting"));
 
 	
 	/* The presets part */
@@ -653,20 +653,20 @@
 	gtk_tree_selection_set_select_function(selection, (GtkTreeSelectionFunc)list_view_select_cb, NULL, NULL);*/
 	
 	cellrenderer = gtk_cell_renderer_text_new();
-	g_object_set(GTK_OBJECT(cellrenderer), "mode", GTK_CELL_RENDERER_MODE_EDITABLE, NULL);
-	g_object_set(GTK_OBJECT(GTK_CELL_RENDERER_TEXT(cellrenderer)), "editable", TRUE, NULL);
+	g_object_set(G_OBJECT(cellrenderer), "mode", GTK_CELL_RENDERER_MODE_EDITABLE, NULL);
+	g_object_set(G_OBJECT(GTK_CELL_RENDERER_TEXT(cellrenderer)), "editable", TRUE, NULL);
 	list_column = gtk_tree_view_column_new_with_attributes(NULL, cellrenderer, "text", 0, NULL);
 	gtk_tree_view_column_set_min_width(list_column, 150);
 	gtk_tree_view_append_column(GTK_TREE_VIEW(list_view), list_column);
-	g_signal_connect(GTK_OBJECT(cellrenderer), "edited", GTK_SIGNAL_FUNC(name_cell_edited_cb), NULL);
+	g_signal_connect(G_OBJECT(cellrenderer), "edited", G_CALLBACK(name_cell_edited_cb), NULL);
 
 	cellrenderer = gtk_cell_renderer_text_new();
-	g_object_set(GTK_OBJECT(cellrenderer), "mode", GTK_CELL_RENDERER_MODE_EDITABLE, NULL);
-	g_object_set(GTK_OBJECT(cellrenderer), "xalign", 1.0f, NULL);
-	g_object_set(GTK_OBJECT(GTK_CELL_RENDERER_TEXT(cellrenderer)), "editable", TRUE, NULL);
+	g_object_set(G_OBJECT(cellrenderer), "mode", GTK_CELL_RENDERER_MODE_EDITABLE, NULL);
+	g_object_set(G_OBJECT(cellrenderer), "xalign", 1.0f, NULL);
+	g_object_set(G_OBJECT(GTK_CELL_RENDERER_TEXT(cellrenderer)), "editable", TRUE, NULL);
 	list_column = gtk_tree_view_column_new_with_attributes(NULL, cellrenderer, "text", 1, NULL);
 	gtk_tree_view_append_column(GTK_TREE_VIEW(list_view), list_column);
-	g_signal_connect(GTK_OBJECT(cellrenderer), "edited", GTK_SIGNAL_FUNC(freq_cell_edited_cb), NULL);
+	g_signal_connect(G_OBJECT(cellrenderer), "edited", G_CALLBACK(freq_cell_edited_cb), NULL);
 
 	button_box = gtk_hbox_new(FALSE, 12);
 
@@ -689,13 +689,13 @@
 		g_free(buffer);
 	}
 
-	g_signal_connect(GTK_OBJECT(add_button), "clicked", GTK_SIGNAL_FUNC(add_button_clicked_cb), NULL);
-	g_signal_connect(GTK_OBJECT(del_button), "clicked", GTK_SIGNAL_FUNC(del_button_clicked_cb), NULL);
-	g_signal_connect(GTK_OBJECT(list_view), "key-press-event", GTK_SIGNAL_FUNC(list_view_key_press_event_cb), NULL);
-	g_signal_connect(GTK_OBJECT(list_view), "cursor-changed", GTK_SIGNAL_FUNC(list_view_cursor_changed_cb), NULL);
+	g_signal_connect(G_OBJECT(add_button), "clicked", G_CALLBACK(add_button_clicked_cb), NULL);
+	g_signal_connect(G_OBJECT(del_button), "clicked", G_CALLBACK(del_button_clicked_cb), NULL);
+	g_signal_connect(G_OBJECT(list_view), "key-press-event", G_CALLBACK(list_view_key_press_event_cb), NULL);
+	g_signal_connect(G_OBJECT(list_view), "cursor-changed", G_CALLBACK(list_view_cursor_changed_cb), NULL);
 
-	gtk_tooltips_set_tip(tooltips, add_button, _("Add a new preset"), NULL);
-	gtk_tooltips_set_tip(tooltips, del_button, _("Remove preset from List"), NULL);
+	gtk_widget_set_tooltip_text(add_button, _("Add a new preset"));
+	gtk_widget_set_tooltip_text(del_button, _("Remove preset from List"));
 
 
 	/* The record settings part */
@@ -723,10 +723,10 @@
 	gtk_table_attach_defaults(GTK_TABLE(record_table), destination_button, 1, 2, 0, 1);
 	gtk_table_attach_defaults(GTK_TABLE(record_table), profile_eb, 0, 2, 1, 2);
 
-	g_signal_connect(GTK_OBJECT(destination_button), "clicked", GTK_SIGNAL_FUNC(destination_button_clicked_cb), NULL);
-	g_signal_connect(GTK_OBJECT(profile_combo), "changed", GTK_SIGNAL_FUNC(profile_combo_change_cb), NULL);
+	g_signal_connect(G_OBJECT(destination_button), "clicked", G_CALLBACK(destination_button_clicked_cb), NULL);
+	g_signal_connect(G_OBJECT(profile_combo), "changed", G_CALLBACK(profile_combo_change_cb), NULL);
 
-	gtk_tooltips_set_tip(tooltips, profile_eb, _("Choose the Media Profile that should be used to record."), NULL);
+	gtk_widget_set_tooltip_text(profile_eb, _("Choose the Media Profile that should be used to record."));
 	
 	gtk_box_pack_start(GTK_BOX(rbox), record_table, TRUE, TRUE, 0);
 
Index: b/src/prefs.h
===================================================================
--- a/src/prefs.h	2012-12-03 10:14:49.950899955 +0000
+++ b/src/prefs.h	2012-12-03 10:14:53.722899843 +0000
@@ -18,7 +18,6 @@
 #define _PREFS_H
 
 #include <math.h>
-#include <gnome.h>
 
 gboolean save_settings(void);
 gboolean load_settings(void);
Index: b/src/record.c
===================================================================
--- a/src/record.c	2012-12-03 10:14:53.478899850 +0000
+++ b/src/record.c	2012-12-03 10:14:53.722899843 +0000
@@ -24,7 +24,8 @@
 
 #include <sys/types.h>
 #include <signal.h>
-#include <gnome.h>
+#include <gtk/gtk.h>
+#include <glib/gi18n.h>
 #include "gui.h"
 #include "tech.h"
 #include "rec_tech.h"
@@ -38,7 +39,7 @@
 {
 	if (timeout_id >= 0)
 	{
-		gtk_timeout_remove(timeout_id);
+		g_source_remove(timeout_id);
 		timeout_id = -1;
 	}
 
@@ -80,7 +81,7 @@
 	
 void run_status_window(Recording *recording)
 {
-	timeout_id = gtk_timeout_add(500, (GtkFunction) timeout_cb, recording);
+	timeout_id = g_timeout_add(500, (GSourceFunc) timeout_cb, recording);
 }
 
 static void button_clicked_cb(GtkButton *button, gpointer data)
@@ -169,8 +170,8 @@
 
 	gtk_container_add(GTK_CONTAINER(status_dialog), vbox);
 
-	g_signal_connect(GTK_OBJECT(status_dialog), "delete_event", GTK_SIGNAL_FUNC(delete_event_cb), recording);
-	g_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(button_clicked_cb), recording);
+	g_signal_connect(G_OBJECT(status_dialog), "delete_event", G_CALLBACK(delete_event_cb), recording);
+	g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(button_clicked_cb), recording);
 
 	gtk_window_set_modal(GTK_WINDOW(status_dialog), TRUE);
 
Index: b/src/record.h
===================================================================
--- a/src/record.h	2012-12-03 10:14:49.950899955 +0000
+++ b/src/record.h	2012-12-03 10:14:53.722899843 +0000
@@ -17,8 +17,6 @@
 #ifndef _RECORD_H
 #define _RECORD_H
 
-#include <gnome.h>
-
 void run_status_window(Recording *recording);
 
 GtkWidget* record_status_window(Recording *recording);	
Index: b/src/rec_tech.c
===================================================================
--- a/src/rec_tech.c	2012-12-03 10:14:53.266899856 +0000
+++ b/src/rec_tech.c	2012-12-03 10:14:53.722899843 +0000
@@ -16,7 +16,8 @@
 
 
 #include "rec_tech.h"
-#include <gnome.h>
+#include <gtk/gtk.h>
+#include <glib/gi18n.h>
 #include <libgnome-media-profiles/audio-profile.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -39,7 +40,7 @@
 	gst_element_set_state (pipeline, GST_STATE_NULL);
 	
 	gst_message_parse_error(message, &error, NULL);
-	show_error_message(_("GStreamer runtime error."), error->message);
+	g_warning(_("GStreamer runtime error: %s\n"), error->message);
 	g_error_free(error);
 }
 
@@ -55,15 +56,13 @@
 	
 	pipeline = gst_pipeline_new("gnomeradio-record-pipeline");
 	if (!pipeline) {
-		show_error_message(_("Could not create GStreamer pipeline."),
-		_("Check your Gstreamer installation!"));
+		g_warning(_("Could not create GStreamer pipeline. Check your Gstreamer installation!\n"));
 		goto error;
 	}		
 	
 	oss_src = gst_element_factory_make("osssrc", "oss-source");
 	if (!oss_src) {
-		show_error_message(_("Could not open Gstreamer OSS Source."),
-		_("Verify your Gstreamer OSS subsystem installation!"));
+		g_warning(_("Could not open Gstreamer OSS Source. Verify your Gstreamer OSS subsystem installation!\n"));
 		goto error;
 	}
 	
@@ -76,8 +75,7 @@
 	g_free(pipeline_str);
 	if (!encoder) {
 		char *caption = g_strdup_printf(_("Could not create encoder \"%s\"."), gm_audio_profile_get_name (profile));
-		show_error_message(caption,
-		_("Verify your Gstreamer plugins installation!"));
+		g_warning(_("%s Verify your Gstreamer plugins installation!\n"), caption);
 		g_free(caption);
 		goto error;
 	}
@@ -85,8 +83,7 @@
 	/* Write to disk */
 	filesink = gst_element_factory_make("filesink", "file-sink");
 	if (!filesink) {	
-		show_error_message(_("Could not create Gstreamer filesink."),
-		_("Check your Gstreamer installation!"));
+		g_warning(_("Could not create Gstreamer filesink. Check your Gstreamer installation!"));
 		goto error;
 	}
 	
Index: b/src/trayicon.c
===================================================================
--- a/src/trayicon.c	2012-12-03 10:14:53.478899850 +0000
+++ b/src/trayicon.c	2012-12-03 10:14:53.722899843 +0000
@@ -19,13 +19,13 @@
  */
 
 #include <config.h>
-#include <gnome.h>
+#include <glib/gi18n.h>
+#include <gtk/gtk.h>
 #include "gui.h"
 #include "trayicon.h"
 #include "tech.h"
 
 extern GtkAdjustment *adj;
-extern GtkTooltips *tooltips;
 
 extern int mom_ps;
 extern gnomeradio_settings settings;
@@ -143,6 +143,6 @@
 		G_CALLBACK(tray_popup_menu), (gpointer)app);
 	
 	text = g_strdup_printf(_("Gnomeradio - %.2f MHz"), gtk_adjustment_get_value(adj)/STEPS);
-        gtk_status_icon_set_tooltip(GTK_STATUS_ICON(tray_icon), text);
+        gtk_status_icon_set_tooltip_text(GTK_STATUS_ICON(tray_icon), text);
 	g_free(text);
 }
Index: b/configure.in
===================================================================
--- a/configure.in	2012-12-03 10:14:53.266899856 +0000
+++ b/configure.in	2012-12-03 10:14:53.722899843 +0000
@@ -23,12 +23,9 @@
 AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE, "$GETTEXT_PACKAGE", GETTEXT_PACKAGE)
 
 
-PKG_CHECK_MODULES(GNOME, libgnomeui-2.0 >= 2.12 gconf-2.0 >= 2.12 gnome-vfs-2.0 >= 2.12 libgnome-media-profiles-3.0 >= 3.0)
-PKG_CHECK_MODULES(GNOME14, libgnomeui-2.0 >= 2.14, GNOME_14="1";echo "yes", GNOME_14="0";echo "no")
+PKG_CHECK_MODULES(GNOME, dbus-glib-1 gconf-2.0 >= 2.12 gtk+-3.0 libgnome-media-profiles-3.0 >= 3.0)
 AC_SUBST(GNOME_CFLAGS)
 AC_SUBST(GNOME_LIBS)
-AC_SUBST(GNOME_14)
-AC_DEFINE_UNQUOTED(GNOME_14, ${GNOME_14}, "Is GNOME 2.14 installed")
 AC_SUBST(LIRC)
 
 PKG_CHECK_MODULES(GSTREAMER, gstreamer-0.10 gstreamer-plugins-base-0.10)
