Description: Port gnomeradio to GSettings.
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/gnomeradio/+bug/1256796
Author: POJAR GEORGE <geoubuntu@gmail.com>
Index: gnomeradio-1.8/configure.ac
===================================================================
--- gnomeradio-1.8.orig/configure.ac
+++ gnomeradio-1.8/configure.ac
@@ -24,6 +24,7 @@ AC_PROG_CPP
 AC_PROG_INSTALL
 AC_PROG_LN_S
 AC_PROG_MAKE_SET
+AM_PATH_GLIB_2_0
 
 LT_PREREQ([2.2])
 LT_INIT
@@ -43,7 +44,7 @@ PKG_CHECK_MODULES(ALSA, alsa >= 1.0.25)
 AC_SUBST(ALSA_CFLAGS)
 AC_SUBST(ALSA_LIBS)
 
-PKG_CHECK_MODULES(GNOME, dbus-glib-1 gconf-2.0 >= 2.12 gtk+-3.0)
+PKG_CHECK_MODULES(GNOME, dbus-glib-1 gtk+-3.0 libxml-2.0 glib-2.0 gio-2.0)
 AC_SUBST(GNOME_CFLAGS)
 AC_SUBST(GNOME_LIBS)
 
@@ -55,13 +56,11 @@ PKG_CHECK_MODULES(XML, libxml-2.0 >= 2.4
 AC_SUBST(XML_CFLAGS)
 AC_SUBST(XML_LIBS)
 
-AC_PATH_PROG(GCONFTOOL, gconftool-2, no)
+AC_PATH_PROG(GLIB_COMPILE_SCHEMAS, glib-compile-schemas)
+GLIB_GSETTINGS
 
-if test x"$GCONFTOOL" = xno; then
-  AC_MSG_ERROR([gconftool-2 executable not found in your path - should be installed with GConf])
-fi
-
-AM_GCONF_SOURCE_2
+GLIB_COMPILE_RESOURCES=`$PKG_CONFIG gio-2.0 --variable=glib_compile_resources`
+AC_SUBST(GLIB_COMPILE_RESOURCES)
 
 AC_SUBST(LIRC)
 LIRC=""
@@ -72,10 +71,6 @@ else
   echo "*** lirc disabled"
 fi
 
-AC_ARG_ENABLE(install_schemas,
-       [  --disable-install-schemas        Disable installation of the gconf schemas])
-AM_CONDITIONAL(INSTALL_SCHEMAS, test x$enable_install_schemas != xno)
-
 AC_CONFIG_FILES([gnomeradio.spec
                  Makefile
                  data/Makefile
Index: gnomeradio-1.8/data/org.gnome.gnomeradio.gschema.xml
===================================================================
--- /dev/null
+++ gnomeradio-1.8/data/org.gnome.gnomeradio.gschema.xml
@@ -0,0 +1,69 @@
+<schemalist>
+  <schema id="org.gnome.gnomeradio" path="/org/gnome/gnomeradio/">
+    <key name="first-time-flag" type="b">
+      <default>false</default>
+      <summary>The first time gnomeradio was run</summary>
+      <description>Set to true when the user ran the first time gnomeradio</description>
+    </key>
+    <key name="last-freq" type="d">
+      <default>100.00</default>
+      <summary>Last frequency</summary>
+      <description>The last frequency (in MHz) in use</description>
+    </key>
+    <key name="device" type="s">
+      <default>'auto'</default>
+      <summary>Radio device</summary>
+      <description>The default radio device to use (e.g. /dev/radio0)</description>
+    </key>
+    <key name="driver" type="s">
+      <default>'any'</default>
+      <summary>Device driver</summary>
+      <description>The default device driver to use (any, v4l1 or v4l2)</description>
+    </key>
+    <key name="mixer" type="s">
+      <default>'hw:0/Line'</default>
+      <summary>Mixer source</summary>
+      <description>The default mixer device and channel to use (e.g. hw:0/Line)</description>
+    </key>
+    <key name="muted" type="b">
+      <default>false</default>
+      <summary>Muted</summary>
+      <description>The muted state in last exited</description>
+    </key>
+    <key name="unmute-volume" type="d">
+      <default>-1</default>
+      <summary>Unmute volume</summary>
+      <description>The volume before muting gnomeradio session</description>
+    </key>
+    <key name="mute-on-exit" type="b">
+      <default>true</default>
+      <summary>Mute on exit</summary>
+      <description>Mute radio device on exit</description>
+    </key>
+    <key name="audio-loopback" type="b">
+      <default>true</default>
+      <summary>The audio loopback mode</summary>
+      <description>When set to true will start an audio streaming between the wireless device and the audio output device</description>
+    </key>
+    <key name="presets" type="i">
+      <default>0</default>
+      <summary>Number of presets</summary>
+      <description>The number of presets</description>
+    </key>
+    <key name="last" type="i">
+      <default>-1</default>
+      <summary>Last presets</summary>
+      <description>The preset that was enabled when gnomeradio was terminated. Range is 0 ... (presets - 1). None is -1</description>
+    </key>
+    <key name="destination" type="s">
+      <default>''</default>
+      <summary>The default location to use for the recorded files</summary>
+      <description>The path to the location where gnomeradio should store recorded files. If that value is empty, the HOME folder will be used</description>
+    </key>
+    <key name="profile" type="s">
+      <default>'audio/x-vorbis'</default>
+      <summary>The media type for encoding audio when recording</summary>
+      <description>The media type for encoding audio when recording (e.g. audio/x-vorbis for Ogg Vorbis, or audio/mpeg for MP3). This is not a MIME type.</description>
+    </key>
+  </schema>
+</schemalist>
Index: gnomeradio-1.8/data/Makefile.am
===================================================================
--- gnomeradio-1.8.orig/data/Makefile.am
+++ gnomeradio-1.8/data/Makefile.am
@@ -3,28 +3,27 @@ SUBDIRS = icons pixmaps
 applicationsdir = $(datadir)/applications/
 applications_in_files = gnomeradio.desktop.in
 applications_DATA = $(applications_in_files:.desktop.in=.desktop)
+
 @INTLTOOL_DESKTOP_RULE@
 
+all-local: $(applications_DATA)
+
 profilesdir = $(datadir)/gnomeradio
 profiles_DATA = gnomeradio.gep
 
-schemadir = @GCONF_SCHEMA_FILE_DIR@
-schema_in_files = gnomeradio.schemas.in
-schema_DATA = $(schema_in_files:.schemas.in=.schemas)
-@INTLTOOL_SCHEMAS_RULE@
+@INTLTOOL_XML_NOMERGE_RULE@
 
-all-local: $(applications_DATA)
+gsettings_SCHEMAS = org.gnome.gnomeradio.gschema.xml
+
+@GSETTINGS_RULES@
+
+EXTRA_DIST =				\
+	$(applications_DATA)		\
+	$(applications_in_files)	\
+	$(profiles_DATA)		\
+	$(gsettings_SCHEMAS)		\
+	example.lircrc
+
+CLEANFILES = $(applications_DATA)
 
-install-data-local: 
-if INSTALL_SCHEMAS
-	GCONF_CONFIG_SOURCE=$(GCONF_SCHEMA_CONFIG_SOURCE) $(GCONFTOOL) --makefile-install-rule $(srcdir)/$(schema_DATA)
-endif
-
-EXTRA_DIST = $(applications_DATA) \
-             $(applications_in_files) \
-             $(schema_DATA) \
-             $(schema_in_files) \
-             $(profiles_DATA) \
-             example.lircrc
 
-CLEANFILES = $(schema_DATA) $(applications_DATA)
Index: gnomeradio-1.8/po/POTFILES.in
===================================================================
--- gnomeradio-1.8.orig/po/POTFILES.in
+++ gnomeradio-1.8/po/POTFILES.in
@@ -1,4 +1,3 @@
-data/gnomeradio.schemas.in
 data/gnomeradio.desktop.in
 src/prefs.c
 src/gui.c
Index: gnomeradio-1.8/src/resources/gnomeradio.dtd
===================================================================
--- /dev/null
+++ gnomeradio-1.8/src/resources/gnomeradio.dtd
@@ -0,0 +1,12 @@
+<!--
+  DTD for GNOMERADIO presets.
+  by POJAR GEORGE <geoubuntu@gmail.com>
+-->
+
+<!ELEMENT gnomeradio (station)* >
+<!-- station -->
+<!ELEMENT station  EMPTY >
+	<!-- freq : ... -->
+	<!ATTLIST station freq CDATA #REQUIRED >
+	<!-- name : ... -->
+	<!ATTLIST station name CDATA #REQUIRED >
Index: gnomeradio-1.8/src/gnomeradio-dtd.gresource.xml
===================================================================
--- /dev/null
+++ gnomeradio-1.8/src/gnomeradio-dtd.gresource.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<gresources>
+  <gresource prefix="/org/gnome/gnomeradio">
+    <file>gnomeradio.dtd</file>
+  </gresource>
+</gresources>
+
+
Index: gnomeradio-1.8/src/Makefile.am
===================================================================
--- gnomeradio-1.8.orig/src/Makefile.am
+++ gnomeradio-1.8/src/Makefile.am
@@ -10,6 +10,10 @@ AM_CPPFLAGS =									\
 
 bin_PROGRAMS = gnomeradio
 
+GNOMERADIO_RESOURCES = \
+	gnomeradio-dtd-resources.c \
+	gnomeradio-dtd-resources.h
+
 gnomeradio_SOURCES =		\
 	alsa_stream.h		\
 	get_media_devices.h	\
@@ -42,6 +46,25 @@ gnomeradio_SOURCES =		\
 	trayicon.c		\
 	utils.c			\
 	v4l1.c			\
-	v4l2.c
+	v4l2.c			\
+	$(GNOMERADIO_RESOURCES)
+
+RESOURCE_FILES = \
+	resources/gnomeradio.dtd
+
+EXTRA_DIST = \
+	gnomeradio-dtd.gresource.xml \
+	$(RESOURCE_FILES)
+
+gnomeradio-dtd-resources.c: gnomeradio-dtd.gresource.xml $(RESOURCE_FILES)
+	$(AM_V_GEN)glib-compile-resources --target=$@ --sourcedir=$(srcdir)/resources --generate-source --c-name gnomeradio $(srcdir)/gnomeradio-dtd.gresource.xml
+
+gnomeradio-dtd-resources.h: gnomeradio-dtd.gresource.xml $(RESOURCE_FILES)
+	$(AM_V_GEN)glib-compile-resources --target=$@ --sourcedir=$(srcdir)/resources --generate-header --c-name gnomeradio $(srcdir)/gnomeradio-dtd.gresource.xml
+
+BUILT_SOURCES = \
+	$(GNOMERADIO_RESOURCES)
 
 gnomeradio_LDADD = $(ALSA_LIBS) $(GNOME_LIBS) $(GSTREAMER_LIBS) $(XML_LIBS) $(LIRC) -lpthread
+
+CLEANFILES = $(BUILT_SOURCES)
Index: gnomeradio-1.8/src/gui.c
===================================================================
--- gnomeradio-1.8.orig/src/gui.c
+++ gnomeradio-1.8/src/gui.c
@@ -23,7 +23,6 @@
 #include <config.h>
 #include <glib/gi18n.h>
 #include <gtk/gtk.h>
-#include <gconf/gconf-client.h>
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-bindings.h>
 #include <math.h>
@@ -101,31 +100,27 @@ static DBusGProxy      * connect_to_sess
 
 static gboolean is_first_start(void)
 {
-	GConfClient *client;
+	GSettings *gsettings;
 	gboolean first_start;
 
-	client = gconf_client_get_default();
-	if (!client)
-		return TRUE;
+	gsettings = g_settings_new ("org.gnome.gnomeradio");
 
-	first_start = gconf_client_get_bool(client, "/apps/gnomeradio/first_time_flag", NULL);
+	first_start = g_settings_get_boolean(gsettings, "first-time-flag");
 
-	g_object_unref (client);
+	g_clear_object (&gsettings);
 
 	return !first_start;
 }
 
 static void set_first_time_flag(void)
 {
-	GConfClient *client;
+	GSettings *gsettings;
 
-	client = gconf_client_get_default();
-	if (!client)
-		return;
+	gsettings = g_settings_new ("org.gnome.gnomeradio");
 
-	gconf_client_set_bool(client, "/apps/gnomeradio/first_time_flag", TRUE, NULL);
+	g_settings_set_boolean(gsettings, "first-time-flag", TRUE);
 
-	g_object_unref (client);
+	g_clear_object (&gsettings);
 }
 
 typedef struct {
@@ -1228,18 +1223,12 @@ session_die_cb(void)
 static void 
 save_session_cb(gint phase, GnomeSaveStyle save_style,
 						gint is_shutdown, GnomeInteractStyle interact_style,
-						gint is_fast, gpointer client_data)
+						gint is_fast, gpointer gsettings_data)
 {
 	save_settings();
 }
 */
 
-static void
-gconf_error_handler(GConfClient *client, GError *error)
-{
-	g_print("GConf error: %s\n", error->message);
-}
-
 gboolean
 key_press_event_cb(GtkWidget *app, GdkEventKey *event, gpointer data)
 {
@@ -1435,19 +1424,6 @@ int main(int argc, char* argv[])
 
 	rb_missing_plugins_init (GTK_WINDOW (app));
 	
-	/* Initizialize Gconf */
-	if (!gconf_init(argc, argv, &err)) {
-		char *details;
-		details = g_strdup_printf(_("%s\n\nChanges to the settings won't be saved."), err->message);
-		show_warning_message(_("Failed to init GConf!"), details);
-		g_error_free(err); 
-		g_free(details);
-		err = NULL;
-	} else {
-		gconf_client_set_global_default_error_handler((GConfClientErrorHandlerFunc)gconf_error_handler);
-		gconf_client_set_error_handling(gconf_client_get_default(),  GCONF_CLIENT_HANDLE_ALL);
-	}
-
 	load_settings();
 
 	start_radio(FALSE, app);
Index: gnomeradio-1.8/src/prefs.c
===================================================================
--- gnomeradio-1.8.orig/src/prefs.c
+++ gnomeradio-1.8/src/prefs.c
@@ -14,14 +14,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include <gconf/gconf-client.h>
 #include <glib/gi18n.h>
+#include <gio/gio.h>
 #include <gtk/gtk.h>
 #include <gst/pbutils/pbutils.h>
 #include <gst/pbutils/install-plugins.h>
 #include <libxml/xmlmemory.h>
 #include <libxml/parser.h>
 #include <string.h>
+#include <sys/stat.h>
 #include "config.h"
 #include "prefs.h"
 #include "trayicon.h"
@@ -30,6 +31,9 @@
 #include "rb_gst_media_types.h"
 #include "rb_missing_plugins.h"
 
+#define GNOMERADIO_XML_FILENAME "gnomeradio.xml"
+#define GNOMERADIO_DTD_RESOURCENAME "/org/gnome/gnomeradio/gnomeradio.dtd"
+
 extern int autodetect;
 extern int can_capture;
 extern int alsa_loopback;
@@ -58,162 +62,124 @@ static GtkWidget *remove_button;
 static GtkWidget *audio_profile_combo;
 static GtkWidget *install_button;
 
-gboolean save_settings(void)
+static gboolean save_to_file;
+static gboolean load_from_file;
+
+static void presets_save (void);
+static void presets_load (void);
+
+void save_settings (void)
 {
-	gint i, count;
-	gchar *buffer;
-	preset *ps;
-	GConfClient* client = NULL;
+	GSettings *gsettings;
+	gint count;
 	
-	if (!gconf_is_initialized())
-		return FALSE;
-
-	client = gconf_client_get_default();
-	if (!client)
-		return FALSE;
+	gsettings = g_settings_new ("org.gnome.gnomeradio");
+	g_settings_delay (gsettings);
 	
 	/* Store general settings */
 	if (autodetect)
-		gconf_client_set_string(client, "/apps/gnomeradio/device", "auto", NULL);
+		g_settings_set_string (gsettings, "device", "auto");
 	else
-		gconf_client_set_string(client, "/apps/gnomeradio/device", settings.device, NULL);
-	gconf_client_set_string(client, "/apps/gnomeradio/driver", settings.driver, NULL);
-	gconf_client_set_string(client, "/apps/gnomeradio/mixer", settings.mixer, NULL);
-	gconf_client_set_bool(client, "/apps/gnomeradio/muted", settings.muted, NULL);
-	gconf_client_set_float(client, "/apps/gnomeradio/unmute-volume", settings.unmute_volume, NULL);
-	gconf_client_set_bool(client, "/apps/gnomeradio/mute-on-exit", settings.mute_on_exit, NULL);
-	gconf_client_set_bool(client, "/apps/gnomeradio/audio-loopback", settings.audio_loopback , NULL);
-	/*gconf_client_set_float(client, "/apps/gnomeradio/volume", volume->value, NULL);*/
-	gconf_client_set_float(client, "/apps/gnomeradio/last-freq", gtk_adjustment_get_value(adj)/STEPS, NULL);
+		g_settings_set_string (gsettings, "device", settings.device);
+	g_settings_set_string (gsettings, "driver", settings.driver);
+	g_settings_set_string (gsettings, "mixer", settings.mixer);
+	g_settings_set_boolean (gsettings, "muted", settings.muted);
+	g_settings_set_double (gsettings, "unmute-volume", settings.unmute_volume);
+	g_settings_set_boolean (gsettings, "mute-on-exit", settings.mute_on_exit);
+	g_settings_set_boolean (gsettings, "audio-loopback", settings.audio_loopback);
+	/*g_settings_set_double (gsettings, "volume", volume->value);*/
+	g_settings_set_double (gsettings, "last-freq", gtk_adjustment_get_value(adj)/STEPS);
 
 	/* Store recording settings */
-/*	gconf_client_set_string(client, "/apps/gnomeradio/recording/audiodevice", rec_settings.audiodevice, NULL);
-	gconf_client_set_bool(client, "/apps/gnomeradio/recording/record-as-mp3", rec_settings.mp3, NULL);
-	gconf_client_set_string(client, "/apps/gnomeradio/recording/sample-rate", rec_settings.rate, NULL);
-	gconf_client_set_string(client, "/apps/gnomeradio/recording/sample-format", rec_settings.sample, NULL);
-	gconf_client_set_bool(client, "/apps/gnomeradio/recording/record-in-stereo", rec_settings.stereo, NULL);
-	gconf_client_set_string(client, "/apps/gnomeradio/recording/encoder", rec_settings.encoder, NULL);
-	gconf_client_set_string(client, "/apps/gnomeradio/recording/bitrate", rec_settings.bitrate, NULL);
+/*	g_settings_set_string (gsettings, "audiodevice", rec_settings.audiodevice);
+	g_settings_set_boolean (gsettings, "record-as-mp3", rec_settings.mp3);
+	g_settings_set_string (gsettings, "sample-rate", rec_settings.rate);
+	g_settings_set_string (gsettings, "sample-format", rec_settings.sample);
+	g_settings_set_boolean (gsettings, "record-in-stereo", rec_settings.stereo);
+	g_settings_set_string (gsettings, "encoder", rec_settings.encoder);
+	g_settings_set_string (gsettings, "bitrate", rec_settings.bitrate);
 */
 
-	gconf_client_set_string(client, "/apps/gnomeradio/recording/destination", rec_settings.destination, NULL);
-	gconf_client_set_string(client, "/apps/gnomeradio/recording/profile", rec_settings.profile, NULL);
+	g_settings_set_string (gsettings, "destination", rec_settings.destination);
+	g_settings_set_string (gsettings, "profile", rec_settings.profile);
 
 	/* Store the presets */
-	count = g_list_length(settings.presets);
-	gconf_client_set_int(client, "/apps/gnomeradio/presets/presets", count, NULL);
-	for (i = 0; i < count; i++)
-	{
-		ps = g_list_nth_data(settings.presets, i);
-		buffer = g_strdup_printf("/apps/gnomeradio/presets/%d/name", i);
-		gconf_client_set_string(client, buffer, ps->title, NULL); 
-		g_free(buffer);
-		buffer = g_strdup_printf("/apps/gnomeradio/presets/%d/freqency", i);
-		gconf_client_set_float(client, buffer, ps->freq, NULL); 
-		g_free(buffer);
-	}	
-	gconf_client_set_int(client, "/apps/gnomeradio/presets/last", mom_ps, NULL);
-	/*g_print("Storing Settings in GConf database\n");*/
+	presets_save ();
 
-	g_object_unref (client);
-	
-	return TRUE;
+	count = g_list_length (settings.presets);
+	g_settings_set_int (gsettings, "presets", count);
+	g_settings_set_int (gsettings, "last", mom_ps);
+
+	g_settings_apply (gsettings);
+	g_clear_object (&gsettings);
 }			
 
-gboolean load_settings(void)
+void load_settings (void)
 {
-	gint i, count;
-	gchar *buffer;
-	preset *ps;
-	GConfClient *client = NULL;
+	GSettings *gsettings;
+	gint count;
 	double freq;
 	
-	settings.presets = NULL;
-		
-	if (!gconf_is_initialized())
-		return FALSE;
-	
-	client = gconf_client_get_default();
-	if (!client)
-		return FALSE;
+	gsettings = g_settings_new ("org.gnome.gnomeradio");
+	g_settings_delay (gsettings);
 
 	/* Load general settings */
-	settings.device = gconf_client_get_string(client, "/apps/gnomeradio/device", NULL);
-	if (!settings.device)
-		settings.device = g_strdup("auto");
-	settings.driver = gconf_client_get_string(client, "/apps/gnomeradio/driver", NULL);
-	if (!settings.driver)
-		settings.driver = g_strdup("any");
-	settings.mixer = gconf_client_get_string(client, "/apps/gnomeradio/mixer", NULL);
-	if (!settings.mixer)
-		settings.mixer = g_strdup("hw:0/Line");
-	settings.muted = gconf_client_get_bool(client, "/apps/gnomeradio/muted", NULL);
-	settings.unmute_volume = gconf_client_get_float(client, "/apps/gnomeradio/unmute-volume", NULL);
-	settings.mute_on_exit = gconf_client_get_bool(client, "/apps/gnomeradio/mute-on-exit", NULL);
-	settings.audio_loopback = gconf_client_get_bool(client, "/apps/gnomeradio/audio-loopback", NULL);
-	/*volume->value = gconf_client_get_float(client, "/apps/gnomeradio/volume", NULL);*/
-	freq = gconf_client_get_float(client, "/apps/gnomeradio/last-freq", NULL);
-	if ((freq < FREQ_MIN) || (freq > FREQ_MAX))
-		gtk_adjustment_set_value(adj, FREQ_MIN * STEPS);
-	else
-		gtk_adjustment_set_value(adj, freq * STEPS);
+	settings.device = g_settings_get_string (gsettings, "device");
+	if ((settings.device == NULL) || (!strcmp (settings.device, "")))
+		settings.device = g_strdup ("auto");
+	settings.driver = g_settings_get_string (gsettings, "driver");
+	if ((settings.driver == NULL) || (!strcmp (settings.driver, "")))
+		settings.driver = g_strdup ("any");
+	settings.mixer = g_settings_get_string (gsettings, "mixer");
+	if ((settings.mixer == NULL) || (!strcmp (settings.mixer, "")))
+		settings.mixer = g_strdup ("hw:0/Line");
+	settings.muted = g_settings_get_boolean (gsettings, "muted");
+	settings.unmute_volume = g_settings_get_double (gsettings, "unmute-volume");
+	settings.mute_on_exit = g_settings_get_boolean (gsettings, "mute-on-exit");
+	settings.audio_loopback = g_settings_get_boolean (gsettings, "audio-loopback");
+	/*volume->value = g_settings_get_double (gsettings, "volume");*/
+	freq = g_settings_get_double (gsettings, "last-freq");
+	if (freq < FREQ_MIN) freq = FREQ_MIN;
+	if (freq > FREQ_MAX) freq = FREQ_MAX;
+	gtk_adjustment_set_value(adj, freq * STEPS);
 	
 	/* Load recording settings */
-/*	rec_settings.audiodevice = gconf_client_get_string(client, "/apps/gnomeradio/recording/audiodevice", NULL);
-	if (!rec_settings.audiodevice)
-		rec_settings.audiodevice = g_strdup("/dev/audio");
-	rec_settings.mp3 = gconf_client_get_bool(client, "/apps/gnomeradio/recording/record-as-mp3", NULL);
-	rec_settings.rate = gconf_client_get_string(client, "/apps/gnomeradio/recording/sample-rate", NULL);
-	if (!rec_settings.rate)
-		rec_settings.rate = g_strdup("44100");
-	rec_settings.sample = gconf_client_get_string(client, "/apps/gnomeradio/recording/sample-format", NULL);
-	if (!rec_settings.sample)
-		rec_settings.sample = g_strdup("16");
-	rec_settings.stereo = gconf_client_get_bool(client, "/apps/gnomeradio/recording/record-in-stereo", NULL);
-	rec_settings.encoder = gconf_client_get_string(client, "/apps/gnomeradio/recording/encoder", NULL);
-	if (!rec_settings.encoder)
-		rec_settings.encoder = g_strdup("oggenc");
-	rec_settings.bitrate = gconf_client_get_string(client, "/apps/gnomeradio/recording/bitrate", NULL);
-	if (!rec_settings.bitrate)
-		rec_settings.bitrate = g_strdup("192");*/
-
-	rec_settings.destination = gconf_client_get_string(client, "/apps/gnomeradio/recording/destination", NULL);
-	if (!rec_settings.destination)
-		rec_settings.destination = g_strdup(g_get_home_dir());
-	rec_settings.profile = gconf_client_get_string(client, "/apps/gnomeradio/recording/profile", NULL);
-	if (!rec_settings.profile)
-		rec_settings.profile = g_strdup("audio/x-vorbis");
+/*	rec_settings.audiodevice = g_settings_get_string (gsettings, "audiodevice");
+	if ((rec_settings.audiodevice == NULL) || (!strcmp (rec_settings.audiodevice, "")))
+		rec_settings.audiodevice = g_strdup ("/dev/audio");
+	rec_settings.mp3 = g_settings_get_boolean (gsettings, "record-as-mp3");
+	rec_settings.rate = g_settings_get_string (gsettings, "sample-rate");
+	if ((rec_settings.rate == NULL) || (!strcmp (rec_settings.rate, "")))
+		rec_settings.rate = g_strdup ("44100");
+	rec_settings.sample = g_settings_get_string (gsettings, "sample-format");
+	if ((rec_settings.sample == NULL) || (!strcmp (rec_settings.sample, "")))
+		rec_settings.sample = g_strdup ("16");
+	rec_settings.stereo = g_settings_get_boolean (gsettings, "record-in-stereo");
+	rec_settings.encoder = g_settings_get_string (gsettings, "encoder");
+	if ((rec_settings.encoder == NULL) || (!strcmp (rec_settings.encoder, "")))
+		rec_settings.encoder = g_strdup ("oggenc");
+	rec_settings.bitrate = g_settings_get_string (gsettings, "bitrate");
+	if ((rec_settings.bitrate == NULL) || (!strcmp (rec_settings.bitrate, "")))
+		rec_settings.bitrate = g_strdup ("192");*/
+
+	rec_settings.destination = g_settings_get_string (gsettings, "destination");
+	if ((rec_settings.destination == NULL) || (!strcmp (rec_settings.destination, "")))
+		rec_settings.destination = g_strdup (g_get_home_dir());
+	rec_settings.profile = g_settings_get_string (gsettings, "profile");
+	if ((rec_settings.profile == NULL) || (!strcmp (rec_settings.profile, "")))
+		rec_settings.profile = g_strdup ("audio/x-vorbis");
 	
 	/* Load the presets */
-	count = gconf_client_get_int(client, "/apps/gnomeradio/presets/presets", NULL);
-	for (i = 0; i < count; i++)
-	{
-		ps = malloc(sizeof(preset));
-		buffer = g_strdup_printf("/apps/gnomeradio/presets/%d/name", i);
-		ps->title = gconf_client_get_string(client, buffer, NULL); 
-		g_free(buffer);
-		if (!ps->title)
-			ps->title = g_strdup(_("unnamed"));
-		buffer = g_strdup_printf("/apps/gnomeradio/presets/%d/freqency", i);
-		freq = gconf_client_get_float(client, buffer, NULL); 
-		if ((freq < FREQ_MIN) || (freq > FREQ_MAX))
-			ps->freq = FREQ_MIN;
-		else
-			ps->freq = freq;
-		g_free(buffer);
-		settings.presets = g_list_prepend(settings.presets, (gpointer)ps);
-	}	
-	settings.presets = g_list_reverse(settings.presets);
+	presets_load ();
 
-	mom_ps = gconf_client_get_int(client, "/apps/gnomeradio/presets/last", NULL);
+	count = g_settings_get_int (gsettings, "presets");
+	mom_ps = g_settings_get_int (gsettings, "last");
 	if (mom_ps >= count)
 		mom_ps = -1;
 
-	g_object_unref (client);
+	g_clear_object (&gsettings);
+}
 
-	return TRUE;
-}			
-	
 static void mute_on_exit_toggled_cb(GtkWidget* widget, gpointer data)
 {
 	settings.mute_on_exit = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(mute_on_exit));
@@ -756,7 +722,8 @@ static void freq_cell_edited_cb(GtkCellR
 	double value;
 	gchar *freq_str;
 	
-	if (sscanf(new_val, "%lf", &value) != 1) return;
+	if (sscanf(new_val, "%lf", &value) != 1)
+		return;
 	
 	if (value < FREQ_MIN) value = FREQ_MIN;
 	if (value > FREQ_MAX) value = FREQ_MAX;
@@ -871,306 +838,334 @@ static void tree_view_scroll_to_active_p
 	tree_view_switch_to_preset (active);
 }
 
-static void free_presets_list (gpointer data)
+static preset *presets_list_new (const gchar *title, const gchar *freq)
+{
+ 	preset *ps;
+	double value;
+
+	ps = malloc (sizeof (preset));
+
+	if (strcmp (title, "") == 0)
+		ps->title = g_strdup(_("unnamed"));
+	else
+		ps->title = g_strdup (title);
+
+	value = g_strtod (freq, NULL);
+	if (value < FREQ_MIN) value = FREQ_MIN;
+	if (value > FREQ_MAX) value = FREQ_MAX;
+	ps->freq = value;
+
+	return ps;
+}
+
+static void
+presets_list_free (gpointer data)
 {
 	preset *ps = (preset *) data;
 	g_free (ps->title);
 	g_free (ps);
 }
 
-/* Go through each row and add its data to the xmlDocPtr */
-static gboolean save_to_file_foreach(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, xmlNodePtr root, gpointer user_data)
+static gboolean
+gnomeradio_xml_validate_from_resource (xmlDoc *doc, const gchar *dtd_resourcename)
 {
-	gchar *title, *freq, *position;
-	xmlNodePtr current;
+	GBytes *resourcecontents;
+	gconstpointer resourcedata;
+	gsize resourcesize;
+	xmlParserInputBufferPtr buffer;
+	xmlValidCtxt cvp;
+	xmlDtd *dtd;
+	GError *error = NULL;
+	gboolean ret;
+
+	resourcecontents = g_resources_lookup_data (dtd_resourcename, G_RESOURCE_LOOKUP_FLAGS_NONE, &error);
+	if (error != NULL) {
+		g_warning ("Unable to load dtd resource '%s': %s", dtd_resourcename, error->message);
+		g_error_free (error);
+		return FALSE;
+	}
+	resourcedata = g_bytes_get_data (resourcecontents, &resourcesize);
+	buffer = xmlParserInputBufferCreateStatic (resourcedata, resourcesize, XML_CHAR_ENCODING_UTF8);
 
-	/* get the data stored in the model... */
-	gtk_tree_model_get(model, iter, 0, &title, 1, &freq, -1);
-	/* ...and get the path of the current row */
-	position = gtk_tree_path_to_string(path);
-	/* create a new child of the root node... */
-	/* (note that I'm using a (guchar*) cast; this is because it's the same thing as
-	 * an (xmlChar*) cast, but easier to type) */
-	current = xmlNewChild(root, NULL, (guchar*)"station", NULL);
-	/* ...and set some properties */
-	xmlSetProp(current, (guchar*)"name", (guchar*)title);
-	xmlSetProp(current, (guchar*)"freq", (guchar*)freq);
-	xmlSetProp(current, (guchar*)"position", (guchar*)position);
-	/* free our data we retrieved from the model */
-	g_free(title);
-	g_free(freq);
-	g_free(position);
+	memset (&cvp, 0, sizeof (cvp));
+	dtd = xmlIOParseDTD (NULL, buffer, XML_CHAR_ENCODING_UTF8);
+	ret = xmlValidateDtd (&cvp, doc, dtd);
 
-	/* return FALSE to keep iterating */
-	return FALSE;
+	xmlFreeDtd (dtd);
+	g_bytes_unref (resourcecontents);
+
+	return ret;
 }
 
-/* Function handle saving an xml file; calls save_to_file_foreach */
-static void save_to_file(gchar *filename)
+static gboolean
+presets_file_save (const gchar *filename)
 {
-	GtkTreeModel *model;
 	xmlDocPtr doc;
+	xmlNodePtr comment;
 	xmlNodePtr root;
+	xmlNodePtr node;
+	GList *l;
 
-	/* create a new doc node */
-	doc = xmlNewDoc((guchar*)"1.0");
-	/* create a new root element. */
-	root = xmlNewDocNode(doc, NULL, (guchar*)"gnomeradio", NULL);
-	/* set it as the root element */
-	xmlDocSetRootElement(doc, root);
-	/* get the tree view's model... */
-	model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree_view));
-	/* ...and go through it with a foreach */
-	gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)save_to_file_foreach, (gpointer)root);
-	/* make sure the XML document will be indented */
-	xmlIndentTreeOutput = 1;
-	/* save the actual file */
-	xmlSaveFormatFileEnc(filename, doc, "utf-8", 1);
-	/* free the doc node */
-	xmlFreeDoc(doc);
-}
+	doc = xmlNewDoc ((const xmlChar *) "1.0");
 
-/* Callback for the "Save to file" button; calls save_to_file */
-static void save_to_file_cb(GtkWidget *button, gpointer data)
-{
-	GtkWidget *dialog;
-	GtkFileFilter *file_filter_all;
-	GtkFileFilter *file_filter_xml;
-	gchar *filename;
+	if (save_to_file)
+		comment = xmlNewDocComment (doc, (const xmlChar *) _("\n"
+								     "          Listen to FM radio\n"));
+	else
+		comment = xmlNewDocComment (doc, (const xmlChar *) _("\n"
+								     "                      Listen to FM radio\n\n"
+								     "            This file was automatically generated.\n"
+								     "  Please MAKE SURE TO BACKUP THIS FILE before making changes.\n"));
+	xmlAddChild ((xmlNodePtr) doc, comment);
+	root = xmlNewNode (NULL, (const xmlChar *) "gnomeradio");
+	xmlDocSetRootElement (doc, root);
+	xmlAddPrevSibling (root, comment);
+
+	for (l = settings.presets; l; l = l->next) {
+		preset *ps = l->data;
+		gchar *buffer;
 
-	dialog = gtk_file_chooser_dialog_new (_("Select file name\xE2\x80\xA6"), NULL,
-					      GTK_FILE_CHOOSER_ACTION_SAVE,
-					      _("_Save"), GTK_RESPONSE_ACCEPT,
-					      _("_Cancel"), GTK_RESPONSE_CANCEL,
-					      NULL);
+		node = xmlNewChild (root, NULL, (const xmlChar *) "station", NULL);
 
-	file_filter_all = gtk_file_filter_new();
-	gtk_file_filter_set_name(file_filter_all, _("All Files"));
-	gtk_file_filter_add_pattern(file_filter_all, "*");
-	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), file_filter_all);
-
-	file_filter_xml = gtk_file_filter_new();
-	gtk_file_filter_set_name(file_filter_xml, _("XML Files (*.xml)"));
-	gtk_file_filter_add_pattern(file_filter_xml, "*.xml");
-	gtk_file_filter_add_pattern(file_filter_xml, "*.XML");
-	gtk_file_filter_add_mime_type(file_filter_xml, "text/xml");
-	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), file_filter_xml);
-
-	gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(dialog), TRUE);
-        gtk_file_chooser_set_filter(GTK_FILE_CHOOSER(dialog), file_filter_xml);
-	gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(dialog), "gnomeradio.xml");
-
-	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
-		filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-		/* Check if .xml extension is added, if not add */
-		if (!g_str_has_suffix(filename, ".xml")) {
-			char *tmp_file;
-			/* create copy of filename to release it and create a new one, using old name */
-			tmp_file = g_strdup(filename);
-			g_free(filename);
-        		filename = g_strdup_printf("%s.xml", tmp_file);
-			g_free(tmp_file);
-		}
-		save_to_file(filename);
-		g_free(filename);
+		xmlNewProp (node, (const xmlChar *) "name", (const xmlChar *) ps->title);
+		buffer = g_strdup_printf("%0.2f", ps->freq);
+		xmlNewProp (node, (const xmlChar *) "freq", (const xmlChar *) buffer);
+		g_free (buffer);
 	}
-	gtk_widget_destroy(dialog);
-}
-
-/* Gets the parent of a path string.
-* passing "0:1:2" would return "0:1",
-* passing "0:1" would return "0",
-* passing "0" would return NULL */
-gchar *gtk_tree_path_string_get_parent(gchar *path)
-{
-	gchar *colon;
-
-	g_return_val_if_fail(path != NULL, NULL);
 
-	colon = g_strrstr(path, ":");
-	if (colon == NULL)
-		  return NULL;
-
-	return g_strndup(path, colon - path);
-}
+	xmlIndentTreeOutput = 1;
 
-/* Make sure that path exists within model */
-static void gtk_tree_model_generate_path(GtkTreeModel *model, gchar *path)
-{
-	GtkTreeIter iter, parent;
-	gchar *temp;
+	xmlSaveFormatFileEnc (filename, doc, "UTF-8", 1);
+	xmlFreeDoc (doc);
 
-	while (TRUE) {
-		/* if this returns TRUE, then this path exists and we're fine */
-		if (gtk_tree_model_get_iter_from_string(model, &iter, path))
-			break;
+	xmlMemoryDump ();
 
-		temp = path;
-		path = gtk_tree_path_string_get_parent(path);
-		/* if there's no parent, then it's toplevel */
-		if (path == NULL) {
-			if (GTK_IS_TREE_STORE(model))
-				gtk_tree_store_append(GTK_TREE_STORE(model), &parent, NULL);
-			else
-				gtk_list_store_append(GTK_LIST_STORE(model), &parent);
-			gtk_tree_model_generate_path(model, temp);
-			break;
-		}
-		if (GTK_IS_TREE_STORE(model)) {
-			gtk_tree_model_generate_path(model, path);
-			gtk_tree_model_get_iter_from_string(model, &parent, path);
-			gtk_tree_store_append(GTK_TREE_STORE(model), &iter, &parent);
-		}
-	}
+	return TRUE;
 }
 
-/* Function to load from an xml file */
-static void load_from_file(gchar *filename)
+static void
+presets_file_parse (const gchar *filename)
 {
+	xmlParserCtxtPtr ctxt;
 	xmlDocPtr doc;
-	xmlNodePtr current;
-	xmlChar *title, *freq, *position;
-	GtkTreeModel *model;
-	GtkTreePath *path = NULL;
-	GtkTreeIter iter;
-	GtkAdjustment* v_scb;
+	xmlNodePtr root;
+	xmlNodePtr node;
+	preset* ps;
 
-	/* load the file */
-	doc = xmlParseFile(filename);
-	/* get the root item */
-	if (doc == NULL)
-		return;
+	ctxt = xmlNewParserCtxt ();
 
-	current = xmlDocGetRootElement(doc);
-	if (current == NULL) {
-		xmlFreeDoc(doc);
+	doc = xmlCtxtReadFile (ctxt, filename, NULL, 0);
+	if (!doc) {
+		g_warning ("Failed to parse file:'%s'", filename);
+		xmlFreeParserCtxt (ctxt);
 		return;
 	}
 
-	if (xmlStrcmp(current->name, (guchar*)"gnomeradio")) {
-		xmlFreeDoc(doc);
+	if (!gnomeradio_xml_validate_from_resource (doc, GNOMERADIO_DTD_RESOURCENAME)) {
+		g_warning ("Failed to validate file:'%s'", filename);
+		xmlFreeDoc (doc);
+		xmlFreeParserCtxt (ctxt);
 		return;
 	}
 
-	/* remove previous presets */
 	if (settings.presets != NULL) {
-		if (main_visible) {
-			gint i, count;
+		if (load_from_file) {
+			gtk_list_store_clear (GTK_LIST_STORE (list_store));
 
-			count = g_list_length (settings.presets);
-			for (i = 0; i < count; i++) {
-				gtk_combo_box_text_remove(GTK_COMBO_BOX_TEXT(preset_combo), 1);
-				tray_menu_remove_preset(0);
-			}
-       		}
+			if (main_visible) {
+				gint i, count;
+
+				count = g_list_length (settings.presets);
+				for (i = 0; i < count; i++) {
+					gtk_combo_box_text_remove (GTK_COMBO_BOX_TEXT (preset_combo), 1);
+					preset_combo_set_item (-1);
 
-		gtk_list_store_clear(GTK_LIST_STORE(list_store));
+					tray_menu_remove_preset (0);
+				}
+			}
+		}
 
-		g_list_free_full (settings.presets, free_presets_list);
+		g_list_free_full (settings.presets, presets_list_free);
 		settings.presets = NULL;
-       	}
+	}
 
-	/* get the tree view's model */
-	model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree_view));
+	root = xmlDocGetRootElement(doc);
 
-	/* iterate through the root's children items */
-	current = current->xmlChildrenNode;
-	while (current) {
-        	if(!xmlIsBlankNode(current)) {
-			/* check for the proper element name */
-			if (!xmlStrcmp(current->name, (guchar*)"station")) {
-				/* get the saved properties */
-				title = xmlGetProp(current, (guchar*)"name");
-				freq = xmlGetProp(current, (guchar*)"freq");
-				position = xmlGetProp(current, (guchar*)"position");
-
-				if( title && freq && position ) {
-					preset *ps = g_malloc0(sizeof(preset));
-					ps->title = g_strdup((gchar*)title);
-					ps->freq = atof((gchar*)freq);
-
-					settings.presets = g_list_append(settings.presets, ps);
-
-					/* make sure that the path exists */
-					gtk_tree_model_generate_path(model, (gchar*)position);
-					/* get an iter to the path */
-					gtk_tree_model_get_iter_from_string(model, &iter, (gchar*)position);
-					/* set the data */
-					gtk_list_store_set(GTK_LIST_STORE(list_store), &iter, 0, title, 1, freq, -1);
-
-					gtk_tree_selection_unselect_all(selection);
-
-					v_scb = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(tree_view));
-					gtk_adjustment_set_value(v_scb, gtk_adjustment_get_upper(v_scb));
-
-					if (main_visible) {
-						gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(preset_combo), ps->title);
-						mom_ps = g_list_length(settings.presets) - 1;
-						preset_combo_set_item(mom_ps);
+	node = root->children;
+	while (node) {
+		if (strcmp ((gchar *) node->name, "station") == 0) {
+			gchar *title;
+			gchar *freq;
+
+			title = (gchar *) xmlGetProp (node, (const xmlChar *) "name");
+			freq = (gchar *) xmlGetProp (node, (const xmlChar *) "freq");
+
+			if (title && freq) {
+				ps = presets_list_new (title, freq);
+				settings.presets = g_list_append (settings.presets, ps);
+			}
 
-						tray_menu_add_preset (ps, mom_ps);
-					}
-				}
-				/* free the data */
-				xmlFree(title);
-				xmlFree(freq);
-				xmlFree(position);
+			xmlFree(title);
+			xmlFree(freq);
+		}
+
+		node = node->next;
+	}
+
+	xmlFreeDoc (doc);
+	xmlFreeParserCtxt (ctxt);
+
+	if (load_from_file) {
+		GList *l;
+
+		for (l = settings.presets; l != NULL; l = l->next) {
+			GtkTreeIter iter = {0};
+			gchar *buffer;
+			ps = l->data;
+			buffer = g_strdup_printf ("%0.2f", ps->freq);
+			gtk_list_store_append (list_store, &iter);
+			gtk_list_store_set (GTK_LIST_STORE (list_store), &iter, 0, ps->title, 1, buffer, -1);
+			g_free (buffer);
+
+			if (main_visible) {
+				gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT(preset_combo), ps->title);
+				mom_ps = g_list_length (settings.presets) - 1;
+				preset_combo_set_item (mom_ps);
+
+				tray_menu_add_preset (ps, mom_ps);
 			}
-			current = current->next;
 		}
+
+		tree_view_scroll_to_active_preset_cb (tree_view, NULL);
+		tree_view_cursor_changed_cb (tree_view, NULL);
+
+		gtk_widget_set_sensitive (save_button, TRUE);
+		gtk_widget_set_sensitive (remove_button, TRUE);
 	}
-	/* free the doc node */
-	xmlFreeDoc(doc);
+}
 
-	if (settings.presets == NULL)
-		return;
+static void
+presets_save (void)
+{
+	gchar *dir;
+	gchar *file_with_path;
 
-	path = gtk_tree_model_get_path(GTK_TREE_MODEL(list_store), &iter);
+	dir = g_build_filename (g_get_user_config_dir (), PACKAGE_NAME, NULL);
+	g_mkdir_with_parents (dir, S_IRUSR | S_IWUSR | S_IXUSR);
+	file_with_path = g_build_filename (dir, GNOMERADIO_XML_FILENAME, NULL);
+	g_free (dir);
 
-	gtk_tree_view_set_cursor(GTK_TREE_VIEW (tree_view), path, NULL, FALSE );
-	gtk_tree_path_free(path);
+	presets_file_save (file_with_path);
 
-	gtk_widget_grab_focus(tree_view);
+	g_free (file_with_path);
+}
 
-	tree_view_cursor_changed_cb(tree_view, NULL);
-	gtk_widget_set_sensitive(save_button, TRUE);
-	gtk_widget_set_sensitive(remove_button, TRUE);
+static void
+presets_load (void)
+{
+	gchar *dir;
+	gchar *file_with_path;
+
+	dir = g_build_filename (g_get_user_config_dir (), PACKAGE_NAME, NULL);
+	file_with_path = g_build_filename (dir, GNOMERADIO_XML_FILENAME, NULL);
+	g_free (dir);
+
+	if (g_file_test (file_with_path, G_FILE_TEST_EXISTS))
+		presets_file_parse (file_with_path);
+
+	g_free (file_with_path);
 }
 
-/* Callback for the "Load from file" button; calls load_from_file */
-static void load_from_file_cb(GtkWidget *button, gpointer data)
+static void
+add_default_file_filters (GtkWidget *file_chooser)
 {
-	GtkWidget *dialog;
 	GtkFileFilter *file_filter_all;
 	GtkFileFilter *file_filter_xml;
-	gchar *filename;
 
-	dialog = gtk_file_chooser_dialog_new (_("Select file name\xE2\x80\xA6"), NULL,
-					      GTK_FILE_CHOOSER_ACTION_OPEN,
-					      _("_Open"), GTK_RESPONSE_ACCEPT,
-					      _("_Cancel"), GTK_RESPONSE_CANCEL,
-					      NULL);
+	file_filter_all = gtk_file_filter_new ();
+	gtk_file_filter_set_name(file_filter_all, _("All files"));
+	gtk_file_filter_add_pattern (file_filter_all, "*");
+
+	file_filter_xml = gtk_file_filter_new ();
+	gtk_file_filter_set_name (file_filter_xml, _("XML files"));
+	gtk_file_filter_add_pattern (file_filter_xml, "*.xml");
+	gtk_file_filter_add_pattern (file_filter_xml, "*.XML");
+	gtk_file_filter_add_mime_type (file_filter_xml, "text/xml");
+
+	gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (file_chooser), file_filter_all);
+	gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (file_chooser), file_filter_xml);
+
+        gtk_file_chooser_set_filter (GTK_FILE_CHOOSER (file_chooser), file_filter_xml);
+}
+
+static void
+save_to_file_cb (GtkWidget *button, gpointer data)
+{
+	GtkWidget *dialog;
+
+	save_to_file = TRUE;
+
+	dialog = gtk_file_chooser_dialog_new (_("Select file name"),
+						NULL,
+						GTK_FILE_CHOOSER_ACTION_SAVE,
+						_("_Save"), GTK_RESPONSE_ACCEPT,
+						_("_Cancel"), GTK_RESPONSE_CANCEL,
+						NULL);
+
+
+
+	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER(dialog), TRUE);
+	add_default_file_filters (dialog);
+	gtk_file_chooser_set_current_name (GTK_FILE_CHOOSER (dialog), "gnomeradio.xml");
+
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
+		gchar *filename;
+
+		filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER(dialog));
+		if (!g_str_has_suffix (filename, ".xml")) {
+			gchar *tmp_file;
 
-	file_filter_all = gtk_file_filter_new();
-	gtk_file_filter_set_name(file_filter_all, _("All Files"));
-	gtk_file_filter_add_pattern(file_filter_all, "*");
-	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), file_filter_all);
-
-	file_filter_xml = gtk_file_filter_new();
-	gtk_file_filter_set_name(file_filter_xml, _("XML Files"));
-	gtk_file_filter_add_pattern(file_filter_xml, "*.xml");
-	gtk_file_filter_add_pattern(file_filter_xml, "*.XML");
-	gtk_file_filter_add_mime_type(file_filter_xml, "text/xml");
-	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), file_filter_xml);
-
-        gtk_file_chooser_set_filter(GTK_FILE_CHOOSER(dialog), file_filter_xml);
-
-	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
-		filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-		load_from_file(filename);
-		g_free(filename);
+			tmp_file = g_strdup (filename);
+			g_free (filename);
+        		filename = g_strdup_printf ("%s.xml", tmp_file);
+			g_free (tmp_file);
+		}
+		presets_file_save (filename);
+		g_free (filename);
+	}
+
+	gtk_widget_destroy (dialog);
+
+	save_to_file = FALSE;
+}
+
+static void
+load_from_file_cb (GtkWidget *button, gpointer data)
+{
+	GtkWidget *dialog;
+
+	load_from_file = TRUE;
+
+	dialog = gtk_file_chooser_dialog_new (_("Select file name"),
+						NULL,
+						GTK_FILE_CHOOSER_ACTION_OPEN,
+						_("_Open"), GTK_RESPONSE_ACCEPT,
+						_("_Cancel"), GTK_RESPONSE_CANCEL,
+						NULL);
+
+	add_default_file_filters (dialog);
+
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
+		gchar *filename;
+
+		filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
+		presets_file_parse (filename);
+		g_free (filename);
 	}
-	gtk_widget_destroy(dialog);
+
+	gtk_widget_destroy (dialog);
+
+	load_from_file = FALSE;
 }
 
 gboolean action_mode (gint mode)
@@ -1206,10 +1201,7 @@ GtkWidget* prefs_window(GtkWidget *app)
 	GtkWidget *open_button;
 	GtkWidget *destination_button;
 	GtkWidget *image;
-
 	GstEncodingProfile *profile;
-
-	gint i;
 	gchar *markup;
 	preset* ps;
 	GList *l;
@@ -1374,7 +1366,6 @@ GtkWidget* prefs_window(GtkWidget *app)
 
 	g_signal_connect(G_OBJECT(cellrenderer), "edited", G_CALLBACK(freq_cell_edited_cb), NULL);
 
-	i = 0;
 	for (l = settings.presets; l != NULL; l = l->next) {
 		GtkTreeIter iter = {0};
 		char *buffer;
@@ -1383,7 +1374,6 @@ GtkWidget* prefs_window(GtkWidget *app)
 		gtk_list_store_append(list_store, &iter);
 		gtk_list_store_set(GTK_LIST_STORE(list_store), &iter, 0, ps->title, 1, buffer, -1);
 		g_free(buffer);
-		i++;
 	}
 
 	gtk_grid_attach(GTK_GRID(grid), scrolled_window, 0, 6, 2, 1);
@@ -1499,8 +1489,8 @@ GtkWidget* prefs_window(GtkWidget *app)
 	g_signal_connect(G_OBJECT(audio_profile_combo), "changed", G_CALLBACK(audio_profile_combo_change_cb), NULL);
 	g_signal_connect(G_OBJECT(install_button), "clicked", G_CALLBACK(audio_profile_install_plugins_cb), NULL);
 
-	gtk_widget_set_tooltip_text(destination_button, _("Select a location where to save recorded file."));
-	gtk_widget_set_tooltip_text(audio_profile_combo, _("Choose the format that should be used for recording."));
+	gtk_widget_set_tooltip_text(destination_button, _("The default location to use for the recorded files"));
+	gtk_widget_set_tooltip_text(audio_profile_combo, _("The media type for encoding audio when recording"));
 
 	gtk_widget_show_all(dialog);
 
Index: gnomeradio-1.8/src/prefs.h
===================================================================
--- gnomeradio-1.8.orig/src/prefs.h
+++ gnomeradio-1.8/src/prefs.h
@@ -19,9 +19,9 @@
 
 #include <math.h>
 
-gboolean save_settings(void);
+void save_settings (void);
 
-gboolean load_settings(void);
+void load_settings (void);
 
 void audio_box_set_visible (gboolean visible);
 
