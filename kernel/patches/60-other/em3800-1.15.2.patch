diff -Naurdp a/drivers/media/video/em3800/adv717x.c b/drivers/media/video/em3800/adv717x.c
--- a/drivers/media/video/em3800/adv717x.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/adv717x.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,702 @@
+/*
+   ADV7175A - Analog Devices ADV7175A video encoder driver version 0.0.3
+
+   Copyright (C) 2000 Henrik Johannson <henrikjo@post.utfors.se>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include <linux/videodev.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/video_encoder.h>
+
+#include "em8300_compat24.h"
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+
+#include "adv717x.h"
+#include "encoder.h"
+
+MODULE_SUPPORTED_DEVICE("adv717x");
+MODULE_LICENSE("GPL");
+
+EXPORT_NO_SYMBOLS;
+
+#ifdef CONFIG_ADV717X_PIXELPORT16BIT
+int pixelport_16bit[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+#else
+int pixelport_16bit[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+#endif
+MODULE_PARM(pixelport_16bit, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(pixelport_16bit, "Changes how the ADV717x expects its input data to be formatted. If the colours on the TV appear green, try changing this. Defaults to 1.");
+
+#ifdef CONFIG_ADV717X_PIXELPORTPAL
+int pixelport_other_pal[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+#else
+int pixelport_other_pal[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+#endif
+MODULE_PARM(pixelport_other_pal, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(pixelport_other_pal, "If this is set to 1, then the pixelport setting is swapped for PAL from the setting given with pixelport_16bit. Defaults to 1.");
+
+int pixeldata_adjust_ntsc[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+MODULE_PARM(pixeldata_adjust_ntsc, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(pixeldata_adjust_ntsc, "If your red and blue colours are swapped in NTSC, try setting this to 0,1,2 or 3. Defaults to 1.");
+
+int pixeldata_adjust_pal[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+MODULE_PARM(pixeldata_adjust_pal, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(pixeldata_adjust_pal, "If your red and blue colours are swapped in PAL, try setting this to 0,1,2 or 3. Defaults to 1.");
+
+
+static int color_bars[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+MODULE_PARM(color_bars, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(color_bars, "If you set this to 1 a set of color bars will be displayed on your screen (used for testing if the chip is working). Defaults to 0.");
+
+static int output_mode_nr[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+static char *output_mode[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = NULL };
+MODULE_PARM(output_mode, "1-" __MODULE_STRING(EM8300_MAX) "s");
+MODULE_PARM_DESC(output_mode, "Specifies the output mode to use for the ADV717x video encoder. See the README-modoptions file for the list of mode names to use. Default is SVideo + composite (\"comp+svideo\").");
+
+
+/* Common register offset definitions */
+#define ADV717X_REG_MR0		0x00
+#define ADV717X_REG_MR1		0x01
+#define ADV717X_REG_TR0		0x07
+
+/* Register offsets specific to the ADV717[56]A chips */
+#define ADV7175_REG_SCFREQ0	0x02
+#define ADV7175_REG_SCFREQ1	0x03
+#define ADV7175_REG_SCFREQ2	0x04
+#define ADV7175_REG_SCFREQ3	0x05
+#define ADV7175_REG_SCPHASE	0x06
+#define ADV7175_REG_CCED0	0x08
+#define ADV7175_REG_CCED1	0x09
+#define ADV7175_REG_CCD0	0x0a
+#define ADV7175_REG_CCD1	0x0b
+#define ADV7175_REG_TR1		0x0c
+#define ADV7175_REG_MR2		0x0d
+#define ADV7175_REG_PCR0	0x0e
+#define ADV7175_REG_PCR1	0x0f
+#define ADV7175_REG_PCR2	0x10
+#define ADV7175_REG_PCR3	0x11
+#define ADV7175_REG_MR3		0x12
+#define ADV7175_REG_TTXRQ_CTRL	0x24
+
+/* Register offsets specific to the ADV717[01] chips */
+#define ADV7170_REG_MR2		0x02
+#define ADV7170_REG_MR3		0x03
+#define ADV7170_REG_MR4		0x04
+#define ADV7170_REG_TR1		0x08
+#define ADV7170_REG_SCFREQ0	0x09
+#define ADV7170_REG_SCFREQ1	0x0a
+#define ADV7170_REG_SCFREQ2	0x0b
+#define ADV7170_REG_SCFREQ3	0x0c
+#define ADV7170_REG_SCPHASE	0x0d
+#define ADV7170_REG_CCED0	0x0e
+#define ADV7170_REG_CCED1	0x0f
+#define ADV7170_REG_CCD0	0x10
+#define ADV7170_REG_CCD1	0x11
+#define ADV7170_REG_PCR0	0x12
+#define ADV7170_REG_PCR1	0x13
+#define ADV7170_REG_PCR2	0x14
+#define ADV7170_REG_PCR3	0x15
+#define ADV7170_REG_TTXRQ_CTRL	0x19
+
+static int adv717x_attach_adapter(struct i2c_adapter *adapter);
+int adv717x_detach_client(struct i2c_client *client);
+int adv717x_command(struct i2c_client *client, unsigned int cmd, void *arg);
+
+typedef enum {
+	MODE_COMPOSITE_SVIDEO,
+	MODE_SVIDEO,
+	MODE_COMPOSITE,
+	MODE_COMPOSITE_PSEUDO_SVIDEO,
+	MODE_PSEUDO_SVIDEO,
+	MODE_COMPOSITE_OVER_SVIDEO,
+	MODE_YUV,
+	MODE_YUV_PROG,
+	MODE_RGB,
+	MODE_RGB_NOSYNC,
+	MODE_RGB_PROG,
+	MODE_RGB_PROG_NOSYNC,
+	MODE_MAX
+} OutputModes;
+
+typedef struct {
+	char const * name;
+	int component;
+	int yuv;
+	int euroscart;
+	int progressive;
+	int sync_all;
+	int dacA;
+	int dacB;
+	int dacC;
+	int dacD;
+} OutputModeInfo;
+
+OutputModeInfo ModeInfo[] = {
+	[ MODE_COMPOSITE_SVIDEO ] =		{ "comp+svideo" , 0, 0, 0, 0, 0, 1, 0, 0, 0 },
+	[ MODE_SVIDEO ] =			{ "svideo"      , 0, 0, 0, 0, 0, 1, 1, 0, 0 },
+	[ MODE_COMPOSITE ] =			{ "comp"        , 0, 0, 0, 0, 0, 1, 0, 1, 1 },
+	[ MODE_COMPOSITE_PSEUDO_SVIDEO ] =	{ "comp+psvideo", 0, 0, 1, 0, 0, 1, 0, 0, 0 },
+	[ MODE_PSEUDO_SVIDEO ] =		{ "psvideo"     , 0, 0, 1, 0, 0, 1, 1, 0, 0 },
+	[ MODE_COMPOSITE_OVER_SVIDEO ] =	{ "composvideo" , 0, 0, 1, 0, 0, 1, 1, 1, 0 },
+	[ MODE_YUV ] =				{ "yuv"         , 1, 1, 0, 0, 0, 1, 0, 0, 0 },
+	[ MODE_RGB ] =				{ "rgbs"        , 1, 0, 0, 0, 1, 0, 0, 0, 0 },
+	[ MODE_RGB_NOSYNC ] =			{ "rgb"         , 1, 0, 0, 0, 0, 0, 0, 0, 0 },
+};
+
+#define CHIP_ADV7175A 1
+#define CHIP_ADV7170  2
+
+struct adv717x_data_s {
+	int chiptype;
+	int mode;
+	int bars;
+	int enableoutput;
+	OutputModes out_mode;
+	int pp_pal;
+	int pp_ntsc;
+	int pd_adj_pal;
+	int pd_adj_ntsc;
+
+	unsigned char config[32];
+	int configlen;
+};
+
+/* This is the driver that will be inserted */
+static struct i2c_driver adv717x_driver = {
+#if defined(EM8300_I2C_FORCE_NEW_API) || (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,54) && !defined(EM8300_I2C_FORCE_OLD_API))
+	.owner =		THIS_MODULE,
+#endif
+	.name =			"ADV717X video encoder driver",
+	.id =			I2C_DRIVERID_ADV717X,
+	.flags =		I2C_DF_NOTIFY,
+	.attach_adapter =	&adv717x_attach_adapter,
+	.detach_client =	&adv717x_detach_client,
+	.command =		&adv717x_command
+};
+
+int adv717x_id = 0;
+
+static unsigned char PAL_config_7170[27] = {
+	0x05,   // Mode Register 0
+	0x00,   // Mode Register 1 (was: 0x07)
+	0x02,   // Mode Register 2 (was: 0x48)
+	0x00,   // Mode Register 3
+	0x00,   // Mode Register 4
+	0x00,   // Reserved
+	0x00,   // Reserved
+	0x0d,   // Timing Register 0
+	0x77,   // Timing Register 1
+	0xcb,   // Subcarrier Frequency Register 0
+	0x8a,   // Subcarrier Frequency Register 1
+	0x09,   // Subcarrier Frequency Register 2
+	0x2a,   // Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0
+	0x00,   // Closed Captioning Register 1
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x00,	// CGMS_WSS Reg 0
+	0x00,	// CGMS_WSS Reg 1
+	0x00,	// CGMS_WSS Reg 2
+	0x00	// TeleText Control Register
+};
+
+static unsigned char NTSC_config_7170[27] = {
+	0x10,   // Mode Register 0
+	0x06,   // Mode Register 1
+	0x08,   // Mode Register 2
+	0x00,   // Mode Register 3
+	0x00,   // Mode Register 4
+	0x00,   // Reserved
+	0x00,   // Reserved
+	0x0d,   // Timing Register 0
+	0x77,   // Timing Register 1
+	0x16,   // Subcarrier Frequency Register 0
+	0x7c,   // Subcarrier Frequency Register 1
+	0xf0,   // Subcarrier Frequency Register 2
+	0x21,   // Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0
+	0x00,   // Closed Captioning Register 1
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x00,	// CGMS_WSS Reg 0
+	0x00,	// CGMS_WSS Reg 1
+	0x00,	// CGMS_WSS Reg 2
+	0x00	// TeleText Control Register
+};
+
+static unsigned char PAL_M_config_7175[19] = {   //These need to be tested
+	0x06,   // Mode Register 0
+	0x00,   // Mode Register 1
+	0xa3,   // Subcarrier Frequency Register 0
+	0xef,	// Subcarrier Frequency Register 1
+	0xe6,	// Subcarrier Frequency Register 2
+	0x21,	// Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register
+	0x0d,   // Timing Register 0
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0
+	0x00,   // Closed Captioning Register 1
+	0x70,	// Timing Register 1
+	0x73,	// Mode Register 2
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x42,   // Mode Register 3
+};
+
+static unsigned char PAL_config_7175[19] = {
+	0x01,   // Mode Register 0
+	0x06,   // Mode Register 1
+	0xcb,   // Subcarrier Frequency Register 0
+	0x8a,   // Subcarrier Frequency Register 1
+	0x09,   // Subcarrier Frequency Register 2
+	0x2a,   // Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register
+	0x0d,   // Timing Register 0
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0
+	0x00,   // Closed Captioning Register 1
+	0x73,   // Timing Register 1
+	0x08,   // Mode Register 2
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x42,   // Mode Register 3
+};
+
+static unsigned char PAL60_config_7175[19] = {
+	0x12,   // Mode Register 0
+	0x0,	// Mode Register 1
+	0xcb,   // Subcarrier Frequency Register 0
+	0x8a,   // Subcarrier Frequency Register 1
+	0x09,   // Subcarrier Frequency Register 2
+	0x2a,   // Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register
+	0x0d,   // Timing Register 0
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0
+	0x00,   // Closed Captioning Register 1
+	0x73,   // Timing Register 1
+	0x08,   // Mode Register 2
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x42,   // Mode Register 3
+};
+
+static unsigned char NTSC_config_7175[19] = {
+	0x04,   // Mode Register 0
+	0x00,   // Mode Register 1
+	0x16,   // Subcarrier Frequency Register 0
+	0x7c,	// Subcarrier Frequency Register 1
+	0xf0,	// Subcarrier Frequency Register 2
+	0x21,	// Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register
+	0x0d,   // Timing Register 0
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0
+	0x00,   // Closed Captioning Register 1
+	0x77,	// Timing Register 1
+	0x00,	// Mode Register 2
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x42,   // Mode Register 3
+};
+
+#define SET_REG(f,o,v) (f) = ((f) & ~(1<<(o))) | (((v) & 1) << (o))
+
+static int adv717x_update(struct i2c_client *client)
+{
+	struct adv717x_data_s *data = i2c_get_clientdata(client);
+	char tmpconfig[32];
+	int n, i;
+
+	memcpy(tmpconfig, data->config, data->configlen);
+
+	SET_REG(tmpconfig[ADV717X_REG_MR1], 7, data->bars);
+
+	switch(data->chiptype) {
+	    case CHIP_ADV7175A:
+		/* ADV7175/6A component out: MR06 (register 0, bit 6) */
+		SET_REG(tmpconfig[ADV717X_REG_MR0], 6,
+				ModeInfo[data->out_mode].component);
+		/* ADV7175/6A YUV out: MR26 (register 13, bit 6) */
+		SET_REG(tmpconfig[ADV7175_REG_MR2], 6,
+				ModeInfo[data->out_mode].yuv);
+		/* ADV7175/6A EuroSCART: MR37 (register 18, bit 7) */
+		SET_REG(tmpconfig[ADV7175_REG_MR3], 7,
+			ModeInfo[data->out_mode].euroscart);
+		/* ADV7175/6A RGB sync: MR05 (register 0, bit 5) */
+		SET_REG(tmpconfig[ADV717X_REG_MR0], 5,
+				ModeInfo[data->out_mode].sync_all);
+		break;
+	    case CHIP_ADV7170:
+		/* ADV7170/1 component out: MR40 (register 4, bit 0) */
+		SET_REG(tmpconfig[ADV7170_REG_MR4], 0,
+				ModeInfo[data->out_mode].component);
+		/* ADV7170/1 YUV out: MR41 (register 4, bit 1) */
+		SET_REG(tmpconfig[ADV7170_REG_MR4], 1,
+				ModeInfo[data->out_mode].yuv);
+		/* ADV7170/1 EuroSCART: MR33 (register 3, bit 3) */
+		SET_REG(tmpconfig[ADV7170_REG_MR3], 3,
+			ModeInfo[data->out_mode].euroscart);
+		/* ADV7170/1 RGB sync: MR42 (register 4, bit 2) */
+		SET_REG(tmpconfig[ADV7170_REG_MR4], 2,
+				ModeInfo[data->out_mode].sync_all);
+		break;
+	}
+	/* ADV7170/1/5A/6A non-interlace: MR10 (register 1, bit 0) */
+	SET_REG(tmpconfig[ADV717X_REG_MR1], 0,
+			ModeInfo[data->out_mode].progressive);
+	/* ADV7170/1/5A/6A DAC A control: MR16 (register 1, bit 6) */
+	SET_REG(tmpconfig[ADV717X_REG_MR1], 6, ModeInfo[data->out_mode].dacA);
+	/* ADV7170/1/5A/6A DAC B control: MR15 (register 1, bit 5) */
+	SET_REG(tmpconfig[ADV717X_REG_MR1], 5, ModeInfo[data->out_mode].dacB);
+	/* ADV7170/1/5A/6A DAC C control: MR13 (register 1, bit 3) */
+	SET_REG(tmpconfig[ADV717X_REG_MR1], 3, ModeInfo[data->out_mode].dacC);
+	/* ADV7170/1/5A/6A DAC D control: MR14 (register 1, bit 4) */
+	SET_REG(tmpconfig[ADV717X_REG_MR1], 4, ModeInfo[data->out_mode].dacD);
+
+	if (!data->enableoutput) {
+		tmpconfig[ADV717X_REG_MR1] |= 0x7f;
+	}
+
+	for(i=0; i < data->configlen; i++) {
+		n = i2c_smbus_write_byte_data(client, i, tmpconfig[i]);
+	}
+
+	i2c_smbus_write_byte_data(client, ADV717X_REG_TR0,
+			tmpconfig[ADV717X_REG_TR0] & 0x7f);
+	i2c_smbus_write_byte_data(client, ADV717X_REG_TR0,
+			tmpconfig[ADV717X_REG_TR0] | 0x80);
+	i2c_smbus_write_byte_data(client, ADV717X_REG_TR0,
+			tmpconfig[ADV717X_REG_TR0] & 0x7f);
+
+	return 0;
+}
+
+static int adv717x_setmode(int mode, struct i2c_client *client) {
+	struct adv717x_data_s *data = i2c_get_clientdata(client);
+	unsigned char *config = NULL;
+
+	pr_debug("adv717x_setmode(%d,%p)\n", mode, client);
+
+	switch (mode) {
+	case ENCODER_MODE_PAL:
+		printk(KERN_NOTICE "adv717x.o: Configuring for PAL\n");
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			config = PAL_config_7175;
+			data->configlen = sizeof(PAL_config_7175);
+			break;
+		case CHIP_ADV7170:
+			config = PAL_config_7170;
+			data->configlen = sizeof(PAL_config_7170);
+			break;
+		}
+		break;
+	case ENCODER_MODE_PAL_M:
+		printk(KERN_NOTICE "adv717x.o: Configuring for PALM\n");
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			config = PAL_config_7175;
+			data->configlen = sizeof(PAL_M_config_7175);
+			break;
+		case CHIP_ADV7170:
+			config = PAL_config_7170;
+			data->configlen = sizeof(PAL_config_7170);
+			break;
+		}
+		break;
+	case ENCODER_MODE_PAL60:
+		printk(KERN_NOTICE "adv717x.o: Configuring for PAL 60\n");
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			config = PAL60_config_7175;
+			data->configlen = sizeof(PAL60_config_7175);
+			break;
+		case CHIP_ADV7170:
+			config = PAL_config_7170;
+			data->configlen = sizeof(PAL_config_7170);
+			break;
+		}
+		break;
+	case ENCODER_MODE_NTSC:
+		printk(KERN_NOTICE "adv717x.o: Configuring for NTSC\n");
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			config = NTSC_config_7175;
+			data->configlen = sizeof(NTSC_config_7175);
+			break;
+		case CHIP_ADV7170:
+			config = NTSC_config_7170;
+			data->configlen = sizeof(NTSC_config_7170);
+			break;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	data->mode = mode;
+
+	if (config) {
+		memcpy(data->config, config, data->configlen);
+	}
+
+	switch (mode) {
+	case ENCODER_MODE_PAL:
+	case ENCODER_MODE_PAL_M:
+	case ENCODER_MODE_PAL60:
+		data->config[ADV717X_REG_TR0] =
+			(data->config[ADV717X_REG_TR0] & ~0x40) | data->pp_pal;
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			data->config[ADV7175_REG_TR1] = (data->config[ADV7175_REG_TR1] & ~0xC0) | data->pd_adj_pal;
+			break;
+		case CHIP_ADV7170:
+			data->config[ADV7170_REG_TR1] = (data->config[ADV7170_REG_TR1] & ~0xC0) | data->pd_adj_pal;
+			break;
+		}
+		break;
+	case ENCODER_MODE_NTSC:
+		data->config[ADV717X_REG_TR0] =
+			(data->config[ADV717X_REG_TR0] & ~0x40) | data->pp_ntsc;
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			data->config[ADV7175_REG_TR1] = (data->config[ADV7175_REG_TR1] & ~0xC0) | data->pd_adj_ntsc;
+			break;
+		case CHIP_ADV7170:
+			data->config[ADV7170_REG_TR1] = (data->config[ADV7170_REG_TR1] & ~0xC0) | data->pd_adj_ntsc;
+			break;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static int adv717x_setup(struct i2c_client *client)
+{
+	struct adv717x_data_s *data = i2c_get_clientdata(client);
+	struct em8300_s *em = i2c_get_adapdata(client->adapter);
+
+	memset(data->config, 0, sizeof(data->config));
+
+	if (pixelport_16bit[em->card_nr]) {
+		data->pp_ntsc = data->pp_pal = 0x40;
+		if (pixelport_other_pal[em->card_nr]) {
+			data->pp_pal = 0x00;
+		}
+	} else {
+		data->pp_ntsc = data->pp_pal = 0x00;
+		if (pixelport_other_pal[em->card_nr]) {
+			data->pp_pal = 0x40;
+		}
+	}
+
+	data->pd_adj_ntsc = (0x03 & pixeldata_adjust_ntsc[em->card_nr]) << 6;
+	data->pd_adj_pal = (0x03 & pixeldata_adjust_pal[em->card_nr]) << 6;
+
+	data->bars = color_bars[em->card_nr];
+	data->enableoutput = 0;
+	/* Maybe map from a string; dunno? */
+	data->out_mode = output_mode_nr[em->card_nr];
+	if (data->out_mode < 0 || data->out_mode >= MODE_MAX)
+		data->out_mode = 0;
+
+	adv717x_setmode(ENCODER_MODE_PAL60, client);
+
+	adv717x_update(client);
+
+	return 0;
+}
+
+static int adv717x_detect(struct i2c_adapter *adapter, int address)
+{
+	struct adv717x_data_s *data;
+	struct i2c_client *new_client;
+	int mr0, mr1;
+	int err;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {
+		return 0;
+	}
+
+	if (!(new_client = kmalloc(sizeof(struct i2c_client) + sizeof(struct adv717x_data_s), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+	memset(new_client, 0, sizeof(struct i2c_client) + sizeof(struct adv717x_data_s));
+	data = (struct adv717x_data_s *) (((struct i2c_client *) new_client) + 1);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &adv717x_driver;
+	new_client->flags = 0;
+
+	i2c_set_clientdata(new_client, data);
+
+	i2c_smbus_write_byte_data(new_client, ADV717X_REG_MR1, 0x55);
+	mr1=i2c_smbus_read_byte_data(new_client, ADV717X_REG_MR1);
+
+	if (mr1 == 0x55) {
+		mr0 = i2c_smbus_read_byte_data(new_client, ADV717X_REG_MR0);
+
+		if (mr0 & 0x20) {
+			strcpy(new_client->name, "ADV7175A chip");
+			data->chiptype = CHIP_ADV7175A;
+			printk(KERN_NOTICE "adv717x.o: ADV7175A chip detected\n");
+		} else {
+			strcpy(new_client->name, "ADV7170 chip");
+			data->chiptype = CHIP_ADV7170;
+			printk(KERN_NOTICE "adv717x.o: ADV7170 chip detected\n");
+		}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+		new_client->id = adv717x_id++;
+#endif
+
+		if ((err = i2c_attach_client(new_client))) {
+			kfree(new_client);
+			return err;
+		}
+
+		adv717x_setup(new_client);
+
+		EM8300_MOD_INC_USE_COUNT;
+
+		return 0;
+	}
+	kfree(new_client);
+
+	return 0;
+}
+
+static int adv717x_attach_adapter(struct i2c_adapter *adapter)
+{
+	adv717x_detect(adapter, 0x6a);
+	adv717x_detect(adapter, 0x7a);
+	adv717x_detect(adapter, 0xa);
+	return 0;
+}
+
+
+int adv717x_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	if ((err = i2c_detach_client(client))) {
+		printk(KERN_ERR "adv717x.o: Client deregistration failed, client not detached.\n");
+		return err;
+	}
+
+	EM8300_MOD_DEC_USE_COUNT;
+
+	kfree(client);
+
+	return 0;
+}
+
+int adv717x_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	struct adv717x_data_s *data = i2c_get_clientdata(client);
+
+	switch (cmd) {
+	case ENCODER_CMD_SETMODE:
+		adv717x_setmode((long int) arg, client);
+		adv717x_update(client);
+		break;
+	case ENCODER_CMD_ENABLEOUTPUT:
+		data->enableoutput = (long int) arg;
+		adv717x_update(client);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+
+int __init adv717x_init(void)
+{
+	int i;
+	for (i=0; i < EM8300_MAX; i++)
+		if ((output_mode[i]) && (output_mode[i][0])) {
+			int j;
+			for (j=0; j < MODE_MAX; j++)
+				if (strcmp(output_mode[i], ModeInfo[j].name) == 0) {
+					output_mode_nr[i] = j;
+					break;
+				}
+			if (j == MODE_MAX)
+				printk(KERN_WARNING "adv717x.o: Unknown output mode: %s\n", output_mode[i]);
+		}
+	//request_module("i2c-algo-bit");
+	return i2c_add_driver(&adv717x_driver);
+}
+
+void __exit adv717x_cleanup(void)
+{
+	i2c_del_driver(&adv717x_driver);
+}
+
+module_init(adv717x_init);
+module_exit(adv717x_cleanup);
diff -Naurdp a/drivers/media/video/em3800/adv717x.h b/drivers/media/video/em3800/adv717x.h
--- a/drivers/media/video/em3800/adv717x.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/adv717x.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,3 @@
+#if !defined(I2C_DRIVERID_ADV717X)
+#define I2C_DRIVERID_ADV717X 0xf000
+#endif
diff -Naurdp a/drivers/media/video/em3800/bt865.c b/drivers/media/video/em3800/bt865.c
--- a/drivers/media/video/em3800/bt865.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/bt865.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,996 @@
+/*
+   BT865A - Brook Tree BT865A video encoder driver version 0.0.4
+
+   Henrik Johannson <henrikjo@post.utfors.se>
+   As modified by Chris C. Hoover <cchoover@home.com>
+
+   Modified by Luis Correia <lfcorreia@users.sourceforge.net>
+   added rgb_mode (requires hacking DXR3 hardware)
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include <linux/videodev.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/video_encoder.h>
+
+#include "em8300_compat24.h"
+#include "bt865.h"
+#include "encoder.h"
+
+MODULE_SUPPORTED_DEVICE("bt865");
+MODULE_LICENSE("GPL");
+
+EXPORT_NO_SYMBOLS;
+
+static int color_bars[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+MODULE_PARM(color_bars, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(color_bars, "If you set this to 1 a set of color bars will be displayed on your screen (used for testing if the chip is working). Defaults to 0.");
+
+static int rgb_mode[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+MODULE_PARM(rgb_mode, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(rgb_mode, "Deprecated, use output_mode instead.");
+
+static char *output_mode[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = NULL };
+MODULE_PARM(output_mode, "1-" __MODULE_STRING(EM8300_MAX) "s");
+MODULE_PARM_DESC(output_mode, "Specifies the output mode to use for the BT865 video encoder. See the README-modoptions file for the list of mode names to use. Default is SVideo + composite (\"comp+svideo\").");
+
+
+static int bt865_attach_adapter(struct i2c_adapter *adapter);
+int bt865_detach_client(struct i2c_client *client);
+int bt865_command(struct i2c_client *client, unsigned int cmd, void *arg);
+static int bt865_setup(struct i2c_client *client);
+
+struct bt865_data_s {
+	int chiptype;
+	int mode;
+	int bars;
+	int rgbmode;
+	int enableoutput;
+
+	unsigned char config[48];
+	int configlen;
+};
+
+/* This is the driver that will be inserted */
+static struct i2c_driver bt865_driver = {
+#if defined(EM8300_I2C_FORCE_NEW_API) || (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,54) && !defined(EM8300_I2C_FORCE_OLD_API))
+	.owner =		THIS_MODULE,
+#endif
+	.name =			"BT865 video encoder driver",
+	.id =			I2C_DRIVERID_BT865,
+	.flags =		I2C_DF_NOTIFY,
+	.attach_adapter =	&bt865_attach_adapter,
+	.detach_client =	&bt865_detach_client,
+	.command =		&bt865_command
+};
+
+int bt865_id = 0;
+
+// Register settings come from Rockwell Semiconductor
+// Advance Information sheet l865a.pdf
+
+// Bits from the Left for Register A0
+// 1. one bit EWSF2 (Enable Wide Screen for Field 2)
+//    enable/disable Wide Screen Signaling/Copy Generation Management
+//    System encoding for field 2 (16:9)
+//    if 0 then Disable WSS/CGMS for Field 2
+//    if 1 then Enable WSS/CGMS for Field 2
+// 2. one bit EWSF1 (Enable Wide Screen for Field 1)
+//    enable/disable Wide Screen Signaling/Copy Generation Management
+//    System encoding for field 1 (16:9)
+//    if 0 then Disable WSS/CGMS for Field 1
+//    if 1 then Enable WSS/CGMS for Field 1
+// 3. two reserved bits, zero for normal operation
+//    this should have been done by the reset above
+// 4. four bits of WSDAT[1:4] (Wide Screen Data)
+
+// Bits from the Left for Register A2
+// 1. eight bits of WSDAT[5:12] (Wide Screen Data)
+
+// Bits from the Left for Register A4
+// 1. eight bits of WSDAT[13:20] (Wide Screen Data)
+//    there is a typo in the document here. it Should Say A4
+
+// Bits from the Left for Register A6
+// 1. one bit SRESET (System Reset)
+//    if 0 then Do Nothing
+//    if 1 then Reset All Registers (including this one) To Zero
+// 2. seven reserved bits, zero for normal operation
+//    this should be done by the reset anyway
+
+// Bits from the Left for Register A8
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register AA
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register AC
+// 1. eight bits TXHS[7:0] (Rising Edge Position of TeleText Request Pin)
+//    first eight bits of eleven
+
+// Bits from the Left for Register AE
+// 1. eight bits TXHE[7:0] (Falling Edge Position of TeleText Request Pin)
+//    first eight bits of eleven
+
+// Bits from the Left for Register B0
+// 1. two bits LUMADLY[1:0] (Luminance Delay Mode, B Output)
+//    D7   D6             Function
+//    ----------------------------
+//    0    0              No Delay
+//    0    1              1 Pixel Clock Delay
+//    1    0              2 Pixel Clock Delay
+//    1    1              3 Pixel Clock Delay
+//    used to program the Luminance Delay on the CVBS/B Output
+// 2. three bits TXHE[10:8] (Last Three Bits Teletext Falling Edge)
+//    (Falling Edge Position of TeleText Request Pin)
+// 3. three bits TXHS[10:8] (Last Three Bits Teletext Rising Edge)
+//    (Rising Edge Position of TeleText Request Pin)
+// (It's a programmable pulse generator)
+
+// Bits from the Left for Register B2
+// 1. two reserved bits, zero for normal operation
+//    this should have been done by the reset above
+// 2. one bit TXRM (Teletext Request Mode)
+//    if 0 then TTXREQ Pin outputs Request
+//    if 1 then TTXREQ Pin outputs TTX Clock
+// 3. one bit TXE (Teletext Enable)
+//    if 0 then Disable Teletext
+//    if 1 then Enable Teletext
+// 4. one bit TXEF2[8] (Last Line of Teletext Field 2 (last bit))
+// 5. one bit TXBF2[8] (First Line of Teletext Field 2 (last bit))
+// 6. one bit TXEF1[8] (Last Line of Teletext Field 1 (last bit))
+// 7. one bit TXBF1[8] (First Line of Teletext Field 1 (last bit))
+
+// Bits from the Left for Register B4
+// 1. eight bits TXBF1[7:0] (First Line of Teletext Field 1
+//    (first eight bits))
+
+// Bits from the Left for Register B6
+// 1. eight bits TXEF1[7:0] (Last Line of Teletext Field 1
+//    (first eight bits))
+
+// Bits from the Left for Register B8
+// 1. eight bits TXBF2[7:0] (First Line of Teletext Field 2
+//    (first eight bits))
+
+// Bits from the Left for Register BA
+// 1. eight bits TXEF2[7:0] (Last Line of Teletext Field 2
+//    (first eight bits))
+
+// Bits from the Left for Register BC
+// 1. one bit ECCF2 (Enable Closed Caption Encoding on Field 2)
+//    if 0 then Disable Closed Caption Encoding on Field 2
+//    if 1 then Enable Closed Caption Encoding on Field 2
+// 2. one bit ECCF1 (Enable Closed Caption Encoding on Field 1)
+//    if 0 then Disable Closed Caption Encoding on Field 1
+//    if 1 then Enable Closed Caption Encoding on Field 1
+// 3. one bit ECCGATE (Closed Caption Mode)
+//    if 0 then Normal Closed Caption Encoding
+//    if 1 then Prevent Encoding of Redundant or Incomplete Data
+//         Future Encoding is Disabled Until a Complete Pair of
+//         New Data Bytes is Received
+// 4. one reserved bit, zero for normal operation
+//    this should have been done by the reset above
+//    this is the bit that the original code mysteriously sets to one
+// 5. one bit DACOFF (Turn Off DAC)
+//    used to Limit Curent Consumption to Digital Circuits Only
+//    if 0 then Normal Operation
+//    if 1 then Disable DAC Output Current and Internal Voltage Reference
+//    This Bit is Forced High After Powerup Until Either 8 Fields Have
+//    Been Output or Register 0xCE Has Been Written
+// 6. one bit YC16 (YC Mode)
+//    if 0 then 8 Bit Mode: P[7:0] is Multiplexed YCrCb 8 Bit Video Data
+//    if 1 then 16 Bit Mode: P[7:0] is Multiplexed CrCb 8 Bit Video Data
+//                       and Y[7:0] is Y 8 Bit Data
+// 7. one bit CBSWAP (Chroma Red/Blue Swap)
+//    if 0 then Normal Pixel Sequence
+//    if 1 then Cr and Cb Pixels are Swapped at the Input to the Pixel Port
+// 8. one bit PORCH
+//    if 0 then Front and Back Porch Timing Meets ITU-RBT.470-3
+//         this must be the standard Porch Timing
+//    if 1 then CCIR601 Porch Timing. This allows 720 Pixels Width
+//         by Narrowing Front and Back Porch in Favor of Active Video
+
+// Bits from the Left for Register BE
+// 1. eight bits CCF2B1[7:0] (First Byte of Closed Captioning
+//    Information for Field 2)
+
+// Bits from the Left for Register C0
+// 1. eight bits CCF2B2[7:0] (Second Byte of Closed Captioning
+//    Information for Field 2)
+
+// Bits from the Left for Register C2
+// 1. eight bits CCF1B1[7:0] (First Byte of Closed Captioning
+//    Information for Field 1)
+
+// Bits from the Left for Register C4
+// 1. eight bits CCF1B2[7:0] (Second Byte of Closed Captioning
+//    Information for Field 1)
+
+// Bits from the Left for Register C6
+// 1. eight bits HSYNCF[7:0] (First Eight Bits Falling Edge Sync Data)
+//    SYNC Pulse Position Relative to Internal Horizontal Pixel Clock
+//    for Falling Edge of HSYNC
+// Needs ADJHSYNC = 1
+// Master Mode Only
+
+// Bits from the Left for Register C8
+// 1. eight bits HSYNCR[7:0] (First Eight Bits Rising Edge Sync Data)
+//    SYNC Pulse Position Relative to Internal Horizontal Pixel Clock
+//    for Rising Edge of HSYNC
+// Needs ADJHSYNC = 1
+// Master Mode Only
+
+// Bits from the Left for Register CA
+// 1. one bit SYNCDLY (Sync Delay Mode)
+//    if 0 then Normal SYNC Timing
+//    if 1 then Delayed SYNC Timing
+//    set this to one to see a pretty green screen :)
+// 2. one bit FIELD1 (the so-called Color Flag)
+//    if 0 then If FIELD Pin = 1 this Indicates Field 2
+//    if 1 then If FIELD Pin = 1 this Indicates Field 1
+// 3. one bit SYNCDIS (VBI SYNC Mode)
+//    if 0 then Normal HSYNC Operation
+//    if 1 then Disable HSYNC Durring VBI (No H Serrations In VBI)
+//    Master Mode Only
+// 4. one bit ADJHSYNC (HSYNC Pulse Timing Mode)
+//    if 0 then Normal 4.7usec HSYNC Pulse
+//    if 1 then Use HSYNCR[10:0] and HSYNCF[10:0] to Program HSYNC Pulse
+//         Rising and Falling Times
+//    See HSYNCR[7:0] and HSYNCF[7:0] Above
+//    (It's a programmable pulse generator and this is it's Enable Bit)
+// 5. two bits HSYNCF[9:8] (Last Two Bits Falling Edge Sync Data)
+// 6. two bits HSYNCR[9:8] (Last Two Bits Rising Edge Sync Data)
+
+// Bits from the Left for Register CC
+// 1. one bit SETMODE (Automatic Mode Detection)
+//    if 0 then Use Automatic Mode Detection
+//    if 1 then Override Automatic Mode Detection
+//         Use VIDFORM[3:0], NONINTL and SQUARE Registers Bits to Set Mode
+//    Slave Mode Only
+// 2. one bit SETUPDIS (Disable 7.5 IRE Setup on Output)
+//    if 0 then Setup On: 7.5 IRE Setup Enabled for Active Video Lines
+//    if 1 then Setup Off: Disable 7.5 IRE Setup on Output Video
+// 3. four bits VIDFORM[3:0]
+//    These Bits Control the World Television Standard
+//    D5  D4  D3  D2  Format         Market
+//    -------------------------------------
+//    0   0   0   0   NTSC Normal    USA/Japan
+//    0   0   1   0   NTSC-60/HDTV   USA-HDTV (SCRESET Must Be 1)
+//    1   1   0   0   PAL-M Normal   Brazil
+//    1   1   1   0   PAL-M-60/HDTV  Brazil-HDTV
+//    1   0   0   1   PAL-BDGHIN     Western Europe
+//    1   1   0   1   PAL-NC         Argentina
+// 4. one bit NONINTL (Non Interlace Mode)
+//    if 0 then Interlaced Operation
+//    if 1 then Non Interlaced Operation (Progressive Scan)
+// 5. one bit SQUARE (Square Pixel Operation Mode)
+//    if 0 then CCIR601 Operation
+//    if 1 then Square Pixel Operation
+
+// Bits from the Left for Register CE
+// 1. one bit ESTATUS (I2C Readback Information Mode)
+//    if 0 then I2C Readback Information Contains Version Number
+//    if 1 then I2C Readback Information Contains Closed Caption Status
+//         and Field Number
+// 2. one bit RGBO (RGB Output Mode)
+//    if 0 then Normal Operation
+//    if 1 then Enable RGB Outputs
+// 3. one bit DCHROMA (Disable Chroma)
+//    if 0 then Normal Operation
+//    if 1 then Disable Chroma (B/W Operation)
+// 4. one bit ECBAR (Enable Color Bars)
+//    if 0 then Normal Operation
+//    if 1 then Enable Internally Generated Color Bars on Output
+// 5. one bit SCRESET (Sub Carrier Reset Mode)
+//    if 0 then Normal Operation
+//         (SC Phase is Reset at Beginning of Each Field)
+//    if 1 then Disable Sub Carrier Reset Event at the
+//         Beginning of Each Field Sequence
+// 6. one bit EVBI (Enable HSYNC Durring VBI)
+//    if 0 then Video is Blanked Durring Vertical Blanking Interval
+//    if 1 then Enable Active Video Durring Vertical Blanking Interval
+//         Setup is Added if SETUPDIS = 0
+//         Scaling of YCrCb Pixels is based on 100% Blank to White
+//         i.e. Normal PAL Input Scaling
+// 7. one bit EACTIVE (Enable Active Video)
+//    if 0 then Output Black With Burst if ECBAR = 0
+//         or Color Bars if ECBAR = 1
+//    if 1 then Normal Operation (Output Active Video)
+// 8. one bit ECLIP (Enable DAC Clipping)
+//    if 0 then Normal Operation
+//    if 1 then DAC Values Less Than 31 Are Set To 31 (This Limit
+//         Corresponds Roughly to 1/4 of Sync Height)
+
+// Bits from the Left for Register D0
+// 1. seven reserved bits, zero for normal operation
+//    this should have been done by the reset above
+// 2. one bit PALN (Enable PAL-N Mode)
+//    if 0 then Normal PAL-BDGHI Operation As Set By VIDFORM[3:0]
+//    if 1 then PAL-N Operation As Set By VIDFORM[3:0]
+
+// Bits from the Left for Register D2
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register D4
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register D6
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register D8
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register DA
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register DC
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register DE
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E0
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E2
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E4
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E6
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E8
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register EA
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register EC
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register EE
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F0
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F2
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F4
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F6
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F8
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register FA
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register FC
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register FE
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// starts at register A0 by twos
+static unsigned char NTSC_CONFIG_BT865[ 48 ] = {
+/*  0 A0 */	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+/*  1 A2 */	0x00,	// WSDAT[12:5]
+/*  2 A4 */	0x00,	// WSDAT[20:13]
+/*  3 A6 */	0x00,	// SRESET RSRVD[6:0]
+/*  4 A8 */	0x00,	// RSRVD[7:0]
+/*  5 AA */	0x00,	// RSRVD[7:0]
+/*  6 AC */	0x00,	// TXHS[7:0]
+/*  7 AE */	0x00,	// TXHE[7:0]
+/*  8 B0 */	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+/*  9 B2 */	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+/* 10 B4 */	0x00,	// TXBF1[7:0]
+/* 11 B6 */	0x00,	// TXEF1[7:0]
+/* 12 B8 */	0x00,	// TXBF2[7:0]
+/* 13 BA */	0x00,	// TXEF2[7:0]
+/* 14 BC */	0xc1,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+/* 15 BE */	0x00,	// CCF2B1[7:0]
+/* 16 C0 */	0x00,	// CCF2B2[7:0]
+/* 17 C2 */	0x00,	// CCF1B1[7:0]
+/* 18 C4 */	0x00,	// CCF1B2[7:0]
+/* 19 C6 */	0x00,	// HSYNCF[7:0]
+/* 20 C8 */	0x00,	// HSYNCR[7:0]
+/* 21 CA */	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+/* 22 CC */	0x00,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+/* 23 CE */	0x04,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+/* 24 D0 */	0x00,	// RSRVD[6:0] PALN
+/* 25 D2 */	0x00,	// RSRVD[7:0]
+/* 26 D4 */	0x00,	// RSRVD[7:0]
+/* 27 D6 */	0x00,	// RSRVD[7:0]
+/* 28 D8 */	0x00,	// RSRVD[7:0]
+/* 29 DA */	0x00,	// RSRVD[7:0]
+/* 30 DC */	0x00,	// RSRVD[7:0]
+/* 31 DE */	0x00,	// RSRVD[7:0]
+/* 32 E0 */	0x00,	// RSRVD[7:0]
+/* 33 E2 */	0x00,	// RSRVD[7:0]
+/* 34 E4 */	0x00,	// RSRVD[7:0]
+/* 35 E6 */	0x00,	// RSRVD[7:0]
+/* 36 E8 */	0x00,	// RSRVD[7:0]
+/* 37 EA */	0x00,	// RSRVD[7:0]
+/* 38 EC */	0x00,	// RSRVD[7:0]
+/* 39 EE */	0x00,	// RSRVD[7:0]
+/* 40 F0 */	0x00,	// RSRVD[7:0]
+/* 41 F2 */	0x00,	// RSRVD[7:0]
+/* 42 F4 */	0x00,	// RSRVD[7:0]
+/* 43 F6 */	0x00,	// RSRVD[7:0]
+/* 44 F8 */	0x00,	// RSRVD[7:0]
+/* 45 FA */	0x00,	// RSRVD[7:0]
+/* 46 FC */	0x00,	// RSRVD[7:0]
+/* 47 FE */	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char NTSC60_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0x88,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+	0x0a,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x00,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char PALM_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0xf0,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+	0x02,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x00,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char PALM60_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0xf8,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+	0x02,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x00,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char PAL_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0xe4,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE // or 0x24
+	0x02,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x00,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char PALNC_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0xf4,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+	0x02,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x01,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+static int bt865_update( struct i2c_client *client )
+{
+	struct bt865_data_s *data = i2c_get_clientdata(client);
+	char tmpconfig[48];
+	int i;
+
+	if (memcpy(tmpconfig, data->config, data->configlen) != tmpconfig) {
+		printk(KERN_NOTICE "bt865_update: memcpy error\n");
+		return -1;
+	}
+
+	if (data->bars) {
+		tmpconfig[23] |= 0x10;
+	}
+
+	if (data->enableoutput) {
+		tmpconfig[23] |= 0x02;
+	}
+
+	if (data->rgbmode) {
+		tmpconfig[23] |= 0x40;
+	}
+
+	for (i = 0; i < data->configlen; i++) {
+		i2c_smbus_write_byte_data(client, 2 * i + 0xA0, tmpconfig[i]);
+	}
+
+	return 0;
+}
+
+static int bt865_setmode(int mode, struct i2c_client *client)
+{
+	struct bt865_data_s *data = i2c_get_clientdata(client);
+	unsigned char *config = NULL;
+
+	pr_debug("bt865_setmode( %d, %p )\n", mode, client);
+
+	switch (mode) {
+	case ENCODER_MODE_NTSC:
+		printk(KERN_NOTICE "bt865.o: Configuring for NTSC\n");
+		config = NTSC_CONFIG_BT865;
+		data->configlen = sizeof(NTSC_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_NTSC60:
+		printk(KERN_NOTICE "bt865.o: Configuring for NTSC\n");
+		config = NTSC60_CONFIG_BT865;
+		data->configlen = sizeof(NTSC60_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_PAL_M:
+		printk(KERN_NOTICE "bt865.o: Configuring for PAL_M\n");
+		config = PALM_CONFIG_BT865;
+		data->configlen = sizeof(PALM_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_PALM60:
+		printk(KERN_NOTICE "bt865.o: Configuring for PAL_M60\n");
+		config = PALM60_CONFIG_BT865;
+		data->configlen = sizeof(PALM60_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_PAL:
+		printk(KERN_NOTICE "bt865.o: Configuring for PAL\n");
+		config = PAL_CONFIG_BT865;
+		data->configlen = sizeof(PAL_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_PALNC:
+		printk(KERN_NOTICE "bt865.o: Configuring for PAL\n");
+		config = PALNC_CONFIG_BT865;
+		data->configlen = sizeof(PALNC_CONFIG_BT865);
+		break;
+	default:
+		return -1;
+	}
+
+	data->mode = mode;
+
+	if (config) {
+		if (memcpy(data->config, config, data->configlen) != data->config) {
+			printk(KERN_NOTICE "bt865_setmode: memcpy error\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int bt865_setup(struct i2c_client *client)
+{
+	struct bt865_data_s *data = i2c_get_clientdata(client);
+	struct em8300_s *em = i2c_get_adapdata(client->adapter);
+
+	if (memset(data->config, 0, sizeof(data->config)) != data->config) {
+		printk(KERN_NOTICE "bt865_setup: memset error\n");
+		return -1;
+	}
+
+	data->bars = color_bars[em->card_nr];
+	data->rgbmode = rgb_mode[em->card_nr];
+	data->enableoutput = 0;
+
+	if (EM8300_VIDEOMODE_DEFAULT == EM8300_VIDEOMODE_PAL) {
+		printk(KERN_NOTICE "bt865.o: Defaulting to PAL\n");
+		bt865_setmode(ENCODER_MODE_PAL, client);
+	} else if (EM8300_VIDEOMODE_DEFAULT == EM8300_VIDEOMODE_NTSC) {
+		printk(KERN_NOTICE "bt865.o: Defaulting to NTSC\n");
+		bt865_setmode(ENCODER_MODE_NTSC, client);
+	}
+
+	if (bt865_update(client)) {
+		printk(KERN_NOTICE "bt865_setup: bt865_update error\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int bt865_detect(struct i2c_adapter *adapter, int address)
+{
+	struct bt865_data_s *data;
+	struct i2c_client *new_client;
+	int err, chk = 0;
+
+	chk = i2c_check_functionality(adapter,
+			I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA);
+
+	if (!chk) {
+		return 0;
+	}
+
+	new_client = kmalloc(sizeof(struct i2c_client) + sizeof(struct bt865_data_s),
+			GFP_KERNEL);
+
+	if (!new_client) {
+		return -ENOMEM;
+	}
+	memset(new_client, 0, sizeof(struct i2c_client) + sizeof(struct bt865_data_s));
+	data = (struct bt865_data_s *) (((struct i2c_client *) new_client) + 1);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &bt865_driver;
+	new_client->flags = 0;
+
+	i2c_set_clientdata(new_client, data);
+
+//	i2c_smbus_write_byte_data(new_client,0xa6, 0x80/*b1*/);
+//	the write is not needed
+//	from the left we have three bits identifying the chip
+//	which is a 4 (100) for the bt864 and a 5 (101) for the bt865
+//  followed by 5 bits for the version number. in this case 17 (1 0001)
+//	thus 1011 0001 (0xb1) is correct for the bt865a version 17
+	if (i2c_smbus_read_byte_data(new_client, 0) == 0xb1) {
+		strcpy(new_client->name, "BT865 chip");
+		printk(KERN_NOTICE "bt865.o: BT865 chip detected\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+		new_client->id = bt865_id++;
+#endif
+
+		if ((err = i2c_attach_client(new_client))) {
+			kfree(new_client);
+			return err;
+		}
+
+		if (bt865_setup(new_client)) {
+			return -1;
+		}
+
+		EM8300_MOD_INC_USE_COUNT;
+
+		return 0;
+	}
+
+	kfree(new_client);
+	return 0;
+}
+
+static int bt865_attach_adapter(struct i2c_adapter *adapter)
+{
+	bt865_detect(adapter, 0x45);
+	return 0;
+}
+
+
+int bt865_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	if ((err = i2c_detach_client(client))) {
+		printk(KERN_ERR "bt865.o: Client deregistration failed, client not detached.\n");
+		return err;
+	}
+
+	EM8300_MOD_DEC_USE_COUNT;
+
+	kfree(client);
+
+	return 0;
+}
+
+int bt865_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	struct bt865_data_s *data = i2c_get_clientdata(client);
+
+	switch(cmd) {
+	case ENCODER_CMD_SETMODE:
+		bt865_setmode((long int) arg, client);
+		bt865_update(client);
+		break;
+	case ENCODER_CMD_ENABLEOUTPUT:
+		data->enableoutput = (long int) arg;
+		bt865_update(client);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+
+int __init bt865_init(void)
+{
+	int i;
+	for (i=0; i < EM8300_MAX; i++)
+		if ((output_mode[i]) && (output_mode[i][0])) {
+			if (strcmp(output_mode[i], "comp+svideo") == 0) {
+				rgb_mode[i] = 0;
+			} else if (strcmp(output_mode[i], "rgb") == 0) {
+				rgb_mode[i] = 1;
+			} else {
+				printk(KERN_WARNING "bt865: Unknown output mode: %s\n", output_mode[i]);
+			}
+		}
+	//request_module("i2c-algo-bit");
+	return i2c_add_driver(&bt865_driver);
+}
+
+void __exit bt865_cleanup(void)
+{
+	i2c_del_driver(&bt865_driver);
+}
+
+module_init(bt865_init);
+module_exit(bt865_cleanup);
+
diff -Naurdp a/drivers/media/video/em3800/bt865.h b/drivers/media/video/em3800/bt865.h
--- a/drivers/media/video/em3800/bt865.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/bt865.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,3 @@
+#if !defined(I2C_DRIVERID_BT865)
+#define I2C_DRIVERID_BT865 0xf001
+#endif
diff -Naurdp a/drivers/media/video/em3800/em8300_audio.c b/drivers/media/video/em3800/em8300_audio.c
--- a/drivers/media/video/em3800/em8300_audio.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_audio.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,657 @@
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <linux/soundcard.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+#include "em8300_fifo.h"
+
+#ifndef AFMT_AC3
+#define AFMT_AC3 0x00000400
+#endif
+
+#include <asm/byteorder.h>
+
+int em8300_audio_calcbuffered(struct em8300_s *em);
+static int set_audiomode(struct em8300_s *em, int mode);
+
+/* C decompilation of sub_prepare_SPDIF by
+*  Anton Altaparmakov <antona@bigfoot.com>
+*
+*  If outblock == inblock generate mute pattern.
+*
+* Notes:
+*  local1 = "in" = current inblock position pointer.
+*  local3 = "i" = for loop counter.
+*  Need unsigned everywhere, otherwise get into trouble with signed shift rights!
+*/
+
+void sub_prepare_SPDIF(struct em8300_s *em, unsigned char *outblock, unsigned char *inblock, unsigned int inlength)
+{
+	//	ebp-4 = local1 = in	ebp-8 = local2
+	//	ebp-0ch = local3 = i	ebp-10h = local4
+
+	unsigned char *in; // 32 bit points to array of 8 bit chars
+	unsigned short int local2; // 16 bit, unsigned
+	unsigned int i; // 32 bit, signed
+	unsigned char local4; // 8 bit, unsigned
+	unsigned char mutepattern[] = {0x00, 0x00};
+	int mute;
+
+	mute = (inblock == outblock) ? 1 : 0;
+	in = (mute) ? mutepattern : inblock;
+
+	for (i = 0; i < (inlength >> 2); i++) {
+		if (em->dword_DB4 == 0xc0) {
+			em->dword_DB4 = 0;
+		}
+
+		{
+			register int ebx;
+			if (em->dword_DB4 < 0) {
+				ebx = em->byte_D90[(em->dword_DB4 + 7) >> 3] & 0xff << (!((!em->dword_DB4 + 1) & 7) + 1) & 0xff;
+			} else {
+				ebx = (em->byte_D90[em->dword_DB4 >> 3] & 0xff) << (em->dword_DB4 & 7);
+			}
+			local4 = (unsigned char) ((ebx & 0x80) >> 1);
+		}
+
+		local2 = in[0] << 8 | in[1];
+		if (!mute)
+			in +=2;
+
+		if (em->dword_DB4 != 0) {
+			outblock[i * 8 + 3] = 2;
+		} else {
+			outblock[i * 8 + 3] = 0;
+		}
+
+		outblock[i * 8 + 2] = local2 << 4;
+		outblock[i * 8 + 1] = local2 >> 4;
+		outblock[i * 8] = local2 >> 12 | local4;
+
+		local2 = in[0] << 8 | in[1];
+		if (!mute)
+			in +=2;
+
+		outblock[i * 8 + 7] = 1;
+		outblock[i * 8 + 6] = local2 << 4;
+		outblock[i * 8 + 5] = local2 >> 4;
+		outblock[i * 8 + 4] = local2 >> 12 | local4;
+
+		++em->dword_DB4;
+	}
+
+	return;
+}
+
+static void preprocess_analog(struct em8300_s *em, unsigned char *outbuf, const unsigned char *inbuf_user, int inlength)
+{
+	int i;
+
+	if (em->audio.format == AFMT_S16_LE) {
+		if (em->audio.channels == 2) {
+			for (i = 0; i < inlength; i += 4) {
+				get_user(outbuf[i + 3], inbuf_user++);
+				get_user(outbuf[i + 2], inbuf_user++);
+				get_user(outbuf[i + 1], inbuf_user++);
+				get_user(outbuf[i + 0], inbuf_user++);
+			}
+		} else {
+			for (i = 0; i < inlength; i += 2) {
+				get_user(outbuf[2 * i + 1], inbuf_user++);
+				get_user(outbuf[2 * i + 0], inbuf_user++);
+				outbuf[2 * i + 3] = outbuf[2 * i + 1];
+				outbuf[2 * i + 2] = outbuf[2 * i + 0];
+			}
+		}
+	} else {
+		if (em->audio.channels == 2) {
+			for (i = 0; i < inlength; i += 4) {
+				get_user(outbuf[i + 2], inbuf_user++);
+				get_user(outbuf[i + 3], inbuf_user++);
+				get_user(outbuf[i + 0], inbuf_user++);
+				get_user(outbuf[i + 1], inbuf_user++);
+			}
+		} else {
+			for (i = 0; i < inlength; i += 2) {
+				get_user(outbuf[2 * i + 0], inbuf_user++);
+				get_user(outbuf[2 * i + 1], inbuf_user++);
+				outbuf[2 * i + 2] = outbuf[2 * i + 0];
+				outbuf[2 * i + 3] = outbuf[2 * i + 1];
+			}
+		}
+	}
+}
+
+static void preprocess_digital(struct em8300_s *em, unsigned char *outbuf,
+			       const unsigned char *inbuf_user, int inlength)
+{
+	int i;
+
+	if (!em->mafifo->preprocess_buffer)
+		return;
+
+        if (em->audio.format == AFMT_S16_LE ||
+	    em->audio.format == AFMT_AC3) {
+		if (em->audio.channels == 2) {
+			for(i = 0; i < inlength; i += 2) {
+				get_user(em->mafifo->preprocess_buffer[i + 1], inbuf_user++);
+				get_user(em->mafifo->preprocess_buffer[i + 0], inbuf_user++);
+			}
+		} else {
+			for(i = 0; i < inlength; i += 2) {
+				get_user(em->mafifo->preprocess_buffer[2 * i + 1], inbuf_user++);
+				get_user(em->mafifo->preprocess_buffer[2 * i + 0], inbuf_user++);
+				em->mafifo->preprocess_buffer[2 * i + 3] = em->mafifo->preprocess_buffer[2 * i + 1];
+				em->mafifo->preprocess_buffer[2 * i + 2] = em->mafifo->preprocess_buffer[2 * i + 0];
+			}
+			inlength *= 2; /* ensure correct size for sub_prepare_SPDIF */
+		}
+	} else {
+		if (em->audio.channels == 2) {
+			(void)copy_from_user(em->mafifo->preprocess_buffer, inbuf_user, inlength);
+		} else {
+			for(i = 0; i < inlength; i += 2) {
+				get_user(em->mafifo->preprocess_buffer[2 * i + 0], inbuf_user++);
+				get_user(em->mafifo->preprocess_buffer[2 * i + 1], inbuf_user++);
+				em->mafifo->preprocess_buffer[2 * i + 2] = em->mafifo->preprocess_buffer[2 * i + 0];
+				em->mafifo->preprocess_buffer[2 * i + 3] = em->mafifo->preprocess_buffer[2 * i + 1];
+			}
+			inlength *= 2; /* ensure correct size for sub_prepare_SPDIF */
+		}
+	}
+
+	sub_prepare_SPDIF(em,outbuf, em->mafifo->preprocess_buffer, inlength);
+}
+
+static void setup_mafifo(struct em8300_s *em)
+{
+	if (em->audio_mode == EM8300_AUDIOMODE_ANALOG) {
+		em->mafifo->preprocess_ratio = ((em->audio.channels == 2) ? 1 : 2);
+		em->mafifo->preprocess_cb = &preprocess_analog;
+	} else {
+		em->mafifo->preprocess_ratio = ((em->audio.channels == 2) ? 2 : 4);
+		em->mafifo->preprocess_cb = &preprocess_digital;
+	}
+}
+
+int mpegaudio_command(struct em8300_s *em, int cmd)
+{
+	em8300_waitfor(em, ucregister(MA_Command), 0xffff, 0xffff);
+
+	pr_debug("MA_Command: %d\n", cmd);
+	write_ucregister(MA_Command, cmd);
+
+	return em8300_waitfor(em, ucregister(MA_Status), cmd, 0xffff);
+}
+
+static int audio_start(struct em8300_s *em)
+{
+	em->irqmask |= IRQSTATUS_AUDIO_FIFO;
+	write_ucregister(Q_IrqMask, em->irqmask);
+	em->audio.enable_bits = PCM_ENABLE_OUTPUT;
+	return mpegaudio_command(em, MACOMMAND_PLAY);
+}
+
+static int audio_stop(struct em8300_s *em)
+{
+	em->irqmask &= ~IRQSTATUS_AUDIO_FIFO;
+	write_ucregister(Q_IrqMask, em->irqmask);
+	em->audio.enable_bits = 0;
+	return mpegaudio_command(em, MACOMMAND_STOP);
+}
+
+static int set_speed(struct em8300_s *em, int speed)
+{
+	em->clockgen &= ~CLOCKGEN_SAMPFREQ_MASK;
+
+	switch (speed) {
+	case 48000:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_48;
+		break;
+	case 44100:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_44;
+		break;
+	case 66000:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_66;
+		break;
+	case 32000:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_32;
+		break;
+	default:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_48;
+		speed = 48000;
+	}
+
+	em->audio.speed = speed;
+
+	em8300_clockgen_write(em, em->clockgen);
+
+	return speed;
+}
+
+static int set_channels(struct em8300_s *em, int val)
+{
+	if (val > 2) val = 2;
+	em->audio.channels = val;
+	setup_mafifo(em);
+
+	return val;
+}
+
+static int set_format(struct em8300_s *em, int fmt)
+{
+	if (fmt != AFMT_QUERY) {
+		switch (fmt) {
+#ifdef AFMT_AC3
+		case AFMT_AC3:
+			if (em->audio_mode != EM8300_AUDIOMODE_DIGITALAC3) {
+				set_speed(em, 48000);
+				set_audiomode(em, EM8300_AUDIOMODE_DIGITALAC3);
+				setup_mafifo(em);
+			}
+			em->audio.format = fmt;
+			break;
+#endif
+		case AFMT_S16_BE:
+		case AFMT_S16_LE:
+			if (em->audio_mode == EM8300_AUDIOMODE_DIGITALAC3) {
+				set_audiomode(em, em->pcm_mode);
+				setup_mafifo(em);
+			}
+			em->audio.format = fmt;
+			break;
+		default:
+			if (em->audio_mode == EM8300_AUDIOMODE_DIGITALAC3) {
+				set_audiomode(em, em->pcm_mode);
+				setup_mafifo(em);
+			}
+			fmt = AFMT_S16_BE;
+			break;
+		}
+	}
+	return em->audio.format;
+}
+
+int em8300_audio_ioctl(struct em8300_s *em,unsigned int cmd, unsigned long arg)
+{
+	int len = 0;
+	int val = 0;
+
+	if (_SIOC_DIR(cmd) != _SIOC_NONE && _SIOC_DIR(cmd) != 0) {
+		/*
+		 * Have to validate the address given by the process.
+		 */
+		len = _SIOC_SIZE(cmd);
+		if (len < 1 || len > 65536 || arg == 0) {
+			return -EFAULT;
+		}
+		if (_SIOC_DIR(cmd) & _SIOC_WRITE) {
+			if (!access_ok(VERIFY_READ, (void *) arg, len)) {
+				return -EFAULT;
+			}
+		}
+		if (_SIOC_DIR(cmd) & _SIOC_READ) {
+			if (!access_ok(VERIFY_WRITE, (void *) arg, len)) {
+				return -EFAULT;
+			}
+		}
+	}
+
+	switch (cmd) {
+	case SNDCTL_DSP_RESET: /* reset device */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_RESET\n");
+		em8300_audio_flush(em);
+		return 0;
+
+	case SNDCTL_DSP_SYNC:  /* wait until last byte is played and reset device */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SYNC\n");
+		em8300_fifo_sync(em->mafifo);
+		return 0;
+
+	case SNDCTL_DSP_SPEED: /* set sample rate */
+		if (get_user(val, (int *) arg)) {
+			return -EFAULT;
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SPEED %i ", val);
+		val = set_speed(em, val);
+		pr_debug("%i\n", val);
+		break;
+
+	case SOUND_PCM_READ_RATE: /* read sample rate */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_RATE %i ", val);
+		val = em->audio.speed;
+		pr_debug("%i\n", val);
+		break;
+
+	case SNDCTL_DSP_STEREO: /* set stereo or mono mode */
+		if (get_user(val, (int *) arg)) {
+			return -EFAULT;
+		}
+		if (val > 1 || val < 0) {
+			return -EINVAL;
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_STEREO %i\n", val);
+		set_channels(em, val + 1);
+		break;
+
+	case SNDCTL_DSP_GETBLKSIZE: /* get fragment size */
+		val = em->audio.slotsize;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETBLKSIZE %i\n", val);
+		break;
+
+	case SNDCTL_DSP_CHANNELS: /* set number of channels */
+		if (get_user(val, (int *) arg)) {
+			return -EFAULT;
+		}
+		if (val > 2 || val < 1) {
+			return -EINVAL;
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_CHANNELS %i\n", val);
+		set_channels(em, val);
+		break;
+
+	case SOUND_PCM_READ_CHANNELS: /* read number of channels */
+		val = em->audio.channels;
+		pr_debug("em8300_audio.o: SOUND_PCM_READ_CHANNELS %i\n", val);
+		break;
+
+	case SNDCTL_DSP_POST: /* "there is likely to be a pause in the output" */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_POST\n");
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETPOST not implemented yet\n");
+		return -ENOSYS;
+		break;
+
+	case SNDCTL_DSP_SETFRAGMENT: /* set fragment size */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SETFRAGMENT %i\n", val);
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SETFRAGMENT not supported by hardware!\n");
+		break;
+
+	case SNDCTL_DSP_GETFMTS: /* get possible formats */
+#ifdef AFMT_AC3
+		val = AFMT_AC3 | AFMT_S16_BE | AFMT_S16_LE;
+#else
+		val = AFMT_S16_BE | AFMT_S16_LE;
+#endif
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETFMTS\n");
+		break;
+
+	case SNDCTL_DSP_SETFMT: /* set sample format */
+		if (get_user(val, (int *) arg)) {
+			return -EFAULT;
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SETFMT %i ", val);
+		val = set_format(em, val);
+		pr_debug("%i\n", val);
+		break;
+
+	case SOUND_PCM_READ_BITS: /* read sample format */
+		val = em->audio.format;
+		pr_debug("em8300_audio.o: SOUND_PCM_READ_BITS\n");
+		break;
+
+	case SNDCTL_DSP_GETOSPACE:
+	{
+		audio_buf_info buf_info;
+		switch(em->audio_mode)
+		{
+			case EM8300_AUDIOMODE_ANALOG:
+				buf_info.fragments=
+					em8300_fifo_freeslots(em->mafifo) -
+					em->mafifo->nslots / 2;
+				break;
+			default:
+				buf_info.fragments=
+					em8300_fifo_freeslots(em->mafifo) / 2;
+				break;
+		}
+		buf_info.fragments = (buf_info.fragments > 0) ? buf_info.fragments : 0;
+		buf_info.fragstotal = em->mafifo->nslots / 2;
+		buf_info.fragsize = em->audio.slotsize;
+		buf_info.bytes = em->mafifo->nslots * em->audio.slotsize / 2;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETOSPACE\n");
+		if (copy_to_user((void *) arg, &buf_info, sizeof(audio_buf_info)))
+			return -EFAULT;
+		return 0;
+	}
+
+	case SNDCTL_DSP_GETISPACE:
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETISPACE\n");
+		return -ENOSYS;
+		break;
+
+	case SNDCTL_DSP_GETCAPS:
+		val = DSP_CAP_REALTIME | DSP_CAP_BATCH | DSP_CAP_TRIGGER;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETCAPS\n");
+		break;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = em->audio.enable_bits;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETTRIGGER\n");
+		break;
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (val & PCM_ENABLE_OUTPUT) {
+			if (em->audio.enable_bits & PCM_ENABLE_OUTPUT) {
+				em->audio.enable_bits |= PCM_ENABLE_OUTPUT;
+				mpegaudio_command(em, MACOMMAND_PLAY);
+			}
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SETTRIGGER\n");
+		pr_info("em8300_audio.o: SNDCTL_DSP_SETTRIGGER not implemented properly yet\n");
+		break;
+
+	case SNDCTL_DSP_GETIPTR:
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETIPTR\n");
+		return -ENOSYS;
+		break;
+
+	case SNDCTL_DSP_GETOPTR:
+	{
+		count_info ci;
+		ci.bytes = em->mafifo->bytes - em8300_audio_calcbuffered(em);
+		if (ci.bytes < 0) ci.bytes = 0;
+		ci.blocks = 0;
+		ci.ptr = 0;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETOPTR %i\n", ci.bytes);
+		if (copy_to_user((void *) arg, &ci, sizeof(count_info)))
+			return -EFAULT;
+		return 0;
+	}
+	case SNDCTL_DSP_GETODELAY:
+		val = em8300_audio_calcbuffered(em);
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETODELAY %i\n", val);
+		break;
+
+	default:
+		pr_info("em8300_audio.o: unknown ioctl called\n");
+		return -EINVAL;
+	}
+
+	return put_user(val, (int *) arg);
+}
+
+int em8300_audio_flush(struct em8300_s *em)
+{
+	int pcirdptr = read_ucregister(MA_PCIRdPtr);
+	write_ucregister(MA_PCIWrPtr, pcirdptr);
+	writel(readl(em->mafifo->readptr), em->mafifo->writeptr);
+	em8300_fifo_sync(em->mafifo);
+	return 0;
+}
+
+int em8300_audio_open(struct em8300_s *em)
+{
+	em8300_require_ucode(em);
+
+	if (!em->ucodeloaded) {
+		return -ENODEV;
+	}
+
+	em->mafifo->bytes = 0;
+
+	return audio_start(em);
+}
+
+int em8300_audio_release(struct em8300_s *em)
+{
+	em8300_fifo_sync(em->mafifo);
+	em8300_audio_flush(em);
+	return audio_stop(em);
+}
+
+static int set_audiomode(struct em8300_s *em, int mode)
+{
+	em->audio_mode = mode;
+
+	em->clockgen &= ~CLOCKGEN_OUTMASK;
+
+	if (em->audio_mode == EM8300_AUDIOMODE_ANALOG) {
+		em->clockgen |= CLOCKGEN_ANALOGOUT;
+	} else {
+		em->clockgen |= CLOCKGEN_DIGITALOUT;
+	}
+
+	em8300_clockgen_write(em, em->clockgen);
+
+	memset(em->byte_D90, 0, sizeof(em->byte_D90));
+
+	em->byte_D90[1] = 0x98;
+
+	switch (em->audio.speed) {
+	case 32000:
+		em->byte_D90[3] = 0xc0;
+		break;
+	case 44100:
+		em->byte_D90[3] = 0;
+		break;
+	case 48000:
+		em->byte_D90[3] = 0x40;
+		break;
+	}
+
+	switch (em->audio_mode) {
+	case EM8300_AUDIOMODE_ANALOG:
+		em->pcm_mode = EM8300_AUDIOMODE_ANALOG;
+
+		write_register(EM8300_AUDIO_RATE, 0x62);
+		em8300_setregblock(em, 2 * ucregister(Mute_Pattern), 0, 0x600);
+		printk(KERN_NOTICE "em8300_audio.o: Analog audio enabled\n");
+		break;
+	case EM8300_AUDIOMODE_DIGITALPCM:
+		em->pcm_mode = EM8300_AUDIOMODE_DIGITALPCM;
+
+		write_register(EM8300_AUDIO_RATE, 0x3a0);
+
+		em->byte_D90[0] = 0x0;
+		sub_prepare_SPDIF(em, em->mafifo->preprocess_buffer, em->mafifo->preprocess_buffer, 0x300);
+
+		em8300_writeregblock(em, 2*ucregister(Mute_Pattern), (unsigned *)em->mafifo->preprocess_buffer, em->mafifo->slotsize);
+
+		printk(KERN_NOTICE "em8300_audio.o: Digital PCM audio enabled\n");
+		break;
+	case EM8300_AUDIOMODE_DIGITALAC3:
+		write_register(EM8300_AUDIO_RATE, 0x3a0);
+
+		em->byte_D90[0] = 0x40;
+		sub_prepare_SPDIF(em, em->mafifo->preprocess_buffer, em->mafifo->preprocess_buffer, 0x300);
+
+		em8300_writeregblock(em, 2*ucregister(Mute_Pattern), (unsigned *)em->mafifo->preprocess_buffer, em->mafifo->slotsize);
+		printk(KERN_NOTICE "em8300_audio.o: Digital AC3 audio enabled\n");
+		break;
+	}
+	return 0;
+}
+
+int em8300_audio_setup(struct em8300_s *em)
+{
+	int ret;
+
+	em->audio.channels = 2;
+	em->audio.format = AFMT_S16_NE;
+	em->audio.slotsize = em->mafifo->slotsize;
+
+	em->clockgen = em->clockgen_tvmode;
+
+	set_speed(em, 48000);
+
+	set_audiomode(em, EM8300_AUDIOMODE_DEFAULT);
+
+	ret = em8300_audio_flush(em);
+
+	setup_mafifo(em);
+
+	if (ret) {
+		printk(KERN_ERR "em8300_audio.o: Couldn't zero audio buffer\n");
+		return ret;
+	}
+
+	write_ucregister(MA_Threshold, 6);
+
+	mpegaudio_command(em, MACOMMAND_PLAY);
+	mpegaudio_command(em, MACOMMAND_PAUSE);
+
+	em->audio.enable_bits = 0;
+
+	return 0;
+}
+
+int em8300_audio_calcbuffered(struct em8300_s *em)
+{
+	int readptr, writeptr, bufsize, n;
+
+	readptr = read_ucregister(MA_Rdptr) | (read_ucregister(MA_Rdptr_Hi) << 16);
+	writeptr = read_ucregister(MA_Wrptr) | (read_ucregister(MA_Wrptr_Hi) << 16);
+	bufsize = read_ucregister(MA_BuffSize) | (read_ucregister(MA_BuffSize_Hi) << 16);
+
+	n = ((bufsize+writeptr-readptr) % bufsize);
+
+	return (em8300_fifo_calcbuffered(em->mafifo) + n) /
+		em->mafifo->preprocess_ratio;
+}
+
+ssize_t em8300_audio_write(struct em8300_s *em, const char * buf, size_t count, loff_t *ppos)
+{
+	if (em->nonblock[1]) {
+		return em8300_fifo_write(em->mafifo, count, buf, 0);
+	} else {
+		return em8300_fifo_writeblocking(em->mafifo, count, buf, 0);
+	}
+}
+
+/* 18-09-2000 - Ze'ev Maor - added these two ioctls to set and get audio mode. */
+
+int em8300_ioctl_setaudiomode(struct em8300_s *em, int mode)
+{
+	em8300_audio_flush(em);
+	set_audiomode(em, mode);
+	setup_mafifo(em);
+	mpegaudio_command(em, MACOMMAND_PLAY);
+	em->audio.enable_bits = PCM_ENABLE_OUTPUT;
+	return 0;
+}
+
+int em8300_ioctl_getaudiomode(struct em8300_s *em, long int mode)
+{
+	int a = em->audio_mode;
+	if (copy_to_user((void *) mode, &a, sizeof(int)))
+		return -EFAULT;
+	return 0;
+}
diff -Naurdp a/drivers/media/video/em3800/em8300_compat24.h b/drivers/media/video/em3800/em8300_compat24.h
--- a/drivers/media/video/em3800/em8300_compat24.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_compat24.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,142 @@
+/* $Id: em8300_compat24.h,v 1.4 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_compat24.h -- compatibility layer for 2.4 and some 2.5 kernels
+ * Copyright (C) 2004 Andreas Schultz <aschultz@warp10.net>
+ * Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+ * Copyright (C) 2005 Jon Burgess <jburgess@uklinux.net>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _EM8300_COMPAT24_H_
+#define _EM8300_COMPAT24_H_
+
+/* Interrupt handler backwards compatibility stuff */
+#ifndef IRQ_NONE
+#define IRQ_NONE
+#define IRQ_HANDLED
+typedef void irqreturn_t;
+#endif
+
+/* i2c stuff */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,67)
+static inline void *i2c_get_clientdata(struct i2c_client *dev)
+{
+	return dev->data;
+}
+
+static inline void i2c_set_clientdata(struct i2c_client *dev, void *data)
+{
+	dev->data = data;
+}
+
+static inline void *i2c_get_adapdata(struct i2c_adapter *dev)
+{
+	return dev->data;
+}
+
+static inline void i2c_set_adapdata(struct i2c_adapter *dev, void *data)
+{
+	dev->data = data;
+}
+#endif
+
+/* modules */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,48)
+#define EM8300_MOD_INC_USE_COUNT MOD_INC_USE_COUNT
+#define EM8300_MOD_DEC_USE_COUNT MOD_DEC_USE_COUNT
+#else
+#define EM8300_MOD_INC_USE_COUNT do { } while(0)
+#define EM8300_MOD_DEC_USE_COUNT do { } while(0)
+#endif
+
+#if !defined(MODULE_LICENSE)
+#define MODULE_LICENSE(_license)
+#endif
+
+#if !defined(MODULE_ALIAS_CHARDEV_MAJOR)
+#define MODULE_ALIAS_CHARDEV_MAJOR(major)
+#endif
+
+#if !defined(EXPORT_NO_SYMBOLS)
+#define EXPORT_NO_SYMBOLS
+#endif
+
+/* EM8300_IMINOR */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,2) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define EM8300_IMINOR(inode) (MINOR((inode)->i_rdev))
+#else
+#define EM8300_IMINOR(inode) (minor((inode)->i_rdev))
+#endif
+
+#ifdef _LINUX_WAIT_H
+
+/* Macros backported from linux-2.6/include/linux/wait.h */
+
+#ifndef __wait_event_interruptible_timeout
+#define __wait_event_interruptible_timeout(wq, condition, ret)		\
+do {									\
+	wait_queue_t __wait;						\
+	init_waitqueue_entry(&__wait, current);				\
+									\
+	add_wait_queue(&wq, &__wait);					\
+	for (;;) {							\
+		set_current_state(TASK_INTERRUPTIBLE);			\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			ret = schedule_timeout(ret);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	current->state = TASK_RUNNING;					\
+	remove_wait_queue(&wq, &__wait);				\
+} while (0)
+#endif
+
+/**
+ * wait_event_interruptible_timeout - sleep until a condition gets true or a timeout elapses
+ * @wq: the waitqueue to wait on
+ * @condition: a C expression for the event to wait for
+ * @timeout: timeout, in jiffies
+ *
+ * The process is put to sleep (TASK_INTERRUPTIBLE) until the
+ * @condition evaluates to true or a signal is received.
+ * The @condition is checked each time the waitqueue @wq is woken up.
+ *
+ * wake_up() has to be called after changing any variable that could
+ * change the result of the wait condition.
+ *
+ * The function returns 0 if the @timeout elapsed, -ERESTARTSYS if it
+ * was interrupted by a signal, and the remaining jiffies otherwise
+ * if the condition evaluated to true before the timeout elapsed.
+ */
+#ifndef wait_event_interruptible_timeout
+#define wait_event_interruptible_timeout(wq, condition, timeout)	\
+({									\
+	long __ret = timeout;						\
+	if (!(condition))						\
+		__wait_event_interruptible_timeout(wq, condition, __ret); \
+	__ret;								\
+})
+#endif
+
+#endif /* _LINUX_WAIT_H */
+
+#endif /* _EM8300_COMPAT24_H_ */
diff -Naurdp a/drivers/media/video/em3800/em8300_devfs.c b/drivers/media/video/em3800/em8300_devfs.c
--- a/drivers/media/video/em3800/em8300_devfs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_devfs.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,116 @@
+/*
+	em8300.c - EM8300 MPEG-2 decoder device driver
+
+	Copyright (C) 2000 Henrik Johansson <henrikjo@post.utfors.se>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+#include <linux/config.h>
+#include "em8300_devfs.h"
+#include <linux/devfs_fs_kernel.h>
+
+#ifdef CONFIG_DEVFS_FS
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,70)
+devfs_handle_t em8300_handle[EM8300_MAX*4];
+#endif
+
+extern struct file_operations em8300_fops;
+
+static void em8300_devfs_register_card(struct em8300_s *em)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,70)
+	char devname[64];
+	sprintf(devname, "%s-%d", EM8300_LOGNAME, em->card_nr );
+	em8300_handle[em->card_nr * 4] = devfs_register(NULL, devname, DEVFS_FL_DEFAULT, major,
+							em->card_nr * 4, S_IFCHR | S_IRUGO | S_IWUGO, &em8300_fops, NULL);
+#else
+	devfs_mk_cdev(MKDEV(major, em->card_nr * 4),
+		      S_IFCHR | S_IRUGO | S_IWUGO,
+		      "%s-%d", EM8300_LOGNAME, em->card_nr);
+#endif
+}
+
+static void em8300_devfs_enable_card(struct em8300_s *em)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,70)
+	char devname[64];
+	sprintf(devname, "%s_mv-%d", EM8300_LOGNAME, em->card_nr );
+	em8300_handle[(em->card_nr * 4) + 1] = devfs_register(NULL, devname, DEVFS_FL_DEFAULT, major,
+							      (em->card_nr * 4) + 1, S_IFCHR | S_IRUGO | S_IWUGO, &em8300_fops, NULL);
+	sprintf(devname, "%s_ma-%d", EM8300_LOGNAME, em->card_nr );
+	em8300_handle[(em->card_nr * 4) + 2] = devfs_register(NULL, devname, DEVFS_FL_DEFAULT, major,
+							      (em->card_nr * 4) + 2, S_IFCHR | S_IRUGO | S_IWUGO, &em8300_fops, NULL);
+	sprintf(devname, "%s_sp-%d", EM8300_LOGNAME, em->card_nr );
+	em8300_handle[(em->card_nr * 4) + 3] = devfs_register(NULL, devname, DEVFS_FL_DEFAULT, major,
+							      (em->card_nr * 4) + 3, S_IFCHR | S_IRUGO | S_IWUGO, &em8300_fops, NULL);
+#else
+	devfs_mk_cdev(MKDEV(major, (em->card_nr * 4) + 1),
+		      S_IFCHR | S_IRUGO | S_IWUGO,
+		      "%s_mv-%d", EM8300_LOGNAME, em->card_nr);
+	devfs_mk_cdev(MKDEV(major, (em->card_nr * 4) + 2),
+		      S_IFCHR | S_IRUGO | S_IWUGO,
+		      "%s_ma-%d", EM8300_LOGNAME, em->card_nr);
+	devfs_mk_cdev(MKDEV(major, (em->card_nr * 4) + 3),
+		      S_IFCHR | S_IRUGO | S_IWUGO,
+		      "%s_sp-%d", EM8300_LOGNAME, em->card_nr);
+#endif
+}
+
+static void em8300_devfs_disable_card(struct em8300_s *em)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,69)
+	devfs_unregister(em8300_handle[(em->card_nr * 4) + 1]);
+	devfs_unregister(em8300_handle[(em->card_nr * 4) + 2]);
+	devfs_unregister(em8300_handle[(em->card_nr * 4) + 3]);
+#else
+	devfs_remove("%s_mv-%d", EM8300_LOGNAME, em->card_nr);
+	devfs_remove("%s_ma-%d", EM8300_LOGNAME, em->card_nr);
+	devfs_remove("%s_sp-%d", EM8300_LOGNAME, em->card_nr);
+#endif
+}
+
+static void em8300_devfs_unregister_card(struct em8300_s *em)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,69)
+	devfs_unregister(em8300_handle[em->card_nr * 4]);
+#else
+	devfs_remove("%s-%d", EM8300_LOGNAME, em->card_nr);
+#endif
+}
+
+struct em8300_registrar_s em8300_devfs_registrar =
+{
+	.register_driver   = NULL,
+	.register_card     = &em8300_devfs_register_card,
+	.enable_card       = &em8300_devfs_enable_card,
+	.disable_card      = &em8300_devfs_disable_card,
+	.unregister_card   = &em8300_devfs_unregister_card,
+	.unregister_driver = NULL,
+};
+
+#else /* CONFIG_DEVFS_FS */
+
+struct em8300_registrar_s em8300_devfs_registrar =
+{
+	.register_driver   = NULL,
+	.register_card     = NULL,
+	.enable_card       = NULL,
+	.disable_card      = NULL,
+	.unregister_card   = NULL,
+	.unregister_driver = NULL,
+};
+
+#endif /* CONFIG_DEVFS_FS */
diff -Naurdp a/drivers/media/video/em3800/em8300_devfs.h b/drivers/media/video/em3800/em8300_devfs.h
--- a/drivers/media/video/em3800/em8300_devfs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_devfs.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,28 @@
+/* $Id: em8300_devfs.h,v 1.2 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_devfs.h -- interface to the devfs filesystem
+ * Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef EM8300_DEVFS_H
+#define EM8300_DEVFS_H
+
+#include "em8300_registration.h"
+
+extern struct em8300_registrar_s em8300_devfs_registrar;
+
+#endif /* EM8300_DEVFS_H */
diff -Naurdp a/drivers/media/video/em3800/em8300_dicom.c b/drivers/media/video/em3800/em8300_dicom.c
--- a/drivers/media/video/em3800/em8300_dicom.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_dicom.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,369 @@
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+
+extern int dicom_other_pal[EM8300_MAX];
+extern int dicom_fix[EM8300_MAX];
+extern int dicom_control[EM8300_MAX];
+
+struct dicom_tvmode {
+	int vertsize;
+	int horizsize;
+	int vertoffset;
+	int horizoffset;
+};
+
+struct dicom_tvmode tvmodematrix[EM8300_VIDEOMODE_LAST + 1] = {
+	{576, 720, 46, 130},     // PAL 4:3
+	{480, 720, 46, 138},     // PAL60 4:3
+	{480, 720, 31, 138},     // NTSC 4:3
+};
+
+/* C decompilation of the chromaluma code
+*  by Anton Altaparmakov <antona@bigfoot.com>
+*
+*  This basically returns the result of calculating param1 / param2 and
+*  depending on some weird rules either adds 1 to the result or not.
+*  Returns 0 on error, ie. when param2 is 0.
+*/
+int sub_265C1 (int param1, unsigned int param2, short int param3)
+{
+	int local1;
+	if (!param2) {
+		return 0;
+	}
+	local1 = param1 / param2;
+	if (param2 & 1) {
+		param1 <<= 1;
+		param2 <<= 1;
+	}
+	if (param3) {
+		// Original was stupid, so there:
+		if (param1 % param2 >= param2) {
+			++local1;
+		}
+	} else {
+		if (param1 % param2 >= param2 >> 1) {
+			++local1;
+		}
+	}
+
+	return local1;
+}
+
+/* sub_40137 calculates the contents of the dicom_bcsluma and dicom_bcschroma
+*		 registers with brightness contrast and saturation values as inputs.
+*/
+int sub_40137(struct em8300_s *em)
+{
+	short int local1;
+	int local2, local3;
+	short int local4;
+	int local5;
+	short int local6, local7;
+	int ir;
+	register int eax;
+
+	local3 = sub_265C1(em->dicom_contrast * 0x7f, 0x3e8, 0); // 0x3e8 = 1000
+	local2 = sub_265C1(em->dicom_brightness * 0xff, 0x3e8, 0);
+	local5 = sub_265C1(em->dicom_saturation * 0x1f, 0x3e8, 0);
+	if (local3 >= 0x40) {
+		local1 = 0x2000 / (0xc0 - local3);
+		ir = local2 - 0x80 - ((local3 - 0x40) << 7) / (0xc0 - local3);
+		if (ir > -128) {
+			local4 = ir;
+		} else {
+			local4 = -128;
+		}
+		if ((eax = local5 << 7) < 0) {
+			eax += 0xf;
+		}
+		local6 = local7 = ((eax & 0xfffffff0) << 2) / (0xc0 - local3);
+	} else {
+		register int eax;
+		if ((eax = (local3 + 0x40) << 6) < 0) {
+			eax += 0x7f;
+		}
+		local1 = eax >> 7;
+		if ((eax = local2 - local3 - 0x40) < 0x7f) {
+			local4 = eax;
+		} else {
+			local4 = 0x7f;
+		}
+		if ((eax = local5 * (local3 + 0x40)) < 0) {
+			eax += 0xf;
+		}
+		if ((eax = (eax & 0xfffffff0) << 2) < 0) {
+			eax += 0x7f;
+		}
+		local6 = local7 =  eax >> 7;
+	}
+#if 0
+	if (em->encoder_type != ENCODER_BT865) {
+#endif
+		write_ucregister(DICOM_BCSLuma, (local1 << 8) | (local4 & 0xff));
+		write_ucregister(DICOM_BCSChroma, local7 << 8 | local6);
+#if 0
+	}
+#endif
+
+	return 1;
+}
+
+void em8300_dicom_setBCS(struct em8300_s *em, int brightness, int contrast, int saturation)
+{
+	em->dicom_brightness = brightness;
+	em->dicom_contrast = contrast;
+	em->dicom_saturation = saturation;
+
+	if (read_ucregister(DICOM_UpdateFlag) == 1) {
+		write_ucregister(DICOM_UpdateFlag, 0);
+		udelay(1);
+	}
+
+	sub_40137(em); // Update brightness/contrast/saturation
+
+	write_ucregister(DICOM_UpdateFlag, 1);
+}
+
+int em8300_dicom_update(struct em8300_s *em)
+{
+	int ret;
+	int vmode_ntsc = 1;
+
+	if (dicom_other_pal[em->card_nr]) {
+		vmode_ntsc = (em->video_mode == EM8300_VIDEOMODE_NTSC);
+	}
+
+	if ((ret = em8300_waitfor(em, ucregister(DICOM_UpdateFlag), 0, 1))) {
+		return ret;
+	}
+
+	if (em->overlay_enabled) {
+		sub_4288c(em, em->overlay_frame_xpos, em->overlay_frame_ypos, em->overlay_frame_width,
+				em->overlay_frame_height, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+				em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+	} else {
+		write_ucregister(DICOM_FrameTop, tvmodematrix[em->video_mode].vertoffset);
+		write_ucregister(DICOM_FrameBottom, tvmodematrix[em->video_mode].vertoffset + tvmodematrix[em->video_mode].vertsize - 1);
+		write_ucregister(DICOM_FrameLeft, tvmodematrix[em->video_mode].horizoffset);
+		write_ucregister(DICOM_FrameRight, tvmodematrix[em->video_mode].horizoffset + tvmodematrix[em->video_mode].horizsize - 1);
+		write_ucregister(DICOM_VisibleTop, tvmodematrix[em->video_mode].vertoffset);
+		write_ucregister(DICOM_VisibleBottom, tvmodematrix[em->video_mode].vertoffset + tvmodematrix[em->video_mode].vertsize - 1);
+		write_ucregister(DICOM_VisibleLeft, tvmodematrix[em->video_mode].horizoffset);
+		write_ucregister(DICOM_VisibleRight, tvmodematrix[em->video_mode].horizoffset + tvmodematrix[em->video_mode].horizsize - 1);
+	}
+
+	if (em->aspect_ratio == EM8300_ASPECTRATIO_16_9) {
+		em->dicom_tvout |= 0x10;
+	} else {
+		em->dicom_tvout &= ~0x10;
+	}
+
+	write_ucregister(DICOM_TvOut, em->dicom_tvout);
+
+	if (em->overlay_enabled) {
+		write_register(0x1f47, 0x0);
+		write_register(0x1f5e, 0x1afe);
+		write_ucregister(DICOM_Control, 0x9afe);
+
+#if 0 /* don't know if this is necessary yet */
+#ifdef EM8300_DICOM_0x1f5e_0x1efe
+		write_register(0x1f5e, 0x1efe);
+#else
+		write_register(0x1f5e, 0x1afe);
+#endif
+#ifdef EM8300_DICOM_CONTROL_0x9efe
+		write_ucregister(DICOM_Control, 0x9efe);
+#else
+		write_ucregister(DICOM_Control, 0x9afe);
+#endif
+#endif
+	} else {
+
+		if (em->encoder_type == ENCODER_BT865) {
+			write_register(0x1f47, 0x0);
+			if (em->video_mode == EM8300_VIDEOMODE_NTSC) {
+				write_register(EM8300_HSYNC_LO, 134);
+				write_register(EM8300_HSYNC_HI, 720);
+			} else {
+				write_register(EM8300_HSYNC_LO, 140);
+				write_register(EM8300_HSYNC_HI, 720);
+			}
+			if (vmode_ntsc) {
+				write_register(EM8300_VSYNC_HI, 260);
+				write_register(0x1f5e, 0xfefe);
+			} else {
+				write_register(EM8300_VSYNC_HI, 310);
+				write_register(0x1f5e, 0x9cfe);
+			}
+
+			write_ucregister(DICOM_VSyncLo1, 0x1);
+			write_ucregister(DICOM_VSyncLo2, 0x0);
+			write_ucregister(DICOM_VSyncDelay1, 0xd2);
+			write_ucregister(DICOM_VSyncDelay2, 0x00);
+
+			write_register(0x1f46, 0x00);
+			write_register(0x1f47, 0x1f);
+
+			write_ucregister(DICOM_Control, 0x9efe);
+		} else { /* ADV7170 or ADV7175A */
+			write_register(0x1f47, 0x18);
+
+			if (vmode_ntsc) {
+				if (dicom_fix[em->card_nr]) {
+					write_register(0x1f5e, 0x1efe);
+				} else {
+					write_register(0x1f5e, 0x1afe);
+				}
+
+				if (dicom_control[em->card_nr]) {
+					write_ucregister(DICOM_Control, 0x9efe);
+				} else {
+					write_ucregister(DICOM_Control, 0x9afe);
+				}
+			} else {
+				if (dicom_fix[em->card_nr]) {
+					write_register(0x1f5e, 0x1afe);
+				} else {
+					write_register(0x1f5e, 0x1efe);
+				}
+
+				if (dicom_control[em->card_nr]) {
+					write_ucregister(DICOM_Control, 0x9afe);
+				} else {
+					write_ucregister(DICOM_Control, 0x9efe);
+				}
+			}
+		}
+	}
+
+	pr_debug("em8300_dicom.o: vmode_ntsc: %d\n", vmode_ntsc);
+	pr_debug("em8300_dicom.o: dicom_other_pal: %d\n", dicom_other_pal[em->card_nr]);
+	pr_debug("em8300_dicom.o: dicom_control: %d\n", dicom_control[em->card_nr]);
+	pr_debug("em8300_dicom.o: dicom_fix: %d\n", dicom_fix[em->card_nr]);
+
+	write_ucregister(DICOM_UpdateFlag, 1);
+
+	return em8300_waitfor(em, ucregister(DICOM_UpdateFlag), 0, 1);
+}
+
+
+
+void em8300_dicom_disable(struct em8300_s *em)
+{
+	em->dicom_tvout = 0x8000;
+	write_ucregister(DICOM_TvOut, em->dicom_tvout);
+}
+
+void em8300_dicom_enable(struct em8300_s *em)
+{
+	if (em->overlay_enabled) {
+		em->dicom_tvout = 0x4000;
+	} else {
+		em->dicom_tvout = 0x4001;
+	}
+
+	if (em->aspect_ratio == EM8300_ASPECTRATIO_16_9) {
+		em->dicom_tvout |= 0x10;
+	} else {
+		em->dicom_tvout &= ~0x10;
+	}
+
+	write_ucregister(DICOM_TvOut, em->dicom_tvout);
+}
+
+int em8300_dicom_get_dbufinfo(struct em8300_s *em)
+{
+	int displaybuffer;
+	struct displaybuffer_info_s *di = &em->dbuf_info;
+
+	displaybuffer = read_ucregister(DICOM_DisplayBuffer) + 0x1000;
+
+	di->xsize = read_register(displaybuffer);
+	di->ysize = read_register(displaybuffer+1);
+	di->xsize2 = read_register(displaybuffer+2) & 0xfff;
+	di->flag1 = read_register(displaybuffer+2) & 0x8000;
+	di->flag2 = read_ucregister(Vsync_DBuf) & 0x4000;
+
+	if(read_ucregister(MicroCodeVersion) <= 0xf) {
+		di->buffer1 = (read_register(displaybuffer + 3) | (read_register(displaybuffer + 4) << 16)) << 4;
+		di->buffer2 = (read_register(displaybuffer + 5) | (read_register(displaybuffer + 6) << 16)) << 4;
+	} else {
+		di->buffer1 = read_register(displaybuffer + 3) << 6;
+		di->buffer2 = read_register(displaybuffer + 4) << 6;
+	}
+
+	if(displaybuffer == ucregister(Width_Buf3)) {
+		di->unk_present = 1;
+		if(read_ucregister(MicroCodeVersion) <= 0xf) {
+			di->unknown1 = read_register(displaybuffer + 7);
+			di->unknown2 = (read_register(displaybuffer + 8) | (read_register(displaybuffer + 9) <<16)) << 4;
+			di->unknown3 = (read_register(displaybuffer + 0xa) | (read_register(displaybuffer + 0xb) <<16)) << 4;
+		} else {
+			di->unknown2 = read_register(displaybuffer + 6);
+			di->unknown3 = read_register(displaybuffer + 7);
+		}
+	} else {
+		di->unk_present = 0;
+	}
+
+	pr_debug("DICOM buffer: xsize=0x%x(%d)\n", di->xsize, di->xsize);
+	pr_debug("			  ysize=0x%x(%d)\n", di->ysize, di->ysize);
+	pr_debug("			  xsize2=0x%x(%d)\n", di->xsize2, di->xsize2);
+	pr_debug("			  flag1=%d, flag2=%d\n", di->flag1, di->flag2);
+	pr_debug("			  buffer1=0x%x(%d)\n", di->buffer1, di->buffer1);
+	pr_debug("			  buffer2=0x%x(%d)\n", di->buffer2, di->buffer2);
+
+	if (di->unk_present) {
+		pr_debug("			  unknown1=0x%x(%d)\n", di->unknown1, di->unknown1);
+		pr_debug("			  unknown2=0x%x(%d)\n", di->unknown2, di->unknown2);
+		pr_debug("			  unknown3=0x%x(%d)\n", di->unknown3, di->unknown3);
+	}
+	return 0;
+}
+
+/* sub_42A32
+   Arguments
+   xoffset = ebp+0x8
+   yoffset = ebp+0xc
+   c = ebp+0x10
+   lines = ebp+0x14
+   pat1 = ebp+0x18
+   pat2 = ebp+0x1c
+ */
+void em8300_dicom_fill_dispbuffers(struct em8300_s *em, int xpos, int ypos, int xsize, int ysize, unsigned int pat1, unsigned int pat2)
+{
+	int i;
+
+	pr_debug("ysize: %d, xsize: %d\n", ysize, xsize);
+	pr_debug("buffer1: %d, buffer2: %d\n", em->dbuf_info.buffer1, em->dbuf_info.buffer2);
+
+	for (i = 0; i < ysize; i++) {
+		em8300_setregblock(em, em->dbuf_info.buffer1 + xpos + (ypos + i) * em->dbuf_info.xsize, pat1, xsize);
+		em8300_setregblock(em, em->dbuf_info.buffer2 + xpos + (ypos + i) / 2 * em->dbuf_info.xsize, pat2, xsize);
+	}
+}
+
+void em8300_dicom_init(struct em8300_s *em)
+{
+	em8300_dicom_disable(em);
+}
diff -Naurdp a/drivers/media/video/em3800/em8300_fifo.c b/drivers/media/video/em3800/em8300_fifo.c
--- a/drivers/media/video/em3800/em8300_fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_fifo.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,344 @@
+/*
+	Copyright (C) 2000 Henrik Johansson <henrikjo@post.utfors.se>
+	Copyright (C) 2005 Jon Burgess <jburgess@uklinux.net>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+#include "em8300_fifo.h"
+
+#include "em8300_compat24.h"
+
+int em8300_fifo_init(struct em8300_s *em, struct fifo_s *f, int start, int wrptr, int rdptr, int pcisize, int slotsize, int fifotype)
+{
+	int i;
+	dma_addr_t phys;
+
+	f->em = em;
+	f->preprocess_ratio = 1;
+	f->preprocess_cb = NULL;
+	f->preprocess_buffer = NULL;
+
+	f->type = fifotype;
+
+	f->writeptr = (unsigned * volatile) ucregister_ptr(wrptr);
+	f->readptr = (unsigned * volatile) ucregister_ptr(rdptr);
+
+	switch (f->type) {
+	case FIFOTYPE_AUDIO:
+		f->slotptrsize = 3;
+		f->slots.a = (struct audio_fifoslot_s *) ucregister_ptr(start);
+		f->nslots = read_ucregister(pcisize) / 3;
+		f->preprocess_buffer=kmalloc(slotsize, GFP_KERNEL);
+		if (!f->preprocess_buffer)
+			return -ENOMEM;
+		break;
+	case FIFOTYPE_VIDEO:
+		f->slotptrsize = 4;
+		f->slots.v = (struct video_fifoslot_s *) ucregister_ptr(start);
+		f->nslots = read_ucregister(pcisize) / 4;
+		break;
+	}
+
+	f->slotsize = slotsize;
+	f->start = ucregister(start) - 0x1000;
+	f->threshold = f->nslots / 2;
+
+	f->bytes = 0;
+
+	if (f->fifobuffer) {
+		kfree(f->fifobuffer);
+	}
+
+	f->fifobuffer = pci_alloc_consistent(f->em->dev, f->nslots * f->slotsize, &f->phys_base);
+	if (f->fifobuffer == NULL) {
+		return -ENOMEM;
+	}
+
+	init_waitqueue_head(&f->wait);
+
+	for (i = 0; i < f->nslots; i++) {
+		phys = f->phys_base + i * f->slotsize;
+		switch (f->type) {
+		case FIFOTYPE_AUDIO:
+			writel(phys >> 16, &f->slots.a[i].physaddress_hi);
+			writel(phys & 0xffff, &f->slots.a[i].physaddress_lo);
+			writel(f->slotsize, &f->slots.a[i].slotsize);
+			break;
+		case FIFOTYPE_VIDEO:
+			writel(0, &f->slots.v[i].flags);
+			writel(phys >> 16, &f->slots.v[i].physaddress_hi);
+			writel(phys & 0xffff, &f->slots.v[i].physaddress_lo);
+			writel(f->slotsize, &f->slots.v[i].slotsize);
+		}
+	}
+
+	init_MUTEX(&f->lock);
+	f->valid = 1;
+
+	return 0;
+}
+
+void em8300_fifo_free(struct fifo_s *f)
+{
+	if (f) {
+		if(f->valid && f->fifobuffer) {
+			pci_free_consistent(f->em->dev, f->nslots * f->slotsize, f->fifobuffer, f->phys_base);
+		}
+		if(f->valid && f->preprocess_buffer) {
+			kfree(f->preprocess_buffer);
+		}
+		kfree(f);
+	}
+}
+
+struct fifo_s *em8300_fifo_alloc()
+{
+	struct fifo_s *f = kmalloc(sizeof(struct fifo_s), GFP_KERNEL);
+	if (f) {
+		memset(f, 0, sizeof(struct fifo_s));
+	}
+	return f;
+}
+
+int em8300_fifo_check(struct fifo_s *fifo)
+{
+	int freeslots;
+
+	if (!fifo || !fifo->valid) {
+		return -1;
+	}
+
+	freeslots = em8300_fifo_freeslots(fifo);
+
+	if (freeslots > fifo->threshold) {
+		wake_up_interruptible(&fifo->wait);
+	}
+
+	return 0;
+}
+
+int em8300_fifo_sync(struct fifo_s *fifo)
+{
+	long ret;
+	ret = wait_event_interruptible_timeout(fifo->wait, readl(fifo->writeptr) == readl(fifo->readptr), 3 * HZ);
+	if (ret == 0) {
+		printk(KERN_ERR "em8300.o: FIFO sync timeout during sync\n");
+		return -EINTR;
+	}
+	else if (ret > 0)
+		return 0;
+	else
+		return ret;
+}
+
+int em8300_fifo_write_nolock(struct fifo_s *fifo, int n, const char *userbuffer, int flags)
+{
+	int freeslots, writeindex, i, bytes_transferred = 0, copysize;
+
+	if (!fifo || !fifo->valid) {
+		return -1;
+	}
+
+	writeindex = ((int)readl(fifo->writeptr) - fifo->start) / fifo->slotptrsize;
+	freeslots = em8300_fifo_freeslots(fifo);
+	for (i = 0; i < freeslots && n; i++) {
+		copysize = n < fifo->slotsize / fifo->preprocess_ratio ? n : fifo->slotsize / fifo->preprocess_ratio;
+
+		switch (fifo->type) {
+		case FIFOTYPE_AUDIO:
+			writel(copysize * fifo->preprocess_ratio, &fifo->slots.a[writeindex].slotsize);
+			break;
+		case FIFOTYPE_VIDEO:
+			writel(flags, &fifo->slots.v[writeindex].flags);
+			writel(copysize * fifo->preprocess_ratio, &fifo->slots.v[writeindex].slotsize);
+			break;
+		}
+
+		if (!access_ok(VERIFY_READ, userbuffer, copysize))
+			return -EFAULT;
+
+		if (fifo->preprocess_cb) {
+			fifo->preprocess_cb(fifo->em, fifo->fifobuffer + writeindex * fifo->slotsize, userbuffer, copysize);
+		} else {
+			(void)copy_from_user(fifo->fifobuffer + writeindex * fifo->slotsize, userbuffer, copysize);
+		}
+
+		writeindex++;
+		writeindex %= fifo->nslots;
+		n -= copysize;
+		userbuffer += copysize;
+		bytes_transferred += copysize;
+		fifo->bytes += copysize;
+	}
+	writel(fifo->start + writeindex * fifo->slotptrsize, fifo->writeptr);
+
+	return bytes_transferred;
+}
+
+int em8300_fifo_write(struct fifo_s *fifo, int n, const char *userbuffer, int flags)
+{
+	int ret;
+	down(&fifo->lock);
+	ret = em8300_fifo_write_nolock(fifo, n, userbuffer, flags);
+	up(&fifo->lock);
+	return ret;
+}
+
+int em8300_fifo_writeblocking_nolock(struct fifo_s *fifo, int n, const char *userbuffer, int flags)
+{
+	int total_bytes_written = 0, copy_size;
+	long ret;
+
+	if (!fifo->valid) {
+		return -EPERM;
+	}
+
+
+	while (n) {
+		copy_size = em8300_fifo_write_nolock(fifo, n, userbuffer, flags);
+
+		if (copy_size == -EFAULT)
+			return -EFAULT;
+
+		if (copy_size < 0) {
+			return -EIO;
+		}
+
+		n -= copy_size;
+		userbuffer += copy_size;
+		total_bytes_written += copy_size;
+
+		if (!copy_size) {
+			struct em8300_s *em = fifo->em;
+			int running = 1;
+
+			//printk("Fifo Full %p\n", fifo);
+
+			running = (running && (read_ucregister(MV_SCRSpeed) > 0));
+			running = (running && (em->video_playmode == EM8300_PLAYMODE_PLAY));
+			/* FIXME: are these all conditions for a running DMA engine? */
+
+			if (running) {
+				int i;
+				for (i=0; i<2; i++) {
+
+					ret = wait_event_interruptible_timeout(fifo->wait, em8300_fifo_freeslots(fifo), 2 * HZ);
+					if (ret > 0)
+						break;
+					else if (ret == 0) {
+						printk("Fifo still full, trying stop\n");
+						em8300_video_setplaymode(em, EM8300_PLAYMODE_STOPPED);
+						em8300_video_setplaymode(em, EM8300_PLAYMODE_PLAY);
+					}
+					else
+						return (total_bytes_written>0)?total_bytes_written:ret;
+				}
+				if (ret == 0) {
+					printk(KERN_ERR "em8300.o: FIFO sync timeout during blocking write\n");
+					return (total_bytes_written>0)?total_bytes_written:-EINTR;
+				}
+			}
+			else {
+				if ((ret = wait_event_interruptible(fifo->wait, em8300_fifo_freeslots(fifo))))
+					return (total_bytes_written>0)?total_bytes_written:ret;
+			}
+
+		}
+	}
+
+	// printk(KERN_ERR "em8300.o: count = %d\n", total_bytes_written);
+	// printk(KERN_ERR "em8300.o: time  = %d\n", jiffies - safe_jiff);
+	return total_bytes_written;
+}
+
+int em8300_fifo_writeblocking(struct fifo_s *fifo, int n, const char *userbuffer, int flags)
+{
+	int ret;
+	down(&fifo->lock);
+	ret = em8300_fifo_writeblocking_nolock(fifo, n, userbuffer, flags);
+	up(&fifo->lock);
+	return ret;
+}
+
+int em8300_fifo_freeslots(struct fifo_s *fifo)
+{
+	return (((int)readl(fifo->readptr) - (int)readl(fifo->writeptr)) / fifo->slotptrsize + fifo->nslots - 1) % fifo->nslots;
+}
+
+void em8300_fifo_statusmsg(struct fifo_s *fifo, char *str)
+{
+	int freeslots = em8300_fifo_freeslots(fifo);
+	sprintf(str,"Free slots: %d/%d", freeslots, fifo->nslots);
+}
+
+int em8300_fifo_calcbuffered(struct fifo_s *fifo)
+{
+	int readindex, writeindex, i, n;
+
+	writeindex = ((int)readl(fifo->writeptr) - fifo->start) / fifo->slotptrsize;
+	readindex = ((int)readl(fifo->readptr) - fifo->start) / fifo->slotptrsize;
+	n = 0;
+	i = readindex;
+	while (i != writeindex) {
+		switch (fifo->type) {
+		case FIFOTYPE_AUDIO:
+			n += readl(&fifo->slots.a[i].slotsize);
+			break;
+		case FIFOTYPE_VIDEO:
+			n += readl(&fifo->slots.v[i].slotsize);
+			break;
+		}
+		i++;
+		i &= fifo->nslots-1;
+	}
+
+	return n;
+}
+
+int em8300_fifo_isempty(struct fifo_s *fifo)
+{
+	return (readl(fifo->writeptr) == readl(fifo->readptr));
+}
diff -Naurdp a/drivers/media/video/em3800/em8300_fifo.h b/drivers/media/video/em3800/em8300_fifo.h
--- a/drivers/media/video/em3800/em8300_fifo.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_fifo.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,91 @@
+#ifndef EM8300_FIFO_H
+#define EM8300_FIFO_H
+
+#include <asm/semaphore.h>
+
+#define FIFOTYPE_AUDIO 1
+#define FIFOTYPE_VIDEO 2
+
+struct video_fifoslot_s {
+	uint32_t flags;
+	uint32_t physaddress_hi;
+	uint32_t physaddress_lo;
+	uint32_t slotsize;
+};
+
+struct audio_fifoslot_s {
+	uint32_t physaddress_hi;
+	uint32_t physaddress_lo;
+	uint32_t slotsize;
+};
+
+struct pts_fifoslot_s {
+	uint32_t streamoffset_hi;
+	uint32_t streamoffset_lo;
+	uint32_t pts_hi;
+	uint32_t pts_lo;
+};
+
+struct em8300_s;
+typedef void (*preprocess_cb_t) (struct em8300_s *, unsigned char *, const unsigned char *, int);
+
+struct fifo_s {
+	struct em8300_s *em;
+
+	int valid;
+
+	int type;
+	int nslots;
+	union {
+		struct video_fifoslot_s *v;
+		struct audio_fifoslot_s *a;
+		struct pts_fifoslot_s *pts;
+	} slots;
+	int slotptrsize;
+	int slotsize;
+
+	int start;
+	int * volatile writeptr;
+	int * volatile readptr;
+	int localreadptr;
+	int threshold;
+
+	int bytes;
+
+	char *fifobuffer;
+
+	preprocess_cb_t preprocess_cb;
+	int preprocess_ratio;
+	char *preprocess_buffer;
+
+	wait_queue_head_t wait;
+
+	struct semaphore lock;
+
+	dma_addr_t phys_base;
+};
+
+struct em8300_s;
+
+/*
+  Prototypes
+*/
+int em8300_fifo_init(struct em8300_s *em, struct fifo_s *f,
+		     int start, int wrptr, int rdptr,
+		     int pcisize, int slotsize, int fifotype);
+
+struct fifo_s * em8300_fifo_alloc(void);
+void em8300_fifo_free(struct fifo_s *f);
+
+int em8300_fifo_write(struct fifo_s *fifo, int n, const char *userbuffer,
+		      int flags);
+int em8300_fifo_writeblocking(struct fifo_s *fifo, int n,
+			      const char *userbuffer, int flags);
+int em8300_fifo_check(struct fifo_s *fifo);
+int em8300_fifo_sync(struct fifo_s *fifo);
+int em8300_fifo_freeslots(struct fifo_s *fifo);
+void em8300_fifo_statusmsg(struct fifo_s *fifo, char *str);
+int em8300_fifo_calcbuffered(struct fifo_s *fifo);
+int em8300_fifo_isempty(struct fifo_s *fifo);
+
+#endif /* EM8300_FIFO_H */
diff -Naurdp a/drivers/media/video/em3800/em8300_i2c.c b/drivers/media/video/em3800/em8300_i2c.c
--- a/drivers/media/video/em3800/em8300_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_i2c.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,380 @@
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_compat24.h"
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+
+#include "adv717x.h"
+#include "bt865.h"
+//#include <linux/sensors.h>
+
+#define I2C_HW_B_EM8300 0xa
+
+struct private_data_s {
+	int clk;
+	int data;
+	struct em8300_s *em;
+};
+
+/* ----------------------------------------------------------------------- */
+/* I2C bitbanger functions						   */
+/* ----------------------------------------------------------------------- */
+
+/* software I2C functions */
+
+static void em8300_setscl(void *data,int state)
+{
+	struct private_data_s *p = (struct private_data_s *) data;
+	struct em8300_s *em = p->em;
+	int sel = p->clk << 8;
+
+	writel(sel | p->clk, &em->mem[em->i2c_oe_reg]);
+	writel(sel | (state ? p->clk : 0), &em->mem[em->i2c_pin_reg]);
+}
+
+static void em8300_setsda(void *data, int state)
+{
+	struct private_data_s *p = (struct private_data_s *) data;
+	struct em8300_s *em = p->em;
+	int sel = p->data << 8;
+
+	writel(sel | p->data, &em->mem[em->i2c_oe_reg]);
+	writel(sel | (state ? p->data : 0), &em->mem[em->i2c_pin_reg]);
+}
+
+static int em8300_getscl(void *data)
+{
+	struct private_data_s *p = (struct private_data_s *)data;
+	struct em8300_s *em = p->em;
+
+	return readl(&em->mem[em->i2c_pin_reg]) & (p->clk << 8);
+}
+
+static int em8300_getsda(void *data)
+{
+	struct private_data_s *p = (struct private_data_s *)data;
+	struct em8300_s *em = p->em;
+
+	return readl(&em->mem[em->i2c_pin_reg]) & (p->data << 8);
+}
+
+static int em8300_i2c_lock_client(struct i2c_client *client)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,54) && !defined(EM8300_I2C_FORCE_OLD_API))
+	if (!try_module_get(client->driver->owner)) {
+		printk(KERN_ERR "em8300_i2c: Unable to lock client module\n");
+		return -ENODEV;
+	}
+#endif
+	return 0;
+}
+
+static int em8300_i2c_reg(struct i2c_client *client)
+{
+	struct em8300_s *em = i2c_get_adapdata(client->adapter);
+
+	switch (client->driver->id) {
+	case I2C_DRIVERID_ADV717X:
+		if (em8300_i2c_lock_client(client)) {
+			return -ENODEV;
+		}
+		if (!strncmp(client->name, "ADV7175", 7)) {
+			em->encoder_type = ENCODER_ADV7175;
+		}
+		if (!strncmp(client->name, "ADV7170", 7)) {
+			em->encoder_type = ENCODER_ADV7170;
+		}
+		em->encoder = client;
+		break;
+	case I2C_DRIVERID_BT865:
+		if (em8300_i2c_lock_client(client)) {
+			return -ENODEV;
+		}
+		em->encoder_type = ENCODER_BT865;
+		em->encoder = client;
+		break;
+	case I2C_DRIVERID_EEPROM:
+		/* do nothing */
+		break;
+	default:
+		printk(KERN_ERR "em8300_i2c: unknown client id\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int em8300_i2c_unreg(struct i2c_client *client)
+{
+	struct em8300_s *em = i2c_get_adapdata(client->adapter);
+
+	switch (client->driver->id) {
+	case I2C_DRIVERID_ADV717X:
+	case I2C_DRIVERID_BT865:
+		em->encoder = NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,54) && !defined(EM8300_I2C_FORCE_OLD_API))
+		module_put(client->driver->owner);
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+/* I2C functions							   */
+/* ----------------------------------------------------------------------- */
+int em8300_i2c_init(struct em8300_s *em)
+{
+	int ret;
+	struct private_data_s *pdata;
+
+	//request_module("i2c-algo-bit");
+
+	switch (em->chip_revision) {
+	case 2:
+		em->i2c_oe_reg = EM8300_I2C_OE;
+		em->i2c_pin_reg = EM8300_I2C_PIN;
+		break;
+	case 1:
+		em->i2c_oe_reg = 0x1f4f;
+		em->i2c_pin_reg = EM8300_I2C_OE;
+		break;
+	}
+
+	/*
+	  Reset devices on I2C bus
+	*/
+	writel(0x3f3f, &em->mem[em->i2c_pin_reg]);
+	writel(0x3b3b, &em->mem[em->i2c_oe_reg]);
+	writel(0x0100, &em->mem[em->i2c_pin_reg]);
+	writel(0x0101, &em->mem[em->i2c_pin_reg]);
+	writel(0x0808, &em->mem[em->i2c_pin_reg]);
+
+	/*
+	  Setup info structure for bus 1
+	*/
+
+	em->i2c_data_1.setsda = &em8300_setsda;
+	em->i2c_data_1.setscl = &em8300_setscl;
+	em->i2c_data_1.getsda = &em8300_getsda;
+	em->i2c_data_1.getscl = &em8300_getscl;
+	em->i2c_data_1.mdelay = 10;
+	em->i2c_data_1.udelay = 10;
+	em->i2c_data_1.timeout = 100;
+
+	pdata = kmalloc(sizeof(struct private_data_s),GFP_KERNEL);
+	pdata->clk = 0x10;
+	pdata->data = 0x8;
+	pdata->em = em;
+
+	em->i2c_data_1.data = pdata;
+
+	strcpy(em->i2c_ops_1.name, "EM8300 I2C bus 1");
+	em->i2c_ops_1.id = I2C_HW_B_EM8300;
+	em->i2c_ops_1.algo = NULL;
+	em->i2c_ops_1.algo_data = &em->i2c_data_1;
+	em->i2c_ops_1.client_register = em8300_i2c_reg;
+	em->i2c_ops_1.client_unregister = em8300_i2c_unreg;
+
+	i2c_set_adapdata(&em->i2c_ops_1, (void *)em);
+
+	ret = i2c_bit_add_bus(&em->i2c_ops_1);
+
+	if (ret) {
+		return ret;
+	}
+
+	/*
+	  Setup info structure for bus 2
+	*/
+
+	em->i2c_data_2.setsda = &em8300_setsda;
+	em->i2c_data_2.setscl = &em8300_setscl;
+	em->i2c_data_2.getsda = &em8300_getsda;
+	em->i2c_data_2.getscl = &em8300_getscl;
+	em->i2c_data_2.mdelay = 10;
+	em->i2c_data_2.udelay = 10;
+	em->i2c_data_2.timeout = 100;
+
+	pdata = kmalloc(sizeof(struct private_data_s), GFP_KERNEL);
+	pdata->clk = 0x4;
+	pdata->data = 0x8;
+	pdata->em = em;
+
+	em->i2c_data_2.data = pdata;
+
+	strcpy(em->i2c_ops_2.name, "EM8300 I2C bus 2");
+	em->i2c_ops_2.id = I2C_HW_B_EM8300;
+	em->i2c_ops_2.algo = NULL;
+	em->i2c_ops_2.algo_data = &em->i2c_data_2;
+	em->i2c_ops_2.client_register = em8300_i2c_reg;
+	em->i2c_ops_2.client_unregister = em8300_i2c_unreg;
+
+	i2c_set_adapdata(&em->i2c_ops_2, (void *)em);
+
+	ret = i2c_bit_add_bus(&em->i2c_ops_2);
+	return ret;
+}
+
+void em8300_i2c_exit(struct em8300_s *em)
+{
+	/* unregister i2c_bus */
+	kfree(em->i2c_data_1.data);
+	kfree(em->i2c_data_2.data);
+	i2c_bit_del_bus(&em->i2c_ops_1);
+	i2c_bit_del_bus(&em->i2c_ops_2);
+}
+
+void em8300_clockgen_write(struct em8300_s *em, int abyte)
+{
+	int i;
+
+	writel(0x808, &em->mem[em->i2c_pin_reg]);
+	for (i=0; i < 8; i++) {
+		writel(0x2000, &em->mem[em->i2c_pin_reg]);
+		writel(0x800 | ((abyte & 1) ? 8 : 0), &em->mem[em->i2c_pin_reg]);
+		writel(0x2020, &em->mem[em->i2c_pin_reg]);
+		abyte >>= 1;
+	}
+
+	writel(0x200, &em->mem[em->i2c_pin_reg]);
+	udelay(10);
+	writel(0x202, &em->mem[em->i2c_pin_reg]);
+}
+
+static void I2C_clk(struct em8300_s *em, int level)
+{
+	writel(0x1000 | (level ? 0x10 : 0), &em->mem[em->i2c_pin_reg]);
+	udelay(1);
+}
+
+static void I2C_data(struct em8300_s *em, int level)
+{
+	writel(0x800 | (level ? 0x8 : 0), &em->mem[em->i2c_pin_reg]);
+	udelay(1);
+}
+
+static void I2C_drivedata(struct em8300_s *em, int level)
+{
+	writel(0x800 | (level ? 0x8 : 0), &em->mem[em->i2c_oe_reg]);
+	udelay(1);
+}
+
+#define I2C_read_data ((readl(&em->mem[em->i2c_pin_reg]) & 0x800) ? 1 : 0)
+
+static void I2C_out(struct em8300_s *em, int data, int bits)
+{
+	int i;
+	for (i = bits - 1; i >= 0; i--) {
+		I2C_data(em, data & (1 << i));
+		I2C_clk(em, 1);
+		I2C_clk(em, 0);
+	}
+}
+
+static int I2C_in(struct em8300_s *em, int bits)
+{
+	int i, data = 0;
+
+	for(i = bits - 1; i >= 0; i--) {
+		data |= I2C_read_data << i;
+		I2C_clk(em, 0);
+		I2C_clk(em, 1);
+	}
+	return data;
+}
+
+static void sub_23660(struct em8300_s *em, int arg1, int arg2)
+{
+	I2C_clk(em, 0);
+	I2C_out(em, arg1, 8);
+	I2C_data(em, arg2);
+	I2C_clk(em, 1);
+}
+
+
+static void sub_236f0 (struct em8300_s *em,int arg1, int arg2, int arg3)
+{
+	I2C_clk(em, 1);
+	I2C_data(em, 1);
+	I2C_clk(em, 0);
+	I2C_data(em, 1);
+	I2C_clk(em, 1);
+	I2C_clk(em, 0);
+
+	sub_23660(em, 1, arg2);
+
+	sub_23660(em, arg1, arg3);
+}
+
+void em9010_write(struct em8300_s *em, int reg, int data)
+{
+	sub_236f0(em, reg, 1, 0);
+	sub_23660(em, data, 1);
+}
+
+int em9010_read(struct em8300_s *em, int reg)
+{
+	int val;
+
+	sub_236f0(em, reg, 0, 0);
+	I2C_drivedata(em, 0);
+	val = I2C_in(em, 8);
+	I2C_drivedata(em, 1);
+	I2C_clk(em, 0);
+	I2C_data(em, 1);
+	I2C_clk(em, 1);
+
+	return val;
+}
+
+/* loc_2A5d8 in cl.asm
+   call dword ptr [exx+0x14]
+*/
+int em9010_read16(struct em8300_s *em, int reg)
+{
+	if (reg > 128) {
+		em9010_write(em, 3, 0);
+		em9010_write(em, 4, reg);
+	} else {
+		em9010_write(em, 4, 0);
+		em9010_write(em, 3, reg);
+	}
+
+	return em9010_read(em, 2) | (em9010_read(em, 1) << 8);
+}
+
+/* loc_2A558 in cl.asm
+   call dword ptr [exx+0x10]
+*/
+void em9010_write16(struct em8300_s *em, int reg, int value)
+{
+	if (reg > 128) {
+		em9010_write(em, 3, 0);
+		em9010_write(em, 4, reg);
+	} else {
+		em9010_write(em, 4, 0);
+		em9010_write(em, 3, reg);
+	}
+	em9010_write(em, 2, value & 0xff);
+	em9010_write(em, 1, value >> 8);
+}
+
diff -Naurdp a/drivers/media/video/em3800/em8300_ioctl32.c b/drivers/media/video/em3800/em8300_ioctl32.c
--- a/drivers/media/video/em3800/em8300_ioctl32.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_ioctl32.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,165 @@
+/* $Id: em8300_ioctl32.c,v 1.2 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_ioctl32.c -- compatibility layer for 32-bit ioctls on 64-bit kernels
+ * Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+#include "em8300_ioctl32.h"
+
+typedef struct {
+	u32 ucode;
+	s32 ucode_size;
+} em8300_microcode32_t;
+
+#define EM8300_IOCTL32_INIT       _IOW('C',0,em8300_microcode32_t)
+
+int register_ioctl32_conversion(unsigned int cmd, int (*handler)(unsigned int, unsigned int, unsigned long, struct file *));
+int unregister_ioctl32_conversion(unsigned int cmd);
+
+static int get_em8300_microcode32(em8300_microcode_t *kp, em8300_microcode32_t *up)
+{
+	u32 tmp;
+	if (get_user(kp->ucode_size, &up->ucode_size))
+		return -EFAULT;
+	kp->ucode = kmalloc(kp->ucode_size, GFP_KERNEL);
+	if (!kp->ucode)
+		return -ENOMEM;
+	__get_user(tmp, &up->ucode);
+	if (copy_from_user(kp->ucode, (void *) ((unsigned long)tmp), kp->ucode_size)) {
+		kfree(kp->ucode);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int do_em8300_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *filp)
+{
+	mm_segment_t old_fs = get_fs();
+	em8300_microcode_t karg;
+	em8300_microcode32_t *up = (em8300_microcode32_t *)arg;
+	int err = 0;
+
+	/* First, convert the command. */
+	switch (cmd) {
+	case EM8300_IOCTL32_INIT: cmd = EM8300_IOCTL_INIT; break;
+	}
+
+	switch (cmd) {
+	case EM8300_IOCTL_INIT:
+		err = get_em8300_microcode32(&karg, up);
+		break;
+	};
+	if (err)
+		goto out;
+
+	set_fs(KERNEL_DS);
+	err = filp->f_op->ioctl(filp->f_dentry->d_inode, filp, cmd, (unsigned long)&karg);
+	set_fs(old_fs);
+
+	if (cmd == EM8300_IOCTL_INIT)
+		kfree(karg.ucode);
+
+out:
+	return err;
+}
+
+void em8300_ioctl32_init(void) {
+	register_ioctl32_conversion(EM8300_IOCTL32_INIT, do_em8300_ioctl);
+	register_ioctl32_conversion(EM8300_IOCTL_READREG, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_WRITEREG, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_GETSTATUS, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SETBCS, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_GETBCS, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SET_ASPECTRATIO, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_GET_ASPECTRATIO, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SET_VIDEOMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_GET_VIDEOMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SET_PLAYMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_GET_PLAYMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SET_AUDIOMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_GET_AUDIOMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SET_SPUMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_GET_SPUMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_OVERLAY_CALIBRATE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SETMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SETWINDOW, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SETSCREEN, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_OVERLAY_GET_ATTRIBUTE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SET_ATTRIBUTE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SIGNALMODE, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SCR_GET, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SCR_SET, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SCR_GETSPEED, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_SCR_SETSPEED, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_FLUSH, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_VBI, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_VIDEO_GETSCR, NULL);
+	register_ioctl32_conversion(EM8300_IOCTL_VIDEO_SETSCR, NULL);
+}
+
+void em8300_ioctl32_exit(void) {
+	unregister_ioctl32_conversion(EM8300_IOCTL32_INIT);
+	unregister_ioctl32_conversion(EM8300_IOCTL_READREG);
+	unregister_ioctl32_conversion(EM8300_IOCTL_WRITEREG);
+	unregister_ioctl32_conversion(EM8300_IOCTL_GETSTATUS);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SETBCS);
+	unregister_ioctl32_conversion(EM8300_IOCTL_GETBCS);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SET_ASPECTRATIO);
+	unregister_ioctl32_conversion(EM8300_IOCTL_GET_ASPECTRATIO);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SET_VIDEOMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_GET_VIDEOMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SET_PLAYMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_GET_PLAYMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SET_AUDIOMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_GET_AUDIOMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SET_SPUMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_GET_SPUMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_OVERLAY_CALIBRATE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SETMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SETWINDOW);
+	unregister_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SETSCREEN);
+	unregister_ioctl32_conversion(EM8300_IOCTL_OVERLAY_GET_ATTRIBUTE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SET_ATTRIBUTE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_OVERLAY_SIGNALMODE);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SCR_GET);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SCR_SET);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SCR_GETSPEED);
+	unregister_ioctl32_conversion(EM8300_IOCTL_SCR_SETSPEED);
+	unregister_ioctl32_conversion(EM8300_IOCTL_FLUSH);
+	unregister_ioctl32_conversion(EM8300_IOCTL_VBI);
+	unregister_ioctl32_conversion(EM8300_IOCTL_VIDEO_GETSCR);
+	unregister_ioctl32_conversion(EM8300_IOCTL_VIDEO_SETSCR);
+}
diff -Naurdp a/drivers/media/video/em3800/em8300_ioctl32.h b/drivers/media/video/em3800/em8300_ioctl32.h
--- a/drivers/media/video/em3800/em8300_ioctl32.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_ioctl32.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,27 @@
+/* $Id: em8300_ioctl32.h,v 1.2 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_ioctl32.h -- compatibility layer for 32-bit ioctls on 64-bit kernels
+ * Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef EM8300_IOCTL32_H
+#define EM8300_IOCTL32_H
+
+extern void em8300_ioctl32_init(void);
+extern void em8300_ioctl32_exit(void);
+
+#endif /* EM8300_IOCTL32_H */
diff -Naurdp a/drivers/media/video/em3800/em8300_ioctl.c b/drivers/media/video/em3800/em8300_ioctl.c
--- a/drivers/media/video/em3800/em8300_ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_ioctl.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,702 @@
+/*
+ * Copyright (C) 2005 Jon Burgess <jburgess@uklinux.net>
+ */
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/wait.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+#include "em8300_fifo.h"
+
+#include "encoder.h"
+
+#include "em8300_registration.h"
+#include "em8300_compat24.h"
+
+int em8300_control_ioctl(struct em8300_s *em, int cmd, unsigned long arg)
+{
+	em8300_register_t reg;
+	int val, len;
+	em8300_bcs_t bcs;
+	em8300_overlay_window_t ov_win;
+	em8300_overlay_screen_t ov_scr;
+	em8300_overlay_calibrate_t ov_cal;
+	em8300_attribute_t attr;
+	int old_count;
+	long ret;
+
+	if (_IOC_DIR(cmd) != 0) {
+		len = _IOC_SIZE(cmd);
+
+		if (len < 1 || len > 65536 || arg == 0) {
+			return -EFAULT;
+		}
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (!access_ok(VERIFY_READ, (void *) arg, len)) {
+				return -EFAULT;
+			}
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			if (!access_ok(VERIFY_WRITE, (void *) arg, len)) {
+				return -EFAULT;
+			}
+		}
+	}
+
+	switch(_IOC_NR(cmd)) {
+	case _IOC_NR(EM8300_IOCTL_INIT):
+		return em8300_ioctl_init(em, (em8300_microcode_t *) arg);
+
+	case _IOC_NR(EM8300_IOCTL_WRITEREG):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (copy_from_user(&reg, (void *) arg, sizeof(em8300_register_t)))
+			return -EFAULT;
+
+		if (reg.microcode_register) {
+			write_ucregister(reg.reg, reg.val);
+		} else {
+			write_register(reg.reg, reg.val);
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_READREG):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (copy_from_user(&reg, (void *) arg, sizeof(em8300_register_t)))
+			return -EFAULT;
+
+		if (reg.microcode_register) {
+			reg.val = read_ucregister(reg.reg);
+			reg.reg = ucregister(reg.reg);
+		} else {
+			reg.val = read_register(reg.reg);
+		}
+		if (copy_to_user((void *) arg, &reg, sizeof(em8300_register_t)))
+			return -EFAULT;
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_GETSTATUS):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		return em8300_ioctl_getstatus(em, (char *) arg);
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_VBI):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		old_count = em->irqcount;
+		em->irqmask |= IRQSTATUS_VIDEO_VBL;
+		write_ucregister(Q_IrqMask, em->irqmask);
+
+		ret = wait_event_interruptible_timeout(em->vbi_wait, em->irqcount != old_count, HZ);
+		if (ret == 0)
+			return -EINTR;
+		else if (ret < 0)
+		        return ret;		
+
+		/* copy timestamp and return */
+		if (copy_to_user((void *) arg, &em->tv, sizeof(struct timeval)))
+			return -EFAULT;
+		return 0;
+
+	case _IOC_NR(EM8300_IOCTL_GETBCS):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (copy_from_user(&bcs, (void *) arg, sizeof(em8300_bcs_t)))
+				return -EFAULT;
+			em8300_dicom_setBCS(em, bcs.brightness, bcs.contrast, bcs.saturation);
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			bcs.brightness = em->dicom_brightness;
+			bcs.contrast = em->dicom_contrast;
+			bcs.saturation = em->dicom_saturation;
+			if (copy_to_user((void *) arg, &bcs, sizeof(em8300_bcs_t)))
+				return -EFAULT;
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SET_VIDEOMODE):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setvideomode(em, val);
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			if (copy_to_user((void *) arg, &em->video_mode, sizeof(em->video_mode)))
+				return -EFAULT;
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SET_PLAYMODE):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setplaymode(em, val);
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SET_ASPECTRATIO):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setaspectratio(em, val);
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			if (copy_to_user((void *) arg, &em->aspect_ratio, sizeof(em->aspect_ratio)))
+				return -EFAULT;
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_GET_AUDIOMODE):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setaudiomode(em, val);
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			em8300_ioctl_getaudiomode(em, arg);
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SET_SPUMODE):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setspumode(em, val);
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			if (copy_to_user((void *) arg, &em->sp_mode, sizeof(em->sp_mode)))
+				return -EFAULT;
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_SETMODE):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			if (!em8300_ioctl_overlay_setmode(em, val)) {
+				return -EINVAL;
+			}
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_SIGNALMODE):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			if (!em9010_overlay_set_signalmode(em, val)) {
+				return -EINVAL;
+			}
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_SETWINDOW):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (copy_from_user(&ov_win, (void *) arg, sizeof(em8300_overlay_window_t)))
+				return -EFAULT;
+			if (!em8300_ioctl_overlay_setwindow(em, &ov_win)) {
+				return -EINVAL;
+			}
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			if (copy_to_user((void *) arg, &ov_win, sizeof(em8300_overlay_window_t)))
+				return -EFAULT;
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_SETSCREEN):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (copy_from_user(&ov_scr, (void *) arg, sizeof(em8300_overlay_screen_t)))
+				return -EFAULT;
+			if (!em8300_ioctl_overlay_setscreen(em, &ov_scr)) {
+				return -EINVAL;
+			}
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			if (copy_to_user((void *) arg, &ov_scr, sizeof(em8300_overlay_screen_t)))
+				return -EFAULT;
+		}
+	break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_CALIBRATE):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (copy_from_user(&ov_cal, (void *) arg, sizeof(em8300_overlay_calibrate_t)))
+				return -EFAULT;
+			if(!em8300_ioctl_overlay_calibrate(em, &ov_cal)) {
+				return -EIO;
+			}
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			if (copy_to_user((void *) arg, &ov_cal, sizeof(em8300_overlay_calibrate_t)))
+				return -EFAULT;
+		}
+	break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_GET_ATTRIBUTE):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (copy_from_user(&attr, (void *) arg, sizeof(em8300_attribute_t)))
+			return -EFAULT;
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			em9010_set_attribute(em, attr.attribute, attr.value);
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			attr.value = em9010_get_attribute(em, attr.attribute);
+			if (copy_to_user((void *) arg, &attr, sizeof(em8300_attribute_t)))
+				return -EFAULT;
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SCR_GET):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			unsigned scr;
+			if (get_user(val, (unsigned*) arg))
+				return -EFAULT;
+			scr = read_ucregister(MV_SCRlo) | (read_ucregister(MV_SCRhi) << 16);
+
+			if (scr > val)
+				scr = scr - val;
+			else
+				scr = val - scr;
+
+			if (scr > 2 * 1800) { /* Tolerance: 2 frames */
+				pr_info("adjusting scr: %i\n", val);
+				write_ucregister(MV_SCRlo, val & 0xffff);
+				write_ucregister(MV_SCRhi, (val >> 16) & 0xffff);
+			}
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			val = read_ucregister(MV_SCRlo) | (read_ucregister(MV_SCRhi) << 16);
+			if (copy_to_user((void *) arg, &val, sizeof(unsigned)))
+				return -EFAULT;
+		}
+	break;
+
+	case _IOC_NR(EM8300_IOCTL_SCR_GETSPEED):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int*) arg);
+			val &= 0xFFFF;
+
+			write_ucregister(MV_SCRSpeed,
+			 read_ucregister(MicroCodeVersion) >= 0x29 ? val : val >> 8);
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			val = read_ucregister(MV_SCRSpeed);
+			if (! read_ucregister(MicroCodeVersion) >= 0x29)
+				val <<= 8;
+
+			if (copy_to_user((void *) arg, &val, sizeof(unsigned)))
+				return -EFAULT;
+		}
+	break;
+
+	case _IOC_NR(EM8300_IOCTL_FLUSH):
+		em8300_require_ucode(em);
+
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (get_user(val, (unsigned*) arg))
+				return -EFAULT;
+
+			switch (val) {
+			case EM8300_SUBDEVICE_CONTROL:
+				return -ENOSYS;
+			case EM8300_SUBDEVICE_VIDEO:
+				return em8300_video_flush(em);
+			case EM8300_SUBDEVICE_AUDIO:
+				return em8300_audio_flush(em);
+			case EM8300_SUBDEVICE_SUBPICTURE:
+				return -ENOSYS;
+			default:
+				return -EINVAL;
+			}
+		}
+	break;
+
+	default:
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+int em8300_ioctl_init(struct em8300_s *em, em8300_microcode_t *useruc)
+{
+	em8300_microcode_t uc;
+	unsigned char *ucode;
+	int ret;
+
+	if (copy_from_user(&uc, useruc, sizeof(em8300_microcode_t)))
+		return -EFAULT;
+
+	ucode = kmalloc(uc.ucode_size, GFP_KERNEL);
+	if (!ucode) {
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(ucode, uc.ucode, uc.ucode_size)) {
+		kfree(ucode);
+		return -EFAULT;
+	}
+
+	em8300_ucode_upload(em, ucode, uc.ucode_size);
+
+	kfree(ucode);
+
+	em8300_dicom_init(em);
+
+	if ((ret = em8300_video_setup(em))) {
+		return ret;
+	}
+
+	if (em->mvfifo) {
+		em8300_fifo_free(em->mvfifo);
+	}
+	if (em->mafifo) {
+		em8300_fifo_free(em->mafifo);
+	}
+	if (em->spfifo) {
+		em8300_fifo_free(em->spfifo);
+	}
+
+	if (!(em->mvfifo = em8300_fifo_alloc())) {
+		return -ENOMEM;
+	}
+
+	if (!(em->mafifo = em8300_fifo_alloc())) {
+		return -ENOMEM;
+	}
+
+	if (!(em->spfifo = em8300_fifo_alloc())) {
+		return -ENOMEM;
+	}
+
+	em8300_fifo_init(em,em->mvfifo, MV_PCIStart, MV_PCIWrPtr, MV_PCIRdPtr, MV_PCISize, 0x900, FIFOTYPE_VIDEO);
+	em8300_fifo_init(em,em->mafifo, MA_PCIStart, MA_PCIWrPtr, MA_PCIRdPtr, MA_PCISize, 0x1000, FIFOTYPE_AUDIO);
+	//	em8300_fifo_init(em,em->spfifo, SP_PCIStart, SP_PCIWrPtr, SP_PCIRdPtr, SP_PCISize, 0x1000, FIFOTYPE_VIDEO);
+	em8300_fifo_init(em,em->spfifo, SP_PCIStart, SP_PCIWrPtr, SP_PCIRdPtr, SP_PCISize, 0x800, FIFOTYPE_VIDEO);
+	em8300_spu_init(em);
+
+	if ((ret = em8300_audio_setup(em))) {
+		return ret;
+	}
+
+	em8300_ioctl_enable_videoout(em, 1);
+
+#if ! ( defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE) )
+	if (!em->ucodeloaded)
+		em8300_enable_card(em);
+#endif
+
+	em->ucodeloaded = 1;
+
+	printk(KERN_NOTICE "em8300: Microcode version 0x%02x loaded\n", read_ucregister(MicroCodeVersion));
+	return 0;
+}
+
+int em8300_ioctl_getstatus(struct em8300_s *em, char *usermsg)
+{
+	char tmpstr[1024];
+	struct timeval tv;
+	long tdiff, frames, scr, picpts;
+	char mvfstatus[128];
+	char mafstatus[128];
+	char spfstatus[128];
+
+	em8300_fifo_statusmsg(em->mvfifo, mvfstatus);
+	em8300_fifo_statusmsg(em->mafifo, mafstatus);
+	em8300_fifo_statusmsg(em->spfifo, spfstatus);
+
+	frames = (read_ucregister(MV_FrameCntHi) << 16) | read_ucregister(MV_FrameCntLo);
+	picpts = (read_ucregister(PicPTSHi) << 16) |
+	read_ucregister(PicPTSLo);
+	scr = (read_ucregister(MV_SCRhi) << 16) | read_ucregister(MV_SCRlo);
+
+	do_gettimeofday(&tv);
+	tdiff = TIMEDIFF(tv, em->last_status_time);
+	em->last_status_time = tv;
+	em->irqcount = 0;
+	em->frames = frames;
+	em->scr = scr;
+	if (copy_to_user((void *) usermsg, tmpstr, strlen(tmpstr) + 1))
+		return -EFAULT;
+	return 0;
+}
+
+
+int em8300_ioctl_setvideomode(struct em8300_s *em, int mode)
+{
+	long int encoder;
+
+	switch (mode) {
+	case EM8300_VIDEOMODE_PAL:
+		encoder = ENCODER_MODE_PAL;
+		break;
+	case EM8300_VIDEOMODE_PAL60:
+		encoder = ENCODER_MODE_PAL60;
+		break;
+	case EM8300_VIDEOMODE_NTSC:
+		encoder = ENCODER_MODE_NTSC;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	em->video_mode = mode;
+
+	em8300_dicom_disable(em);
+
+	if (em->encoder) {
+		em->encoder->driver->command(em->encoder, ENCODER_CMD_SETMODE, (void *)encoder);
+	}
+	em8300_dicom_enable(em);
+	em8300_dicom_update(em);
+
+	return 0;
+}
+
+void em8300_ioctl_enable_videoout(struct em8300_s *em, int mode)
+{
+	em8300_dicom_disable(em);
+
+	if (em->encoder) {
+		em->encoder->driver->command(em->encoder, ENCODER_CMD_ENABLEOUTPUT, (void *)(long int)mode);
+	}
+	em8300_dicom_enable(em);
+}
+
+
+int em8300_ioctl_setaspectratio(struct em8300_s *em, int ratio)
+{
+	em->aspect_ratio = ratio;
+	em8300_dicom_update(em);
+
+	return 0;
+}
+
+int em8300_ioctl_setplaymode(struct em8300_s *em, int mode)
+{
+	switch (mode) {
+	case EM8300_PLAYMODE_PLAY:
+		mpegaudio_command(em, MACOMMAND_PLAY);
+		if (em->playmode == EM8300_PLAYMODE_STOPPED) {
+			em8300_ioctl_enable_videoout(em, 1);
+		}
+		em8300_video_setplaymode(em, mode);
+		break;
+	case EM8300_PLAYMODE_STOPPED:
+		em8300_ioctl_enable_videoout(em, 0);
+		em8300_video_setplaymode(em, mode);
+		break;
+	case EM8300_PLAYMODE_PAUSED:
+		mpegaudio_command(em, MACOMMAND_PAUSE);
+		em8300_video_setplaymode(em, mode);
+		break;
+	default:
+		return -1;
+	}
+	em->playmode = mode;
+
+	return 0;
+}
+
+int em8300_ioctl_setspumode(struct em8300_s *em, int mode)
+{
+	em->sp_mode = mode;
+	return 0;
+}
+
+int em8300_ioctl_overlay_setmode(struct em8300_s *em, int val)
+{
+	switch (val) {
+	case EM8300_OVERLAY_MODE_OFF:
+		if (em->overlay_enabled) {
+			em->clockgen = (em->clockgen & ~CLOCKGEN_MODEMASK) | em->clockgen_tvmode;
+			em8300_clockgen_write(em, em->clockgen);
+			em->overlay_enabled = 0;
+			em->overlay_mode = val;
+			em8300_ioctl_setvideomode(em, em->video_mode);
+			em9010_overlay_update(em);
+		}
+		break;
+	case EM8300_OVERLAY_MODE_RECTANGLE:
+	case EM8300_OVERLAY_MODE_OVERLAY:
+		if (!em->overlay_enabled) {
+			em->clockgen = (em->clockgen & ~CLOCKGEN_MODEMASK) | em->clockgen_overlaymode;
+			em8300_clockgen_write(em, em->clockgen);
+			em->overlay_enabled = 1;
+			em->overlay_mode = val;
+			em8300_dicom_disable(em);
+			em8300_dicom_enable(em);
+			em8300_dicom_update(em);
+			em9010_overlay_update(em);
+		} else {
+			em->overlay_mode = val;
+			em9010_overlay_update(em);
+		}
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+int em8300_ioctl_overlay_setwindow(struct em8300_s *em, em8300_overlay_window_t *w)
+{
+	if (w->xpos < -2000 || w->xpos > 2000) {
+		return 0;
+	}
+	if (w->ypos < -2000 || w->ypos > 2000) {
+		return 0;
+	}
+	if (w->width <= 0 || w->width > 2000) {
+		return 0;
+	}
+	if (w->height <= 0 || w->height > 2000) {
+		return 0;
+	}
+	em->overlay_frame_xpos = w->xpos;
+	em->overlay_frame_ypos = w->ypos;
+	em->overlay_frame_width = w->width;
+	em->overlay_frame_height = w->height;
+
+	if (em->overlay_enabled) {
+		sub_4288c(em, em->overlay_frame_xpos, em->overlay_frame_ypos, em->overlay_frame_width,
+			em->overlay_frame_height, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+	} else {
+		em8300_dicom_update(em);
+	}
+
+	return 1;
+}
+
+int em8300_ioctl_overlay_setscreen(struct em8300_s *em, em8300_overlay_screen_t *s)
+{
+	if (s->xsize < 0 || s->xsize > 2000) {
+		return 0;
+	}
+	if (s->ysize < 0 || s->ysize > 2000) {
+		return 0;
+	}
+
+	em9010_overlay_set_res(em, s->xsize, s->ysize);
+	return 1;
+}
diff -Naurdp a/drivers/media/video/em3800/em8300_main.c b/drivers/media/video/em3800/em8300_main.c
--- a/drivers/media/video/em3800/em8300_main.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_main.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,828 @@
+/*
+	em8300.c - EM8300 MPEG-2 decoder device driver
+
+	Copyright (C) 2000 Henrik Johansson <henrikjo@post.utfors.se>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/sound.h>
+#include <linux/signal.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <linux/poll.h>
+#include <linux/devfs_fs_kernel.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_compat24.h"
+#include "encoder.h"
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+#include "em8300_fifo.h"
+#include "em8300_registration.h"
+
+#ifdef CONFIG_EM8300_IOCTL32
+#include "em8300_ioctl32.h"
+#endif
+
+#if !defined(CONFIG_I2C_ALGOBIT) && !defined(CONFIG_I2C_ALGOBIT_MODULE)
+#error "This needs the I2C Bit Banging Interface in your Kernel"
+#endif
+
+MODULE_AUTHOR("Henrik Johansson <henrikjo@post.utfors.se>");
+MODULE_DESCRIPTION("EM8300 MPEG-2 decoder");
+MODULE_SUPPORTED_DEVICE("em8300");
+MODULE_LICENSE("GPL");
+#if EM8300_MAJOR != 0
+MODULE_ALIAS_CHARDEV_MAJOR(EM8300_MAJOR);
+#endif
+
+EXPORT_NO_SYMBOLS;
+
+static unsigned int use_bt865[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+MODULE_PARM(use_bt865, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(use_bt865, "Set this to 1 if you have a bt865. It changes some internal register values. Defaults to 0.");
+
+/*
+ * Module params by Jonas Birm (birme@jpl.nu)
+ */
+#ifdef CONFIG_EM8300_DICOMPAL
+int dicom_other_pal[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+#else
+int dicom_other_pal[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+#endif
+MODULE_PARM(dicom_other_pal, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(dicom_other_pal, "If this is set, then some internal register values are swapped for PAL and NTSC. Defaults to 1.");
+
+#ifdef CONFIG_EM8300_DICOMFIX
+int dicom_fix[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+#else
+int dicom_fix[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+#endif
+MODULE_PARM(dicom_fix, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(dicom_fix, "If this is set then some internal register values are changed. Fixes green screen problems for some. Defaults to 1.");
+
+#ifdef CONFIG_EM8300_DICOMCTRL
+int dicom_control[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+#else
+int dicom_control[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+#endif
+MODULE_PARM(dicom_control, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(dicom_control, "If this is set then some internal register values are changed. Fixes green screen problems for some. Defaults to 1.");
+
+#ifdef CONFIG_EM8300_UCODETIMEOUT
+int bt865_ucode_timeout[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+#else
+int bt865_ucode_timeout[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+#endif
+MODULE_PARM(bt865_ucode_timeout, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(bt865_ucode_timeout, "Set this to 1 if you have a bt865 and get timeouts when uploading the microcode. Defaults to 0.");
+
+#ifdef CONFIG_EM8300_LOOPBACK
+int activate_loopback[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 1 };
+#else
+int activate_loopback[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = 0 };
+#endif
+MODULE_PARM(activate_loopback, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(activate_loopback, "If you lose video after loading the modules or uploading the microcode set this to 1. Defaults to 0.");
+
+int major = EM8300_MAJOR;
+MODULE_PARM(major, "i");
+MODULE_PARM_DESC(major, "Major number used for the devices. "
+		 "0 means automatically assigned. "
+		 "Defaults to " __MODULE_STRING(EM8300_MAJOR) ".");
+
+static int em8300_cards,clients;
+
+static struct em8300_s em8300[EM8300_MAX];
+
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+int dsp_num[EM8300_MAX] = { [ 0 ... EM8300_MAX-1 ] = -1 };
+MODULE_PARM(dsp_num, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(dsp_num, "The /dev/dsp number to assign to the card. -1 for automatic (this is the default).");
+
+static int dsp_num_table[16];
+#endif
+
+/* structure to keep track of the memory that has been allocated by
+   the user via mmap() */
+struct memory_info
+{
+	struct list_head item;
+	long length;
+	char *ptr;
+};
+
+static struct pci_device_id em8300_ids[] = {
+	{ PCI_VENDOR_ID_SIGMADESIGNS, PCI_DEVICE_ID_SIGMADESIGNS_EM8300,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, em8300_ids);
+
+static irqreturn_t em8300_irq(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct em8300_s *em = (struct em8300_s *) dev_id;
+	int irqstatus;
+	struct timeval tv;
+
+	irqstatus = read_ucregister(Q_IrqStatus);
+
+	if (irqstatus & 0x8000) {
+		write_ucregister(Q_IrqMask, 0x0);
+		writel(2, &em->mem[EM8300_INTERRUPT_ACK]);
+
+		write_ucregister(Q_IrqStatus, 0x8000);
+
+		if (irqstatus & IRQSTATUS_VIDEO_FIFO) {
+			em8300_fifo_check(em->mvfifo);
+		}
+
+		if (irqstatus & IRQSTATUS_AUDIO_FIFO) {
+			em8300_fifo_check(em->mafifo);
+		}
+
+		if (irqstatus & IRQSTATUS_VIDEO_VBL) {
+			em8300_fifo_check(em->spfifo);
+			em8300_video_check_ptsfifo(em);
+			em8300_spu_check_ptsfifo(em);
+
+			do_gettimeofday(&tv);
+			em->irqtimediff = TIMEDIFF(tv, em->tv);
+			em->tv = tv;
+			em->irqcount++;
+			wake_up(&em->vbi_wait);
+		}
+
+		write_ucregister(Q_IrqMask, em->irqmask);
+		write_ucregister(Q_IrqStatus, 0x0000);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+static void release_em8300(struct em8300_s *em)
+{
+	if(em->encoder) {
+		em->encoder->driver->command(em->encoder, ENCODER_CMD_ENABLEOUTPUT, (void *) 0);
+	}
+
+#ifdef CONFIG_MTRR
+	if (em->mtrr_reg) {
+		mtrr_del(em->mtrr_reg,em->adr, em->memsize);
+	}
+#endif
+
+	em8300_i2c_exit(em);
+
+	write_ucregister(Q_IrqMask, 0);
+	write_ucregister(Q_IrqStatus, 0);
+	writel(0, &em->mem[0x2000]);
+
+	em8300_fifo_free(em->mvfifo);
+	em8300_fifo_free(em->mafifo);
+	em8300_fifo_free(em->spfifo);
+
+	/* free it */
+	free_irq(em->dev->irq, em);
+
+	/* unmap and free memory */
+	if (em->mem) {
+		iounmap((unsigned *) em->mem);
+	}
+}
+
+static int em8300_io_ioctl(struct inode* inode, struct file* filp, unsigned int cmd, unsigned long arg)
+{
+	struct em8300_s *em = filp->private_data;
+	int subdevice = EM8300_IMINOR(inode) % 4;
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_AUDIO:
+		return em8300_audio_ioctl(em, cmd, arg);
+	case EM8300_SUBDEVICE_VIDEO:
+		return em8300_video_ioctl(em, cmd, arg);
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		return em8300_spu_ioctl(em, cmd, arg);
+	case EM8300_SUBDEVICE_CONTROL:
+		return em8300_control_ioctl(em, cmd, arg);
+	}
+
+	return -EINVAL;
+}
+
+static int em8300_io_open(struct inode* inode, struct file* filp)
+{
+	int card = EM8300_IMINOR(inode) / 4;
+	int subdevice = EM8300_IMINOR(inode) % 4;
+	struct em8300_s *em = &em8300[card];
+	int err = 0;
+
+	if (card >= em8300_cards) {
+		return -ENODEV;
+	}
+
+	if (subdevice != EM8300_SUBDEVICE_CONTROL) {
+		if (em8300[card].inuse[subdevice]) {
+			return -EBUSY;
+		}
+	}
+
+	filp->private_data = &em8300[card];
+
+	/* initalize the memory list */
+	INIT_LIST_HEAD(&em->memory);
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_CONTROL:
+		em8300[card].nonblock[0] = ((filp->f_flags&O_NONBLOCK) == O_NONBLOCK);
+		break;
+	case EM8300_SUBDEVICE_AUDIO:
+		em8300[card].nonblock[1] = ((filp->f_flags&O_NONBLOCK) == O_NONBLOCK);
+		err = em8300_audio_open(em);
+		break;
+	case EM8300_SUBDEVICE_VIDEO:
+		em8300_require_ucode(em);
+		if (!em->ucodeloaded) {
+			return -ENODEV;
+		}
+		em8300[card].nonblock[2] = ((filp->f_flags&O_NONBLOCK) == O_NONBLOCK);
+		em8300_video_open(em);
+
+		em8300_ioctl_enable_videoout(em, 1);
+
+		em8300_video_setplaymode(em, EM8300_PLAYMODE_PLAY);
+		break;
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		em8300_require_ucode(em);
+		if (!em->ucodeloaded) {
+			return -ENODEV;
+		}
+		em8300[card].nonblock[3] = ((filp->f_flags&O_NONBLOCK) == O_NONBLOCK);
+		err = em8300_spu_open(em);
+		break;
+	default:
+		return -ENODEV;
+		break;
+	}
+
+	if (err) {
+		return err;
+	}
+
+	em8300[card].inuse[subdevice]++;
+
+	clients++;
+	pr_debug("em8300_main.o: Opening device %d, Clients:%d\n", subdevice, clients);
+
+	EM8300_MOD_INC_USE_COUNT;
+
+	return(0);
+}
+
+static ssize_t em8300_io_write(struct file *file, const char * buf, size_t count, loff_t *ppos)
+{
+	struct em8300_s *em = file->private_data;
+	int subdevice = EM8300_IMINOR(file->f_dentry->d_inode) % 4;
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_VIDEO:
+		em->nonblock[2] = ((file->f_flags&O_NONBLOCK) == O_NONBLOCK);
+		return em8300_video_write(em, buf, count, ppos);
+		break;
+	case EM8300_SUBDEVICE_AUDIO:
+		em->nonblock[1] = ((file->f_flags&O_NONBLOCK) == O_NONBLOCK);
+		return em8300_audio_write(em, buf, count, ppos);
+		break;
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		em->nonblock[3] = ((file->f_flags&O_NONBLOCK) == O_NONBLOCK);
+		return em8300_spu_write(em, buf, count, ppos);
+		break;
+	default:
+		return -EPERM;
+	}
+}
+
+int em8300_io_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct em8300_s *em = file->private_data;
+	unsigned long size = vma->vm_end - vma->vm_start;
+	int subdevice = EM8300_IMINOR(file->f_dentry->d_inode) % 4;
+
+	if (subdevice != EM8300_SUBDEVICE_CONTROL) {
+		return -EPERM;
+	}
+
+	switch (vma->vm_pgoff) {
+	case 1: {
+		/* fixme: we should count the total size of allocated memories
+		   so we don't risk a out-of-memory or denial-of-service attack... */
+
+		char *mem = 0;
+		struct memory_info *info = NULL;
+		unsigned long adr = 0;
+		unsigned long size = vma->vm_end - vma->vm_start;
+		unsigned long pages = (size+(PAGE_SIZE-1))/PAGE_SIZE;
+		/* round up the memory */
+		size = pages * PAGE_SIZE;
+
+		/* allocate the physical contiguous memory */
+		mem = (char*)kmalloc(pages*PAGE_SIZE, GFP_KERNEL);
+		if( mem == NULL) {
+			return -ENOMEM;
+		}
+		/* clear out the memory for sure */
+		memset(mem, 0x00, pages*PAGE_SIZE);
+
+		/* reserve all pages */
+		for(adr = (long)mem; adr < (long)mem + size; adr += PAGE_SIZE) {
+			SetPageReserved(virt_to_page(adr));
+		}
+
+		/* lock the area*/
+		vma->vm_flags |=VM_LOCKED;
+
+		/* remap the memory to user space */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,3)
+		if (remap_page_range(vma->vm_start, virt_to_phys((void *)mem), size, vma->vm_page_prot)) {
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+		if (remap_page_range(vma, vma->vm_start, virt_to_phys((void *)mem), size, vma->vm_page_prot)) {
+#else
+		if (remap_pfn_range(vma, vma->vm_start, virt_to_phys((void *)mem) >> PAGE_SHIFT, size, vma->vm_page_prot)) {
+#endif
+			kfree(mem);
+			return -EAGAIN;
+		}
+
+		/* put the physical address into the first dword of the memory */
+		*((long*)mem) = virt_to_phys((void *)mem);
+
+		/* keep track of the memory we have allocated */
+		info = (struct memory_info*)vmalloc(sizeof(struct memory_info));
+		if( NULL == info ) {
+			kfree(mem);
+			return -ENOMEM;
+		}
+
+		info->ptr = mem;
+		info->length = size;
+		list_add_tail(&info->item,&em->memory);
+
+		break;
+	}
+	case 0:
+		if (size > em->memsize) {
+			return -EINVAL;
+		}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,3)
+		remap_page_range(vma->vm_start, em->adr, vma->vm_end - vma->vm_start, vma->vm_page_prot);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+		remap_page_range(vma, vma->vm_start, em->adr, vma->vm_end - vma->vm_start, vma->vm_page_prot);
+#else
+		remap_pfn_range(vma, vma->vm_start, em->adr >> PAGE_SHIFT, vma->vm_end - vma->vm_start, vma->vm_page_prot);
+#endif
+		vma->vm_file = file;
+		atomic_inc(&file->f_dentry->d_inode->i_count);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int em8300_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct em8300_s *em = file->private_data;
+	int subdevice = EM8300_IMINOR(file->f_dentry->d_inode) % 4;
+	unsigned int mask = 0;
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_AUDIO:
+		poll_wait(file, &em->mafifo->wait, wait);
+		if (file->f_mode & FMODE_WRITE) {
+			if (em8300_fifo_freeslots(em->mafifo)) {
+				pr_debug("Poll audio - Free slots: %d\n", em8300_fifo_freeslots(em->mafifo));
+				mask |= POLLOUT | POLLWRNORM;
+			}
+		}
+		break;
+	case EM8300_SUBDEVICE_VIDEO:
+		poll_wait(file, &em->mvfifo->wait, wait);
+		if (file->f_mode & FMODE_WRITE) {
+			if (em8300_fifo_freeslots(em->mvfifo)) {
+				pr_debug("Poll video - Free slots: %d\n", em8300_fifo_freeslots(em->mvfifo));
+				mask |= POLLOUT | POLLWRNORM;
+			}
+		}
+		break;
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		poll_wait(file, &em->spfifo->wait, wait);
+		if (file->f_mode & FMODE_WRITE) {
+			if (em8300_fifo_freeslots(em->spfifo)) {
+				pr_debug("Poll subpic - Free slots: %d\n", em8300_fifo_freeslots(em->spfifo));
+				mask |= POLLOUT | POLLWRNORM;
+			}
+		}
+	}
+
+	return mask;
+}
+
+int em8300_io_release(struct inode* inode, struct file *filp)
+{
+	struct em8300_s *em = filp->private_data;
+	int subdevice = EM8300_IMINOR(inode) % 4;
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_AUDIO:
+		em8300_audio_release(em);
+		break;
+	case EM8300_SUBDEVICE_VIDEO:
+		em8300_video_release(em);
+		em8300_ioctl_enable_videoout(em, 0);
+		break;
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		em8300_spu_release(em);    /* Do we need this one ? */
+		break;
+	}
+
+	while( 0 == list_empty(&em->memory)) {
+		unsigned long adr = 0;
+
+		struct memory_info *info = list_entry(em->memory.next, struct memory_info, item);
+		list_del(&info->item);
+
+		for(adr = (long)info->ptr; adr < (long)info->ptr + info->length; adr += PAGE_SIZE) {
+			ClearPageReserved(virt_to_page(adr));
+		}
+
+		kfree(info->ptr);
+		vfree(info);
+	}
+
+	em->inuse[subdevice]--;
+
+	clients--;
+	pr_debug("em8300_main.o: Releasing device %d, clients:%d\n", subdevice, clients);
+
+	EM8300_MOD_DEC_USE_COUNT;
+
+	return(0);
+}
+
+struct file_operations em8300_fops = {
+	owner: THIS_MODULE,
+	write: em8300_io_write,
+	ioctl: em8300_io_ioctl,
+	mmap: em8300_io_mmap,
+	poll: em8300_poll,
+	open: em8300_io_open,
+	release: em8300_io_release,
+};
+
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+static int em8300_dsp_ioctl(struct inode* inode, struct file* filp, unsigned int cmd, unsigned long arg)
+{
+	struct em8300_s *em = filp->private_data;
+	return em8300_audio_ioctl(em, cmd, arg);
+}
+
+static int em8300_dsp_open(struct inode* inode, struct file* filp)
+{
+	int dsp_number = ((EM8300_IMINOR(inode) >> 4) & 0x0f);
+	int card = dsp_num_table[dsp_number] - 1;
+	int err = 0;
+
+	pr_debug("em8300: opening dsp %i for card %i\n", dsp_number, card);
+
+	if (card < 0 || card >= em8300_cards) {
+		return -ENODEV;
+	}
+
+	if (em8300[card].inuse[EM8300_SUBDEVICE_AUDIO]) {
+		return -EBUSY;
+	}
+
+	filp->private_data = &em8300[card];
+
+	err = em8300_audio_open(&em8300[card]);
+
+	if (err) {
+		return err;
+	}
+
+	em8300[card].inuse[EM8300_SUBDEVICE_AUDIO]++;
+
+	clients++;
+	pr_debug("em8300_main.o: Opening device %d, Clients:%d\n", EM8300_SUBDEVICE_AUDIO, clients);
+
+	EM8300_MOD_INC_USE_COUNT;
+
+	return(0);
+}
+
+static ssize_t em8300_dsp_write(struct file *file, const char * buf, size_t count, loff_t *ppos)
+{
+	struct em8300_s *em = file->private_data;
+	return em8300_audio_write(em, buf, count, ppos);
+}
+
+static unsigned int em8300_dsp_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct em8300_s *em = file->private_data;
+	unsigned int mask = 0;
+	poll_wait(file, &em->mafifo->wait, wait);
+	if (file->f_mode & FMODE_WRITE) {
+		if (em8300_fifo_freeslots(em->mafifo)) {
+			pr_debug("Poll dsp - Free slots: %d\n", em8300_fifo_freeslots(em->mafifo));
+			mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+	return mask;
+}
+
+int em8300_dsp_release(struct inode* inode, struct file* filp)
+{
+	struct em8300_s *em = filp->private_data;
+
+	em8300_audio_release(em);
+
+	em->inuse[EM8300_SUBDEVICE_AUDIO]--;
+
+	clients--;
+	pr_debug("em8300_main.o: Releasing device %d, clients:%d\n", EM8300_SUBDEVICE_AUDIO, clients);
+
+	EM8300_MOD_DEC_USE_COUNT;
+
+	return(0);
+}
+
+static struct file_operations em8300_dsp_audio_fops = {
+	owner: THIS_MODULE,
+	write: em8300_dsp_write,
+	ioctl: em8300_dsp_ioctl,
+	poll: em8300_dsp_poll,
+	open: em8300_dsp_open,
+	release: em8300_dsp_release,
+};
+#endif
+
+static int init_em8300(struct em8300_s *em)
+{
+	write_register(0x30000, read_register(0x30000));
+
+	write_register(0x1f50, 0x123);
+
+	if (read_register(0x1f50) == 0x123) {
+		em->chip_revision = 2;
+		if (0x40 & read_register(0x1c08)) {
+			em->var_video_value = 3375; /* was 0xd34 = 3380 */
+			em->mystery_divisor = 0x107ac;
+			em->var_ucode_reg2 = 0x272;
+			em->var_ucode_reg3 = 0x8272;
+			if (0x20 & read_register(0x1c08)) {
+				if (use_bt865[em->card_nr]) {
+					em->var_ucode_reg1 = 0x800;
+				} else {
+					em->var_ucode_reg1 = 0x818;
+				}
+			}
+		} else {
+			em->var_video_value = 0xce4;
+			em->mystery_divisor = 0x101d0;
+			em->var_ucode_reg2 = 0x25a;
+			em->var_ucode_reg3 = 0x825a;
+		}
+	} else {
+		em->chip_revision = 1;
+		em->var_ucode_reg1 = 0x80;
+		em->var_video_value = 0xce4;
+		em->mystery_divisor = 0x101d0;
+		em->var_ucode_reg2 = 0xC7;
+		em->var_ucode_reg3 = 0x8c7;
+	}
+
+	pr_info("em8300_main.o: Chip revision: %d\n", em->chip_revision);
+	pr_debug("em8300_main.o: use_bt865: %d\n", use_bt865[em->card_nr]);
+	em8300_i2c_init(em);
+
+	if (activate_loopback[em->card_nr] == 0) {
+		em->clockgen_tvmode = CLOCKGEN_TVMODE_1;
+		em->clockgen_overlaymode = CLOCKGEN_OVERLAYMODE_1;
+	} else {
+		em->clockgen_tvmode = CLOCKGEN_TVMODE_2;
+		em->clockgen_overlaymode = CLOCKGEN_OVERLAYMODE_2;
+	}
+
+	pr_debug("em8300_main.o: activate_loopback: %d\n", activate_loopback);
+
+	return 0;
+}
+
+static int __devinit em8300_probe(struct pci_dev *dev,
+				  const struct pci_device_id *pci_id)
+{
+	unsigned char revision;
+	struct em8300_s *em;
+	int result;
+
+	em = &em8300[em8300_cards];
+	em->dev = dev;
+	em->card_nr = em8300_cards;
+	em->adr = dev->resource[0].start;
+	em->memsize = 1024 * 1024;
+
+	if ((result = pci_enable_device(dev)) != 0) {
+		printk(KERN_ERR "em8300: Unable to enable PCI device\n");
+		return result;
+	}
+
+	pci_read_config_byte(dev, PCI_CLASS_REVISION, &revision);
+	em->pci_revision = revision;
+	pr_info("em8300: EM8300 %x (rev %d) ", dev->device, revision);
+	printk("bus: %d, devfn: %d, irq: %d, ", dev->bus->number, dev->devfn, dev->irq);
+	printk("memory: 0x%08lx.\n", em->adr);
+
+	em->mem = ioremap(em->adr, em->memsize);
+	pr_info("em8300: mapped-memory at 0x%p\n", em->mem);
+#ifdef CONFIG_MTRR
+	em->mtrr_reg = mtrr_add(em->adr, em->memsize, MTRR_TYPE_UNCACHABLE, 1);
+	if (em->mtrr_reg) pr_info("em8300: using MTRR\n");
+#endif
+
+	init_waitqueue_head(&em->video_ptsfifo_wait);
+	init_waitqueue_head(&em->vbi_wait);
+	init_waitqueue_head(&em->sp_ptsfifo_wait);
+
+	result = request_irq(dev->irq, em8300_irq, SA_SHIRQ | SA_INTERRUPT, "em8300", (void *) em);
+
+	if (result == -EINVAL) {
+		printk(KERN_ERR "em8300: Bad irq number or handler\n");
+		return -EINVAL;
+	}
+
+	pci_set_master(dev);
+	pci_set_drvdata(dev, em);
+
+	em->irqmask = 0;
+	em->encoder = NULL;
+	em->linecounter=0;
+
+	init_em8300(em);
+
+	em8300_register_card(em);
+
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+	if ((em->dsp_num = register_sound_dsp(&em8300_dsp_audio_fops, dsp_num[em->card_nr])) < 0) {
+		printk(KERN_ERR "em8300: cannot register oss audio device!\n");
+	} else {
+		dsp_num_table[em->dsp_num >> 4 & 0x0f] = em8300_cards + 1;
+		pr_debug("em8300: registered dsp %i for device %i\n", em->dsp_num >> 4 & 0x0f, em8300_cards);
+	}
+#endif
+
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+	em8300_enable_card(em);
+#endif
+
+	em8300_cards++;
+	return 0;
+}
+
+static void __devexit em8300_remove(struct pci_dev *pci)
+{
+	struct em8300_s *em = pci_get_drvdata(pci);
+
+	if (em) {
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+		em8300_disable_card(em);
+#else
+		if (em->ucodeloaded == 1)
+			em8300_disable_card(em);
+#endif
+
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+		unregister_sound_dsp(em->dsp_num);
+#endif
+
+		em8300_unregister_card(em);
+
+		release_em8300(em);
+	}
+
+	pci_set_drvdata(pci, NULL);
+	pci_disable_device(pci);
+}
+
+static struct pci_driver em8300_driver = {
+	.name     = "Sigma Designs EM8300",
+	.id_table = em8300_ids,
+	.probe    = em8300_probe,
+	.remove   = __devexit_p(em8300_remove),
+};
+
+static void __exit em8300_exit(void)
+{
+#ifdef CONFIG_EM8300_IOCTL32
+	em8300_ioctl32_exit();
+#endif
+
+	pci_unregister_driver(&em8300_driver);
+
+	unregister_chrdev(major, EM8300_LOGNAME);
+
+	em8300_unregister_driver();
+}
+
+static int __init em8300_init(void)
+{
+	int err;
+
+	//memset(&em8300, 0, sizeof(em8300) * EM8300_MAX);
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+	memset(&dsp_num_table, 0, sizeof(dsp_num_table));
+#endif
+
+	em8300_register_driver();
+
+	if (major) {
+		if (register_chrdev(major, EM8300_LOGNAME, &em8300_fops)) {
+			printk(KERN_ERR "em8300: unable to get major %d\n", major);
+			err = -ENODEV;
+			goto err_chrdev;
+		}
+	}
+	else {
+		int m = register_chrdev(major, EM8300_LOGNAME, &em8300_fops);
+		if (m > 0) {
+			major = m;
+		}
+		else {
+			printk(KERN_ERR "em8300: unable to get any majo\n");
+			err = -ENODEV;
+			goto err_chrdev;
+		}
+	}
+
+	if ((err = pci_module_init(&em8300_driver)) < 0) {
+#ifdef MODULE
+		printk(KERN_ERR "Sigmadesigns EM8300 not found or device busy\n");
+#endif
+		goto err_init;
+	}
+
+#ifdef CONFIG_EM8300_IOCTL32
+	em8300_ioctl32_init();
+#endif
+
+	return 0;
+
+ err_init:
+	unregister_chrdev(major, EM8300_LOGNAME);
+
+ err_chrdev:
+	em8300_unregister_driver();
+	return err;
+}
+
+module_init(em8300_init);
+module_exit(em8300_exit);
diff -Naurdp a/drivers/media/video/em3800/em8300_misc.c b/drivers/media/video/em3800/em8300_misc.c
--- a/drivers/media/video/em3800/em8300_misc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_misc.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,140 @@
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+
+#include <linux/soundcard.h>
+
+int em8300_waitfor(struct em8300_s *em, int reg, int val, int mask)
+{
+	int tries;
+
+	for (tries = 0; tries < 100; tries++) {
+		if ((readl(&em->mem[reg]) & mask) == val) {
+			return 0;
+		}
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ/100);
+	}
+
+	return -ETIME;
+}
+
+int em8300_waitfor_not(struct em8300_s *em, int reg, int val, int mask)
+{
+	int tries;
+
+	for (tries = 0; tries < 100; tries++) {
+		if ((readl(&em->mem[reg]) & mask) != val) {
+			return 0;
+		}
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ/100);
+	}
+
+	return -ETIME;
+}
+
+int em8300_setregblock(struct em8300_s *em, int offset, int val, int len)
+{
+	int i;
+
+	for (i = 1000; i; i--) {
+		if (!read_register(0x1c1a)) {
+			break;
+		}
+		if (!i) {
+			return -ETIME;
+		}
+	}
+#if 0 /* FIXME: was in the zeev01 branch, verify if it is necessary */
+	val = val | (val << 8) | (val << 16) | (val << 24);
+#endif
+
+	writel(offset & 0xffff, &em->mem[0x1c11]);
+	writel((offset >> 16) & 0xffff, &em->mem[0x1c12]);
+	writel(len, &em->mem[0x1c13]);
+	writel(len, &em->mem[0x1c14]);
+	writel(0, &em->mem[0x1c15]);
+	writel(1, &em->mem[0x1c16]);
+	writel(1, &em->mem[0x1c17]);
+	writel(offset & 0xffff, &em->mem[0x1c18]);
+	writel(0, &em->mem[0x1c19]);
+
+	writel(1, &em->mem[0x1c1a]);
+
+	for (i = 0; i < len / 4; i++) {
+		writel(val, &em->mem[0x11800]);
+	}
+
+	switch (len % 4) {
+	case 1:
+		writel(val, &em->mem[0x10000]);
+		break;
+	case 2:
+		writel(val, &em->mem[0x10800]);
+		break;
+	case 3:
+		writel(val, &em->mem[0x11000]);
+		break;
+	}
+
+	for (i = 1000; i; i--) {
+		if (!read_register(0x1c1a)) {
+			break;
+		}
+		if (!i) {
+			return -ETIME;
+		}
+	}
+
+#if 0 /* FIXME: was in zeev01 branch, verify if it is necessary */
+	if (em8300_waitfor(em, 0x1c1a, 0, 1))
+		return -ETIME;
+#endif
+
+	return 0;
+}
+
+int em8300_writeregblock(struct em8300_s *em, int offset, unsigned *buf, int len)
+{
+	int i;
+
+	writel(offset & 0xffff, &em->mem[0x1c11]);
+	writel((offset >> 16) & 0xffff, &em->mem[0x1c12]);
+	writel(len, &em->mem[0x1c13]);
+	writel(len, &em->mem[0x1c14]);
+	writel(0, &em->mem[0x1c15]);
+	writel(1, &em->mem[0x1c16]);
+	writel(1, &em->mem[0x1c17]);
+	writel(offset & 0xffff, &em->mem[0x1c18]);
+	writel((offset >> 16) & 0xffff, &em->mem[0x1c19]);
+
+	writel(1, &em->mem[0x1c1a]);
+
+	for (i = 0; i < len / 4; i++) {
+		writel(*buf++, &em->mem[0x11800]);
+	}
+
+	if (em8300_waitfor(em, 0x1c1a, 0, 1)) {
+		return -ETIME;
+	}
+	return 0;
+}
diff -Naurdp a/drivers/media/video/em3800/em8300_procfs.c b/drivers/media/video/em3800/em8300_procfs.c
--- a/drivers/media/video/em3800/em8300_procfs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_procfs.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,186 @@
+/*
+	em8300.c - EM8300 MPEG-2 decoder device driver
+
+	Copyright (C) 2000 Henrik Johansson <henrikjo@post.utfors.se>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+#include <linux/config.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include "em8300_procfs.h"
+#include "em8300_reg.h"
+
+#ifdef CONFIG_PROC_FS
+
+#ifndef EM8300_PROCFS_DIR
+#define EM8300_PROCFS_DIR "em8300"
+#endif
+
+struct proc_dir_entry *em8300_proc;
+
+
+static int em8300_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len = 0;
+	struct em8300_s *em = (struct em8300_s *) data;
+	char *encoder_name;
+
+	*start = 0;
+	*eof = 1;
+
+	len += sprintf(page + len,
+		       "----- Driver Info -----\n");
+	len += sprintf(page + len,
+		       "em8300 module version %s\n",
+		       EM8300_VERSION);
+	/* Device information */
+	len += sprintf(page + len,
+		       "Card revision %d\n",
+		       em->pci_revision);
+	len += sprintf(page + len,
+		       "Chip revision %d\n",
+		       em->chip_revision);
+	switch (em->encoder_type) {
+	case ENCODER_BT865:
+		encoder_name = "BT865";
+		break;
+	case ENCODER_ADV7170:
+		encoder_name = "ADV7170";
+		break;
+	case ENCODER_ADV7175:
+		encoder_name = "ADV7175";
+		break;
+	default:
+		len += sprintf(page + len, "No known video encoder found.\n");
+		goto encoder_done;
+	}
+	len += sprintf(page + len,
+		       "Video encoder: %s at address 0x%02x on %s\n",
+		       encoder_name, em->encoder->addr,
+		       em->encoder->adapter->name);
+ encoder_done:
+	len += sprintf(page + len,
+		       "Memory mapped at address range 0x%0lx->0x%0lx%s\n",
+		       (unsigned long int) em->mem,
+		       (unsigned long int) em->mem
+		       + (unsigned long int) em->memsize,
+		       em->mtrr_reg ? " (FIFOs using MTRR)" : "");
+	if (em->ucodeloaded) {
+		len += sprintf(page + len,
+			       "Microcode version 0x%02x loaded\n",
+			       read_ucregister(MicroCodeVersion));
+		em8300_dicom_get_dbufinfo(em);
+		len += sprintf(page + len,
+			       "Display buffer resolution: %dx%d\n",
+			       em->dbuf_info.xsize, em->dbuf_info.ysize);
+		len += sprintf(page + len,
+			       "Dicom set to %s\n",
+			       em->dicom_tvout ? "TV-out" : "overlay");
+		if (em->dicom_tvout) {
+			len += sprintf(page + len,
+				       "Using %s\n",
+				       (em->video_mode == EM8300_VIDEOMODE_PAL) ? "PAL" : "NTSC");
+			len += sprintf(page + len,
+				       "Aspect is %s\n",
+				       (em->aspect_ratio == EM8300_ASPECTRATIO_4_3) ? "4:3" : "16:9");
+		} else {
+			len += sprintf(page + len,
+				       "em9010 %s\n",
+				       em->overlay_enabled ? "online" : "offline");
+			len += sprintf(page + len,
+				       "Video mapped to screen coordinates %dx%d (%dx%d)\n",
+				       em->overlay_frame_xpos, em->overlay_frame_ypos,
+				       em->overlay_xres, em->overlay_yres);
+		}
+	} else {
+		len += sprintf(page + len, "Microcode not loaded\n");
+	}
+	len += sprintf(page + len,
+		       "%s audio output\n",
+		       (em->audio_mode == EM8300_AUDIOMODE_ANALOG) ? "Analog" : "Digital");
+	return len;
+}
+
+
+static void em8300_procfs_register_card(struct em8300_s *em)
+{
+	char devname[64];
+	if (em8300_proc) {
+		struct proc_dir_entry *proc;
+		sprintf(devname, "%d", em->card_nr);
+		proc = create_proc_entry(devname,
+					 S_IFREG | S_IRUGO,
+					 em8300_proc);
+		if (proc) {
+			proc->data = (void *) em;
+			proc->read_proc = em8300_proc_read;
+			proc->owner = THIS_MODULE;
+		}
+	}
+}
+
+static void em8300_procfs_unregister_card(struct em8300_s *em)
+{
+	char devname[64];
+	if (em8300_proc) {
+		sprintf(devname, "%d", em->card_nr);
+		remove_proc_entry(devname, em8300_proc);
+	}
+}
+
+static void em8300_procfs_unregister_driver(void)
+{
+	if (em8300_proc) {
+		remove_proc_entry(EM8300_PROCFS_DIR, &proc_root);
+	}
+}
+
+static void em8300_procfs_register_driver(void)
+{
+	em8300_proc = create_proc_entry(EM8300_PROCFS_DIR,
+					S_IFDIR | S_IRUGO | S_IXUGO,
+					&proc_root);
+	if (em8300_proc) {
+		em8300_proc->owner = THIS_MODULE;
+	} else {
+		printk(KERN_ERR "em8300: unable to register proc entry!\n");
+	}
+}
+
+struct em8300_registrar_s em8300_procfs_registrar =
+{
+	.register_driver   = &em8300_procfs_register_driver,
+	.register_card     = &em8300_procfs_register_card,
+	.enable_card       = NULL,
+	.disable_card      = NULL,
+	.unregister_card   = &em8300_procfs_unregister_card,
+	.unregister_driver = &em8300_procfs_unregister_driver,
+};
+
+#else /* CONFIG_PROC_FS */
+
+struct em8300_registrar_s em8300_procfs_registrar =
+{
+	.register_driver   = NULL,
+	.register_card     = NULL,
+	.enable_card       = NULL,
+	.disable_card      = NULL,
+	.unregister_card   = NULL,
+	.unregister_driver = NULL,
+};
+
+#endif /* CONFIG_PROC_FS */
diff -Naurdp a/drivers/media/video/em3800/em8300_procfs.h b/drivers/media/video/em3800/em8300_procfs.h
--- a/drivers/media/video/em3800/em8300_procfs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_procfs.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,28 @@
+/* $Id: em8300_procfs.h,v 1.2 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_procfs.h -- interface to the procfs filesystem
+ * Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef EM8300_PROCFS_H
+#define EM8300_PROCFS_H
+
+#include "em8300_registration.h"
+
+extern struct em8300_registrar_s em8300_procfs_registrar;
+
+#endif /* EM8300_PROCFS_H */
diff -Naurdp a/drivers/media/video/em3800/em8300_reg.c b/drivers/media/video/em3800/em8300_reg.c
--- a/drivers/media/video/em3800/em8300_reg.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_reg.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,114 @@
+char *ucodereg_names[] = {
+	"MV_Command",
+	"MV_Status",
+	"MV_BuffStart_Lo",
+	"MV_BuffStart_Hi",
+	"MV_BuffSize_Lo",
+	"MV_BuffSize_Hi",
+	"MV_RdPtr_Lo",
+	"MV_RdPtr_Hi",
+	"MV_Threshold",
+	"MV_Wrptr_Lo",
+	"MV_Wrptr_Hi",
+	"MV_PCIRdPtr",
+	"MV_PCIWrPtr",
+	"MV_PCISize",
+	"MV_PCIStart",
+	"MV_PTSRdPtr",
+	"MV_PTSSize",
+	"MV_PTSFifo",
+	"MV_SCRSpeed",
+	"MV_SCRlo",
+	"MV_SCRhi",
+	"MV_FrameCntLo",
+	"MV_FrameCntHi",
+	"MV_FrameEventLo",
+	"MV_FrameEventHi",
+	"MV_AccSpeed",
+	"Width_Buf3",
+	"MA_Command",
+	"MA_Status",
+	"MA_BuffStart_Lo",
+	"MA_BuffStart_Hi",
+	"MA_BuffSize",
+	"MA_BuffSize_Hi",
+	"MA_Rdptr",
+	"MA_Rdptr_Hi",
+	"MA_Threshold",
+	"MA_Wrptr",
+	"MA_Wrptr_Hi",
+	"Q_IrqMask",
+	"Q_IrqStatus",
+	"Q_IntCnt",
+	"MA_PCIRdPtr",
+	"MA_PCIWrPtr",
+	"MA_PCISize",
+	"MA_PCIStart",
+	"SP_Command",
+	"SP_Status",
+	"SP_BuffStart_Lo",
+	"SP_BuffStart_Hi",
+	"SP_BuffSize_Lo",
+	"SP_BuffSize_Hi",
+	"SP_RdPtr_Lo",
+	"SP_RdPtr_Hi",
+	"SP_Wrptr_Lo",
+	"SP_Wrptr_Hi",
+	"SP_PCIRdPtr",
+	"SP_PCIWrPtr",
+	"SP_PCISize",
+	"SP_PCIStart",
+	"SP_PTSRdPtr",
+	"SP_PTSSize",
+	"SP_PTSFifo",
+	"DICOM_DisplayBuffer",
+	"Vsync_DBuf",
+	"DICOM_TvOut",
+	"DICOM_UpdateFlag",
+	"DICOM_VSyncLo1",
+	"DICOM_VSyncLo2",
+	"DICOM_VSyncDelay1",
+	"DICOM_VSyncDelay2",
+	"DICOM_Display_Data",
+	"PicPTSLo",
+	"PicPTSHi",
+	"Error_Code",
+	"DisplayHorSize",
+	"Line21Buf1_Cnt",
+	"Line21Buf2_Cnt",
+	"TimeCodeHi",
+	"TimeCodeLo",
+	"AUTH_Challenge",
+	"AUTH_Response",
+	"AUTH_Command",
+	"Timer_Cnt",
+	"Ovl_Addr",
+	"Button_Color",
+	"Button_Contrast",
+	"Button_Top",
+	"Button_Bottom",
+	"Button_Left",
+	"Button_Right",
+	"SP_Palette",
+	"DICOM_FrameTop",
+	"DICOM_FrameBottom",
+	"DICOM_FrameLeft",
+	"DICOM_FrameRight",
+	"DICOM_VisibleTop",
+	"DICOM_VisibleBottom",
+	"DICOM_VisibleLeft",
+	"DICOM_VisibleRight",
+	"DICOM_BCSLuma",
+	"DICOM_BCSChroma",
+	"DICOM_Control",
+	"DICOM_Controlx",
+	"MV_CryptKey",
+	"DICOM_Kmin",
+	"MicroCodeVersion",
+	"ForcedLeftParity",
+	"L21_Buf1",
+	"L21_Buf2",
+	"Mute_Pattern",
+	"Mute_Patternrityhtm",
+	NULL
+};
diff -Naurdp a/drivers/media/video/em3800/em8300_reg.h b/drivers/media/video/em3800/em8300_reg.h
--- a/drivers/media/video/em3800/em8300_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_reg.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,141 @@
+/*
+  Register access macros
+*/
+
+#define register_ptr(a) &em->mem[a]
+#define ucregister_ptr(a) &em->mem[em->ucode_regs[a]]
+#define ucregister(a) em->ucode_regs[a]
+
+#define write_register(a,v) writel(v, &em->mem[a])
+#define read_register(a) readl(&em->mem[a])
+#define write_ucregister(a,v) writel(v, &em->mem[em->ucode_regs[a]])
+#define read_ucregister(a) readl(&em->mem[em->ucode_regs[a]])
+
+/*
+  EM8300 fixed registers
+*/
+
+#define EM8300_I2C_OE 0x1f4e
+#define EM8300_I2C_PIN 0x1f4d
+#define EM8300_AUDIO_RATE 0x1fb0
+#define EM8300_INTERRUPT_ACK 0x1ffa
+#define EM8300_HSYNC_HI 0x1f43
+#define EM8300_HSYNC_LO 0x1f42
+#define EM8300_VSYNC_HI 0x1f45
+
+/*
+  EM8300 microcode dependent registers
+*/
+
+#define MV_Command 0
+#define MV_Status 1
+#define MV_BuffStart_Lo 2
+#define MV_BuffStart_Hi 3
+#define MV_BuffSize_Lo 4
+#define MV_BuffSize_Hi 5
+#define MV_RdPtr_Lo 6
+#define MV_RdPtr_Hi 7
+#define MV_Threshold 8
+#define MV_Wrptr_Lo 9
+#define MV_Wrptr_Hi 10
+#define MV_PCIRdPtr 11
+#define MV_PCIWrPtr 12
+#define MV_PCISize 13
+#define MV_PCIStart 14
+#define MV_PTSRdPtr 15
+#define MV_PTSSize 16
+#define MV_PTSFifo 17
+#define MV_SCRSpeed 18
+#define MV_SCRlo 19
+#define MV_SCRhi 20
+#define MV_FrameCntLo 21
+#define MV_FrameCntHi 22
+#define MV_FrameEventLo 23
+#define MV_FrameEventHi 24
+#define MV_AccSpeed 25
+#define Width_Buf3 26
+#define MA_Command 27
+#define MA_Status 28
+#define MA_BuffStart_Lo 29
+#define MA_BuffStart_Hi 30
+#define MA_BuffSize 31
+#define MA_BuffSize_Hi 32
+#define MA_Rdptr 33
+#define MA_Rdptr_Hi 34
+#define MA_Threshold 35
+#define MA_Wrptr 36
+#define MA_Wrptr_Hi 37
+#define Q_IrqMask 38
+#define Q_IrqStatus 39
+#define Q_IntCnt 40
+#define MA_PCIRdPtr 41
+#define MA_PCIWrPtr 42
+#define MA_PCISize 43
+#define MA_PCIStart 44
+#define SP_Command 45
+#define SP_Status 46
+#define SP_BuffStart_Lo 47
+#define SP_BuffStart_Hi 48
+#define SP_BuffSize_Lo 49
+#define SP_BuffSize_Hi 50
+#define SP_RdPtr_Lo 51
+#define SP_RdPtr_Hi 52
+#define SP_Wrptr_Lo 53
+#define SP_Wrptr_Hi 54
+#define SP_PCIRdPtr 55
+#define SP_PCIWrPtr 56
+#define SP_PCISize 57
+#define SP_PCIStart 58
+#define SP_PTSRdPtr 59
+#define SP_PTSSize 60
+#define SP_PTSFifo 61
+#define DICOM_DisplayBuffer 62
+#define Vsync_DBuf 63
+#define DICOM_TvOut 64
+#define DICOM_UpdateFlag 65
+#define DICOM_VSyncLo1 66
+#define DICOM_VSyncLo2 67
+#define DICOM_VSyncDelay1 68
+#define DICOM_VSyncDelay2 69
+#define DICOM_Display_Data 70
+#define PicPTSLo 71
+#define PicPTSHi 72
+#define Error_Code 73
+#define DisplayHorSize 74
+#define Line21Buf1_Cnt 75
+#define Line21Buf2_Cnt 76
+#define TimeCodeHi 77
+#define TimeCodeLo 78
+#define AUTH_Challenge 79
+#define AUTH_Response 80
+#define AUTH_Command 81
+#define Timer_Cnt 82
+#define Ovl_Addr 83
+#define Button_Color 84
+#define Button_Contrast 85
+#define Button_Top 86
+#define Button_Bottom 87
+#define Button_Left 88
+#define Button_Right 89
+#define SP_Palette 90
+#define DICOM_FrameTop 91
+#define DICOM_FrameBottom 92
+#define DICOM_FrameLeft 93
+#define DICOM_FrameRight 94
+#define DICOM_VisibleTop 95
+#define DICOM_VisibleBottom 96
+#define DICOM_VisibleLeft 97
+#define DICOM_VisibleRight 98
+#define DICOM_BCSLuma 99
+#define DICOM_BCSChroma 100
+#define DICOM_Control 101
+#define DICOM_Controlx 102
+#define MV_CryptKey 103
+#define DICOM_Kmin 104
+#define MicroCodeVersion 105
+#define ForcedLeftParity 106
+#define L21_Buf1 107
+#define L21_Buf2 108
+#define Mute_Pattern 109
+#define Mute_Patternrityhtm 110
+
diff -Naurdp a/drivers/media/video/em3800/em8300_registration.c b/drivers/media/video/em3800/em8300_registration.c
--- a/drivers/media/video/em3800/em8300_registration.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_registration.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,89 @@
+/* $Id: em8300_registration.c,v 1.5 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_registration.c -- common interface for everything that needs
+ *                          to be registered
+ * Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "em8300_registration.h"
+
+#include "em8300_procfs.h"
+#include "em8300_devfs.h"
+#include "em8300_sysfs.h"
+
+static struct em8300_registrar_s *registrars[] =
+{
+	&em8300_procfs_registrar,
+	&em8300_devfs_registrar,
+	&em8300_sysfs_registrar,
+	NULL
+};
+
+
+void em8300_register_driver(void)
+{
+	int i;
+	for (i = 0; registrars[i]; i++) {
+		if (registrars[i]->register_driver)
+			registrars[i]->register_driver();
+	}
+}
+
+void em8300_register_card(struct em8300_s *em)
+{
+	int i;
+	for (i = 0; registrars[i]; i++) {
+		if (registrars[i]->register_card)
+			registrars[i]->register_card(em);
+	}
+}
+
+void em8300_enable_card(struct em8300_s *em)
+{
+	int i;
+	for (i = 0; registrars[i]; i++) {
+		if (registrars[i]->enable_card)
+			registrars[i]->enable_card(em);
+	}
+}
+
+void em8300_disable_card(struct em8300_s *em)
+{
+	int i;
+	for (i = 0; registrars[i]; i++) {
+		if (registrars[i]->disable_card)
+			registrars[i]->disable_card(em);
+	}
+}
+
+void em8300_unregister_card(struct em8300_s *em)
+{
+	int i;
+	for (i = 0; registrars[i]; i++) {
+		if (registrars[i]->unregister_card)
+			registrars[i]->unregister_card(em);
+	}
+}
+
+void em8300_unregister_driver(void)
+{
+	int i;
+	for (i = 0; registrars[i]; i++) {
+		if (registrars[i]->unregister_driver)
+			registrars[i]->unregister_driver();
+	}
+}
diff -Naurdp a/drivers/media/video/em3800/em8300_registration.h b/drivers/media/video/em3800/em8300_registration.h
--- a/drivers/media/video/em3800/em8300_registration.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_registration.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,49 @@
+/* $Id: em8300_registration.h,v 1.2 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_registration.h -- common interface for everything that needs
+ *                          to be registered
+ * Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef EM8300_REGISTRATION_H
+#define EM8300_REGISTRATION_H
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/time.h>
+#include <linux/em8300.h>
+
+struct em8300_registrar_s {
+	void (*register_driver)(void);
+	void (*register_card)(struct em8300_s *);
+	void (*enable_card)(struct em8300_s *);
+	void (*disable_card)(struct em8300_s *);
+	void (*unregister_card)(struct em8300_s *);
+	void (*unregister_driver)(void);
+};
+
+extern void em8300_register_driver(void);
+extern void em8300_register_card(struct em8300_s *);
+extern void em8300_enable_card(struct em8300_s *);
+extern void em8300_disable_card(struct em8300_s *);
+extern void em8300_unregister_card(struct em8300_s *);
+extern void em8300_unregister_driver(void);
+
+#endif /* EM8300_REGISTRATION_H */
diff -Naurdp a/drivers/media/video/em3800/em8300_spu.c b/drivers/media/video/em3800/em8300_spu.c
--- a/drivers/media/video/em3800/em8300_spu.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_spu.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2005 Jon Burgess <jburgess@uklinux.net>
+ */
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/wait.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+#include "em8300_fifo.h"
+
+#include "em8300_compat24.h"
+
+unsigned default_palette[16] = {
+	0xe18080, 0x2b8080, 0x847b9c, 0x51ef5a, 0x7d8080, 0xb48080, 0xa910a5,
+	0x6addca, 0xd29210, 0x1c76b8, 0x50505a, 0x30b86d, 0x5d4792,
+	0x3dafa5, 0x718947, 0xeb8080
+};
+
+int em8300_spu_setpalette(struct em8300_s *em, unsigned *pal)
+{
+	int i, palette;
+
+	palette = ucregister(SP_Palette);
+
+	for (i=0; i < 16; i++) {
+		write_register(palette + i * 2, pal[i] >> 16);
+		write_register(palette + i * 2 + 1, pal[i] & 0xffff);
+	}
+
+	return 0;
+}
+
+int em8300_spu_button(struct em8300_s *em, em8300_button_t *btn)
+{
+	write_ucregister(SP_Command, 0x2);
+
+	if (btn == 0) /* btn = 0 means release button */
+		return 0;
+
+	write_ucregister(Button_Color, btn->color);
+	write_ucregister(Button_Contrast, btn->contrast);
+	write_ucregister(Button_Top, btn->top);
+	write_ucregister(Button_Bottom, btn->bottom);
+	write_ucregister(Button_Left, btn->left);
+	write_ucregister(Button_Right, btn->right);
+
+	write_ucregister(DICOM_UpdateFlag, 1);
+	write_ucregister(SP_Command, 0x102);
+
+	return 0;
+}
+
+void em8300_spu_check_ptsfifo(struct em8300_s *em)
+{
+	int ptsfifoptr;
+
+		ptsfifoptr = ucregister(SP_PTSFifo) + 2 * em->sp_ptsfifo_ptr;
+
+		if (!(read_register(ptsfifoptr + 1) & 1)) {
+			wake_up_interruptible(&em->sp_ptsfifo_wait);
+		}
+	}
+
+ssize_t em8300_spu_write(struct em8300_s *em, const char * buf, size_t count, loff_t *ppos)
+{
+	int flags = 0;
+	long ret;
+
+	if (!(em->sp_mode)) return 0;
+//	em->sp_ptsvalid=0;
+	if (em->sp_ptsvalid) {
+		int ptsfifoptr;
+
+		ptsfifoptr = ucregister(SP_PTSFifo) + 2 * em->sp_ptsfifo_ptr;
+		ret = wait_event_interruptible_timeout(em->sp_ptsfifo_wait,
+						       (read_register(ptsfifoptr + 1) & 1) == 0, HZ);
+		if (ret == 0) {
+			printk(KERN_ERR "em8300_spu.c: SPU Fifo timeout\n");
+			return -EINTR;
+		}
+		else if (ret < 0)
+			return ret;
+
+		write_register(ptsfifoptr + 0, em->sp_pts >> 16);
+		write_register(ptsfifoptr + 1, (em->sp_pts & 0xffff) | 1);
+		em->sp_ptsfifo_ptr++;
+		em->sp_ptsfifo_ptr &= read_ucregister(SP_PTSSize) / 2 - 1;
+
+		em->sp_ptsvalid = 0;
+	}
+
+	if (em->nonblock[3]) {
+		return em8300_fifo_write(em->spfifo, count, buf, flags);
+	} else {
+		return em8300_fifo_writeblocking(em->spfifo, count, buf, flags);
+	}
+}
+
+int em8300_spu_ioctl(struct em8300_s *em, unsigned int cmd, unsigned long arg)
+{
+	unsigned clu[16];
+
+	switch (cmd) {
+	case EM8300_IOCTL_SPU_SETPTS:
+		if (get_user(em->sp_pts, (int *) arg)) {
+			return -EFAULT;
+		}
+		em->sp_pts >>= 1;
+		em->sp_ptsvalid = 1;
+		break;
+	case EM8300_IOCTL_SPU_SETPALETTE:
+		if (copy_from_user(clu, (void *) arg, 16 * 4))
+			return -EFAULT;
+		em8300_spu_setpalette(em, clu);
+		break;
+	case EM8300_IOCTL_SPU_BUTTON:
+		{
+			em8300_button_t btn;
+			if (arg == 0) {
+				em8300_spu_button(em, 0);
+				break;
+			}
+			if (copy_from_user(&btn, (void*) arg, sizeof(btn)))
+				return -EFAULT;
+			em8300_spu_button(em, &btn);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int em8300_spu_init(struct em8300_s *em)
+{
+	return 0;
+}
+
+int em8300_spu_open(struct em8300_s *em)
+{
+	em->sp_ptsfifo_ptr = 0;
+	em->sp_ptsvalid = 0;
+	em->sp_mode = 1;
+	em8300_spu_setpalette(em, default_palette);
+	write_ucregister(SP_Command, 0x2);
+
+	return 0;
+}
+
+void em8300_spu_release(struct em8300_s *em)
+{
+	em->sp_pts = 0;
+	em->sp_ptsvalid = 0;
+	em->sp_count = 0;
+	em->sp_ptsfifo_ptr = 0;
+	em8300_fifo_sync(em->spfifo);
+
+	return em8300_spu_check_ptsfifo(em);
+}
diff -Naurdp a/drivers/media/video/em3800/em8300_sysfs.c b/drivers/media/video/em3800/em8300_sysfs.c
--- a/drivers/media/video/em3800/em8300_sysfs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_sysfs.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,183 @@
+/* $Id: em8300_sysfs.c,v 1.6 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_sysfs.c -- interface to the sysfs filesystem
+ * Copyright (C) 2004 Eric Donohue <epd3j@hotmail.com>
+ * Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "em8300_sysfs.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,46)
+
+#include <linux/pci.h>
+#include <linux/device.h>
+
+#ifndef EM8300_SYSFS_DIR
+#define EM8300_SYSFS_DIR "em8300"
+#endif
+
+static void em8300_class_release(struct class_device *cd)
+{
+	printk (KERN_DEBUG "em8300_class_release(%s)\n", cd->class_id);
+}
+
+static struct class em8300_class = {
+	.name = EM8300_SYSFS_DIR,
+	.release = em8300_class_release
+};
+
+static ssize_t show_version(struct class_device *cd, char *buf)
+{
+	sprintf(buf, "%s\n", EM8300_VERSION);
+	return strlen(buf) + 1;
+}
+
+static CLASS_DEVICE_ATTR(version, S_IRUGO, show_version, NULL);
+
+static ssize_t show_devnum(struct class_device *cd, char *buf)
+{
+	char name[64];
+	struct em8300_s *em = container_of(cd, struct em8300_s, classdev);
+	sprintf(name, "%s-%d", EM8300_LOGNAME, em->card_nr);
+	if(!strcmp(cd->class_id, name)) {
+		dev_t dev = MKDEV(major, em->card_nr * 4 + 0);
+		return print_dev_t(buf, dev);
+	}
+	sprintf(name, "%s_mv-%d", EM8300_LOGNAME, em->card_nr);
+	if(!strcmp(cd->class_id, name)) {
+		dev_t dev = MKDEV(major, em->card_nr * 4 + 1);
+		return print_dev_t(buf, dev);
+	}
+	sprintf(name, "%s_ma-%d", EM8300_LOGNAME, em->card_nr);
+	if(!strcmp(cd->class_id, name)) {
+		dev_t dev = MKDEV(major, em->card_nr * 4 + 2);
+		return print_dev_t(buf, dev);
+	}
+	sprintf(name, "%s_sp-%d", EM8300_LOGNAME, em->card_nr);
+	if(!strcmp(cd->class_id, name)) {
+		dev_t dev = MKDEV(major, em->card_nr * 4 + 3);
+		return print_dev_t(buf, dev);
+	}
+	return -ENODEV;
+}
+
+static CLASS_DEVICE_ATTR(dev, S_IRUGO, show_devnum, NULL);
+
+static struct class_device_attribute *em8300_attrs[] = {
+	&class_device_attr_version,
+	&class_device_attr_dev,
+	NULL
+};
+
+static void em8300_sysfs_register_driver(void)
+{
+	class_register(&em8300_class);
+}
+
+static void em8300_sysfs_register_card(struct em8300_s *em)
+{
+	char name[64] = "";
+	int i;
+
+	em->classdev.class = &em8300_class;
+
+	em->classdev.dev = &em->dev->dev;
+
+	sprintf(name,"%s-%d", EM8300_LOGNAME, em->card_nr);
+	strcpy(em->classdev.class_id, name);
+
+	if(class_device_register(&em->classdev))
+		printk(KERN_ERR "Unable to register em8300 class device\n");
+
+	for(i = 0; em8300_attrs[i]; i++)
+		class_device_create_file(&(em->classdev), em8300_attrs[i]);
+}
+
+static void em8300_sysfs_enable_card(struct em8300_s *em)
+{
+	char name[64] = "";
+	int i;
+
+	em->classdev_mv.class = &em8300_class;
+	em->classdev_ma.class = &em8300_class;
+	em->classdev_sp.class = &em8300_class;
+
+	em->classdev_mv.dev = &em->dev->dev;
+	em->classdev_ma.dev = &em->dev->dev;
+	em->classdev_sp.dev = &em->dev->dev;
+
+	sprintf(name,"%s_mv-%d", EM8300_LOGNAME, em->card_nr);
+	strcpy(em->classdev_mv.class_id, name);
+	sprintf(name,"%s_ma-%d", EM8300_LOGNAME, em->card_nr);
+	strcpy(em->classdev_ma.class_id, name);
+	sprintf(name,"%s_sp-%d", EM8300_LOGNAME, em->card_nr);
+	strcpy(em->classdev_sp.class_id, name);
+
+	if(class_device_register(&em->classdev_mv))
+		printk(KERN_ERR "Unable to register em8300_mv class device\n");
+	if(class_device_register(&em->classdev_ma))
+		printk(KERN_ERR "Unable to register em8300_ma class device\n");
+	if(class_device_register(&em->classdev_sp))
+		printk(KERN_ERR "Unable to register em8300_sp class device\n");
+
+	for(i = 0; em8300_attrs[i]; i++) {
+		class_device_create_file(&(em->classdev_mv), em8300_attrs[i]);
+		class_device_create_file(&(em->classdev_ma), em8300_attrs[i]);
+		class_device_create_file(&(em->classdev_sp), em8300_attrs[i]);
+	}
+}
+
+static void em8300_sysfs_disable_card(struct em8300_s *em)
+{
+	class_device_unregister(&(em->classdev_mv));
+	class_device_unregister(&(em->classdev_ma));
+	class_device_unregister(&(em->classdev_sp));
+}
+
+static void em8300_sysfs_unregister_card(struct em8300_s *em)
+{
+	class_device_unregister(&(em->classdev));
+}
+
+static void em8300_sysfs_unregister_driver(void)
+{
+	class_unregister(&em8300_class);
+}
+
+struct em8300_registrar_s em8300_sysfs_registrar =
+{
+	.register_driver   = &em8300_sysfs_register_driver,
+	.register_card     = &em8300_sysfs_register_card,
+	.enable_card       = &em8300_sysfs_enable_card,
+	.disable_card      = &em8300_sysfs_disable_card,
+	.unregister_card   = &em8300_sysfs_unregister_card,
+	.unregister_driver = &em8300_sysfs_unregister_driver,
+};
+
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,46) */
+
+struct em8300_registrar_s em8300_sysfs_registrar =
+{
+	.register_driver   = NULL,
+	.register_card     = NULL,
+	.enable_card       = NULL,
+	.disable_card      = NULL,
+	.unregister_card   = NULL,
+	.unregister_driver = NULL,
+};
+
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,46) */
diff -Naurdp a/drivers/media/video/em3800/em8300_sysfs.h b/drivers/media/video/em3800/em8300_sysfs.h
--- a/drivers/media/video/em3800/em8300_sysfs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_sysfs.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,28 @@
+/* $Id: em8300_sysfs.h,v 1.2 2005/10/19 18:02:44 scop Exp $
+ *
+ * em8300_sysfs.h -- interface to the sysfs filesystem
+ * Copyright (C) 2004 Eric Donohue <epd3j@hotmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef EM8300_SYSFS_H
+#define EM8300_SYSFS_H
+
+#include "em8300_registration.h"
+
+extern struct em8300_registrar_s em8300_sysfs_registrar;
+
+#endif /* EM8300_SYSFS_H */
diff -Naurdp a/drivers/media/video/em3800/em8300_ucode.c b/drivers/media/video/em3800/em8300_ucode.c
--- a/drivers/media/video/em3800/em8300_ucode.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_ucode.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,238 @@
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+
+#include <linux/soundcard.h>
+
+#include "em8300_reg.c"
+
+static int upload_block(struct em8300_s *em, int blocktype, int offset, int len, unsigned char *buf)
+{
+	int i, val;
+
+	switch (blocktype) {
+	case 4:
+		offset *= 2;
+		writel(offset & 0xffff, &em->mem[0x1c11]);
+		writel((offset >> 16) & 0xffff, &em->mem[0x1c12]);
+		writel(len, &em->mem[0x1c13]);
+		writel(len, &em->mem[0x1c14]);
+		writel(0, &em->mem[0x1c15]);
+		writel(1, &em->mem[0x1c16]);
+		writel(1, &em->mem[0x1c17]);
+		writel(offset & 0xffff, &em->mem[0x1c18]);
+		writel((offset >> 16) & 0xffff, &em->mem[0x1c19]);
+
+		writel(1, &em->mem[0x1c1a]);
+
+		for (i = 0; i < len; i += 4) {
+			val = (buf[i + 2] << 24) | (buf[i + 3] << 16) | (buf[i] << 8) | buf[i + 1];
+			writel(val, &em->mem[0x11800]);
+		}
+
+		if (em8300_waitfor(em, 0x1c1a, 0, 1)) {
+			return -ETIME;
+		}
+		break;
+	case 1:
+		for (i = 0; i < len; i += 4) {
+			val = (buf[i + 1] << 24) | (buf[i] << 16) | (buf[i + 3] << 8) | buf[i + 2];
+			writel(val, &em->mem[offset / 2 + i / 4]);
+		}
+		break;
+	case 2:
+		for (i = 0; i < len; i += 2) {
+			val = (buf[i + 1] << 8) | buf[i];
+			writel(val, &em->mem[0x1000 + offset + i / 2]);
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static
+int upload_prepare(struct em8300_s *em)
+{
+	writel(0x1ff00, &em->mem[0x30000]);
+	writel(0x123, &em->mem[0x1f50]);
+
+	writel(0x0, &em->mem[0x20001]);
+	writel(0x2, &em->mem[0x2000]);
+	writel(0x0, &em->mem[0x2000]);
+	writel(0xffff, &em->mem[0x1ff8]);
+	writel(0xffff, &em->mem[0x1ff9]);
+	writel(0xff00, &em->mem[0x1ff8]);
+	writel(0xff00, &em->mem[0x1ff9]);
+
+	if (em->chip_revision == 1) {
+		writel(0x8c7, &em->mem[0x1c04]);
+		writel(0x80, &em->mem[0x1c00]);
+		writel(0xc7, &em->mem[0x1c04]);
+	}
+	writel(em->var_ucode_reg3, &em->mem[0x1c04]);
+	writel(em->var_ucode_reg1, &em->mem[0x1c00]);
+	writel(em->var_ucode_reg2, &em->mem[0x1c04]);
+
+	/* em->mem[0x1c08]; */
+	writel(0x8, &em->mem[0x1c10]);
+	writel(0x8, &em->mem[0x1c20]);
+	writel(0x8, &em->mem[0x1c30]);
+	writel(0x8, &em->mem[0x1c40]);
+	writel(0x8, &em->mem[0x1c50]);
+	writel(0x8, &em->mem[0x1c60]);
+	writel(0x8, &em->mem[0x1c70]);
+	writel(0x8, &em->mem[0x1c80]);
+	writel(0x10, &em->mem[0x1c90]);
+	writel(0x10, &em->mem[0x1ca0]);
+	writel(0x8, &em->mem[0x1cb0]);
+	writel(0x8, &em->mem[0x1cc0]);
+	writel(0x8, &em->mem[0x1cd0]);
+	writel(0x8, &em->mem[0x1ce0]);
+	writel(0x5555, &em->mem[0x1c01]);
+	writel(0x55a, &em->mem[0x1c02]);
+	writel(0x0, &em->mem[0x1c03]);
+
+	return 0;
+}
+
+void em8300_ucode_upload(struct em8300_s *em, void *ucode, int ucode_size)
+{
+	int flags, offset, len;
+	unsigned char *p;
+	int memcount, i;
+	char regname[128];
+
+	upload_prepare(em);
+
+	memcount = 0;
+
+	p = ucode;
+	while (memcount < ucode_size) {
+		flags =  p[0] | (p[1] << 8); p += 2;
+		offset = p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24); p += 4;
+		len = p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24); p += 4;
+		memcount += 10;
+		len *= 2;
+
+		if (!flags)
+			break;
+
+		switch (flags & 0xf00) {
+		case 0:
+			upload_block(em, flags, offset, len, p);
+			break;
+		case 0x200:
+			for (i = 0;i < len; i++) {
+				if (p[i]) {
+					regname[i] = p[i] ^ 0xff;
+				} else {
+					break;
+				}
+			}
+			regname[i] = 0;
+
+			for (i = 0; i < MAX_UCODE_REGISTER; i++) {
+				if (!strcmp(ucodereg_names[i], regname)) {
+					em->ucode_regs[i] = 0x1000 + offset;
+					break;
+				}
+			}
+			break;
+		}
+		memcount += len;
+		p += len;
+	}
+}
+
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+
+#include <linux/firmware.h>
+#include "em8300_fifo.h"
+#include "em8300_registration.h"
+
+void em8300_require_ucode(struct em8300_s *em)
+{
+	if (!em->ucodeloaded) {
+		const struct firmware *fw_entry = NULL;
+
+		if (request_firmware(&fw_entry, "em8300.bin", &em->dev->dev) != 0) {
+			printk(KERN_ALERT "%s: firmware %s is missing, cannot start.\n",
+			       em->dev->dev.bus_id, "em8300.bin");
+			return;
+		}
+		em8300_ucode_upload(em, fw_entry->data, fw_entry->size);
+
+		em8300_dicom_init(em);
+
+		if (em8300_video_setup(em)) {
+			return;
+		}
+
+		if (em->mvfifo) {
+			em8300_fifo_free(em->mvfifo);
+		}
+		if (em->mafifo) {
+			em8300_fifo_free(em->mafifo);
+		}
+		if (em->spfifo) {
+			em8300_fifo_free(em->spfifo);
+		}
+
+		if (!(em->mvfifo = em8300_fifo_alloc())) {
+			return;
+		}
+
+		if (!(em->mafifo = em8300_fifo_alloc())) {
+			return;
+		}
+
+		if (!(em->spfifo = em8300_fifo_alloc())) {
+			return;
+		}
+
+		em8300_fifo_init(em,em->mvfifo, MV_PCIStart, MV_PCIWrPtr, MV_PCIRdPtr, MV_PCISize, 0x900, FIFOTYPE_VIDEO);
+		em8300_fifo_init(em,em->mafifo, MA_PCIStart, MA_PCIWrPtr, MA_PCIRdPtr, MA_PCISize, 0x1000, FIFOTYPE_AUDIO);
+		//	em8300_fifo_init(em,em->spfifo, SP_PCIStart, SP_PCIWrPtr, SP_PCIRdPtr, SP_PCISize, 0x1000, FIFOTYPE_VIDEO);
+		em8300_fifo_init(em,em->spfifo, SP_PCIStart, SP_PCIWrPtr, SP_PCIRdPtr, SP_PCISize, 0x800, FIFOTYPE_VIDEO);
+		em8300_spu_init(em);
+
+		if (em8300_audio_setup(em)) {
+			return;
+		}
+
+		em8300_ioctl_enable_videoout(em, 1);
+
+		em->ucodeloaded = 1;
+
+		printk(KERN_NOTICE "em8300: Microcode version 0x%02x loaded\n", read_ucregister(MicroCodeVersion));
+
+	}
+}
+
+#else
+
+void em8300_require_ucode(struct em8300_s *em)
+{
+	return;
+}
+
+#endif
diff -Naurdp a/drivers/media/video/em3800/em8300_video.c b/drivers/media/video/em3800/em8300_video.c
--- a/drivers/media/video/em3800/em8300_video.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em8300_video.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,440 @@
+/*
+ * Copyright (C) 2005 Jon Burgess <jburgess@uklinux.net>
+ */
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/wait.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+#include "em8300_fifo.h"
+
+#include <linux/soundcard.h>
+
+#include "em8300_compat24.h"
+
+extern int bt865_ucode_timeout[EM8300_MAX];
+
+static int mpegvideo_command(struct em8300_s *em, int cmd)
+{
+	if (em8300_waitfor(em, ucregister(MV_Command), 0xffff, 0xffff)) {
+		return -1;
+	}
+
+	write_ucregister(MV_Command, cmd);
+
+	if ((cmd == MVCOMMAND_DISPLAYBUFINFO) || (cmd == 0x10)) {
+		return em8300_waitfor_not(em, ucregister(DICOM_Display_Data), 0, 0xffff);
+	} else {
+		return em8300_waitfor(em, ucregister(MV_Command), 0xffff, 0xffff);
+	}
+}
+
+int em8300_video_setplaymode(struct em8300_s *em, int mode)
+{
+	if (mode == EM8300_PLAYMODE_FRAMEBUF) {
+		mpegvideo_command(em, MVCOMMAND_DISPLAYBUFINFO);
+		em->video_playmode = mode;
+		return 0;
+	}
+
+	if (em->video_playmode != mode) {
+		switch (mode) {
+		case EM8300_PLAYMODE_STOPPED:
+			em->video_ptsfifo_ptr = 0;
+			em->video_offset = 0;
+			mpegvideo_command(em, MVCOMMAND_STOP);
+			break;
+		case EM8300_PLAYMODE_PLAY:
+			em->video_pts = 0;
+			em->video_lastpts = 0;
+			if (em->video_playmode == EM8300_PLAYMODE_STOPPED) {
+				write_ucregister(MV_FrameEventLo, 0xffff);
+				write_ucregister(MV_FrameEventHi, 0x7fff);
+			}
+			mpegvideo_command(em, MVCOMMAND_START);
+			break;
+		case EM8300_PLAYMODE_PAUSED:
+			mpegvideo_command(em, MVCOMMAND_PAUSE);
+			break;
+		default:
+			return -1;
+		}
+
+		em->video_playmode = mode;
+
+		return 0;
+	}
+
+	return -1;
+}
+
+int em8300_video_sync(struct em8300_s *em)
+{
+	int rdptr, wrptr, rdptr_last, synctimeout;
+
+	rdptr_last = 0;
+	synctimeout = 0;
+
+	do {
+		wrptr = read_ucregister(MV_Wrptr_Lo) |
+			(read_ucregister(MV_Wrptr_Hi) << 16);
+		rdptr = read_ucregister(MV_RdPtr_Lo) |
+			(read_ucregister(MV_RdPtr_Hi) << 16);
+
+		if (rdptr == wrptr) {
+			break;
+		}
+
+		if (rdptr == rdptr_last) {
+			printk(KERN_DEBUG "em8300_video.o: Video sync rdptr is stuck at 0x%08x, wrptr 0x%08x, left %d\n", rdptr, wrptr, wrptr - rdptr);
+			break;
+		}
+		rdptr_last = rdptr;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ / 2);
+
+		if (signal_pending(current)) {
+			set_current_state(TASK_RUNNING);
+			printk(KERN_ERR "em8300_video.o: Video sync interrupted\n");
+			return -EINTR;
+		}
+	} while (++synctimeout < 4);
+
+	if (rdptr != wrptr) {
+		printk(KERN_DEBUG "em8300_video.o: Video sync timeout\n");
+	}
+
+	set_current_state(TASK_RUNNING);
+
+	return 0;
+}
+
+int em8300_video_flush(struct em8300_s *em)
+{
+	write_ucregister(MV_Wrptr_Lo, 0);
+	write_ucregister(MV_Wrptr_Hi, 0);
+	write_ucregister(MV_RdPtr_Lo, 0);
+	write_ucregister(MV_RdPtr_Hi, 0);
+	writel(readl(em->mvfifo->readptr), em->mvfifo->writeptr);
+
+	em->video_ptsvalid = 0;
+	em->video_pts = 0;
+	em->video_ptsfifo_ptr = 0;
+	em->video_offset = 0;
+
+	write_ucregister(SP_Wrptr_Lo, 0);
+	write_ucregister(SP_Wrptr_Hi, 0);
+	write_ucregister(SP_RdPtr_Lo, 0);
+	write_ucregister(SP_RdPtr_Hi, 0);
+	writel(readl(em->spfifo->readptr), em->spfifo->writeptr);
+ 
+	em->sp_ptsfifo_ptr = 0;
+	em->sp_ptsvalid = 0;
+	em->sp_pts = 0;
+
+	return 0;
+}
+
+void set_dicom_kmin(struct em8300_s *em)
+{
+	int kmin;
+
+	kmin = (em->overlay_70 + 10) * 150645 / em->mystery_divisor;
+	if (kmin > 0x900) {
+		kmin = 0x900;
+	}
+	write_ucregister(DICOM_Kmin, kmin);
+	pr_debug("em8300: register DICOM_Kmin = 0x%x\n", kmin);
+}
+
+int em8300_video_setup(struct em8300_s *em)
+{
+	write_register(0x1f47, 0x0);
+
+	if (em->encoder_type == ENCODER_BT865) {
+		write_register(0x1f5e, 0x9efe);
+		write_ucregister(DICOM_Control, 0x9efe);
+	} else {
+		write_register(0x1f5e, 0x9afe);
+		write_ucregister(DICOM_Control, 0x9afe);
+	}
+
+	write_register(EM8300_I2C_PIN, 0x3c3c);
+	write_register(EM8300_I2C_OE, 0x3c00);
+	write_register(EM8300_I2C_OE, 0x3c3c);
+
+	write_register(EM8300_I2C_PIN, 0x808);
+	write_register(EM8300_I2C_PIN, 0x1010);
+
+	em9010_init(em);
+
+	em9010_write(em, 7, 0x40);
+	em9010_write(em, 9, 0x4);
+
+	em9010_read(em, 0);
+
+	udelay(100);
+
+	write_ucregister(DICOM_UpdateFlag, 0x0);
+
+	write_ucregister(DICOM_VisibleLeft, 0x168);
+	write_ucregister(DICOM_VisibleTop, 0x2e);
+	write_ucregister(DICOM_VisibleRight, 0x36b);
+	write_ucregister(DICOM_VisibleBottom, 0x11e);
+	write_ucregister(DICOM_FrameLeft, 0x168);
+	write_ucregister(DICOM_FrameTop, 0x2e);
+	write_ucregister(DICOM_FrameRight, 0x36b);
+	write_ucregister(DICOM_FrameBottom, 0x11e);
+	em8300_dicom_enable(em);
+
+	em9010_write16(em, 0x8, 0xff);
+	em9010_write16(em, 0x10, 0xff);
+	em9010_write16(em, 0x20, 0xff);
+
+	em9010_write(em, 0xa, 0x0);
+
+	if (em9010_cabledetect(em)) {
+		pr_debug("em8300: overlay loop-back cable detected\n");
+	}
+
+	pr_debug("em8300: overlay reg 0x80 = %x \n", em9010_read16(em, 0x80));
+
+	em9010_write(em, 0xb, 0xc8);
+
+	pr_debug("em8300: register 0x1f4b = %x (0x138)\n", read_register(0x1f4b));
+
+	em9010_write16(em, 1, 0x4fe);
+	em9010_write(em, 1, 4);
+	em9010_write(em, 5, 0);
+	em9010_write(em, 6, 0);
+	em9010_write(em, 7, 0x40);
+	em9010_write(em, 8, 0x80);
+	em9010_write(em, 0xc, 0x8c);
+	em9010_write(em, 9, 0);
+
+	set_dicom_kmin(em);
+
+	em9010_write(em, 7, 0x80);
+	em9010_write(em, 9, 0);
+
+	if (bt865_ucode_timeout[em->card_nr]) {
+		write_register(0x1f47, 0x18);
+	}
+	if (em->encoder_type == ENCODER_BT865) {
+		write_register(0x1f5e, 0x9efe);
+		write_ucregister(DICOM_Control, 0x9efe);
+	} else {
+		if (!bt865_ucode_timeout[em->card_nr]) {
+			write_register(0x1f47, 0x18);
+		}
+		write_register(0x1f5e,0x9afe);
+		write_ucregister(DICOM_Control, 0x9afe);
+	}
+
+	write_ucregister(DICOM_UpdateFlag, 0x1);
+
+	udelay(100);
+
+	write_ucregister(ForcedLeftParity, 0x2);
+
+	write_ucregister(MV_Threshold, 0x90); // was 0x50 for BT865, but this works too
+
+	write_register(EM8300_INTERRUPT_ACK, 0x2);
+	write_ucregister(Q_IrqMask, 0x0);
+	write_ucregister(Q_IrqStatus, 0x0);
+	write_ucregister(Q_IntCnt, 0x64);
+
+	write_register(0x1ffb, em->var_video_value);
+
+	write_ucregister(MA_Threshold, 0x8);
+
+	/* Release reset */
+	write_register(0x2000, 0x1);
+
+	if (mpegvideo_command(em, MVCOMMAND_DISPLAYBUFINFO)) {
+		printk(KERN_ERR "em8300_video: mpegvideo_command(0x11) failed\n");
+		return -ETIME;
+	}
+	em8300_dicom_get_dbufinfo(em);
+
+	write_ucregister(SP_Status, 0x0);
+
+	if (mpegvideo_command(em, 0x10)) {
+		printk(KERN_ERR "em8300: mpegvideo_command(0x10) failed\n");
+		return -ETIME;
+	}
+
+	em8300_video_setspeed(em, 0x900);
+
+	write_ucregister(MV_FrameEventLo, 0xffff);
+	write_ucregister(MV_FrameEventHi, 0x7fff);
+
+	em8300_ioctl_setvideomode(em, EM8300_VIDEOMODE_DEFAULT);
+	em8300_ioctl_setaspectratio(em, EM8300_ASPECTRATIO_4_3);
+
+	em8300_dicom_setBCS(em, 500, 500, 500);
+
+	if (em8300_dicom_update(em)) {
+		printk(KERN_ERR "em8300: DICOM Update failed\n");
+		return -ETIME;
+	}
+
+	em->video_playmode = -1;
+	em8300_video_setplaymode(em, EM8300_PLAYMODE_STOPPED);
+
+	return 0;
+}
+
+void em8300_video_setspeed(struct em8300_s *em, int speed)
+{
+	if (read_ucregister(MicroCodeVersion) >= 0x29) {
+		write_ucregister(MV_SCRSpeed, speed);
+	} else {
+		write_ucregister(MV_SCRSpeed, speed >> 8);
+	}
+}
+
+void em8300_video_check_ptsfifo(struct em8300_s *em)
+{
+	int ptsfifoptr;
+
+	ptsfifoptr = ucregister(MV_PTSFifo) + 4 * em->video_ptsfifo_ptr;
+
+	if (!(read_register(ptsfifoptr + 3) & 1)) {
+		wake_up_interruptible(&em->video_ptsfifo_wait);
+	}
+}
+
+ssize_t em8300_video_write(struct em8300_s *em, const char * buf, size_t count, loff_t *ppos)
+{
+	unsigned flags = 0;
+	int written;
+	long ret;
+
+	if (em->video_ptsvalid) {
+		int ptsfifoptr = 0;
+		em->video_pts >>= 1;
+
+		flags = 0x40000000;
+		ptsfifoptr = ucregister(MV_PTSFifo) + 4 * em->video_ptsfifo_ptr;
+
+		ret = wait_event_interruptible_timeout(em->video_ptsfifo_wait,
+						       (read_register(ptsfifoptr + 3) & 1) == 0, HZ);
+		if (ret == 0) {
+			printk(KERN_ERR "em8300_video.c: Video Fifo timeout\n");
+			return -EINTR;
+		}
+		else if (ret < 0)
+			return ret;
+
+#ifdef DEBUG_SYNC
+		pr_info("em8300_video.o: pts: %u\n", em->video_pts >> 1);
+#endif
+
+		write_register(ptsfifoptr, em->video_offset >> 16);
+		write_register(ptsfifoptr + 1, em->video_offset & 0xffff);
+		write_register(ptsfifoptr + 2, em->video_pts >> 16);
+		write_register(ptsfifoptr + 3, (em->video_pts & 0xffff) | 1);
+
+		em->video_ptsfifo_ptr++;
+		em->video_ptsfifo_ptr %= read_ucregister(MV_PTSSize) / 4;
+
+		em->video_ptsvalid = 0;
+	}
+
+	if (em->nonblock[2]) {
+		written = em8300_fifo_write(em->mvfifo, count, buf, flags);
+	} else {
+		written = em8300_fifo_writeblocking(em->mvfifo, count, buf, flags);
+	}
+	if (written > 0) {
+		em->video_offset += written;
+	}
+	return written;
+}
+
+int em8300_video_ioctl(struct em8300_s *em, unsigned int cmd, unsigned long arg)
+{
+	unsigned scr, val;
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(EM8300_IOCTL_VIDEO_SETPTS):
+		if (get_user(em->video_pts, (int *) arg)) {
+			return -EFAULT;
+		}
+
+		if (em->video_pts == 0) {
+			printk("Video SETPTS = 0x%x\n", em->video_pts);
+		}
+
+		if (em->video_pts != em->video_lastpts) {
+			em->video_ptsvalid = 1;
+			em->video_lastpts = em->video_pts;
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_VIDEO_SETSCR):
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (get_user(val, (unsigned*) arg))
+				return -EFAULT;
+			val >>= 1;
+			scr = read_ucregister(MV_SCRlo) | (read_ucregister(MV_SCRhi) << 16);
+			scr -= val;
+			if (scr < 0) scr = -scr;
+			if (scr > 9000) {
+				pr_info("setting scr: %i\n", val);
+				write_ucregister(MV_SCRlo, val & 0xffff);
+				write_ucregister(MV_SCRhi, (val >> 16) & 0xffff);
+			}
+
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			scr = read_ucregister(MV_SCRlo) | (read_ucregister(MV_SCRhi) << 16);
+			if (copy_to_user((void *) arg, &scr, sizeof(unsigned)))
+				return -EFAULT;
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void em8300_video_open(struct em8300_s *em)
+{
+	em->irqmask |= IRQSTATUS_VIDEO_FIFO | IRQSTATUS_VIDEO_VBL;
+	write_ucregister(Q_IrqMask, em->irqmask);
+}
+
+int em8300_video_release(struct em8300_s *em)
+{
+	em->video_ptsfifo_ptr = 0;
+	em->video_offset = 0;
+	em->video_ptsvalid = 0;
+	em8300_fifo_sync(em->mvfifo);
+	em8300_video_sync(em);
+
+	em->irqmask &= ~(IRQSTATUS_VIDEO_FIFO | IRQSTATUS_VIDEO_VBL);
+	write_ucregister(Q_IrqMask, em->irqmask);
+
+	return em8300_video_setplaymode(em, EM8300_PLAYMODE_STOPPED);
+}
diff -Naurdp a/drivers/media/video/em3800/em9010.c b/drivers/media/video/em3800/em9010.c
--- a/drivers/media/video/em3800/em9010.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/em9010.c	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,810 @@
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/time.h>
+
+#include "em8300_reg.h"
+#include <linux/em8300.h>
+
+/* sub_2ac2d */
+static int testcable(struct em8300_s *em)
+{
+	int attempts;
+
+	attempts = 0;
+	while (em9010_read(em, 0x0) & 0x20) {
+		if(attempts++ > 100) {
+			return 0;
+		}
+		mdelay(1);
+	}
+
+	attempts = 0;
+	while (!(em9010_read(em, 0x0) & 0x20)) {
+		if(attempts++ > 100) {
+			return 0;
+		}
+		mdelay(1);
+	}
+
+	return 1;
+}
+
+/* loc_2abac */
+int em9010_cabledetect(struct em8300_s *em)
+{
+	em9010_write(em, 0xb, 0xc8);
+	em9010_write(em, 0x9, 0x4);
+	em9010_write(em, 0xd, 0x44);
+
+	if (testcable(em)) {
+		return 1;
+	}
+
+	em9010_write(em, 0xd, 0x4c);
+
+	if (testcable(em)) {
+		return 1;
+	}
+
+	em9010_write(em, 0x9, 0x0);
+
+	return 0;
+}
+
+/*
+  sub_2AC2D
+
+  locals:
+  a = [ebp-8]
+*/
+
+/* computes `a - b'  and write the result in `result', assumes `a >= b' */
+static inline void my_timeval_less(struct timeval a, struct timeval b, struct timeval * result)
+{
+		if (a.tv_usec < b.tv_usec) {
+			a.tv_sec--;
+			a.tv_usec += 1000000;
+		}
+
+		result->tv_sec = a.tv_sec - b.tv_sec;
+		result->tv_usec = a.tv_usec - b.tv_usec;
+}
+
+static
+int sub_2AC2D(struct em8300_s *em)
+{
+	int a;
+	struct timeval t, t2, tr;
+
+	do_gettimeofday(&t);
+	a = 1000;
+	while (em9010_read(em, 0x0) & 0x20) {
+		if (!a--) {
+			do_gettimeofday(&t2);
+			my_timeval_less(t2, t, &tr);
+			if (tr.tv_usec >= 50 * 1000)
+			return(0);
+			a = 1000;
+		}
+	}
+
+	do_gettimeofday(&t);
+	a = 1000;
+	while (!(em9010_read(em, 0x0) & 0x20)) {
+		if (!a--) {
+			do_gettimeofday(&t2);
+			my_timeval_less(t2, t, &tr);
+			if(tr.tv_usec >= 50*1000)
+			return(0);
+			a = 1000;
+		}
+	}
+
+	return(1);
+}
+
+
+/* sub_4288C
+
+   Arguments
+   pa = [ebp+0x8]
+   pb = [ebp+0xc]
+   pc = [ebp+0x10]
+   pd = [ebp+0x14]
+   pe = [ebp+0x18]
+   pf = [ebp+0x1c]
+   pg = [ebp+0x20]
+   ph = [ebp+0x24]
+ */
+void sub_4288c(struct em8300_s *em, int pa, int pb, int pc, int pd, int pe, int pf, int pg, int ph)
+{
+  int pav, pbv, pcv, pdv, i;
+	/*	pr_debug("sub_4288c:  xpos=%d, ypos=%d, xwin=%d, ywin=%d, xoff=%d, yoff=%d, xcorr=%d, xd=%d\n",
+	  pa,pb,pc,pd,pe,pf,pg,ph); */
+	if (pg >= 800) {
+		if (ph) {
+			pb >>= 1;
+			pd >>= 1;
+			pf >>= 1;
+		}
+		if (pa < 0) {
+			pav = 0;
+			pcv = pc + pa;
+		}
+		else {
+			pav = pa;
+			pcv = pc;
+		}
+		if (pb < 0) {
+			pbv = 0;
+			pdv = pd + pb;
+		}
+		else {
+			pbv = pb;
+			pdv = pd;
+		}
+		if (pav + pcv>em->overlay_xres) {
+			pcv=em->overlay_xres - pav;
+		}
+		if (pb+pd > em->overlay_yres) {
+		  pdv=em->overlay_yres - pb;
+		}
+
+		pa = (pa * 1000) / pg;
+		pc = (pc * 1000) / pg;
+		pav = (pav * 1000) / pg;
+		pcv = (pcv * 1000) / pg;
+
+		if (read_ucregister(DICOM_UpdateFlag) == 1) {
+			i=0;
+			while ((read_ucregister(DICOM_UpdateFlag) == 1) & (i < 20)) {
+				udelay(50);
+				i++;
+			}
+			if (read_ucregister(DICOM_UpdateFlag) == 1) {
+				write_ucregister(DICOM_UpdateFlag, 0);
+				udelay(50);
+			}
+		}
+
+		write_ucregister(DICOM_VisibleLeft, pe + pav);
+		write_ucregister(DICOM_VisibleRight, pe + pav + pcv - 1);
+		write_ucregister(DICOM_VisibleTop, pf + pbv);
+		write_ucregister(DICOM_VisibleBottom, pf + pbv + pdv - 1);
+
+		write_ucregister(DICOM_FrameLeft, pe + pa);
+		write_ucregister(DICOM_FrameRight, pe + pa + pc - 1);
+		write_ucregister(DICOM_FrameTop, pf + pb);
+		write_ucregister(DICOM_FrameBottom, pf + pb + pd - 1);
+
+		write_ucregister(DICOM_UpdateFlag, 1);
+	}
+}
+
+static int loc_2BE50(struct em8300_s *em)
+{
+	em9010_write(em, 0xb, 0xc8);
+	sub_2AC2D(em);
+	sub_2AC2D(em);
+	if (read_register(0x1f4b) < (2 * em->overlay_yres / 3)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+int em9010_calibrate_yoffset(struct em8300_s *em)
+{
+	int i;
+
+	pr_debug("em9010: Starting yoffset calibration\n");
+
+	//clear the stability value
+	em9010_write(em, 0x6, 0x0);
+
+	em->overlay_a[EM9010_ATTRIBUTE_XCORR] = em->overlay_xcorr_default;
+	em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] = 100000 / em->overlay_a[EM9010_ATTRIBUTE_XCORR];
+	em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] = 4;
+
+	em9010_write(em, 0xb, 0x14);
+
+	em9010_write16(em, 0x8, 0x2000);
+	em9010_write16(em, 0x10, 0x2000);
+	em9010_write16(em, 0x20, 0xff20);
+
+	em9010_write(em, 0xa, 0x6);
+
+	em8300_video_setplaymode(em, EM8300_PLAYMODE_FRAMEBUF );
+
+	if (em->overlay_double_y) {
+		em8300_dicom_fill_dispbuffers(em, 0, 0, em->dbuf_info.xsize, 4, 0xffffffff, 0x80808080 );
+	} else {
+		em8300_dicom_fill_dispbuffers(em, 0, 0, em->dbuf_info.xsize, 2, 0xffffffff, 0x80808080 );
+	}
+
+	sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+
+	pr_debug("em9010: Done drawing y testpattern\n");
+
+	mdelay(20);
+
+	if (!sub_2AC2D(em)) {
+		return 0;
+	}
+
+	em9010_write(em, 0, 0x14);
+	em9010_write(em, 0, 0x10);
+
+	for (i = 0; i < 60; i++) {
+		if (!sub_2AC2D(em)) {
+			pr_debug("em9010: sub_2AC2D failed\n");
+			return 0;
+		}
+		if (!(em9010_read(em,0) & 4)) {
+			sub_4288c(em, 0, i, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+					em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+			if (!sub_2AC2D(em)) {
+			    return 0;
+			}
+		} else {
+			break;
+		}
+	}
+
+	if (i == 60) {
+		return 0;
+	}
+
+	em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] = em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] + i - 2;
+
+	if (em->overlay_double_y) {
+		em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] >>= 1;
+	}
+
+	pr_debug("em9010: Sucessfully calibrated yoffset (%d)\n", em->overlay_a[EM9010_ATTRIBUTE_YOFFSET]);
+
+	return 1;
+}
+
+int em9010_calibrate_xoffset(struct em8300_s *em)
+{
+	int i;
+
+	em9010_write(em, 0xb, 0x14);
+
+	em9010_write16(em, 0x8, 0x2000);
+	em9010_write16(em, 0x10, 0x2000);
+	em9010_write16(em, 0x20, 0xff20);
+
+	em9010_write(em, 0xa, 0x6);
+
+	em8300_dicom_fill_dispbuffers(em, 0, 0, em->dbuf_info.xsize, 4, 0, 0x80808080 );
+	em8300_dicom_fill_dispbuffers(em, 2, 0, 2, em->dbuf_info.ysize, 0xffffffff, 0x80808080 );
+
+	em->overlay_a[EM9010_ATTRIBUTE_XCORR] = 1000;
+	em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] = 100000 / em->overlay_a[EM9010_ATTRIBUTE_XCORR];
+
+	sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+
+	pr_debug("em9010: Done drawing x testpattern\n");
+
+	mdelay(20);
+
+	if (!sub_2AC2D(em)) {
+		return 0;
+	}
+
+	em9010_write(em, 0, 0x14);
+	em9010_write(em, 0, 0x10);
+
+	for (i = 0; i <  220; i++) {
+		if (!sub_2AC2D(em)) {
+			pr_debug("em9010: sub_2AC2D failed\n");
+			return 0;
+		}
+		if (!(em9010_read(em,0) & 4)) {
+			sub_4288c(em, i, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+					em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+			if (!sub_2AC2D(em)) {
+			    return 0;
+			}
+		} else {
+			break;
+		}
+	}
+
+	if (i == 220) {
+		return 0;
+	}
+
+	em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] = em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] + i;
+
+	pr_debug("em9010: Sucessfully calibrated xoffset (%d)\n", em->overlay_a[EM9010_ATTRIBUTE_XOFFSET]);
+
+	return 1;
+}
+
+static int color_cal(struct em8300_s *em,int ul, int a, int b, int c,int d, int *res)
+{
+	int i;
+
+	if (ul == 1) {
+		/* Measure upper threshold level */
+
+		em9010_write16(em, a, d << 8);
+		em9010_write(em, 0xa, b);
+
+		if (!sub_2AC2D(em)) {
+			return 0;
+		}
+
+		em9010_write(em, 0, 0x17);
+		em9010_write(em, 0, 0x10);
+
+		for (i = d; i > 0; i--) {
+			em9010_write16(em, a, i << 8);
+			if (em9010_read(em, 0) & (a >> 3)) {
+				break;
+			} else {
+				continue;
+			}
+		}
+	} else if (ul == 2) {
+		/* Measure lower threshold level */
+		em9010_write16(em, a, 0x0);
+		em9010_write(em, 0xa, c);
+		if (!sub_2AC2D(em)) {
+			return 0;
+		}
+		em9010_write(em, 0, 0x17);
+		em9010_write(em, 0, 0x10);
+
+		for (i = 0; i < d; i++) {
+			em9010_write16(em, a, i);
+			if (em9010_read(em, 0) & (a >> 3)) {
+				break;
+			} else {
+				continue;
+			}
+		}
+	} else {
+		return -1;
+	}
+
+	*res = i;
+
+	return 1;
+}
+
+int em9010_calibrate_xcorrection(struct em8300_s *em)
+{
+	int i, j;
+
+	em9010_write(em, 0xb, 0x14);
+
+	em9010_write16(em, 0x8, 0x2000);
+	em9010_write16(em, 0x10, 0x2000);
+	em9010_write16(em, 0x20, 0xff20);
+
+	em9010_write(em, 0xa, 0x6);
+
+	em8300_dicom_fill_dispbuffers(em, 2, 0, 2, em->dbuf_info.ysize, 0, 0x80808080 );
+	em8300_dicom_fill_dispbuffers(em, 356, 0, 2, em->dbuf_info.ysize, 0xffffffff, 0x80808080 );
+
+	em->overlay_a[EM9010_ATTRIBUTE_XCORR] = em->overlay_xcorr_default;
+
+	sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+
+	pr_debug("em9010: Done drawing xcorr testpattern\n");
+
+	mdelay(20);
+
+	if (!sub_2AC2D(em)) {
+		return 0;
+	}
+
+	em9010_write(em, 0, 0x14);
+	em9010_write(em, 0, 0x10);
+
+	j = 1;
+	if (em->overlay_xcorr_default > 1200) {
+		j = 2;
+	}
+
+	for (i = -100; i < 150; i++) {
+		if (!sub_2AC2D(em)) {
+			return 0;
+		}
+		if (!(em9010_read(em, 0) & 4)) {
+			em->overlay_a[EM9010_ATTRIBUTE_XCORR] = i * j + em->overlay_xcorr_default;
+			sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+					em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+			if (!sub_2AC2D(em)) {
+			    return 0;
+			}
+		} else {
+			break;
+		}
+
+	}
+
+	if (em->overlay_xcorr_default > 1500) {
+		em->overlay_a[EM9010_ATTRIBUTE_XCORR] += 2;
+	} else {
+		em->overlay_a[EM9010_ATTRIBUTE_XCORR] -= 2;
+	}
+	sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+
+	pr_debug("em9010: Sucessfully calibrated x correction (%d)\n", em->overlay_a[EM9010_ATTRIBUTE_XCORR]);
+
+	return 1;
+}
+
+/*
+  l7 = [ebp-0x18]
+  l6 = [ebp-0xc]
+  l5 = [ebp-0x1d]
+  l4 = [ebp-0x14]
+  l2 = [ebp-8]
+  l3 = [ebp-4]
+  l1 = [ebp-0x10]
+ */
+int loc_2bcfe(struct em8300_s *em)
+{
+	int l1 = 10,l2,l3,l4,l5,l6,l7;
+
+	em9010_write(em, 4, 0);
+	em9010_write(em, 3, 0x80);
+	l2 = em9010_read(em, 2);
+	l3 = em9010_read(em, 1);
+
+	while (--l1 != 0) {
+		l4 = em9010_read(em, 1);
+		if ((l4 & 0xff) == (l3 & 0xff)) {
+			continue;
+		}
+		if ((l3 & 0xff) > (l4 & 0xff)) {
+			l5 = l3;
+		} else {
+			l5 = l4;
+		}
+		l3 = l5;
+		l2 = 0;
+		break;
+	}
+
+	l6 = (l3 << 8) + l2;
+	l7 = 165000 / (l6 + 2);
+
+	if ((l7 > em->overlay_dword_24bb8 + 1) || (l7 < em->overlay_dword_24bb8 - 1)) {
+		em->overlay_dword_24bb8 = l7;
+	} else {
+		l7 = em->overlay_dword_24bb8;
+	}
+
+	if ((l7 < 100) || (l7 > 1000)) {
+		if (em->overlay_yres) {
+			l7 = em->overlay_yres * 62 / 100;
+		}
+	}
+
+	pr_debug("em9010: loc_2bcfe -> %d\n", l7);
+	return l7;
+}
+/*
+  loc_2a66e
+
+  l13 [ebp-38]
+  l12 [ebp-8]
+  l11 [ebp-20]
+  l10 [ebp-34]
+  l9 [ebp-28]
+  l8 [ebp-4]
+  l7 [ebp-18]
+  l6 [ebp-0c]
+  l5 [ebp-30]
+  l4 [ebp-10]
+  l1 [ebp-14]
+  l2 [ebp-1c]
+  l3[ebp-24]
+ */
+int loc_2A66E(struct em8300_s *em)
+{
+	int l1, l2, l3, l4, l5, l6 = 0, l7, l8, l9, l10, l11, l12, l13;
+
+	l1 = 70000;
+	l2 = 0;
+	l3 = 0;
+
+	l7 = em->overlay_70 / 10;
+	l4 = 1000;
+
+	l5 = em->overlay_xres;
+	if (l5 <= 720) {
+		if (l5 == 720) {
+			l6 = 0x398;
+		} else if (l5 == 640) {
+			l6 = 0x370;
+		}
+	} else if (l5 <= 1024) {
+		if (l5 == 1024) {
+			l6 = 0x500;
+		} else if (l5 == 800) {
+			l6 = 0x400;
+		}
+	} else if (l5 <= 1280) {
+		if (l5 == 1280) {
+			l6 = 0x60e;
+		} else if (l5 == 1152) {
+			l6 = 0x5a0;
+		}
+	} else if (l5 == 1600) {
+		l6 = 0x7d0;
+	} else if (l5 == 2048) {
+		l6 = 0xa00;
+	} else {
+		l6 = 0x500;
+	}
+
+	pr_debug("l6 * l7 * (1 << l2)=%d, l1=%d\n", l6 * l7 * (1 << l2), l1);
+	if (l6 * l7 * (1 << l2) >= l1) {
+		l4 = l6 * l7 * (1 << l2) * 1000 / l1;
+		l8 = l1 / (l7*(1 << l2)) ;
+		l9 = l1 / (1 << l2);
+	} else {
+		l4 = 1000;
+		l8 = l6;
+		l9 = l8 * l7;
+	}
+	em->overlay_xcorr_default = l4;
+	if ((em->overlay_xcorr_default < 0x352) || (em->overlay_xcorr_default > 0xdac)) {
+		em->overlay_xcorr_default = 0x5dc;
+	}
+
+	if (l9 * (1 << l2) > 0x7530) {
+		l3 = l8 * (1 << l2) - 2;
+		if (l3 > 0xfff) {
+			l10 = 0xfff;
+		} else {
+			l10 = l3;
+		}
+		l3 = l10;
+		l11 = ((l3 >> 8) & 0xf) | (l2 << 4);
+		l12 = l3;
+	} else {
+		l2++;
+		l3 = l8 * (1 << l2) - 2;
+		if (l3 > 0xfff) {
+			l13 = 0xfff;
+		} else {
+			l13 = l3;
+		}
+		l3 = l13;
+		l11 = ((l3 >> 8) & 0xf) | (l2 << 4);
+		l12 = l3;
+	}
+	pr_debug("em9010: Writing %x to 16-bit register 1.\n", l12 | (l11 << 8));
+	em9010_write16(em, 1, l12 | (l11 << 8));
+	return 1;
+}
+
+int em9010_overlay_set_res(struct em8300_s *em, int xres, int yres)
+{
+	pr_debug("em9010: Setting resolution %d x %d\n", xres, yres);
+	em->overlay_xres = xres;
+	em->overlay_yres = yres;
+	em->overlay_70 = loc_2bcfe(em);
+	loc_2A66E(em);
+	em->overlay_a[EM9010_ATTRIBUTE_XCORR] = em->overlay_xcorr_default;
+	pr_debug("em9010: Xcorrector: %d\n", em->overlay_a[EM9010_ATTRIBUTE_XCORR]);
+	em9010_overlay_update(em);
+	return 1;
+}
+
+static int set_keycolor(struct em8300_s *em, unsigned upper, unsigned lower)
+{
+	int ru = (upper >> 16) & 0xff;
+	int gu = (upper >> 8) & 0xff;
+	int bu = (upper) & 0xff;
+	int rl = (lower >> 16) & 0xff;
+	int gl = (lower >> 8) & 0xff;
+	int bl = (lower) & 0xff;
+
+	em9010_write16(em, 0x8, (ru << 8) | (rl & 0xff));
+	em9010_write16(em, 0x10, (gu << 8) | (gl & 0xff));
+	em9010_write16(em, 0x20, (bu << 8) | (bl & 0xff));
+
+	return 1;
+}
+
+int em9010_overlay_set_signalmode(struct em8300_s *em, int val)
+{
+	switch (val) {
+	case EM8300_OVERLAY_SIGNAL_ONLY:
+		em9010_write(em, 7, em->overlay_a[EM9010_ATTRIBUTE_JITTER]);
+		break;
+	case EM8300_OVERLAY_SIGNAL_WITH_VGA:
+		em9010_write(em, 7, em->overlay_a[EM9010_ATTRIBUTE_JITTER] | 0x40);
+		break;
+	case EM8300_OVERLAY_VGA_ONLY:
+		em9010_write(em, 7, em->overlay_a[EM9010_ATTRIBUTE_JITTER] | 0x80);
+		break;
+	default:
+		return 0;
+	}
+	pr_debug("em9010: overlay reg 7 = %x \n", em9010_read(em, 7));
+
+	return 1;
+}
+
+int em9010_overlay_update(struct em8300_s *em)
+{
+	pr_debug("em9010: Update overlay: enabled=%d, gamma_enabled=%d\n", em->overlay_enabled, em->overlay_gamma_enable);
+
+	em9010_write(em, 5, 0);
+	em9010_write(em, 4, 0);
+	em9010_write(em, 6, em->overlay_a[EM9010_ATTRIBUTE_STABILITY]);
+
+	if (em->overlay_enabled) {
+		em->overlay_gamma_enable=4;
+		em9010_write(em, 9, em->overlay_gamma_enable);
+		em9010_overlay_set_signalmode(em, EM8300_OVERLAY_SIGNAL_WITH_VGA);
+	} else {
+		em->overlay_gamma_enable=0;
+		em9010_write(em, 9, em->overlay_gamma_enable);
+		em9010_overlay_set_signalmode(em, EM8300_OVERLAY_VGA_ONLY);
+	}
+
+	em9010_write(em, 8, 0x80);
+
+	if (em->overlay_gamma_enable) {
+		em9010_write(em, 0xc, 0x8e);
+	} else {
+		em9010_write(em, 0xc, 0xe);
+	}
+
+	//wait on the display of one frame at least
+	mdelay(20);
+
+	//the setting of the overlay mode shall be done before calling loc_2BE50!
+	em->overlay_double_y = loc_2BE50(em);
+	pr_debug("em9010: ydouble: %d\n", em->overlay_double_y);
+
+	switch(em->overlay_mode) {
+	case EM8300_OVERLAY_MODE_RECTANGLE:
+		em9010_write(em, 0xa, 0x77);
+		break;
+	case EM8300_OVERLAY_MODE_OVERLAY:
+		em9010_write(em, 0xb, 0xc8);
+		em9010_write(em, 0xa, 0x0);
+		set_keycolor(em, em->overlay_a[EM9010_ATTRIBUTE_KEYCOLOR_UPPER], em->overlay_a[EM9010_ATTRIBUTE_KEYCOLOR_LOWER]);
+		break;
+	}
+
+	return 0;
+}
+
+
+int em9010_init(struct em8300_s *em)
+{
+	em->overlay_dword_24bb8 = 2000;
+	em9010_overlay_set_res(em, 1280, 1024);
+	em->overlay_frame_xpos = 0;
+	em->overlay_frame_ypos = 0;
+	em->overlay_frame_width = 720;
+	em->overlay_frame_height = 480;
+	em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] = 43;
+	em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] = 225;
+	em->overlay_gamma_enable = 4;
+
+	return 1;
+}
+
+int em9010_set_attribute(struct em8300_s *em, int attribute, int value)
+{
+	if (attribute <= EM9010_ATTRIBUTE_MAX) {
+		em->overlay_a[attribute] = value;
+		switch(attribute) {
+		case EM9010_ATTRIBUTE_JITTER:
+			em9010_write(em, 7, (em9010_read(em, 7) & 0xf0) | value);
+			break;
+		case EM9010_ATTRIBUTE_STABILITY:
+			em9010_write(em, 6, value);
+			break;
+		}
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+int em9010_get_attribute(struct em8300_s *em, int attribute)
+{
+	if (attribute <= EM9010_ATTRIBUTE_MAX) {
+		return em->overlay_a[attribute];
+	} else {
+		return -1;
+	}
+}
+
+int em8300_ioctl_overlay_calibrate(struct em8300_s *em, em8300_overlay_calibrate_t *c)
+{
+	int r1;
+	em9010_write(em, 0xc, 0xe);
+
+	switch (c->cal_mode) {
+	case EM8300_OVERLAY_CALMODE_XOFFSET:
+		if (em9010_calibrate_xoffset(em)) {
+			c->result = em->overlay_a[EM9010_ATTRIBUTE_XOFFSET];
+		} else {
+			return 0;
+		}
+		break;
+	case EM8300_OVERLAY_CALMODE_YOFFSET:
+		if (em9010_calibrate_yoffset(em)) {
+			c->result = em->overlay_a[EM9010_ATTRIBUTE_YOFFSET];
+		} else {
+			return 0;
+		}
+		break;
+	case EM8300_OVERLAY_CALMODE_XCORRECTION:
+		if (em9010_calibrate_xcorrection(em)) {
+			c->result = em->overlay_a[EM9010_ATTRIBUTE_XCORR];
+			em8300_dicom_fill_dispbuffers(em, 0x164, 0, 2, em->dbuf_info.ysize, 0x0, 0x80808080 );
+		} else {
+			return 0;
+		}
+		break;
+	case EM8300_OVERLAY_CALMODE_COLOR:
+		r1=1;
+
+		em9010_write(em, 0xb, 0xc8);
+
+		mdelay(1);
+
+		if (color_cal(em, c->arg2, 8, 0x37, 0x73, c->arg, &r1)) {
+			c->result = r1 << 16;
+		} else {
+			return 0;
+		}
+
+		if (color_cal(em, c->arg2, 0x10, 0x57, 0x75, c->arg, &r1)) {
+			c->result |= r1 << 8;
+		} else {
+			return 0;
+		}
+
+		if (color_cal(em, c->arg2, 0x20, 0x67, 0x76, c->arg, &r1)) {
+			c->result |= r1;
+		} else {
+			return 0;
+		}
+		break;
+	}
+
+	if (1) {
+		em9010_write(em, 0xc, 0xe);
+	}
+	return 1;
+}
+
diff -Naurdp a/drivers/media/video/em3800/encoder.h b/drivers/media/video/em3800/encoder.h
--- a/drivers/media/video/em3800/encoder.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/encoder.h	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,18 @@
+#ifndef _ENCODER_H_
+#define _ENCODER_H_
+
+#include <linux/em8300.h>
+
+#define ENCODER_MODE_NTSC	 1
+#define ENCODER_MODE_NTSC60	 2
+#define ENCODER_MODE_PAL_M	 3
+#define ENCODER_MODE_PALM60	 4
+#define ENCODER_MODE_PAL	 5
+#define ENCODER_MODE_PAL60	 6
+#define ENCODER_MODE_PALNC	 7
+
+#define ENCODER_CMD_SETMODE      1
+#define ENCODER_CMD_ENABLEOUTPUT 2
+
+#endif
+
diff -Naurdp a/drivers/media/video/em3800/Kconfig b/drivers/media/video/em3800/Kconfig
--- a/drivers/media/video/em3800/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/Kconfig	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,128 @@
+#
+# Sigma Designs Hollywood Plus
+# Creative Labs DXR3
+#
+
+menu "Hollywood Plus / DXR3"
+	depends on I2C && I2C_ALGOBIT
+
+config DXR3
+	tristate "Hollywood Plus / DXR3"
+	depends on I2C && I2C_ALGOBIT
+
+config EM8300
+	tristate "Sigma designs EM8300"
+	depends on DXR3
+	help
+  Sigma REALmagic EM8300 single-chip MPEG-2 decoder with full compliance
+  to ISO 13818-2 MPEG-2 standard. The EM8300 is fully DVD-compliant,
+  providing CSS copy protection, sub-picture processing, letterbox, Pan &
+  Scan, and alpha-blending. On-chip digital controls adjust brightness,
+  contrast, and color saturation. 
+
+config EM8300_LOOPBACK
+	bool "  Activate loopback"
+	depends on EM8300
+	help
+  If you lose video after loading the modules or uploading the microcode
+  set this.
+  This is option is only used if you have problems with the loopback cable,
+  it is not used to activate overlay!
+  The module option is called activate_loopback.
+
+config EM8300_UCODETIMEOUT
+	bool "  BT865 uCode timeout"
+	depends on EM8300
+	help
+  Set this if you have a bt865 and get timeouts when uploading the 
+  microcode.
+
+  The module option is called bt865_ucode_timeout. It takes either a 1
+  or a 0 as argument.
+
+config EM8300_DICOMFIX
+	bool "  Dicom fix"
+	depends on EM8300
+	help
+  If this is set then some internal register values are changed.
+  Fixes green screen problems for some.
+
+  The module option is called dicom_fix. It takes either a 1 or a 0 as
+  argument.
+
+config EM8300_DICOMCTRL
+	bool "  Dicom control"
+	depends on EM8300
+	help
+  If this is set then some internal register values are changed.
+  Fixes green screen problems for some.
+
+  The module option is called dicom_control. It takes either a 1 or a 0
+  as argument.
+
+config EM8300_DICOMPAL
+	bool "  Dicom other pal"
+	depends on EM8300
+	help
+  If this is set, then some internal register values are swapped
+  for PAL and NTSC.
+
+  The module option is called dicom_other_pal. It takes either a 1
+  or a 0 as argument.
+
+config ADV717X
+	tristate "ADV717x video encoder"
+	depends on DXR3
+	help
+  The ADV7175A/ADV7176A is an integrated digital video encoder that
+  converts Digital CCIR-601 4:2:2 8 or 16-bit component video data into
+  a standard analog baseband television signal compatible with worldwide
+  standards.
+  This chip is used in all (?) Hollywood Plus cards.
+
+config ADV717X_SWAP
+	bool "  Swap red/blue pal"
+	depends on ADV717X
+	help
+  If your red and blue colours are swapped, set this.
+
+  The module option is called swap_redblue_pal. It takes either a 1 or a
+  0 as argument.
+
+config ADV717X_PIXELPORT16BIT
+	bool "  16bit pixelport"
+	depends on ADV717X
+	help
+  Changes how the ADV717x expects its input data to be formatted.
+  If the colours on the TV appear green, try changing this. The
+  correct value for a particular card varies, even with people with
+  the exact same card using the same microcode.
+
+  The module option is called pixelport_16bit. It takes either a 1 or a 0
+  as argument.
+
+config ADV717X_PIXELPORTPAL
+	bool "  Pixelport other pal"
+	depends on ADV717X
+	help
+  If this is set, then the pixelport setting is swapped for PAL
+  from the setting given with pixelport_16bit.
+
+  The module option is called pixelport_other_pal. It takes either a 1 or
+  a 0 as argument.
+
+config BT865
+	tristate "BT865 video encoder"
+	depends on DXR3
+	help
+  The BT864A/865A is specifically designed for video systems requiring
+  the generation of composite, Y/C (S-video) or RGB (SCART) video signals
+  from an 8- or 16-bit YCrCb digital video stream.
+  This chip was used by Creative Labs in their DXR3 card.
+  Creative Labs sold a few Hollywood Plus cards but with their name on it
+  and called them DXR3 (the cards are virtually identical anyway). This
+  means that a few of you have cards that claim to be DXR3 but use the
+  ADV717X instead of the BT865. If you are uncertain it is recommended
+  that you compile ADV717X support as well.
+
+endmenu
diff -Naurdp a/drivers/media/video/em3800/Makefile b/drivers/media/video/em3800/Makefile
--- a/drivers/media/video/em3800/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/media/video/em3800/Makefile	2007-05-21 11:46:49.000000000 +0200
@@ -0,0 +1,111 @@
+# $Id: Makefile,v 1.70 2005/11/23 22:44:24 nboullis Exp $
+#
+# Makefile -- makefile for the em8300 modules
+# Copyright (C) 2004 Nicolas Boullis <nboullis@debian.org>
+#
+#  This program is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License
+#  as published by the Free Software Foundation; either version 2
+#  of the License, or (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ifeq ($(KERNELRELEASE),)
+
+KERNEL_LOCATION := /lib/modules/$(shell uname -r)/build
+
+# If you are using external i2c modules, you should set
+# EM8300_I2C_LOCATION to the source directory of the modules.
+# Moreover, if the API of the modules is not properly guessed, you can
+# force it by setting EM8300_I2C_FORCE_API to OLD or NEW. (That is
+# especially for using 2.8.x modules with 2.4.x kernels.)
+#export EM8300_I2C_LOCATION := /usr/src/modules/i2c
+#export EM8300_I2C_FORCE_API := NEW
+export EM8300_VERSION := "0.15.2"
+export EM8300_DIR := $(PWD)/..
+
+build:
+	$(MAKE) -C $(KERNEL_LOCATION) SUBDIRS=$(PWD) modules
+
+clean:
+	-rm -f *.o *.ko *.mod.c .*.cmd .*.o.flags
+
+KERNVER := $(shell $(CPP) -dM $(KERNEL_LOCATION)/include/linux/version.h | sed -ne 's/^\#define[[:space:]]\+UTS_RELEASE[[:space:]]\+"\(.*\)"$$/\1/p')
+MODINST := em8300
+
+# Test if the kernel if older than 2.5.51
+ifeq ($(shell echo $(KERNVER) | sed -e 's/^\([[:digit:]]\+\)\.\([[:digit:]]\+\)\.\([[:digit:]]\+\).*/\1 * 65536 + \2 * 256 + \3 < 2 * 65536 + 5 * 256 + 51/' | xargs expr),1)
+MODULES := adv717x.o bt865.o em8300.o
+else
+MODULES := adv717x.ko bt865.ko em8300.ko
+endif
+
+install: $(MODULES)
+	install -d $(DESTDIR)/lib/modules/$(KERNVER)/$(MODINST)
+	install $(MODULES) $(DESTDIR)/lib/modules/$(KERNVER)/$(MODINST)
+
+uninstall:
+	rm -rf /lib/modules/$(KERNVER)/$(MODINST)
+
+.PHONY: build clean install uninstall
+
+else
+
+BUILD_IOCTL32 := n
+
+ifeq ($(ARCH),sparc64)
+BUILD_IOCTL32 := $(CONFIG_SPARC32_COMPAT)
+endif
+
+EXTRA_CFLAGS := -I$(EM8300_DIR)/include \
+		-DEM8300_VIDEOMODE_DEFAULT=EM8300_VIDEOMODE_PAL \
+		-DEM8300_AUDIOMODE_DEFAULT=EM8300_AUDIOMODE_ANALOG \
+		-DEM8300_VERSION=\"$(EM8300_VERSION)\" \
+		-DCONFIG_ADV717X_PIXELPORT16BIT -DCONFIG_ADV717X_PIXELPORTPAL \
+		-DCONFIG_EM8300_DICOMPAL -DCONFIG_EM8300_DICOMFIX \
+		-DCONFIG_EM8300_DICOMCTRL
+ifeq ($(BUILD_IOCTL32),y)
+EXTRA_CFLAGS += -DCONFIG_EM8300_IOCTL32=1
+endif
+ifneq ($(EM8300_I2C_LOCATION),)
+EXTRA_CFLAGS += -DCONFIG_I2C_ALGOBIT=1
+# This is a hack to include i2c headers from $(EM8300_I2C_LOCATION)
+# over those from the kernel source tree.
+override CC += -I$(EM8300_I2C_LOCATION)
+endif
+ifneq ($(EM8300_I2C_FORCE_API),)
+EXTRA_CFLAGS += -DEM8300_I2C_FORCE_$(EM8300_I2C_FORCE_API)_API
+endif
+
+#MOD_DESTDIR := drivers/video
+
+em8300-objs := em8300_main.o em8300_i2c.o em8300_audio.o em8300_fifo.o \
+		em8300_video.o em8300_misc.o em8300_dicom.o em8300_ucode.o \
+		em8300_ioctl.o em8300_spu.o em9010.o em8300_registration.o \
+		em8300_procfs.o em8300_devfs.o em8300_sysfs.o
+ifeq ($(BUILD_IOCTL32),y)
+em8300-objs += em8300_ioctl32.o
+endif
+
+obj-$(CONFIG_EM8300)	+= em8300.o
+obj-$(CONFIG_ADV717X)	+= adv717x.o
+obj-$(CONFIG_BT865)	+= bt865.o
+
+# The following hack tests for old kernels (2.4 and old 2.5).
+ifneq ($(TOPDIR),$(shell /bin/pwd))
+
+include $(TOPDIR)/Rules.make
+
+em8300.o: $(em8300-objs)
+	$(LD) $(LDFLAGS) $(LDFLAGS_MODULE) -r -o $@ $(em8300-objs)
+
+endif
+
+endif
diff -Naurdp a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
--- a/drivers/media/video/Kconfig	2007-05-19 06:06:17.000000000 +0200
+++ b/drivers/media/video/Kconfig	2007-05-21 11:47:19.000000000 +0200
@@ -343,6 +343,8 @@ config VIDEO_UPD64083
 	  To compile this driver as a module, choose M here: the
 	  module will be called upd64083.
 
+source drivers/media/video/em3800/Kconfig
+
 endmenu # encoder / decoder chips
 
 config VIDEO_VIVI
