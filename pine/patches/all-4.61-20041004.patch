diff -rc pine4.61/README.maildir pine4.61.I.USE/README.maildir
*** pine4.61/README.maildir	Thu Sep 23 15:32:08 2004
--- pine4.61.I.USE/README.maildir	Fri Jul 16 11:50:22 2004
***************
*** 0 ****
--- 1,75 ----
+ Maildir Driver for Pine4.61
+ ---------------------------
+ 
+ This is a maildir driver for the c-client library and Pine. This code
+ started from code in old maildir patches but it was completely rewritten,
+ so the old way to configure it does not apply anymore.
+ 
+ This patch takes the approach that you should not patch Pine to make the
+ maildir driver do its work correctly, by this I mean things like appending
+ messages to a folder, or so. You could of course patch Pine if you want to
+ pass parameters to the driver, but not to fix the driver. This patch
+ modifies Pine so that it will be possible to pass a parameter to the
+ driver (the location of the INBOX). Although this patch was based in an
+ old version of a maildir patch it has been almost completely rewritten and
+ it can be considered independent work (look at the flow of functions,
+ checks, etc). The patch is based on the code for the unix driver plus some
+ combinations of the mh driver and the mbx driver for the c-client library.
+ Those drivers were designed by Mark Crispin, and bugs in this code are not
+ his bugs, but my own.
+ 
+  One of my goals with this patch is that the associated imap server must
+ work well with this patch and any client!. Trying to do this I've cleaned
+ a lot of bugs in older work and restructured the flow. I am sure that
+ doing this is a never ending job, since improvements to the code can
+ always be made, and I am looking forward to doing them sometime in the
+ future.
+ 
+  This patch does not keep UIDs between sessions, but hopefully it does
+ keep consistent UIDs during one session. This is not a bug of the driver,
+ instead it is a shortcoming of the maildir specification. The main point
+ of the maildir configuration is that you should never (read my lips) ever
+ edit the message, but edit the filename associated to the message. Well, I
+ could not find any single place in the web where it was told how to save
+ the UID of a message, if there is one please let me know and I will add
+ UID support for this driver.
+ 
+   I got all the specification for this patch from
+ http://cr.yp.to/proto/maildir.html. If you know of a place with a better
+ specification for maildir format please let me know. The method this patch
+ uses to create a unique filename for a message is one of the "old
+ fashioned" methods. I realize that this is old fashioned, but it is
+ portable, and portability is the main reason why I decided to use an old
+ fashioned method (most methods are not portable. See the word
+ "Unfortunately" in that document).
+ 
+   I am interested in improving speed in the driver, please send me reports
+ of slowness or any other comments you can think are appropriate.
+ 
+ Once this approach was chosen, it implied the following:
+ 
+     * This patch assumes that your INBOX is located at "$HOME/Maildir".  
+       This is a directory which should have three subdirectories "cur",
+       "tmp" and "new". Mail is delivered to 'new' and read from 'cur'. I
+       have added a configuration option "maildir-location" which can be
+       used to tell Pine where your Maildir inbox is, in case your system
+       do not use the above directory (e.g. your system may use
+       ".maildir"). In this case define that variable to be the name of the
+       directory where your e-mail is being delivered (e.g. ".maildir").
+ 
+     * If you want to use the above configuration as your inbox, you must
+       define your inbox-path as "#md/inbox" (no quotes).  You can define
+       the inbox-path like above even if you have changed the
+       maildir-location variable. That's the whole point of that variable.
+ 
+     * You can create a collection of folders which are in maildir format.
+       In order to do that press M S L and add the following data:
+        
+       Nickname: Anything
+       Server  :
+       Path    : #md/relative/path/to/home
+       View    :
+ 
+ Written by Eduardo Chappa <chappa@math.washington.edu>
+ 
+ Last Updated June 04, 2004
diff -rc pine4.61/imap/src/c-client/imap4r1.c pine4.61.I.USE/imap/src/c-client/imap4r1.c
*** pine4.61/imap/src/c-client/imap4r1.c	Thu Jul  8 15:02:03 2004
--- pine4.61.I.USE/imap/src/c-client/imap4r1.c	Thu Jul 29 14:10:47 2004
***************
*** 4374,4379 ****
--- 4374,4380 ----
    if (*env) {			/* need to merge this header into envelope? */
      if (!(*env)->newsgroups) {	/* need Newsgroups? */
        (*env)->newsgroups = nenv->newsgroups;
+       (*env)->ngbogus = nenv->ngbogus;
        nenv->newsgroups = NIL;
      }
      if (!(*env)->followup_to) {	/* need Followup-To? */
***************
*** 4428,4433 ****
--- 4429,4435 ----
      if (oenv) {			/* need to merge old envelope? */
        (*env)->newsgroups = oenv->newsgroups;
        oenv->newsgroups = NIL;
+       (*env)->ngbogus = oenv->ngbogus;
        (*env)->followup_to = oenv->followup_to;
        oenv->followup_to = NIL;
        (*env)->references = oenv->references;
diff -rc pine4.61/imap/src/c-client/mail.h pine4.61.I.USE/imap/src/c-client/mail.h
*** pine4.61/imap/src/c-client/mail.h	Mon Jun 21 18:06:58 2004
--- pine4.61.I.USE/imap/src/c-client/mail.h	Fri Jul 16 12:06:51 2004
***************
*** 307,312 ****
--- 307,314 ----
  #define SET_SNARFINTERVAL (long) 565
  #define GET_SNARFPRESERVE (long) 566
  #define SET_SNARFPRESERVE (long) 567
+ #define GET_MDINBOX (long) 568
+ #define SET_MDINBOX (long) 569
  
  /* Driver flags */
  
***************
*** 617,622 ****
--- 619,625 ----
  /* Message envelope */
  
  typedef struct mail_envelope {
+   unsigned int ngbogus : 1;	/* newsgroups may be bogus */
    unsigned int incomplete : 1;	/* envelope may be incomplete */
    unsigned int imapenvonly : 1;	/* envelope only has IMAP envelope */
    char *remail;			/* remail header if any */
***************
*** 785,790 ****
--- 788,794 ----
    unsigned int spare7 : 1;	/* seventh spare bit */
    unsigned int spare8 : 1;	/* eighth spare bit */
    void *sparep;			/* spare pointer */
+   void *maildirp;		/* for the Maildir driver */
    unsigned long user_flags;	/* user-assignable flags */
  } MESSAGECACHE;
  
diff -rc pine4.61/imap/src/c-client/nntp.c pine4.61.I.USE/imap/src/c-client/nntp.c
*** pine4.61/imap/src/c-client/nntp.c	Thu Jul  8 15:02:03 2004
--- pine4.61.I.USE/imap/src/c-client/nntp.c	Thu Sep 16 10:44:57 2004
***************
*** 10,16 ****
   *		Internet: MRC@CAC.Washington.EDU
   *
   * Date:	10 February 1992
!  * Last Edited:	4 May 2004
   * 
   * The IMAP toolkit provided in this Distribution is
   * Copyright 1988-2004 University of Washington.
--- 10,16 ----
   *		Internet: MRC@CAC.Washington.EDU
   *
   * Date:	10 February 1992
!  * Last Edited:	18 August 2004
   * 
   * The IMAP toolkit provided in this Distribution is
   * Copyright 1988-2004 University of Washington.
***************
*** 141,147 ****
  long nntp_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options);
  long nntp_append (MAILSTREAM *stream,char *mailbox,append_t af,void *data);
  
- SENDSTREAM *nntp_greet (SENDSTREAM *stream,long options);
  long nntp_extensions (SENDSTREAM *stream,long flags);
  long nntp_send (SENDSTREAM *stream,char *command,char *args);
  long nntp_send_work (SENDSTREAM *stream,char *command,char *args);
--- 141,146 ----
***************
*** 1668,1674 ****
  	stream->debug = (mb.dbgflag || (options & NOP_DEBUG)) ? T : NIL;
  	if (mb.loser) stream->loser = T;
  				/* process greeting */
! 	stream = nntp_greet (stream,options);
        }
      }
    } while (!stream && *++hostlist);
--- 1667,1685 ----
  	stream->debug = (mb.dbgflag || (options & NOP_DEBUG)) ? T : NIL;
  	if (mb.loser) stream->loser = T;
  				/* process greeting */
! 	switch ((int) nntp_reply (stream)) {
! 	case NNTPGREET:		/* allow posting */
! 	  NNTP.post = T;
! 	  mm_notify (NIL,stream->reply + 4,(long) NIL);
! 	  break;
! 	case NNTPGREETNOPOST:	/* posting not allowed, must be readonly */
! 	  NNTP.post = NIL;
! 	  break;
! 	default:
! 	  mm_log (stream->reply,ERROR);
! 	  stream = nntp_close (stream);
! 	  break;
! 	}
        }
      }
    } while (!stream && *++hostlist);
***************
*** 1710,1717 ****
--- 1721,1738 ----
      }
      if (!nntp_send_auth_work (stream,&mb,tmp)) stream = nntp_close (stream);
    }
+ 				/* authenticate if no-post and not readonly */
+   else if (stream && !(NNTP.post || (options & NOP_READONLY) ||
+ 	     nntp_send_auth (stream))) stream = nntp_close (stream);
+ 
  				/* in case server demands MODE READER */
    if (stream) switch ((int) nntp_send_work (stream,"MODE","READER")) {
+   case NNTPGREET:
+     NNTP.post = T;
+     break;
+   case NNTPGREETNOPOST:
+     NNTP.post = NIL;
+     break;
    case NNTPWANTAUTH:		/* server wants auth first, do so and retry */
    case NNTPWANTAUTH2:		/* remote name for authentication */
      if ((int) mail_parameters (NIL,GET_TRUSTDNS,NIL)) {
***************
*** 1719,1756 ****
  	       net_remotehost (netstream) : net_host (netstream),NETMAXHOST-1);
        mb.host[NETMAXHOST-1] = '\0';
      }
!     if (nntp_send_auth_work(stream,&mb,tmp)) nntp_send(stream,"MODE","READER");
      else stream = nntp_close (stream);
      break;
    }
!   return stream;
! }
! 
! /* Process NNTP greeting
!  * Accepts: stream
!  *	    NNTP open options
!  * Returns: stream or NIL if bad greeting
!  */
! 
! SENDSTREAM *nntp_greet (SENDSTREAM *stream,long options)
! {
! 				/* get server greeting */
!   switch ((int) nntp_reply (stream)) {
!   case NNTPGREET:		/* allow posting */
!     NNTP.post = T;
!     mm_notify (NIL,stream->reply + 4,(long) NIL);
!     break;
!   case NNTPGREETNOPOST:		/* posting not allowed, must be readonly */
!     NNTP.post = NIL;
!     if (options & NOP_READONLY) {
!       mm_notify (NIL,stream->reply + 4,(long) NIL);
!       break;
!     }
! 				/* falls through */
!   default:			/* anything else is an error */
!     mm_log (stream->reply,ERROR);
      stream = nntp_close (stream);
-   }
    return stream;
  }
  
--- 1740,1760 ----
  	       net_remotehost (netstream) : net_host (netstream),NETMAXHOST-1);
        mb.host[NETMAXHOST-1] = '\0';
      }
!     if (nntp_send_auth_work (stream,&mb,tmp))
!       switch ((int) nntp_send (stream,"MODE","READER")) {
!       case NNTPGREET:
! 	NNTP.post = T;
! 	break;
!       case NNTPGREETNOPOST:
! 	NNTP.post = NIL;
! 	break;
!       }
      else stream = nntp_close (stream);
      break;
    }
! 				/* make sure can post if not readonly */
!   if (stream && !NNTP.post && !(options & NOP_READONLY))
      stream = nntp_close (stream);
    return stream;
  }
  
***************
*** 2166,2168 ****
--- 2170,2198 ----
  				/* output remainder of text */
    return *s ? net_soutr (stream,s) : T;
  }
+ 
+ /* overrides the newsrc assigned by nntp_mopen 
+  * Yes, I know...
+  */
+ 
+ char *change_newsrc(MAILSTREAM *stream,char *oldnewsrc, int option)
+ {
+   char *s = NULL;
+ 
+   if (!LOCAL)
+     return s;
+ 
+   if (LOCAL->newsrc){
+      s = cpystr(LOCAL->newsrc);
+      fs_give((void **)&LOCAL->newsrc);
+   }
+   if (option == 1)	/* return .newsrc file */
+      LOCAL->newsrc = cpystr((char *) mail_parameters (NIL,GET_NEWSRC,NIL));
+   else			/* return .newsrc-server file */
+      LOCAL->newsrc = cpystr(oldnewsrc);
+ 
+   if (oldnewsrc)
+      fs_give((void **)&oldnewsrc);
+ 
+   return s;
+ }
diff -rc pine4.61/imap/src/c-client/rfc822.c pine4.61.I.USE/imap/src/c-client/rfc822.c
*** pine4.61/imap/src/c-client/rfc822.c	Tue Apr 27 17:21:48 2004
--- pine4.61.I.USE/imap/src/c-client/rfc822.c	Thu Jul 29 14:21:59 2004
***************
*** 374,379 ****
--- 374,380 ----
    ENVELOPE *env = (*en = mail_newenvelope ());
    BODY *body = bdy ? (*bdy = mail_newbody ()) : NIL;
    long MIMEp = -1;		/* flag that MIME semantics are in effect */
+   long PathP = NIL;             /* flag that a Path: was seen */
    parseline_t pl = (parseline_t) mail_parameters (NIL,GET_PARSELINE,NIL);
    if (!host) host = BADHOST;	/* make sure that host is non-null */
    while (i && *s != '\n') {	/* until end of header */
***************
*** 463,468 ****
--- 464,472 ----
  	  *t++ = '\0';
  	}
  	break;
+       case 'P':                 /* possible Path: */
+ 	if (!strcmp (tmp+1,"ATH")) env->ngbogus = T;
+ 	break;
        case 'R':			/* possible Reply-To: */
  	if (!strcmp (tmp+1,"EPLY-TO"))
  	  rfc822_parse_adrlist (&env->reply_to,d,host);
diff -rc pine4.61/imap/src/osdep/unix/Makefile pine4.61.I.USE/imap/src/osdep/unix/Makefile
*** pine4.61/imap/src/osdep/unix/Makefile	Tue Jun 22 13:56:05 2004
--- pine4.61.I.USE/imap/src/osdep/unix/Makefile	Fri Jul 16 11:50:22 2004
***************
*** 107,113 ****
  # Standard distribution build parameters
  
  DEFAULTAUTHENTICATORS=md5 pla log
! DEFAULTDRIVERS=imap nntp pop3 mh mx mbx tenex mtx mmdf unix news phile
  
  
  # Normally no need to change any of these
--- 107,113 ----
  # Standard distribution build parameters
  
  DEFAULTAUTHENTICATORS=md5 pla log
! DEFAULTDRIVERS=maildir imap nntp pop3 mh mx mbx tenex mtx mmdf unix news phile
  
  
  # Normally no need to change any of these
***************
*** 116,122 ****
  BINARIES=osdep.o mail.o misc.o newsrc.o smanager.o utf8.o siglocal.o \
   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
!  unix.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o
  CFLAGS=-g
  
  CAT=cat
--- 116,122 ----
  BINARIES=osdep.o mail.o misc.o newsrc.o smanager.o utf8.o siglocal.o \
   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
!  unix.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o maildir.o
  CFLAGS=-g
  
  CAT=cat
***************
*** 834,840 ****
  tenex.o: mail.h misc.h osdep.h dummy.h
  unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
  utf8.o: mail.h misc.h osdep.h utf8.h
! 
  
  # OS-dependent
  
--- 834,840 ----
  tenex.o: mail.h misc.h osdep.h dummy.h
  unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
  utf8.o: mail.h misc.h osdep.h utf8.h
! maildir.o: mail.h misc.h osdep.h maildir.h dummy.h
  
  # OS-dependent
  
diff -rc pine4.61/imap/src/osdep/unix/dummy.c pine4.61.I.USE/imap/src/osdep/unix/dummy.c
*** pine4.61/imap/src/osdep/unix/dummy.c	Mon Feb  2 16:50:32 2004
--- pine4.61.I.USE/imap/src/osdep/unix/dummy.c	Wed Jul 28 14:09:25 2004
***************
*** 104,109 ****
--- 104,111 ----
  {
    char *s,tmp[MAILTMPLEN];
    struct stat sbuf;
+ 
+   maildir_remove_root(&name);
  				/* must be valid local mailbox */
    if (name && *name && (*name != '{') && (s = mailboxfile (tmp,name))) {
  				/* indeterminate clearbox INBOX */
***************
*** 362,368 ****
    char *s,tmp[MAILTMPLEN];
  				/* don't \NoSelect dir if it has a driver */
    if ((attributes & LATT_NOSELECT) && (d = mail_valid (NIL,name,NIL)) &&
!       (d != &dummydriver)) attributes &= ~LATT_NOSELECT;
    if (!contents ||		/* notify main program */
        (!(attributes & LATT_NOSELECT) && (csiz = strlen (contents)) &&
         (s = dummy_file (tmp,name)) && !stat (s,&sbuf) &&
--- 364,373 ----
    char *s,tmp[MAILTMPLEN];
  				/* don't \NoSelect dir if it has a driver */
    if ((attributes & LATT_NOSELECT) && (d = mail_valid (NIL,name,NIL)) &&
!       (d != &dummydriver)){
! 	 attributes &= ~LATT_NOSELECT;
! 	 attributes |= LATT_NOINFERIORS;
!   }
    if (!contents ||		/* notify main program */
        (!(attributes & LATT_NOSELECT) && (csiz = strlen (contents)) &&
         (s = dummy_file (tmp,name)) && !stat (s,&sbuf) &&
***************
*** 382,387 ****
--- 387,394 ----
  {
    char *s,tmp[MAILTMPLEN];
    long ret = NIL;
+   if(!strncmp(mailbox,"#md/",4))
+     return maildir_create(stream, mailbox);
  				/* validate name */
    if (!(compare_cstring (mailbox,"INBOX") && (s = dummy_file (tmp,mailbox)))) {
      sprintf (tmp,"Can't create %.80s: invalid name",mailbox);
***************
*** 447,452 ****
--- 454,461 ----
  {
    struct stat sbuf;
    char *s,tmp[MAILTMPLEN];
+   if (!strncmp(mailbox,"#md/",4))
+      return maildir_delete(stream, mailbox);
    if (!(s = dummy_file (tmp,mailbox))) {
      sprintf (tmp,"Can't delete - invalid name: %.80s",s);
      MM_LOG (tmp,ERROR);
***************
*** 473,478 ****
--- 482,490 ----
  {
    struct stat sbuf;
    char c,*s,tmp[MAILTMPLEN],mbx[MAILTMPLEN],oldname[MAILTMPLEN];
+ 
+   maildir_remove_root(&old);
+   maildir_remove_root(&newname);
  				/* no trailing / allowed */
    if (!dummy_file (oldname,old) || !(s = dummy_file (mbx,newname)) ||
        ((s = strrchr (s,'/')) && !s[1])) {
diff -rc pine4.61/imap/src/osdep/unix/env_unix.c pine4.61.I.USE/imap/src/osdep/unix/env_unix.c
*** pine4.61/imap/src/osdep/unix/env_unix.c	Thu Jul  8 15:02:04 2004
--- pine4.61.I.USE/imap/src/osdep/unix/env_unix.c	Tue Sep 14 14:59:02 2004
***************
*** 33,38 ****
--- 33,39 ----
  static char *sysInbox = NIL;	/* system inbox name */
  static char *newsActive = NIL;	/* news active file */
  static char *newsSpool = NIL;	/* news spool */
+ static char *myMdInboxDir = NIL;/* Location of the Maildir INBOX */
  				/* anonymous home directory */
  static char *anonymousHome = NIL;
  static char *ftpHome = NIL;	/* ftp export home directory */
***************
*** 177,182 ****
--- 178,189 ----
    case GET_NEWSRC:
      ret = (void *) myNewsrc;
      break;
+   case SET_MDINBOX:
+     if (myMdInboxDir) fs_give ((void **) &myMdInboxDir);
+     myMdInboxDir = cpystr ((char *) value);
+   case GET_MDINBOX:
+     ret = (void *) myMdInboxDir;
+     break;
    case SET_NEWSACTIVE:
      if (newsActive) fs_give ((void **) &newsActive);
      newsActive = cpystr ((char *) value);
***************
*** 339,352 ****
    case GET_BLOCKNOTIFY:
      ret = (void *) mailblocknotify;
      break;
-   case GET_LOGOUTHOOK:
-     maillogouthook = (logouthook_t) value;
    case SET_LOGOUTHOOK:
      ret = maillogouthook;
      break;
-   case GET_LOGOUTDATA:
-     maillogoutdata = (void *) value;
    case SET_LOGOUTDATA:
      ret = maillogoutdata;
    }
    return ret;
--- 346,359 ----
    case GET_BLOCKNOTIFY:
      ret = (void *) mailblocknotify;
      break;
    case SET_LOGOUTHOOK:
+     maillogouthook = (logouthook_t) value;
+   case GET_LOGOUTHOOK:
      ret = maillogouthook;
      break;
    case SET_LOGOUTDATA:
+     maillogoutdata = (void *) value;
+   case GET_LOGOUTDATA:
      ret = maillogoutdata;
    }
    return ret;
***************
*** 733,738 ****
--- 740,746 ----
    }
    if (!myLocalHost) mylocalhost ();
    if (!myNewsrc) myNewsrc = cpystr(strcat (strcpy (tmp,myHomeDir),"/.newsrc"));
+   if (!myMdInboxDir) myMdInboxDir = cpystr("Maildir");
    if (!newsActive) newsActive = cpystr (ACTIVEFILE);
    if (!newsSpool) newsSpool = cpystr (NEWSSPOOL);
  				/* force default prototype to be set */
diff -rc pine4.61/imap/src/osdep/unix/maildir.c pine4.61.I.USE/imap/src/osdep/unix/maildir.c
*** pine4.61/imap/src/osdep/unix/maildir.c	Thu Sep 23 15:32:08 2004
--- pine4.61.I.USE/imap/src/osdep/unix/maildir.c	Tue Aug 31 11:29:45 2004
***************
*** 0 ****
--- 1,1665 ----
+ /*
+  * Maildir driver for Pine4.61
+  * 
+  * Written by Eduardo Chappa <chappa@math.washington.edu>
+  * Last Update: August 31, 2004.
+  *
+  * The IMAP toolkit provided in this Distribution is
+  * Copyright 2004 University of Washington.
+  * The full text of our legal notices is contained in the file called
+  * CPYRIGHT, included with this Distribution.
+  */
+ 
+ #include <stdio.h>
+ #include <ctype.h>
+ #include <errno.h>
+ extern int errno;		/* just in case */
+ #include "mail.h"
+ #include "osdep.h"
+ #include <pwd.h>
+ #include <sys/stat.h>
+ #include <sys/time.h>
+ #include "maildir.h"
+ #include "fdstring.h"
+ #include "misc.h"
+ #include "dummy.h"
+ 
+ /* Driver dispatch used by MAIL */
+ 
+ DRIVER maildirdriver = {
+   "md",				/* driver name, yes it's md, not maildir */
+ 				/* driver flags */
+   DR_MAIL|DR_LOCAL|DR_NOFAST|DR_NAMESPACE|DR_NOSTICKY,
+   (DRIVER *) NIL,		/* next driver 				*/
+   maildir_valid,		/* mailbox is valid for us 		*/
+   maildir_parameters,		/* manipulate parameters		*/
+   NIL,				/* scan mailboxes 			*/
+   maildir_list,			/* find mailboxes 			*/
+   maildir_lsub,			/* find subscribed mailboxes 		*/
+   maildir_sub,			/* subscribe to mailbox 		*/
+   maildir_unsub,		/* unsubscribe from mailbox 		*/
+   maildir_create,		/* create mailbox 			*/
+   maildir_delete,		/* delete mailbox 			*/
+   maildir_rename,		/* rename mailbox 			*/
+   mail_status_default,		/* status of mailbox 			*/
+   maildir_open,			/* open mailbox				*/
+   maildir_close,		/* close mailbox 			*/
+   maildir_fast,			/* fetch message "fast" attributes	*/
+   NIL,				/* fetch message flags 			*/
+   NIL,				/* fetch overview 			*/
+   NIL,				/* fetch message structure 		*/
+   maildir_header,		/* fetch message header 		*/
+   maildir_text,			/* fetch message body 			*/
+   NIL,				/* fetch partial message text 		*/
+   NIL,				/* unique identifier 			*/
+   NIL,				/* message number 			*/
+   NIL,				/* modify flags 			*/
+   maildir_flagmsg,		/* per-message modify flags 		*/
+   NIL,				/* search for message based on criteria */
+   NIL,				/* sort messages 			*/
+   NIL,				/* thread messages 			*/
+   maildir_ping,			/* ping mailbox to see if still alive 	*/
+   maildir_check,		/* check for new messages		*/
+   maildir_expunge,		/* expunge deleted messages 		*/
+   maildir_copy,			/* copy messages to another mailbox 	*/
+   maildir_append,		/* append string message to mailbox 	*/
+   NIL				/* garbage collect stream 		*/
+ };
+ 
+ MAILSTREAM maildirproto = {&maildirdriver};	/* prototype stream */
+ 
+ void 
+ md_domain_name(void)
+ {
+    int i;
+ 
+    strcpy(mdlocaldomain,mylocalhost ());
+    for (i = 0; mdlocaldomain[i] ; i++)
+       if(mdlocaldomain[i] == '/')
+ 	 mdlocaldomain[i] = '\057';
+       else if (mdlocaldomain[i] == ':')
+ 	 mdlocaldomain[i] =  '\072';
+ }
+ 
+ /* remove the "#md/" part from a folder name */
+ void maildir_remove_root (char **name)
+ {
+   if (maildir_valid_name(*name)){
+      (*name) += 3;
+      if (**name == '/')
+ 	(*name)++;
+   }
+ }
+ 
+ 
+ /* Check validity of the name, we accept:
+  *	a) #md/directory/folder
+  *	b) #md/inbox
+  * A few considerations: We can only accept as valid
+  *  a) names that start with #md/ and the directory exists or
+  *  b) names that do not start with #md/ but are maildir directories (have
+  *     the /cur, /tmp and /new structure)
+  */
+ 
+ 
+ int maildir_valid_name (char *name)
+ {
+   int ret = NIL;
+   char tmpname[MAILTMPLEN+1] = {'\0'};
+ 
+    if (mdfpath)
+       fs_give((void **)&mdfpath);
+    if (name && name[0] != '#')
+ 	sprintf(tmpname,"#md/%s",name);
+    mdfpath = cpystr(tmpname[0] ? tmpname : name);
+ 
+   if (name && (name[0] == '#') 
+ 	&& ((name[1] == 'm') || (name[1] == 'M'))
+ 	&& ((name[2] == 'd') || (name[2] == 'D')) 
+ 	&& ((name[3] == '/') && name[4])) ret = T;
+ 
+   return ret;
+ }
+ 
+ /* Check if the directory whose path is given by name is a valid maildir
+  *  directory (contains /cur, /tmp and /new)
+  */
+ 
+ int maildir_valid_dir (char *name)
+ {
+  int len;
+  DirNamesType i;
+  struct stat sbuf;
+  char tmp[MAILTMPLEN+1];
+ 
+    len = strlen(name);
+    for (i = Cur; i != EndDir; i++){
+       MDFLD(tmp, name, i);
+       if (stat(tmp, &sbuf) < 0 || !S_ISDIR(sbuf.st_mode))
+ 	  break;
+    }
+    name[len] = '\0';
+    return i == EndDir ? T : NIL;
+ }
+ 
+ /* given a maildir folder, return its path. Memory freed by caller. Directory
+  * does not contain the trailing slash "/". On error NULL is returned.
+  */
+ 
+ int maildir_file_path (char *name, char *tmp)
+ {
+    char *maildirpath = mail_parameters(NIL,GET_MDINBOX,NIL);
+ 
+     maildir_remove_root(&name);
+     tmp[0] = '\0';	/* just in case something fails */
+     if (strlen(myhomedir()) + 
+ 		max(strlen(name), strlen(maildirpath)) > MAILTMPLEN){
+ 	errno = ENAMETOOLONG;
+ 	sprintf(tmp,"Error opening \"%s\": %s", name, strerror (errno));
+ 	mm_log(tmp,ERROR);
+     }
+     else
+ 	sprintf (tmp,"%s/%s%s",myhomedir (),
+ 	    strncmp (ucase (strcpy (tmp, name)), "INBOX", 5) 
+ 		? name : maildirpath,
+ 	    strncmp (ucase (strcpy (tmp, name)), "INBOX", 5) 
+ 		? "" : *(name+5) == '/' ? name+5 : "");
+ 
+     return tmp[0] ? T : NIL;
+ }
+ 
+ /* Check validity of mailbox. This routine does not send errors to log, other
+  *  routines calling this one may do so, though
+  */ 
+ 
+ DRIVER *maildir_valid (char *name)
+ {
+   char tmpname[MAILTMPLEN+1];
+   struct stat sbuf;
+   int  rv, mdv, mdvd;
+ 
+    maildir_file_path(name, tmpname);
+    mdv = maildir_valid_name(name);
+    mdvd = maildir_valid_dir(tmpname);
+    rv = stat(tmpname, &sbuf);
+ 
+    return (mdv == 1 && rv == 0 && S_ISDIR(sbuf.st_mode) && mdvd == 1)
+ 	   || (mdv == 1 && rv < 0  && errno == ENOENT)
+ 	   || (mdv == 0 && mdvd == 1) ? &maildirdriver : NIL;
+ }
+ 
+ int maildir_base_name(char *name, char *tmp)
+ {
+   int i;
+ 
+   if (tmp)
+      *tmp = '\0';
+ 
+   if (!name || name[0] == '.')
+      return NIL;
+ 
+   for (i = 0; name[i] && name[i] != FLAGSEP && (tmp[i] = name[i]); i++);
+   tmp[i] = '\0';		/* tie me off, thank you */
+ 
+   return T;
+ }
+ 
+ /* 
+  * return all files in a given directory. This is a separate call
+  * so that if there are warnings during compilation this only appears once
+  * It is also important to touch the uidvalidity file to tell us when we did
+  * this last.
+  */
+ unsigned long
+ maildir_scandir (char *name, struct direct ***flist, 
+ 			unsigned long *nfiles, int *scand)
+ {
+   struct stat sbuf;
+ 
+   if (scand)
+      *scand = -1;	/* assume error for safety */
+   stat(name,&sbuf);	/* stat the containing directory */
+   if (scand)
+      *scand = scandir(name, flist, maildir_select, maildir_namesort);
+  *nfiles = (scand && (*scand > 0)) ? (unsigned long) *scand : 0L;
+ 
+   return sbuf.st_ctime;
+ }
+ 
+ /* Does a message with given name exists (or was it removed)?
+  * Returns: 1 - yes, such message exist,
+  *	    0 - No, that message does not exist anymore
+  *
+  * Parameters: stream, name of mailbox, new name if his message does not
+  *		exist.
+  */
+ 
+ int maildir_message_exists(MAILSTREAM *stream, char *name, char *newfile)
+ {
+   char tmp[MAILTMPLEN+1];
+   int gotit = NIL;
+   DIR *dir;
+   struct direct *d;
+   struct stat sbuf;
+ 
+   /* First check directly if it exists, if not there, look for it */
+   sprintf(tmp,"%s/%s", LOCAL->curdir, name);
+   if ((stat(tmp, &sbuf) == 0) && ((sbuf.st_mode & S_IFMT) == S_IFREG))
+     return T;
+ 
+   if (!(dir = opendir (LOCAL->curdir)))
+      return NIL;
+ 
+   while ((d = readdir(dir)) && gotit == NIL){
+     if (d->d_name[0] == '.')
+       continue;
+     if (same_maildir_file(d->d_name, name)){
+ 	  gotit = T;
+ 	  strcpy(newfile, d->d_name);
+     }
+   }
+   closedir(dir);
+   return gotit;
+ }
+ 
+ /* Maildir open */
+  
+ MAILSTREAM *maildir_open (MAILSTREAM *stream)
+ {
+   char tmp[MAILTMPLEN+1], tmp2[MAILTMPLEN+1];
+   struct stat sbuf;
+ 
+   if (!stream) return &maildirproto;
+   if (stream->local) fatal ("maildir recycle stream");
+   md_domain_name();    /* get domain name for maildir files in mdlocaldomain */
+   stream->uid_last  = stream->uid_validity = 0;
+   if (!stream->rdonly){
+      stream->perm_seen = stream->perm_deleted = stream->perm_flagged = 
+ 	stream->perm_answered = stream->perm_draft = T;
+   }
+   stream->uid_validity = time(0);
+   stream->local = (MAILDIRLOCAL *)fs_get (sizeof (MAILDIRLOCAL));
+   memset(LOCAL, 0, sizeof(MAILDIRLOCAL));
+   LOCAL->fd = -1;
+ 
+   strcpy(tmp2, stream->mailbox);	     /* tmp2 = what the user entered */
+   if (maildir_file_path("#md/INBOX", tmp))   /* tmp = real path to #md/inbox */
+      LOCAL->inbox = !strcmp(ucase(tmp2),"#MD/INBOX") || !strcmp(tmp2,tmp);
+ 
+   strcpy(tmp, stream->mailbox);
+   if (maildir_file_path (stream->mailbox, tmp))
+      LOCAL->dir = cpystr (tmp);
+   if (LOCAL->dir){
+      MDFLD(tmp, LOCAL->dir, Cur);
+      LOCAL->curdir = cpystr (tmp);
+      if (stat (LOCAL->curdir,&sbuf) < 0) {
+          sprintf (tmp,"Can't open folder %s: %s",
+ 				stream->mailbox,strerror (errno));
+          mm_log (tmp,ERROR);
+ 	 maildir_close(stream, 0);
+         return NIL;
+      }
+   }
+   sprintf(tmp,"%s/%s", *stream->mailbox == '/' ? "" : myhomedir(), 
+ 		        stream->mailbox);
+   fs_give ((void **) &stream->mailbox);
+   stream->mailbox = cpystr(tmp);
+ 
+   LOCAL->buf = (char *) fs_get ((LOCAL->buflen = MAXMESSAGESIZE) + 1);
+   stream->sequence++;
+   stream->nmsgs = stream->recent = 0;
+ 
+   maildir_parse_folder(stream, 1);
+ 
+   return stream;
+ }
+ 
+ /* Maildir initial parsing of the folder */
+ void
+ maildir_parse_folder (MAILSTREAM *stream, int full)
+ {
+    unsigned long total;
+ 
+    if (!stream)		/* what??? */
+       return;
+ 
+    MM_CRITICAL(stream);
+ 
+    /* Scan old messages first, escoba! */
+    total = LOCAL ? maildir_parse_dir(stream, 0L, Cur, full) 
+ 		 : stream->nmsgs;
+    stream->nmsgs = LOCAL ? maildir_parse_dir(stream, total, New, full) 
+ 			 : stream->nmsgs;
+ 
+    MM_NOCRITICAL(stream);
+ }
+ 
+ /* Return the number of messages in the directory, while filling the
+  * elt structure.
+  */
+ 
+ unsigned long
+ maildir_parse_dir(MAILSTREAM *stream, unsigned long nmsgs,
+ 		  DirNamesType dirtype, int full)
+ {
+    char tmp[MAILTMPLEN+1], tmp2[MAILTMPLEN+1], file[MAILTMPLEN+1], 
+ 	newfile[MAILTMPLEN+1], *mdstr;
+    struct direct **names = NIL;
+    struct stat sbuf;
+    unsigned long i, j = 0L, nfiles, last_scan;
+    unsigned long recent = stream ? stream->recent : 0L;
+    int d = 0, f = 0, r = 0, s = 0, t = 0;
+    int k, we_compute, in_list, scan_err;
+    int silent = stream ? stream->silent : NIL;
+    MESSAGECACHE *elt;
+ 
+    MDFLD(tmp, LOCAL->dir, dirtype);
+    if (access (tmp, R_OK|W_OK|X_OK) != 0){
+       maildir_abort(stream);
+       return stream->nmsgs;
+    }
+ 
+    MDFLD(tmp, LOCAL->dir, Cur);
+    if (dirtype != New && 
+ 	(stat(tmp, &sbuf) < 0 || sbuf.st_ctime == LOCAL->scantime))
+       return stream->nmsgs;
+ 
+    MDFLD(tmp, LOCAL->dir, dirtype);
+    last_scan =  maildir_scandir (tmp, &names, &nfiles, &scan_err);
+    if (dirtype == Cur)
+       LOCAL->scantime = last_scan;
+ 
+    if (scan_err < 0){
+ 	maildir_abort(stream);
+ 	return nmsgs;
+    }
+ 
+    if (dirtype == Cur)
+       for (i = 1L; i <= stream->nmsgs;){
+ 	elt = mail_elt(stream,  i);
+ 	in_list = elt && elt->maildirp && nfiles > 0L
+ 		  ? (MDPOS(elt) < nfiles 
+ 		    ? same_maildir_file(MDFILE(elt), names[MDPOS(elt)]->d_name)
+ 		    : NIL)
+ 		    || maildir_message_in_list(MDFILE(elt), names, 0L, 
+ 						nfiles - 1L, &MDPOS(elt))
+ 		  : NIL;
+ 	if (!in_list){
+ 	   if (elt->maildirp)
+ 	      maildir_free_file ((void **) &elt->maildirp);
+ 
+ 	   if (elt->recent) --recent;
+ 	   mail_expunged(stream,i);
+ 	}
+ 	else i++;
+       }
+ 
+    stream->silent = T;
+    for (we_compute = 0, i = 1L; i <= nfiles; i++){
+       unsigned long pos, n;
+       mail_exists(stream, i + nmsgs);
+       elt = mail_elt(stream, i + nmsgs);
+       if (elt && elt->maildirp)
+          pos = MDPOS(elt);	/* use data we found above */
+       else{
+         if (full)
+            pos = i - 1;		/* first time, use sequence number */
+         else{
+            for (n = 0L ; (n < nfiles) && !names[n] ; n++);
+            pos = n;		/* nfiles > stream->nmsgs!!, assign one */
+         }
+       }
+       if (dirtype == New) elt->recent = T;
+       if (!elt->private.uid){
+ 	 elt->private.uid = stream->uid_last + 1;
+ 	 stream->uid_validity = time(0);
+       }
+       if (stream->uid_last < elt->private.uid) 
+ 	  stream->uid_last = elt->private.uid;
+       if (elt->maildirp || stream->rdonly){
+ 	we_compute++; /* get old flags */
+ 	maildir_getflag(names[pos]->d_name, &d, &f, &r ,&s, &t);
+ 	maildir_free_file ((void **)&elt->maildirp);
+       }
+       maildir_get_file((MAILDIRFILE **)&elt->maildirp);
+       MDFILE(elt) = cpystr(names[pos]->d_name);
+       MDPOS(elt)  = pos;
+       if (full && !stream->rdonly) 
+ 	 maildir_parse_message(stream, i + nmsgs, dirtype);
+       if (we_compute && (elt->draft != d || elt->flagged != f || 
+ 	elt->answered != r || elt->seen != s || elt->deleted != t)){
+ 	   elt->draft = d; elt->flagged = f; elt->answered = r;
+ 	   elt->seen  = s; elt->deleted = t;
+ 	   if (!stream->rdonly)
+ 	      MM_FLAGS(stream, i+nmsgs);
+       }
+       if (full && !stream->rdonly){
+ 	 LOCAL->buf[elt->private.msg.header.text.size] = '\0';
+          close (LOCAL->fd);  LOCAL->fd = -1;
+       }
+       if (dirtype == New && !stream->rdonly){ /* move new messages to cur */
+ 	 sprintf (file,"%s/%s", tmp, names[pos]->d_name);
+ 	 if (stat (file,&sbuf) == 0 && S_ISREG (sbuf.st_mode)){
+ 	    strcpy(tmp2,names[pos]->d_name);
+ 	    if ((mdstr = strstr (names[pos]->d_name,MDSEP(3)))
+ 		|| (mdstr = strstr (names[pos]->d_name,MDSEP(2)))){ /* Grrr */
+ 	       *(mdstr+1) = '2';
+ 	       sprintf (newfile,"%s/%s",LOCAL->curdir,names[pos]->d_name);
+ 	    }
+ 	    else{
+ 	       sprintf (newfile,"%s/%s%s",LOCAL->curdir,names[pos]->d_name,MDSEP(2));
+ 	       strcat(tmp2, MDSEP(2));
+ 	    }
+ 	    if (link (file,newfile) < 0)
+ 	       mm_log("Unable to read new mail!",WARN);
+ 	    else{
+ 	      unlink (file);
+ 	      j++;	/* success!, count it! */
+ 	    }
+ 	 }
+ 	 maildir_free_file((void **)&elt->maildirp);
+ 	 maildir_get_file((MAILDIRFILE **)&elt->maildirp);
+ 	 MDFILE(elt) = cpystr(tmp2);
+       }
+       fs_give((void **)&names[pos]);
+    }
+    if(names)
+       fs_give((void **) &names);
+    stream->silent = silent;
+    if (dirtype == New && stream->rdonly)
+       j = nfiles;
+    mail_exists(stream, nmsgs  + (dirtype == New ? j : nfiles));
+    mail_recent(stream, recent + (dirtype == New ? j : 0));
+ 
+    return (nmsgs  + (dirtype == New ? j : nfiles));
+ }
+ 
+ long maildir_ping (MAILSTREAM *stream)
+ {
+   maildir_parse_folder(stream, 0);
+   return stream && LOCAL ? T : NIL;
+ }
+ 
+ int maildir_select (struct direct *name)
+ {
+  int rv = NIL, val;
+  val = name->d_name[0] - '0';
+  switch(val){
+      case 1: case 2: case 3: case 4: case 5:
+      case 6: case 7: case 8: case 9:
+         rv = T;
+      default: break;
+  }
+  return rv;
+ }
+ 
+ /*
+  * Unfortunately, there is no way to sort by arrival in this driver, this
+  * means that opening a folder in this driver using the scandir function
+  * will always make this driver slower than any driver that has a natural
+  * way of sorting by arrival (like a flat file format, "mbox", "mbx", etc).
+  */
+ 
+ int maildir_namesort (const void *d1,const  void *d2)
+ {
+   const struct direct **e1, **e2;
+ 
+   e1 = (const struct direct **)d1;
+   e2 = (const struct direct **)d2;
+ 
+   return comp_maildir_file((char*)(*e1)->d_name, (char *)(*e2)->d_name);
+ }
+ 
+ /* Maildir close */
+ 
+ void maildir_close (MAILSTREAM *stream, long options)
+ {
+   MESSAGECACHE *elt;
+   unsigned long i;
+   int silent = stream ? stream->silent : 0;
+   mailcache_t mc = (mailcache_t) mail_parameters (NIL,GET_CACHE,NIL);
+ 
+   if (!stream) return;
+ 
+   for (i = 1; i <= stream->nmsgs; i++)
+     if ((elt = (MESSAGECACHE *) (*mc) (stream,i,CH_ELT)) && elt->maildirp)
+       maildir_free_file ((void **) &(elt->maildirp));
+   stream->silent = T;
+   if (options & CL_EXPUNGE) maildir_expunge (stream);
+   maildir_abort(stream);
+   stream->silent = silent;
+ }
+ 
+ void maildir_check (MAILSTREAM *stream)
+ {
+   if (maildir_ping (stream)) mm_log ("Check completed",(long) NIL);   
+ }
+ 
+ long maildir_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs, long flags)
+ {
+   char tmp[MAILTMPLEN+1];
+   unsigned long i;
+   MESSAGECACHE *elt;
+   char *s;
+                                 /* UID call "impossible" */
+   if (flags & FT_UID || !LOCAL) return NIL;
+   elt = mail_elt (stream,msgno);
+   sprintf (tmp,"%s/%s",LOCAL->curdir, MDFILE(elt));
+   if (LOCAL->fd < 0)	/* if file closed ? */
+      LOCAL->fd = open(tmp,O_RDONLY,NIL);
+ 
+   if (LOCAL->fd < 0 && (errno == EACCES || errno == ENOENT)){
+      INIT (bs, mail_string, "", 0);
+      elt->rfc822_size = 0L;
+      return NIL;
+   }
+ 
+   if (!(flags & FT_PEEK) && !elt->seen) {     /* mark as seen */
+     elt->seen = T;
+     maildir_flagmsg (stream,elt); /* Change flags physically */
+     if (LOCAL->dirty == 0)
+ 	MM_FLAGS(stream, elt->msgno); 
+   }
+   s = maildir_text_work(stream, elt, &i, flags);
+   INIT (bs, mail_string, s, i);
+   return T;
+ }
+ 
+ char *maildir_text_work (MAILSTREAM *stream,MESSAGECACHE *elt,
+                       unsigned long *length,long flags)
+ {
+   FDDATA d;
+   STRING bs;
+   char *s,*t,*tl,tmp[CHUNK];
+   unsigned long msgno = elt->msgno;
+   static int try = 0;
+ 
+   if (length)
+      *length = 0L;
+   LOCAL->buf[0] = '\0';
+ 
+   sprintf (tmp,"%s/%s",LOCAL->curdir, MDFILE(elt));
+   if (LOCAL->fd < 0)	/* if file closed ? */
+      LOCAL->fd = open(tmp,O_RDONLY,NIL);
+ 
+   if (LOCAL->fd < 0){		/* flag change? */
+       if (try < 5){
+ 	try++;
+ 	if (maildir_update_elt_maildirp(stream, msgno) > 0)
+ 	  try = 0;
+ 	return maildir_text_work(stream, mail_elt(stream, msgno),length, flags);
+       }
+       try = 0;
+       return NULL;
+   }
+ 
+   lseek (LOCAL->fd,elt->private.special.offset +
+         elt->private.msg.text.offset,L_SET);
+ 
+   if (flags & FT_INTERNAL) {    /* initial data OK? */
+     if (elt->private.msg.text.text.size > LOCAL->buflen) {
+       fs_give ((void **) &LOCAL->buf);
+       LOCAL->buf = (char *) fs_get ((LOCAL->buflen =
+                                      elt->private.msg.text.text.size) + 1);
+     }
+     read (LOCAL->fd,LOCAL->buf,elt->private.msg.text.text.size);
+     LOCAL->buf[*length = elt->private.msg.text.text.size] = '\0';
+   }
+   else {
+     if (elt->rfc822_size > LOCAL->buflen) {
+       fs_give ((void **) &LOCAL->buf);
+       LOCAL->buf = (char *) fs_get ((LOCAL->buflen = elt->rfc822_size) + 1);
+     }
+     d.fd = LOCAL->fd;           /* yes, set up file descriptor */
+     d.pos = elt->private.special.offset + elt->private.msg.text.offset;
+     d.chunk = tmp;              /* initial buffer chunk */
+     d.chunksize = CHUNK;
+     INIT (&bs,fd_string,&d,elt->private.msg.text.text.size);
+     for (s = LOCAL->buf; SIZE (&bs);) switch (CHR (&bs)) {
+     case '\r':                  /* carriage return seen */
+       *s++ = SNX (&bs);         /* copy it and any succeeding LF */
+       if (SIZE (&bs) && (CHR (&bs) == '\n')) *s++ = SNX (&bs);
+       break;
+     case '\n':
+       *s++ = '\r';              /* insert a CR */
+     default:
+       *s++ = SNX (&bs);         /* copy characters */
+     }
+     *s = '\0';                  /* tie off buffer */
+     *length = s - (char *) LOCAL->buf;   /* calculate length */
+   }
+   close(LOCAL->fd); LOCAL->fd = -1;
+   return LOCAL->buf;
+ }
+ 
+ /* maildir parse, fill the elt structure... well not all of it... */
+ 
+ unsigned long maildir_parse_message(MAILSTREAM *stream, unsigned long msgno,
+ 				    DirNamesType dirtype)
+ {
+   struct stat sbuf;
+   struct tm *tm;
+   char *b, *s;
+   char v[MAILTMPLEN+1],t[MAILTMPLEN+1], tmp[MAILTMPLEN+1];
+   unsigned long i;
+   long len;
+   int offset = 0, d, f, r, se, dt;
+   MESSAGECACHE *elt;
+ 
+   elt = mail_elt (stream,msgno);
+   MSGPATH(tmp, LOCAL->dir, MDFILE(elt), dirtype);
+   if (LOCAL->fd < 0)	/* if file closed ? */
+      LOCAL->fd = open(tmp,O_RDONLY,NIL);
+ 
+   if (fstat(LOCAL->fd,&sbuf) == 0){
+      tm = gmtime (&sbuf.st_mtime);
+      elt->day = tm->tm_mday; elt->month = tm->tm_mon + 1;
+      elt->year = tm->tm_year + 1900 - BASEYEAR;
+      elt->hours = tm->tm_hour; elt->minutes = tm->tm_min;
+      elt->seconds = tm->tm_sec;
+      elt->zhours = 0; elt->zminutes = 0;
+      if (LOCAL->fd >= 0){
+ 	s = (char *) fs_get (sbuf.st_size + 1);
+ 	read (LOCAL->fd,s,sbuf.st_size);
+ 	s[sbuf.st_size] = '\0';
+ 	for (i = 0, b = s; *b && !(i && (*b == '\n')); i = (*b++ == '\n'));
+ 	    len = (*b ? ++b:b) - s;
+ 	elt->private.msg.header.text.size = 
+ 		elt->private.msg.text.offset = len;
+ 	elt->private.msg.text.text.size = sbuf.st_size - len;
+ 	elt->rfc822_size = strcrlfcpy (&LOCAL->buf,&LOCAL->buflen, 
+ 							     s, sbuf.st_size);
+ 	fs_give ((void **) &s);
+ 	close(LOCAL->fd); LOCAL->fd = -1;
+      }
+   }
+   maildir_getflag(MDFILE(elt), &d, &f, &r ,&se, &dt);
+   elt->draft = d; elt->flagged = f; elt->answered = r; elt->seen = se;
+   elt->deleted = dt; elt->valid  = T;
+   return elt->rfc822_size;
+ }
+ 
+ int
+ maildir_update_elt_maildirp(MAILSTREAM *stream, unsigned long msgno)
+ {
+      char tmp[MAILTMPLEN+1];
+      struct direct **names = NIL;
+      unsigned long i, nfiles, pos;
+      int d = 0, f = 0 , r = 0, s = 0, t = 0, in_list, scan_err;
+      MESSAGECACHE *elt;
+ 
+      MDFLD(tmp, LOCAL->dir, Cur);
+ 
+      maildir_scandir (tmp, &names, &nfiles, &scan_err);
+ 
+      elt = mail_elt (stream,msgno);
+ 
+      in_list = nfiles > 0L
+ 		? maildir_message_in_list(MDFILE(elt), names, 0L, 
+ 					nfiles - 1L, &pos)
+ 		: NIL;
+ 
+      if (in_list && pos >= 0L && pos < nfiles
+ 	 && !strcmp(MDFILE(elt), names[pos]->d_name)){
+ 	in_list = NIL;
+ 	maildir_abort(stream);
+      }
+ 
+      if (in_list && pos >= 0L && pos < nfiles){
+ 	maildir_free_file((void **)&elt->maildirp);
+ 	maildir_get_file((MAILDIRFILE **)&elt->maildirp);
+ 	MDFILE(elt) = cpystr(names[pos]->d_name);
+ 	maildir_getflag(MDFILE(elt), &d, &f, &r ,&s, &t);
+ 	if (elt->draft != d || elt->flagged != f || 
+ 	   elt->answered != r || elt->seen != s || elt->deleted != t){
+ 	   elt->draft = d; elt->flagged = f; elt->answered = r;
+ 	   elt->seen  = s; elt->deleted = t;
+ 	   MM_FLAGS(stream, msgno);
+         }
+      }
+      for (i = 0L; i < nfiles; i++)
+ 	fs_give((void **) &names[i]);
+      if (names)
+ 	fs_give((void **) &names);
+      return in_list ? 1 : -1;
+ }
+ 
+ /* Maildir fetch message header */
+ 
+ char *maildir_header (MAILSTREAM *stream,unsigned long msgno,
+ 		unsigned long *length, long flags)
+ {
+   char tmp[MAILTMPLEN+1], *s;
+   struct stat sbuf;
+   MESSAGECACHE *elt;
+   static int try = 0;
+ 
+   if (length)
+      *length = 0;
+   if (flags & FT_UID || !LOCAL) return "";	/* UID call "impossible" */
+   elt = mail_elt (stream,msgno);
+   sprintf (tmp,"%s/%s",LOCAL->curdir, MDFILE(elt));
+   if (LOCAL->fd < 0)
+      LOCAL->fd = open (tmp,O_RDONLY,NIL);
+ 
+   if (LOCAL->fd < 0 && errno == EACCES){
+      mm_log ("Message exists but can not be read. Envelope and body lost!",ERROR);
+      return NULL;
+   }
+ 
+   if (LOCAL->fd < 0){			/* flag change? */
+       if (try < 5){
+ 	try++;
+ 	if (maildir_update_elt_maildirp(stream, msgno) > 0)
+ 	  try = 0;
+ 	return maildir_header(stream, msgno, length, flags);
+       }
+       try = 0;
+       return NULL;
+   }
+ 
+   lseek (LOCAL->fd, 0,L_SET);
+ 
+   if (elt->private.msg.header.text.size == 0){
+      maildir_parse_message(stream, msgno, Cur);
+      LOCAL->buf[*length = elt->private.msg.header.text.size] = '\0';
+   }
+   else{ 
+      if ((flags & FT_INTERNAL) && 
+ 	(elt->private.msg.header.text.size > LOCAL->buflen)){
+ 	   fs_give ((void **) &LOCAL->buf);
+ 	   LOCAL->buf = (char *) fs_get ((LOCAL->buflen =
+                                  elt->private.msg.header.text.size) + 1);
+      }
+      else
+ 	s = (char *) fs_get(elt->private.msg.header.text.size+1);
+      if (LOCAL->fd >= 0){
+         read (LOCAL->fd,flags & FT_INTERNAL ? (void *)LOCAL->buf : (void *)s,
+ 					elt->private.msg.header.text.size);
+ 	if (flags & FT_INTERNAL)
+ 	   LOCAL->buf[*length = elt->private.msg.header.text.size] = '\0';
+ 	else{
+ 	   s[*length = elt->private.msg.header.text.size] = '\0';
+ 	   *length = strcrlfcpy (&LOCAL->buf,&LOCAL->buflen,s,
+                           elt->private.msg.header.text.size);
+ 	    fs_give ((void **) &s);
+ 	}
+      } 
+   }
+   close (LOCAL->fd);  LOCAL->fd = -1;
+   *length = mail_filter (LOCAL->buf,*length,NIL,FT_NOT);
+   return LOCAL->buf;
+ }
+ 
+ /* fetches "fast" attributes (flags, internal date and rfc822 size) */
+ 
+ void maildir_fast (MAILSTREAM *stream,char *sequence,long flags)
+ {
+   unsigned long i;
+ 
+   if (stream && LOCAL && ((flags & FT_UID) ?
+ 			  mail_uid_sequence (stream,sequence) :
+ 			  mail_sequence (stream,sequence)))
+     for (i = 1; i <= stream->nmsgs; i++)
+       if (mail_elt (stream,i)->sequence) maildir_parse_message(stream, i, Cur);
+ }
+ 
+ /* Maildir find list of subscribed mailboxes
+  * Accepts: mail stream
+  *	    pattern to search
+  */
+ 
+ void maildir_list (MAILSTREAM *stream,char *ref, char *pat)
+ {
+   char *s,test[MAILTMPLEN+1],file[MAILTMPLEN+1];
+   long i = 0;
+ 
+   if (!pat || !*pat) {
+     if (maildir_canonicalize (test,ref,"*")) {
+       if (maildir_valid_name(test)){	/* there is a #md/ leading here */
+ 	for (i = 3; test[i] && test[i] != '/'; i++);
+ 	if (s = strchr (test+i+1,'/')) *++s = '\0';
+ 	else test[0] = '\0';
+ 	mm_list (stream,'/',test, LATT_NOSELECT);
+       }
+     }
+   }
+                                 /* get canonical form of name */
+   else if (maildir_canonicalize (test,ref,pat)) {
+     if (test[3] == '/') {       /* looking down levels? */
+                                 /* yes, found any wildcards? */
+       if (s = strpbrk (test,"%*")) {
+                                 /* yes, copy name up to that point */
+         strncpy (file,test+4,i = s - (test+4));
+         file[i] = '\0';         /* tie off */
+       }
+       else strcpy (file,test+4);/* use just that name then */
+                                 /* find directory name */
+       if (s = strrchr (file,'/')) {
+         *s = '\0';              /* found, tie off at that point */
+         s = file;
+       }
+                                 /* do the work */
+       maildir_list_work (stream,s,test,0);
+     }
+                                 /* always an INBOX */
+     if (!compare_cstring (test,"#MD/INBOX"))
+       mm_list (stream,NIL,"#MD/INBOX",LATT_NOINFERIORS);
+   }
+ }
+ 
+ /* For those that want to hide things, we give them a chance to do so */
+ void *maildir_parameters (long function,void *value)
+ {
+   switch ((int) function) {
+   case GET_MDINBOX:
+     value = env_parameters (function,NIL);
+     break;
+   default:
+     value = NIL; 
+     break;
+   }
+   return value;
+ }
+ 
+ long maildir_create_work(char *mailbox)
+ {
+   char *s, c, err[MAILTMPLEN+1], tmp[MAILTMPLEN+1];
+   int fnlen, i, create_dir = 0;
+   struct stat sbuf;
+ 
+   if (mailbox[strlen(mailbox) - 1] == '/'){
+       create_dir++;
+       mailbox[strlen(mailbox) - 1] = '\0';
+   }
+ 
+   fnlen = strlen(mailbox);
+ 
+   if (s = strrchr(mailbox,'/')){
+      c = *++s;
+     *s = '\0';
+ 
+     if ((stat(mailbox,&sbuf) || ((sbuf.st_mode & S_IFMT) != S_IFDIR)) &&
+         !maildir_create_work (mailbox))
+       return NIL;
+     *s = c;
+   }
+   mailbox[fnlen] = '\0';
+ 
+   if (mkdir (mailbox,0700) && errno != EEXIST)
+      return NIL;
+ 
+   if (create_dir)
+      mailbox[fnlen] = '/';
+ 
+   if (!create_dir){
+      for (i = Cur; i != EndDir; i++){
+ 	MDFLD(tmp, mailbox, i);
+ 
+ 	if (mkdir(tmp, 0700)){	/* try to make new dir */
+ 	    sprintf (err, "Can't create %s: %s", tmp, strerror(errno));
+ 	    mm_log (err,ERROR);
+ 	    return NIL;
+ 	}
+      }
+   }
+   else{
+      FILE *fp = NULL;
+      sprintf(tmp,"%s%s", mailbox, MDDIR);
+      if ((fp = fopen(tmp,"w")) == NULL){
+ 	sprintf (err,"Problem creating %s: %s", tmp, strerror(errno));
+ 	    mm_log (err,ERROR);
+ 	    return NIL;
+      }
+      fclose(fp);
+   }
+   return T;			/* return success */
+ }
+ 
+ long maildir_create (MAILSTREAM *stream,char *mailbox)
+ {
+   char tmp[MAILTMPLEN+1], err[MAILTMPLEN+1];
+   long rv;
+   int create_dir;
+ 
+   create_dir = mailbox ? (mailbox[strlen(mailbox) - 1] == '/') : 0;
+   maildir_file_path(mailbox, tmp);
+   rv = maildir_create_work(tmp);
+   if (rv == 0L){
+      sprintf (err,"Can't create %s %s: %s %s",
+ 		   create_dir ? "directory" : "mailbox", 
+ 		   mailbox, tmp, strerror (errno));
+      mm_log (err,ERROR);
+   }
+   return rv;
+ }
+ 
+ #define MAXTRY 10000
+ void maildir_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt)
+ {
+   char oldfile[MAILTMPLEN+1],newfile[MAILTMPLEN+1],fn[MAILTMPLEN+1];
+   char tmp[MAILTMPLEN+1];
+   struct stat sbufold, sbufnew;
+   char *s;
+   int ren, try = 0;
+ 
+   LOCAL->dirty = 0;
+   if (elt->valid){
+      for (try = 1; try > 0 && try < MAXTRY; try++){
+                                 /* build the new filename */
+ 	sprintf (oldfile,"%s/%s",LOCAL->curdir, MDFILE(elt));
+ 	fn[0] = '\0';
+ 	if ((ren = maildir_message_exists(stream, MDFILE(elt), fn)) == 0){
+ 	    errno = ENOENT;
+ 	    try = MAXTRY;
+ 	}
+ 	if (*fn)	/* new oldfile! */
+ 	   sprintf (oldfile,"%s/%s",LOCAL->curdir,fn);
+         if ((s = strchr (MDFILE(elt), FLAGSEP))) *s = '\0';
+ 	sprintf (fn,"%s%s%s%s%s%s%s", MDFILE(elt), MDSEP(2),
+ 		MDFLAG(Draft, elt->draft), MDFLAG(Flagged, elt->flagged),
+ 		MDFLAG(Replied, elt->answered), MDFLAG(Seen, elt->seen),
+ 		MDFLAG(Trashed, elt->deleted));
+ 	sprintf (newfile,"%s/%s",LOCAL->curdir,fn);
+         if (ren != 0 && rename (oldfile,newfile) >= 0){
+ 	   char tmp[MAILTMPLEN+1];
+          try = -1;
+ 	}
+      }
+ 
+      if (try > 0){
+        sprintf(oldfile,"Unable to write flags to disk: %s",strerror (errno));
+        mm_log(oldfile,ERROR);
+        LOCAL->dirty = 1;
+        return;
+      }
+      maildir_free_file ((void **) &elt->maildirp);
+      maildir_get_file((MAILDIRFILE **)&elt->maildirp);
+      MDFILE(elt) = cpystr (fn);
+   }
+ }
+ 
+ void maildir_expunge (MAILSTREAM *stream)
+ {
+   MESSAGECACHE *elt;
+   unsigned long i;
+   unsigned long n = 0;
+   unsigned long nmsgs = stream->nmsgs;
+   unsigned long recent = stream->recent;
+   char tmp[MAILTMPLEN+1];
+   
+   mm_critical (stream);		/* go critical */
+   for (i = 1; i <= stream->nmsgs;)
+     if ((elt = mail_elt (stream,i))->deleted){
+       sprintf (tmp,"%s/%s",LOCAL->curdir, MDFILE(elt));
+       if (unlink (tmp)) {/* try to delete the message */
+ 	sprintf (tmp,"Expunge of message %ld failed, aborted: %s",i,
+ 		 strerror (errno));
+ 	if (!stream->silent)
+ 	   mm_log (tmp,WARN);
+ 	break;
+       }
+ 				/* free the cached filename */
+       if (elt->maildirp)
+ 	 maildir_free_file ((void **) &elt->maildirp);
+ 
+       if (elt->recent) --recent;/* if recent, note one less recent message */
+       mail_expunged (stream,i);	/* notify upper levels */
+       n++;			/* count up one more expunged message */
+     }
+     else i++;
+   if (n) {			/* output the news if any expunged */
+     sprintf (tmp,"Expunged %ld messages",n);
+     if (!stream->silent)
+        mm_log (tmp,(long) NIL);
+   }
+   else 
+     if (!stream->silent)
+ 	mm_log ("No messages deleted, so no update needed",(long) NIL);
+   mm_nocritical (stream);	/* release critical */
+ 				/* notify upper level of new mailbox size */
+   mail_exists (stream,stream->nmsgs);
+   mail_recent (stream,recent);
+ }
+ 
+ long maildir_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options)
+ {
+   STRING st;
+   MESSAGECACHE *elt;
+   struct stat sbuf;
+   unsigned long len;
+   int fd;
+   long i, length;
+   char tmp[MAILTMPLEN+1], flags[MAILTMPLEN+1], path[MAILTMPLEN+1], *s, *b;
+ 				/* copy the messages */
+   if ((options & CP_UID) ? mail_uid_sequence (stream, sequence) : 
+   	mail_sequence (stream,sequence)) 
+   for (i = 1; i <= stream->nmsgs; i++)
+     if ((elt = mail_elt (stream,i))->sequence){
+       sprintf (path,"%s/%s",LOCAL->curdir, MDFILE(elt));
+       if ((fd = open (path,O_RDONLY,NIL)) < 0) return NIL;
+ 	fstat (fd,&sbuf);
+ 
+         s = (char *) fs_get(sbuf.st_size + 1);
+         read (fd,s,sbuf.st_size);
+         s[sbuf.st_size] = '\0';
+         close (fd);
+ 	len = strcrlfcpy (&LOCAL->buf,&LOCAL->buflen, s, sbuf.st_size);
+         INIT (&st,mail_string, LOCAL->buf, len);
+ 	fs_give ((void **)&s);
+ 
+       flags[0] = flags[1] = '\0';
+       if (elt->seen) strcat (flags," \\Seen");
+       if (elt->draft) strcat (flags," \\Draft");
+       if (elt->deleted) strcat (flags," \\Deleted");
+       if (elt->flagged) strcat (flags," \\Flagged");
+       if (elt->answered) strcat (flags," \\Answered");
+       flags[0] = '(';         /* open list */
+       strcat (flags,")");     /* close list */
+       mail_date (tmp,elt);	/* generate internal date */
+       if (!mail_append_full (NIL,mailbox,flags,tmp,&st))
+         return NIL;
+       if (options & CP_MOVE) elt->deleted = T;
+     }
+   return T;			/* return success */
+ }
+ 
+ long maildir_append (MAILSTREAM *stream,char *mailbox,append_t af,void *data)
+ {
+   int fd;
+   STRING *message;
+   char c,*s, *flags, *date;
+   char tmp[MAILTMPLEN+1],file[MAILTMPLEN+1],path1[MAILTMPLEN+1],path2[MAILTMPLEN+1];
+   MESSAGECACHE elt;
+   long i;
+   long size = 0;
+   long ret = LONGT;
+   unsigned long uf;
+   long f;
+   static unsigned int transact = 0;
+ 
+   if (!maildir_valid(mailbox)) {
+     sprintf (tmp,"Not a valid Maildir mailbox: %s",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 
+  if (!*mdlocaldomain)
+      md_domain_name();    /* get domain name for maildir files in mdlocaldomain now! */
+ 
+   if (!(*af) (stream,data,&flags,&date,&message)) return NIL;
+ 
+   mm_critical (stream);		/* go critical */
+   do {
+     if (!SIZE (message)) {      /* guard against zero-length */
+       mm_log ("Append of zero-length message",ERROR);
+       ret = NIL;
+       break;
+     }
+     if (date) {                 /* want to preserve date? */
+                                 /* yes, parse date into an elt */
+       if (!mail_parse_date (&elt,date)) {
+         sprintf (tmp,"Bad date in append: %.80s",date);
+         mm_log (tmp,ERROR);
+         ret = NIL;
+         break;
+       }
+     }
+     f = mail_parse_flags (stream,flags,&uf);
+ 				/* build file name we will use */
+     sprintf (file,"%u.%d_%09u.%s%s%s%s%s%s",
+ 	   time (0),getpid (),transact++,mdlocaldomain, f ? MDSEP(2) : "",
+ 		MDFLAG(Draft, f&fDRAFT), MDFLAG(Flagged, f&fFLAGGED),
+ 		MDFLAG(Replied, f&fANSWERED), MDFLAG(Seen, f&fSEEN));
+ 				/* build tmp file name */
+     if (maildir_file_path(mailbox, tmp))
+        MSGPATH(path1, tmp, file, Tmp);
+ 
+     if ((fd = open (path1,O_WRONLY|O_CREAT|O_EXCL,S_IREAD|S_IWRITE)) < 0) {
+        sprintf (tmp,"Can't open append mailbox: %s",strerror (errno));
+        mm_log (tmp,ERROR);
+        return NIL;
+     }
+     for (size = 0,i = SIZE (message),s = (char *) fs_get (i + 1); i; --i)
+       if ((c = SNX (message)) != '\015') s[size++] = c;
+     if ((write (fd,s,size) < 0) || fsync (fd)) {
+ 	unlink (path1);		/* delete message */
+ 	sprintf (tmp,"Message append failed: %s",strerror (errno));
+ 	mm_log (tmp,ERROR);
+ 	ret = NIL;
+     }
+     fs_give ((void **) &s);	/* flush the buffer */
+     close (fd);			/* close the file */
+ 				/* build final filename to use */
+     if (maildir_file_path(mailbox, tmp))
+ 	MSGPATH(path2, tmp, file, New);
+     if (link (path1,path2) < 0) {
+        sprintf (tmp,"Message append failed: %s",strerror (errno));
+        mm_log (tmp,ERROR);
+        ret = NIL;
+     }
+     unlink (path1);
+ 
+     if (ret)
+      if (!(*af) (stream,data,&flags,&date,&message)) ret = NIL;
+ 
+   } while (ret && message);	/* write the data */
+   
+   mm_nocritical (stream);	/* release critical */
+   return ret;
+ }
+ 
+ long maildir_delete (MAILSTREAM *stream,char *mailbox)
+ {
+   DIR *dirp;
+   struct direct *d;
+   int i, remove_dir = 0, mddir = 0, rv;
+   char tmp[MAILTMPLEN+1],tmp2[MAILTMPLEN+1];
+   struct stat sbuf;
+   char *mdpath = mail_parameters(NIL,GET_MDINBOX,NIL);
+ 
+   if (mailbox[strlen(mailbox) - 1] == '/'){
+       remove_dir++;
+       mailbox[strlen(mailbox) -1] = '\0';
+   }
+ 
+   if (!maildir_valid(mailbox)){
+       struct stat sbuf;
+       sprintf(tmp,"%s/%s/", myhomedir(), *(mdfpath+4) ? mdfpath+4 : mdpath);
+       if (stat(tmp, &sbuf) < 0 || !S_ISDIR(sbuf.st_mode))
+      return NIL;
+   }
+ 
+   maildir_close(stream,0);	/* even if stream was NULL */
+ 
+   if (remove_dir && !maildir_dir_is_empty(mailbox)){
+      sprintf(tmp,"Can not remove directory %s/: directory not empty", mailbox);
+      mm_log (tmp,ERROR);
+      return NIL;
+   }
+   maildir_file_path(mailbox, tmp2);
+ 
+   if (remove_dir){
+      sprintf(tmp,"%s/%s", tmp2, MDDIR);
+      if ((rv = stat (tmp,&sbuf)) == 0 && S_ISREG(sbuf.st_mode))
+ 	rv = unlink(tmp);
+      else if (errno == ENOENT)
+ 	rv = 0;
+      if (rv != 0){
+ 	sprintf(tmp,"Can not remove %s/%s: %s", tmp2, MDDIR, strerror(errno));
+ 	mm_log (tmp,ERROR);
+ 	return NIL;
+      }
+      if (!maildir_valid(mailbox) && rmdir(tmp2) != 0){
+ 	sprintf(tmp,"Can not remove %s/: %s", tmp2, strerror(errno));
+ 	mm_log (tmp,ERROR);
+ 	return NIL;
+      }
+      return T;
+   }
+   /* else remove just the folder. Remove all hidden files, except MDDIR */
+   for (i = Cur; i != EndDir; i++){
+       maildir_file_path(mailbox, tmp);
+       MDFLD(tmp2, tmp, i);
+ 
+       if (!(dirp = opendir (tmp2))){
+ 	  sprintf(tmp,"Can not read %s/: %s", tmp2, strerror(errno));
+ 	  mm_log (tmp,ERROR);
+ 	  return NIL;
+       }
+ 
+       while (d = readdir(dirp)){
+ 	 if (strcmp(d->d_name, ".") && strcmp(d->d_name,"..")){
+ 	    sprintf(tmp,"%s/%s", tmp2, d->d_name);
+ 	    if (unlink(tmp) != 0){
+ 	       sprintf(tmp,"Can not remove %s: %s", tmp2, strerror(errno));
+ 	       mm_log (tmp,ERROR);
+ 	       return NIL;
+ 	    }
+ 	 }
+       }
+       closedir(dirp);
+       if (rmdir(tmp2) != 0){
+ 	 sprintf(tmp,"Can not remove %s: %s", tmp2, strerror(errno));
+ 	 mm_log (tmp,ERROR);
+ 	 return NIL;
+       }
+   }
+   /* 
+    * ok we have removed all subdirectories of the folder mailbox, Remove the
+    * hidden files.
+    */
+ 
+      maildir_file_path(mailbox, tmp2);
+      if (!(dirp = opendir (tmp2))){
+ 	sprintf(tmp,"Can not read %s/: %s", tmp2, strerror(errno));
+ 	mm_log (tmp,ERROR);
+ 	return NIL;
+      }
+ 
+      while (d = readdir(dirp)){
+ 	if (strcmp(d->d_name, ".") && strcmp(d->d_name,"..")
+ 		&& strcmp(d->d_name, MDDIR)){
+ 	   sprintf(tmp,"%s/%s", tmp2, d->d_name);
+ 	   if (unlink(tmp) != 0){
+ 	      sprintf(tmp,"Can not remove %s: %s", tmp2, strerror(errno));
+ 	      mm_log (tmp,ERROR);
+ 	      return NIL;
+ 	   }
+ 	}
+ 	else if (!strcmp(d->d_name, MDDIR)) mddir++;
+      }
+      closedir(dirp);
+      if (maildir_dir_is_empty(mailbox) && mddir == 0 && rmdir(tmp2) < 0){
+         sprintf(tmp,"Can not remove folder %s: %s", mailbox, strerror(errno));
+         mm_log (tmp,ERROR);
+         return NIL;
+      }
+    return T;
+ }
+ 
+ long maildir_rename (MAILSTREAM *stream,char *old,char *new)
+ {
+   char tmp[MAILTMPLEN+1],tmpnew[MAILTMPLEN+1];
+   char *maildirpath = mail_parameters(NIL, GET_MDINBOX, NIL);
+ 
+   if (!maildir_valid(old)){
+     sprintf (tmp,"Can't rename mailbox %s: folder not in maildir format",old);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   sprintf(tmp,"%s/%s/", myhomedir(), *(mdfpath+4) ? mdfpath+4 : maildirpath);
+ 
+   if (!maildir_valid_name(new) && new[0] == '#'){
+     sprintf (tmp,"Can't rename mailbox %s: folder not in maildir format",new);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   sprintf(tmpnew,"%s/%s/", myhomedir(), *(mdfpath+4) ? mdfpath+4 : maildirpath);
+ 				/* new mailbox name must not exist */
+   if (access(tmpnew,F_OK) == 0) {
+     sprintf (tmp,"Can't rename to mailbox %s: destination already exists",new);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 				/* try to rename the directory */
+   if (rename (tmp,tmpnew)) {
+     sprintf (tmp,"Can't rename mailbox %s to %s: %s",old,new,strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   return T;			/* return success */
+ }
+ 
+ long maildir_sub (MAILSTREAM *stream,char *mailbox)
+ {
+   return sm_subscribe (mailbox);
+ }
+ 
+ long maildir_unsub (MAILSTREAM *stream,char *mailbox)
+ {
+   return sm_unsubscribe (mailbox);
+ }
+ 
+ void maildir_lsub (MAILSTREAM *stream,char *ref,char *pat)
+ {
+   void *sdb = NIL;
+   char *s, 	test[MAILTMPLEN+1];
+                                 /* get canonical form of name */
+   if (maildir_canonicalize (test,ref,pat) && (s = sm_read (&sdb))) {
+     do if (pmatch_full (s,test,'/')) mm_lsub (stream,'/',s,NIL);
+     while (s = sm_read (&sdb)); /* until no more subscriptions */
+   }
+ }
+ 
+ long maildir_canonicalize (char *pattern,char *ref,char *pat)
+ {
+   if (ref && *ref) {            /* have a reference */
+     strcpy (pattern,ref);       /* copy reference to pattern */
+                                 /* # overrides mailbox field in reference */
+     if (*pat == '#') strcpy (pattern,pat);
+                                 /* pattern starts, reference ends, with / */
+     else if ((*pat == '/') && (pattern[strlen (pattern) - 1] == '/'))
+       strcat (pattern,pat + 1); /* append, omitting one of the period */
+                                                                                 
+     else strcat (pattern,pat);  /* anything else is just appended */
+   }
+   else strcpy (pattern,pat);    /* just have basic name */
+   return (maildir_valid_name(pattern));
+ }
+ 
+ void maildir_list_work (MAILSTREAM *stream,char *dir,char *pat,long level)
+ {
+   DIR *dp;
+   struct direct *d;
+   struct stat sbuf;
+   char *cp,*np, curdir[MAILTMPLEN+1],name[MAILTMPLEN+1], tmp[MAILTMPLEN+1];
+   int i;
+   char *maildirpath = mail_parameters(NIL, GET_MDINBOX, NIL);
+ 
+   sprintf(curdir,"%s/%s/", myhomedir(), dir ? dir : maildirpath);
+   if (dp = opendir (curdir)){ 
+      if (dir) sprintf (name,"#md/%s/",dir);
+      else strcpy (name,"#md/");
+ 
+      if (level == 0 && name && pmatch_full (name, pat, '/'))
+ 	mm_list (stream,'/', name, LATT_NOSELECT);
+ 
+      while (d = readdir (dp))
+        if (strcmp(d->d_name, ".") && strcmp(d->d_name,"..")
+ 		&& strcmp(d->d_name, MDNAME(Cur)) 
+ 		&& strcmp(d->d_name, MDNAME(Tmp)) 
+ 		&& strcmp(d->d_name, MDNAME(New))){
+ 
+ 	  if (dir) sprintf (tmp,"%s%s", name,d->d_name);
+ 	  else strcpy(tmp, d->d_name);
+ 
+ 	  if (pmatch_full (tmp,pat,'/')){
+ 	       sprintf(tmp,"%s/%s/%s", myhomedir(), dir ? dir : maildirpath,
+ 						 d->d_name);
+                if (stat (tmp,&sbuf) == 0 
+ 		   && ((sbuf.st_mode & S_IFMT) == S_IFDIR)){
+ 		    if (dir) sprintf (tmp,"%s%s", name,d->d_name);
+ 		    else strcpy(tmp, d->d_name);
+ 		     i = maildir_valid(tmp) ? LATT_NOINFERIORS : LATT_NOSELECT;
+ 		     if (i == LATT_NOINFERIORS && 
+ 				maildir_contains_folder(dir, d->d_name))
+ 			i = LATT_HASCHILDREN;
+ 		     i += maildir_any_new_msgs(tmp) ? LATT_MARKED : LATT_UNMARKED;
+ 	             mm_list (stream,'/',tmp, i);
+ 		     strcat (tmp, "/");
+ 	             if (dmatch (tmp,pat,'/') &&
+                        (level < (long) mail_parameters (NIL,GET_LISTMAXLEVEL,NIL))){
+ 		       sprintf(tmp,"%s/%s",dir,d->d_name);
+  		       maildir_list_work (stream,tmp,pat,level+1);
+ 		     }
+ 	       }
+ 	  }
+        }
+   }
+   closedir (dp);
+ }
+ 
+ int 
+ same_maildir_file(char *name1, char *name2)
+ {
+  char tmp1[MAILTMPLEN+1], tmp2[MAILTMPLEN+1];
+  char *s1, *s2;
+  int i;
+ 
+  strcpy(tmp1, name1 ? name1 : "");
+  strcpy(tmp2, name2 ? name2 : "");
+  if (s1 = strchr(name1, FLAGSEP)){
+    for (i = 0; tmp1[i] != FLAGSEP; i++);
+    tmp1[i] = '\0';
+  } 
+  if (s2 = strchr(name2, FLAGSEP)){
+    for (i = 0; tmp2[i] != FLAGSEP; i++);
+    tmp2[i] = '\0';
+  } 
+  return !strcmp(tmp1, tmp2);
+ }
+ 
+ 
+ int comp_maildir_file(char *name1, char *name2)
+ {
+   char tmp1[MAILTMPLEN+1], tmp2[MAILTMPLEN+1], *s1, *s2;
+   unsigned long t1, t2;
+   int i, try_strcmp;
+ 
+   if (!(name1 && *name1))
+      return name2 && *name2 ? (*name2 == FLAGSEP ? 0 : -1) : 0;
+                                                                                 
+   if (!(name2 && *name2))
+      return name1 && *name1 ? (*name1 == FLAGSEP ? 0 : 1) : 0;
+                                                                                 
+    if(!strcmp(name1,name2))
+       return 0;
+ 
+   strcpy(tmp1,name1);
+   strcpy(tmp2,name2);
+ 
+   if(s1 = strchr(tmp1,'.')){
+      *s1++ = '\0';
+      t1 = strtoul(tmp1, NULL, 10);
+   }
+   if(s2 = strchr(tmp2,'.')){
+      *s2++ = '\0';
+      t2 = strtoul(tmp2, NULL, 10);
+   }
+ 
+   if (t1 < t2)
+      return -1;
+ 
+   if (t1 > t2)
+     return 1;
+ 
+   /* 
+    * Ok, we know t1 = t2, but we need to figure out how to sort them when
+    * they have the same arrival time. We will have to use strcmp to do this
+    * for us, but we will do so by first passing the part that they agree on.
+    */
+ 
+   for (i = 0; s1 && s2 && s1[i] && s2[i] && s1[i] == s2[i]; i++);
+   s1 += i;
+   s2 += i;
+   if (s1 && s2 && *s1 && *s2){
+      strcpy(tmp1, s1);
+      strcpy(tmp2, s2);
+      if(s1 = strchr(tmp1,'.'))
+ 	*s1++ = '\0';
+      if(s2 = strchr(tmp2,'.'))
+        *s2++ = '\0';
+      if (s1 && s2 && *s1 && *s2)
+         return strcmp(tmp1, tmp2);
+   }
+   return 0;
+ }
+ 
+ void
+ maildir_getflag(char *name, int *d, int *f, int *r ,int *s, int *t)
+ {
+   char tmp[MAILTMPLEN+1], *b;
+   int offset = 0;
+ 
+   if(d && f && r && s && t) 
+     *d = *f = *r = *s = *t = 0;
+   else
+     return; 		/* can not call this function with null arguments */
+ 
+   strcpy(tmp,name);
+   while (b = strchr(tmp+offset, FLAGSEP)){
+     char flag,last;
+     int  i,k;
+     if (!++b) break;
+     switch (*b){
+ 	case '1':
+ 	case '2':
+ 	case '3': flag = *b; b += 2;
+ 		  for (k = 0; b[k] && b[k] != FLAGSEP && b[k] != ','; k++);
+ 		  last = b[k];
+ 		  b[k] = '\0';
+ 		  if (flag == '2' || flag == '3'){
+ 		     *d = strchr (b, MDFLAGC(Draft))   ? T : NIL;
+ 		     *f = strchr (b, MDFLAGC(Flagged)) ? T : NIL;
+ 		     *r = strchr (b, MDFLAGC(Replied)) ? T : NIL;
+ 		     *s = strchr (b, MDFLAGC(Seen))    ? T : NIL;
+ 		     *t = strchr (b, MDFLAGC(Trashed)) ? T : NIL;
+ 		  }
+ 		  b[k] = last;
+ 		  b += k;
+ 		  for (; tmp[offset] && tmp[offset] != FLAGSEP; offset++);
+ 		  offset++;
+ 		break;
+ 	default: break;	/* Should we crash?... Nahhh */
+     }
+   }
+ }
+ 
+ int
+ maildir_message_in_list(char *msgname, struct direct **names, 
+ 		unsigned long bottom, unsigned long top, unsigned long *pos)
+ {
+   unsigned long middle = (bottom + top)/2;
+   int test;
+ 
+   if (!msgname)
+      return NIL;
+ 
+   if (pos) *pos = middle;
+ 
+   if (same_maildir_file(msgname, names[middle]->d_name))
+      return T;
+ 
+   if (middle == bottom){	 /* 0 <= 0 < 1 */
+      int rv = NIL;
+      if (same_maildir_file(msgname, names[middle]->d_name)){
+ 	rv = T;
+ 	if (pos) *pos = middle;
+      } 
+      else
+        if (same_maildir_file(msgname, names[top]->d_name)){
+ 	  rv = T;
+ 	  if (pos) *pos = top;
+        }
+      return rv;
+   }
+ 
+   test = comp_maildir_file(msgname, names[middle]->d_name);
+ 
+   if (top <= bottom)
+       return test ? NIL : T;
+ 
+   if (test < 0 ) /* bottom <  msgname < middle */
+      return maildir_message_in_list(msgname, names, bottom, middle, pos);
+   else if (test > 0)  /* middle < msgname < top */
+      return maildir_message_in_list(msgname, names, middle, top, pos);
+   else return T;
+ }
+ 
+ void
+ maildir_abort(MAILSTREAM *stream)
+ {
+   if (LOCAL){
+     if (LOCAL->dir) fs_give ((void **) &LOCAL->dir);
+     if (LOCAL->curdir) fs_give ((void **) &LOCAL->curdir);
+     if (LOCAL->buf) fs_give ((void **) &LOCAL->buf);
+     if (mdfpath) fs_give((void **)&mdfpath);
+     fs_give ((void **) &stream->local);
+     stream->dtb = NIL;
+   }
+ }
+ 
+ int
+ maildir_contains_folder(char *dirname, char *name)
+ {
+   char tmp[MAILTMPLEN+1], tmp2[MAILTMPLEN+1];
+   int rv = 0;
+   DIR *dir;
+   struct direct *d;
+   struct stat sbuf;
+   char *maildirpath = mail_parameters(NIL, GET_MDINBOX, NIL);
+ 
+   sprintf(tmp2,"%s/%s/%s", myhomedir(), dirname ? dirname : maildirpath, name);
+ 
+   if (!(dir = opendir (tmp2)))
+      return NIL;
+ 
+   while (d = readdir(dir)){
+     if (strcmp(d->d_name, ".") && strcmp(d->d_name,"..")
+ 	&& strcmp(d->d_name, MDNAME(Cur)) 
+ 	&& strcmp(d->d_name, MDNAME(Tmp)) 
+ 	&& strcmp(d->d_name, MDNAME(New))){
+ 
+        sprintf(tmp,"%s/%s", tmp2, d->d_name);
+        if (stat (tmp,&sbuf) == 0 
+ 	   && ((sbuf.st_mode & S_IFMT) == S_IFDIR || 
+ 		(S_ISREG(sbuf.st_mode) && !strcmp(d->d_name, MDDIR)))){
+ 	   rv++;
+ 	   break;
+        }
+     }
+   }
+   closedir(dir);
+   return rv;
+ }
+ 
+ int
+ maildir_dir_is_empty(char *mailbox)
+ {
+   char tmp[MAILTMPLEN+1], tmp2[MAILTMPLEN+1];
+   int rv = 1;
+   DIR *dir;
+   struct direct *d;
+   struct stat sbuf;
+   char *maildirpath = mail_parameters(NIL, GET_MDINBOX, NIL);
+ 
+   maildir_file_path(mailbox, tmp2);
+ 
+   if (!(dir = opendir (tmp2)))
+      return rv;
+ 
+   while (d = readdir(dir)){
+     sprintf(tmp,"%s/%s", tmp2, d->d_name);
+     if (strcmp(d->d_name, ".") 
+ 	&& strcmp(d->d_name,"..")
+ 	&& strcmp(d->d_name, MDNAME(Cur)) 
+ 	&& strcmp(d->d_name, MDNAME(Tmp)) 
+ 	&& strcmp(d->d_name, MDNAME(New))
+ 	&& strcmp(d->d_name, MDDIR)
+ 	&& strcmp(d->d_name, MDUIDVALIDITY)
+ 	&& !(d->d_name[0] == '.' 
+ 		&& stat (tmp,&sbuf) == 0 
+ 		&& S_ISREG(sbuf.st_mode))){
+ 	   rv = 0;
+ 	   break;
+        }
+   }
+   closedir(dir);
+   return rv;
+ }
+ 
+ void
+ maildir_get_file (MAILDIRFILE **mdfile)
+ {
+   MAILDIRFILE *md;
+ 
+   md = (MAILDIRFILE *) fs_get(sizeof(MAILDIRFILE));
+   memset(md, 0, sizeof(MAILDIRFILE));
+   *mdfile = md;
+ }
+ 
+ void
+ maildir_free_file (void **mdfile)
+ {
+   MAILDIRFILE *md = (mdfile && *mdfile) ? (MAILDIRFILE *) *mdfile : NULL;
+ 
+   if (md){
+      if (md->name) fs_give((void **)&md->name);
+      fs_give((void **)&md);
+   }
+ }
+ 
+ int
+ maildir_any_new_msgs(char *mailbox)
+ {
+   char tmp[MAILTMPLEN+1];
+   int rv = NIL;
+   DIR *dir;
+   struct direct *d;
+   struct stat sbuf;
+ 
+   MDFLD(tmp, mailbox, New);
+ 
+   if (!(dir = opendir (tmp)))
+      return rv;
+ 
+   while (d = readdir(dir)){
+     if (d->d_name[0] == '.')
+ 	continue;
+     rv = T;
+     break;
+   }
+   closedir(dir);
+   return rv;
+ }
diff -rc pine4.61/imap/src/osdep/unix/maildir.h pine4.61.I.USE/imap/src/osdep/unix/maildir.h
*** pine4.61/imap/src/osdep/unix/maildir.h	Thu Sep 23 15:32:08 2004
--- pine4.61.I.USE/imap/src/osdep/unix/maildir.h	Fri Aug  6 10:51:43 2004
***************
*** 0 ****
--- 1,136 ----
+ /* 
+  * A few definitions that try to make this module portable to other
+  * platforms (e.g. Cygwin). This module is based on the information from
+  * http://cr.yp.to/proto/maildir.html
+  */
+ 
+ /* First we deal with the separator character */
+ #ifndef FLAGSEP
+ #define FLAGSEP ':'
+ #endif
+ 
+ #define MDUIDVALIDITY	".uidvalidity"	/* support for old maildirs   */
+ #define MDDIR		".mdir"		/* this folder is a directory */
+ 
+ const char sep1[] = {FLAGSEP, '1', ',', '\0'}; /* experimental semantics*/
+ const char sep2[] = {FLAGSEP, '2', ',', '\0'}; /* Flags Information	*/
+ const char sep3[] = {FLAGSEP, '3', ',', '\0'}; /* Grrrr....		*/
+ 
+ const char *sep[] = { sep1, sep2, sep3, NULL};
+ 
+ #define MDSEP(i)  sep[((i) - 1)]
+ 
+ /* Now we deal with flags. Woohoo! */
+ typedef enum  {Draft, Flagged, Passed, Replied, Seen, Trashed, 
+ 	       EmptyFlag, EndFlags} MdFlagNamesType;
+ const int mdimapflags[] = {Draft, Flagged, Replied, Seen, Trashed, EmptyFlag, EndFlags};
+ const int mdkwdflags[]  = {Passed, EmptyFlag, EndFlags};
+ 
+ /* this array lists the codes for mdflgnms (maildir flag names) above */
+ const char *mdflags[] = { "D", "F", "P", "R", "S", "T", "", NULL};
+ /* and as characters too */
+ const char cmdflags[] = { 'D', 'F', 'P', 'R', 'S', 'T', '0', '\0'};
+ 
+ /* MDFLAG(Seen, elt->seen) */
+ #define MDFLAG(i,j) mdflags[j ? (i) : EmptyFlag]
+ /* MDFLAGC(Seen) */
+ #define MDFLAGC(i) cmdflags[(i)]
+ 
+ /* Now we deal with the directory structure */
+ typedef enum {Cur, Tmp, New, EndDir} DirNamesType;
+ char *mdstruct[] = {"cur", "tmp", "new", NULL};
+ #define MDNAME(i) mdstruct[(i)]
+ #define MDFLD(tmp, dir, i) sprintf((tmp),"%s/%s", (dir), mdstruct[(i)])
+ #define MSGPATH(tmp, dir, msg,i) sprintf((tmp),"%s/%s/%s", (dir), mdstruct[(i)],(msg))
+ 
+ /* Now we deal with messages filenames */
+ char mdlocaldomain[MAILTMPLEN+1] = {'\0'};
+ static char *mdfpath = NULL;
+ #define CHUNK	16384	/* from unix.h */
+ /* In gdb this is the  *(struct maildir_local *)stream->local structure */
+ 	
+ typedef struct maildir_local {
+   unsigned int inbox : 1;	/* if it is an INBOX or not */
+   unsigned int dirty : 1;	/* diskcopy needs updating */
+   int fd;			/* fd of open message */
+   char *dir;			/* mail directory name */
+   char *curdir;			/* mail directory name/cur */
+   unsigned char *buf;		/* temporary buffer */
+   char *hdr;			/* current header */
+   unsigned long buflen;		/* current size of temporary buffer */
+   time_t scantime;		/* last time directory scanned */
+ } MAILDIRLOCAL;
+ 
+ /* Convenient access to local data */
+ #define LOCAL ((MAILDIRLOCAL *) stream->local)
+ 
+ typedef struct maildir_file_info {
+    char *name;		/* name of the file			   */
+    unsigned long pos;	/* place in list where this file is listed */
+ } MAILDIRFILE;
+ 
+ #define MDFILE(F) (((MAILDIRFILE *)((F)->maildirp))->name)
+ #define MDPOS(F)  (((MAILDIRFILE *)((F)->maildirp))->pos)
+ 
+ /* Function prototypes */
+ 
+ DRIVER *maildir_valid (char *name);
+ MAILSTREAM *maildir_open (MAILSTREAM *stream);
+ void maildir_gc (MAILSTREAM *stream,long gcflags);
+ void maildir_close (MAILSTREAM *stream, long options);
+ long maildir_ping (MAILSTREAM *stream);
+ long maildir_ping_core (MAILSTREAM *stream);
+ void maildir_check (MAILSTREAM *stream);
+ long maildir_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags);
+ char *maildir_header (MAILSTREAM *stream,unsigned long msgno,
+ 		unsigned long *length, long flags);
+ void maildir_fast (MAILSTREAM *stream,char *sequence,long flags);
+ void maildir_list (MAILSTREAM *stream,char *ref,char *pat);
+ void *maildir_parameters (long function,void *value);
+ long maildir_create (MAILSTREAM *stream,char *mailbox);
+ void maildir_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt); /*check */
+ void maildir_expunge (MAILSTREAM *stream);
+ long maildir_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options);
+ long maildir_append (MAILSTREAM *stream,char *mailbox, append_t af, void *data);
+ long maildir_delete (MAILSTREAM *stream,char *mailbox);
+ long maildir_rename (MAILSTREAM *stream,char *old,char *new);
+ long maildir_sub (MAILSTREAM *stream,char *mailbox);
+ long maildir_unsub (MAILSTREAM *stream,char *mailbox);
+ void maildir_lsub (MAILSTREAM *stream,char *ref,char *pat);
+ 
+ /* utility functions */
+ char *maildir_file (char *dst,char *name);
+ int maildir_select (struct direct *name);
+ int maildir_namesort (const void *d1, const void *d2);
+ void maildir_listwork(char *name, MAILSTREAM *stream, char *s2, char *subdir, int flag);
+ long maildir_canonicalize (char *pattern,char *ref,char *pat);
+ void maildir_list_work (MAILSTREAM *stream,char *subdir,char *pat,long level);
+ int maildir_file_path(char *name, char *tmp);
+ int maildir_valid_name (char *name);
+ int maildir_valid_dir (char *name);
+ int maildir_base_name (char *name, char *tmp);
+ int maildir_message_exists(MAILSTREAM *stream,char *name, char *tmp);
+ void maildir_remove_root(char **name);
+ char *maildir_text_work (MAILSTREAM *stream,MESSAGECACHE *elt, unsigned long *length,long flags);
+ unsigned long  maildir_parse_message(MAILSTREAM *stream, unsigned long msgno, 
+ 						DirNamesType dirtype);
+ unsigned long maildir_scandir (char *name, struct direct ***flist, 
+ 					unsigned long *nfiles, int *scand);
+ void maildir_parse_folder (MAILSTREAM *stream, int full);
+ void  md_domain_name (void);
+ unsigned long  maildir_parse_dir(MAILSTREAM *stream, unsigned long nmsgs, 
+ 						DirNamesType dirtype, int full);
+ int same_maildir_file(char *name1, char *name2);
+ int comp_maildir_file(char *name1, char *name2);
+ int maildir_message_in_list(char *msgname, struct direct **names,
+ 		unsigned long bottom, unsigned long top, unsigned long *pos);
+ void maildir_getflag(char *name, int *d, int *f, int *r ,int *s, int *t);
+ int maildir_update_elt_maildirp(MAILSTREAM *stream, unsigned long msgno);
+ void maildir_abort (MAILSTREAM *stream);
+ int maildir_contains_folder(char *dirname, char *name);
+ int maildir_dir_is_empty(char *mailbox);
+ long maildir_create_work (char *mailbox);
+ void maildir_get_file (MAILDIRFILE **mdfile);
+ void maildir_free_file (void **mdfile);
+ int maildir_any_new_msgs(char *mailbox);
+ 
diff -rc pine4.61/imap/src/osdep/unix/os_cyg.h pine4.61.I.USE/imap/src/osdep/unix/os_cyg.h
*** pine4.61/imap/src/osdep/unix/os_cyg.h	Mon Apr 19 08:23:48 2004
--- pine4.61.I.USE/imap/src/osdep/unix/os_cyg.h	Fri Jul 16 11:50:23 2004
***************
*** 39,44 ****
--- 39,45 ----
  #define setpgrp setpgid
  
  #define SYSTEMUID 18		/* Cygwin returns this for SYSTEM */
+ #define FLAGSEP ';'
  #define geteuid Geteuid
  uid_t Geteuid (void);
  
diff -rc pine4.61/pico/basic.c pine4.61.I.USE/pico/basic.c
*** pine4.61/pico/basic.c	Fri May  7 14:36:44 2004
--- pine4.61.I.USE/pico/basic.c	Fri Aug 20 14:22:37 2004
***************
*** 267,273 ****
  int f, n;	/* default Flag & Numeric argument */
  {
      int quoted, qlen;
!     char qstr[NLINE], qstr2[NLINE];
  
      if (n < 0)	/* the other way...*/
        return(gotoeop(f, -n));
--- 267,273 ----
  int f, n;	/* default Flag & Numeric argument */
  {
      int quoted, qlen;
!     char qstr[NLINE], qstr2[NLINE], ind_str[NLINE];
  
      if (n < 0)	/* the other way...*/
        return(gotoeop(f, -n));
***************
*** 279,284 ****
--- 279,295 ----
  	    curwp->w_dotp = lback(curwp->w_dotp);
  	    curwp->w_doto = 0;
  	}
+ 
+ 	if (indent_match((glo_quote_str || (Pmaster && Pmaster->quote_str))
+ 			? (glo_quote_str ? glo_quote_str : Pmaster->quote_str)
+ 			: "",
+ 			  curwp->w_dotp,ind_str, NLINE, 0)){
+ 	   if (n){ /* look for another paragraph ? */
+ 	      curwp->w_dotp = lback(curwp->w_dotp);
+ 	      continue;
+ 	   }
+ 	   break;
+ 	}
  	
  	/* scan line by line until we come to a line ending with
  	 * a <NL><NL> or <NL><TAB> or <NL><SPACE>
***************
*** 288,294 ****
  	 */
  	quoted = (glo_quote_str || (Pmaster && Pmaster->quote_str))
  	  ? quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str,
! 			curwp->w_dotp, qstr, NLINE) : 0;
  	qlen   = quoted ? strlen(qstr) : 0;
  	while(lback(curwp->w_dotp) != curbp->b_linep
  	      && llength(lback(curwp->w_dotp)) > qlen
--- 299,305 ----
  	 */
  	quoted = (glo_quote_str || (Pmaster && Pmaster->quote_str))
  	  ? quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str,
! 			curwp->w_dotp, qstr, NLINE, 0) : 0;
  	qlen   = quoted ? strlen(qstr) : 0;
  	while(lback(curwp->w_dotp) != curbp->b_linep
  	      && llength(lback(curwp->w_dotp)) > qlen
***************
*** 296,308 ****
  		  ? (quoted == quote_match(glo_quote_str ? glo_quote_str
  					   : Pmaster->quote_str, 
  					   lback(curwp->w_dotp),
! 					   qstr2, NLINE)
  		     && !strcmp(qstr, qstr2))
  		  : 1)
  	      && lgetc(curwp->w_dotp, qlen).c != TAB
  	      && lgetc(curwp->w_dotp, qlen).c != ' ')
  	  curwp->w_dotp = lback(curwp->w_dotp);
  
  	if(n){
  	    /* keep looking */
  	    if(lback(curwp->w_dotp) == curbp->b_linep)
--- 307,361 ----
  		  ? (quoted == quote_match(glo_quote_str ? glo_quote_str
  					   : Pmaster->quote_str, 
  					   lback(curwp->w_dotp),
! 					   qstr2, NLINE, 0)
  		     && !strcmp(qstr, qstr2))
  		  : 1)
+ 	      && !indent_match((glo_quote_str 
+ 					|| (Pmaster && Pmaster->quote_str))
+ 			? (glo_quote_str ? glo_quote_str : Pmaster->quote_str)
+ 			: "",
+ 			  lback(curwp->w_dotp),ind_str, NLINE, 0)
  	      && lgetc(curwp->w_dotp, qlen).c != TAB
  	      && lgetc(curwp->w_dotp, qlen).c != ' ')
  	  curwp->w_dotp = lback(curwp->w_dotp);
  
+        /*
+         * Ok, we made it here and we assume that we are at the begining
+         * of the paragraph. Let's double check this now. In order to do
+         * so we shell check if the first line was indented in a special
+         * way.
+         */
+        if(lback(curwp->w_dotp) == curbp->b_linep)
+              break;
+        else{
+            int indented, i, j;
+ 
+            /*
+             * for the following test we need to have the raw values,
+             * not the processed values
+             */
+ 	   if (glo_quote_str || (Pmaster && Pmaster->quote_str)){
+               quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str, 
+ 			curwp->w_dotp, qstr, NLINE, 1);
+               quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str, 
+ 			lback(curwp->w_dotp), qstr2, NLINE, 1);
+ 	   }
+ 	   else
+ 	      qstr[0] = qstr2[0] = '\0';
+            indented = indent_match((glo_quote_str || (Pmaster && Pmaster->quote_str))
+ 			? (glo_quote_str ? glo_quote_str :  Pmaster->quote_str)
+ 			: "",
+ 			  lback(curwp->w_dotp),
+                           ind_str, NLINE, 1);
+            if (strlenis(qstr2) + strlenis(ind_str) < strlenis(qstr))
+                indented = 0; /* Hack, so that it won't return one more line */
+            for (i= 0,j=0; qstr[i] && qstr2[i] && (qstr[i] == qstr2[i]);i++,j++);
+            for (; isspace(qstr2[i]); i++);
+            for (; isspace(qstr[j]); j++);
+            if (!qstr2[i] && !qstr[j] && indented)
+                curwp->w_dotp = lback(curwp->w_dotp);
+        }
+ 
  	if(n){
  	    /* keep looking */
  	    if(lback(curwp->w_dotp) == curbp->b_linep)
***************
*** 329,346 ****
      return(TRUE);
  }
  
! 
  /* 
!  * go forword to the end of the current paragraph
   * here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>
   * combination to delimit the begining of a paragraph
   */
  gotoeop(f, n)
  int f, n;	/* default Flag & Numeric argument */
- 
  {
!     int quoted, qlen;
!     char qstr[NLINE], qstr2[NLINE];
  
      if (n < 0)	/* the other way...*/
        return(gotobop(f, -n));
--- 382,581 ----
      return(TRUE);
  }
  
! GetAccent()
! {
!   char c,d;
!     c = (char) GetKey();
!     if ((c == '?') || (c == '!')) {
!         d = c;
!         c = '\\';
!     }
!     else
!       if ((c == 's') || (c == 'S')){
! 	 c =  d = 's';
!       }
!       else 
! 	if ((c == 'l') || (c == 'L')){
! 	   c =  d = 'l';
! 	}
! 	else
!           d = (char) GetKey();
! 	return (int) accent(c,d);
! }
! 
! pineaccent(f,n)
! int f,n;
! { int e;
!    
!        if (e = GetAccent())
!          execute(e,0,1);
!        return 1;
! }
! 
! unsigned char accent(f,n)
! int f,n;
! {  char c,d;
! 
!          c = (char) f;
!        d = (char) n;
!        switch(c){
!         case '~' :  
!                    switch(d){
!                                case 'a' : return '\343';
!                                case 'n' : return '\361';
!                                case 'o' : return '\365';
!                                case 'A' : return '\303';
!                                case 'N' : return '\321';
!                                case 'O' : return '\325';
!                             }
!                        break;
!         case '\047' :
!                        switch(d){
!                                case 'a' : return '\341';
!                                case 'e' : return '\351';
!                                case 'i' : return '\355';
!                                case 'o' : return '\363';
!                                case 'u' : return '\372';
!                                case 'y' : return '\375';
!                                case 'A' : return '\301';
!                                case 'E' : return '\311';
!                                case 'I' : return '\315';
!                                case 'O' : return '\323';
!                                case 'U' : return '\332';
!                                case 'Y' : return '\335';
!                                     }
!                        break;
!         case '"' :
!                        switch(d){
!                                case 'a' : return '\344';
!                                case 'e' : return '\353';
!                                case 'i' : return '\357';
!                                case 'o' : return '\366';
!                                case 'u' : return '\374';
!                                case 'y' : return '\377';
!                                case 'A' : return '\304';
!                                case 'E' : return '\313';
!                                case 'I' : return '\317';
!                                case 'O' : return '\326';
!                                case 'U' : return '\334';
!                                     }
!                        break;
!         case '^' :
!                        switch(d){
!                                case 'a' : return '\342';
!                                case 'e' : return '\352';
!                                case 'i' : return '\356';
!                                case 'o' : return '\364';
!                                case 'u' : return '\373';
!                                case 'A' : return '\302';
!                                case 'E' : return '\312';
!                                case 'I' : return '\316';
!                                case 'O' : return '\324';
!                                case 'U' : return '\333';
! 			       case '0' : return '\260';
! 			       case '1' : return '\271';
! 			       case '2' : return '\262';
! 			       case '3' : return '\263';
!                                     }
!                        break;
!         case '`' :
!                        switch(d){
!                                case 'a' : return '\340';
!                                case 'e' : return '\350';
!                                case 'i' : return '\354';
!                                case 'o' : return '\362';
!                                case 'u' : return '\371';
!                                case 'A' : return '\300';
!                                case 'E' : return '\310';
!                                case 'I' : return '\314';
!                                case 'O' : return '\322';
!                                case 'U' : return '\331';
!                                     }
!                        break;
!         case 'o' :
!                        switch(d){
!                                case 'a' : return '\345';
!                                case 'A' : return '\305';
! 			       case '/' : return '\370';
! 			       case 'r' : return '\256';
! 			       case 'R' : return '\256';
! 			       case 'c' : return '\251';
! 			       case 'C' : return '\251';
! 				}
!                        break;
! 	case '-' :
! 		       switch(d){
! 			       case 'o' : return '\272';
! 			       case 'O' : return '\272';
! 			       case '0' : return '\272';
! 			       case 'a' : return '\252';
! 			       case 'A' : return '\252';
! 			       case 'l' : return '\243';
! 			       case 'L' : return '\243';
! 				}
! 		       break;
! 	case 'O' :
! 		       switch(d){
! 			       case '/' : return '\330';
! 			       case 'r' : return '\256';
! 			       case 'R' : return '\256';
! 			       case 'c' : return '\251';
! 			       case 'C' : return '\251';
! 				}
!         case '/' :
!                        switch(d){
!                                case 'o' : return '\370';
!                                case 'O' : return '\330';
! 				}
!                        break;
!         case 'a' :
!                        switch(d){
!                                case 'e' : return '\346';
!                                case 'E' : return '\346';
! 				}
!                        break;
!         case 'A' :
!                        switch(d){
!                                case 'E' : return '\306';
!                                case 'e' : return '\306';
! 				}
!                        break;
!         case ',' :
!                        switch(d){
!                                case 'c' : return '\347';
!                                case 'C' : return '\307';
!                                     }
!                        break;
!         case '\\' :
!                        switch(d){
!                                case '?' : return '\277';
!                                case '!' : return '\241';
!                                     }
!                        break;
!        case 's' :
!                         switch(d){
!                                 case 's' : return '\337';
!                                      }
! 			break;
!        case 'l' :
!                         switch(d){
!                                 case 'l' : return '\243';
!                                  }
! 			break;
!        }
!        return '\0';
!  }
!                                
  /* 
!  * go forward to the end of the current paragraph
   * here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>
   * combination to delimit the begining of a paragraph
   */
  gotoeop(f, n)
  int f, n;	/* default Flag & Numeric argument */
  {
!     int quoted, qlen, indented;
!     char qstr[NLINE], qstr2[NLINE], ind_str[NLINE];
  
      if (n < 0)	/* the other way...*/
        return(gotobop(f, -n));
***************
*** 353,358 ****
--- 588,645 ----
  	      break;
  	}
  
+         /* 
+ 	 * We need to figure out if this line is the first line of
+ 	 * a paragraph that has been indented in a special way. If this
+ 	 * is the case, we advance one more line before we use the
+ 	 * algorithm below
+ 	 */
+ 
+          if(curwp->w_dotp != curbp->b_linep){
+ 	    int i,j;
+ 
+ 	    if (glo_quote_str || (Pmaster && Pmaster->quote_str)){
+ 	       quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str,
+ 					curwp->w_dotp, qstr, NLINE, 1);
+ 	       quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str, 
+ 					lforw(curwp->w_dotp), qstr2, NLINE, 1);
+ 	    }
+ 	    else
+ 		qstr[0] = qstr2[0] = '\0';
+ 	    indented = indent_match((glo_quote_str || (Pmaster && Pmaster->quote_str))
+ 					? (glo_quote_str ? glo_quote_str 
+ 					: Pmaster->quote_str) : "", curwp->w_dotp,
+ 					  ind_str, NLINE, 1);
+ 	    if (strlenis(qstr) + strlenis(ind_str) < strlenis(qstr2)){
+ 		curwp->w_doto = 0;
+ 		if(n){    /* this line is a paragraph by itself */
+ 	      	   curwp->w_dotp = lforw(curwp->w_dotp);
+ 		   continue;
+ 		}
+ 		break;
+ 	    }
+ 	    for (i=0,j=0; qstr[i] && qstr2[i] && (qstr[i] == qstr2[i]);i++,j++);
+ 	    for (; isspace(qstr[i]); i++);
+ 	    for (; isspace(qstr2[j]); j++);
+ 	    if (!qstr[i] && !qstr2[j] && indented){
+ 		if (indent_match((glo_quote_str 
+ 					|| (Pmaster && Pmaster->quote_str)) 
+ 					? (glo_quote_str ? glo_quote_str 
+ 					       : Pmaster->quote_str) : "", 
+ 						 lforw(curwp->w_dotp), 
+ 						 ind_str, NLINE, 0)){
+ 		   if (n){ /* look for another paragraph ? */
+ 	      	      curwp->w_dotp = lforw(curwp->w_dotp);
+ 		      continue;
+ 		   }
+ 		}
+ 		else{
+ 		  if (!lisblank(lforw(curwp->w_dotp)))
+ 		     curwp->w_dotp = lforw(curwp->w_dotp);
+ 		}
+ 	    }
+          }
+ 
  	/* scan line by line until we come to a line ending with
  	 * a <NL><NL> or <NL><TAB> or <NL><SPACE>
  	 *
***************
*** 361,367 ****
  	 */
  	quoted = ((glo_quote_str || (Pmaster && Pmaster->quote_str))
  	  ? quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str,
! 			curwp->w_dotp, qstr, NLINE) : 0);
  	qlen   = quoted ? strlen(qstr) : 0;
  	
  	while(curwp->w_dotp != curbp->b_linep
--- 648,654 ----
  	 */
  	quoted = ((glo_quote_str || (Pmaster && Pmaster->quote_str))
  	  ? quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str,
! 			curwp->w_dotp, qstr, NLINE, 0) : 0);
  	qlen   = quoted ? strlen(qstr) : 0;
  	
  	while(curwp->w_dotp != curbp->b_linep
***************
*** 370,378 ****
  		  ? (quoted == quote_match(glo_quote_str ? glo_quote_str
  					   : Pmaster->quote_str,
  					   lforw(curwp->w_dotp),
! 					   qstr2, NLINE)
  		     && !strcmp(qstr, qstr2))
  		  : 1)
  	      && lgetc(lforw(curwp->w_dotp), qlen).c != TAB
  	      && lgetc(lforw(curwp->w_dotp), qlen).c != ' ')
  	  curwp->w_dotp = lforw(curwp->w_dotp);
--- 657,671 ----
  		  ? (quoted == quote_match(glo_quote_str ? glo_quote_str
  					   : Pmaster->quote_str,
  					   lforw(curwp->w_dotp),
! 					   qstr2, NLINE, 0)
  		     && !strcmp(qstr, qstr2))
  		  : 1)
+ 	      && !indent_match((glo_quote_str 
+ 					|| (Pmaster && Pmaster->quote_str)) 
+ 				? (glo_quote_str ? glo_quote_str
+ 					  : Pmaster->quote_str) : "", 
+ 					  lforw(curwp->w_dotp),
+ 					  ind_str, NLINE, 0)
  	      && lgetc(lforw(curwp->w_dotp), qlen).c != TAB
  	      && lgetc(lforw(curwp->w_dotp), qlen).c != ' ')
  	  curwp->w_dotp = lforw(curwp->w_dotp);
***************
*** 653,659 ****
--- 946,992 ----
      return (scrollback (n, TRUE));
  }
  
+ /* deltext deletes from the specified position until the end of the file
+  * or until the signature (when called from Pine), whichever comes first.
+  */
  
+ int
+ deltext (f,n)
+ int f,n;
+ {               
+   LINE *currline = curwp->w_dotp;
+ 
+   if ((lastflag&CFKILL) == 0)
+      kdelete();
+   
+   curwp->w_markp = curwp->w_dotp;
+   curwp->w_marko = curwp->w_doto;
+   
+   while (curwp->w_dotp != curbp->b_linep){
+      if ((Pmaster) 
+     	&& (llength(curwp->w_dotp) == 3) 
+ 	&& (lgetc(curwp->w_dotp, 0).c == '-') 
+ 	&& (lgetc(curwp->w_dotp, 1).c == '-') 
+ 	&& (lgetc(curwp->w_dotp, 2).c == ' ')){
+ 	  if (curwp->w_dotp == currline){
+ 	     if (curwp->w_doto)
+ 		curwp->w_dotp = lforw(curwp->w_dotp);
+ 	     else
+ 	   	break;
+      	  }
+      	  else{
+ 	     curwp->w_dotp = lback(curwp->w_dotp);
+ 	     curwp->w_doto = llength(curwp->w_dotp);
+ 	     break;
+           }
+      }
+      else
+ 	curwp->w_dotp = lforw(curwp->w_dotp);
+   }         
+   killregion(FALSE,1);
+   lastflag |= CFKILL;
+   return TRUE;
+ }
  
  scrollupline (f, n)
  int f, n;
diff -rc pine4.61/pico/composer.c pine4.61.I.USE/pico/composer.c
*** pine4.61/pico/composer.c	Tue Jun 15 15:22:57 2004
--- pine4.61.I.USE/pico/composer.c	Fri Jul 16 12:04:43 2004
***************
*** 1681,1687 ****
          }
  
  	if(VALID_KEY(ch)){			/* char input */
!             /*
               * if we are allowing editing, insert the new char
               * end up leaving tbufp pointing to newly
               * inserted character in string, and offset to the
--- 1681,1687 ----
          }
  
  	if(VALID_KEY(ch)){			/* char input */
! insert_char:/*
               * if we are allowing editing, insert the new char
               * end up leaving tbufp pointing to newly
               * inserted character in string, and offset to the
***************
*** 1765,1770 ****
--- 1765,1777 ----
          }
          else {					/* interpret ch as a command */
              switch (ch = normalize_cmd(ch, ckm, 2)) {
+ 	      case (CTRL|'\\') :
+ 		if (ch = GetAccent())
+ 		  goto insert_char;
+ 		else
+ 		  clearcursor();
+ 	      break;
+ 
  	      case (CTRL|'@') :		/* word skip */
  		while(strng[ods.p_off]
  		      && isalnum((unsigned char)strng[ods.p_off]))
***************
*** 2945,2950 ****
--- 2952,2960 ----
  {
      register char    *bufp;
  
+     if (sendnow)
+ 	return;
+ 
      if(ComposerTopLine - 1 >= BOTTOM())		/* silently forget it */
        return;
  
***************
*** 2994,2999 ****
--- 3004,3012 ----
      register char   *bufp;
      register int    i;
  
+     if (sendnow)
+       return(TRUE);
+ 
      bufp = headents[entry].prompt;		/* fresh prompt paint */
      if((i = entry_line(entry, FALSE)) == -1)
        return(-1);				/* silently forget it */
***************
*** 3911,3916 ****
--- 3924,3932 ----
  void
  ShowPrompt()
  {
+     if (sendnow)
+ 	return;
+ 
      if(headents[ods.cur_e].key_label){
  	menu_header[TO_KEY].name  = "^T";
  	menu_header[TO_KEY].label = headents[ods.cur_e].key_label;
diff -rc pine4.61/pico/display.c pine4.61.I.USE/pico/display.c
*** pine4.61/pico/display.c	Fri May  7 14:38:24 2004
--- pine4.61.I.USE/pico/display.c	Fri Jul 16 12:05:27 2004
***************
*** 362,367 ****
--- 362,370 ----
      register int     scroll = 0;
      CELL	     c;
  
+     if (sendnow)
+ 	return;
+ 
  #if	TYPEAH
      if (typahead())
  	return;
***************
*** 1460,1465 ****
--- 1463,1481 ----
  		b++;
  	    continue;
  
+ 	  case (CTRL|'N'):			/* Insert pattern */
+ 	   if (pat[0] != '\0'){
+ 		strcat(buf,pat);
+ 		pputs(pat,1);
+ 		b += strlen(pat);
+ 		changed = TRUE;
+ 		}
+ 	   else
+ 		(*term.t_beep)();
+ 	  continue;
+ 
+ 
+ 
  	  case (CTRL|'G') :			/* CTRL-G help		*/
  	    if(term.t_mrow == 0 && km_popped == 0){
  		movecursor(term.t_nrow-2, 0);
***************
*** 1515,1520 ****
--- 1531,1541 ----
  	      b--;
  	    continue;
  
+          case (CTRL|'\\'):
+ 	    if (c = GetAccent())
+ 	      goto text;
+          continue;
+ 
  	  case KEY_RIGHT:
  	    if(*b != '\0')
  	      b++;
***************
*** 1566,1571 ****
--- 1587,1593 ----
  #endif
  
  	  default : 
+ text:
  	    if(strlen(buf) >= maxl){		/* contain the text      */
  		(*term.t_beep)();
  		continue;
diff -rc pine4.61/pico/ebind.h pine4.61.I.USE/pico/ebind.h
*** pine4.61/pico/ebind.h	Fri May  7 14:38:24 2004
--- pine4.61.I.USE/pico/ebind.h	Fri Jul 16 12:04:43 2004
***************
*** 105,111 ****
  	{CTRL|'^',		setmark},
  	{CTRL|'_',		alt_editor},
  	{0x7F,			backdel},
! 	{0,			NULL}
  };
  
  
--- 105,113 ----
  	{CTRL|'^',		setmark},
  	{CTRL|'_',		alt_editor},
  	{0x7F,			backdel},
!         {CTRL|'\\',             pineaccent},
! 	{0,
! NULL}
  };
  
  
diff -rc pine4.61/pico/edef.h pine4.61.I.USE/pico/edef.h
*** pine4.61/pico/edef.h	Fri Mar 26 14:36:12 2004
--- pine4.61.I.USE/pico/edef.h	Fri Jul 16 11:56:02 2004
***************
*** 43,48 ****
--- 43,49 ----
  
  /* initialized global definitions */
  
+ int	sendnow = 0;			/* should we send now		*/
  int     fillcol = 72;                   /* Current fill column          */
  int     userfillcol = -1;               /* Fillcol set from cmd line    */
  char    pat[NPAT];                      /* Search pattern		*/
***************
*** 95,100 ****
--- 96,102 ----
  
  /* initialized global external declarations */
  
+ extern	int	sendnow;		/* should we send now		*/
  extern  int     fillcol;                /* Fill column                  */
  extern  int     userfillcol;            /* Fillcol set from cmd line    */
  extern  char    pat[];                  /* Search pattern               */
diff -rc pine4.61/pico/efunc.h pine4.61.I.USE/pico/efunc.h
*** pine4.61/pico/efunc.h	Tue Jun 15 15:22:58 2004
--- pine4.61.I.USE/pico/efunc.h	Fri Jul 16 12:07:01 2004
***************
*** 65,70 ****
--- 65,71 ----
  extern	int gotoeop PROTO((int, int));
  extern	int forwpage PROTO((int, int));
  extern	int backpage PROTO((int, int));
+ extern	int deltext PROTO((int, int));
  extern  int scrollupline PROTO((int, int));
  extern  int scrolldownline PROTO((int, int));
  extern  int scrollto PROTO((int, int));
***************
*** 73,78 ****
--- 74,82 ----
  extern	int setimark PROTO((int, int));
  extern	int swapimark PROTO((int, int));
  extern	int mousepress PROTO((int, int));
+ extern  unsigned char accent PROTO((int, int));
+ extern  int pineaccent PROTO((int, int));
+ extern  int GetAccent PROTO((void));
  
  /* bind.c */
  extern	int whelp PROTO((int, int));
***************
*** 337,342 ****
  extern	int fillpara PROTO((int, int));
  extern	int fillbuf PROTO((int, int));
  extern	int inword PROTO((void));
! extern	int quote_match PROTO((char *, LINE *, char *, int));
  
  #endif	/* EFUNC_H */
--- 341,350 ----
  extern	int fillpara PROTO((int, int));
  extern	int fillbuf PROTO((int, int));
  extern	int inword PROTO((void));
! extern	int quote_match PROTO((char *, LINE *, char *, int, int));
! extern  void flatten_qstring PROTO((QSTRING_S *, char *));
! extern  void free_qs PROTO((QSTRING_S **));
! extern  QSTRING_S *do_quote_match PROTO((char *, char *, char *, char *, int));
! extern  QSTRING_S *copy_qs PROTO((QSTRING_S *));
  
  #endif	/* EFUNC_H */
diff -rc pine4.61/pico/line.c pine4.61.I.USE/pico/line.c
*** pine4.61/pico/line.c	Fri May  7 14:41:16 2004
--- pine4.61.I.USE/pico/line.c	Fri Jul 16 12:04:32 2004
***************
*** 635,641 ****
  
      n = ((glo_quote_str || (Pmaster && Pmaster->quote_str))
  	 && quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str,
! 			line, qstr, NLINE))
  	  ? strlen(qstr) : 0;
  
      for(; n < llength(line); n++)
--- 635,641 ----
  
      n = ((glo_quote_str || (Pmaster && Pmaster->quote_str))
  	 && quote_match(glo_quote_str ? glo_quote_str : Pmaster->quote_str,
! 			line, qstr, NLINE, 1))
  	  ? strlen(qstr) : 0;
  
      for(; n < llength(line); n++)
diff -rc pine4.61/pico/main.c pine4.61.I.USE/pico/main.c
*** pine4.61/pico/main.c	Fri May  7 14:41:16 2004
--- pine4.61.I.USE/pico/main.c	Fri Jul 16 12:05:13 2004
***************
*** 149,154 ****
--- 149,155 ----
      int      setlocale_ctype = 0;
      char     bname[NBUFN];		/* buffer name of file to read	*/
      char    *file_to_edit = NULL;
+     int line_information_on = FALSE;
  
      timeo = 600;
      Pmaster = NULL;     		/* turn OFF composer functionality */
***************
*** 306,311 ****
--- 307,318 ----
  	      emlwrite("You may possibly have new mail.", NULL);
  	}
  
+          if (c == (CTRL|'\\')){
+            c = GetAccent();
+ 	   if (!c)
+ 	     c = NODATA;
+ 	 }
+ 
  	if(km_popped)
  	  switch(c){
  	    case NODATA:
***************
*** 327,340 ****
  	      mlerase();
  	}
  
! 	f = FALSE;
  	n = 1;
  
  #ifdef	MOUSE
  	clear_mfunc(mouse_in_content);
  #endif
  					/* Do it.               */
  	execute(normalize_cmd(c, fkm, 1), f, n);
      }
  }
  
--- 334,363 ----
  	      mlerase();
  	}
  
! 	f = (c == (CTRL|'J'));
  	n = 1;
+ 	if (!line_information_on)
+ 	   line_information_on = (c == (CTRL|'C'));
+ 	else
+ 	   line_information_on = ((c == KEY_DOWN) || (c == KEY_UP) || 
+ 				  (c == KEY_RIGHT) || (c == KEY_LEFT) || 
+ 			          (c == (CTRL|'V')) || (c == (CTRL|'Y')) ||
+ 			          (c == (CTRL|'K')) || (c == (CTRL|'D')) ||
+ 			          (c == (CTRL|'F')) || (c == (CTRL|'B')) ||
+ 			          (c == (CTRL|'N')) || (c == (CTRL|'P')) ||
+ 			          (c == (CTRL|'A')) || (c == (CTRL|'E')) ||
+ 			          (c == (CTRL|'U')) || (c == (CTRL|'^'))) 
+ 				&& (c != (CTRL|'C'));
  
  #ifdef	MOUSE
  	clear_mfunc(mouse_in_content);
  #endif
  					/* Do it.               */
  	execute(normalize_cmd(c, fkm, 1), f, n);
+ 	if (line_information_on){
+ 	   c = (CTRL|'C');
+ 	   execute(normalize_cmd(c, fkm, 1), f, n);
+ 	}
      }
  }
  
diff -rc pine4.61/pico/osdep/term.cap pine4.61.I.USE/pico/osdep/term.cap
*** pine4.61/pico/osdep/term.cap	Wed Jun  4 23:55:18 2003
--- pine4.61.I.USE/pico/osdep/term.cap	Fri Jul 16 11:56:03 2004
***************
*** 431,436 ****
--- 431,442 ----
  {
      int     row, col;
  
+     if (sendnow){
+ 	term.t_nrow = 23;
+ 	term.t_ncol = 80;
+ 	return 0;
+     }
+ 
      /*
       * determine the terminal's communication speed and decide
       * if we need to do optimization ...
diff -rc pine4.61/pico/osdep/unix pine4.61.I.USE/pico/osdep/unix
*** pine4.61/pico/osdep/unix	Wed May  5 15:01:13 2004
--- pine4.61.I.USE/pico/osdep/unix	Fri Jul 16 11:56:03 2004
***************
*** 364,369 ****
--- 364,385 ----
  {
      int    ch, status, cc;
  
+     switch (sendnow){
+ 	case 1 : sendnow++;
+ 		 ch = CTRL|'X';
+ 		 break;
+ 
+ 	case 2 : sendnow++;
+ 		 ch = (unsigned char) 'y';
+ 		 break;
+ 
+ 	default: ch = NODATA;
+ 		 break;
+     }
+ 
+     if (sendnow)
+ 	return ch;
+ 
      if(!ReadyForKey(FUDGE-5))
        return(NODATA);
  
diff -rc pine4.61/pico/pico.c pine4.61.I.USE/pico/pico.c
*** pine4.61/pico/pico.c	Mon Jul 12 15:17:06 2004
--- pine4.61.I.USE/pico/pico.c	Fri Jul 16 11:56:03 2004
***************
*** 137,142 ****
--- 137,151 ----
      pico_all_done = 0;
      km_popped     = 0;
  
+     if (pm->auto_cmds){
+        int i;
+ #define CTRL_X 24
+       for (i = 0;  pm->auto_cmds[i]; i++);
+       if ((i > 1) && (pm->auto_cmds[i - 2] == CTRL_X) && 
+ 		((pm->auto_cmds[i - 1] == 'y') || (pm->auto_cmds[i-1] == 'Y')))
+       sendnow++;
+     }
+ 
      if(!vtinit())			/* Init Displays.      */
        return(COMP_CANCEL);
  
***************
*** 686,691 ****
--- 695,711 ----
  	    return(FALSE);
  	}
  
+  	/* When we send a message using the command line we are going to
+  	   ignore if the user wants to spell check, we assume she already
+  	   did */
+  	if (sendnow){
+  	    result = (*Pmaster->exittest)(Pmaster->headents,
+  			redraw_pico_for_callback, Pmaster->allow_flowed_text);
+  	    if (!result)
+  		pico_all_done = COMP_EXIT;
+  	    return(result ? FALSE : TRUE);
+  	}
+ 
  #ifdef	SPELLER
  	if(Pmaster->always_spell_check)
  	  if(spell(0, 0) == -1)
diff -rc pine4.61/pico/pico.h pine4.61.I.USE/pico/pico.h
*** pine4.61/pico/pico.h	Fri Jul  9 13:31:54 2004
--- pine4.61.I.USE/pico/pico.h	Fri Jul 16 12:04:32 2004
***************
*** 219,224 ****
--- 219,225 ----
      void  (*resize)();			/* callback handling screen resize */
      void  (*winch_cleanup)();		/* callback handling screen resize */
      int    arm_winch_cleanup;		/* do the winch_cleanup if resized */
+     int   *auto_cmds;			/* Initial keystroke commands */
      HELP_T search_help;
      HELP_T ins_help;
      HELP_T ins_m_help;
***************
*** 342,347 ****
--- 343,364 ----
  	struct	KBSTREE	*left;
  } KBESC_T;
  
+ /* 
+  * struct that will help us determine what the quote string of a line
+  * is. The "next" field indicates the presence of a possible continuation.
+  * The idea is that if a continuation fails, we free it and check for the
+  * remaining structure left
+  */
+ 
+ typedef enum {qsNormal, qsString, qsWord, qsChar} QStrType;
+ 
+ typedef struct QSTRING {
+ 	char		*value;			/* possible quote string */
+ 	QStrType 	 qstype;		/* type of quote string	 */
+ 	struct QSTRING	*next;			/* possible continuation */
+ } QSTRING_S;
+ 
+ 
  /*
   * Protos for functions used to manage keyboard escape sequences
   * NOTE: these may ot actually get defined under some OS's (ie, DOS, WIN)
diff -rc pine4.61/pico/random.c pine4.61.I.USE/pico/random.c
*** pine4.61/pico/random.c	Fri May  7 14:43:48 2004
--- pine4.61.I.USE/pico/random.c	Fri Jul 16 12:04:32 2004
***************
*** 364,370 ****
  	else{
  	    backchar(FALSE, 1);
  	    dotp = curwp->w_dotp;
! 	    gotobop(FALSE, 1);		/* then go to the top of the para */
  	}
  
  	curwp->w_doto = 0;
--- 364,371 ----
  	else{
  	    backchar(FALSE, 1);
  	    dotp = curwp->w_dotp;
! 	    swapimark(FALSE, 1); /* go back to the spot we marked before justify */
!        /* We assume that no imarks have been set between fillpara and now */
  	}
  
  	curwp->w_doto = 0;
diff -rc pine4.61/pico/search.c pine4.61.I.USE/pico/search.c
*** pine4.61/pico/search.c	Thu Jul  1 14:36:36 2004
--- pine4.61.I.USE/pico/search.c	Tue Aug 24 22:51:13 2004
***************
*** 78,83 ****
--- 78,87 ----
  "\tbrackets.  This string is the default search prompt.",
  "~        Hitting only ~R~e~t~u~r~n or at the prompt will cause the",
  "\tsearch to be made with the default value.",
+ " ",
+ "~        Hitting ~^~N will reinsert the last string you searched for",
+ "\tso that you can edit it (in case you made a mistake entering the",
+ "\tsearch pattern the first time).",
  "  ",
  "\tThe text search is not case sensitive, and will examine the",
  "\tentire message.",
***************
*** 239,244 ****
--- 243,253 ----
  	    repl_mode = !repl_mode;
  	    break;
  
+ 	  case (CTRL|'X'):
+ 	    deltext(f,n);
+ 	    mlerase();
+ 	    FWS_RETURN(TRUE);
+ 
  	  default:
  	    if(status == ABORT)
  	      emlwrite("Search Cancelled", NULL);
***************
*** 275,281 ****
  	}
  
  	if(status + curwp->w_doto >= llength(curwp->w_dotp) ||
! 	   !eq(defpat[status],lgetc(curwp->w_dotp, curwp->w_doto + status).c))
  	  break;		/* do nothing! */
  	status++;
      }
--- 284,290 ----
  	}
  
  	if(status + curwp->w_doto >= llength(curwp->w_dotp) ||
! 	   !eq((unsigned char)defpat[status],lgetc(curwp->w_dotp, curwp->w_doto + status).c))
  	  break;		/* do nothing! */
  	status++;
      }
***************
*** 499,505 ****
  	register int s;
  	int	     i = 0;
  	char	     tpat[NPAT+20];
! 	EXTRAKEYS    menu_pat[8];
  
  	menu_pat[i = 0].name = "^Y";
  	menu_pat[i].label    = "FirstLine";
--- 508,514 ----
  	register int s;
  	int	     i = 0;
  	char	     tpat[NPAT+20];
! 	EXTRAKEYS    menu_pat[9];
  
  	menu_pat[i = 0].name = "^Y";
  	menu_pat[i].label    = "FirstLine";
***************
*** 517,522 ****
--- 526,536 ----
  	KS_OSDATASET(&menu_pat[i], KS_NONE);
  
  	if(!repl_mode){
+ 	    menu_pat[++i].name = "^X";     
+ 	    menu_pat[i].label  = "EndText";
+ 	    menu_pat[i].key    = (CTRL|'X');    
+ 	    KS_OSDATASET(&menu_pat[i], KS_NONE);
+ 
  	    menu_pat[++i].name = "^T";
  	    menu_pat[i].label  = "LineNumber";
  	    menu_pat[i].key    = (CTRL|'T');
***************
*** 630,636 ****
  	register int s;
  	int	     i;
  	char	     tpat[NPAT+20];
! 	EXTRAKEYS    menu_pat[7];
  
  	menu_pat[i = 0].name = "^Y";
  	menu_pat[i].label    = "FirstLine";
--- 644,650 ----
  	register int s;
  	int	     i;
  	char	     tpat[NPAT+20];
! 	EXTRAKEYS    menu_pat[8];
  
  	menu_pat[i = 0].name = "^Y";
  	menu_pat[i].label    = "FirstLine";
***************
*** 643,648 ****
--- 657,667 ----
  	KS_OSDATASET(&menu_pat[i], KS_NONE);
  
  	if(text_mode){
+ 	    menu_pat[++i].name = "^X";     
+ 	    menu_pat[i].label  = "EndText";
+ 	    menu_pat[i].key    = (CTRL|'X');    
+ 	    KS_OSDATASET(&menu_pat[i], KS_NONE);
+ 
  	    menu_pat[++i].name = "^T";
  	    menu_pat[i].label  = "LineNumber";
  	    menu_pat[i].key    = (CTRL|'T');
***************
*** 760,766 ****
  	  c = lgetc(curline, curoff++).c;	/* get the char */
  
  	/* test it against first char in pattern */
! 	if (eq(c, patrn[0]) != FALSE) {	/* if we find it..*/
  	    /* setup match pointers */
  	    matchline = curline;
  	    matchoff = curoff;
--- 779,785 ----
  	  c = lgetc(curline, curoff++).c;	/* get the char */
  
  	/* test it against first char in pattern */
! 	if (eq(c, (unsigned char) patrn[0]) != FALSE) {	/* if we find it..*/
  	    /* setup match pointers */
  	    matchline = curline;
  	    matchoff = curoff;
***************
*** 781,787 ****
  		  return(FALSE);
  
  		/* and test it against the pattern */
! 		if (eq(*patptr, c) == FALSE)
  		  goto fail;
  	    }
  
--- 800,806 ----
  		  return(FALSE);
  
  		/* and test it against the pattern */
! 		if (eq((unsigned char)*patptr, c) == FALSE)
  		  goto fail;
  	    }
  
***************
*** 820,829 ****
  int maxlength;	/* maximum chars in destination */
  
  {
! 	char c;		/* current char to translate */
  
  	/* scan through the string */
! 	while ((c = *srcstr++) != 0) {
  		if (c == '\n') {		/* its an EOL */
  			*deststr++ = '<';
  			*deststr++ = 'N';
--- 839,848 ----
  int maxlength;	/* maximum chars in destination */
  
  {
! 	unsigned char c;		/* current char to translate */
  
  	/* scan through the string */
! 	while ((c = (unsigned char) *srcstr++) != 0) {
  		if (c == '\n') {		/* its an EOL */
  			*deststr++ = '<';
  			*deststr++ = 'N';
***************
*** 872,874 ****
--- 891,895 ----
  
      curwp->w_flag |= WFEDIT;
  }
+ 
+ 
diff -rc pine4.61/pico/word.c pine4.61.I.USE/pico/word.c
*** pine4.61/pico/word.c	Fri May  7 14:45:24 2004
--- pine4.61.I.USE/pico/word.c	Tue Sep 21 13:48:50 2004
***************
*** 360,403 ****
  	   && isalnum((unsigned char)lgetc(curwp->w_dotp, curwp->w_doto).c));
  }
  
  
  /*
!  * Return number of quotes if whatever starts the line matches the quote string
   */
! quote_match(q, l, buf, buflen)
      char *q;
      LINE *l;
      char *buf;
      int   buflen;
  {
!     register int i, n, j, qb;
  
!     *buf = '\0';
!     if(*q == '\0')
!       return(1);
! 
!     qb = (strlen(q) > 1 && q[strlen(q)-1] == ' ') ? 1 : 0;
!     for(n = 0, j = 0; ;){
! 	for(i = 0; j <= llength(l) && qb ? q[i+1] : q[i]; i++, j++)
! 	  if(q[i] != lgetc(l, j).c)
! 	    return(n);
! 
! 	n++;
! 	if((!qb && q[i] == '\0') || (qb && q[i+1] == '\0')){
! 	    if(strlen(buf) + strlen(q) + 1 < buflen){
! 		strcat(buf,q);
! 		if(qb && (j > llength(l) || lgetc(l, j).c != ' '))
! 		  buf[strlen(buf)-1] = '\0';
! 	    }
  	}
! 	if(j > llength(l))
! 	  return(n);
! 	else if(qb && lgetc(l, j).c == ' ')
! 	  j++;
      }
!     return(n);  /* never reached */
  }
  
  
  /* Justify the entire buffer instead of just a paragraph */
  fillbuf(f, n)
--- 360,1403 ----
  	   && isalnum((unsigned char)lgetc(curwp->w_dotp, curwp->w_doto).c));
  }
  
+ /* Support of indentation of paragraphs */
+ 
+ #define is_indent_char(c)  (((c) == '.' || (c) == '}' || (c) == RPAREN || \
+ 			     (c) == '*' || (c) == ' ' || is_a_digit(c) || \
+ 			     (c) == '+' || (c) == TAB || (c) == '-' || \
+ 			     (c) == ']') ? 1 : 0)
+ #define allowed_after_digit(c,word,k)  ((((c) == '.' && \
+ 				   allowed_after_period(next((word),(k))))  ||\
+ 				  (c) == RPAREN || (c) == '}' || (c) == ']' ||\
+ 				  (c) == ' ' || (c) == TAB || \
+ 				  is_a_digit(c) || \
+ 				  ((c) == '-' ) && \
+ 					allowed_after_dash(next((word),(k)))) \
+ 				  ? 1 : 0)
+ #define allowed_after_period(c)  (((c) == RPAREN || (c) == '}' || (c) == ']' ||\
+ 				   (c) == ' ' || (c) == TAB || (c) == '-' || \
+ 				   is_a_digit(c)) ? 1 : 0)
+ #define allowed_after_parenth(c)  (((c) == ' ' || (c) == TAB) ? 1 : 0)
+ #define allowed_after_space(c)    (((c) == ' ' || (c) == TAB) ? 1 : 0)
+ #define allowed_after_braces(c)   (((c) == ' ' || (c) == TAB) ? 1 : 0)
+ #define allowed_after_star(c)     (((c) == ' ' || (c) == TAB || (c) == RPAREN\
+ 					|| (c) == ']' || (c) == '}') ? 1 : 0)
+ #define allowed_after_dash(c)     (((c) == ' ' || (c) == TAB || \
+ 					is_a_digit(c)) ? 1 : 0)
+ #define EOLchar(c)		  (((c) == '.' || (c) == ':' || (c) == '?' ||\
+ 				   (c) == '!') ? 1 : 0)
+ 
+ int is_indent PROTO((char *, int));
+ int indent_match PROTO(( char *, LINE *, char *, int, int));
+ 
+ /* Extended justification support */
+ 
+ #define is_cquote(c) ((c) == '>' || (c) == '|' || (c) == ']' || (c) == ':')
+ #define is_cword(c)  ((((c) >= 'a') && ((c) <= 'z')) ||  \
+ 		      (((c) >= 'A') && ((c) <= 'Z')) || \
+ 		      (((c) >= '0') && ((c) <= '9')) || \
+ 		       ((c) == ' ') || ((c) == '?') || \
+ 		       ((c) == '@') || ((c) == '.') || \
+ 		       ((c) == '!') || ((c) == '\'') || \
+ 		       ((c) == ',') || ((c) == '\"') ? 1 : 0)
+ #define isaquote(c)   ((c) == '\"' || (c) == '\'')
+ #define is_cletter(c)  (((c) >= 'a') && ((c) <= 'z')) ||\
+ 			 (((c) >= 'A') && ((c) <= 'Z'))
+ #define is_cnumber(c) ((c) >= '0' && (c) <= '9')
+ #define allwd_after_word(c) (((c) == ' ') || ((c) == '>') || is_cletter(c))
+ #define allwd_after_qsword(c)  (((c) != '\\') && ((c) != RPAREN))
+ #define before(word,i) (((i) > 0) ? (word)[(i) - 1] : 0)
+ #define next(w,i) ((((w)[(i)]) != 0) ? ((w)[(i) + 1]) : 0)
+ #define now(w,i)  ((w)[(i)])
+ #define is_qsword(c)  (((c) == ':') || ((c) == RPAREN) ? 1 : 0)
+ #define is_colon(c)   (((c) == ':') ? 1 : 0)
+ #define is_rarrow(c)  (((c) == '>') ? 1 : 0)
+ #define is_tilde(c)   (((c) == '~') ? 1 : 0)
+ #define is_dash(c)    (((c) == '-') ? 1 : 0)
+ #define is_pound(c)   (((c) == '#') ? 1 : 0)
+ #define is_space(c)   (((c) == ' ') ? 1 : 0)
+ #define is_a_digit(c) ((((c) >= '0') && ((c) <= '9')) ? 1 : 0)
+ #define is_allowed(c)  (is_cquote(c) || is_cword(c) || is_dash(c) || \
+ 			is_pound(c))
+ 
+ /* Internal justification functions */
+ 
+ QSTRING_S *is_quote PROTO((char *, char *, int));
+ QSTRING_S *copy_qs PROTO((QSTRING_S *));
+ QSTRING_S *qs_normal_part PROTO((QSTRING_S *));
+ QSTRING_S *qs_remove_trailing_spaces PROTO((QSTRING_S *));
+ QSTRING_S *trim_qs_from_cl PROTO((QSTRING_S *, QSTRING_S *, QSTRING_S *));
+ QSTRING_S *fix_qstring PROTO((QSTRING_S *, QSTRING_S *, QSTRING_S *));
+ QSTRING_S *qs_add PROTO((char *, char *, QStrType, int, int, int, int));
+ QSTRING_S *remove_qsword PROTO((QSTRING_S *));
+ int	   qstring_is_normal PROTO((QSTRING_S *));
+ int	   exists_good_part PROTO((QSTRING_S *));
+ int	   value_is_space PROTO((char *));
+ int	   strcmp_qs PROTO((char *, char *));
+ int	   count_levels_qstring PROTO((QSTRING_S *));
+ int	   same_qstring PROTO((QSTRING_S *, QSTRING_S *));
+ int	   advance_quote_string PROTO((char *, char *, int));
+ int	   strlenis PROTO((char *));
+ void 	   flatten_qstring PROTO((QSTRING_S *, char *));
+ void	   linencpy PROTO((char *, LINE *, int));
+ 
+ /* 
+  * This function creates a qstring pointer with the information that 
+  * is_quote handles to it.
+  * Parameters:
+  * qs		- User supplied quote string
+  * word		- The line of text that the user is trying to read/justify
+  * beginw	- Where we need to start copying from
+  * endw		- Where we end copying
+  * offset	- Any offset in endw that we need to account for
+  * typeqs	- type of the string to be created
+  * neednext	- boolean, indicating if we need to compute the next field
+  *		  of leave it NULL
+  *
+  * It is a mistake to call this function if beginw >= endw + offset.
+  * Please note the equality sign in the above inequality (this is because
+  * we always assume that qstring->value != "").
+  */
+ 
+ QSTRING_S *
+ qs_add(qs, word, typeqs, beginw, endw, offset, neednext)
+    char	     *qs;
+    char	      word[NSTRING];
+    QStrType   typeqs;
+    int	      beginw;
+    int	      endw;
+    int	      offset;
+    int	      neednext;
+ {
+     QSTRING_S *qstring, *nextqs = (QSTRING_S *) NULL;
+     int i;
+ 
+     qstring = (QSTRING_S *) malloc (sizeof(QSTRING_S));
+     memset (qstring, 0, sizeof(QSTRING_S));
+     qstring->qstype = qsNormal;
+ 
+     if (beginw == 0){
+ 	beginw = endw + offset;
+ 	qstring->qstype = typeqs;
+     }
+ 
+     if (neednext)
+        nextqs = is_quote(qs, word+beginw, 1);
+ 
+     qstring->value = (char *) malloc((beginw+1)*sizeof(char));
+     for (i = 0; (i < beginw) && (qstring->value[i] = word[i]); i++);
+     qstring->value[i] = '\0';
+ 
+     qstring->next = nextqs;
+ 
+     return qstring;
+ }
+ 
+ 
+ int
+ qstring_is_normal(cl)
+   QSTRING_S *cl;
+ {
+   for (;cl && (cl->qstype == qsNormal); cl = cl->next);
+ 
+   return cl ? 0 : 1;
+ }
+ 
+ void
+ free_qs(cl)
+   QSTRING_S **cl;
+ {
+   if (!(*cl))
+     return;
+ 
+   if ((*cl)->next)
+     free_qs(&((*cl)->next));
+ 
+   (*cl)->next = (QSTRING_S *) NULL;
+ 
+   if ((*cl)->value)
+     free((void *)(*cl)->value);
+ 
+   (*cl)->value = (char *) NULL;
+ 
+   free((void *)(*cl));
+   *cl = (QSTRING_S *) NULL;
+ }
+ 
+ QSTRING_S *
+ copy_qs(cl)
+   QSTRING_S *cl;
+ {
+   QSTRING_S *qs;
+ 
+   if (!cl)
+     return (QSTRING_S *)NULL;
+ 
+   qs = (QSTRING_S *) malloc (sizeof(QSTRING_S));
+   memset (qs, 0, sizeof(QSTRING_S));
+ 
+   qs->value = (char *) malloc ((strlen(cl->value)+1)*sizeof(char));
+   strcpy(qs->value, cl->value);
+   qs->qstype = cl->qstype;
+   qs->next = copy_qs(cl->next);
+   return qs;
+ }
+ 
+ /* 
+  * Given a quote string, this function returns the part that is the leading
+  * normal part of it. (the normal part is the part that is tagged qsNormal,
+  * that is to say, the one that is not controversial at all (like qsString
+  * for example).
+  */
+ QSTRING_S *
+ qs_normal_part(cl)
+   QSTRING_S *cl;
+ {
+ 
+   if (!cl)		/* nothing in, nothing out */
+      return cl;
+ 
+   if (cl->qstype != qsNormal)
+      free_qs(&cl);
+ 
+   if (cl) 
+      cl->next = qs_normal_part(cl->next);
+ 
+   return cl;
+ }
+ 
+ int
+ value_is_space(value)
+   char *value;
+ {
+   for (; value && *value && isspace((unsigned char) *value); value++);
+ 
+   return value && *value ? 0 : 1;
+ }
+ 
+ /* 
+  * this function removes trailing spaces from a quote string, but leaves the
+  * last one if there are trailing spaces
+  */
+ QSTRING_S *
+ qs_remove_trailing_spaces(cl)
+    QSTRING_S *cl;
+ {
+   QSTRING_S *rl = cl;
+ 
+   if (!cl)		/* nothing in, nothing out */
+     return cl;
+ 
+   if (cl->next)
+     cl->next = qs_remove_trailing_spaces(cl->next);
+   else{
+     if (value_is_space(cl->value))
+        free_qs(&cl);
+     else{
+        int i, l; 
+        i = l = strlen(cl->value) - 1;
+        while (cl->value && cl->value[i] 
+ 	  && isspace((unsigned char) cl->value[i]))
+ 	     i--;
+ 	  i += (i < l) ? 2 : 1;
+ 	  cl->value[i] = '\0';
+     }
+   }
+ 
+   return cl;
+ }
+ 
+ /*
+  * This function returns if two strings are the same quote string.
+  * The call is not symmetric. cl must preceed the line nl. This function
+  * should be called for comparing the last part of cl and nl.
+  */
+ int
+ strcmp_qs(valuecl, valuenl)
+   char *valuecl;
+   char *valuenl;
+ {
+    int j;
+ 
+    for (j = 0; valuecl[j] && (valuecl[j] == valuenl[j]); j++);
+    return !strcmp(valuecl, valuenl)
+ 	    || (valuenl[j] && value_is_space(valuenl+j) 
+ 			   && value_is_space(valuecl+j)
+ 			   && strlenis(valuecl+j) >= strlenis(valuenl+j))
+ 	    || (!valuenl[j] && value_is_space(valuecl+j));
+ }
+ 
+ int
+ count_levels_qstring(cl)
+   QSTRING_S *cl;
+ {
+   int count;
+   for (count = 0; cl ; count++, cl = cl->next);
+ 
+   return count;
+ }
+ 
+ /* 
+  * This function returns the number of agreements between 
+  * cl and nl. The call is not symmetric. cl must be the line
+  * preceding nl.
+  */
+ int
+ same_qstring(cl,nl)
+   QSTRING_S *cl;
+   QSTRING_S *nl;
+ {
+    int same = 0, done = 0;
+ 
+    for (;cl && nl && !done; cl = cl->next, nl = nl->next)
+       if ((cl->qstype == nl->qstype) && (!strcmp(cl->value, nl->value) 
+ 	  || ((!cl->next) && strcmp_qs(cl->value, nl->value))))
+ 	same++;
+       else
+ 	done++;
+ 
+    return same;
+ }
+ 
+ QSTRING_S *
+ trim_qs_from_cl(cl, nl, pl)
+   QSTRING_S *cl;
+   QSTRING_S *nl;
+   QSTRING_S *pl;
+ {
+    QSTRING_S *cqstring = pl ? pl : nl;
+    QSTRING_S *tl = pl ? pl : nl;
+    int p, c;
+ 
+    if (qstring_is_normal(tl))
+     return tl;
+ 
+     p = same_qstring(pl ? pl : cl, pl ? cl : nl);
+ 
+     for (c = 1; c < p; c++, cl = cl->next, tl = tl->next);
+ 
+     /*
+      * cl->next and tl->next differ, it may be because cl->next does not
+      * exist or tl->next does not exist or simply both exist but are
+      * different. In this last case, it may be that cl->next->value is made
+      * of spaces. If this is the case, tl advances once more.
+      */
+ 
+     if (tl->next){
+        if (cl && cl->next && value_is_space(cl->next->value))
+ 	  tl = tl->next;
+        if (tl->next)
+ 	  free_qs(&(tl->next));
+     }
+ 
+     if (!p)
+        free_qs(&cqstring);
+ 
+     return cqstring;
+ }
+ 
+ /* This function trims cl so that it returns a real quote string based
+  * on information gathered from the previous and next lines. pl and cl are
+  * also trimmed, but that is done in another function, not here.
+  */
+ QSTRING_S *
+ fix_qstring(cl, nl, pl)
+   QSTRING_S *cl;
+   QSTRING_S *nl;
+   QSTRING_S *pl;
+ {
+   QSTRING_S *cqstring = cl, *nqstring = nl, *pqstring = pl;
+   int c, n;
+ 
+   if (qstring_is_normal(cl))
+     return cl;
+ 
+   c = count_levels_qstring(cl);
+   n = same_qstring(cl,nl);
+ 
+   if (!n){  /* no next line or no agreement with next line */
+      int p = same_qstring(pl, cl); /* number of agreements between pl and cl */
+      QSTRING_S *tl; 		   /* test line */
+ 
+      /*
+       * Here p <= c, so either p < c or p == c. If p == c, we are done, 
+       * and return cl. If not, there are two cases, either p == 0 or
+       * 0 < p < c. In the first case, we do not have enough evidence
+       * to return anything other than the normal part of cl, in the second
+       * case we can only return p levels of cl.
+       */
+ 
+      if (p == c)
+ 	tl = cqstring;
+      else{
+ 	if (p){
+ 	   for (c = 1; c < p; c++)
+ 	      cl = cl->next;
+ 	   free_qs(&(cl->next));
+ 	   tl = cqstring;
+ 	}
+ 	else{
+ 	   int done = 0;
+ 	   QSTRING_S *al = cl;	/* another line */
+ 	   /* 
+ 	    * Ok, we reaelly don't have enough evidence to return anything,
+ 	    * different from the normal part of cl, but it could be possible
+ 	    * that we may want to accept the not-normal part, so we better
+ 	    * make an extra test to determine what needs to be freed
+ 	    */
+ 	   while (pl && cl && !strucmp(cl->value, pl->value)){
+ 		cl = cl->next;
+ 		pl = pl->next;
+ 	   }
+ 	   if (pl && cl && strcmp_qs(pl->value, cl->value))
+ 		cl = cl->next;	/* next level differs only in spaces */
+ 	   while (!done){
+ 		while (cl && cl->qstype == qsNormal)
+ 		    cl = cl->next;
+ 		if (cl){
+ 		   if ((cl->qstype == qsString) 
+ 		       && (cl->value[strlen(cl->value) - 1] == '>'))
+ 		      cl = cl->next;
+ 		   else done++;
+ 		}
+ 		else done++;
+ 	   }
+ 	   if (al == cl){
+ 	      free_qs(&(cl));
+ 	      tl = cl;
+ 	   }
+ 	   else {
+ 	      while (al && (al->next != cl))
+ 	         al = al->next;
+ 	      cl = al;
+ 	      if (cl && cl->next)
+ 	         free_qs(&(cl->next));
+ 	      tl = cqstring;
+ 	   }
+ 	}
+      }
+      return tl;
+   }
+   if (n + 1 < c){  /* if there are not enough agreements */
+      int p = same_qstring(pl, cl); /* number of agreement between pl and cl */
+      QSTRING_S *tl; /* test line */
+ 
+ 	/*
+ 	 * There's no way we can use cl in this case, but we can use
+ 	 * part of cl, this is if pl does not have more agreements
+ 	 * with cl.
+ 	 */
+ 
+      if (p == c)
+ 	tl = cqstring;
+      else{
+ 	int m = p < n ? n : p;
+ 	for (c = 1; c < m; c++){
+ 	  pl = pl ? pl->next : (QSTRING_S *) NULL;
+ 	  nl = nl ? nl->next : (QSTRING_S *) NULL;
+ 	  cl = cl->next;
+ 	}
+ 	if ((p == n) && pl && pl->next && nl && nl->next
+ 	   && ((cl->next->qstype == pl->next->qstype) 
+ 	      || (cl->next->qstype == nl->next->qstype))
+ 	   && (strcmp_qs(cl->next->value, pl->next->value) 
+ 	      || strcmp_qs(pl->next->value, cl->next->value) 
+ 	      || strcmp_qs(cl->next->value, nl->next->value) 
+ 	      || strcmp_qs(nl->next->value, cl->next->value))) 
+ 	  cl = cl->next;	/* next level differs only in spaces */
+ 	if (cl->next)
+ 	   free_qs(&(cl->next));
+ 	tl = cqstring;
+      }
+      return tl;
+   }
+   if (n + 1 == c){
+      int p = same_qstring(pl, cl);
+      QSTRING_S *tl; /* test line */
+ 
+      /* 
+       * p <= c, so p <= n+1, which means p < n + 1 or p == n + 1.
+       * If p < n + 1, then p <= n.
+       * so we have three possibilities: 
+       *	p == n + 1 or p == n or p < n.
+       * In the first case we copy p == n + 1 == c levels, in the second
+       * and third case we copy n levels, and check if we can copy the 
+       * n + 1 == c level.
+       */
+ 
+      if (p == n + 1)      /* p == c, in the above sense of c */
+ 	tl = cl; 	  /* use cl, this is enough evidence */
+      else{
+ 	for (c = 1; c < n; c++)
+ 	  cl = cl->next;
+ 	/* 
+ 	 * Here c == n, we only have one more level of cl, and at least one
+ 	 * more level of nl 
+ 	 */
+ 	if (cl->next->qstype == qsNormal)
+ 	   cl = cl->next;
+ 	if (cl->next)
+ 	   free_qs(&(cl->next));
+ 	tl = cqstring;
+      }
+      return tl;
+   }
+   if (n == c)  /* Yeah!!! */
+     return cqstring;
+ }
+ 
+ /* 
+  * This function flattens the quote string returned to us by is_quote. A
+  * crash in this function implies a bug elsewhere.
+  */
+ void 
+ flatten_qstring(qs, buff)
+   QSTRING_S *qs;
+   char	    *buff;
+ {
+   int i = 0, j;
+ 
+   for (; qs; qs = qs->next)
+     for (j = 0; (qs->value[j]) && (buff[i++] = qs->value[j]); j++);
+   buff[i] = '\0';
+ }
+ 
+ /* 
+  * Given a string, we return the position where the function thinks that
+  * the quote string is over, if you are ever thinking of fixing something,
+  * you got to the right place. Memory freed by caller. Experience shows
+  * that it only makes sense to initialize memory when we need it, not at
+  * the start of this function.
+  */
+ QSTRING_S *
+ is_quote (qs,word, been_here)
+   char *qs;
+   char word[NSTRING];
+   int been_here;
+ {
+   int i = 0, j, c, nxt, prev, finished = 0, offset;
+   QSTRING_S *qstring = (QSTRING_S *) NULL;
+ 
+    if (!word || !word[0])
+       return (QSTRING_S *) NULL;
+ 
+    while (!finished){
+ 	/* 
+ 	 * Before we apply our rules, let's advance past the quote string
+ 	 * given by the user, this will avoid not recognition of the
+ 	 * user's indent string and application of the arbitrary rules
+ 	 * below. Notice that this step may bring bugs into this
+ 	 * procedure, but these bugs will only appear if the indent string
+ 	 * is really really strange and the text to be justified
+ 	 * cooperates a lot too, so in general this will not be a problem.
+ 	 * If you are concerned about this bug, simply remove the
+ 	 * following lines after this comment and before the "switch"
+ 	 * command below and use a more normal quote string!.
+ 	 */
+ 	i += advance_quote_string(qs, word, i);
+ 	if (!word[i]) /* went too far? */
+ 	   return qs_add(qs, word, qsNormal, 0, i, 0, 0);
+ 
+      switch (c = now(word,i)){
+ 	case TAB:
+ 	case ' ': { QSTRING_S *nextqs, *testqs = NULL;
+ 		    int j;
+ 
+ 		    for (; isspace((unsigned char) word[i]); i++);
+ 		    nextqs = is_quote(qs,word+i, 1);
+ 		  /* 
+ 		   * Merge qstring and nextqs, since this is an artificial
+ 		   * separation, unless nextqs is of different type.
+ 		   * What this means in practice is that if 
+ 		   * qs->qstype == qsNormal and qs->next != NULL, then
+ 		   * qs->next->qstype != qsNormal.
+ 		   *
+ 		   * Can't use qs_add to merge because it could lead
+ 		   * to an infinite loop (e.g a line "^ ^").
+ 		   */
+ 		    if (nextqs){
+ 		        if(nextqs->qstype == qsNormal){
+ 		          i += strlen(nextqs->value);
+ 		          testqs = copy_qs(nextqs->next);
+ 		        }
+ 		        else
+ 		          testqs = copy_qs(nextqs);
+ 		        free_qs(&nextqs);
+ 		    }
+ 
+ 		    qstring = (QSTRING_S *) malloc (sizeof(QSTRING_S));
+ 		    memset (qstring, 0, sizeof(QSTRING_S));
+ 
+ 		    qstring->value = (char *) malloc((i+1)*sizeof(char));
+ 		    for (j = 0; (j < i) && (qstring->value[j] = word[j]); j++);
+ 		    qstring->value[j] = '\0';
+ 		    qstring->qstype   = qsNormal;
+ 
+ 		    qstring->next = testqs;
+ 
+ 		    return qstring;
+ 		  }
+ 		 break;
+ 
+ 	case RPAREN:		/* parenthesis ')' */
+ 		     if ((i != 0) || ((i == 0) && been_here))
+ 			i++;
+ 		     else
+ 			if (i == 0)
+ 		           return qs_add(qs, word, qsChar, i, i, 1, 1);
+ 		        else
+ 			   finished++;
+ 		    break;
+ 
+ 	case ';':
+ 	case ':':			/* colon */
+ 	case '~': if (is_cquote(nxt = next(word,i)) 
+ 			|| ((c != '~') && (nxt == RPAREN))
+ 			|| ((i != 0) && is_space(nxt))
+ 			|| is_cquote(prev = before(word,i)) 
+ 			|| (is_space(prev)))
+ 		      i++;
+ 		  else
+ 		     if (i == 0)
+ 		       return qs_add(qs, word, qsChar, i, i, 1, 1);
+ 		     else
+ 			finished++;
+ 		 break;
+ 
+ 	case '<' :
+ 	case '=' :
+ 	case '-' : offset = is_cquote(nxt = next(word,i)) ? 2
+                                 : ((nxt == c)
+                                      && is_cquote(next(word,i+1))) ? 3 : -1;
+                    
+ 		   if (offset > 0)
+ 		       return qs_add(qs, word, qsString, i, i, offset, 1);
+ 		   else
+ 		       finished++;
+ 		 break;
+ 
+ 	case '+' :	/* accept +>, *> */
+ 	case '*' :  if (is_rarrow(nxt = next(word, i)) || /* stars */
+ 		      (is_space(nxt) && is_rarrow(next(word,i+1))))
+ 			 i++;
+ 		    else
+ 		       finished++;
+ 		 break;
+ 
+ 	case '^' :
+ 	case '!' :
+ 	case '%' :
+ 	case '#' : if (next(word,i) != c)
+ 		      return qs_add(qs, word, qsChar, i, i+1, 0, 1);
+ 		   else
+ 		      finished++;
+ 	         break;
+ 
+         default:
+ 	    if (is_cquote(c))
+ 	       i++;
+ 	    else if (is_cletter(c)){
+ 		for (j = i; is_cword(nxt = next(word,j)) 
+ 			    && !(is_space(nxt));j++);
+ 		  /* 
+ 		   * The whole reason why we are splitting the quote
+ 		   * string is so that we will be able to accept quote
+ 		   * strings that are strange in some way. Here we got to
+ 		   * a point in which a quote string might exist, but it
+ 		   * could be strange, so we need to create a "next" field
+ 		   * for the quote string to warn us that something
+ 		   * strange is coming. We need to confirm if this is a
+ 		   * good choice later. For now we will let it pass.
+ 		   */
+ 		  if (isaword(word,i,j) || isamailbox(word,i,j)){
+ 		    int offset;
+ 		    QStrType qstype;
+ 
+ 		    offset = (is_cquote(c = next(word,j))
+ 			     || (c == RPAREN)) ? 2
+ 				: ((is_space(c) 
+ 				     && is_cquote(next(word,j+1))) ? 3 : -1);
+ 
+ 		    qstype = (is_cquote(c) || (c == RPAREN))
+ 		      ? (is_qsword(c) ? qsWord : qsString)
+ 		      : ((is_space(c) && is_cquote(next(word,j+1)))
+ 			 ? (is_qsword(next(word,j+1))
+ 			    ? qsWord : qsString) 
+ 				  : qsString);
+ 
+ 		    /* 
+ 		     * qsWords are valid quote strings only when
+ 		     * they are followed by text.
+ 		     */
+ 		    if ((offset > 0) && (qstype == qsWord) &&
+ 			!(allwd_after_qsword(now(word,j + offset))))
+ 			offset = -1;
+ 
+ 		    if (offset > 0)
+ 		        return qs_add(qs, word, qstype, i, j, offset, 1);
+ 		  }
+ 		  finished++;
+ 	    }
+ 	    else   /* Chao pescao! */
+ 	      finished++;
+ 	break;
+      }  /* End Switch */
+    }  /* End while */
+ 
+    if (i > 0)
+       qstring = qs_add(qs, word, qsNormal, 0, i, 0, 0);
+ 
+    return qstring;
+ }
+ 
+ void
+ linencpy(word, l, buflen)
+ char word[NSTRING];
+ LINE *l;
+ int buflen;
+ {
+   int i = 0;
+   for (;(i < buflen) && (i < llength(l)) && (word[i] = (char)lgetc(l,i).c); i++);
+   word[buflen - 1] = '\0';
+ }
+ 
+ 
+ 
+ int
+ isaword(word,i,j)
+ char word[NSTRING];
+ int i;
+ int j;
+ {
+  return i <= j && is_cletter(word[i]) ?
+          (i < j ? isaword(word,i+1,j) : 1) : 0;
+ }
+ 
+ int
+ isamailbox(word,i,j)
+ char word[NSTRING];
+ int i;
+ int j;
+ {
+  return i <= j && (is_cletter(word[i]) || is_a_digit(word[i]) 
+ 		  || word[i] == '.')
+ 	? (i < j ? isamailbox(word,i+1,j) : 1) : 0;
+ }
+ 
+ 
+ /* 
+  * This function returns the quote string as a structure. In this way we
+    have two ways to get the quote string: as a char * or as a QSTRING_S *
+    directly.
+  */
+ QSTRING_S *
+ qs_quote_match(q, l, buf, buflen, raw)
+     char *q;
+     LINE *l;
+     char *buf;
+     int   buflen;
+     int   raw;
+ {
+     char GLine[NSTRING] = {'\0'}, NLine[NSTRING] = {'\0'}, 
+ 	 PLine[NSTRING] = {'\0'};
+     LINE *nl = l != curbp->b_linep ? lforw(l) : NULL;
+     LINE *pl = lback(l) != curbp->b_linep ? lback(l) : NULL;
+ 
+     if (nl)
+       linencpy(NLine, nl, NSTRING);
+ 
+     if (pl)
+       linencpy(PLine, pl, NSTRING);
+ 
+     linencpy(GLine, l, NSTRING);
+ 
+     return do_quote_match(q,GLine, NLine, PLine, raw);
+ }
  
  /*
!  * Return number of quotes if whatever starts the line matches the quote
!  * string
   */
! quote_match(q, l, buf, buflen, raw)
      char *q;
      LINE *l;
      char *buf;
      int   buflen;
+     int   raw;
  {
!     QSTRING_S *qs;
  
!     qs = qs_quote_match(q, l, buf, buflen, raw);
!     flatten_qstring(qs, buf);
!     if (qs)
! 	free_qs(&qs);
! 
!     return buf && buf[0] ? strlen(buf) : 0;
! }
! 
! /*
!    This routine removes the last part that is qsword or qschar that is not
!    followed by a normal part. This means that if a qsword or qschar is
!    followed by a qsnormal (or qsstring), we accept the qsword (or qschar)
!    as part of a quote string.
!  */
! 
! QSTRING_S *
! remove_qsword(cl)
!   QSTRING_S *cl;
! {
!     QSTRING_S *np = cl;
!     QSTRING_S *cp = np;		/* this variable trails cl */
! 
!     while(1){
!        while (cl && cl->qstype == qsNormal)
!            cl = cl->next;
! 
!        if (cl){
! 	  if (((cl->qstype == qsWord) || (cl->qstype == qsChar))
! 		&& !exists_good_part(cl)){
! 	      if (np == cl)     /* qsword or qschar at the beginning */
! 		 free_qs(&cp);
! 	      else{
! 	         while (np->next != cl)
! 		     np = np->next;
! 		 free_qs(&(np->next));
! 	     }
! 	     break;
! 	  }
! 	  else
! 	     cl = cl->next;
!        }
!        else
!         break;
!    }
!    return cp;
! }
! 
! int
! exists_good_part (cl)
!   QSTRING_S *cl;
! {
!   return (cl ? (((cl->qstype != qsWord) && (cl->qstype != qsChar)
!                    && !value_is_space(cl->value)) 
! 		? 1 
! 		: exists_good_part(cl->next)) 
! 	    : 0);
! }
! 
! 
! QSTRING_S *
! do_quote_match(q,GLine, NLine, PLine, raw)
!   char *q;
!   char  GLine[NSTRING];
!   char  NLine[NSTRING];
!   char  PLine[NSTRING];
!   int  raw;
! {
!     QSTRING_S *cl, *nl = NULL, *pl = NULL;
!     int c, n, p,i, j, NewC, NewN, clength, same = 0;
!     char nbuf[NSTRING], pbuf[NSTRING], buf[NSTRING];
!     int emptynl = 0, emptypl = 0;
! 
!     cl = is_quote(q,GLine, 0);	/* Current or Given line */
! 
!     if (!cl)			/* if nothing in, nothing out */
!       return cl;
! 
!     if (NLine && NLine[0])
! 	nl = is_quote(q,NLine, 0);	/* Next Line		 */
!     if (PLine && PLine[0])
! 	pl = is_quote(q,PLine, 0);	/* Previous Line	 */
! 
!     /* 
!      * If there's nothing in the preceeding or following line
!      * there is not enough information to accept it or discard it. In this
!      * case it's likely to be an isolated line, so we better accept it
!      * if it does not look like a word. */
! 
!     flatten_qstring(pl, pbuf);
!     emptypl = (!PLine || !PLine[0] ||
! 		(pl && value_is_space(pbuf)) && !PLine[strlen(pbuf)]) ? 1 : 0;
!     if (emptypl){
!        flatten_qstring(nl, nbuf);
!        emptynl = (!NLine || !NLine[0] ||
! 		(nl && value_is_space(nbuf) && !NLine[strlen(nbuf)])) ? 1 : 0;
!        if (emptynl){
! 	  cl = remove_qsword(cl);
! 	  cl = qs_remove_trailing_spaces(cl);
! 	  free_qs(&nl);
! 	  free_qs(&pl);
! 
! 	  return cl;
!        }
!     }
! 
!     /* 
!      * If either cl, nl or pl contain suspicious characters that may make
!      * them (or not) be quote strings, we need to fix them, so that the
!      * next pass will be done correctly.
!      */
! 
!     cl = fix_qstring(cl, nl, pl);
!     nl = trim_qs_from_cl(cl, nl, NULL);
!     pl = trim_qs_from_cl(cl, NULL, pl);
!     flatten_qstring(cl,  buf);
!     flatten_qstring(nl, nbuf);
!     flatten_qstring(pl, pbuf);
! 
!     if (raw){			/* if we are asked for the raw string */
! 	free_qs(&nl);
! 	free_qs(&pl);
! 	
!        return cl;		/* return now! */
!     }
!     /* 
!      * Once upon a time, is_quote used to return the length of the quote
!      * string that it had found. One day, not long ago, black hand came
!      * and changed all that, and made is_quote return a quote string
!      * divided in several fields, making the algorithm much more
!      * complicated. Fortunately black hand left a few comments in the
!      * source code to make it more understandable. Because of this change
!      * we need to compute the lengths of the quote strings separately
!      */
!     c =  buf &&  buf[0] ? strlen(buf)  : 0;
!     n = nbuf && nbuf[0] ? strlen(nbuf) : 0;
!     p = pbuf && pbuf[0] ? strlen(pbuf) : 0;
! 
!     /*
!      * When quote strings contain only blank spaces (ascii code 32) the
!      * above count is equal to the length of the quote string, but if
!      * there are TABS, the length of the quote string as seen by the user
!      * is different than the number that was just computed.  Because of
!      * this we demand a recount (hmm.. unless you are in Florida, where
!      * recounts are forbidden)
!      */
! 
!     NewC = strlenis(buf);
!     NewN = strlenis(nbuf);
! 
!     /* 
!      * For paragraphs with spaces in the first line, but no space in the
!      * quote string of the second line, we make sure we choose the quote
!      * string without a space at the end of it.
!      */
!     if ((NLine && !NLine[0])
! 	&& ((PLine && !PLine[0]) 
! 	     || (((same = same_qstring(pl, cl)) != 0)
! 			&& (same != count_levels_qstring(cl)))))
! 	cl = qs_remove_trailing_spaces(cl);
!     else 
!       if (NewC > NewN){
!         for (j = 0; (j < n) && (GLine[j] == NLine[j]); j++);
! 	clength = j;
! 	if (j < n){ /* see if buf and nbuf are padded with spaces and tabs */
! 	   for (i = clength; i < n && isspace((unsigned char)NLine[i]); i++);
! 	   if (i == n){
! 	      for (i = clength; i < c && isspace((unsigned char)GLine[i]); i++);
! 		if (i == c)
! 		  j = n;
! 	   }
  	}
!         if (j == n){
!            for (j = clength; j < c && isspace((unsigned char)GLine[j]); j++);
!            if (j == c){
! 
! 	/* 
! 	 * If we get here, it means that the current line has the same
! 	 * quote string (visually) than the next line, but both of them
! 	 * are padded with different amount of TABS or spaces at the end.
! 	 * The current line (GLine) has more spaces/TABs than the next
! 	 * line. This is the typical situation that is found at the
! 	 * begining of a paragraph. We need to check this, however, by
! 	 * checking the previous line. This avoids that we confuse
! 	 * ourselves with being in the last line of a paragraph.
! 	 */
! 
! 	      for (j = 0; (j < p) && (GLine[j] == PLine[j]); j++);
!               if (((p == c) && ((j != p) && NLine[n]))
! 		   || ((p != c) && NLine[n])){
! 		 free_qs(&cl);
! 		 cl = copy_qs(nl);
!               }
!            }   
!         }
!       }
! 
!     free_qs(&nl);
!     free_qs(&pl);
! 
!     return cl;
! }
! 
! /*
!  * Given a line, an initial position, and a quote string, we advance the
!  * current line past the quote string, including arbitraty spaces
!  * contained in the line, except that it removes trailing spaces. We do
!  * not handle TABs, if any, contained in the quote string. At least not
!  * yet.
!  *
!  * Arguments: q - quote string
!  *	      l - a line to process
!  *	      i - position in the line to start processing. i = 0 is the
!  *		  begining of that line.
!  */
! int
! advance_quote_string(q, l, i)
!     char *q;
!     char  l[NSTRING];
!     int   i;
! {
!     int n = 0, j = 0, is = 0, es = 0;
!     int k, m, p, adv;
!     char qs[NSTRING] = {'\0'};
! 
!     if(!q || !*q)
!       return(0);
! 
!     for (p = strlen(q); (p > 0) && (q[p - 1] == ' '); p--, es++);
!     if (!p){  /* string contains only spaces */
! 	for (k = 0; l[i + k] == ' '; k++);
! 	k -= k % es;
! 	return k;
!     }
!     for (is = 0; q[is] == ' '; is++); /* count initial spaces */
!     for (m = 0 ; is + m < p ; m++)
! 	qs[m] = q[is + m];   /* qs = quote string without any space at the end */
! 		      /* advance as many spaces as there are at the begining */
!     for (k = 0; l[i + j] == ' '; k++, j++);
! 			/* now find the visible string in the line */
!     for (m = 0; qs[m] && l[i + j] == qs[m]; m++, j++);
!     if (!qs[m]){	/* no match */
! 	/* 
! 	 * So far we have advanced at least "is" spaces, plus the visible
! 	 * string "qs". Now we need to advance the trailing number of
! 	 * spaces "es". If we can do that, we have found the quote string.
! 	 */
!       for (p = 0; l[i + j + p] == ' '; p++);
!       adv = advance_quote_string(q, l, i + j + ((p < es) ? p : es));
!       n = ((p < es) ? 0 : es) + k + m + adv;
      }
!     return n;
  }
  
+ /* 
+  * This function returns the effective length in screen of the quote
+  * string. If the string contains a TAB character, it is added here, if
+  * not, the length returned is the length of the string
+  */
+ 
+ int
+ strlenis(qstr)
+ char *qstr;
+ {
+   int i, rv = 0;
+ 
+   if (qstr && *qstr){
+      for (i = 0; qstr[i]; i++)
+         rv += ((qstr[i] == TAB) ? (~rv & 0x07) + 1 : 1);
+   }
+   return rv;
+ }
  
  /* Justify the entire buffer instead of just a paragraph */
  fillbuf(f, n)
***************
*** 475,485 ****
  int f, n;	/* deFault flag and Numeric argument */
  
  {
!     int	    i, j, c, qlen, word[NSTRING], same_word,
! 	    spaces, word_len, line_len, line_last, qn;
!     char   *qstr, qstr2[NSTRING];
      LINE   *eopline;
      REGION  region;
  
      if(curbp->b_mode&MDVIEW){		/* don't allow this command if	*/
  	return(rdonly());		/* we are in read only mode	*/
--- 1475,1487 ----
  int f, n;	/* deFault flag and Numeric argument */
  
  {
!     int	    i = 0, j, c, qlen, word[NSTRING], same_word, qlenis,
! 	    spaces, word_len, line_len, line_last, qn, indlen, qi, pqi;
!     char   *qstr, qstr2[NSTRING], tbuf[NSTRING], ind_str[NSTRING], 
! 	   *qstrfl, qstrfl2[NSTRING], quoid[NSTRING];
      LINE   *eopline;
      REGION  region;
+     QSTRING_S *tl;
  
      if(curbp->b_mode&MDVIEW){		/* don't allow this command if	*/
  	return(rdonly());		/* we are in read only mode	*/
***************
*** 499,512 ****
  
      /* and back to the beginning of the paragraph */
      gotobop(FALSE, 1);
  
!     /* determine if we're justifying quoted text or not */
      qstr = ((glo_quote_str || (Pmaster && Pmaster->quote_str))
! 	    && quote_match(glo_quote_str ? glo_quote_str
! 			   : Pmaster->quote_str, 
! 			   curwp->w_dotp, qstr2, NSTRING)
! 	    && *qstr2) ? qstr2 : NULL;
!     qlen = qstr ? strlen(qstr) : 0;
  
      /* let yank() know that it may be restoring a paragraph */
      thisflag |= CFFILL;
--- 1501,1586 ----
  
      /* and back to the beginning of the paragraph */
      gotobop(FALSE, 1);
+     setimark(FALSE, 1);  /* Remember this spot in case we unjustify */
  
!     /*
!      * When a paragraph has special indentation, we will get two quote
!      * strings. One from the first line of the paragraph, and one from
!      * the last line of the paragraph. We will need to use both when
!      * we justify.
!      *
!      * Here's a model of what we will code:
!      *
!      *      +-------+-------+-+-----+
!      *      | qstrfl|ind_str|X| text|  
!      *      +-----+-+-------+-+-----+
!      *      | qstr| *(space)|X| text|
!      *      +-----+---------+-+-----+
!      *
!      * Here X represents 1 space if it exists after ind_str and
!      * "*(space)" represent a variable amount of space that is put there
!      * to pad text so that it will align correctly when justified.
!      */
!     indlen = indent_match((glo_quote_str || (Pmaster && Pmaster->quote_str))
! 			 ? (glo_quote_str ? glo_quote_str : Pmaster->quote_str)
! 			 : "", curwp->w_dotp, ind_str, NSTRING, 0);
!     qstrfl = (quote_match((glo_quote_str || (Pmaster && Pmaster->quote_str)) 
! 			? (glo_quote_str ? glo_quote_str : Pmaster->quote_str)
! 			: ">", curwp->w_dotp, qstrfl2, NSTRING,0)
!             && *qstrfl2) ? qstrfl2 : NULL;
!     if (qstrfl){
!        if (glo_quote_str || (Pmaster && Pmaster->quote_str))
!           for (; (i < NSTRING) && (quoid[i] = qstrfl[i]); i++);
!        else{
!           for (; (i < NSTRING) && qstrfl[i] && (quoid[i] = ' '); i++);
! 	  qstrfl[0] = '\0';
!        }
!     }
!     if (indlen)
!        for (j = 0; ((i + j) < NSTRING) && (quoid[i] = ind_str[j]); i++,j++); 
!     quoid[i] = '\0';
!     qi = quoid && quoid[0] ? strlen(quoid) : 0;
!     if (indlen)			 /* strip trailing spaces */
!        for (;isspace((unsigned char) quoid[qi - 1]); qi--); 
!     quoid[qi] = '\0';     /* we have closed quoid at "X" in the first line */
!      
!     if (strlenis(quoid) > fillcol)
!        return FALSE;          /* Too wide, we can't justify this! */
!       
!      /* determine if we're justifying quoted text or not */
      qstr = ((glo_quote_str || (Pmaster && Pmaster->quote_str))
!  	    && quote_match(glo_quote_str ? glo_quote_str :
!   			   Pmaster->quote_str,
!  			   curwp->w_dotp, qstr2, NSTRING, 0)
!   	    && *qstr2) ? qstr2 : NULL;
!     /* In some situations, like in the following paragraph, qstr can be non
!      * empty as returned above,  when indeed it is empty. Fix it!.
! 
!         * Item #1
!         * Item #2
!         continuation of item #2
!      */
!     if (qstr && indlen){
! 	for (i = strlen(qstr) - 1; isspace((unsigned char) qstr[i]); i--);
! 	qstr[i + 1] = '\0';
!     }
! 
!     qlen   = qstr ? strlen(qstr)   : 0;
!     qlenis = qstr ? strlenis(qstr) : 0;
!   
!     /*
!      * Compare effective lengths of quoid and qstr to decide how much space
!      * we need to use to pad with.
!      */
!     if (indlen && ((j = strlenis(quoid) - strlenis(qstr)) > 0)){
!        pqi = qstr ? strlen(qstr) : 0;
!        for (i = 0; (i < j) && (qstr2[pqi + i] = ' '); i++);
!        if (isspace((unsigned char) ind_str[indlen - 1]))
!           qstr2[pqi + i++] = ' ';
!        qstr2[pqi + i] = '\0';
!        if (!qstr)
!           qstr = qstr2;
!     }
  
      /* let yank() know that it may be restoring a paragraph */
      thisflag |= CFFILL;
***************
*** 524,541 ****
        return(FALSE);
  
      /* Now insert it back wrapped */
!     spaces = word_len = line_len = same_word = 0;
  
      /* Beginning with leading quoting... */
!     if(qstr){
! 	while(qstr[line_len])
! 	  linsert(1, qstr[line_len++]);
  
  	line_last = ' ';			/* no word-flush space! */
      }
  
      /* ...and leading white space */
!     for(i = qlen; (c = fremove(i)) == ' ' || c == TAB; i++){
  	linsert(1, line_last = c);
  	line_len += ((c == TAB) ? (~line_len & 0x07) + 1 : 1);
      }
--- 1598,1635 ----
        return(FALSE);
  
      /* Now insert it back wrapped */
!     spaces = word_len = line_len = same_word = i = 0;
  
      /* Beginning with leading quoting... */
!     if(qstrfl){
! 	while((tbuf[line_len] = qstrfl[line_len]) == fremove(line_len))
! 	  linsert(1, qstrfl[line_len++]);
! 	/* 
! 	 * The only way that at the end of the above loop we don't have
! 	 * line_len == qlen is that there are trailing spaces or TABS
! 	 * which could not be accounted in the qstr in is_quote or other
! 	 * functions before we got here. Now we enter the common part of
! 	 * the quote string in the first line and the rest is only spaces
! 	 * (or TABS) that need to be entered, which are left to the loop
! 	 * following this "if" statement
! 	 */
! 	i = line_len;				/* start next loop from here */
! 	tbuf[line_len] = '\0';			/* closing tbuf...	*/
! 	line_len = strlenis(tbuf);		/* we demand a recount! */
! 	line_last = ' ';			/* no word-flush space! */
!     }
  
+     /* ...followed by the indent string, if any */
+     if (indlen){
+ 	for (i, j = 0; (c = fremove(i)) && ind_str[j]; i++, j++){
+ 	    linsert(1, line_last = c);
+ 	    line_len += ((c == TAB) ? (~line_len & 0x07) + 1 : 1);
+         }
  	line_last = ' ';			/* no word-flush space! */
      }
  
      /* ...and leading white space */
!     for(i; (c = fremove(i)) == ' ' || c == TAB; i++){
  	linsert(1, line_last = c);
  	line_len += ((c == TAB) ? (~line_len & 0x07) + 1 : 1);
      }
***************
*** 558,564 ****
  
  	  default :
  	    if(spaces){				/* flush word? */
! 		if((line_len - qlen > 0)
  		   && line_len + word_len + 1 > fillcol
  		   && ((isspace((unsigned char)line_last))
  		       || (linsert(1, ' ')))
--- 1652,1658 ----
  
  	  default :
  	    if(spaces){				/* flush word? */
! 		if((line_len - qlenis > 0)
  		   && line_len + word_len + 1 > fillcol
  		   && ((isspace((unsigned char)line_last))
  		       || (linsert(1, ' ')))
***************
*** 588,594 ****
  
  	    if(word_len + 1 >= NSTRING){
  		/* Magic!  Fake that we output a wrapped word */
! 		if((line_len - qlen > 0) && !same_word++){
  		    if(!isspace((unsigned char) line_last))
  		      linsert(1, ' ');
  		    line_len = fpnewline(qstr);
--- 1682,1688 ----
  
  	    if(word_len + 1 >= NSTRING){
  		/* Magic!  Fake that we output a wrapped word */
! 		if((line_len - qlenis > 0) && !same_word++){
  		    if(!isspace((unsigned char) line_last))
  		      linsert(1, ' ');
  		    line_len = fpnewline(qstr);
***************
*** 608,617 ****
      }
  
      if(word_len){
! 	if((line_len - qlen > 0) && (line_len + word_len + 1 > fillcol)){
  	    if(!isspace((unsigned char) line_last))
  	      linsert(1, ' ');
! 	    (void) fpnewline(qstr);
  	}
  	else if(line_len && !isspace((unsigned char) line_last))
  	  linsert(1, ' ');
--- 1702,1712 ----
      }
  
      if(word_len){
! 	if((line_len - qlenis > 0) && (line_len + word_len + 1 > fillcol)){
  	    if(!isspace((unsigned char) line_last))
  	      linsert(1, ' ');
!           if (line_len && (line_len != qlenis))
!              (void) fpnewline(qstr);
  	}
  	else if(line_len && !isspace((unsigned char) line_last))
  	  linsert(1, ' ');
***************
*** 640,644 ****
--- 1735,1849 ----
      for(len = 0; quote && *quote; quote++, len++)
        linsert(1, *quote);
  
+     quote -= len;		/* go back */
+     len = strlenis(quote);	/* and recount */
      return(len);
  }
+ 
+ int
+ is_indent (word, plb)
+   char word[NSTRING];
+   int  plb;
+ {
+   int i = 0, finished = 0, c, nxt, j, k, digit = 0, bdigits = -1;
+ 
+    if (!word || !word[0])
+       return i;
+ 
+    for (i = 0, j = 0; isspace((unsigned char) word[i]); i++, j++);
+    while ((i < NSTRING - 2) && !finished){
+ 	switch (c = now(word,i)){
+ 	    case TAB:
+ 	    case ' ': for (; isspace((unsigned char )word[i]); i++);
+ 		      if (!is_indent_char(now(word,i)))
+ 			finished++;
+ 		   break;
+ 
+ 	    case '+' :
+ 	    case '.' :
+ 	    case ']' :
+ 	    case '*' :
+ 	    case '}' :
+ 	    case '-' :
+ 	    case RPAREN:
+ 		   nxt = next(word,i);
+ 	           if (((c == '.') && allowed_after_period(nxt))
+ 			|| ((c == '*') && allowed_after_star(nxt))
+ 		        || ((c == '}') && allowed_after_braces(nxt))
+ 		        || ((c == '-') && allowed_after_dash(nxt))
+ 		        || ((c == '+') && allowed_after_dash(nxt))
+ 		        || ((c == RPAREN) && allowed_after_parenth(nxt))
+ 		        || ((c == ']') && allowed_after_parenth(nxt)))
+ 		      i++;
+ 		   else
+ 		      finished++;
+ 		   break;
+ 
+ 	    default : if (is_a_digit(c)){
+ 			if (bdigits < 0)
+ 			   bdigits = i;  /* first digit */
+ 			if (plb){
+ 			   for (k = i; is_a_digit(now(word,k)); k++);
+ 			   if (k - bdigits > 2){ /* more than 2 digits? */
+ 			     i = bdigits;	/* too many! */
+ 			     finished++;
+ 			   }
+ 			   else{ 
+ 			     if (allowed_after_digit(now(word,k),word,k))
+ 				i = k;
+ 			     else{
+ 				i = bdigits;
+ 				finished++;
+ 			     }
+ 			   }
+ 			}
+ 			else{
+ 			   i -= (i > 0) ? 1 : 0;
+ 			   finished++;
+ 			}
+ 		      }
+ 		      else
+ 			finished++;
+ 		   break;
+ 	}
+    }
+    if (i == j)
+       i = 0;  /* there must be something more than spaces in an indent string */
+    return i;   
+ }
+ 
+ 
+ /*
+  * If there is an indent string this function returns 
+  * its length
+  */
+ int
+ indent_match(q, l, buf, buflen, raw)
+     char *q;
+     LINE *l;
+     char *buf;
+     int   buflen;
+     int   raw;
+ {
+     char GLine[NSTRING] = {0};
+     int  i, j, k, plb;
+ 
+     k = quote_match(q,l, buf, buflen, raw);
+ 
+     linencpy(GLine, l, NSTRING);
+ 
+     plb = (lback(l) != curbp->b_linep) ? lisblank(lback(l)) : 1;
+     if (!plb){
+ 	i = llength(lback(l)) - 1;
+         for (; i >= 0 && isspace((unsigned char)lgetc(lback(l), i).c); i--);
+ 	if (EOLchar(lgetc(lback(l), i).c))
+ 	   plb++;
+     }
+ 
+     i = is_indent(GLine+k, plb);
+ 
+     for (j = 0; (j < i) && (buf[j] = GLine[j + k]); j++);
+     buf[j] = '\0';
+ 
+     return i;
+ }
diff -rc pine4.61/pine/addrbook.c pine4.61.I.USE/pine/addrbook.c
*** pine4.61/pine/addrbook.c	Tue Apr 20 16:09:58 2004
--- pine4.61.I.USE/pine/addrbook.c	Fri Jul 16 12:05:27 2004
***************
*** 6647,6656 ****
  	 *warped;
  {
      int          find_result, rc, flags;
      static char  search_string[MAX_SEARCH + 1] = { '\0' };
      char         prompt[MAX_SEARCH + 50], nsearch_string[MAX_SEARCH+1];
      HelpType	 help;
!     ESCKEY_S     ekey[4];
      PerAddrBook *pab;
      long         nl;
  
--- 6647,6657 ----
  	 *warped;
  {
      int          find_result, rc, flags;
+     static char  last_search_string[MAX_SEARCH + 1] = { '\0' };
      static char  search_string[MAX_SEARCH + 1] = { '\0' };
      char         prompt[MAX_SEARCH + 50], nsearch_string[MAX_SEARCH+1];
      HelpType	 help;
!     ESCKEY_S     ekey[5];
      PerAddrBook *pab;
      long         nl;
  
***************
*** 6665,6681 ****
      ekey[0].name  = "";
      ekey[0].label = "";
  
!     ekey[1].ch    = ctrl('Y');
!     ekey[1].rval  = 10;
!     ekey[1].name  = "^Y";
!     ekey[1].label = "First Adr";
! 
!     ekey[2].ch    = ctrl('V');
!     ekey[2].rval  = 11;
!     ekey[2].name  = "^V";
!     ekey[2].label = "Last Adr";
  
!     ekey[3].ch    = -1;
  
      flags = OE_APPEND_CURRENT | OE_KEEP_TRAILING_SPACE;
      while(1){
--- 6666,6687 ----
      ekey[0].name  = "";
      ekey[0].label = "";
  
!     ekey[1].ch    = ctrl('N');
!     ekey[1].rval  = 9;
!     ekey[1].name  = "^N";
!     ekey[1].label = "Ins Pat";
! 
!     ekey[2].ch    = ctrl('Y');
!     ekey[2].rval  = 10;
!     ekey[2].name  = "^Y";
!     ekey[2].label = "First Adr";
! 
!     ekey[3].ch    = ctrl('V');
!     ekey[3].rval  = 11;
!     ekey[3].name  = "^V";
!     ekey[3].label = "Last Adr";
  
!     ekey[4].ch    = -1;
  
      flags = OE_APPEND_CURRENT | OE_KEEP_TRAILING_SPACE;
      while(1){
***************
*** 6686,6691 ****
--- 6692,6700 ----
              help = help == NO_HELP ? h_oe_searchab : NO_HELP;
              continue;
          }
+ 	else if(rc == 9)
+ 	     insert_pattern_in_string(nsearch_string, last_search_string
+ 						    , MAX_SEARCH);
  	else if(rc == 10){
  	    *warped = 1;
  	    warp_to_beginning();  /* go to top of addrbooks */
***************
*** 6713,6719 ****
  	    }
  	}
  
!         if(rc != 4)
            break;
      }
  
--- 6722,6728 ----
  	    }
  	}
  
!         if(rc != 4 && rc != 9)
            break;
      }
  
***************
*** 6726,6731 ****
--- 6735,6743 ----
          search_string[sizeof(search_string)-1] = '\0';
      }
  
+     strncpy(last_search_string, nsearch_string, sizeof(last_search_string));
+     last_search_string[sizeof(last_search_string)-1] = '\0';
+      
      find_result = find_in_book(cur_line, search_string, new_line, wrapped);
      
      if(*wrapped == 1)
diff -rc pine4.61/pine/adrbkcmd.c pine4.61.I.USE/pine/adrbkcmd.c
*** pine4.61/pine/adrbkcmd.c	Mon Jul 12 19:26:14 2004
--- pine4.61.I.USE/pine/adrbkcmd.c	Fri Jul 16 11:50:43 2004
***************
*** 3865,3870 ****
--- 3865,3872 ----
  	 * won't do anything, but will cause compose_mail to think there's
  	 * already a role so that it won't try to confirm the default.
  	 */
+ 	if (ps_global->role)
+ 	   fs_give((void **)&ps_global->role);
  	if(role)
  	  role = copy_action(role);
  	else{
***************
*** 3872,3877 ****
--- 3874,3880 ----
  	    memset((void *)role, 0, sizeof(*role));
  	    role->nick = cpystr("Default Role");
  	}
+ 	ps_global->role = cpystr(role->nick);
      }
  
      compose_mail(addr, fcc, role, NULL, NULL);
diff -rc pine4.61/pine/args.c pine4.61.I.USE/pine/args.c
*** pine4.61/pine/args.c	Fri Oct 10 14:05:32 2003
--- pine4.61.I.USE/pine/args.c	Fri Jul 16 11:56:03 2004
***************
*** 74,79 ****
--- 74,80 ----
  char args_err_non_abs_passfile[] =	"argument to \"-passfile\" should be fully-qualified";
  char args_err_missing_lu[] =		"missing argument for option \"-create_lu\"\nUsage: pine -create_lu <addrbook_file> <addrbook_sort_type>";
  char args_err_missing_sort[] =		"missing argument for option \"-sort\"";
+ char args_err_missing_thread_sort[] = "missing argument for option \"-threadsort\""; 
  char args_err_missing_flag_arg[] =	"missing argument for flag \"%c\"";
  char args_err_missing_flag_num[] =	"Non numeric argument for flag \"%c\"";
  char args_err_missing_debug_num[] =	"Non numeric argument for \"%s\"";
***************
*** 117,122 ****
--- 118,124 ----
  " -z \t\tSuspend - allow use of ^Z suspension",
  " -r \t\tRestricted - can only send mail to oneself",
  " -sort <sort>\tSort - Specify sort order of folder:",
+ " -threadsort <sort>\tSort - Specify sort order of thread index screen:",
  "\t\t       subject, arrival, date, from, size, /reverse",
  " -i\t\tIndex - Go directly to index, bypassing main menu",
  " -I <keystroke_list>   Initial keystrokes to be executed",
***************
*** 202,207 ****
--- 204,210 ----
      char *cmd_list            = NULL;
      char *debug_str           = NULL;
      char *sort                = NULL;
+     char *threadsort          = NULL;
      char *pinerc_file         = NULL;
      char *addrbook_file       = NULL;
      char *ab_sort_descrip     = NULL;
***************
*** 389,394 ****
--- 392,409 ----
  
  		  goto Loop;
  	      }
+               else if(strcmp(*av, "threadsort") == 0){
+                   if(--ac){
+                       threadsort = *++av;
+                       COM_THREAD_SORT_KEY = cpystr(threadsort);
+                   }
+                   else{
+                       display_args_err(args_err_missing_thread_sort, NULL, 1);
+ 		      ++usage;
+ 		  }
+ 
+ 		  goto Loop;
+ 	      }
  	      else if(strcmp(*av, "url") == 0){
  		  if(args->action == aaFolder && !args->data.folder){
  		      args->action = aaURL;
***************
*** 490,495 ****
--- 505,516 ----
  		  do_version = 1;
  		  goto Loop;
  	      }
+               else if(strcmp(*av, "subject") == 0){
+                      if(--ac){
+                         pine_state->subject = cpystr(*++av);
+                         }
+                         goto Loop;
+               }
  #ifdef	_WINDOWS
  	      else if(strcmp(*av, "install") == 0){
  		  ps_global->install_flag = 1;
diff -rc pine4.61/pine/bldaddr.c pine4.61.I.USE/pine/bldaddr.c
*** pine4.61/pine/bldaddr.c	Fri May  7 15:30:06 2004
--- pine4.61.I.USE/pine/bldaddr.c	Fri Jul 16 11:50:43 2004
***************
*** 2306,2313 ****
  	    if(as.cur >= as.how_many_personals)
  	      pab->type |= GLOBAL;
  
! 	    pab->access = adrbk_access(pab);
! 
  	    /* global address books are forced readonly */
  	    if(pab->type & GLOBAL && pab->access != NoAccess)
  	      pab->access = ReadOnly;
--- 2306,2319 ----
  	    if(as.cur >= as.how_many_personals)
  	      pab->type |= GLOBAL;
  
! 	    if(ps_global->mail_stream && 
! 		ps_global->mail_stream->lock && (pab->type & REMOTE_VIA_IMAP)){
! 	      as.initialized = 0;
! 	      pab->access = NoAccess;
! 	    }
! 	    else{
! 	      pab->access = adrbk_access(pab);
! 	    }
  	    /* global address books are forced readonly */
  	    if(pab->type & GLOBAL && pab->access != NoAccess)
  	      pab->access = ReadOnly;
diff -rc pine4.61/pine/filter.c pine4.61.I.USE/pine/filter.c
*** pine4.61/pine/filter.c	Thu Jul  8 16:39:42 2004
--- pine4.61.I.USE/pine/filter.c	Fri Jul 23 09:55:14 2004
***************
*** 204,209 ****
--- 204,213 ----
  		       error_description(errno)));
  		if(source == TmpFileStar)
  		  (void)unlink(so->name);
+                 if (ps_global->send_immediately){
+                    printf("%s : %s\n", so->name, error_description(errno));
+                    exit(1);
+ 		}
  
  		fs_give((void **)&so->name);
  		fs_give((void **)&so); 		/* so freed & set to NULL */
***************
*** 6768,6773 ****
--- 6772,6782 ----
  		margin_r,
  		indent;
      char	special[256];
+     long	curlinenum;	/* current line number */
+     int		curqstrpos;	/* current position in quote string */
+     long	linenum;	/* line number */
+     long	qstrlen;	/* multiples of 100 */
+     char      **qstrln;		/* qstrln[i] = quote string line i - 1 */
  } WRAP_S;
  
  #define	WRAP_MARG_L(F)	(((WRAP_S *)(F)->opt)->margin_l)
***************
*** 6802,6807 ****
--- 6811,6822 ----
  #define	WRAP_COLOR(F)	(((WRAP_S *)(F)->opt)->color)
  #define	WRAP_COLOR_SET(F)  ((WRAP_COLOR(F)) && (WRAP_COLOR(F)->fg[0]))
  #define	WRAP_SPACES(F)	(((WRAP_S *)(F)->opt)->spaces)
+ #define WRAP_CURLINE(F)	(((WRAP_S *)(F)->opt)->curlinenum)
+ #define WRAP_CURPOS(F)	(((WRAP_S *)(F)->opt)->curqstrpos)
+ #define WRAP_LINENUM(F)	(((WRAP_S *)(F)->opt)->linenum)
+ #define WRAP_QSTRLEN(F)	(((WRAP_S *)(F)->opt)->qstrlen)
+ #define WRAP_QSTRN(F)	(((WRAP_S *)(F)->opt)->qstrln)
+ #define WRAP_QSTR(F, N)	(((WRAP_S *)(F)->opt)->qstrln[(N)])
  #define	WRAP_PUTC(F,C,V) {						\
  			    if((F)->linep == WRAP_LASTC(F)){		\
  				size_t offset = (F)->linep - (F)->line;	\
***************
*** 6869,6874 ****
--- 6884,6891 ----
  	      case CCR :				/* CRLF or CR in text ? */
  		state = BOL;				/* either way, handle start */
  
+ 		WRAP_CURLINE(f)++;
+ 		WRAP_CURPOS(f) = 0;
  		if(WRAP_FLOW(f)){
  		    if(f->f2 == 0 && WRAP_SPC_LEN(f)){	/* wrapped line */
  			/*
***************
*** 6960,6966 ****
  
  	      case BOL :
  		if(WRAP_FLOW(f)){
! 		    if(c == '>'){
  			WRAP_FL_QC(f) = 1;		/* init it */
  			state = FL_QLEV;		/* go collect it */
  		    }
--- 6977,6986 ----
  
  	      case BOL :
  		if(WRAP_FLOW(f)){
! 		    if(WRAP_QSTR(f, WRAP_CURLINE(f)) 
! 			&& WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)]
! 			&& WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)] == c){
! 			WRAP_CURPOS(f)++;
  			WRAP_FL_QC(f) = 1;		/* init it */
  			state = FL_QLEV;		/* go collect it */
  		    }
***************
*** 6974,6980 ****
  			}
  
  			/* quote level change implies new paragraph */
! 			if(WRAP_FL_QD(f)){
  			    WRAP_FL_QD(f) = 0;
  			    if(WRAP_HARD(f) == 0){
  				WRAP_HARD(f) = 1;
--- 6994,7009 ----
  			}
  
  			/* quote level change implies new paragraph */
! 			if (WRAP_CURLINE(f) > 0 
! 			&& WRAP_CURLINE(f) < WRAP_QSTRLEN(f)
! 			&& (WRAP_QSTR(f, WRAP_CURLINE(f)) != NULL
! 			     || WRAP_QSTR(f, WRAP_CURLINE(f) - 1) != NULL)
! 			&& ((WRAP_QSTR(f, WRAP_CURLINE(f)) != NULL && 
! 			     WRAP_QSTR(f, WRAP_CURLINE(f) - 1) == NULL)
! 			   || (WRAP_QSTR(f, WRAP_CURLINE(f)) == NULL && 
! 			       WRAP_QSTR(f, WRAP_CURLINE(f) - 1) != NULL)
! 			   || strcmp(WRAP_QSTR(f, WRAP_CURLINE(f)),
! 				     WRAP_QSTR(f, WRAP_CURLINE(f) - 1)))){
  			    WRAP_FL_QD(f) = 0;
  			    if(WRAP_HARD(f) == 0){
  				WRAP_HARD(f) = 1;
***************
*** 7026,7033 ****
  		break;
  
  	      case  FL_QLEV :
! 		if(c == '>'){				/* another level */
! 		    WRAP_FL_QC(f)++;
  		}
  		else {
  		    /* if EMBEDed, process it and return here */
--- 7055,7065 ----
  		break;
  
  	      case  FL_QLEV :
! 		if(WRAP_QSTR(f, WRAP_CURLINE(f)) 
! 		   && WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)]
! 		   && WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)] == c){
! 		    WRAP_CURPOS(f)++;
! 		    WRAP_FL_QC(f)++; 			/* another level */
  		}
  		else {
  		    /* if EMBEDed, process it and return here */
***************
*** 7039,7045 ****
  		    }
  
  		    /* quote level change signals new paragraph */
! 		    if(WRAP_FL_QC(f) != WRAP_FL_QD(f)){
  			WRAP_FL_QD(f) = WRAP_FL_QC(f);
  			if(WRAP_HARD(f) == 0){		/* add hard newline */ 
  			    WRAP_HARD(f) = 1;		/* hard newline */
--- 7071,7086 ----
  		    }
  
  		    /* quote level change signals new paragraph */
! 		    if (WRAP_CURLINE(f) > 0 
! 			&& WRAP_CURLINE(f) < WRAP_QSTRLEN(f)
! 			&& (WRAP_QSTR(f, WRAP_CURLINE(f))
! 			     || WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
! 			&& ((WRAP_QSTR(f, WRAP_CURLINE(f)) && 
! 			     !WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
! 			   || (!WRAP_QSTR(f, WRAP_CURLINE(f)) && 
! 			       WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
! 			   || strcmp(WRAP_QSTR(f, WRAP_CURLINE(f)),
! 				      WRAP_QSTR(f, WRAP_CURLINE(f) - 1)))){
  			WRAP_FL_QD(f) = WRAP_FL_QC(f);
  			if(WRAP_HARD(f) == 0){		/* add hard newline */ 
  			    WRAP_HARD(f) = 1;		/* hard newline */
***************
*** 7112,7118 ****
  					     &eob);      /* note any embedded*/
  			    wrap_eol(f, 1, &ip, &eib,
  				     &op, &eob);       /* plunk down newline */
! 			    wrap_bol(f, 1, 1, &ip, &eib,
  				     &op, &eob);         /* write any prefix */
  			}
  
--- 7153,7159 ----
  					     &eob);      /* note any embedded*/
  			    wrap_eol(f, 1, &ip, &eib,
  				     &op, &eob);       /* plunk down newline */
! 			    wrap_bol(f, 1, WRAP_FLOW(f), &ip, &eib,
  				     &op, &eob);         /* write any prefix */
  			}
  
***************
*** 7417,7423 ****
  		    wrap_flush_embed(f, &ip, &eib, &op, &eob);
  		    wrap_eol(f, 1, &ip, &eib, &op,
  			     &eob);	    /* plunk down newline */
! 		    wrap_bol(f,1,1, &ip, &eib, &op,
  			     &eob);	      /* write any prefix */
  		}
  
--- 7458,7464 ----
  		    wrap_flush_embed(f, &ip, &eib, &op, &eob);
  		    wrap_eol(f, 1, &ip, &eib, &op,
  			     &eob);	    /* plunk down newline */
! 		    wrap_bol(f,1,WRAP_FLOW(f), &ip, &eib, &op,
  			     &eob);	      /* write any prefix */
  		}
  
***************
*** 7475,7480 ****
--- 7516,7528 ----
  	if(WRAP_COLOR(f))
  	  free_color_pair(&WRAP_COLOR(f));
  
+ 	{ long i;
+ 	  for (i = 0L; i < WRAP_QSTRLEN(f); i++)
+ 	      if (WRAP_QSTR(f,i))
+ 		fs_give((void **) &(WRAP_QSTR(f,i)));
+ 	  fs_give((void **)&WRAP_QSTRN(f));
+ 	}
+ 
  	fs_give((void **) &f->line);	/* free temp line buffer */
  	so_give(&WRAP_SPACES(f));
  	fs_give((void **) &f->opt);	/* free wrap widths struct */
***************
*** 7782,7793 ****
      unsigned char **opp;
      unsigned char **eobp;
  {
!     int j;
      COLOR_PAIR *col = NULL;
!     for(j = 0; j < WRAP_FL_QD(f); j++){
! 	f->n += (WRAP_LV_FLD(f) ? 1 : 2);
  	if(WRAP_USE_CLR(f)){
! 	    if((j % 3) == 0
  	       && ps_global->VAR_QUOTE1_FORE_COLOR
  	       && ps_global->VAR_QUOTE1_BACK_COLOR
  	       && (col = new_color_pair(ps_global->VAR_QUOTE1_FORE_COLOR,
--- 7830,7845 ----
      unsigned char **opp;
      unsigned char **eobp;
  {
!     char *wrap_qstr = cpystr(WRAP_QSTR(f, WRAP_CURLINE(f)));
!     int j, level = 0, oldj, k;
!     int len = wrap_qstr ? strlen(wrap_qstr) : 0;
      COLOR_PAIR *col = NULL;
!     for (j = 0; len && isspace((unsigned char)wrap_qstr[j]); j++); 
!     for(; j < len && level < len; level++){
! 	oldj = j;
! 	j = next_level_quote(wrap_qstr, (char **)NULL, j, WRAP_FLOW(f));
  	if(WRAP_USE_CLR(f)){
! 	    if((level % 3) == 0
  	       && ps_global->VAR_QUOTE1_FORE_COLOR
  	       && ps_global->VAR_QUOTE1_BACK_COLOR
  	       && (col = new_color_pair(ps_global->VAR_QUOTE1_FORE_COLOR,
***************
*** 7795,7801 ****
  	       && pico_is_good_colorpair(col)){
                  GF_COLOR_PUTC(f, col);
              }
! 	    else if((j % 3) == 1
  		    && ps_global->VAR_QUOTE2_FORE_COLOR
  		    && ps_global->VAR_QUOTE2_BACK_COLOR
  		    && (col = new_color_pair(ps_global->VAR_QUOTE2_FORE_COLOR,
--- 7847,7853 ----
  	       && pico_is_good_colorpair(col)){
                  GF_COLOR_PUTC(f, col);
              }
! 	    else if((level % 3) == 1
  		    && ps_global->VAR_QUOTE2_FORE_COLOR
  		    && ps_global->VAR_QUOTE2_BACK_COLOR
  		    && (col = new_color_pair(ps_global->VAR_QUOTE2_FORE_COLOR,
***************
*** 7803,7809 ****
  		    && pico_is_good_colorpair(col)){
  	        GF_COLOR_PUTC(f, col);
              }
! 	    else if((j % 3) == 2
  		    && ps_global->VAR_QUOTE3_FORE_COLOR
  		    && ps_global->VAR_QUOTE3_BACK_COLOR
  		    && (col = new_color_pair(ps_global->VAR_QUOTE3_FORE_COLOR,
--- 7855,7861 ----
  		    && pico_is_good_colorpair(col)){
  	        GF_COLOR_PUTC(f, col);
              }
! 	    else if((level % 3) == 2
  		    && ps_global->VAR_QUOTE3_FORE_COLOR
  		    && ps_global->VAR_QUOTE3_BACK_COLOR
  		    && (col = new_color_pair(ps_global->VAR_QUOTE3_FORE_COLOR,
***************
*** 7816,7829 ****
  		col = NULL;
  	    }
  	}
! 	GF_PUTC_GLO(f->next, '>');
! 	if(!WRAP_LV_FLD(f))
! 	  GF_PUTC_GLO(f->next, ' ');
      }
      if(j && WRAP_LV_FLD(f)){
  	GF_PUTC_GLO(f->next, ' ');
  	f->n++;
      }
  
      return 0;
  }
--- 7868,7889 ----
  		col = NULL;
  	    }
  	}
! 	if(!WRAP_LV_FLD(f)){
! 	  for (k = oldj; k < j; k++)
! 	     GF_PUTC_GLO(f->next, wrap_qstr[k]);
! 	}
! 	GF_PUTC_GLO(f->next, WRAP_LV_FLD(f) ? '>' : ' ');
! 	f->n += (WRAP_LV_FLD(f) ? 0 : j - oldj) + 1;
! 	for (; isspace((unsigned char)wrap_qstr[j]); j++);
      }
      if(j && WRAP_LV_FLD(f)){
  	GF_PUTC_GLO(f->next, ' ');
  	f->n++;
      }
+     if (wrap_qstr){
+       f->n += strlenis(wrap_qstr) + (WRAP_LV_FLD(f) ? 0 : level);
+       fs_give((void **)&wrap_qstr);
+     } 
  
      return 0;
  }
***************
*** 7855,7860 ****
--- 7915,7926 ----
      wrap->leave_flowed = (GFW_FLOW_RESULT & flags) == GFW_FLOW_RESULT;
      wrap->delsp	       = (GFW_DELSP & flags) == GFW_DELSP;
      wrap->use_color    = (GFW_USECOLOR & flags) == GFW_USECOLOR;
+     wrap->curlinenum   = 0L;
+     wrap->curqstrpos   = 0;
+     wrap->linenum      = 0L;
+     wrap->qstrlen      = 100L;
+     wrap->qstrln       = (char **) fs_get(100*sizeof(char *));
+     memset(wrap->qstrln, 0, 100*sizeof(char *));
  
      return((void *) wrap);
  }
***************
*** 8028,8034 ****
--- 8094,8276 ----
  			    } \
  			}
  
+ #define ADD_QUOTE_STRING(F) {						\
+ 	int len = tmp_20k_buf[0] ? strlen(tmp_20k_buf) + 1 : 0;		\
+ 	FILTER_S *fltr;							\
+ 									\
+ 	for(fltr = (F); fltr && fltr->f != gf_wrap; fltr = fltr->next);\
+ 	if (fltr){							\
+ 	   if (WRAP_LINENUM(fltr) >= WRAP_QSTRLEN(fltr)){		\
+ 	      fs_resize((void **)&WRAP_QSTRN(fltr),			\
+ 			(WRAP_QSTRLEN(fltr) + 100) * sizeof(char *));	\
+ 	      memset(WRAP_QSTRN(fltr)+WRAP_QSTRLEN(fltr), 0, 		\
+ 						100*sizeof(char*));	\
+ 	      WRAP_QSTRLEN(fltr) += 100L;				\
+ 	   }								\
+ 	   if (len){							\
+ 	      WRAP_QSTR(fltr, WRAP_LINENUM(fltr)) = 			\
+ 				(char *) fs_get(len*sizeof(char));	\
+ 	      WRAP_QSTR(fltr, WRAP_LINENUM(fltr)) = cpystr(tmp_20k_buf);\
+ 	   }								\
+ 	   WRAP_LINENUM(fltr)++;					\
+ 	}								\
+ }
+ 
+ #define GF_ADD_QUOTED_LINE(F, line) \
+ 		{ \
+ 		    LT_INS_S	  *ins = NULL, *insp; \
+ 		    unsigned char  ch;\
+ 		    register char *cp;\
+ 		    register int   l;\
+ 			\
+ 		    if (line){\
+ 			turn_flowed_off =(*((LINETEST_S *) (F)->opt)->f)((F)->n++,\
+ 					    line, &ins,\
+ 					   ((LINETEST_S *) (F)->opt)->local);\
+ 			ADD_QUOTE_STRING((F));\
+ 			for(insp = ins,  cp = line; *cp ; ){\
+ 			    while(insp && cp == insp->where){\
+ 			       for(l = 0; l < insp->len; l++){\
+ 				  ch =  (unsigned char) insp->text[l];\
+ 				  GF_PUTC((F)->next, ch);\
+ 			       }\
+ 			       insp = insp->next;\
+ 			    }\
+ 			    GF_PUTC((F)->next, *cp);\
+ 			    cp++;\
+ 			}\
+ 			while(insp){\
+ 			    for(l = 0; l < insp->len; l++){\
+ 			       ch = (unsigned char) insp->text[l];\
+ 			       GF_PUTC((F)->next, ch);\
+ 			    }\
+ 			    insp = insp->next;\
+ 			}\
+ 			gf_line_test_free_ins(&ins);\
+ 		   }\
+ 		   GF_PUTC(f->next, '\015');\
+ 		   GF_PUTC(f->next, '\012');\
+ 		}
+ /* test second line of old line first */
+ #define SECOND_LINE_QUOTE_TEST(oldline, line, F) \
+ 		{\
+ 		   *p = '\0';\
+ 		   for (i = 0; oldline[i] && oldline[i] != '\015'; i++);\
+ 			if (oldline[i]){\
+ 			   i += (oldline[i+1] == '\012') ? 2 : 1;\
+ 			   line = oldline + i;\
+ 			}\
+ 		        for (i = 0; ((F)->line) && ((F)->line)[i] \
+ 				   && (i < LINE_TEST_BLOCK) \
+ 			      	   && (i < SIZEOF_20KBUF)\
+ 				   && (((F)->line)[i] != '\015')\
+ 				   && (((F)->line)[i] != '\012')\
+ 				   && (tmp_20k_buf[i] = ((F)->line)[i]); i++);\
+ 			tmp_20k_buf[i] = '\0';\
+ 			GF_ADD_QUOTED_LINE(F, line);\
+ 		}
+ 
+ #define FIRST_LINE_QUOTE_TEST(oldline, line, F)\
+ 		{\
+ 		    *p = '\0';\
+ 		    line = (F)->line;\
+ 		    oldline = cpystr(line);\
+ 		    for (i = 0; line[i] && line[i] != '\015' \
+ 				&& line[i] != '\012'; i++);  \
+ 		    if (line[i]){\
+ 			(line[i]) = '\0';\
+ 			i+= (line[i+1] == '\012') ? 2 : 1;\
+ 		    }\
+ 		    for (j = 0; ((F)->line) && ((F)->line)[i + j] \
+ 			   && (((F)->line)[i + j] != '\015')\
+ 			   && (((F)->line)[i + j] != '\012')\
+ 			   && (tmp_20k_buf[j] = ((F)->line)[i + j])\
+ 			  ; j++);\
+ 		    tmp_20k_buf[j] = '\0';\
+ 		    GF_ADD_QUOTED_LINE(F, line);\
+ 		}
+ 
+ 
+ void
+ gf_quote_test(f, flg)
+     FILTER_S *f;
+     int	      flg;
+ {
+     register char *p = f->linep;
+     register char *eobuf = GF_LINE_TEST_EOB(f);
+     static char *oldline = NULL;
+     char *line = NULL;
+     int i, j, done = 0, turn_flowed_off;
+     GF_INIT(f, f->next);
+ 
+     if(flg == GF_DATA){
+ 	register unsigned char c;
+ 	register int state = f->f1;
+ 	register int nlste = f->f3; /* new line state */
+ 
+ 	while(GF_GETC(f, c)){
+ 
+ 	    if(state == 2){		/* two full lines read */
+ 		state = nlste = 0;
  
+ 		/* first process the second line of an old line */
+ 		if (oldline && oldline[0])
+ 		    SECOND_LINE_QUOTE_TEST(oldline, line, f);
+ 
+ 		/* now we process the first line */
+ 		FIRST_LINE_QUOTE_TEST(oldline, line, f);
+ 
+ 		p = (f)->line;
+ 		continue;
+ 	    }
+ 	    if(c == '\015'){
+ 	      state++;
+ 	      if (state == 1)
+ 		 GF_LINE_TEST_ADD(f, c);
+ 	    }
+ 	    else
+ 	      GF_LINE_TEST_ADD(f, c);
+ 	}
+ 
+ 	f->f1 = state;
+ 	f->f3 = nlste;
+ 	GF_END(f, f->next);
+     }
+     else if(flg == GF_EOD){
+         /* first process the second line of an old line */
+ 	if (oldline && oldline[0])
+ 	    SECOND_LINE_QUOTE_TEST(oldline, line, f);
+ 
+ 	/* now we process the first line */
+ 	FIRST_LINE_QUOTE_TEST(oldline, line, f);
+ 
+ 	/* We are out of data. In this case we have processed the second
+ 	 * line of an oldline, then the first line of a line, but we need
+ 	 * to process the second line of the given line. We do this by
+ 	 * processing it now!.
+ 	 */
+ 	if (line[i]){
+ 	   tmp_20k_buf[0] = '\0';	/* No next line */
+ 	   GF_ADD_QUOTED_LINE(f, line+i);
+ 	}
+         if (oldline)
+ 	   fs_give((void **) &oldline);
+ 	fs_give((void **) &f->line);	/* free line buffer */
+ 	fs_give((void **) &f->opt);	/* free test struct */
+ 	GF_FLUSH(f->next);
+ 	(*f->next->f)(f->next, GF_EOD);
+     }
+     else if(flg == GF_RESET){
+ 	dprint(9, (debugfile, "-- gf_reset line_test\n"));
+ 	f->f1 = 0;			/* state */
+ 	f->n  = 0L;			/* line number */
+ 	f->f2 = LINE_TEST_BLOCK;	/* size of alloc'd line */
+ 	f->f3 = 0;			/* state for new line   */
+ 	f->line = p = (char *) fs_get(f->f2 * sizeof(char));
+     }
+ 
+     f->linep = p;
+ }
  
  /*
   * this simple filter accumulates characters until a newline, offers it
***************
*** 8053,8059 ****
  	    if(state){
  		state = 0;
  		if(c == '\012'){
! 		    int done;
  
  		    GF_LINE_TEST_TEST(f, done);
  
--- 8295,8306 ----
  	    if(state){
  		state = 0;
  		if(c == '\012'){
! 		    int done, i, j = 0;
! 
! 		    for (i = 0; op && op[i] && (i < LINE_TEST_BLOCK) &&
! 				(i < SIZEOF_20KBUF) && (op[i] != '\015') &&
! 				(tmp_20k_buf[i] = op[i]); i++);
! 		    tmp_20k_buf[i] = '\0';
  
  		    GF_LINE_TEST_TEST(f, done);
  
***************
*** 8115,8120 ****
--- 8362,8368 ----
      else if(flg == GF_EOD){
  	int i;
  
+ 	tmp_20k_buf[0] = '\0';
  	GF_LINE_TEST_TEST(f, i);	/* examine remaining data */
  	fs_give((void **) &f->line);	/* free line buffer */
  	fs_give((void **) &f->opt);	/* free test struct */
diff -rc pine4.61/pine/folder.c pine4.61.I.USE/pine/folder.c
*** pine4.61/pine/folder.c	Mon Jul 12 19:26:16 2004
--- pine4.61.I.USE/pine/folder.c	Thu Jul 29 10:15:29 2004
***************
*** 94,100 ****
  #define	FLW_SLCT	0x02
  #define	FLW_LIST	0x04
  
! 
  
  
  /*----------------------------------------------------------------------
--- 94,100 ----
  #define	FLW_SLCT	0x02
  #define	FLW_LIST	0x04
  
! static int max_slot_size = 0;
  
  
  /*----------------------------------------------------------------------
***************
*** 224,229 ****
--- 224,230 ----
  				   gf_io_t, HANDLE_S **, int));
  int	   folder_list_write_folder PROTO((gf_io_t, CONTEXT_S *,
  					   int, char *, int));
+ int	   folder_list_write_count PROTO((FOLDER_S *, CONTEXT_S *, gf_io_t, int));
  int	   folder_list_write_prefix PROTO((FOLDER_S *, int, gf_io_t));
  int	   folder_list_ith PROTO((int, CONTEXT_S *));
  char	  *folder_list_center_space PROTO((char *, int));
***************
*** 468,474 ****
  
  	HELP_MENU,
  	OTHER_MENU,
! 	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
--- 469,475 ----
  
  	HELP_MENU,
  	OTHER_MENU,
!         {"^H","ChkIncFld",{MC_FORCECHECK,1,ctrl('H')}, KS_NONE},
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
***************
*** 1681,1686 ****
--- 1682,1688 ----
      gf_io_t	pc;
  
      dprint(1, (debugfile, "\n\n    ---- FOLDER LISTER ----\n"));
+     ps->in_fld_list = 1;
  
      memset(&folder_proc_data, 0, sizeof(FPROC_S));
      folder_proc_data.fs = fs;
***************
*** 1801,1806 ****
--- 1803,1809 ----
      if(folder_proc_data.all_done)
        fs->context = NULL;
  
+     ps->in_fld_list = 0;
      return(folder_proc_data.rv);
  }
  
***************
*** 1914,1919 ****
--- 1917,1934 ----
  		gf_puts("\n", pc);
  	    }
  
+ 	    if (c_list->use & CNTXT_INCMNG &&
+ 		F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 		F_ON(F_ENABLE_INCOMING,ps_global) &&
+ 		F_OFF(F_ENABLE_FAST_RECENT, ps_global)){
+ 		sprintf(tmp_20k_buf, 
+ 		   "Format: Folder-name [Total New Messages/Total Messages]");
+ 		gf_puts(folder_list_center_space(tmp_20k_buf, cols), pc);
+ 		gf_puts(tmp_20k_buf, pc);
+ 		gf_puts("\n", pc);
+ 	    }
+ 
+ 
  	    gf_puts(repeat_char(cols, '-'), pc);
  	    gf_puts("\n\n", pc);
  	}
***************
*** 1951,1958 ****
--- 1966,1986 ----
  		    else if(c_list == fp->fs->list_cntxt)
  		      len += 4;			/* "[X] " */
  
+ 		    if (c_list->use & CNTXT_INCMNG &&
+ 			F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 			F_ON(F_ENABLE_INCOMING,ps_global) &&
+ 			F_OFF(F_ENABLE_FAST_RECENT, ps_global))
+ 			if (need_folder_report(FLDR_NAME(f))){
+ 			   len += 5;		/* "[/]" + "  " */
+ 			   len += strlen(comatose(f->countrecent));
+ 			   len += strlen(comatose(f->messages));
+ 			}
+ 			else
+ 			   len += 1;
+ 
  		    if(slot_size < len)
  		      slot_size = len;
+ 		    max_slot_size = slot_size;
  		}
  
  		if(F_ON(F_SINGLE_FOLDER_LIST, ps_global)){
***************
*** 2057,2063 ****
      int	       flags;
  {
      char      buf[256];
!     int	      l = 0;
      FOLDER_S *fp;
      HANDLE_S *h;
  
--- 2085,2091 ----
      int	       flags;
  {
      char      buf[256];
!     int	      l = 0, s = 0;
      FOLDER_S *fp;
      HANDLE_S *h;
  
***************
*** 2080,2085 ****
--- 2108,2114 ----
  	     && (*pc)(strlen(buf)) && gf_puts(buf, pc)) : 1)
         && (fp ? ((l = folder_list_write_prefix(fp, flags, pc)) >= 0
  		 && gf_puts(FLDR_NAME(fp), pc)
+ 		 && (s = folder_list_write_count(fp, ctxt, pc, l)) >= 0
  		 && ((fp->isdir && fp->isfolder) ? (*pc)('[') : 1)
  		 && ((fp->isdir) ? (*pc)(ctxt->dir->delim) : 1)
  		 && ((fp->isdir && fp->isfolder) ? (*pc)(']') : 1))
***************
*** 2087,2093 ****
         && (h ? ((*pc)(TAG_EMBED) && (*pc)(TAG_BOLDOFF)
  		&& (*pc)(TAG_EMBED) && (*pc)(TAG_INVOFF)) : 1)){
  	if(fp){
! 	    l += strlen(FLDR_NAME(fp));
  	    if(fp->isdir)
  	      l += (fp->isfolder) ? 3 : 1;
  	}
--- 2116,2122 ----
         && (h ? ((*pc)(TAG_EMBED) && (*pc)(TAG_BOLDOFF)
  		&& (*pc)(TAG_EMBED) && (*pc)(TAG_INVOFF)) : 1)){
  	if(fp){
! 	    l += strlen(FLDR_NAME(fp)) + s;
  	    if(fp->isdir)
  	      l += (fp->isfolder) ? 3 : 1;
  	}
***************
*** 2098,2103 ****
--- 2127,2162 ----
      return(l);
  }
  
+ int
+ folder_list_write_count(f, ctxt, pc, l)
+     FOLDER_S *f;
+     CONTEXT_S *ctxt;
+     gf_io_t   pc;
+     int	      l;
+ {
+     int rv = 0, i;
+     int offset = 1;
+ 
+     if (ctxt->use & CNTXT_INCMNG &&
+ 	F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 	F_ON(F_ENABLE_INCOMING,ps_global) &&
+ 	F_OFF(F_ENABLE_FAST_RECENT, ps_global) && 
+ 	need_folder_report(FLDR_NAME(f))){
+ 	   rv  = max_slot_size - strlen(FLDR_NAME(f)) - l;
+ 	   rv -= strlen(comatose(f->countrecent));
+  	   rv -= strlen(comatose(f->messages));
+ 	   rv -= 5 + offset;
+ 	   for (i = 0; i <= rv; i++) gf_puts(" ", pc);
+ 	   gf_puts("[", pc);
+ 	   gf_puts(comatose(f->countrecent), pc);
+ 	   gf_puts("/", pc);
+ 	   gf_puts(comatose(f->messages), pc);
+ 	   gf_puts("]", pc);
+ 	   rv = max_slot_size - strlen(FLDR_NAME(f)) - l - offset -1;
+     }
+     return rv;
+ }
+ 
  
  int
  folder_list_write_prefix(f, flags, pc)
***************
*** 2415,2421 ****
  			   "Empty folder collection.  No folder to rename!");
  
  	break;
! 		     
  
              /*-------------- Delete --------------------*/
        case MC_DELETE :
--- 2474,2489 ----
  			   "Empty folder collection.  No folder to rename!");
  
  	break;
! 
! 
! 		/*------- Check incoming forlders -------*/
!       case MC_FORCECHECK:
! 	   ps_global->force_check_now = 1;
! 	   rv = (new_mail_incfolder(ps_global,MC_FORCECHECK) &&
! 		 ps_global->refresh_list > 0) ? 1 : 0;
! 	   ps_global->refresh_list = 0;
! 	break;
! 
  
              /*-------------- Delete --------------------*/
        case MC_DELETE :
***************
*** 3205,3212 ****
  	  case 'f' :			/* flip selection */
  	    n = folder_total(FOLDERS(context));
  	    for(total = i = 0; i < n; i++)
! 	      if(f = folder_entry(i, FOLDERS(context)))
  		f->selected = !f->selected;
  
  	    return(1);			/* repaint */
  
--- 3273,3282 ----
  	  case 'f' :			/* flip selection */
  	    n = folder_total(FOLDERS(context));
  	    for(total = i = 0; i < n; i++)
! 	      if(f = folder_entry(i, FOLDERS(context))){
  		f->selected = !f->selected;
+ 		f->user_selected = f->selected;
+ 	      }
  
  	    return(1);			/* repaint */
  
***************
*** 3349,3363 ****
      CONTEXT_S *context;
  {
      int	      i, n, total;
  
      n = folder_total(FOLDERS(context));
!     for(total = i = 0; i < n; i++)
!       if(folder_entry(i, FOLDERS(context))->selected)
  	total++;
  
      return(total);
  }
  
  
  SELECTED_S *
  new_selected()
--- 3419,3478 ----
      CONTEXT_S *context;
  {
      int	      i, n, total;
+     FOLDER_S  *f;
  
      n = folder_total(FOLDERS(context));
!     for(total = i = 0; i < n; i++){
!       f = folder_entry(i, FOLDERS(context));
!       if(f->selected) 
  	total++;
+     }
  
      return(total);
  }
  
+ void
+ update_incoming_folder_data(stream, context)
+  MAILSTREAM *stream;
+  CONTEXT_S  *context;
+ {
+  FOLDER_S *f = incoming_folder_data(stream, context);
+ 
+   if(f){
+      f->origrecent = f->recent = stream->recent;
+      f->messages   = stream->nmsgs;
+   }
+ }
+ 
+ 
+ FOLDER_S *
+ incoming_folder_data(stream, cntxt)
+  MAILSTREAM *stream;
+  CONTEXT_S  *cntxt;
+ {
+    long index, total;
+    FOLDER_S *f = NULL;
+ 
+    if (cntxt && cntxt->use & CNTXT_INCMNG){
+       total = folder_total(FOLDERS(cntxt));
+       for (index = 0L; index < total ; index++){ 
+ 	 f = folder_entry(index, FOLDERS(cntxt));
+ 	 if (!strcmp(STREAMNAME(stream), FLDR_NAME(f)))
+ 	     break;
+       }
+    }
+    return f;
+ }
+ 
+ int
+ need_folder_report(folder)
+   char *folder;
+ {
+   return (ps_global->VAR_INCOMING_FOLDERS_CHECK &&
+ 	 ((ps_global->VAR_INCOMING_FOLDERS_CHECK[0] == '*') ||
+ 	  strstr(ps_global->VAR_INCOMING_FOLDERS_CHECK, folder)));
+ }
+ 
  
  SELECTED_S *
  new_selected()
***************
*** 4087,4092 ****
--- 4202,4208 ----
  
      if(f = folder_entry(index, FOLDERS(context))){
        f->selected = !f->selected;
+       f->user_selected = f->selected;
        return((*func)(context, index));
      }
      return 1;
***************
*** 5752,5759 ****
      }
      else{
  	sprintf(ques_buf, "DELETE \"%.100s\"%s", folder, 
! 		close_opened ? " (the currently open folder)"
! 			     : fp->isdir ? " (a directory)" : "");
  
  	if((ret = want_to(ques_buf, 'n', 'x', NO_HELP, WT_NORM)) != 'y'){
  	    q_status_message(SM_ORDER,0,3, (ret == 'x') ? "Delete cancelled" 
--- 5868,5877 ----
      }
      else{
  	sprintf(ques_buf, "DELETE \"%.100s\"%s", folder, 
! 	(!fp->isfolder || (fp->isdir && !close_opened)) 
! 			? " (a directory) "
! 			: close_opened ? " (the currently open folder) "
! 				       : "");
  
  	if((ret = want_to(ques_buf, 'n', 'x', NO_HELP, WT_NORM)) != 'y'){
  	    q_status_message(SM_ORDER,0,3, (ret == 'x') ? "Delete cancelled" 
***************
*** 5787,5793 ****
  	   && context_same_stream(context, fp->name, *possible_streamp))
  	  del_stream = *possible_streamp;
  
! 	if(!fp->isfolder)
  	  sprintf(fnamep = fname, "%.*s%c", sizeof(fname)-3, fp->name,
  		  context->dir->delim);
  	else
--- 5905,5911 ----
  	   && context_same_stream(context, fp->name, *possible_streamp))
  	  del_stream = *possible_streamp;
  
! 	if(!fp->isfolder || (fp->isdir && !close_opened))
  	  sprintf(fnamep = fname, "%.*s%c", sizeof(fname)-3, fp->name,
  		  context->dir->delim);
  	else
***************
*** 5803,5810 ****
      }
  
      q_status_message2(SM_ORDER, 0, 3, "%.200s \"%.200s\" deleted.",
! 		      blast_folder ? "Folder" : "Nickname", folder);
! 
  
      if(context->use & CNTXT_INCMNG){
  	char **new_list, **lp, ***alval;
--- 5921,5930 ----
      }
  
      q_status_message2(SM_ORDER, 0, 3, "%.200s \"%.200s\" deleted.",
! 		      blast_folder 
! 	? (!fp->isfolder || (fp->isdir && !close_opened)) 
! 		? "Directory" : "Folder" 
! 	: "Nickname", folder);
  
      if(context->use & CNTXT_INCMNG){
  	char **new_list, **lp, ***alval;
***************
*** 7098,7103 ****
--- 7218,7226 ----
      FOLDERS(context) = init_folder_entries();
      init_incoming_folder_list(ps_global, context);
      init_inbox_mapping(ps_global->VAR_INBOX_PATH, context);
+     ps_global->force_check_now = 1;	/* sorry about this */
+     new_mail_incfolder(ps_global,MC_FORCECHECK);
+     ps_global->refresh_list += 1;
  }
  
  
***************
*** 8259,8269 ****
      long	*find_recent;
      int         *did_cancel;
  {
!     int       index, recent = 0, failed_status = 0, try_fast;
      char      prompt[128];
      FOLDER_S *f = NULL;
      char      tmp[MAILTMPLEN];
! 
  
      /* note: find_folders may assign "stream" */
      build_folder_list(streamp, cntxt, NULL, NULL,
--- 8382,8398 ----
      long	*find_recent;
      int         *did_cancel;
  {
!     int       index, recent = 0, failed_status = 0, try_fast, done = 0;
      char      prompt[128];
      FOLDER_S *f = NULL;
      char      tmp[MAILTMPLEN];
!     char *test_current = cpystr(current);
!     int  cur_indx  = folder_index(ps_global->cur_folder, cntxt, FI_FOLDER);
!     int  loop = !strcmp(next, ps_global->cur_folder) ? 0 :
!               (folder_index(test_current, cntxt, FI_FOLDER) <= cur_indx
!                       ? 1 : 0);
!     int  last = !strcmp(ps_global->cur_folder, ps_global->inbox_name)
!                ? 1 : cur_indx;
  
      /* note: find_folders may assign "stream" */
      build_folder_list(streamp, cntxt, NULL, NULL,
***************
*** 8274,8280 ****
      if(find_recent)
        *find_recent = 0L;
  
!     for(index = folder_index(current, cntxt, FI_FOLDER) + 1;
  	index > 0
  	&& index < folder_total(FOLDERS(cntxt))
  	&& (f = folder_entry(index, FOLDERS(cntxt)))
--- 8403,8411 ----
      if(find_recent)
        *find_recent = 0L;
  
! 
! find_new_message:
!     for(index = folder_index(test_current, cntxt, FI_FOLDER) + 1;
  	index > 0
  	&& index < folder_total(FOLDERS(cntxt))
  	&& (f = folder_entry(index, FOLDERS(cntxt)))
***************
*** 8285,8290 ****
--- 8416,8426 ----
  	  int         rv, we_cancel = 0, mlen, match;
  	  char        msg_buf[MAX_BM+1], mbuf[MAX_BM+1];
  
+ 	  if (loop && (index == last)){
+ 	    done++;
+ 	    break;
+ 	  }
+ 
  	  /* must be a folder and it can't be the current one */
  	  if(ps_global->context_current == ps_global->context_list
  	     && !strcmp(ps_global->cur_folder, FLDR_NAME(f)))
***************
*** 8436,8454 ****
  	  }
        }
  
!     if(f && (!find_recent || recent))
        strcpy(next, FLDR_NAME(f));
      else
        *next = '\0';
  
      /* BUG: how can this be made smarter so we cache the list? */
      free_folder_list(cntxt);
      return((*next) ? next : NULL);
  }
  
  
  
  /*
   * folder_is_nick - check to see if the given name is a nickname
   *                  for some folder in the given context...
   *
--- 8572,8739 ----
  	  }
        }
  
!     if(f && (!find_recent || recent)){
        strcpy(next, FLDR_NAME(f));
+       done++;
+     }
      else
        *next = '\0';
  
+     if (!done && F_ON(F_AUTO_CIRCULAR_TAB,ps_global)
+ 	 && strcmp(test_current,ps_global->inbox_name)){
+ 	 done++; loop++;
+           if (test_current)                   
+             fs_give((void **)&test_current);
+           test_current = cpystr(ps_global->inbox_name);
+ 	 goto find_new_message;
+     }
+ 
      /* BUG: how can this be made smarter so we cache the list? */
      free_folder_list(cntxt);
+     if (test_current)                   
+        fs_give((void **)&test_current);
      return((*next) ? next : NULL);
  }
  
  
  
  /*
+  * next_folder - given a current folder in a context, return the next in
+  *               the list, or NULL if no more or there's a problem.
+  */
+ char *
+ next_folder_check(streamp, cntxt, find_recent, find_messages, f, opstrm)
+     MAILSTREAM **streamp;
+     CONTEXT_S	*cntxt;
+     long	*find_recent, *find_messages;
+     FOLDER_S 	*f;
+     int		*opstrm;
+ {
+     char      *next;
+     int       index, recent = 0, failed_status = 0;
+     char      *star = "*";
+     char      *oldnewsrc = NULL;
+ 
+     /* note: find_folders may assign "stream" */
+     build_folder_list(streamp, cntxt, NULL, NULL,
+ 		      NEWS_TEST(cntxt) ? BFL_LSUB : BFL_NONE);
+ 
+     if(find_recent && find_messages && opstrm){
+       MAILSTREAM *stream = NULL;
+       int         rv, we_cancel = 0;
+       char        msg_buf[MAX_SCREEN_COLS+1] = {'\0'};
+       char        tmp[MAILTMPLEN];
+ 
+       *opstrm	     = 0;		/* default value */
+       *find_recent   = f->recent;	/* default value. Return this if */
+       *find_messages = f->messages;	/* not requested		 */
+ 
+       if((stream = sp_stream_get(context_apply(tmp, cntxt, f->name,sizeof(tmp)),
+ 						     SP_MATCH)) != NULL){
+ 	  *opstrm = 1;
+ 	  (void) pine_mail_ping(stream);
+ 	  next = new_mail_in_open_stream(stream, find_recent, find_messages);
+ 	  free_folder_list(cntxt);
+ 	  return next;
+       } 
+       else if ((F_ON(F_ENABLE_FAST_RECENT, ps_global) &&
+ 		F_OFF(F_ENABLE_INCOMING_RECHECK,ps_global)  && 
+ 		(folder_in_message_list(FLDR_NAME(f)) || f->selected))
+ 		|| (f->selected && f->user_selected)){
+ 
+ 	  next = folder_in_message_list(FLDR_NAME(f)) ? cpystr(FLDR_NAME(f)) 
+ 						      : NULL;
+ 	  free_folder_list(cntxt);
+ 	  return next;
+       }
+       else if (need_folder_report(FLDR_NAME(f))
+ 		&& (strcmp(ps_global->cur_folder, FLDR_NAME(f)) || !stream)){
+ 
+ 	  we_cancel = busy_alarm(1, msg_buf, NULL, 1);
+ 
+ 	  /* First, get a stream for the test */
+ 	  if(streamp && *streamp){
+ 	     if(context_same_stream(cntxt, f->name, *streamp))
+ 		stream = *streamp;
+ 	     else{
+ 		mail_close(*streamp);
+ 		*streamp = NULL;
+ 	     }
+ 	   }
+ 
+ 	  if(!stream)
+ 	      stream = sp_stream_get(context_apply(tmp, cntxt, f->name,
+ 						   sizeof(tmp)), SP_SAME);
+ 
+ 	  if (IS_NEWS(ps_global->mail_stream) 
+ 		&& F_ON(F_ENABLE_MULNEWSRCS,ps_global))
+ 	     oldnewsrc = (char *)change_newsrc(ps_global->mail_stream,oldnewsrc, 1);
+ 
+ 	  if(F_OFF(F_ENABLE_FAST_RECENT, ps_global)
+ 	     || !((rv = folder_exists(cntxt,f->name))
+ 					     & (FEX_ISMARKED | FEX_UNMARKED))){
+ 	      extern MAILSTATUS mm_status_result;
+ 
+ 	      if((F_ON(F_ENABLE_FAST_RECENT, ps_global) &&
+ 	          (rv == 0 || rv & FEX_ERROR))){
+ 		  failed_status = 1;
+ 		  mm_status_result.flags = 0L;
+ 	      }
+ 	      else{
+ 		  if(stream){
+ 		      if(!context_status_full(cntxt, stream,
+ 					      f->name, SA_RECENT | SA_MESSAGES,
+ 					      &f->uidvalidity,
+ 					      &f->uidnext)){
+ 			  failed_status = 1;
+ 			  mm_status_result.flags = 0L;
+ 		      }
+ 		  }
+ 		  else{
+ 		      if(!context_status_streamp_full(cntxt, streamp, f->name,
+ 						      SA_RECENT | SA_MESSAGES,
+ 						      &f->uidvalidity,
+ 						      &f->uidnext)){
+ 			  failed_status = 1;
+ 			  mm_status_result.flags = 0L;
+ 		      }
+ 		  }
+ 	      }
+ 
+ 	      *find_messages = mm_status_result.messages;
+ 	      rv = (((mm_status_result.flags & SA_RECENT) ||
+ 		      (F_OFF(F_ENABLE_FAST_RECENT,ps_global) 
+ 			&& (mm_status_result.recent != f->recent)))
+ 		    && (*find_recent = mm_status_result.recent))
+ 		     ? FEX_ISMARKED : 0;
+ 	  }
+ 
+ 	  if (IS_NEWS(ps_global->mail_stream) 
+ 		&& F_ON(F_ENABLE_MULNEWSRCS,ps_global))
+ 	     oldnewsrc = (char *)change_newsrc(ps_global->mail_stream,oldnewsrc, 0);
+ 
+ 	  if (oldnewsrc)
+ 	     fs_give((void **)&oldnewsrc);
+ 
+ 	  if(we_cancel)
+ 	    cancel_busy_alarm(0);
+ 
+ 	  failed_status = 0;
+ 
+ 	  if(rv & FEX_ISMARKED){
+ 	    recent++;
+ 	    next = (f && (!find_recent || recent)) ? cpystr(FLDR_NAME(f)) : NULL;
+   	    free_folder_list(cntxt);
+     	    return(next);
+ 	  }
+       }
+       return(NULL);
+     }
+ }
+ 
+ 
+ 
+ /*
   * folder_is_nick - check to see if the given name is a nickname
   *                  for some folder in the given context...
   *
diff -rc pine4.61/pine/help.c pine4.61.I.USE/pine/help.c
*** pine4.61/pine/help.c	Thu Apr  8 09:59:19 2004
--- pine4.61.I.USE/pine/help.c	Thu Sep 23 15:28:02 2004
***************
*** 1235,1240 ****
--- 1235,1246 ----
      {16, 3},
      {16, 1},
      {16, 0},
+     {4, -1},
+     {8, -1},
+     {12, -1},
+     {14, -1},
+     {15, -1},
+     {16, -1},
      {0, 0}
  };
  
diff -rc pine4.61/pine/imap.c pine4.61.I.USE/pine/imap.c
*** pine4.61/pine/imap.c	Wed Jun  2 15:00:36 2004
--- pine4.61.I.USE/pine/imap.c	Tue Aug 24 09:12:36 2004
***************
*** 704,710 ****
      q_line = -(ps_global->ttyo ? ps_global->ttyo->footer_rows : 3);
  
      /* make sure errors are seen */
!     if(ps_global->ttyo)
        flush_status_messages(0);
  
      /*
--- 704,710 ----
      q_line = -(ps_global->ttyo ? ps_global->ttyo->footer_rows : 3);
  
      /* make sure errors are seen */
!     if((ps_global->ttyo) && (!ps_global->checking_incfld))
        flush_status_messages(0);
  
      /*
***************
*** 1938,1948 ****
  #endif
  
      if(elapsed >= (long)ps_global->tcp_query_timeout){
! 	sprintf(pmt,
! 	 "Waited %s seconds for server reply.  Break connection to server",
  		long2string(elapsed));
! 	if(want_to(pmt, 'n', 'n', NO_HELP, WT_FLUSH_IN) == 'y')
! 	  return(0L);
      }
  
      return(rv);
--- 1938,1952 ----
  #endif
  
      if(elapsed >= (long)ps_global->tcp_query_timeout){
! 	if (!ps_global->checking_incfld){
! 	  sprintf(pmt,
! 	   "Waited %s seconds for server reply.  Break connection to server",
  		long2string(elapsed));
! 	  if(want_to(pmt, 'n', 'n', NO_HELP, WT_FLUSH_IN) == 'y')
! 	    return(0L);
! 	}
! 	else
! 	   rv = 0L;
      }
  
      return(rv);
***************
*** 1984,2009 ****
      if(elapsed >= (long)ps_global->tcp_query_timeout){
  	int clear_inverse;
  
! 	ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
! 	if(clear_inverse = !InverseState())
! 	  StartInverse();
! 
! 	Writechar(BELL, 0);
! 
! 	PutLine1(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global), 0,
!        "Waited %s seconds for server reply.  Break connection to server? ",
! 	   long2string(elapsed));
! 	CleartoEOLN();
! 	fflush(stdout);
! 	flush_input();
! 	ch = read_char(7);
! 	if(ch == 'y' || ch == 'Y')
! 	  rv = 0L;
  
! 	if(clear_inverse)
! 	  EndInverse();
  
! 	ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
      }
  
      if(rv == 1L){			/* just warn 'em something's up */
--- 1988,2017 ----
      if(elapsed >= (long)ps_global->tcp_query_timeout){
  	int clear_inverse;
  
! 	if (!ps_global->checking_incfld){
! 	   ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
! 	   if(clear_inverse = !InverseState())
! 	     StartInverse();
! 
! 	   Writechar(BELL, 0);
! 
! 	   PutLine1(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global), 0,
!             "Waited %s seconds for server reply.  Break connection to server? ",
! 	     long2string(elapsed));
! 	   CleartoEOLN();
! 	   fflush(stdout);
! 	   flush_input();
! 	   ch = read_char(7);
! 	   if(ch == 'y' || ch == 'Y')
! 	     rv = 0L;
  
! 	   if(clear_inverse)
! 	     EndInverse();
  
! 	   ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
! 	}
! 	else
! 	   rv = 0L;
      }
  
      if(rv == 1L){			/* just warn 'em something's up */
***************
*** 2223,2233 ****
        return(mulname);
  
      sprintf(buf,
! 	    "Rename newsrc \"%.15s%s\" for use as new host-specific newsrc",
  	    last_cmpnt(name), 
  	    strlen(last_cmpnt(name)) > 15 ? "..." : "");
      if(want_to(buf, 'n', 'n', NO_HELP, WT_NORM) == 'y')
!       rename_file(name, mulname);
      return(mulname);
  }
  
--- 2231,2241 ----
        return(mulname);
  
      sprintf(buf,
! 	    "Copy newsrc \"%.15s%s\" for use as new host-specific newsrc",
  	    last_cmpnt(name), 
  	    strlen(last_cmpnt(name)) > 15 ? "..." : "");
      if(want_to(buf, 'n', 'n', NO_HELP, WT_NORM) == 'y')
!       link(name, mulname);
      return(mulname);
  }
  
diff -rc pine4.61/pine/init.c pine4.61.I.USE/pine/init.c
*** pine4.61/pine/init.c	Thu Jul 15 10:37:24 2004
--- pine4.61.I.USE/pine/init.c	Thu Jul 22 14:07:41 2004
***************
*** 71,76 ****
--- 71,77 ----
  typedef enum {Sapling, Seedling, Seasoned} FeatureLevel;
  
  #define	TO_BAIL_THRESHOLD	60
+ #define	INCFLD_THRESHOLD	5
  
  #define METASTR "\nremote-abook-metafile="
  static char meta_prefix[] = ".ab";
***************
*** 158,163 ****
--- 159,166 ----
  
  CONF_TXT_T cf_text_incoming_folders[] =	"List of incoming msg folders besides INBOX, e.g. ={host2}inbox, {host3}inbox\n# Syntax: optnl-label {optnl-imap-host-name}folder-path";
  
+ CONF_TXT_T cf_incoming_folders_check[] = "List of incoming folders to be checked for new mail";
+ 
  CONF_TXT_T cf_text_folder_collections[] =	"List of directories where saved-message folders may be. First one is\n# the default for Saves. Example: Main {host1}mail/[], Desktop mail\\[]\n# Syntax: optnl-label {optnl-imap-hostname}optnl-directory-path[]";
  
  CONF_TXT_T cf_text_news_collections[] =	"List, only needed if nntp-server not set, or news is on a different host\n# than used for NNTP posting. Examples: News *[] or News *{host3/nntp}[]\n# Syntax: optnl-label *{news-host/protocol}[]";
***************
*** 214,223 ****
--- 217,256 ----
  
  CONF_TXT_T cf_text_sort_key[] =		"Sets presentation order of messages in Index. Choices:\n# subject, from, arrival, date, size. Default: \"arrival\".";
  
+ CONF_TXT_T cf_text_thread_sort_key[] =        "#Sets presentation order of threads in thread index. Choices:\n#arrival, and thread.";
+ 
  CONF_TXT_T cf_text_addrbook_sort_rule[] =	"Sets presentation order of address book entries. Choices: dont-sort,\n# fullname-with-lists-last, fullname, nickname-with-lists-last, nickname\n# Default: \"fullname-with-lists-last\".";
  
  CONF_TXT_T cf_text_folder_sort_rule[] =	"Sets presentation order of folder list entries. Choices: alphabetical,\n# alpha-with-dirs-last, alpha-with-dirs-first.\n# Default: \"alpha-with-directories-last\".";
  
+ CONF_TXT_T cf_text_compose_rules[] =	"Allows a user to set rules when composing messages.";
+ 
+ CONF_TXT_T cf_text_forward_rules[] =	"Allows a user to set rules when forwarding messages.";
+ 
+ CONF_TXT_T cf_text_reply_rules[] =	"Allows a user to set rules when replying messages.";
+ 
+ CONF_TXT_T cf_text_index_rules[] =	"Allows a user to supercede global index format variable in designated folders.";
+ 
+ CONF_TXT_T cf_text_replace_rules[] =	"Allows a user to change the form a specify field in the index-format is \n# displayed.";
+ 
+ CONF_TXT_T cf_text_reply_indent_rules[] = "Allows a user to change the form a specify a reply-indent-string\n# based of rules.";
+ 
+ CONF_TXT_T cf_text_reply_leadin_rules[] =	"Allows a user to replace the reply-leadin message based on different parameters.";
+ 
+ CONF_TXT_T cf_text_reply_subject_rules[] =	"Allows a user to replace the subject of a message in a customs based way";
+ 
+ CONF_TXT_T cf_text_thread_displaystyle_rule[] = "Allows a user to specify the threading style of specific folders";
+ 
+ CONF_TXT_T cf_text_thread_indexstyle_rule[] = "Allows a user to specify the threading index style of specific folders";
+ 
+ CONF_TXT_T cf_text_save_rules[] =	"Allows a user to specify a save folder message for specific senders or folders.";
+ 
+ CONF_TXT_T cf_text_smtp_rules[] =	"Allows a user to specify a smtp server to be used when sending e-mail,\n# according to the rules specified here.";
+ 
+ CONF_TXT_T cf_text_sort_rules[] =	"Allows a user to specify the sort default order of a specific folder.";
+ 
+ CONF_TXT_T cf_text_startup_rules[] =	"Allows a user to specify the position of a highlighted message when opening a \n# folder.";
+ 
  CONF_TXT_T cf_text_character_set[] =	"Reflects capabilities of the display you have. Default: US-ASCII.\n# Typical alternatives include ISO-8859-x, (x is a number between 1 and 9).";
  
  CONF_TXT_T cf_text_editor[] =		"Specifies the program invoked by ^_ in the Composer,\n# or the \"enable-alternate-editor-implicitly\" feature.";
***************
*** 228,233 ****
--- 261,268 ----
  
  CONF_TXT_T cf_text_fillcol[] =		"Specifies the column of the screen where the composer should wrap.";
  
+ CONF_TXT_T cf_special_text_color[] =	"Specifies a comma separated list of text and regular expresions that Pine\n# will highlight";
+ 
  CONF_TXT_T cf_text_replystr[] =		"Specifies the string to insert when replying to a message.";
  
  CONF_TXT_T cf_text_replyintro[] =	"Specifies the introduction to insert when replying to a message.";
***************
*** 240,245 ****
--- 275,282 ----
  
  CONF_TXT_T cf_text_inc_startup[] =	"Sets message which cursor begins on. Choices: first-unseen, first-recent,\n# first-important, first-important-or-unseen, first-important-or-recent,\n# first, last. Default: \"first-unseen\".";
  
+ CONF_TXT_T cf_text_inc_check[] =	"Sets how and when checks for new mail should happen. Choices: automatic,\n# automatic-after-first-manual-check, manual-only, Default: automatic";
+ 
  CONF_TXT_T cf_pruning_rule[] =		"Allows a default answer for the prune folder questions. Choices: yes-ask,\n# yes-no, no-ask, no-no, ask-ask, ask-no. Default: \"ask-ask\".";
  
  CONF_TXT_T cf_reopen_rule[] =		"Controls behavior when reopening an already open folder.";
***************
*** 368,373 ****
--- 405,412 ----
  
  CONF_TXT_T cf_text_tcp_query_timeo[] =	"If this much time has elapsed at the time of a tcp read or write\n# timeout, pine will ask if you want to break the connection.\n# Default is 60 seconds, minimum is 5, maximum is 1000.";
  
+ CONF_TXT_T cf_text_inc_fld_timeout[] =	"If this much time has elapsed at the time of a tcp read or write\n# timeout while checking for new mail in an incoming folder, pine will break the connection.\n# Default is 5 seconds, minimum is 2, maximum is 60.";
+ 
  CONF_TXT_T cf_text_rsh_open_timeo[] =	"Sets the time in seconds that Pine will attempt to open a UNIX remote\n# shell connection.  The default is 15, min is 5, and max is unlimited.\n# Zero disables rsh altogether.";
  
  CONF_TXT_T cf_text_rsh_path[] =		"Sets the name of the command used to open a UNIX remote shell connection.\n# The default is tyically /usr/ucb/rsh.";
***************
*** 408,413 ****
--- 447,455 ----
  
  CONF_TXT_T cf_text_newsrc_path[] =		"Full path and name of NEWSRC file";
  
+ CONF_TXT_T cf_text_maildir_location[] =		"Location relative to your HOME directory of the directory where your INBOX\n# for the maildir format is located. Default value is \"Maildir\". If your\n# inbox is located at \"~/Maildir\" you do not need to change this value.\n# A common value is also \".maildir\"";
+ 
+ 
  /* these are used to report folder directory creation problems */
  CONF_TXT_T init_md_exists[] =	"The \"%s\" subdirectory already exists, but it is not writable by Pine so Pine cannot run.  Please correct the permissions and restart Pine.";
  
***************
*** 461,466 ****
--- 503,510 ----
  				cf_text_nntp_server},
  {"inbox-path",				0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_inbox_path},
+ {"incoming-folders-to-check",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_incoming_folders_check},
  {"incoming-archive-folders",		0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
  				cf_text_archived_folders},
  {"pruned-folders",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
***************
*** 501,506 ****
--- 545,552 ----
  				cf_text_fcc_name_rule},
  {"sort-key",				0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_sort_key},
+ {"thread-sort-key",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_text_thread_sort_key},
  {"addrbook-sort-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_addrbook_sort_rule},
  {"folder-sort-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
***************
*** 509,514 ****
--- 555,562 ----
  				cf_text_goto_default},
  {"incoming-startup-rule",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_inc_startup},
+ {"incoming-check-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_text_inc_check},
  {"pruning-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_pruning_rule},
  {"folder-reopen-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
***************
*** 523,528 ****
--- 571,602 ----
  				cf_text_thread_exp_char},
  {"threading-lastreply-character",	0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_thread_lastreply_char},
+ {"threading-display-style-rule",	0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_thread_displaystyle_rule},
+ {"threading-index-style-rule",	0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_thread_indexstyle_rule},
+ {"compose-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_compose_rules},
+ {"forward-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_forward_rules},
+ {"index-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_index_rules},
+ {"replace-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_replace_rules},
+ {"reply-indent-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_reply_indent_rules},
+ {"reply-leadin-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_reply_leadin_rules},
+ {"reply-subject-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_reply_subject_rules},
+ {"save-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_save_rules},
+ {"smtp-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_smtp_rules},
+ {"sort-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_sort_rules},
+ {"startup-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_startup_rules},
  {"character-set",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_character_set},
  {"editor",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
***************
*** 531,536 ****
--- 605,612 ----
  				cf_text_speller},
  {"composer-wrap-column",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_fillcol},
+ {"special-text-color",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_special_text_color},
  {"reply-indent-string",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_replystr},
  {"reply-leadin",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
***************
*** 591,596 ****
--- 667,674 ----
  				cf_text_news_active},
  {"news-spool-directory",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_news_spooldir},
+ {"maildir-location",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_text_maildir_location},
  {"upload-command",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_upload_cmd},
  {"upload-command-prefix",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
***************
*** 651,656 ****
--- 729,736 ----
  				cf_text_tcp_write_timeo},
  {"tcp-query-timeout",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_tcp_query_timeo},
+ {"inc-fld-timeout",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_text_inc_fld_timeout},
  {"rsh-command",				0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_rsh_command},
  {"rsh-path",				0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
***************
*** 750,755 ****
--- 830,837 ----
  {"quote3-background-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0, NULL},
  {"signature-foreground-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0, NULL},
  {"signature-background-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0, NULL},
+ {"special-text-foreground-color",	0, 1, 0, 1, 1, 0, 0, 0, 0, 0, NULL},
+ {"special-text-background-color",	0, 1, 0, 1, 1, 0, 0, 0, 0, 0, NULL},
  {"prompt-foreground-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0, NULL},
  {"prompt-background-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0, NULL},
  {"index-to-me-foreground-color",	0, 1, 0, 1, 1, 0, 0, 0, 0, 0, NULL},
***************
*** 1449,1455 ****
      register struct variable *vars = ps->vars;
      int		 obs_header_in_reply,     /* the obs_ variables are to       */
  		 obs_old_style_reply,     /* support backwards compatibility */
! 		 obs_save_by_sender, i, def_sort_rev;
      long         rvl;
      PINERC_S    *fixedprc = NULL;
      FeatureLevel obs_feature_level;
--- 1531,1537 ----
      register struct variable *vars = ps->vars;
      int		 obs_header_in_reply,     /* the obs_ variables are to       */
  		 obs_old_style_reply,     /* support backwards compatibility */
! 		 obs_save_by_sender, i, def_sort_rev, thread_def_sort_rev;
      long         rvl;
      PINERC_S    *fixedprc = NULL;
      FeatureLevel obs_feature_level;
***************
*** 1471,1476 ****
--- 1553,1559 ----
      GLO_FEATURE_LEVEL		= cpystr(DF_FEATURE_LEVEL);
      GLO_OLD_STYLE_REPLY		= cpystr(DF_OLD_STYLE_REPLY);
      GLO_SORT_KEY		= cpystr(DF_SORT_KEY);
+     GLO_THREAD_SORT_KEY		= cpystr(DF_THREAD_SORT_KEY);
      GLO_SAVED_MSG_NAME_RULE	= cpystr(DF_SAVED_MSG_NAME_RULE);
      GLO_FCC_RULE		= cpystr(DF_FCC_RULE);
      GLO_AB_SORT_RULE		= cpystr(DF_AB_SORT_RULE);
***************
*** 1481,1486 ****
--- 1564,1570 ----
      GLO_REMOTE_ABOOK_VALIDITY	= cpystr(DF_REMOTE_ABOOK_VALIDITY);
      GLO_GOTO_DEFAULT_RULE	= cpystr(DF_GOTO_DEFAULT_RULE);
      GLO_INCOMING_STARTUP	= cpystr(DF_INCOMING_STARTUP);
+     GLO_INCOMING_RULE		= cpystr(DF_INCOMING_RULE);
      GLO_PRUNING_RULE		= cpystr(DF_PRUNING_RULE);
      GLO_REOPEN_RULE		= cpystr(DF_REOPEN_RULE);
      GLO_THREAD_DISP_STYLE	= cpystr(DF_THREAD_DISP_STYLE);
***************
*** 1827,1834 ****
--- 1911,1930 ----
      set_current_val(&vars[V_POSTPONED_FOLDER], TRUE, TRUE);
      set_current_val(&vars[V_READ_MESSAGE_FOLDER], TRUE, TRUE);
      set_current_val(&vars[V_FORM_FOLDER], TRUE, TRUE);
+     set_current_val(&vars[V_COMPOSE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_FORWARD_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_INDEX_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_REPLACE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_REPLY_INDENT_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_REPLY_LEADIN_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_RESUB_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SAVE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SMTP_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SORT_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_STARTUP_RULES], TRUE, TRUE);
      set_current_val(&vars[V_EDITOR], TRUE, TRUE);
      set_current_val(&vars[V_SPELLER], TRUE, TRUE);
+     set_current_val(&vars[V_SPECIAL_TEXT], TRUE, TRUE);
      set_current_val(&vars[V_IMAGE_VIEWER], TRUE, TRUE);
      set_current_val(&vars[V_BROWSER], TRUE, TRUE);
      set_current_val(&vars[V_SMTP_SERVER], TRUE, TRUE);
***************
*** 2051,2056 ****
--- 2147,2159 ----
      else
        ps->tcp_query_timeout = i;
  
+     set_current_val(&vars[V_INCFLDTIMEO], TRUE, TRUE);
+     ps->incfld_timeout = i = INCFLD_THRESHOLD;
+     if(VAR_INCFLDTIMEO && SVAR_INCFLDQUERY(ps, i, tmp_20k_buf))
+       init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
+     else
+       ps->incfld_timeout = i;
+ 
      set_current_val(&vars[V_NEWSRC_PATH], TRUE, TRUE);
      if(VAR_NEWSRC_PATH && VAR_NEWSRC_PATH[0])
        mail_parameters(NULL, SET_NEWSRC, (void *)VAR_NEWSRC_PATH);
***************
*** 2065,2070 ****
--- 2168,2177 ----
        mail_parameters(NULL, SET_NEWSSPOOL,
  		      (void *)VAR_NEWS_SPOOL_DIR);
  
+     set_current_val(&vars[V_MAILDIR_LOCATION], TRUE, TRUE);
+     if(VAR_MAILDIR_LOCATION && VAR_MAILDIR_LOCATION[0])
+       mail_parameters(NULL, SET_MDINBOX, (void *)VAR_MAILDIR_LOCATION);
+ 
      /* guarantee a save default */
      set_current_val(&vars[V_DEFAULT_SAVE_FOLDER], TRUE, TRUE);
      if(!VAR_DEFAULT_SAVE_FOLDER || !VAR_DEFAULT_SAVE_FOLDER[0])
***************
*** 2286,2293 ****
      set_current_val(&vars[V_PRUNED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_ARCHIVED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_INCOMING_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_SORT_KEY], TRUE, TRUE);
!     if(decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev) == -1){
  	sprintf(tmp_20k_buf, "Sort type \"%.200s\" is invalid", VAR_SORT_KEY);
  	init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
  	ps->def_sort = SortArrival;
--- 2393,2401 ----
      set_current_val(&vars[V_PRUNED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_ARCHIVED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_INCOMING_FOLDERS], TRUE, TRUE);
+     set_current_val(&vars[V_INCOMING_FOLDERS_CHECK], TRUE, TRUE);
      set_current_val(&vars[V_SORT_KEY], TRUE, TRUE);
!     if(decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev,0) == -1){
  	sprintf(tmp_20k_buf, "Sort type \"%.200s\" is invalid", VAR_SORT_KEY);
  	init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
  	ps->def_sort = SortArrival;
***************
*** 2296,2301 ****
--- 2404,2420 ----
      else
        ps->def_sort_rev = def_sort_rev;
  
+     set_current_val(&vars[V_THREAD_SORT_KEY], TRUE, TRUE);
+     if(decode_sort(VAR_THREAD_SORT_KEY, &ps->thread_def_sort, 
+                               &thread_def_sort_rev, 1) == -1){
+       sprintf(tmp_20k_buf, "Sort type \"%s\" is invalid", VAR_THREAD_SORT_KEY);
+       init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
+       ps->thread_def_sort = SortThread;
+       ps->thread_def_sort_rev = 0;
+     }
+     else
+       ps->thread_def_sort_rev = thread_def_sort_rev;
+ 
      cur_rule_value(&vars[V_SAVED_MSG_NAME_RULE], TRUE, TRUE);
      {NAMEVAL_S *v; int i;
      for(i = 0; v = save_msg_rules(i); i++)
***************
*** 2323,2333 ****
--- 2442,2455 ----
      cur_rule_value(&vars[V_TITLEBAR_COLOR_STYLE], TRUE, TRUE);
      cur_rule_value(&vars[V_FLD_SORT_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_INCOMING_STARTUP], TRUE, TRUE);
+     cur_rule_value(&vars[V_INCOMING_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_PRUNING_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_REOPEN_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_GOTO_DEFAULT_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_THREAD_DISP_STYLE], TRUE, TRUE);
      cur_rule_value(&vars[V_THREAD_INDEX_STYLE], TRUE, TRUE);
+     cur_rule_value(&vars[V_THREAD_DISP_STYLE_RULES], TRUE, TRUE);
+     cur_rule_value(&vars[V_THREAD_INDEX_STYLE_RULES], TRUE, TRUE);
  
      set_current_val(&vars[V_THREAD_MORE_CHAR], TRUE, TRUE);
      if(VAR_THREAD_MORE_CHAR[0] && VAR_THREAD_MORE_CHAR[1]){
***************
*** 2561,2566 ****
--- 2683,2690 ----
  	 F_COMPOSE_ALWAYS_DOWNGRADE, h_downgrade_multipart_to_text, PREF_COMP},
  
  /* Reply Prefs */
+ 	{"alternate-reply-menu",
+ 	 F_ALT_REPLY_MENU, h_config_alt_reply_menu, PREF_RPLY},
  	{"enable-reply-indent-string-editing",
  	 F_ENABLE_EDIT_REPLY_INDENT, h_config_prefix_editing, PREF_RPLY},
  	{"include-attachments-in-reply",
***************
*** 2595,2600 ****
--- 2719,2726 ----
  	 F_AUTO_FCC_ONLY, h_config_auto_fcc_only, PREF_SEND},
  	{"fcc-without-attachments",
  	 F_NO_FCC_ATTACH, h_config_no_fcc_attach, PREF_SEND},
+         {"return-path-uses-domain-name",
+          F_USE_DOMAIN_NAME, h_config_use_domain, PREF_SEND},
  	{"mark-fcc-seen",
  	 F_MARK_FCC_SEEN, h_config_mark_fcc_seen, PREF_SEND},
  	{"send-without-confirm",
***************
*** 2615,2620 ****
--- 2741,2750 ----
  	 F_ENABLE_DOT_FOLDERS, h_config_enable_dot_folders, PREF_FLDR},
  	{"enable-incoming-folders",
  	 F_ENABLE_INCOMING, h_config_enable_incoming, PREF_FLDR},
+ 	{"enable-check-incoming-folders",
+ 	 F_ENABLE_INCOMING_CHECK, h_config_enable_check_incoming, PREF_FLDR},
+ 	{"recheck-all-incoming-folders",
+ 	 F_ENABLE_INCOMING_RECHECK, h_config_enable_recheck_incoming,PREF_FLDR},
  	{"enable-lame-list-mode",
  	 F_FIX_BROKEN_LIST, h_config_lame_list_mode, PREF_FLDR},
  	{"expanded-view-of-folders",
***************
*** 2643,2648 ****
--- 2773,2780 ----
  /* Index prefs */
  	{"auto-open-next-unread",
  	 F_AUTO_OPEN_NEXT_UNREAD, h_config_auto_open_unread, PREF_INDX},
+ 	{"enable-circular-tab",
+ 	   F_AUTO_CIRCULAR_TAB, h_config_circular_tab, PREF_INDX},
  	{"continue-tab-without-confirm",
  	 F_TAB_NO_CONFIRM, h_config_tab_no_prompt, PREF_INDX},
  	{"delete-skips-deleted",
***************
*** 2665,2670 ****
--- 2797,2804 ----
  	 F_TAB_TO_NEW, h_config_tab_new_only, PREF_INDX},
  	{"thread-index-shows-important-color",
  	 F_COLOR_LINE_IMPORTANT, h_config_color_thrd_import, PREF_INDX},
+ 	{"enhanced-fancy-thread-support",
+ 	 F_ENHANCED_THREAD, h_config_enhanced_thread, PREF_INDX},
  
  /* Viewer prefs */
  	{"enable-msg-view-addresses",
***************
*** 2768,2773 ****
--- 2902,2909 ----
  	 F_FORCE_LOW_SPEED, h_config_force_low_speed, PREF_OS_LWSD},
  	{"auto-move-read-msgs",
  	 F_AUTO_READ_MSGS, h_config_auto_read_msgs, PREF_MISC},
+ 	{"auto-move-read-msgs-using-rules",
+ 	 F_AUTO_READ_MSGS_RULES, h_config_auto_read_msgs_rules, PREF_MISC},
  	{"auto-unzoom-after-apply",
  	 F_AUTO_UNZOOM, h_config_auto_unzoom, PREF_MISC},
  	{"auto-zoom-after-select",
***************
*** 3080,3085 ****
--- 3216,3224 ----
      if(F_ON(F_QUELL_LOCK_FAILURE_MSGS, ps))
        mail_parameters(NULL, SET_LOCKEACCESERROR, (void *) 0);
  
+     /* Show dot folders? */
+       ps->show_dot_names = F_ON(F_ENABLE_DOT_FOLDERS, ps);
+ 
      /*
       * Turn on quelling of pseudo message.
       */
***************
*** 3684,3689 ****
--- 3823,3845 ----
  	   ? &is_rules[index] : NULL);
  }
  
+ /*
+  * Standard way to get  incoming check rules...
+  */
+ NAMEVAL_S *
+ incoming_check_rules(index)
+     int index;
+ {
+     static NAMEVAL_S is_rules[] = {
+ 	{"automatic",				NULL, IC_AUTO},
+ 	{"automatic-after-first-manual-check",	NULL, IC_MAN_AUTO},
+ 	{"manual-only",				NULL, IC_MAN}
+     };
+ 
+     return((index >= 0 && index < (sizeof(is_rules)/sizeof(is_rules[0])))
+ 	   ? &is_rules[index] : NULL);
+ }
+ 
  
  NAMEVAL_S *
  startup_rules(index)
***************
*** 4117,4127 ****
  
      if(i > 0){
  	ps->initial_cmds = (int *)fs_get((i+1) * sizeof(int));
  	ps->free_initial_cmds = ps->initial_cmds;
! 	for(j = 0; j < i; j++)
  	  ps->initial_cmds[j] = i_cmds[j];
! 
  	ps->initial_cmds[i] = 0;
  	ps->in_init_seq = ps->save_in_init_seq = 1;
      }
  }
--- 4273,4288 ----
  
      if(i > 0){
  	ps->initial_cmds = (int *)fs_get((i+1) * sizeof(int));
+         ps->initial_cmds_backup = (int *)fs_get((i+1) * sizeof(int));
  	ps->free_initial_cmds = ps->initial_cmds;
! 	for(j = 0; j < i; j++){
  	  ps->initial_cmds[j] = i_cmds[j];
!           ps->initial_cmds_backup[j] = i_cmds[j];}
! #define ctrl_x 24
!       if (i > 1)
!       ps->send_immediately = (i_cmds[i - 2] == ctrl_x) && (i_cmds[i - 1] == 'y');
  	ps->initial_cmds[i] = 0;
+        ps->initial_cmds_backup[i] = 0;
  	ps->in_init_seq = ps->save_in_init_seq = 1;
      }
  }
***************
*** 6339,6361 ****
   * argument also means arrival/reverse.
   */
  int
! decode_sort(sort_spec, def_sort, def_sort_rev)
       char        *sort_spec;
       SortOrder   *def_sort;
       int         *def_sort_rev;
  {
      char *sep;
      char *fix_this = NULL;
!     int   x, reverse;
  
      if(!sort_spec || !*sort_spec){
! 	*def_sort = SortArrival;
  	*def_sort_rev = 0;
          return(0);
      }
  
      if(struncmp(sort_spec, "reverse", strlen(sort_spec)) == 0){
! 	*def_sort = SortArrival;
  	*def_sort_rev = 1;
          return(0);
      }
--- 6500,6523 ----
   * argument also means arrival/reverse.
   */
  int
! decode_sort(sort_spec, def_sort, def_sort_rev, thread)
       char        *sort_spec;
       SortOrder   *def_sort;
       int         *def_sort_rev;
+      int	  thread;
  {
      char *sep;
      char *fix_this = NULL;
!     int   x = 0, reverse;
  
      if(!sort_spec || !*sort_spec){
! 	*def_sort = thread ? SortThread : SortArrival;
  	*def_sort_rev = 0;
          return(0);
      }
  
      if(struncmp(sort_spec, "reverse", strlen(sort_spec)) == 0){
! 	*def_sort = thread ? SortThread : SortArrival;
  	*def_sort_rev = 1;
          return(0);
      }
***************
*** 6378,6390 ****
                    sort_spec, strlen(sort_spec)) == 0)
          break;
  
      if(fix_this)
        *fix_this = '/';
  
      if(ps_global->sort_types[x] == EndofList)
        return(-1);
  
!     *def_sort     = ps_global->sort_types[x];
      *def_sort_rev = reverse;
      return(0);
  }
--- 6540,6558 ----
                    sort_spec, strlen(sort_spec)) == 0)
          break;
  
+     if (thread && ps_global->sort_types[x] != SortArrival
+ 	&& ps_global->sort_types[x] != SortDate
+ 	&& ps_global->sort_types[x] != SortThread)
+ 	for(x = 0; ps_global->sort_types[x] != EndofList; x++);
+ 
      if(fix_this)
        *fix_this = '/';
  
      if(ps_global->sort_types[x] == EndofList)
        return(-1);
  
!     *def_sort     = (thread && ps_global->sort_types[x] == SortDate)
! 		    ? SortThread : ps_global->sort_types[x];
      *def_sort_rev = reverse;
      return(0);
  }
***************
*** 10899,10904 ****
--- 11067,11080 ----
  	      break;
  	  }
      }
+     else if(var == &ps_global->vars[V_INCOMING_RULE]){
+       if(ps_global->VAR_INCOMING_RULE)
+ 	for(i = 0; v = incoming_check_rules(i); i++)
+ 	  if(!strucmp(ps_global->VAR_INCOMING_RULE, S_OR_L(v))){
+ 	      ps_global->inc_check_rule = v->value;
+ 	      break;
+ 	  }
+     }
      else if(var == &ps_global->vars[V_PRUNING_RULE]){
        if(ps_global->VAR_PRUNING_RULE)
  	for(i = 0; v = pruning_rules(i); i++)
diff -rc pine4.61/pine/mailcmd.c pine4.61.I.USE/pine/mailcmd.c
*** pine4.61/pine/mailcmd.c	Tue Jul 13 18:35:15 2004
--- pine4.61.I.USE/pine/mailcmd.c	Thu Aug 19 21:52:03 2004
***************
*** 88,98 ****
  int	  save_ex_explain_body PROTO((BODY *, unsigned long *, gf_io_t));
  int	  save_ex_explain_parts PROTO((BODY *, int, unsigned long *, gf_io_t));
  int	  save_ex_output_line PROTO((char *, unsigned long *, gf_io_t));
  int	  create_for_save PROTO((MAILSTREAM *, CONTEXT_S *, char *));
  void      set_keywords_in_msgid_msg PROTO((MAILSTREAM *, MESSAGECACHE *,
  					   MAILSTREAM *, char *));
  long      get_msgno_by_msg_id PROTO((MAILSTREAM *, char *, MSGNO_S *));
! int	  select_sort PROTO((struct pine *, int, SortOrder *, int *));
  void	  aggregate_select PROTO((struct pine *, MSGNO_S *, int, CmdWhere,int));
  int	  select_number PROTO((MAILSTREAM *, MSGNO_S *, long, SEARCHSET **));
  int	  select_thrd_number PROTO((MAILSTREAM *, MSGNO_S *, long,
--- 88,101 ----
  int	  save_ex_explain_body PROTO((BODY *, unsigned long *, gf_io_t));
  int	  save_ex_explain_parts PROTO((BODY *, int, unsigned long *, gf_io_t));
  int	  save_ex_output_line PROTO((char *, unsigned long *, gf_io_t));
+ long	  any_new_message PROTO ((MAILSTREAM *));
+ long	  any_unseen_message PROTO ((MAILSTREAM *));
+ char	  *any_report_message PROTO ((MAILSTREAM *));
  int	  create_for_save PROTO((MAILSTREAM *, CONTEXT_S *, char *));
  void      set_keywords_in_msgid_msg PROTO((MAILSTREAM *, MESSAGECACHE *,
  					   MAILSTREAM *, char *));
  long      get_msgno_by_msg_id PROTO((MAILSTREAM *, char *, MSGNO_S *));
! int	  select_sort PROTO((struct pine *, int, SortOrder *, int *, int));
  void	  aggregate_select PROTO((struct pine *, MSGNO_S *, int, CmdWhere,int));
  int	  select_number PROTO((MAILSTREAM *, MSGNO_S *, long, SEARCHSET **));
  int	  select_thrd_number PROTO((MAILSTREAM *, MSGNO_S *, long,
***************
*** 109,114 ****
--- 112,138 ----
  char	 *currentf_sequence PROTO((MAILSTREAM *, MSGNO_S *, long, long *,
  				   int, char **, char **));
  char	 *invalid_elt_sequence PROTO((MAILSTREAM *, MSGNO_S *));
+ long	  top_thread PROTO((MAILSTREAM *, long));
+ void	  move_top_thread PROTO((MAILSTREAM *, MSGNO_S *, long));
+ long	  top_this_thread PROTO((MAILSTREAM *, long));
+ void	  move_top_this_thread PROTO((MAILSTREAM *, MSGNO_S *, long));
+ void	  cmd_delete_this_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *));
+ void	  cmd_delete_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *));
+ void	  cmd_undelete_this_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *));
+ void	  cmd_undelete_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *));
+ void	  cmd_select_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *));
+ void	  kolapse_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, char, int));
+ int	  count_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, long));
+ int	  count_this_thread PROTO((MAILSTREAM *, unsigned long));
+ int	  this_thread_is_kolapsed PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, long));
+ int	  thread_is_kolapsed PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, long));
+ int	  collapse_this_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int, int));
+ void	  collapse_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int));
+ int	  expand_this_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int, int));
+ void	  expand_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int));
+ int	  move_next_this_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int));
+ int	  move_next_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int));
+ int	  move_prev_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int));
  char	 *selected_sequence PROTO((MAILSTREAM *, MSGNO_S *, long *, int));
  int	  any_messages PROTO((MSGNO_S *, char *, char *));
  int	  can_set_flag PROTO((struct pine *, char *, int));
***************
*** 119,124 ****
--- 143,154 ----
  int	  read_msg_prompt PROTO((long, char *));
  char	 *move_read_incoming PROTO((MAILSTREAM *, CONTEXT_S *, char *,
  				    char **, char *));
+ char	 *move_read_msgs_using_rules PROTO((MAILSTREAM *, char *, char *));
+ unsigned  get_perfolder_startup_rule PROTO((MAILSTREAM *, int, char *));
+ void	  setup_threading_index_style PROTO(());
+ int	  find_startup_position PROTO((int, MAILSTREAM *, long));
+ char	 *get_rule_result PROTO((int, char *, char **));
+ char	 *get_folder_to_save PROTO((MAILSTREAM *, long, char *));
  void	  cross_delete_crossposts PROTO((MAILSTREAM *));
  void      menu_clear_cmd_binding PROTO((struct key_menu *, int));
  int	  update_folder_spec PROTO((char *, char *));
***************
*** 139,144 ****
--- 169,177 ----
  #define SV_FOR_FILT		0x2
  #define SV_FIX_DELS		0x4
  
+ static  MAILSTREAM *saved_stream;
+ static  unsigned long rule_curpos = 0L;
+ 
  typedef struct append_package {
    MAILSTREAM *stream;
    char *flags;
***************
*** 219,232 ****
  
  
  static char *sel_flag = 
!     "Select New, Deleted, Answered, or Important messages ? ";
  static char *sel_flag_not = 
!     "Select NOT New, NOT Deleted, NOT Answered or NOT Important msgs ? ";
  static ESCKEY_S sel_flag_opt[] = {
      {'n', 'n', "N", "New"},
      {'*', '*', "*", "Important"},
      {'d', 'd', "D", "Deleted"},
      {'a', 'a', "A", "Answered"},
      {'!', '!', "!", "Not"},
      {-1, 0, NULL, NULL}
  };
--- 252,266 ----
  
  
  static char *sel_flag = 
!     "Select New, Deleted, Recent, Answered, or Important messages ? ";
  static char *sel_flag_not = 
!     "Select NOT New, NOT Deleted, NOT Recent, NOT Answered or NOT Important msgs ? ";
  static ESCKEY_S sel_flag_opt[] = {
      {'n', 'n', "N", "New"},
      {'*', '*', "*", "Important"},
      {'d', 'd', "D", "Deleted"},
      {'a', 'a', "A", "Answered"},
+     {'r', 'r', "R", "Recent"},
      {'!', '!', "!", "Not"},
      {-1, 0, NULL, NULL}
  };
***************
*** 258,263 ****
--- 292,298 ----
      {'r', 'r', "R", "Recipient"},
      {'p', 'p', "P", "Participant"},
      {'b', 'b', "B", "Body"},
+     {'h', 'h', "H", "Header"},
      {-1, 0, NULL, NULL}
  };
  
***************
*** 904,910 ****
  				     state->context_current, &recent_cnt,
  				     F_ON(F_TAB_NO_CONFIRM,state)
  				       ? NULL : &did_cancel))){
! 			if(!in_inbox){
  			    static ESCKEY_S inbox_opt[] = {
  				{'y', 'y', "Y", "Yes"},
  				{'n', 'n', "N", "No"},
--- 939,945 ----
  				     state->context_current, &recent_cnt,
  				     F_ON(F_TAB_NO_CONFIRM,state)
  				       ? NULL : &did_cancel))){
! 			if(!in_inbox && F_OFF(F_AUTO_CIRCULAR_TAB,state)){
  			    static ESCKEY_S inbox_opt[] = {
  				{'y', 'y', "Y", "Yes"},
  				{'n', 'n', "N", "No"},
***************
*** 1154,1159 ****
--- 1189,1198 ----
  		    if(SORT_IS_THREADED(msgmap))
  		      refresh_sort(stream, msgmap, SRT_NON);
  
+ 		    if (msgmap->nmsgs
+ 			  && F_ON(F_ENHANCED_THREAD, state) && COLL_THRDS())
+ 			kolapse_thread(state, stream, msgmap, '[', 0);
+ 
  		    state->mangled_body = 1;
  		    state->mangled_header = 1;
  		    q_status_message2(SM_ORDER, 0, 4,
***************
*** 1224,1229 ****
--- 1263,1269 ----
  	ps_global->expunge_in_progress = 0;
  	if(we_cancel)
  	  cancel_busy_alarm((sp_expunge_count(stream) > 0) ? 0 : -1);
+ 	update_incoming_folder_data(stream, state->context_current);
  
  	dprint(2,(debugfile,"expunge complete cur:%ld max:%ld\n",
  		  mn_get_cur(msgmap), mn_get_total(msgmap)));
***************
*** 1266,1271 ****
--- 1306,1314 ----
  	     */
  	    if(SORT_IS_THREADED(msgmap))
  	      refresh_sort(stream, msgmap, SRT_NON);
+ 	    if (msgmap->nmsgs
+ 		  && F_ON(F_ENHANCED_THREAD, state) && COLL_THRDS())
+ 		kolapse_thread(state, stream, msgmap, '[', 0);
  	}
  	else{
  	    if(del_count)
***************
*** 1401,1407 ****
  	if(any_messages(msgmap, NULL, NULL)){
  	    if(any_lflagged(msgmap, MN_SLCT) > 0L){
  		if(apply_command(state, stream, msgmap, 0,
! 				 AC_NONE, question_line)
  		   && F_ON(F_AUTO_UNZOOM, state))
  		  unzoom_index(state, stream, msgmap);
  	    }
--- 1444,1450 ----
  	if(any_messages(msgmap, NULL, NULL)){
  	    if(any_lflagged(msgmap, MN_SLCT) > 0L){
  		if(apply_command(state, stream, msgmap, 0,
! 				 AC_NONE, question_line, 1)
  		   && F_ON(F_AUTO_UNZOOM, state))
  		  unzoom_index(state, stream, msgmap);
  	    }
***************
*** 1414,1431 ****
  
            /*-------- Sort command -------*/
        case MC_SORT :
  	{
  	    int were_threading = THREADING();
  	    SortOrder sort = mn_get_sort(msgmap);
  	    int	      rev  = mn_get_revsort(msgmap);
  
  	    dprint(1, (debugfile,"MAIL_CMD: sort\n"));		    
! 	    if(select_sort(state, question_line, &sort, &rev)){
  		/* $ command reinitializes threading collapsed/expanded info */
  		if(SORT_IS_THREADED(msgmap) && !SEP_THRDINDX())
  		  erase_threading_info(stream, msgmap);
  
! 		sort_folder(stream, msgmap, sort, rev, SRT_VRB|SRT_MAN);
  	    }
  
  	    state->mangled_footer = 1;
--- 1457,1481 ----
  
            /*-------- Sort command -------*/
        case MC_SORT :
+       case MC_SORTHREAD :
  	{
  	    int were_threading = THREADING();
  	    SortOrder sort = mn_get_sort(msgmap);
  	    int	      rev  = mn_get_revsort(msgmap);
+ 	    int	    thread = (command == MC_SORT) ? 0 : 1;
  
+ 	    if (sort == SortThread)
+ 		sort = ps_global->thread_cur_sort;
  	    dprint(1, (debugfile,"MAIL_CMD: sort\n"));		    
! 	    if(select_sort(state, question_line, &sort, &rev, thread)){
  		/* $ command reinitializes threading collapsed/expanded info */
  		if(SORT_IS_THREADED(msgmap) && !SEP_THRDINDX())
  		  erase_threading_info(stream, msgmap);
  
! 		if (command == MC_SORTHREAD)
! 		   ps_global->thread_cur_sort = sort;
! 		sort = (command == MC_SORT) ? sort : SortThread;
! 		sort_folder(stream, msgmap, sort, rev, SRT_VRB|SRT_MAN, 1);
  	    }
  
  	    state->mangled_footer = 1;
***************
*** 1500,1505 ****
--- 1550,1561 ----
  	break;
  
  
+          /*--------Incoming Folders Auto Check --------*/
+       case MC_FORCECHECK:
+ 	state->force_check_now = 1;
+ 	new_mail_incfolder(state,command);
+ 	break;
+ 
            /*--------- Default, unknown command ----------*/
        default:
  	panic("Unexpected command case");
***************
*** 2779,2784 ****
--- 2835,2841 ----
  
      dprint(4, (debugfile, "\n - saving message -\n"));
  
+     saved_stream = stream;		/* ugly hack! */
      state->ugly_consider_advancing_bit = 0;
      if(msgno_any_deletedparts(stream, msgmap)
         && want_to("Saved copy will NOT include entire message!  Continue",
***************
*** 3018,3031 ****
  {
      static char	      folder[MAILTMPLEN+1] = {'\0'};
      static CONTEXT_S *last_context = NULL;
!     int		      rc, n, flags, last_rc = 0, saveable_count = 0, done = 0;
      int               context_was_set;
      char	      prompt[MAX_SCREEN_COLS+1], *p, expanded[MAILTMPLEN];
      char              *buf = tmp_20k_buf;
      HelpType	      help;
      CONTEXT_S	     *tc;
      ESCKEY_S	      ekey[8];
! 
      if(!cntxt)
        panic("no context ptr in save_prompt");
  
--- 3075,3090 ----
  {
      static char	      folder[MAILTMPLEN+1] = {'\0'};
      static CONTEXT_S *last_context = NULL;
!     int		      rc, n=0, flags, last_rc = 0, saveable_count = 0, done = 0;
      int               context_was_set;
      char	      prompt[MAX_SCREEN_COLS+1], *p, expanded[MAILTMPLEN];
      char              *buf = tmp_20k_buf;
      HelpType	      help;
      CONTEXT_S	     *tc;
      ESCKEY_S	      ekey[8];
!     RULE_RESULT      *rule;
!  
!     saved_stream  = state->mail_stream;
      if(!cntxt)
        panic("no context ptr in save_prompt");
  
***************
*** 3055,3060 ****
--- 3114,3127 ----
  	  return(0);
      }
  
+     if (rule = (RULE_RESULT *)  /* override selection here */
+           get_result_rule(ps_global->VAR_SAVE_RULES, FOR_RULE | FOR_SAVE, env)){
+        strncpy(folder,rule->result,sizeof(folder)-1);
+        folder[sizeof(folder)-1] = '\0';
+        if (rule->result)
+ 	   fs_give((void **)&rule->result);
+        fs_give((void **)&rule);
+     }
  
      /* how many context's can be saved to... */
      for(tc = state->context_list; tc; tc = tc->next)
***************
*** 4059,4065 ****
  	      *date = '\0';
  
  	    rv = save_fetch_append(stream, mn_m2raw(msgmap, i),
! 				   NULL, save_stream, save_folder, context,
  				   mc->rfc822_size, flags, date, so);
  
  	    if(sp_expunge_count(ps_global->mail_stream))
--- 4126,4132 ----
  	      *date = '\0';
  
  	    rv = save_fetch_append(stream, mn_m2raw(msgmap, i),
! 				   NULL, save_stream, folder, context,
  				   mc->rfc822_size, flags, date, so);
  
  	    if(sp_expunge_count(ps_global->mail_stream))
***************
*** 7092,7097 ****
--- 7159,7218 ----
      return(newfolder);
  }
  
+ char *
+ any_report_message (stream)
+  MAILSTREAM *stream;
+ {
+  char message[40] = {'\0'}, *report;
+  long new, unseen;
+  int i, imapstatus = 0;
+ 
+  for (i = 0; ps_global->index_disp_format[i].ctype != iNothing
+ 		&& ps_global->index_disp_format[i].ctype != iIStatus; i++);
+  imapstatus = ps_global->index_disp_format[i].ctype == iIStatus;
+ 
+  report = (char *) fs_get(41*sizeof(char));
+  new = any_new_message(stream);
+  unseen = any_unseen_message(stream);
+ 
+  if (new > 0L || unseen > 0L && imapstatus){
+     sprintf(message," - %s%s%s%s%s", new > 0L ? comatose(new) : "",
+ 			new > 0L ? " new" : "",
+ 			new > 0L && unseen > 0L && imapstatus ? ", " : "",
+ 			unseen > 0L && imapstatus ? comatose(unseen) : "",
+ 			unseen > 0L && imapstatus ? " unseen" : "");
+  }
+  report = *message ? cpystr(message) : cpystr("");
+ 
+  return report;
+ }
+ 
+ 
+ long
+ any_new_message (stream)
+  MAILSTREAM *stream;
+ {
+  MSGNO_S *msgmap = sp_msgmap(stream);
+  long excluded = any_lflagged(msgmap, MN_EXLD);
+  return excluded > 0L 
+ 		? (excluded < stream->nmsgs 
+ 			? count_flagged(stream, F_RECENT|F_UNSEEN) : 0L)
+ 		: count_flagged(stream, F_RECENT|F_UNSEEN);
+ }
+ 
+ long
+ any_unseen_message (stream)
+  MAILSTREAM *stream;
+ {
+  MSGNO_S *msgmap = sp_msgmap(stream);
+  long excluded = any_lflagged(msgmap, MN_EXLD);
+  return excluded > 0L 
+ 		? (excluded < stream->nmsgs 
+ 			? count_flagged(stream, F_UNSEEN)
+ 			  - count_flagged(stream, F_RECENT) : 0L)
+ 		: count_flagged(stream, F_UNSEEN) 
+ 			 - count_flagged(stream, F_RECENT);
+ }
  
  /*----------------------------------------------------------------------
      Check to see if user input is in form of old c-client mailbox speck
***************
*** 7149,7154 ****
--- 7270,7483 ----
      return(FALSE);
  }
  
+ void
+ setup_threading_index_style()
+ {
+   RULE_RESULT *rule;
+   NAMEVAL_S *v;
+   int i;
+ 
+   rule = (RULE_RESULT *)
+           get_result_rule(ps_global->VAR_THREAD_INDEX_STYLE_RULES, 
+ 			  FOR_RULE | FOR_THREAD, (ENVELOPE *) NULL);
+   if (rule || ps_global->VAR_THREAD_INDEX_STYLE){
+      for(i = 0; v = thread_index_styles(i); i++)
+         if(!strucmp(rule ? rule->result : ps_global->VAR_THREAD_INDEX_STYLE, 
+ 		    rule ? (v ? v->name : "" ) : S_OR_L(v))){
+               ps_global->thread_index_style = v->value;
+               break;
+         }
+      if (rule){
+ 	if (rule->result)
+ 	   fs_give((void **)&rule->result);
+ 	fs_give((void **)&rule);
+      }
+   }
+ }
+ 
+ 
+ char *get_rule_result(rule_context, newfolder, list)
+ int rule_context;
+ char *newfolder;
+ char **list;
+ {   char	*rule_result = NULL;
+     ENVELOPE	*news_envelope;
+     RULE_RESULT *rule;
+ 
+     if (IS_NEWS(ps_global->mail_stream)){
+        news_envelope = mail_newenvelope();
+        news_envelope->newsgroups = cpystr(newfolder);
+     }
+     else
+        news_envelope = (ENVELOPE *) NULL;
+ 
+     rule = (RULE_RESULT *) get_result_rule(list,rule_context, news_envelope);
+ 
+     if (news_envelope)
+         mail_free_envelope (&news_envelope); 
+ 
+     if (rule){
+ 	rule_result = cpystr(rule->result);
+         if (rule->result)
+           fs_give((void **)&rule->result);
+         fs_give((void **)&rule);
+     }
+ 
+     return rule_result;
+ }
+ 
+ find_startup_position(rule, m, pc)
+ int rule;
+ MAILSTREAM *m;
+ long pc;
+ {
+   long n;
+     switch(rule){
+ 	      /*
+ 	       * For news in incoming collection we're doing the same thing
+ 	       * for first-unseen and first-recent. In both those cases you
+ 	       * get first-unseen if FAKE_NEW is off and first-recent if
+ 	       * FAKE_NEW is on. If FAKE_NEW is on, first unseen is the
+ 	       * same as first recent because all recent msgs are unseen
+ 	       * and all unrecent msgs are seen (see pine_mail_open).
+ 	       */
+ 	      case IS_FIRST_UNSEEN:
+ first_unseen:
+ 		mn_set_cur(ps_global->msgmap,
+ 			(sp_first_unseen(m)
+ 			 && mn_get_sort(ps_global->msgmap) == SortArrival
+ 			 && !mn_get_revsort(ps_global->msgmap)
+ 			 && !get_lflag(ps_global->mail_stream, NULL,
+ 				       sp_first_unseen(m), MN_EXLD)
+ 			 && (n = mn_raw2m(ps_global->msgmap, 
+ 					  sp_first_unseen(m))))
+ 			   ? n
+ 			   : first_sorted_flagged(F_UNSEEN | F_UNDEL, m, pc,
+ 					      THREADING() ? 0 : FSF_SKIP_CHID));
+ 		break;
+ 
+ 	      case IS_FIRST_RECENT:
+ first_recent:
+ 		/*
+ 		 * We could really use recent for news but this is the way
+ 		 * it has always worked, so we'll leave it. That is, if
+ 		 * the FAKE_NEW feature is on, recent and unseen are
+ 		 * equivalent, so it doesn't matter. If the feature isn't
+ 		 * on, all the undeleted messages are unseen and we start
+ 		 * at the first one. User controls with the FAKE_NEW feature.
+ 		 */
+ 		if(IS_NEWS(ps_global->mail_stream)){
+ 		    mn_set_cur(ps_global->msgmap,
+ 			       first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID));
+ 		}
+ 		else{
+ 		    mn_set_cur(ps_global->msgmap,
+ 			       first_sorted_flagged(F_RECENT | F_UNSEEN
+ 						    | F_UNDEL,
+ 						    m, pc,
+ 					      THREADING() ? 0 : FSF_SKIP_CHID));
+ 		}
+ 		break;
+ 
+ 	      case IS_FIRST_IMPORTANT:
+ 		mn_set_cur(ps_global->msgmap,
+ 			   first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+ 					      THREADING() ? 0 : FSF_SKIP_CHID));
+ 		break;
+ 
+ 	      case IS_FIRST_IMPORTANT_OR_UNSEEN:
+ 
+ 		if(IS_NEWS(ps_global->mail_stream))
+ 		  goto first_unseen;
+ 
+ 		{
+ 		    MsgNo flagged, first_unseen;
+ 
+ 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID);
+ 		    first_unseen = (sp_first_unseen(m)
+ 			     && mn_get_sort(ps_global->msgmap) == SortArrival
+ 			     && !mn_get_revsort(ps_global->msgmap)
+ 			     && !get_lflag(ps_global->mail_stream, NULL,
+ 					   sp_first_unseen(m), MN_EXLD)
+ 			     && (n = mn_raw2m(ps_global->msgmap, 
+ 					      sp_first_unseen(m))))
+ 				? n
+ 				: first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID);
+ 		    mn_set_cur(ps_global->msgmap,
+ 			  (MsgNo) min((int) flagged, (int) first_unseen));
+ 
+ 		}
+ 
+ 		break;
+ 
+ 	      case IS_FIRST_IMPORTANT_OR_RECENT:
+ 
+ 		if(IS_NEWS(ps_global->mail_stream))
+ 		  goto first_recent;
+ 
+ 		{
+ 		    MsgNo flagged, first_recent;
+ 
+ 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID);
+ 		    first_recent = first_sorted_flagged(F_RECENT | F_UNSEEN
+ 							| F_UNDEL,
+ 							m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID);
+ 		    mn_set_cur(ps_global->msgmap,
+ 			      (MsgNo) min((int) flagged, (int) first_recent));
+ 		}
+ 
+ 		break;
+ 
+ 	      case IS_FIRST:
+ 		mn_set_cur(ps_global->msgmap,
+ 			   first_sorted_flagged(F_UNDEL, m, pc,
+ 					      THREADING() ? 0 : FSF_SKIP_CHID));
+ 		break;
+ 
+ 	      case IS_LAST:
+ 		mn_set_cur(ps_global->msgmap,
+ 			   first_sorted_flagged(F_UNDEL, m, pc,
+ 			         FSF_LAST | (THREADING() ? 0 : FSF_SKIP_CHID)));
+ 		break;
+ 
+ 	      default:
+ 		panic("Unexpected incoming startup case");
+ 		break;
+ 
+     }
+ }
+ 
+ unsigned
+ get_perfolder_startup_rule(stream, rule_type, folder)
+   MAILSTREAM *stream;
+   int	      rule_type;
+   char	     *folder;
+ {
+     unsigned	startup_rule;
+     char        *rule_result;
+      
+     startup_rule =  reset_startup_rule(stream);
+     rule_result = get_rule_result(FOR_RULE | FOR_STARTUP, folder,
+                               ps_global->vars[rule_type].current_val.l);
+      if (rule_result && *rule_result){
+        int        i;
+        NAMEVAL_S *v;
+ 
+        for(i = 0; v = incoming_startup_rules(i); i++)
+           if(!strucmp(rule_result, v->name)){
+              startup_rule = v->value;
+              break;
+           }
+        fs_give((void **)&rule_result);  
+      }
+    return startup_rule;
+ }
+ 
  
  /*----------------------------------------------------------------------
      Actually attempt to open given folder 
***************
*** 7183,7189 ****
      int         open_inbox, rv, old_tros, we_cancel = 0,
                  do_reopen = 0, n, was_dead = 0, cur_already_set = 0;
      char        expanded_file[max(MAXPATH,MAILTMPLEN)+1],
! 	       *old_folder, *old_path, *p;
      long        openmode, rflags = 0L, pc = 0L, cur, raw;
      ENVELOPE   *env = NULL;
      char        status_msg[81];
--- 7512,7518 ----
      int         open_inbox, rv, old_tros, we_cancel = 0,
                  do_reopen = 0, n, was_dead = 0, cur_already_set = 0;
      char        expanded_file[max(MAXPATH,MAILTMPLEN)+1],
! 	       *old_folder, *old_path, *p, *report;
      long        openmode, rflags = 0L, pc = 0L, cur, raw;
      ENVELOPE   *env = NULL;
      char        status_msg[81];
***************
*** 7443,7457 ****
  		sizeof(ps_global->cur_folder)-1);
  	ps_global->cur_folder[sizeof(ps_global->cur_folder)-1] = '\0';
  	ps_global->context_current = ps_global->context_list;
  	reset_index_format();
  	clear_index_cache();
          /* MUST sort before restoring msgno! */
  	refresh_sort(ps_global->mail_stream, ps_global->msgmap, SRT_NON);
!         q_status_message3(SM_ORDER, 0, 3,
! 			  "Opened folder \"%.200s\" with %.200s message%.200s",
! 			  ps_global->inbox_name, 
!                           long2string(mn_get_total(ps_global->msgmap)),
! 			  plural(mn_get_total(ps_global->msgmap)));
  #ifdef	_WINDOWS
  	mswin_settitle(ps_global->inbox_name);
  #endif
--- 7772,7791 ----
  		sizeof(ps_global->cur_folder)-1);
  	ps_global->cur_folder[sizeof(ps_global->cur_folder)-1] = '\0';
  	ps_global->context_current = ps_global->context_list;
+ 	setup_threading_index_style();
  	reset_index_format();
  	clear_index_cache();
          /* MUST sort before restoring msgno! */
  	refresh_sort(ps_global->mail_stream, ps_global->msgmap, SRT_NON);
! 	report = any_report_message(ps_global->mail_stream);
! 	q_status_message4(SM_ORDER, 0, 3,
! 			"Opened folder \"%.200s\" with %.200s message%.200s%.200s",
! 			ps_global->inbox_name,
! 			long2string(mn_get_total(ps_global->msgmap)),
! 			plural(mn_get_total(ps_global->msgmap)),
! 			report);
! 	if (report)
! 	    fs_give((void **)&report);
  #ifdef	_WINDOWS
  	mswin_settitle(ps_global->inbox_name);
  #endif
***************
*** 7752,7757 ****
--- 8086,8092 ----
  
      clear_index_cache();
      reset_index_format();
+     setup_threading_index_style();
  
      /*
       * Start news reading with messages the user's marked deleted
***************
*** 7771,7778 ****
      if(!sp_flagged(ps_global->mail_stream, SP_FILTERED))
        process_filter_patterns(ps_global->mail_stream, ps_global->msgmap, 0L);
  
!     q_status_message6(SM_ORDER, 0, 4,
! 		    "%.20s \"%.200s\" opened with %.20s message%.20s%.20s%.20s",
  			IS_NEWS(ps_global->mail_stream)
  			  ? "News group" : "Folder",
  			pretty_fn(newfolder),
--- 8106,8121 ----
      if(!sp_flagged(ps_global->mail_stream, SP_FILTERED))
        process_filter_patterns(ps_global->mail_stream, ps_global->msgmap, 0L);
  
!     if(!(rflags & SP_MATCH) || !(rflags & SP_LOCKED))
!       reset_sort_order(SRT_VRB);
!     else if(sp_new_mail_count(ps_global->mail_stream) > 0L
! 	    || sp_unsorted_newmail(ps_global->mail_stream)
! 	    || sp_need_to_rethread(ps_global->mail_stream))
!       refresh_sort(ps_global->mail_stream, ps_global->msgmap, SRT_NON);
! 
!     report = any_report_message(ps_global->mail_stream);
!     q_status_message7(SM_ORDER, 0, 4,
! 			"%.20s \"%.200s\" opened with %.20s message%.20s%.20s%.20s%.20s", 
  			IS_NEWS(ps_global->mail_stream)
  			  ? "News group" : "Folder",
  			pretty_fn(newfolder),
***************
*** 7782,7801 ****
  			 && sp_flagged(ps_global->mail_stream, SP_PERMLOCKED))
  			    ? " (StayOpen)" : "",
  			READONLY_FOLDER(ps_global->mail_stream)
! 						? " READONLY" : "");
  
  #ifdef	_WINDOWS
      mswin_settitle(pretty_fn(newfolder));
  #endif
  
-     if(!(rflags & SP_MATCH) || !(rflags & SP_LOCKED))
-       reset_sort_order(SRT_VRB);
-     else if(sp_new_mail_count(ps_global->mail_stream) > 0L
- 	    || sp_unsorted_newmail(ps_global->mail_stream)
- 	    || sp_need_to_rethread(ps_global->mail_stream))
-       refresh_sort(ps_global->mail_stream, ps_global->msgmap, SRT_NON);
- 
- 
      /*
       * Set current message number when re-opening Stay-Open or
       * cached folders.
--- 8125,8140 ----
  			 && sp_flagged(ps_global->mail_stream, SP_PERMLOCKED))
  			    ? " (StayOpen)" : "",
  			READONLY_FOLDER(ps_global->mail_stream)
! 						? " READONLY" : "",
! 			report);
!     if (report)
! 	fs_give((void **)&report);
! 
  
  #ifdef	_WINDOWS
      mswin_settitle(pretty_fn(newfolder));
  #endif
  
      /*
       * Set current message number when re-opening Stay-Open or
       * cached folders.
***************
*** 7859,7865 ****
  
      if(!cur_already_set && mn_get_total(ps_global->msgmap) > 0L){
  
! 	perfolder_startup_rule = reset_startup_rule(ps_global->mail_stream);
  
  	if(ps_global->start_entry > 0){
  	    mn_set_cur(ps_global->msgmap, mn_get_revsort(ps_global->msgmap)
--- 8198,8207 ----
  
      if(!cur_already_set && mn_get_total(ps_global->msgmap) > 0L){
  
! 	perfolder_startup_rule = get_perfolder_startup_rule(ps_global->mail_stream,
!                                        V_STARTUP_RULES, newfolder);
! 
! 	reset_startup_rule(ps_global->mail_stream);
  
  	if(ps_global->start_entry > 0){
  	    mn_set_cur(ps_global->msgmap, mn_get_revsort(ps_global->msgmap)
***************
*** 7881,8032 ****
  	    else
  	      use_this_startup_rule = ps_global->inc_startup_rule;
  
! 	    switch(use_this_startup_rule){
! 	      /*
! 	       * For news in incoming collection we're doing the same thing
! 	       * for first-unseen and first-recent. In both those cases you
! 	       * get first-unseen if FAKE_NEW is off and first-recent if
! 	       * FAKE_NEW is on. If FAKE_NEW is on, first unseen is the
! 	       * same as first recent because all recent msgs are unseen
! 	       * and all unrecent msgs are seen (see pine_mail_open).
! 	       */
! 	      case IS_FIRST_UNSEEN:
! first_unseen:
! 		mn_set_cur(ps_global->msgmap,
! 			(sp_first_unseen(m)
! 			 && mn_get_sort(ps_global->msgmap) == SortArrival
! 			 && !mn_get_revsort(ps_global->msgmap)
! 			 && !get_lflag(ps_global->mail_stream, NULL,
! 				       sp_first_unseen(m), MN_EXLD)
! 			 && (n = mn_raw2m(ps_global->msgmap, 
! 					  sp_first_unseen(m))))
! 			   ? n
! 			   : first_sorted_flagged(F_UNSEEN | F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		break;
  
! 	      case IS_FIRST_RECENT:
! first_recent:
! 		/*
! 		 * We could really use recent for news but this is the way
! 		 * it has always worked, so we'll leave it. That is, if
! 		 * the FAKE_NEW feature is on, recent and unseen are
! 		 * equivalent, so it doesn't matter. If the feature isn't
! 		 * on, all the undeleted messages are unseen and we start
! 		 * at the first one. User controls with the FAKE_NEW feature.
! 		 */
! 		if(IS_NEWS(ps_global->mail_stream)){
! 		    mn_set_cur(ps_global->msgmap,
! 			       first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID));
! 		}
! 		else{
! 		    mn_set_cur(ps_global->msgmap,
! 			       first_sorted_flagged(F_RECENT | F_UNSEEN
! 						    | F_UNDEL,
! 						    m, pc,
  					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		}
! 		break;
  
! 	      case IS_FIRST_IMPORTANT:
! 		mn_set_cur(ps_global->msgmap,
! 			   first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		break;
  
! 	      case IS_FIRST_IMPORTANT_OR_UNSEEN:
  
! 		if(IS_NEWS(ps_global->mail_stream))
! 		  goto first_unseen;
! 
! 		{
! 		    MsgNo flagged, first_unseen;
! 
! 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    first_unseen = (sp_first_unseen(m)
! 			     && mn_get_sort(ps_global->msgmap) == SortArrival
! 			     && !mn_get_revsort(ps_global->msgmap)
! 			     && !get_lflag(ps_global->mail_stream, NULL,
! 					   sp_first_unseen(m), MN_EXLD)
! 			     && (n = mn_raw2m(ps_global->msgmap, 
! 					      sp_first_unseen(m))))
! 				? n
! 				: first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    mn_set_cur(ps_global->msgmap,
! 			  (MsgNo) min((int) flagged, (int) first_unseen));
! 
! 		}
! 
! 		break;
! 
! 	      case IS_FIRST_IMPORTANT_OR_RECENT:
! 
! 		if(IS_NEWS(ps_global->mail_stream))
! 		  goto first_recent;
! 
! 		{
! 		    MsgNo flagged, first_recent;
! 
! 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    first_recent = first_sorted_flagged(F_RECENT | F_UNSEEN
! 							| F_UNDEL,
! 							m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    mn_set_cur(ps_global->msgmap,
! 			      (MsgNo) min((int) flagged, (int) first_recent));
! 		}
! 
! 		break;
! 
! 	      case IS_FIRST:
! 		mn_set_cur(ps_global->msgmap,
! 			   first_sorted_flagged(F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		break;
! 
! 	      case IS_LAST:
! 		mn_set_cur(ps_global->msgmap,
! 			   first_sorted_flagged(F_UNDEL, m, pc,
! 			         FSF_LAST | (THREADING() ? 0 : FSF_SKIP_CHID)));
! 		break;
! 
! 	      default:
! 		panic("Unexpected incoming startup case");
! 		break;
! 
! 	    }
! 	}
! 	else if(IS_NEWS(ps_global->mail_stream)){
! 	    /*
! 	     * This will go to two different places depending on the FAKE_NEW
! 	     * feature (see pine_mail_open).
! 	     */
! 	    mn_set_cur(ps_global->msgmap,
! 		       first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 	}
!         else{
! 	    mn_set_cur(ps_global->msgmap,
! 		       mn_get_revsort(ps_global->msgmap)
! 		         ? 1L
! 			 : mn_get_total(ps_global->msgmap));
! 	}
! 
! 	adjust_cur_to_visible(ps_global->mail_stream, ps_global->msgmap);
!     }
!     else if(!(rflags & SP_MATCH)){
! 	mn_set_cur(ps_global->msgmap, -1L);
!     }
! 
!     if(ps_global->mail_stream)
!       sp_set_first_unseen(ps_global->mail_stream, 0L);
! 
!     return(1);
! }
  
  
  void
--- 8223,8258 ----
  	    else
  	      use_this_startup_rule = ps_global->inc_startup_rule;
  
! 	    find_startup_position(use_this_startup_rule, m, pc);
  
! 	}
! 	else if(IS_NEWS(ps_global->mail_stream)){
! 	    /*
! 	     * This will go to two different places depending on the FAKE_NEW
! 	     * feature (see pine_mail_open).
! 	     */
! 	    mn_set_cur(ps_global->msgmap,
! 		       first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
  					      THREADING() ? 0 : FSF_SKIP_CHID));
! 	}
!         else{
! 	    mn_set_cur(ps_global->msgmap,
! 		       mn_get_revsort(ps_global->msgmap)
! 		         ? 1L
! 			 : mn_get_total(ps_global->msgmap));
! 	}
  
! 	adjust_cur_to_visible(ps_global->mail_stream, ps_global->msgmap);
!     }
!     else if(!(rflags & SP_MATCH)){
! 	mn_set_cur(ps_global->msgmap, -1L);
!     }
  
!     if(ps_global->mail_stream)
!       sp_set_first_unseen(ps_global->mail_stream, 0L);
  
!     return(1);
! }
  
  
  void
***************
*** 8035,8043 ****
      long rflags = ROLE_DO_OTHER;
      PAT_STATE     pstate;
      PAT_S        *pat;
!     int           we_set_it = 0;
  
!     if(ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
  	    if(match_pattern(pat->patgrp, ps_global->mail_stream, NULL,
  			     NULL, NULL, 0))
--- 8261,8270 ----
      long rflags = ROLE_DO_OTHER;
      PAT_STATE     pstate;
      PAT_S        *pat;
!     int           we_set_it = 0,found = 0;
  
!    found = find_index_rule();  if (found) we_set_it++;
!    if(!found && ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
  	    if(match_pattern(pat->patgrp, ps_global->mail_stream, NULL,
  			     NULL, NULL, 0))
***************
*** 8067,8078 ****
      PAT_S        *pat;
      SortOrder	  the_sort_order;
      int           sort_is_rev;
  
!     /* set default order */
!     the_sort_order = ps_global->def_sort;
!     sort_is_rev    = ps_global->def_sort_rev;
! 
!     if(ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
  	    if(match_pattern(pat->patgrp, ps_global->mail_stream, NULL,
  			     NULL, NULL, 0))
--- 8294,8323 ----
      PAT_S        *pat;
      SortOrder	  the_sort_order;
      int           sort_is_rev;
+     char         *rule_result;
+     SortOrder     new_sort = EndofList;
+     int           is_rev;
+ 
+     rule_result = get_rule_result(FOR_RULE | FOR_SORT, ps_global->cur_folder,
+                               ps_global->VAR_SORT_RULES);
+     if (rule_result && *rule_result){
+        new_sort  = (SortOrder) translate(rule_result, 1);
+        is_rev    = (SortOrder) translate(rule_result, 0) == EndofList ? 0 : 1;
+        fs_give((void **)&rule_result);
+     }
+     if (new_sort != EndofList){
+         the_sort_order = new_sort;
+ 	sort_is_rev    = the_sort_order == SortThread 
+ 		        ? (ps_global->thread_def_sort_rev +is_rev) % 2 : is_rev;
+     }
+     else{
+       /* set default order */
+       the_sort_order = ps_global->def_sort;
+       sort_is_rev    = the_sort_order == SortThread 
+ 	? (ps_global->thread_def_sort_rev + ps_global->def_sort_rev) % 2 
+ 	: ps_global->def_sort_rev;
  
!       if(ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
  	    if(match_pattern(pat->patgrp, ps_global->mail_stream, NULL,
  			     NULL, NULL, 0))
***************
*** 8082,8093 ****
  	if(pat && pat->action && !pat->action->bogus
  	   && pat->action->sort_is_set){
  	    the_sort_order = pat->action->sortorder;
! 	    sort_is_rev    = pat->action->revsort;
  	}
!     }
  
      sort_folder(ps_global->mail_stream, ps_global->msgmap,
! 		the_sort_order, sort_is_rev, flags);
  }
  
  
--- 8327,8345 ----
  	if(pat && pat->action && !pat->action->bogus
  	   && pat->action->sort_is_set){
  	    the_sort_order = pat->action->sortorder;
! 	    sort_is_rev    = the_sort_order == SortThread 
! 		? (ps_global->thread_def_sort_rev + pat->action->revsort) % 2
! 		: pat->action->revsort;
  	}
!       }
!    }
! 
!     if (ps_global->thread_cur_sort != SortArrival 
! 	&& ps_global->thread_cur_sort != SortThread)
! 	ps_global->thread_cur_sort = ps_global->thread_def_sort;
  
      sort_folder(ps_global->mail_stream, ps_global->msgmap,
! 		the_sort_order, sort_is_rev, flags, 1);
  }
  
  
***************
*** 8172,8177 ****
--- 8424,8430 ----
            temp[MAILTMPLEN+1], buff1[MAX_SCREEN_COLS+1], *moved_msg = NULL,
  	  buff2[MAX_SCREEN_COLS+1], *folder;
      CONTEXT_S *context;
+     FOLDER_S  *f;
      struct variable *vars = ps_global->vars;
      int ret, expunge = FALSE, no_close = 0;
      char ing[4];
***************
*** 8188,8194 ****
      }
  
      if(stream != NULL){
! 	context = sp_context(stream);
  	folder  = STREAMNAME(stream);
  
          dprint(2, (debugfile, "expunge_and_close: \"%s\"%s\n",
--- 8441,8447 ----
      }
  
      if(stream != NULL){
! 	context = ps_global->context_current;
  	folder  = STREAMNAME(stream);
  
          dprint(2, (debugfile, "expunge_and_close: \"%s\"%s\n",
***************
*** 8201,8206 ****
--- 8454,8465 ----
  	buff1[0] = '\0';
  	buff2[0] = '\0';
  
+ 	if(F_OFF(F_ENABLE_FAST_RECENT,ps_global) && 
+ 	   (f = incoming_folder_data(stream, context))){ 
+ 	   new_mail_in_open_stream(stream, &(f->recent), &(f->messages));
+ 	   f->notified   = 0;
+ 	}
+ 
          if(!stream->rdonly){
  
  	    if(!no_close){
***************
*** 8228,8236 ****
  	    /* Save read messages? */
  	    if(VAR_READ_MESSAGE_FOLDER && VAR_READ_MESSAGE_FOLDER[0]
  	       && sp_flagged(stream, SP_INBOX)
! 	       && (seen_not_del = count_flagged(stream, F_SEEN | F_UNDEL))){
  
  		if(F_ON(F_AUTO_READ_MSGS,ps_global)
  		   || read_msg_prompt(seen_not_del, VAR_READ_MESSAGE_FOLDER))
  		  /* move inbox's read messages */
  		  moved_msg = move_read_msgs(stream, VAR_READ_MESSAGE_FOLDER,
--- 8487,8497 ----
  	    /* Save read messages? */
  	    if(VAR_READ_MESSAGE_FOLDER && VAR_READ_MESSAGE_FOLDER[0]
  	       && sp_flagged(stream, SP_INBOX)
! 	       && (F_ON(F_AUTO_READ_MSGS_RULES, ps_global) ||
! 	          (seen_not_del = count_flagged(stream, F_SEEN | F_UNDEL)))){
  
  		if(F_ON(F_AUTO_READ_MSGS,ps_global)
+ 		   || F_ON(F_AUTO_READ_MSGS_RULES, ps_global)
  		   || read_msg_prompt(seen_not_del, VAR_READ_MESSAGE_FOLDER))
  		  /* move inbox's read messages */
  		  moved_msg = move_read_msgs(stream, VAR_READ_MESSAGE_FOLDER,
***************
*** 9839,9844 ****
--- 10100,10108 ----
      char	  *bufp = NULL;
      MESSAGECACHE *mc;
  
+     if (F_ON(F_AUTO_READ_MSGS_RULES, ps_global))
+      return move_read_msgs_using_rules(stream, dstfldr, buf);
+ 
      if(!is_absolute_path(dstfldr)
         && !(save_context = default_save_context(ps_global->context_list)))
        save_context = ps_global->context_list;
***************
*** 9880,9887 ****
  	sprintf(buf, "Moving %s read message%s to \"%.45s\"",
  		comatose(searched), plural(searched), dstfldr);
  	we_cancel = busy_alarm(1, buf, NULL, 1);
! 	if(save(ps_global, stream, save_context, dstfldr, msgmap,
! 		SV_DELETE | SV_FIX_DELS) == searched)
  	  strncpy(bufp = buf + 1, "Moved", 5); /* change Moving to Moved */
  
  	mn_give(&msgmap);
--- 10144,10152 ----
  	sprintf(buf, "Moving %s read message%s to \"%.45s\"",
  		comatose(searched), plural(searched), dstfldr);
  	we_cancel = busy_alarm(1, buf, NULL, 1);
! 	ps_global->exiting = 1;
! 	if((save(ps_global, stream, save_context, dstfldr, msgmap,
! 		SV_DELETE | SV_FIX_DELS) == searched))
  	  strncpy(bufp = buf + 1, "Moved", 5); /* change Moving to Moved */
  
  	mn_give(&msgmap);
***************
*** 9892,9897 ****
--- 10157,10295 ----
      return(bufp);
  }
  
+ char *
+ move_read_msgs_using_rules(stream, dstfldr,buf)
+     MAILSTREAM *stream;
+     char       *dstfldr;
+     char       *buf;
+ {
+     CONTEXT_S  *save_context = NULL;
+     char **folder_to_save = NULL;
+     int  num, we_cancel;
+     long i, j, success, nmsgs = 0L;
+     MSGNO_S *msgmap = NULL;
+ 
+     saved_stream = stream;		/* horrible hack! */
+     if(!is_absolute_path(dstfldr)
+        && !(save_context = default_save_context(ps_global->context_list)))
+        save_context = ps_global->context_list;
+ 
+     folder_to_save = (char **)fs_get((stream->nmsgs + 1)*sizeof(char *));
+     folder_to_save[0] = NULL;
+     mn_init(&msgmap, stream->nmsgs);  
+     for (i = 1L; i <= stream->nmsgs ; i++){
+ 	set_lflag(stream, msgmap, i, MN_SLCT, 0);
+         folder_to_save[i] = get_lflag(stream, NULL, i, MN_EXLD)
+ 				? NULL : get_folder_to_save(stream, i, dstfldr);
+     }
+     for (i = 1L; i <= stream->nmsgs; i++){
+ 	num = 0;
+         if (folder_to_save[i]){
+ 	   mn_init(&msgmap, stream->nmsgs);  
+            for (j = i; j <= stream->nmsgs ; j++){
+         	if (folder_to_save[j]){
+                    if (!strcmp(folder_to_save[i], folder_to_save[j])){
+                         set_lflag(stream, msgmap, j, MN_SLCT, 1);
+                         num++;
+                         if (j != i)
+                            fs_give((void **)&folder_to_save[j]);
+                    }
+                  }
+            }
+            pseudo_selected(msgmap);
+            sprintf(buf, "Moving %s read message%s to \"%.45s\"",
+            	      comatose(num), plural(num), folder_to_save[i]);
+            we_cancel = busy_alarm(1, buf, NULL, 1);
+            ps_global->exiting = 1;
+            if(success = save(ps_global, stream,save_context, folder_to_save[i],
+                  		msgmap, SV_DELETE | SV_FIX_DELS))
+            nmsgs += success;
+            if(we_cancel)
+              cancel_busy_alarm(success ? 0 : -1);
+            for (j = i; j <= stream->nmsgs ; j++)
+                set_lflag(stream, msgmap, j, MN_SLCT, 0);
+            fs_give((void **)&folder_to_save[i]);
+ 	   mn_give(&msgmap);
+         }
+     }
+     ps_global->exiting = 0; /* useful if we call from aggregate operations */
+     sprintf(buf, "Moved automatically %s message%s",
+ 		comatose(nmsgs), plural(nmsgs));
+     if (folder_to_save)
+         fs_give((void **)folder_to_save);
+     rule_curpos = 0L;
+     return buf;
+ }
+ 
+ unsigned long
+ rules_cursor_pos(stream)
+   MAILSTREAM *stream;
+ {
+   MSGNO_S *msgmap = sp_msgmap(stream);
+   return rule_curpos != 0L ? rule_curpos : mn_get_cur(msgmap);
+ }
+ 
+ 
+ MAILSTREAM *
+ find_open_stream()
+ {
+  return saved_stream;
+ }
+ 
+ char *
+ get_folder_to_save(stream, i, dstfldr)
+   MAILSTREAM *stream;
+   long  i;
+   char  *dstfldr;
+ {
+     MESSAGECACHE *mc = NULL;
+     RULE_RESULT *rule;
+     MSGNO_S *msgmap = NULL;
+     char *folder_to_save = NULL, *save_folder = NULL;
+     int n;
+     long msgno;
+ 
+     /* The plan is as follows: Select each message of the folder. We
+      * need to set the cursor correctly so that iFlag gets the value
+      * correctly too, otherwise iFlag will get the value of the position
+      * of the cursor. After that we need to look for a rule that applies
+      * to the message and get the saving folder. If we get a saving folder,
+      * and we used the _FLAG_ token, use that folder, if no
+      * _FLAG_ token was used, move only if seen and not deleted, to the
+      * folder specified in the saving rule. If we did not get a saving
+      * folder from the rule, just save in the default folder.
+      */
+ 
+     mn_init(&msgmap, stream->nmsgs);
+     rule_curpos = i;
+     msgno = mn_m2raw(msgmap, i);
+     if (msgno > 0L){
+ 	mc = mail_elt(stream, msgno);
+ 	rule = (RULE_RESULT *)
+             get_result_rule(ps_global->VAR_SAVE_RULES, FOR_RULE | FOR_SAVE, 
+ 					(ENVELOPE *) mc->private.msg.env);
+ 	if (rule){
+ 	    folder_to_save = cpystr(rule->result);
+ 	    n = rule->number;
+ 	    fs_give((void **)&rule->result);
+ 	    fs_give((void **)&rule);
+         }
+     }
+               
+     if (folder_to_save && *folder_to_save){
+ 	if (strstr(ps_global->VAR_SAVE_RULES[n],"_FLAG_")
+ 	     || (mc->valid && mc->seen && !mc->deleted) 
+ 	     || (!mc->valid && mc->searched))
+ 	     save_folder = cpystr(folder_to_save);
+ 	  else
+ 	     save_folder = NULL;
+     }
+     else
+        if (!mc || (mc->seen && !mc->deleted))
+ 	  save_folder = cpystr(dstfldr);
+     mn_init(&msgmap, stream->nmsgs);
+     return save_folder;
+ }
  
  
  /*----------------------------------------------------------------------
***************
*** 9938,9944 ****
         && ((context_isambig(folder)
  	    && folder_is_nick(folder, FOLDERS(context), 0))
  	   || folder_index(folder, context, FI_FOLDER) > 0)
!        && (seen_undel = count_flagged(stream, F_SEEN | F_UNDEL))){
  
  	for(; f && *archive; archive++){
  	    char *p;
--- 10336,10344 ----
         && ((context_isambig(folder)
  	    && folder_is_nick(folder, FOLDERS(context), 0))
  	   || folder_index(folder, context, FI_FOLDER) > 0)
!        && ((seen_undel = count_flagged(stream, F_SEEN | F_UNDEL))
! 	   || (F_ON(F_AUTO_READ_MSGS,ps_global) &&
! 	       F_ON(F_AUTO_READ_MSGS_RULES, ps_global)))){
  
  	for(; f && *archive; archive++){
  	    char *p;
***************
*** 11207,11219 ****
  
    ----*/
  int
! apply_command(state, stream, msgmap, preloadkeystroke, flags, q_line)
       struct pine *state;
       MAILSTREAM	 *stream;
       MSGNO_S     *msgmap;
       int	  preloadkeystroke;
       int	  flags;
       int	  q_line;
  {
      int i = 8,			/* number of static entries in sel_opts3 */
          rv = 1,
--- 11607,11620 ----
  
    ----*/
  int
! apply_command(state, stream, msgmap, preloadkeystroke, flags, q_line, display)
       struct pine *state;
       MAILSTREAM	 *stream;
       MSGNO_S     *msgmap;
       int	  preloadkeystroke;
       int	  flags;
       int	  q_line;
+      int	  display;
  {
      int i = 8,			/* number of static entries in sel_opts3 */
          rv = 1,
***************
*** 11340,11348 ****
  	collapse_or_expand(state, stream, msgmap,
  			   F_ON(F_SLASH_COLL_ENTIRE, ps_global)
  			     ? 0L
! 			     : mn_get_cur(msgmap));
  	break;
  
        case ':' :
  	select_thread_stmp(state, stream, msgmap);
  	break;
--- 11741,11759 ----
  	collapse_or_expand(state, stream, msgmap,
  			   F_ON(F_SLASH_COLL_ENTIRE, ps_global)
  			     ? 0L
! 			     : mn_get_cur(msgmap),
! 			   display);
  	break;
  
+       case '[' :
+ 	collapse_this_thread(state, stream, msgmap, display, 0);
+       break;
+ 
+       case ']' :
+ 	expand_this_thread(state, stream, msgmap, display, 0);
+       break;
+ 
+ 
        case ':' :
  	select_thread_stmp(state, stream, msgmap);
  	break;
***************
*** 11840,11845 ****
--- 12251,12257 ----
      SEARCHSET  **msgset;
  {
      PINETHRD_S *nthrd, *bthrd;
+     unsigned long next, branch;
  
      if(!(stream && thrd))
        return;
***************
*** 11848,11861 ****
         && (!(msgset && *msgset) || in_searchset(*msgset, thrd->rawno)))
        mm_searched(stream, thrd->rawno);
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_search_bit_for_thread(stream, nthrd, msgset);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  set_search_bit_for_thread(stream, bthrd, msgset);
      }
--- 12260,12273 ----
         && (!(msgset && *msgset) || in_searchset(*msgset, thrd->rawno)))
        mm_searched(stream, thrd->rawno);
  
!     if(next= get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  set_search_bit_for_thread(stream, nthrd, msgset);
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  set_search_bit_for_thread(stream, bthrd, msgset);
      }
***************
*** 12055,12061 ****
  {
      int          r, type, we_cancel = 0, not = 0, flags, old_imap;
      char         sstring[80], savedsstring[80], origcharset[16], tmp[128];
!     char        *sval = NULL, *cset = NULL, *charset = NULL;
      char         buftmp[MAILTMPLEN];
      ESCKEY_S     ekey[4];
      ENVELOPE    *env = NULL;
--- 12467,12473 ----
  {
      int          r, type, we_cancel = 0, not = 0, flags, old_imap;
      char         sstring[80], savedsstring[80], origcharset[16], tmp[128];
!     char	 namehdr[80], *sval = NULL, *cset = NULL, *charset = NULL;
      char         buftmp[MAILTMPLEN];
      ESCKEY_S     ekey[4];
      ENVELOPE    *env = NULL;
***************
*** 12124,12129 ****
--- 12536,12575 ----
  	sval = "BODYTEXT";
  	break;
  
+       case 'h' :
+ 	sprintf(tmp, "Name of HEADER to match : ");
+ 	flags = OE_APPEND_CURRENT;
+ 	namehdr[0] = '\0';
+ 	r = 'x';
+ 	while (r == 'x'){
+ 	       int done = 0;
+ 
+ 	       r = optionally_enter(namehdr, -FOOTER_ROWS(ps_global), 0,
+ 				 sizeof(namehdr), tmp, ekey, NO_HELP, &flags);
+ 	       if (r == 1){
+ 		  cmd_cancelled("Selection by text");
+ 		  return(1);
+ 	       }
+ 	       removing_leading_white_space(namehdr);
+ 	       while(!done){
+ 	          while ((namehdr[0] != '\0') && /* remove trailing ":" */
+ 			(namehdr[strlen(namehdr) - 1] == ':'))
+ 		     namehdr[strlen(namehdr) - 1] = '\0';
+ 		  if ((namehdr[0] != '\0') 
+ 		     && isspace((unsigned char) namehdr[strlen(namehdr) - 1]))
+ 		       removing_trailing_white_space(namehdr);
+ 		  else
+ 		    done++;
+ 	       }
+ 	       if (strchr(namehdr,' ') || strchr(namehdr,'\t') ||
+ 		   strchr(namehdr,':'))
+ 		  namehdr[0] = '\0';
+ 	       if (namehdr[0] == '\0')
+ 	         r = 'x';
+ 	}
+ 	sval = namehdr;
+ 	break;
+ 
        case 'x':
  	break;
  
***************
*** 12247,12252 ****
--- 12693,12701 ----
      }
  
      switch(type){
+       case 'h' :				/* Any header */
+ 	pgm->header = mail_newsearchheader (namehdr,sstring);
+ 	break;
        case 'r' :				/* TO or CC */
  	if(old_imap){
  	    /* No OR on old servers */
***************
*** 12749,12754 ****
--- 13198,13211 ----
  	  
  	break;
  
+       case 'r':
+ 	if(not)
+ 	  pgm->old = 1;
+ 	else
+ 	  pgm->recent = 1;
+ 
+ 	break;
+ 
        case 'd' :
  	if(not)
  	  pgm->undeleted = 1;
***************
*** 13050,13063 ****
        Returns 0 if it was cancelled, 1 otherwise.
    ----*/
  int
! select_sort(state, ql, sort, rev)
       struct pine *state;
       int	  ql;
       SortOrder	 *sort;
       int	 *rev;
  {
      char      prompt[200], tmp[3], *p;
!     int       s, i;
      int       deefault = 'a', retval = 1;
      HelpType  help;
      ESCKEY_S  sorts[14];
--- 13507,13521 ----
        Returns 0 if it was cancelled, 1 otherwise.
    ----*/
  int
! select_sort(state, ql, sort, rev, thread)
       struct pine *state;
       int	  ql;
       SortOrder	 *sort;
       int	 *rev;
+      int	  thread;
  {
      char      prompt[200], tmp[3], *p;
!     int       s, i, j;
      int       deefault = 'a', retval = 1;
      HelpType  help;
      ESCKEY_S  sorts[14];
***************
*** 13086,13102 ****
      /*----- String together the prompt ------*/
      tmp[1] = '\0';
      strcpy(prompt, "Choose type of sort, or 'R' to reverse current sort : ");
!     for(i = 0; state->sort_types[i] != EndofList; i++) {
! 	sorts[i].rval	   = i;
! 	p = sorts[i].label = sort_name(state->sort_types[i]);
! 	while(*(p+1) && islower((unsigned char)*p))
! 	  p++;
! 
! 	sorts[i].ch   = tolower((unsigned char)(tmp[0] = *p));
! 	sorts[i].name = cpystr(tmp);
! 
!         if(mn_get_sort(state->msgmap) == state->sort_types[i])
! 	  deefault = sorts[i].rval;
      }
  
      sorts[i].ch     = 'r';
--- 13544,13570 ----
      /*----- String together the prompt ------*/
      tmp[1] = '\0';
      strcpy(prompt, "Choose type of sort, or 'R' to reverse current sort : ");
!     for(i = 0, j = 0; state->sort_types[i] != EndofList; i++) {
! 	sorts[i].rval = i;
! 	sorts[i].name = cpystr("");
! 	sorts[i].label = "";
! 	sorts[i].ch    = -2;
! 	if (!thread || state->sort_types[i] == SortArrival
!             || state->sort_types[i] == SortThread){
! 	   p = sorts[j].label = sort_name(state->sort_types[i]);
! 	   while(*(p+1) && islower((unsigned char)*p))
! 	     p++;
! 	   sorts[j].ch   = tolower((unsigned char)(tmp[0] = *p));
! 	   sorts[j++].name = cpystr(tmp);
! 	}
! 
! 	if (thread){
! 	   if (state->thread_def_sort == state->sort_types[i])
! 	       deefault = sorts[j-1].rval;
! 	}
! 	else
!             if(mn_get_sort(state->msgmap) == state->sort_types[i])
! 	       deefault = sorts[i].rval;
      }
  
      sorts[i].ch     = 'r';
***************
*** 13111,13117 ****
  	if(s == 'r')
  	  *rev = !mn_get_revsort(state->msgmap);
  	else
! 	  *sort = state->sort_types[s];
  
  	if(F_ON(F_SHOW_SORT, ps_global))
  	  ps_global->mangled_header = 1;
--- 13579,13585 ----
  	if(s == 'r')
  	  *rev = !mn_get_revsort(state->msgmap);
  	else
! 	  *sort = state->sort_types[thread ? (s == 0 ? 1 : 9) : s];
  
  	if(F_ON(F_SHOW_SORT, ps_global))
  	  ps_global->mangled_header = 1;
***************
*** 13795,13797 ****
--- 14263,14961 ----
      return(flag_submenu);
  }
  #endif	/* _WINDOWS */
+ 
+ /* Extra Fancy Thread support */
+ 
+ long
+ top_thread(stream, rawmsgno)
+   MAILSTREAM	*stream;
+   long		 rawmsgno;
+ {
+      PINETHRD_S   *thrd = NULL;
+      unsigned long rawno;
+ 
+      if(!stream)
+        return -1L;
+ 
+      if(rawmsgno)
+        thrd = fetch_thread(stream, rawmsgno);
+ 
+      if(!thrd)
+        return -1L;
+ 
+      return F_ON(F_ENHANCED_THREAD, ps_global) 
+ 		? (thrd->toploose ? thrd->toploose : thrd->top)
+ 		: thrd->top;
+ }
+ 
+ void
+ move_top_thread(stream, msgmap, rawmsgno)
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     long       rawmsgno;
+ {
+     mn_set_cur(msgmap,mn_raw2m(msgmap, top_thread(stream, rawmsgno)));
+ }
+ 
+ long
+ top_this_thread(stream, rawmsgno)
+   MAILSTREAM	*stream;
+   long		 rawmsgno;
+ {
+      PINETHRD_S   *thrd = NULL;
+      unsigned long rawno;
+ 
+      if(!stream)
+        return -1L;
+ 
+      if(rawmsgno)
+        thrd = fetch_thread(stream, rawmsgno);
+ 
+      if(!thrd)
+        return -1L;
+ 
+      return thrd->top;
+ }
+ 
+ void
+ move_top_this_thread(stream, msgmap, rawmsgno)
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     long       rawmsgno;
+ {
+     mn_set_cur(msgmap,mn_raw2m(msgmap, top_this_thread(stream, rawmsgno)));
+ }
+ 
+ 
+ void
+ cmd_delete_this_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     unsigned long rawno, top, save_kolapsed;
+     PINETHRD_S   *thrd = NULL, *nxthrd;
+ 
+     if(!stream)
+       return;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_this_thread(stream, msgmap, rawno);
+     top =  mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     save_kolapsed = this_thread_is_kolapsed(state, stream, msgmap, top);
+     collapse_this_thread(state, stream, msgmap, 0, 0);
+     thread_command(state, stream, msgmap, 'd', -FOOTER_ROWS(state), 1);
+     if (!save_kolapsed)
+        expand_this_thread(state, stream, msgmap, 0, 0);
+ }
+ 
+ void
+ cmd_delete_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     unsigned long rawno, top, orig_top, topnxt, save_kolapsed;
+     PINETHRD_S   *thrd = NULL, *nxthrd;
+     int done = 0, count;
+ 
+     if(!stream)
+       return;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap, rawno);
+     top =  orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     while (!done){
+       cmd_delete_this_thread(state, stream, msgmap);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, rawno));
+     cmd_delete(state, msgmap, 0, MsgIndx);
+     count = count_thread(state, stream, msgmap, rawno);
+     q_status_message2(SM_ORDER, 0, 1, "%s message%s marked deleted",
+ 		int2string(count), plural(count));
+ }
+ 
+ 
+ 
+ int
+ thread_is_kolapsed(state, stream, msgmap, rawmsgno)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     long       rawmsgno;
+ {
+     int          collapsed;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno, orig, orig_rawno;
+ 
+     if(!stream)
+       return -1;
+ 
+     orig = mn_get_cur(msgmap);
+     move_top_thread(stream, msgmap, rawmsgno);
+     rawno = orig_rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return -1;
+     
+     while(collapsed = this_thread_is_kolapsed(state, stream, msgmap, rawno))
+        if (F_OFF(F_ENHANCED_THREAD, state)
+           || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	  || !(rawno = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	  || (orig_rawno != top_thread(stream, rawno)))
+ 	break;
+ 
+     mn_set_cur(msgmap,orig); /* return home */
+ 
+     return collapsed;
+ }
+ 
+ /* this function tells us if the thread (or branch in the case of loose threads)
+  * is collapsed
+  */
+ 
+ int
+ this_thread_is_kolapsed(state, stream, msgmap, rawmsgno)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     long       rawmsgno;
+ {
+     int          collapsed;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno, orig;
+ 
+     if(!stream)
+       return -1;
+ 
+     rawno = rawmsgno;
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return -1;
+ 
+     collapsed = get_lflag(stream, NULL, rawno, MN_COLL | MN_CHID);
+ 
+     if (!thrd->next){
+       if (thrd->rawno != top_thread(stream, thrd->rawno))
+ 	collapsed = get_lflag(stream, NULL, rawno,  MN_CHID);
+       else
+ 	collapsed = get_lflag(stream, NULL, rawno,  MN_COLL);
+     }
+ 
+     return collapsed;
+ }
+ 
+ int
+ collapse_this_thread(state, stream, msgmap, display, special)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int          display;
+     int		 special;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL, *nthrd;
+     unsigned long rawno, orig, msgno;
+ 
+     if(!stream)
+       return 0;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(rawno)
+        thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+        return rv;
+ 
+     collapsed = this_thread_is_kolapsed(state, stream, msgmap, rawno);
+ 
+     if (special && collapsed){
+ 	expand_this_thread(state, stream, msgmap, 0, 0);
+ 	collapsed = 0;
+     }
+ 
+     clear_index_cache_ent(mn_raw2m(msgmap,rawno));
+ 
+     if (!collapsed && thrd->next){
+        if (thrd->rawno == top_thread(stream, thrd->rawno))
+          collapse_or_expand(state, stream, msgmap, mn_get_cur(msgmap), display);
+        else{
+ 	 set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno), MN_COLL, 1);
+ 	 set_thread_subtree(stream, thrd, msgmap, 1, MN_CHID);
+        }
+     }
+     else{
+        if (!collapsed && special 
+ 	   && ((F_OFF(F_ENHANCED_THREAD, state) && !thrd->next) 
+ 	        || F_ON(F_ENHANCED_THREAD, state))){
+ 	  if (thrd->toploose){
+ 	    if (thrd->rawno != thrd->toploose)
+ 	       set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno),MN_CHID, 
+ 									     1);
+ 	    else
+ 	       set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno),MN_COLL,
+ 									     1);
+ 	  }
+        }
+        else{
+          rv = 0; 
+          if (display)
+             q_status_message(SM_ORDER, 0, 1, "Thread already collapsed");
+        }
+     }
+     return rv;
+ }
+ 
+ void
+ collapse_thread(state, stream, msgmap, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int          display;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long orig, orig_top, top;
+ 
+     if(!stream)
+       return;
+ 
+     expand_this_thread(state, stream, msgmap, display, 1);
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap,orig);
+     top = orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     while (!done){
+       collapse_this_thread(state, stream, msgmap, display, 1);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, orig_top));
+ }
+ 
+ int
+ expand_this_thread(state, stream, msgmap, display, special)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int          display;
+     int		 special;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL, *nthrd;
+     unsigned long rawno, orig, msgno;
+ 
+     if(!stream)
+       return 0;
+ 
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_this_thread(stream, msgmap,orig);
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(rawno)
+        thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+        return rv;
+ 
+     collapsed = this_thread_is_kolapsed(state, stream, msgmap, rawno);
+ 
+     if (special && !collapsed){
+ 	collapse_this_thread(state, stream, msgmap, 0, 0);
+ 	collapsed = 1;
+     }
+ 
+     clear_index_cache_ent(mn_raw2m(msgmap,rawno));
+ 
+      if (collapsed && thrd->next){
+        if (thrd->rawno == top_thread(stream, thrd->rawno))
+          collapse_or_expand(state, stream, msgmap, mn_get_cur(msgmap), display);
+        else{
+         set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno), MN_COLL, 0);
+ 	 set_thread_subtree(stream, thrd, msgmap, 0, MN_CHID);
+        }
+      }
+      else{
+        if (collapsed && special 
+ 	&& ((F_OFF(F_ENHANCED_THREAD, state) && !thrd->next) 
+ 	   || F_ON(F_ENHANCED_THREAD, state))){ 
+ 	  if (thrd->toploose)
+ 	    if (thrd->rawno != thrd->toploose)
+ 	       set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno),MN_CHID, 0);
+ 	    else
+ 	       set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno),MN_COLL, 0);
+        }
+        else{
+          rv = 0; 
+          if (display)
+             q_status_message(SM_ORDER, 0, 1, "Thread already expanded");
+        }
+      }
+     return rv;
+ }
+ 
+ void
+ expand_thread(state, stream, msgmap, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int          display;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long orig, orig_top, top;
+ 
+     if(!stream)
+       return;
+ 
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     top = orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     while (!done){
+       expand_this_thread(state, stream, msgmap, display, 1);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, orig_top));
+ }
+ 
+ 
+ void
+ cmd_undelete_this_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     unsigned long rawno;
+     int save_kolapsed;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     save_kolapsed = this_thread_is_kolapsed(state, stream, msgmap, rawno);
+     collapse_this_thread(state, stream, msgmap, 0, 0);
+     thread_command(state, stream, msgmap, 'u', -FOOTER_ROWS(state), 1);
+     if (!save_kolapsed)
+        expand_this_thread(state, stream, msgmap, 0, 0);
+ }
+ 
+ void
+ cmd_undelete_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno, top, orig_top;
+     int done = 0, count;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap, rawno);
+     top =  orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     while (!done){
+       cmd_undelete_this_thread(state, stream, msgmap);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, rawno));
+     count = count_thread(state, stream, msgmap, rawno);
+     q_status_message2(SM_ORDER, 0, 1, "Deletion mark removed from %s message%s",
+ 		int2string(count), plural(count));
+ }
+ 
+ void
+ kolapse_thread(state, stream, msgmap, ch, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     char      ch;
+     int		display;
+ {
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno;
+     int       rv = 1, done = 0;
+ 
+     if(!stream)
+       return;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return;
+ 
+     clear_index_cache();
+     mn_set_cur(msgmap,1); /* go to the first message */
+     while (!done){
+       if (ch == '[')
+ 	collapse_thread(state, stream, msgmap, display);
+       else
+ 	expand_thread(state, stream, msgmap, display);
+       if ((rv = move_next_thread(state, stream, msgmap, 0)) <= 0)
+          done++;
+     }
+ 
+     if (rv < 0){
+       if (display)
+       q_status_message(SM_ORDER, 0, 1, (ch == '[')
+                ? "Error while collapsing thread"
+                : "Error while expanding thread");
+     }
+     else
+       if(display)
+       q_status_message(SM_ORDER, 0, 1, (ch == '[')
+                ? "All threads collapsed. Use \"}\" to expand them"
+                : "All threads expanded. Use \"{\" to collapse them");
+ 
+     mn_set_cur(msgmap,mn_raw2m(msgmap, top_thread(stream,rawno)));
+ }
+ 
+ int
+ move_next_this_thread(state, stream, msgmap, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int                display;
+ {
+     PINETHRD_S   *thrd = NULL, *thrdnxt;
+     unsigned long rawno, top;
+     int       rv = 1;
+ 
+     if(!stream)
+        return -1;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return -1;
+ 
+    top = top_thread(stream, rawno);
+ 
+    thrdnxt = (top == rawno) ? fetch_thread(stream, top) : thrd;
+    if (thrdnxt->nextthd)
+        mn_set_cur(msgmap,mn_raw2m(msgmap, thrdnxt->nextthd));
+    else{
+        rv = 0;
+        if (display)
+          q_status_message(SM_ORDER, 0, 1, "No more Threads to advance");
+    }
+    return rv;
+ }
+ 
+ int
+ move_next_thread(state, stream, msgmap, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int                display;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long orig, orig_top, top;
+ 
+     if(!stream)
+       return 0;
+ 
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap,orig);
+     top = orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return 0;
+ 
+     while (rv > 0 && !done){
+       rv = move_next_this_thread(state, stream, msgmap, display);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     if (display){
+   	if (rv > 0 && SEP_THRDINDX())
+            q_status_message(SM_ORDER, 0, 2, "Viewing next thread");
+ 	if (!rv)
+            q_status_message(SM_ORDER, 0, 2, "No more threads to advance");
+     }
+     if(rv <= 0){
+        rv = 0;
+        mn_set_cur(msgmap, mn_raw2m(msgmap, orig));
+     }
+ 
+    return rv;
+ }
+ 
+ int
+ move_prev_thread(state, stream, msgmap, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int                display;
+ {
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno, top;
+     int rv = 1;
+ 
+     if(!stream)
+       return -1;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+        return -1;
+ 
+     top = top_thread(stream, rawno);
+ 
+     if (top != rawno)
+        mn_set_cur(msgmap,mn_raw2m(msgmap, top));
+     else if (thrd->prevthd)
+        mn_set_cur(msgmap,mn_raw2m(msgmap, top_thread(stream,thrd->prevthd)));
+     else
+       rv = 0;
+     if (display){
+   	if (rv && SEP_THRDINDX())
+            q_status_message(SM_ORDER, 0, 2, "Viewing previous thread");
+ 	if (!rv)
+            q_status_message(SM_ORDER, 0, 2, "No more threads to go back");
+     }
+ 
+     return rv;
+ }
+ 
+ void
+ cmd_select_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     unsigned long rawno;
+     int save_kolapsed;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     save_kolapsed = thread_is_kolapsed(state, stream, msgmap, rawno);
+     collapse_thread(state, stream, msgmap, 0);
+     thread_command(state, stream, msgmap, ':', -FOOTER_ROWS(state), 1);
+     if (!save_kolapsed)
+        expand_thread(state, stream, msgmap, 0);
+ }
+ 
+ /* 
+  * This function assumes that it is called at a top of a thread in its 
+  * first call
+  */
+ 
+ int
+ count_this_thread(stream, rawno)
+     MAILSTREAM  *stream;
+     unsigned long rawno;
+ {
+     unsigned long top, orig_top, topnxt;
+     PINETHRD_S   *thrd = NULL;
+     int count = 1;
+ 
+     if(!stream)
+       return 0;
+ 
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return 0;
+ 
+     if (thrd->next)
+        count += count_this_thread(stream, thrd->next);
+ 
+     if (thrd->branch)
+        count += count_this_thread(stream, thrd->branch);
+ 
+     return count;
+ }
+ 
+ int
+ count_thread(state, stream, msgmap, rawno)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     long	 rawno;
+ {
+     unsigned long top, orig, orig_top;
+     PINETHRD_S   *thrd = NULL;
+     int done = 0, count = 0;
+ 
+     if(!stream)
+       return 0;
+ 
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap,rawno);
+     top =  orig_top = top_thread(stream, rawno);
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return 0;
+ 
+     while (!done){
+       count += count_this_thread(stream, top);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, orig));
+     return count;
+ }
diff -rc pine4.61/pine/mailindx.c pine4.61.I.USE/pine/mailindx.c
*** pine4.61/pine/mailindx.c	Mon Jun 14 14:59:15 2004
--- pine4.61.I.USE/pine/mailindx.c	Thu Sep 23 12:08:49 2004
***************
*** 112,119 ****
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	NULL_MENU,
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
  INST_KEY_MENU(index_keymenu, index_keys);
--- 112,132 ----
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	{"K","Sort Thread",{MC_SORTHREAD,1,{'k'}},KS_NONE},
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
+ 	{"{","Collapse All",{MC_KOLAPSE,1,{'{'}},KS_NONE},
+ 	{"}","Expand All", {MC_EXPTHREAD,1,{'}'}},KS_NONE},
+ 
+ 	HELP_MENU,
+ 	OTHER_MENU,
+ 	{")","Next Threa",{MC_NEXTHREAD,1,{')'}},KS_NONE},
+ 	{"(","Prev Threa",{MC_PRETHREAD,1,{'('}},KS_NONE},
+ 	{"^D","Delete Thr",{MC_DELTHREAD,1,{ctrl('D')}},KS_NONE},
+ 	{"^U","Undel Thre",{MC_UNDTHREAD,1,{ctrl('U')}},KS_NONE},
+ 	{"^T","Select Thr",{MC_SELTHREAD,1,{ctrl('T')}},KS_NONE},
+ 	{"^H","ChkIncFl",{MC_FORCECHECK,1,{ctrl('H')}},KS_NONE},
+ 	{"[","Close Thre",{MC_CTHREAD,1,{'['}},KS_NONE},
+ 	{"]","Open Threa",{MC_OTHREAD,1,{']'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
  INST_KEY_MENU(index_keymenu, index_keys);
***************
*** 197,205 ****
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	NULL_MENU,
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
  INST_KEY_MENU(thread_keymenu, thread_keys);
  
--- 210,231 ----
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	{"]","Open Threa",{MC_OTHREAD,1,{']'}},KS_NONE},
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
+ 	{")","Next Threa",{MC_NEXTHREAD,1,{')'}},KS_NONE},
+ 	{"(","Prev Threa",{MC_PRETHREAD,1,{'('}},KS_NONE},
+ 
+ 	HELP_MENU,
+ 	OTHER_MENU,
+ 	NULL_MENU,
+ 	NULL_MENU,
+ 	{"^D","Delete Thr",{MC_DELTHREAD,1,{ctrl('D')}},KS_NONE},
+ 	{"^U","Undel Thre",{MC_UNDTHREAD,1,{ctrl('U')}},KS_NONE},
+ 	{"^T","Select Thr",{MC_SELTHREAD,1,{ctrl('T')}},KS_NONE},
  	NULL_MENU,
+ 	NULL_MENU,
+ 	NULL_MENU,
+ 	{"K","Sort Thread",{MC_SORTHREAD,1,{'k'}},KS_NONE},
  	NULL_MENU};
  INST_KEY_MENU(thread_keymenu, thread_keys);
  
***************
*** 318,329 ****
  
  HLINE_S	       *(*format_index_line) PROTO((INDEXDATA_S *));
  void		(*setup_header_widths) PROTO((void));
! 
  
  
  /*
   * Internal prototypes
   */
  void            index_index_screen PROTO((struct pine *));
  void            thread_index_screen PROTO((struct pine *));
  void            setup_for_index_index_screen PROTO((void));
--- 344,360 ----
  
  HLINE_S	       *(*format_index_line) PROTO((INDEXDATA_S *));
  void		(*setup_header_widths) PROTO((void));
! static int erase_thread_info = 1;
  
  
  /*
   * Internal prototypes
   */
+ SortOrder	translate PROTO ((char *, int));
+ ENVELOPE        *make_envelope PROTO ((INDEXDATA_S *, int));
+ char	        *find_value PROTO ((char *,char *, int, char *, int, char *, int, INDEXDATA_S *, char **));
+ int		find_index_rule PROTO((void));
+ void	        setup_threading_display_style PROTO((void));
  void            index_index_screen PROTO((struct pine *));
  void            thread_index_screen PROTO((struct pine *));
  void            setup_for_index_index_screen PROTO((void));
***************
*** 349,354 ****
--- 380,393 ----
  void		index_data_env PROTO((INDEXDATA_S *, ENVELOPE *));
  int		set_index_addr PROTO((INDEXDATA_S *, char *, ADDRESS *,
  				      char *, int, char *));
+ unsigned long	get_next PROTO((MAILSTREAM *,PINETHRD_S *));
+ unsigned long	get_branch PROTO((MAILSTREAM *,PINETHRD_S *));
+ long		get_length_branch PROTO((MAILSTREAM *, long));
+ THREADNODE     *copy_tree PROTO((THREADNODE *));
+ void		find_msgmap PROTO((MAILSTREAM *, MSGNO_S *, int, SortOrder, 
+ 					unsigned));
+ void		move_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int));
+ void		relink_threads PROTO((MAILSTREAM *, MSGNO_S *, long *));
  int		i_cache_size PROTO((long));
  int		i_cache_width PROTO(());
  int             ctype_is_fixed_length PROTO((IndexColType));
***************
*** 390,406 ****
  struct pass_along
  	       *sort_thread_flatten PROTO((THREADNODE *, MAILSTREAM *,
  					   struct pass_along *,
! 					   PINETHRD_S *, unsigned));
  void            make_thrdflags_consistent PROTO((MAILSTREAM *, MSGNO_S *,
  						 PINETHRD_S *, int));
  THREADNODE     *collapse_threadnode_tree PROTO((THREADNODE *));
  PINETHRD_S     *msgno_thread_info PROTO((MAILSTREAM *, unsigned long,
  					 PINETHRD_S *, unsigned));
  long            calculate_visible_threads PROTO((MAILSTREAM *));
  void		set_thread_subtree PROTO((MAILSTREAM *, PINETHRD_S *,
  					  MSGNO_S *, int, int));
  void		thread_command PROTO((struct pine *, MAILSTREAM *, MSGNO_S *,
! 				      int, int));
  void		set_flags_for_thread PROTO((MAILSTREAM *, MSGNO_S *, int,
  					    PINETHRD_S *, int));
  unsigned long   count_flags_in_thread PROTO((MAILSTREAM *, PINETHRD_S *, long));
--- 429,447 ----
  struct pass_along
  	       *sort_thread_flatten PROTO((THREADNODE *, MAILSTREAM *,
  					   struct pass_along *,
! 					   PINETHRD_S *, unsigned, int, 
! 					   long,long));
  void            make_thrdflags_consistent PROTO((MAILSTREAM *, MSGNO_S *,
  						 PINETHRD_S *, int));
  THREADNODE     *collapse_threadnode_tree PROTO((THREADNODE *));
+ THREADNODE     *copy_tree PROTO((THREADNODE *));
  PINETHRD_S     *msgno_thread_info PROTO((MAILSTREAM *, unsigned long,
  					 PINETHRD_S *, unsigned));
  long            calculate_visible_threads PROTO((MAILSTREAM *));
  void		set_thread_subtree PROTO((MAILSTREAM *, PINETHRD_S *,
  					  MSGNO_S *, int, int));
  void		thread_command PROTO((struct pine *, MAILSTREAM *, MSGNO_S *,
! 				      int, int, int));
  void		set_flags_for_thread PROTO((MAILSTREAM *, MSGNO_S *, int,
  					    PINETHRD_S *, int));
  unsigned long   count_flags_in_thread PROTO((MAILSTREAM *, PINETHRD_S *, long));
***************
*** 592,600 ****
--- 633,644 ----
  	return;
      }
  
+     state->redrawer    = redraw_index_body;
      state->prev_screen = mail_index_screen;
      state->next_screen = SCREEN_FUN_NULL;
  
+     setup_threading_display_style();
+ 
      if(THRD_AUTO_VIEW() && sp_viewing_a_thread(state->mail_stream)
         && state->view_skipped_index)
        unview_thread(state, state->mail_stream, state->msgmap);
***************
*** 702,720 ****
       MAILSTREAM  *stream;
       MSGNO_S     *msgmap;
  {
!     int		 ch, cmd, which_keys, force,
  		 cur_row, cur_col, km_popped, paint_status;
      int          old_day = -1;
!     long	 i, j, k, old_max_msgno;
      IndexType    style, old_style = MsgIndex;
      struct index_state id;
      struct key_menu *km = NULL;
  #if defined(DOS) || defined(OS2)
      extern void (*while_waiting)();
  #endif
  
      dprint(1, (debugfile, "\n\n ---- INDEX MANAGER ----\n"));
!     
      ch                    = 'x';	/* For displaying msg 1st time thru */
      force                 = 0;
      km_popped             = 0;
--- 746,784 ----
       MAILSTREAM  *stream;
       MSGNO_S     *msgmap;
  {
!     int		 ch, cmd, which_keys, force, skip = 0,
  		 cur_row, cur_col, km_popped, paint_status;
      int          old_day = -1;
!     long	 i, j, k, old_max_msgno, nm;
      IndexType    style, old_style = MsgIndex;
      struct index_state id;
      struct key_menu *km = NULL;
+     char	*begin_string, *this_folder = folder_in_list(folder);
+     FOLDER_S *f;
  #if defined(DOS) || defined(OS2)
      extern void (*while_waiting)();
  #endif
  
      dprint(1, (debugfile, "\n\n ---- INDEX MANAGER ----\n"));
!     if ((f = incoming_folder_data(stream, cntxt)) && !f->user_selected){
! 	f->selected = 0;     /* unselect this folder now		     */
! 	f->notified = 1;     /* do not repaint due to changes in this folder */
!     }
!     if (f){
! 	f->origrecent  = stream->recent;
! 	f->countrecent = 0;
!     }
!     if (cntxt && cntxt->use & CNTXT_INCMNG && state->last_message && 
! 	 (begin_string = strstr(state->last_message,this_folder))){
! 	int index = 0, length_folder = strlen(this_folder);
! 
! 	while (begin_string[index + length_folder] != '\0'){
! 	   begin_string[index] = begin_string[index + length_folder];
! 	   index++;
! 	}
! 	begin_string[index] = '\0';
! 	fs_give((void **)&this_folder);
!     }    
      ch                    = 'x';	/* For displaying msg 1st time thru */
      force                 = 0;
      km_popped             = 0;
***************
*** 749,757 ****
  	}
  
  	/*------- Check for new mail -------*/
!         new_mail(force, NM_TIMING(ch), NM_STATUS_MSG);
! 	force = 0;			/* may not need to next time around */
! 
  	/*
  	 * If the width of the message number field in the display changes
  	 * we need to flush the cache and redraw. When the cache is cleared
--- 813,835 ----
  	}
  
  	/*------- Check for new mail -------*/
!         nm = new_mail(force, NM_TIMING(ch), NM_STATUS_MSG);
! 	if (!skip || nm >= 0L){
! 	   state->in_indx = 1;
! 	   if (nm >= 0L)
! 	      state->force_check_now = 1;
! 	   new_mail_incfolder(state, MC_IFAUTOCHECK);
! 	}
! 	if (f){
! 	   long rec, tot;
! 	   new_mail_in_open_stream(stream, &rec, &tot);
! 	   f->countrecent = rec > f->recent ? rec - f->countrecent : 0;
! 	   f->recent   = rec;
! 	   f->messages = tot;
! 	   f->selected = f->user_selected ? 1 : 0;
! 	}
! 	ps_global->refresh_list = 0;	/* reset refresh_list	    */
! 	force = skip = 0;		/* may not need to next time around */
  	/*
  	 * If the width of the message number field in the display changes
  	 * we need to flush the cache and redraw. When the cache is cleared
***************
*** 946,951 ****
--- 1024,1032 ----
  	      break;
  	  }
  
+ 	if ((cmd != MC_NONE) && (cmd != MC_FORCECHECK))
+            state->force_check_now = 0;
+ 
  	/*----------- Execute the command ------------------*/
  	switch(cmd){
  
***************
*** 961,966 ****
--- 1042,1048 ----
  
              /*---------- Scroll line up ----------*/
  	  case MC_CHARUP :
+ previtem:
  	    (void) process_cmd(state, stream, msgmap, MC_PREVITEM,
  			       (style == MsgIndex
  				|| style == MultiMsgIndex
***************
*** 978,983 ****
--- 1060,1066 ----
  
              /*---------- Scroll line down ----------*/
  	  case MC_CHARDOWN :
+ nextitem:
  	    /*
  	     * Special Page framing handling here.  If we
  	     * did something that should scroll-by-a-line, frame
***************
*** 1194,1199 ****
--- 1277,1283 ----
  
  
  	  case MC_THRDINDX :
+ mc_thrdindx:
  	    msgmap->top = msgmap->top_after_thrd;
  	    if(unview_thread(state, stream, msgmap)){
  		ps_global->redrawer = NULL;
***************
*** 1243,1249 ****
  			      && mp.col == id.plus_col
  			      && style != ThreadIndex){
  			      collapse_or_expand(state, stream, msgmap,
! 						 mn_get_cur(msgmap));
  			  }
  			  else if (mp.doubleclick){
  			      if(mp.button == M_BUTTON_LEFT){
--- 1327,1333 ----
  			      && mp.col == id.plus_col
  			      && style != ThreadIndex){
  			      collapse_or_expand(state, stream, msgmap,
! 						 mn_get_cur(msgmap), 1);
  			  }
  			  else if (mp.doubleclick){
  			      if(mp.button == M_BUTTON_LEFT){
***************
*** 1337,1345 ****
  
  
  	  case MC_COLLAPSE :
! 	    thread_command(state, stream, msgmap, ch, -FOOTER_ROWS(state));
  	    break;
  
            case MC_DELETE :
            case MC_UNDELETE :
            case MC_REPLY :
--- 1421,1526 ----
  
  
  	  case MC_COLLAPSE :
! 	      thread_command(state, stream, msgmap, ch, -FOOTER_ROWS(state), 1);
  	    break;
  
+ 	  case MC_CTHREAD  :
+            if (SEP_THRDINDX())
+               goto mc_thrdindx;
+ 	   else
+ 	     if (THREADING()){ 
+ 		if (any_messages(ps_global->msgmap, NULL, 
+ 							"to collapse a thread"))
+ 		   collapse_thread(state, stream,msgmap, 1);
+ 	     }
+ 	     else
+ 	        q_status_message(SM_ORDER, 0, 1,
+ 			 "Command available in threaded mode only");
+ 	  break;
+ 
+ 	  case MC_OTHREAD  :
+            if (SEP_THRDINDX())
+               goto view_a_thread;
+ 	   else
+ 	     if (THREADING()){ 
+ 		if (any_messages(ps_global->msgmap, NULL, "to expand a thread"))
+ 		   expand_thread(state, stream,msgmap, 1);
+ 	     }
+ 	     else
+ 	        q_status_message(SM_ORDER, 0, 1,
+ 			 "Command available in threaded mode only");
+            break;
+ 
+ 	  case MC_NEXTHREAD:
+           case MC_PRETHREAD:
+            if (THRD_INDX()){
+               if (cmd == MC_NEXTHREAD)
+ 		goto nextitem;
+ 	      else
+ 		goto previtem;
+ 	   }
+ 	   else
+ 	     if (THREADING()){ 
+ 		if (any_messages(ps_global->msgmap, NULL, 
+ 					"to move to other thread"))
+ 		  move_thread(state, stream, msgmap, 
+ 						cmd == MC_NEXTHREAD ? 1 : -1);
+ 	     }
+ 	     else
+ 	        q_status_message(SM_ORDER, 0, 1,
+ 			 "Command available in threaded mode only");
+           break;
+ 
+ 	  case MC_KOLAPSE:
+ 	  case MC_EXPTHREAD:
+               if (SEP_THRDINDX()){
+                       q_status_message(SM_ORDER, 0, 1,
+                               "Command not available in this screen");
+               }
+               else{
+ 		if (THREADING()){
+ 		   if (any_messages(ps_global->msgmap, NULL, 
+ 			     cmd == MC_KOLAPSE ? "to collapse" : "to expand"))
+ 		      kolapse_thread(state, stream, msgmap,
+                               (cmd == MC_KOLAPSE) ? '[' : ']', 1);
+ 	        }
+ 		else
+ 		    q_status_message(SM_ORDER, 0, 1,
+ 			 "Command available in threaded mode only");
+ 	      }
+           break;
+ 
+ 	  case MC_DELTHREAD:
+ 	     if (THREADING()){
+ 		if (any_messages(ps_global->msgmap, NULL, "to delete"))
+                     cmd_delete_thread(state, stream, msgmap);
+ 	     }
+ 	     else
+ 		q_status_message(SM_ORDER, 0, 1,
+ 			 "Command available in threaded mode only");
+           break;
+ 
+ 	  case MC_UNDTHREAD:
+ 	     if (THREADING()){
+ 		if (any_messages(ps_global->msgmap, NULL, "to undelete"))
+ 		    cmd_undelete_thread(state, stream, msgmap);
+ 	     }
+ 	     else
+ 		q_status_message(SM_ORDER, 0, 1,
+ 			 "Command available in threaded mode only");
+ 	  break;
+ 
+ 
+ 	  case MC_SELTHREAD:
+ 	     if (THREADING()){
+ 		if (any_messages(ps_global->msgmap, NULL, "to undelete"))
+ 		    cmd_select_thread(state, stream, msgmap);
+ 	     }
+ 	     else
+ 		q_status_message(SM_ORDER, 0, 1,
+ 			 "Command available in threaded mode only");
+ 	  break;
+ 
            case MC_DELETE :
            case MC_UNDELETE :
            case MC_REPLY :
***************
*** 1360,1372 ****
  		  if(rawno)
  		    thrd = fetch_thread(stream, rawno);
  
! 		  collapsed = thrd && thrd->next
! 			      && get_lflag(stream, NULL, rawno, MN_COLL);
  	      }
  
  	      if(collapsed){
  		  thread_command(state, stream, msgmap,
! 				 ch, -FOOTER_ROWS(state));
  		  /* increment current */
  		  if(cmd == MC_DELETE){
  		      advance_cur_after_delete(state, stream, msgmap,
--- 1541,1552 ----
  		  if(rawno)
  		    thrd = fetch_thread(stream, rawno);
  
! 		collapsed = thread_is_kolapsed(ps_global, stream, msgmap, rawno);
  	      }
  
  	      if(collapsed){
  		  thread_command(state, stream, msgmap,
! 				 ch, -FOOTER_ROWS(state),1);
  		  /* increment current */
  		  if(cmd == MC_DELETE){
  		      advance_cur_after_delete(state, stream, msgmap,
***************
*** 1405,1411 ****
  	    }
  	    /* else fall thru to normal default */
  
! 
              /*---------- Default -- all other command ----------*/
            default:
     do_the_default:
--- 1585,1594 ----
  	    }
  	    /* else fall thru to normal default */
  
!           case MC_TAB:
! 		skip++;
!         /* do not check for new mail in inc fldrs and fall through */ 
!             
              /*---------- Default -- all other command ----------*/
            default:
     do_the_default:
***************
*** 2661,2666 ****
--- 2844,2850 ----
  		      n = mn_raw2m(msgs, thrd->rawno);
  
  		    while(thrd){
+ 			unsigned long branch;
  			if(!msgline_hidden(stream, msgs, n, 0)
  			   && (++m % lines_per_page) == 1L)
  			  t = n;
***************
*** 2729,2739 ****
  
  	    /* n is the end of this thread */
  	    while(thrd){
  		n = mn_raw2m(msgs, thrd->rawno);
! 		if(thrd->branch)
! 		  thrd = fetch_thread(stream, thrd->branch);
! 		else if(thrd->next)
! 		  thrd = fetch_thread(stream, thrd->next);
  		else
  		  thrd = NULL;
  	    }
--- 2913,2924 ----
  
  	    /* n is the end of this thread */
  	    while(thrd){
+ 		unsigned long next = 0L, branch = 0L;
  		n = mn_raw2m(msgs, thrd->rawno);
! 		if(branch = get_branch(stream,thrd))
! 		  thrd = fetch_thread(stream, branch);
! 		else if(next = get_next(stream,thrd))
! 		  thrd = fetch_thread(stream, next);
  		else
  		  thrd = NULL;
  	    }
***************
*** 2886,2891 ****
--- 3071,3077 ----
  	      case iSTime:
  	      case iKSize:
  	      case iSize:
+ 	      case iSizeThread:
  		(*answer)[column].req_width = 7;
  		break;
  	      case iS1Date:
***************
*** 2927,2935 ****
      {"FROMORTONOTNEWS",	iFromToNotNews,	FOR_INDEX},
      {"SIZE",		iSize,		FOR_INDEX},
      {"SIZECOMMA",	iSizeComma,	FOR_INDEX},
      {"SIZENARROW",	iSizeNarrow,	FOR_INDEX},
      {"KSIZE",		iKSize,		FOR_INDEX},
!     {"SUBJECT",		iSubject,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"FULLSTATUS",	iFStatus,	FOR_INDEX},
      {"IMAPSTATUS",	iIStatus,	FOR_INDEX},
      {"SUBJKEY",		iSubjKey,	FOR_INDEX},
--- 3113,3122 ----
      {"FROMORTONOTNEWS",	iFromToNotNews,	FOR_INDEX},
      {"SIZE",		iSize,		FOR_INDEX},
      {"SIZECOMMA",	iSizeComma,	FOR_INDEX},
+     {"SIZETHREAD",	iSizeThread,	FOR_INDEX},
      {"SIZENARROW",	iSizeNarrow,	FOR_INDEX},
      {"KSIZE",		iKSize,		FOR_INDEX},
!     {"SUBJECT",		iSubject,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_TRIM},
      {"FULLSTATUS",	iFStatus,	FOR_INDEX},
      {"IMAPSTATUS",	iIStatus,	FOR_INDEX},
      {"SUBJKEY",		iSubjKey,	FOR_INDEX},
***************
*** 2952,2963 ****
      {"MONTHABBREV",	iMonAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"DAYOFWEEKABBREV",	iDayOfWeekAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"DAYOFWEEK",	iDayOfWeek,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"FROM",		iFrom,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TO",		iTo,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SENDER",		iSender,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"CC",		iCc,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"RECIPS",		iRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"NEWS",		iNews,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"TOANDNEWS",	iToAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"NEWSANDTO",	iNewsAndTo,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"RECIPSANDNEWS",	iRecipsAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
--- 3139,3153 ----
      {"MONTHABBREV",	iMonAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"DAYOFWEEKABBREV",	iDayOfWeekAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"DAYOFWEEK",	iDayOfWeek,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"FROM",		iFrom,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE|FOR_COMPOSE},
!     {"TO",		iTo,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE|FOR_COMPOSE},
!     {"SENDER",		iSender,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
!     {"CC",		iCc,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
!     {"ADDRESSTO",	iAddressTo,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
!     {"ADDRESSCC",	iAddressCc,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
!     {"ADDRESSRECIPS",	iAddressRecip,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
      {"RECIPS",		iRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"NEWS",		iNews,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE},
      {"TOANDNEWS",	iToAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"NEWSANDTO",	iNewsAndTo,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"RECIPSANDNEWS",	iRecipsAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
***************
*** 2972,2978 ****
      {"MONTH2DIGIT",	iMon2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"YEAR",		iYear,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"YEAR2DIGIT",	iYear2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"ADDRESS",		iAddress,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"MAILBOX",		iMailbox,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"ROLENICK",       	iRoleNick,	FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"INIT",		iInit,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
--- 3162,3168 ----
      {"MONTH2DIGIT",	iMon2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"YEAR",		iYear,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"YEAR2DIGIT",	iYear2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"ADDRESS",		iAddress,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE},
      {"MAILBOX",		iMailbox,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"ROLENICK",       	iRoleNick,	FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"INIT",		iInit,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
***************
*** 2982,2987 ****
--- 3172,3186 ----
      {"CURTIME24",	iCurTime24,	FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"CURTIME12",	iCurTime12,	FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"CURSORPOS",	iCursorPos,	FOR_TEMPLATE},
+     {"NICK",		iNick,		FOR_RULE|FOR_SAVE},
+     {"FOLDER",		iFolder,	FOR_RULE|FOR_SAVE|FOR_FOLDER},
+     {"ROLE",		iRole,		FOR_RULE| FOR_RESUB | FOR_TRIM | FOR_TEMPLATE},
+     {"FLAG",		iFlag,		FOR_RULE|FOR_SAVE|FOR_FLAG},
+     {"COLLECTION",	iCollection,	FOR_RULE|FOR_SAVE|FOR_COMPOSE|FOR_FOLDER},
+     {"BCC",		iBcc,		FOR_COMPOSE|FOR_RULE},
+     {"LCC",		iLcc,		FOR_COMPOSE|FOR_RULE},
+     {"FORWARDFROM",	iFfrom,		FOR_COMPOSE|FOR_RULE},
+     {"FORWARDADDRESS",  iFadd,		FOR_COMPOSE|FOR_RULE},
      {NULL,		iNothing,	FOR_NOTHING}
  };
  
***************
*** 3149,3155 ****
   */
  static IndexColType fixed_ctypes[] = {
      iMessNo, iStatus, iFStatus, iIStatus, iDate, iSDate, iSDateTime,
!     iSTime, iLDate,
      iS1Date, iS2Date, iS3Date, iS4Date, iDateIso, iDateIsoS,
      iSize, iSizeComma, iSizeNarrow, iKSize, iDescripSize,
      iAtt, iTime24, iTime12, iTimezone, iMonAbb, iYear, iYear2Digit,
--- 3348,3354 ----
   */
  static IndexColType fixed_ctypes[] = {
      iMessNo, iStatus, iFStatus, iIStatus, iDate, iSDate, iSDateTime,
!     iSTime, iLDate,     iSizeThread, 
      iS1Date, iS2Date, iS3Date, iS4Date, iDateIso, iDateIsoS,
      iSize, iSizeComma, iSizeNarrow, iKSize, iDescripSize,
      iAtt, iTime24, iTime12, iTimezone, iMonAbb, iYear, iYear2Digit,
***************
*** 3312,3317 ****
--- 3511,3517 ----
  		  case iTime12:
  		  case iSize:
  		  case iKSize:
+ 		  case iSizeThread:
  		    cdesc->actual_length = 7;
  		    cdesc->adjustment = Right;
  		    break;
***************
*** 3373,3379 ****
  	cdesc->ctype != iNothing;
  	cdesc++)
        if(cdesc->ctype == iSize || cdesc->ctype == iKSize ||
!          cdesc->ctype == iSizeNarrow ||
  	 cdesc->ctype == iSizeComma || cdesc->ctype == iDescripSize){
  	  if(cdesc->actual_length == 0){
  	      if((fix=cdesc->width) > 0){ /* had this reserved */
--- 3573,3579 ----
  	cdesc->ctype != iNothing;
  	cdesc++)
        if(cdesc->ctype == iSize || cdesc->ctype == iKSize ||
!          cdesc->ctype == iSizeNarrow || cdesc->ctype == iSizeThread ||
  	 cdesc->ctype == iSizeComma || cdesc->ctype == iDescripSize){
  	  if(cdesc->actual_length == 0){
  	      if((fix=cdesc->width) > 0){ /* had this reserved */
***************
*** 3634,3639 ****
--- 3834,3927 ----
      }
  }
  
+ ENVELOPE *make_envelope(idata, index)
+     INDEXDATA_S	*idata;
+     int		 index;
+ {
+   ENVELOPE *result;
+ 
+    result = mail_newenvelope();
+ 
+    result->from    = rfc822_cpy_adr(idata->from);
+    result->to      = rfc822_cpy_adr(idata->to);
+    result->cc      = rfc822_cpy_adr(idata->cc);
+    result->sender  = rfc822_cpy_adr(idata->sender);
+    result->subject = cpystr(idata->subject);
+    result->newsgroups = index ? cpystr(idata->newsgroups) : 
+ 			 IS_NEWS(idata->stream) ? cpystr(ps_global->cur_folder) 
+ 						: NULL;
+   return result;
+ }
+ 
+ /*---------------------------------
+ 
+ -----------*/
+ 
+ char *find_value(token,function1, context1, function2, context2, function3, context3, idata, rule)
+ char *token;
+ char *function1;
+ int context1;
+ char *function2;
+ int context2;
+ char *function3;
+ int context3;
+ INDEXDATA_S *idata;
+ char **rule;
+ {   int n = 0, we_cancel = FALSE, next_step = FALSE;
+     char  *rule_result;
+     int	   rule_context;
+     char  *rule_data;
+     char  *rule_data_backup;
+ 	 
+      if (rule && *rule){
+ 	rule_context = FOR_RULE;
+ 	while (!we_cancel && rule[n] && *rule[n]){
+ 	   rule_data = cpystr(rule[n++]);
+ 	   rule_data_backup = strstr(rule_data,"=>");
+ 	   if (rule_data_backup){
+ 	      if (rule_data_backup = strstr(rule_data_backup,token))
+ 		 rule_data_backup += strlen(token);
+ 	      if (rule_data_backup && strstr(rule_data_backup,":="))
+ 		 rule_data_backup += strlen(":=");
+ 	      if (context1){
+ 		if (rule_data_backup && strstr(rule_data_backup,function1)){
+ 		    rule_context |= context1;
+ 		    next_step = TRUE;
+ 	        }
+ 	      }
+ 	      if (context2){
+ 		if (rule_data_backup && strstr(rule_data_backup,function2)){
+ 		    rule_context |= context2;
+ 		    next_step = TRUE;
+ 	        }
+ 	      }
+ 	      if (context3){
+ 		if (rule_data_backup && strstr(rule_data_backup,function3)){
+ 		    rule_context |= context3;
+ 		    next_step = TRUE;
+ 	        }
+ 	      }
+ 	   }
+ 	   if (next_step){
+ 	      ENVELOPE *local_env = make_envelope(idata,1);
+ 	      next_step = FALSE;
+               rule_result = (char *)
+ 			    process_rule(rule_data, rule_context, local_env);
+ 	      if (local_env)
+ 		mail_free_envelope(&local_env);
+               if (rule_result)
+ 	         we_cancel = TRUE;
+            }
+            if (rule_data)
+ 	      fs_give((void **)&rule_data);
+         }
+      }
+      if (!we_cancel)
+ 	return NULL;
+      else
+ 	return rule_result;
+ }
+ 
  
  /*----------------------------------------------------------------------
        Create a string summarizing the message header for index on screen
***************
*** 3766,3775 ****
  
  		/* find next thread which is visible */
  		do{
  		    if(mn_get_revsort(msgmap) && thrd->prevthd)
  		      thrd = fetch_thread(stream, thrd->prevthd);
! 		    else if(!mn_get_revsort(msgmap) && thrd->nextthd)
! 		      thrd = fetch_thread(stream, thrd->nextthd);
  		    else
  		      thrd = NULL;
  		} while(thrd
--- 4054,4064 ----
  
  		/* find next thread which is visible */
  		do{
+ 		   unsigned long branch;
  		    if(mn_get_revsort(msgmap) && thrd->prevthd)
  		      thrd = fetch_thread(stream, thrd->prevthd);
! 		    else if(!mn_get_revsort(msgmap) && thrd->branch)
! 		      thrd = fetch_thread(stream, thrd->branch);
  		    else
  		      thrd = NULL;
  		} while(thrd
***************
*** 4218,4231 ****
  
      memset(str_buf, 0, sizeof(str_buf));
  
-     hline = get_index_cache(idata->msgno);
- 
      /* is this a collapsed thread index line? */
      if(!idata->bogus && THREADING()){
! 	thrd = fetch_thread(idata->stream, idata->rawno);
! 	collapsed = thrd && thrd->next
! 		    && get_lflag(idata->stream, NULL,
! 				 idata->rawno, MN_COLL);
      }
  
      /* calculate contents of the required fields */
--- 4507,4516 ----
  
      memset(str_buf, 0, sizeof(str_buf));
  
      /* is this a collapsed thread index line? */
+     thrd = fetch_thread(idata->stream, idata->rawno);
      if(!idata->bogus && THREADING()){
! 	collapsed = thrd && thread_is_kolapsed(ps_global, idata->stream, ps_global->msgmap, idata->rawno);
      }
  
      /* calculate contents of the required fields */
***************
*** 4583,4589 ****
--- 4868,4898 ----
  
  	        break;
  
+ 	     case iSizeThread:
+ 		if (!THREADING()){
+ 		  goto getsize;
+ 		} else if (collapsed){
+ 		     l =  count_flags_in_thread(idata->stream, thrd, F_NONE);
+ 		     sprintf(str, "(%lu)", l);
+ 		}
+ 		else{ 		
+ 		    thrd = fetch_thread(idata->stream, idata->rawno);
+ 		    if(!thrd)
+ 			   sprintf(str,"Error");
+ 		    else{
+ 			long lengthb;
+ 			lengthb = get_length_branch(idata->stream, idata->rawno);
+ 
+ 			if (lengthb > 0L)
+ 			   sprintf(str,"(%lu)", lengthb);
+ 			else
+ 			   sprintf(str," ");
+ 		     }
+ 		}
+ 	       break;
+ 
  	      case iSize:
+ getsize:
  		/* 0 ... 9999 */
  		if((l = fetch_size(idata)) < 10*1000L)
  		  sprintf(str, "(%lu)", l);
***************
*** 4931,4936 ****
--- 5240,5246 ----
  	    }
        }
  
+     hline = get_index_cache(idata->msgno);
      *(p = buffer = hline->line) = '\0';
  
      /*--- Put them all together ---*/
***************
*** 6546,6558 ****
      char          *p, *border, *q = NULL, *free_subj = NULL;
      unsigned char *tmp;
      size_t         len;
!     int            depth = 0, mult = 2, collapsed;
      PINETHRD_S    *thd, *thdorig;
      HLINE_S       *hline;
      unsigned long  rawno;
  
      memset(str, 0, (width+1) * sizeof(*str));
!     origsubj = fetch_subject(idata);
      if(!origsubj)
        origsubj = "";
  
--- 6856,6876 ----
      char          *p, *border, *q = NULL, *free_subj = NULL;
      unsigned char *tmp;
      size_t         len;
!     int            depth = 0, mult = 2, collapsed, we_clear = 0;
      PINETHRD_S    *thd, *thdorig;
      HLINE_S       *hline;
      unsigned long  rawno;
+     char	  *rule_result;
  
      memset(str, 0, (width+1) * sizeof(*str));
!     rule_result = find_value("_SUBJECT_","_REPLACE_",FOR_REPLACE,"_TRIM_",FOR_TRIM, "_REXTRIM_", FOR_TRIM, idata,ps_global->vars[V_REPLACE_RULES].current_val.l);
!     if (rule_result){
! 	we_clear++;
!        origsubj = cpystr(rule_result);
!        fs_give((void **)&rule_result);
!     }
!     else
!       origsubj = fetch_subject(idata);
      if(!origsubj)
        origsubj = "";
  
***************
*** 6575,6582 ****
  	thdorig = thd = fetch_thread(idata->stream, idata->rawno);
  	border = str + width;
  	if(current_index_state->plus_col >= 0 && !THRD_INDX()){
! 	    collapsed = thd && thd->next &&
! 		    get_lflag(idata->stream, NULL, idata->rawno, MN_COLL);
  	    hline = get_index_cache(idata->msgno);
  	    hline->plus = collapsed ? ps_global->VAR_THREAD_MORE_CHAR[0]
  		    : (thd && thd->next)
--- 6893,6900 ----
  	thdorig = thd = fetch_thread(idata->stream, idata->rawno);
  	border = str + width;
  	if(current_index_state->plus_col >= 0 && !THRD_INDX()){
! 	    collapsed = this_thread_is_kolapsed(ps_global, idata->stream, ps_global->msgmap, idata->rawno);
! 	    collapsed = collapsed && (count_thread(ps_global,idata->stream, ps_global->msgmap, idata->rawno) != 1);
  	    hline = get_index_cache(idata->msgno);
  	    hline->plus = collapsed ? ps_global->VAR_THREAD_MORE_CHAR[0]
  		    : (thd && thd->next)
***************
*** 6773,6778 ****
--- 7091,7098 ----
  
      if(free_subj)
        fs_give((void **) &free_subj);
+     if (we_clear && origsubj)
+       fs_give((void **)&origsubj);
  }
  
  
***************
*** 6898,6905 ****
  	thdorig = thd = fetch_thread(idata->stream, idata->rawno);
  	border = str + width;
  	if(current_index_state->plus_col >= 0 && !THRD_INDX()){
! 	    collapsed = thd && thd->next &&
! 			get_lflag(idata->stream, NULL, idata->rawno, MN_COLL);
  	    hline = get_index_cache(idata->msgno);
  	    hline->plus = collapsed ? ps_global->VAR_THREAD_MORE_CHAR[0]
  			: (thd && thd->next)
--- 7218,7225 ----
  	thdorig = thd = fetch_thread(idata->stream, idata->rawno);
  	border = str + width;
  	if(current_index_state->plus_col >= 0 && !THRD_INDX()){
! 	    collapsed = this_thread_is_kolapsed(ps_global, idata->stream, ps_global->msgmap, idata->rawno);
!             collapsed = collapsed && (count_thread (ps_global,idata->stream, ps_global->msgmap, idata->rawno) != 1);
  	    hline = get_index_cache(idata->msgno);
  	    hline->plus = collapsed ? ps_global->VAR_THREAD_MORE_CHAR[0]
  			: (thd && thd->next)
***************
*** 6990,7005 ****
  				 ? "To"
  				 : (addr = fetch_cc(idata))
  				 ? "Cc"
! 				 : NULL))
! 		       && set_index_addr(idata, field, addr, "To: ",
! 					 width, fptr))
! 		      break;
! 
  		    if(ctype == iFromTo &&
  		       (newsgroups = fetch_newsgroups(idata)) &&
  		       *newsgroups){
! 			sprintf(fptr, "To: %-*.*s", width-4, width-4,
! 				newsgroups);
  			break;
  		    }
  
--- 7310,7339 ----
  				 ? "To"
  				 : (addr = fetch_cc(idata))
  				 ? "Cc"
! 				 : NULL))){
!                          char *rule_result;
! 			 rule_result = find_value("_FROM_","_REPLACE_",FOR_REPLACE, NULL,0,NULL,0, idata,ps_global->vars[V_REPLACE_RULES].current_val.l);
!                          if (!rule_result)
!                             set_index_addr(idata, field, addr, "To: ",
!                                       width, str);
!                          else{
!                             sprintf(str, "%-*.*s", width, width, rule_result);
!                             fs_give((void **)&rule_result);
!                          }
!                          break;
! 		    }
  		    if(ctype == iFromTo &&
  		       (newsgroups = fetch_newsgroups(idata)) &&
  		       *newsgroups){
!                            char *rule_result;
! 			   rule_result = find_value("_FROM_","_REPLACE_",FOR_REPLACE, NULL,0,NULL, 0, idata,ps_global->vars[V_REPLACE_RULES].current_val.l);
!                            if (!rule_result)
!                               sprintf(str, "To: %-*.*s", width-4, width-4,
!                                   newsgroups);
!                            else{
!                                sprintf(str, "%-*.*s", width, width, rule_result);
!                               fs_give((void **)&rule_result);
!                            }
  			break;
  		    }
  
***************
*** 7012,7019 ****
  	      break;
  
  	  case iFrom:
! 	    set_index_addr(idata, "From", fetch_from(idata),
! 			   NULL, width, fptr);
  	    break;
  
  	  case iAddress:
--- 7346,7362 ----
  	      break;
  
  	  case iFrom:
!               { char *rule_result;
! 		rule_result = find_value("_FROM_","_REPLACE_",FOR_REPLACE, "_TRIM_",FOR_TRIM, "_REXTRIM_",FOR_TRIM,idata,ps_global->vars[V_REPLACE_RULES].current_val.l);
!                 if (!rule_result)
!                    set_index_addr(idata, "From", fetch_from(idata),
!                              NULL, width, str);
!                 else{  
!                   sprintf(str, "%-*.*s", width, width, rule_result);
!                   fs_give((void **)&rule_result);
!                 }   
!               }
! 
  	    break;
  
  	  case iAddress:
***************
*** 7096,7101 ****
--- 7439,7462 ----
      return(1);
  }
  
+ void
+ insert_pattern_in_string(buf, last, maxbuf)
+   char *buf;
+   char *last;
+   int maxbuf;
+ {
+    if (last[0] != '\0'){
+ 	int lenlast, lenbuf;
+ 	lenlast = strlen(last);
+ 	lenbuf = buf[0] == '\0' ? 0 : strlen(buf);
+ 	if (lenlast + lenbuf <= maxbuf){
+ 	   if (buf[0] == '\0')
+ 	      strcpy(buf, last);
+ 	   else
+ 	      strcat(buf, last);
+ 	}
+    }
+ }
  
  
  /*----------------------------------------------------------------------
***************
*** 7120,7128 ****
--- 7481,7491 ----
      long        i, sorted_msg, selected = 0L;
      char        prompt[MAX_SEARCH+50], new_string[MAX_SEARCH+1];
      HelpType	help;
+     static char last_search_pat[MAX_SEARCH+1] = {'\0'};
      static char search_string[MAX_SEARCH+1] = { '\0' };
      HLINE_S    *hl;
      static ESCKEY_S header_search_key[] = { {0, 0, NULL, NULL },
+ 					    {ctrl('N'),  9,  "^N","Ins Pat"},
  					    {ctrl('Y'), 10, "^Y", "First Msg"},
  					    {ctrl('V'), 11, "^V", "Last Msg"},
  					    {-1, 0, NULL, NULL} };
***************
*** 7169,7174 ****
--- 7532,7539 ----
  		       : h_os_index_whereis;
              continue;
          }
+ 	else if(rc == 9)
+ 	   insert_pattern_in_string(new_string, last_search_pat, MAX_SEARCH);
  	else if(rc == 10){
  	    q_status_message(SM_ORDER, 0, 3, "Searched to First Message.");
  	    if(any_lflagged(msgmap, MN_HIDE | MN_CHID)){
***************
*** 7206,7212 ****
  	    break;
  	}
  
!         if(rc != 4)			/* redraw */
            break; /* redraw */
      }
  
--- 7571,7577 ----
  	    break;
  	}
  
!         if(rc != 4 && rc != 9)			/* redraw */
            break; /* redraw */
      }
  
***************
*** 7223,7228 ****
--- 7588,7596 ----
      strncpy(search_string, new_string, sizeof(search_string));
      search_string[sizeof(search_string)-1] = '\0';
  
+     strncpy(last_search_pat, new_string, sizeof(last_search_pat));
+     last_search_pat[sizeof(last_search_pat)-1] = '\0';
+ 
  #ifndef	DOS
      intr_handling_on();
  #endif
***************
*** 7409,7414 ****
--- 7777,7819 ----
  	    : ((mdiff = *mess_a - *mess_b) ? ((mdiff > 0) ? 1 : -1) : 0));
  }
  
+ SortOrder  translate(order, is_rev)
+ char *order;
+ int   is_rev;
+ {
+    int rev = 0;
+      if (!strncmp(order,"tHread", 6) 
+ 		|| (rev = !strncmp(order,"Reverse tHread", 14)))
+ 	return is_rev || rev ? SortThread : EndofList;
+      if (!strncmp(order,"OrderedSubj", 11)
+ 		|| (rev = !strncmp(order,"Reverse OrderedSubj", 19)))
+ 	return is_rev || rev  ? SortSubject2 : EndofList;
+      if (!strncmp(order,"Subject", 7)
+ 		|| (rev = !strncmp(order,"Reverse SortSubject", 15)))
+ 	return is_rev || rev  ?  SortSubject : EndofList;
+      if (!strncmp(order,"Arrival", 7)
+ 		|| (rev = !strncmp(order,"Reverse Arrival", 15)))
+ 	return is_rev || rev  ?  SortArrival : EndofList;
+      if (!strncmp(order,"From", 4)
+ 		|| (rev = !strncmp(order,"Reverse From", 12)))
+ 	return is_rev || rev  ?  SortFrom : EndofList;
+      if (!strncmp(order,"To", 2)
+ 		|| (rev = !strncmp(order,"Reverse To", 10)))
+ 	return is_rev || rev  ?  SortTo : EndofList;
+      if (!strncmp(order,"Cc", 2)
+ 		|| (rev = !strncmp(order,"Reverse Cc", 10)))
+ 	return is_rev || rev  ?  SortCc : EndofList;
+      if (!strncmp(order,"Date", 4)
+ 		|| (rev = !strncmp(order,"Reverse Date", 12)))
+ 	return is_rev || rev  ?  SortDate : EndofList;
+      if (!strncmp(order,"siZe", 4)
+ 		|| (rev = !strncmp(order,"Reverse siZe", 12)))
+ 	return is_rev || rev  ?  SortSize : EndofList;
+      if (!strncmp(order,"scorE", 5)
+ 		|| (rev = !strncmp(order,"Reverse scorE", 13)))
+ 	return is_rev || rev  ?  SortScore : EndofList;
+    return EndofList;
+ }
  
  /*----------------------------------------------------------------------
      Sort the current folder into the order set in the msgmap
***************
*** 7424,7435 ****
      causes the sort to happen if it is still needed.
    ----*/
  void
! sort_folder(stream, msgmap, new_sort, new_rev, flags)
      MAILSTREAM *stream;
      MSGNO_S    *msgmap;
      SortOrder   new_sort;
      int	        new_rev;
      unsigned    flags;
  {
      long	   raw_current, i, j;
      unsigned long *sort = NULL;
--- 7829,7841 ----
      causes the sort to happen if it is still needed.
    ----*/
  void
! sort_folder(stream, msgmap, new_sort, new_rev, flags, first)
      MAILSTREAM *stream;
      MSGNO_S    *msgmap;
      SortOrder   new_sort;
      int	        new_rev;
      unsigned    flags;
+     int		first;
  {
      long	   raw_current, i, j;
      unsigned long *sort = NULL;
***************
*** 7439,7444 ****
--- 7845,7859 ----
      int	           current_rev;
      MESSAGECACHE  *mc;
  
+     if (first){
+        if (new_sort == SortThread)
+ 	  find_msgmap(stream, msgmap, flags, 
+ 		   ps_global->thread_cur_sort, new_rev);
+        else
+ 	  sort_folder(stream, msgmap, new_sort, new_rev, flags, 0);
+        return;
+     }
+ 
      dprint(2, (debugfile, "Sorting by %s%s\n",
  	       sort_name(new_sort), new_rev ? "/reverse" : ""));
  
***************
*** 7801,7806 ****
--- 8216,8222 ----
  
  		thrd = fetch_head_thread(stream);
  		for(j = msgmap->max_thrdno; thrd && j >= 1L; j--){
+ 		    unsigned long branch;
  		    thrd->thrdno = j;
  
  		    if(thrd->nextthd)
***************
*** 7867,7873 ****
      MESSAGECACHE *mc;
      PINELT_S     *peltp;
  
!     if(!(stream && stream->spare))
        return;
      
      ps_global->view_skipped_index = 0;
--- 8283,8289 ----
      MESSAGECACHE *mc;
      PINELT_S     *peltp;
  
!     if(!(stream && stream->spare) || !erase_thread_info)
        return;
      
      ps_global->view_skipped_index = 0;
***************
*** 7929,7935 ****
      unsigned long msgno, rawno, set_in_thread, in_thread;
      int           bail, this_is_vis;
      int           un_view_thread = 0;
!     long          raw_current;
  
  
      dprint(2, (debugfile, "sort_thread_callback\n"));
--- 8345,8351 ----
      unsigned long msgno, rawno, set_in_thread, in_thread;
      int           bail, this_is_vis;
      int           un_view_thread = 0;
!     long          raw_current, branch;
  
  
      dprint(2, (debugfile, "sort_thread_callback\n"));
***************
*** 7948,7956 ****
       * way. If the dummy node is at the top-level, then its children are
       * promoted to the top-level as separate threads.
       */
!     collapsed_tree = collapse_threadnode_tree(tree);
!     (void) sort_thread_flatten(collapsed_tree, stream, thrd_flatten_array,
! 			       NULL, THD_TOP);
      mail_free_threadnode(&collapsed_tree);
  
      if(any_lflagged(g_sort.msgmap, MN_HIDE))
--- 8364,8374 ----
       * way. If the dummy node is at the top-level, then its children are
       * promoted to the top-level as separate threads.
       */
!     collapsed_tree = F_ON(F_ENHANCED_THREAD, ps_global) ? 
! 			copy_tree(tree) : collapse_threadnode_tree(tree);
!     (void) sort_thread_flatten(collapsed_tree,
! 				stream, thrd_flatten_array,
! 			       NULL, THD_TOP, 0, 1L, 0L);
      mail_free_threadnode(&collapsed_tree);
  
      if(any_lflagged(g_sort.msgmap, MN_HIDE))
***************
*** 8115,8126 ****
  	else{
  	    thrd = fetch_head_thread(stream);
  	    while(thrd){
  		/*
  		 * The top-level threads aren't hidden by collapse.
  		 */
  		msgno = mn_raw2m(g_sort.msgmap, thrd->rawno);
! 		if(msgno)
! 		  set_lflag(stream, g_sort.msgmap, msgno, MN_CHID, 0);
  
  		if(thrd->next){
  		    PINETHRD_S *nthrd;
--- 8533,8546 ----
  	else{
  	    thrd = fetch_head_thread(stream);
  	    while(thrd){
+ 		unsigned long raw = thrd->rawno;
+ 		unsigned long top = top_thread(stream, raw);
  		/*
  		 * The top-level threads aren't hidden by collapse.
  		 */
  		msgno = mn_raw2m(g_sort.msgmap, thrd->rawno);
! 		if(msgno && !get_lflag(stream, NULL,thrd->rawno, MN_COLL))
! 		   set_lflag(stream, g_sort.msgmap, msgno, MN_CHID, 0);
  
  		if(thrd->next){
  		    PINETHRD_S *nthrd;
***************
*** 8134,8142 ****
  							  MN_COLL));
  		}
  
! 		if(thrd->nextthd)
  		  thrd = fetch_thread(stream, thrd->nextthd);
! 		else
  		  thrd = NULL;
  	    }
  	}
--- 8554,8563 ----
  							  MN_COLL));
  		}
  
! 		while (thrd && top_thread(stream, thrd->rawno) == top 
! 				&& thrd->nextthd)
  		  thrd = fetch_thread(stream, thrd->nextthd);
! 		if (!(thrd && thrd->nextthd))
  		  thrd = NULL;
  	    }
  	}
***************
*** 8157,8166 ****
      PINETHRD_S *not_this_thread;
  {
      PINETHRD_S   *thrd = NULL, *nthrd;
!     unsigned long msgno;
  
      dprint(9, (debugfile, "collapse_threads\n"));
  
      thrd = fetch_head_thread(stream);
      while(thrd){
  	if(thrd != not_this_thread){
--- 8578,8594 ----
      PINETHRD_S *not_this_thread;
  {
      PINETHRD_S   *thrd = NULL, *nthrd;
!     unsigned long msgno, branch;
  
      dprint(9, (debugfile, "collapse_threads\n"));
  
+ /*    if(F_ON(F_ENHANCED_THREAD, ps_global)){*/
+       kolapse_thread(ps_global, stream, msgmap, '[', 0);
+       if (not_this_thread)
+          expand_thread(ps_global, stream, msgmap, 0);
+       return;
+ /*    }*/
+ 
      thrd = fetch_head_thread(stream);
      while(thrd){
  	if(thrd != not_this_thread){
***************
*** 8195,8201 ****
      int         a_parent_is_collapsed;
  {
      PINETHRD_S *nthrd, *bthrd;
!     unsigned long msgno;
  
      if(!thrd)
        return;
--- 8623,8629 ----
      int         a_parent_is_collapsed;
  {
      PINETHRD_S *nthrd, *bthrd;
!     unsigned long msgno, next, branch;
  
      if(!thrd)
        return;
***************
*** 8213,8220 ****
  	  set_lflag(stream, msgmap, msgno, MN_CHID, 0);
      }
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  make_thrdflags_consistent(stream, msgmap, nthrd,
  				    a_parent_is_collapsed
--- 8641,8648 ----
  	  set_lflag(stream, msgmap, msgno, MN_CHID, 0);
      }
  
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  make_thrdflags_consistent(stream, msgmap, nthrd,
  				    a_parent_is_collapsed
***************
*** 8223,8230 ****
  						  MN_COLL));
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  make_thrdflags_consistent(stream, msgmap, bthrd,
  				    a_parent_is_collapsed);
--- 8651,8658 ----
  						  MN_COLL));
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  make_thrdflags_consistent(stream, msgmap, bthrd,
  				    a_parent_is_collapsed);
***************
*** 8237,8243 ****
      MAILSTREAM *stream;
  {
      PINETHRD_S   *thrd = NULL;
!     long          vis = 0L;
  
      thrd = fetch_head_thread(stream);
      while(thrd){
--- 8665,8671 ----
      MAILSTREAM *stream;
  {
      PINETHRD_S   *thrd = NULL;
!     long          vis = 0L, branch;
  
      thrd = fetch_head_thread(stream);
      while(thrd){
***************
*** 8254,8300 ****
  
  
  struct pass_along *
! sort_thread_flatten(node, stream, entry, thrd, flags)
      THREADNODE *node;
      MAILSTREAM *stream;
      struct pass_along *entry;
      PINETHRD_S *thrd;
      unsigned    flags;
  {
      long n = 0L;
!     PINETHRD_S *newthrd = NULL;
  
      if(node){
! 	if(node->num){		/* holes happen */
  	    n = (long) (entry - thrd_flatten_array);
  
  	    for(; n > 0; n--)
  	      if(thrd_flatten_array[n].rawno == node->num)
  		break;	/* duplicate */
  
! 	    if(!n)
! 	      entry->rawno = node->num;
! 	}
! 
! 	/*
! 	 * Build a richer threading structure that will help us paint
! 	 * and operate on threads and subthreads.
! 	 */
! 	if(!n && node->num){
! 	    newthrd = msgno_thread_info(stream, node->num, thrd, flags);
! 	    if(newthrd){
! 		entry->thrd = newthrd;
! 		entry++;
! 
! 		if(node->next)
  		  entry = sort_thread_flatten(node->next, stream, entry,
! 					      newthrd, THD_NEXT);
! 
  		if(node->branch)
  		  entry = sort_thread_flatten(node->branch, stream, entry,
! 					      newthrd,
! 					      (flags == THD_TOP) ? THD_TOP
! 								 : THD_BRANCH);
  	    }
  	}
      }
--- 8682,8767 ----
  
  
  struct pass_along *
! sort_thread_flatten(node, stream, entry, thrd, flags, adopted, top, threadno)
      THREADNODE *node;
      MAILSTREAM *stream;
      struct pass_along *entry;
      PINETHRD_S *thrd;
      unsigned    flags;
+     int		adopted;
+     long	top;
+     long	threadno;
  {
      long n = 0L;
!     PINETHRD_S *newthrd = NULL, *save_thread = NULL;
  
      if(node){
! 	if(node->num){
  	    n = (long) (entry - thrd_flatten_array);
  
+ 	    if (adopted == 2)
+ 		top 	 = node->num;
+ 
  	    for(; n > 0; n--)
  	      if(thrd_flatten_array[n].rawno == node->num)
  		break;	/* duplicate */
  
! 	    if(!n){
! 	        entry->rawno = node->num;
! 		newthrd = msgno_thread_info(stream, node->num, thrd, flags);
! 	    	if(newthrd){
! 		  if (adopted == 2)
! 		      threadno = newthrd->thrdno;
! 		  if (adopted){
! 		      newthrd->toploose = top;
! 		      newthrd->thrdno	= threadno;
! 		  }
! 		  entry->thrd = newthrd;
! 		  entry++;
! 	        }
! 	        adopted = adopted ? 1 : 0;
! 		if (node->next)
  		  entry = sort_thread_flatten(node->next, stream, entry,
! 					  newthrd, THD_NEXT, adopted, top, 
! 					  threadno);
  		if(node->branch)
  		  entry = sort_thread_flatten(node->branch, stream, entry,
! 				newthrd,
! 				(flags == THD_TOP) ? THD_TOP: THD_BRANCH,
! 				adopted, top, threadno);
! 	    }
! 	}
! 	else{
! 	    adopted = 2;
! 	    if(node->next)
! 	       entry =  sort_thread_flatten(node->next, stream, entry,
! 					  thrd, THD_TOP, adopted, top, threadno);
! 	    adopted = 0;
! 	    if(node->branch){
! 		if(entry){
! 		    struct pass_along *last_entry = entry;
! 		    int i = 0;
! 
! 		    /*
! 		     * Next moved up to replace "tree" in the tree.
! 		     * If next has no branches, then we want to branch off
! 		     * of next. If next has branches, we want to branch off
! 		     * of the last of those branches instead.
! 		     */
! 		    last_entry--;
! 		    while(last_entry->thrd->parent)
! 		      last_entry--;
! 		    save_thread = last_entry->thrd;
! 		    last_entry += i+1;
! 		    
! 		  last_entry = sort_thread_flatten(node->branch, stream, entry,
! 				save_thread,
! 				(flags == THD_TOP) ? THD_TOP: THD_BRANCH,
! 				adopted, top, threadno);
! 		}
! 		else
! 		  entry = sort_thread_flatten(node->branch, stream, entry,
! 				NULL, THD_TOP, adopted, top, threadno);
  	    }
  	}
      }
***************
*** 8302,8307 ****
--- 8769,8794 ----
      return(entry);
  }
  
+ /*
+  * Make a copy of c-client's THREAD tree
+  */
+ THREADNODE *
+ copy_tree(tree)
+     THREADNODE *tree;
+ {
+     THREADNODE *newtree = NULL;
+ 
+     if(tree){
+ 	newtree = mail_newthreadnode(NULL);
+ 	newtree->num  = tree->num;
+ 	if(tree->next)
+ 	   newtree->next = copy_tree(tree->next);
+ 
+ 	if(tree->branch)
+ 	   newtree->branch = copy_tree(tree->branch);
+     }
+     return(newtree);
+ }
  
  /*
   * Make a copy of c-client's THREAD tree while eliminating dummy nodes.
***************
*** 10037,10048 ****
  
  
  void
! thread_command(state, stream, msgmap, preloadkeystroke, q_line)
      struct pine *state;
      MAILSTREAM	*stream;
      MSGNO_S     *msgmap;
      int	         preloadkeystroke;
      int	         q_line;
  {
      PINETHRD_S   *thrd = NULL;
      unsigned long rawno, save_branch;
--- 10524,10536 ----
  
  
  void
! thread_command(state, stream, msgmap, preloadkeystroke, q_line, display)
      struct pine *state;
      MAILSTREAM	*stream;
      MSGNO_S     *msgmap;
      int	         preloadkeystroke;
      int	         q_line;
+     int		 display;
  {
      PINETHRD_S   *thrd = NULL;
      unsigned long rawno, save_branch;
***************
*** 10091,10097 ****
        cancel_busy_alarm(0);
  
      (void ) apply_command(state, stream, msgmap, preloadkeystroke, flags,
! 			  q_line);
  
      /* restore the original flags */
      copy_lflags(stream, msgmap, MN_STMP, MN_SLCT);
--- 10579,10585 ----
        cancel_busy_alarm(0);
  
      (void ) apply_command(state, stream, msgmap, preloadkeystroke, flags,
! 			  q_line, display);
  
      /* restore the original flags */
      copy_lflags(stream, msgmap, MN_STMP, MN_SLCT);
***************
*** 10129,10148 ****
      int          v;
  {
      PINETHRD_S *nthrd, *bthrd;
  
      if(!(stream && thrd && msgmap))
        return;
  
      set_lflag(stream, msgmap, mn_raw2m(msgmap, thrd->rawno), f, v);
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_flags_for_thread(stream, msgmap, f, nthrd, v);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  set_flags_for_thread(stream, msgmap, f, bthrd, v);
      }
--- 10617,10637 ----
      int          v;
  {
      PINETHRD_S *nthrd, *bthrd;
+     unsigned long next = 0L, branch = 0L;
  
      if(!(stream && thrd && msgmap))
        return;
  
      set_lflag(stream, msgmap, mn_raw2m(msgmap, thrd->rawno), f, v);
  
!     if(next = get_next(stream,thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  set_flags_for_thread(stream, msgmap, f, nthrd, v);
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  set_flags_for_thread(stream, msgmap, f, bthrd, v);
      }
***************
*** 10197,10207 ****
   * index.
   */
  void
! collapse_or_expand(state, stream, msgmap, msgno)
      struct pine *state;
      MAILSTREAM  *stream;
      MSGNO_S     *msgmap;
      unsigned long msgno;
  {
      int           collapsed, adjust_current = 0;
      PINETHRD_S   *thrd = NULL, *nthrd;
--- 10686,10697 ----
   * index.
   */
  void
! collapse_or_expand(state, stream, msgmap, msgno, display)
      struct pine *state;
      MAILSTREAM  *stream;
      MSGNO_S     *msgmap;
      unsigned long msgno;
+     int		display;
  {
      int           collapsed, adjust_current = 0;
      PINETHRD_S   *thrd = NULL, *nthrd;
***************
*** 10230,10235 ****
--- 10720,10743 ----
  	if(thrd && thrd->top != thrd->rawno){
  	    adjust_current++;
  	    thrd = fetch_thread(stream, thrd->top);
+ 	    
+ 	    /*
+ 	     * Special case. If the user is collapsing the entire thread
+ 	     * (msgno == 0), and we are in a Zoomed view, and the top of
+ 	     * the entire thread is not part of the Zoomed view, then watch
+ 	     * out. If we were to collapse the entire thread it would just
+ 	     * disappear, because the top is not in the Zoom. Therefore,
+ 	     * don't allow it. Do what the user probably wants, which is to
+ 	     * collapse the thread at that point instead of the entire thread,
+ 	     * leaving behind the top of the subthread to expand if needed.
+ 	     * In other words, treat it as if they didn't have the
+ 	     * F_SLASH_COLL_ENTIRE feature set.
+ 	     */
+ 	    collapsed = get_lflag(stream, NULL, thrd->rawno, MN_COLL)
+ 			&& thrd->next;
+ 
+ 	    if(!collapsed && get_lflag(stream, NULL, thrd->rawno, MN_HIDE))
+ 	      thrd = fetch_thread(stream, rawno);
  	}
      }
  
***************
*** 10237,10243 ****
      if(!thrd)
        return;
  
!     collapsed = get_lflag(stream, NULL, thrd->rawno, MN_COLL) && thrd->next;
  
      if(collapsed){
  	msgno = mn_raw2m(msgmap, thrd->rawno);
--- 10745,10751 ----
      if(!thrd)
        return;
  
!     collapsed = this_thread_is_kolapsed(ps_global, stream, msgmap, thrd->rawno);
  
      if(collapsed){
  	msgno = mn_raw2m(msgmap, thrd->rawno);
***************
*** 10255,10267 ****
  	msgno = mn_raw2m(msgmap, thrd->rawno);
  	if(msgno > 0L && msgno <= mn_get_total(msgmap)){
  	    set_lflag(stream, msgmap, msgno, MN_COLL, 1);
! 	    if(nthrd = fetch_thread(stream, thrd->next))
  	      set_thread_subtree(stream, nthrd, msgmap, 1, MN_CHID);
  
  	    clear_index_cache_ent(msgno);
  	}
      }
!     else
        q_status_message(SM_ORDER, 0, 1,
  		       "No thread to collapse or expand on this line");
      
--- 10763,10775 ----
  	msgno = mn_raw2m(msgmap, thrd->rawno);
  	if(msgno > 0L && msgno <= mn_get_total(msgmap)){
  	    set_lflag(stream, msgmap, msgno, MN_COLL, 1);
! 	    if((thrd->next) && (nthrd = fetch_thread(stream, thrd->next)))
  	      set_thread_subtree(stream, nthrd, msgmap, 1, MN_CHID);
  
  	    clear_index_cache_ent(msgno);
  	}
      }
!     else if (display)
        q_status_message(SM_ORDER, 0, 1,
  		       "No thread to collapse or expand on this line");
      
***************
*** 10343,10360 ****
      unsigned long rawno, count = 0;
      PINETHRD_S *nthrd, *bthrd;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
      
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  count += count_flags_in_thread(stream, nthrd, flags);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  count += count_flags_in_thread(stream, bthrd, flags);
      }
--- 10851,10869 ----
      unsigned long rawno, count = 0;
      PINETHRD_S *nthrd, *bthrd;
      MESSAGECACHE *mc;
+     unsigned long next = 0L, branch = 0L;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
      
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  count += count_flags_in_thread(stream, nthrd, flags);
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  count += count_flags_in_thread(stream, bthrd, flags);
      }
***************
*** 10385,10404 ****
      MSGNO_S    *msgmap;
      int         flags;		/* flag to count */
  {
!     unsigned long rawno, count = 0;
      PINETHRD_S *nthrd, *bthrd;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  count += count_lflags_in_thread(stream, nthrd, msgmap, flags);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  count += count_lflags_in_thread(stream, bthrd, msgmap,flags);
      }
--- 10894,10913 ----
      MSGNO_S    *msgmap;
      int         flags;		/* flag to count */
  {
!     unsigned long rawno, count = 0, next, branch;
      PINETHRD_S *nthrd, *bthrd;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
  
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  count += count_lflags_in_thread(stream, nthrd, msgmap, flags);
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  count += count_lflags_in_thread(stream, bthrd, msgmap,flags);
      }
***************
*** 10420,10426 ****
      MAILSTREAM *stream;
      PINETHRD_S *thrd;
  {
!     unsigned long rawno, count = 0;
      PINETHRD_S *nthrd, *bthrd;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
--- 10929,10935 ----
      MAILSTREAM *stream;
      PINETHRD_S *thrd;
  {
!     unsigned long rawno, count = 0, next, branch;
      PINETHRD_S *nthrd, *bthrd;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
***************
*** 10429,10442 ****
      if(get_lflag(stream, NULL, thrd->rawno, MN_HIDE) == 0)
        return 1;
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd && thread_has_some_visible(stream, nthrd))
  	  return 1;
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd && thread_has_some_visible(stream, bthrd))
  	  return 1;
      }
--- 10938,10951 ----
      if(get_lflag(stream, NULL, thrd->rawno, MN_HIDE) == 0)
        return 1;
  
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd && thread_has_some_visible(stream, nthrd))
  	  return 1;
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd && thread_has_some_visible(stream, bthrd))
  	  return 1;
      }
***************
*** 10511,10530 ****
      MSGNO_S    *msgmap;
  {
      int           count = 0;
      PINETHRD_S   *nthrd, *bthrd;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  count += mark_msgs_in_thread(stream, nthrd, msgmap);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  count += mark_msgs_in_thread(stream, bthrd, msgmap);
      }
--- 11020,11040 ----
      MSGNO_S    *msgmap;
  {
      int           count = 0;
+     long          next, branch;
      PINETHRD_S   *nthrd, *bthrd;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
  
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  count += mark_msgs_in_thread(stream, nthrd, msgmap);
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  count += mark_msgs_in_thread(stream, bthrd, msgmap);
      }
***************
*** 10557,10563 ****
      int         flags;		/* flags to set or clear */
      int         v;		/* set or clear? */
  {
!     unsigned long rawno, msgno;
      PINETHRD_S *nthrd, *bthrd;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
--- 11067,11073 ----
      int         flags;		/* flags to set or clear */
      int         v;		/* set or clear? */
  {
!     unsigned long rawno, msgno, next, branch;
      PINETHRD_S *nthrd, *bthrd;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
***************
*** 10583,10596 ****
         && v == 1 && get_index_cache(msgno)->line[0])
        clear_index_cache_ent(msgno);
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_thread_lflags(stream, nthrd, msgmap, flags, v);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  set_thread_lflags(stream, bthrd, msgmap, flags, v);
      }
--- 11093,11106 ----
         && v == 1 && get_index_cache(msgno)->line[0])
        clear_index_cache_ent(msgno);
  
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  set_thread_lflags(stream, nthrd, msgmap, flags, v);
      }
  
!     if(branch = get_branch(stream,thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  set_thread_lflags(stream, bthrd, msgmap, flags, v);
      }
***************
*** 10677,10695 ****
  {
      char        to_us = ' ';
      PINETHRD_S *nthrd, *bthrd;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return to_us;
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  to_us = to_us_symbol_for_thread(stream, nthrd, consider_flagged);
      }
  
!     if(to_us == ' ' && thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  to_us = to_us_symbol_for_thread(stream, bthrd, consider_flagged);
      }
--- 11187,11206 ----
  {
      char        to_us = ' ';
      PINETHRD_S *nthrd, *bthrd;
+     unsigned long next = 0L, branch = 0L;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return to_us;
  
!     if(next = get_next(stream,thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  to_us = to_us_symbol_for_thread(stream, nthrd, consider_flagged);
      }
  
!     if(to_us == ' ' && (branch = get_branch(stream, thrd))){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  to_us = to_us_symbol_for_thread(stream, bthrd, consider_flagged);
      }
***************
*** 10724,10730 ****
  		  break;
  	      }
  	    
! 	    if(to_us != '+' && resent_to_us(&idata))
  	      to_us = '+';
  
  	    if(to_us == ' ' && F_ON(F_MARK_FOR_CC,ps_global))
--- 11235,11241 ----
  		  break;
  	      }
  	    
! 	    if(to_us != '+' && !idata.bogus && resent_to_us(&idata))
  	      to_us = '+';
  
  	    if(to_us == ' ' && F_ON(F_MARK_FOR_CC,ps_global))
***************
*** 10760,10766 ****
      int         flags;		/* flags to set or clear */
  {
      int hiding;
!     unsigned long rawno, msgno;
      PINETHRD_S *nthrd, *bthrd;
  
      hiding = (flags == MN_CHID) && v;
--- 11271,11277 ----
      int         flags;		/* flags to set or clear */
  {
      int hiding;
!     unsigned long rawno, msgno, next, branch;
      PINETHRD_S *nthrd, *bthrd;
  
      hiding = (flags == MN_CHID) && v;
***************
*** 10772,10778 ****
  
      set_lflag(stream, msgmap, msgno, flags, v);
  
!     if(thrd->next && (hiding || !get_lflag(stream,NULL,thrd->rawno,MN_COLL))){
  	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_thread_subtree(stream, nthrd, msgmap, v, flags);
--- 11283,11290 ----
  
      set_lflag(stream, msgmap, msgno, flags, v);
  
!     if(thrd->next
! 	 && (hiding || !get_lflag(stream,NULL,thrd->rawno,MN_COLL))){
  	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_thread_subtree(stream, nthrd, msgmap, v, flags);
***************
*** 10816,10823 ****
      if(rawno)
        thrd = fetch_thread(stream, rawno);
  
!     if(thrd && thrd->top && thrd->top != thrd->rawno)
!       thrd = fetch_thread(stream, thrd->top);
      
      if(!thrd)
        return 0;
--- 11328,11335 ----
      if(rawno)
        thrd = fetch_thread(stream, rawno);
  
!     if(thrd && thrd->top && top_thread(stream,thrd->top) != thrd->rawno)
!       thrd = fetch_thread(stream, top_thread(stream,thrd->top));
      
      if(!thrd)
        return 0;
***************
*** 10833,10840 ****
  	set_thread_lflags(stream, thrd, msgmap, MN_CHID2, 1);
      }
  
!     if(current_index_state)
!       msgmap->top_after_thrd = current_index_state->msg_at_top;
  
      /*
       * If this is one of those wacky users who like to sort backwards
--- 11345,11353 ----
  	set_thread_lflags(stream, thrd, msgmap, MN_CHID2, 1);
      }
  
! /*    if(current_index_state)
!       msgmap->top_after_thrd = current_index_state->msg_at_top;*/
!       msgmap->top_after_thrd = mn_raw2m(msgmap, thrd->top);
  
      /*
       * If this is one of those wacky users who like to sort backwards
***************
*** 10889,10895 ****
        thrd = fetch_thread(stream, rawno);
      
      if(thrd && thrd->top)
!       topthrd = fetch_thread(stream, thrd->top);
      
      if(!topthrd)
        return 0;
--- 11402,11408 ----
        thrd = fetch_thread(stream, rawno);
      
      if(thrd && thrd->top)
!       topthrd = fetch_thread(stream, top_thread(stream,thrd->top));
      
      if(!topthrd)
        return 0;
***************
*** 11026,11028 ****
--- 11539,11879 ----
  	}
      }
  }
+ 
+ unsigned long
+ get_branch(stream,thrd)
+     MAILSTREAM *stream;
+     PINETHRD_S *thrd;
+ {
+   PINETHRD_S *nthrd = NULL;
+   unsigned long top;
+ 
+   if (thrd->toploose && thrd->nextthd)
+     nthrd = fetch_thread(stream, thrd->nextthd);
+   if (!nthrd)
+     return thrd->branch;
+   top = top_thread(stream, thrd->rawno);
+   return thrd->branch 
+ 	   ? thrd->branch 
+ 	   : (F_ON(F_ENHANCED_THREAD, ps_global) 
+ 		? (top == top_thread(stream, nthrd->rawno) ? thrd->nextthd : 0L)
+ 		: 0L);
+ }
+ 
+ unsigned long
+ get_next(stream,thrd)
+     MAILSTREAM *stream;
+     PINETHRD_S *thrd;
+ {
+   return thrd->next;
+ }
+ 
+ long
+ get_length_branch(stream, rawno)
+ MAILSTREAM *stream;
+ long	    rawno;
+ {
+   int branchp = 0, done = 0;
+   long top, count = 1L, raw;
+   PINETHRD_S *thrd, *pthrd = NULL, *nthrd;
+ 
+   thrd = fetch_thread(stream, rawno);
+ 
+   if (!thrd)
+     return -1L;
+ 
+   top = thrd->top;
+ 
+   if (thrd->parent)
+     pthrd = fetch_thread(stream, thrd->parent);
+ 
+   if (thrd->rawno == top)
+      branchp++;
+ 
+   if (!branchp && !pthrd){	/* what!!?? */
+      raw = top;
+      while (!done){
+         pthrd = fetch_thread(stream, raw);
+         if ((pthrd->next == rawno) || (pthrd->branch == rawno))
+            done++;
+         else{
+ 	   if (pthrd->next)
+ 	      raw = pthrd->next;
+ 	   else if (pthrd->branch)
+ 	      raw = pthrd->branch;
+ 	}
+      }
+   }
+ 
+   if (pthrd && pthrd->next == thrd->rawno && thrd->branch)
+      branchp++;
+ 
+   if (pthrd && pthrd->next && pthrd->next != thrd->rawno){
+      nthrd = fetch_thread(stream, pthrd->next);
+      while (nthrd && nthrd->branch && nthrd->branch != thrd->rawno)
+ 	nthrd = fetch_thread(stream, nthrd->branch);
+      if(nthrd && nthrd->branch && nthrd->branch == thrd->rawno)
+ 	branchp++;
+   }
+ 
+   if(branchp){
+     int entry = 0;
+     while(thrd && thrd->next){
+ 	entry = 1;
+ 	count++;
+ 	thrd = fetch_thread(stream, thrd->next);
+ 	if (thrd->branch)
+ 	   break;
+     }
+     if (entry && thrd->branch)
+ 	count--;
+   }
+   return branchp ? (count ? count : 1L) : 0L;
+ }
+ 
+ void
+ find_msgmap(stream, msgmap, flags, ordersort, is_rev)
+ MAILSTREAM *stream;
+ MSGNO_S    *msgmap;
+ int         flags;
+ SortOrder   ordersort;
+ unsigned    is_rev;
+ {
+    int we_cancel;
+    long *old_arrival,*new_arrival;
+    long init_thread, end_thread, current;
+    long k = 1L, j, last_thread = 0L;
+    long i, tmsg, ntmsg, nthreads;
+    int nflags = (SRT_VRB | SRT_MAN);
+    char        sort_msg[MAX_SCREEN_COLS+1] = {'\0'};
+    PINETHRD_S *thrd, *tthrd, *nthrd;
+  
+    erase_thread_info = 0;
+    current = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+    /* now sort by arrival */
+    sort_folder(stream, msgmap, ordersort, 0, nflags, 0);
+ 
+    tmsg = mn_get_total(msgmap) + 1;
+ 
+    if (tmsg <= 1)
+      return;
+ 
+    old_arrival = (long *) fs_get(tmsg * sizeof(long));
+    memset(old_arrival, 0, tmsg*sizeof(long));
+    for (i= 1L;(i <= mn_get_total(msgmap)) && (old_arrival[i] = msgmap->sort[i]); i++);
+ 
+    /* now sort by thread */
+    sort_folder(stream, msgmap, SortThread, 0, nflags, 0);
+    ntmsg = mn_get_total(msgmap) + 1;
+ 
+    if (tmsg != ntmsg){	/* oh oh, something happened,we better try again */
+ 	fs_give((void **)&old_arrival);
+ 	find_msgmap(stream, msgmap, flags, ordersort, is_rev);
+ 	return;
+    }
+ 
+    /* reconstruct the msgmap */
+ 
+    new_arrival = (long *) fs_get(tmsg * sizeof(long));
+    memset(new_arrival, 0, tmsg*sizeof(long));
+    i = mn_get_total(msgmap);
+    while (new_arrival[1] == 0){ /* think of this as (tmsg > 0) */
+         int done = 0;
+ 	long n = mn_get_total(msgmap);
+ 
+         init_thread = top_thread(stream, old_arrival[i]);
+ 	thrd = fetch_thread(stream, init_thread);
+         while ((new_arrival[n] != 0) && !done){ /* compare raw numbers */
+           done = (new_arrival[n] == init_thread); 
+           n--;
+         }
+         if (!done){
+ 	   k = 1L;
+ 	   mn_set_cur(msgmap, mn_raw2m(msgmap, init_thread));
+ 	   if  (move_next_thread(ps_global, stream, msgmap, 0) <= 0)
+ 	 	j = mn_get_total(msgmap) - mn_raw2m(msgmap, init_thread) + 1;
+ 	   else
+ 		j = mn_get_cur(msgmap) - mn_raw2m(msgmap, init_thread);
+            end_thread = mn_raw2m(msgmap, init_thread) + j;
+            while (k <= j){
+               new_arrival[tmsg - k] = msgmap->sort[end_thread - k];
+               k++;
+            }
+            tmsg -= j;
+        }
+        i--;
+    }
+    relink_threads(stream, msgmap, new_arrival);
+    for (i = 1; (i <= mn_get_total(msgmap)) 
+ 		&&  (msgmap->sort[i] = new_arrival[i]); i++);
+    msgno_reset_isort(msgmap);
+ 
+    fs_give((void **)&new_arrival);
+    fs_give((void **)&old_arrival);
+ 
+ 
+    if(is_rev && (mn_get_total(msgmap) > 1L)){
+       long *rev_sort;
+       long i = 1L, l = mn_get_total(msgmap);
+ 
+       rev_sort = (long *) fs_get((mn_get_total(msgmap)+1L) * sizeof(long));
+       memset(rev_sort, 0, (mn_get_total(msgmap)+1L)*sizeof(long));
+       while (l > 0L){
+ 	 if (top_thread(stream, msgmap->sort[l]) == msgmap->sort[l]){
+ 	    long init_thread = msgmap->sort[l];
+ 	    long j, k;
+ 
+ 	    mn_set_cur(msgmap, mn_raw2m(msgmap, init_thread));
+ 	    if (move_next_thread(ps_global, stream, msgmap, 0) <= 0)
+ 	 	j = mn_get_total(msgmap) - mn_raw2m(msgmap, init_thread) + 1;
+ 	    else
+ 		j = mn_get_cur(msgmap) - mn_raw2m(msgmap, init_thread);
+ 	    for (k = 0L; (k < j) && (rev_sort[i+k] = msgmap->sort[l+k]); k++);
+ 	    i += j;
+ 	 }
+ 	 l--;
+       }
+       relink_threads(stream, msgmap, rev_sort);
+       for (i = 1L; i <=  mn_get_total(msgmap); i++)
+         msgmap->sort[i] = rev_sort[i];
+       msgno_reset_isort(msgmap);
+       fs_give((void **)&rev_sort);
+    }
+    mn_reset_cur(msgmap, first_sorted_flagged(is_rev ? F_NONE : F_SRCHBACK,
+ 			stream, mn_raw2m(msgmap, current), FSF_SKIP_CHID));
+    msgmap->top = -1L;
+ 
+    sp_set_unsorted_newmail(ps_global->mail_stream, 0);
+ 
+    for(i = 1L; i <= ps_global->mail_stream->nmsgs; i++)
+       mail_elt(ps_global->mail_stream, i)->spare7 = 0;
+ 
+    mn_set_sort(msgmap, SortThread);
+    mn_set_revsort(msgmap, is_rev);
+    erase_thread_info = 1;
+    clear_index_cache();
+ }
+ 
+ void
+ move_thread(state, stream, msgmap, direction)
+     struct pine *state;
+     MAILSTREAM	*stream;
+     MSGNO_S     *msgmap;
+     int		 direction;
+ {
+   long new_cursor, old_cursor = mn_get_cur(msgmap);
+   int rv;
+   PINETHRD_S *thrd;
+ 
+    rv = direction > 0 ? move_next_thread(state, stream, msgmap, 1):
+ 			move_prev_thread(state, stream, msgmap, 1);
+    if (rv > 0 && THRD_INDX_ENABLED()){
+        new_cursor = mn_get_cur(msgmap);
+        mn_set_cur(msgmap, old_cursor);
+        unview_thread(state, stream, msgmap);
+        thrd = fetch_thread(stream,mn_m2raw(msgmap, new_cursor));
+        mn_set_cur(msgmap, new_cursor);
+        view_thread(state, stream, msgmap, 1);
+        state->next_screen = SCREEN_FUN_NULL;
+    }
+ }
+ 
+ void
+ relink_threads(stream, msgmap, new_arrival)
+   MAILSTREAM *stream;
+   MSGNO_S    *msgmap;
+   long	     *new_arrival;
+ {
+    long last_thread = 0L;
+    long i = 0L, j = 1L, k;
+    PINETHRD_S *thrd, *nthrd;
+ 
+    while (j <= mn_get_total(msgmap)){ 
+ 	i++;
+ 	thrd = fetch_thread(stream, new_arrival[j]);
+ 	if (!thrd)  /* sort failed!, better leave from here now!!! */
+ 	   break;
+ 	thrd->prevthd = last_thread;
+ 	thrd->thrdno  = i;
+ 	thrd->head    = new_arrival[1];
+ 	last_thread = thrd->rawno;
+ 	mn_set_cur(msgmap, mn_raw2m(msgmap,thrd->top));
+ 	k = mn_get_cur(msgmap);
+ 	if  (move_next_thread(ps_global, stream, msgmap, 0) <= 0)
+ 	    j += mn_get_total(msgmap) + 1 - k;
+ 	else
+ 	    j += mn_get_cur(msgmap) - k;
+ 	if (!thrd->toploose)
+ 	   thrd->nextthd = (j <= mn_get_total(msgmap)) ? new_arrival[j] : 0L;
+ 	else{
+ 	  int done = 0;
+ 	  while(thrd->nextthd && !done){
+ 	      thrd->thrdno = i;
+ 	      thrd->head    = new_arrival[1];
+ 	      if (thrd->nextthd)
+ 		 nthrd = fetch_thread(stream, thrd->nextthd);
+ 	      else
+ 		done++;
+ 	      if(top_thread(stream, thrd->rawno) == top_thread(stream, nthrd->rawno))
+ 		thrd = nthrd;
+ 	      else
+ 		done++;
+ 	  }
+ 	  thrd->nextthd = (j <= mn_get_total(msgmap)) ? new_arrival[j] : 0L;
+ 	  last_thread = thrd->rawno;
+ 	}
+    }
+ }
+ 
+       
+ int
+ find_index_rule()
+ {
+   int found = 0;
+   RULE_RESULT *rule;
+   INDEXDATA_S idata;   
+   ENVELOPE *local_env;
+       
+    memset(&idata, 0, sizeof(INDEXDATA_S));
+    idata.stream   = ps_global->mail_stream;
+    local_env = (ENVELOPE *)make_envelope(&idata, 0);
+    rule = (RULE_RESULT *)
+           get_result_rule(ps_global->VAR_INDEX_RULES, FOR_RULE | FOR_INDEX,
+ 				 local_env);
+    if (local_env)
+      mail_free_envelope(&local_env);
+    if (rule){
+       init_index_format(rule->result, &ps_global->index_disp_format);
+       found = 1;
+       if (rule->result)
+          fs_give((void **)&rule->result);
+       fs_give((void **)&rule);
+    }
+    return found;
+ }
+ 
+ void
+ setup_threading_display_style()
+ {
+   RULE_RESULT *rule;
+   NAMEVAL_S *v;
+   int i;
+ 
+   rule = (RULE_RESULT *)
+           get_result_rule(ps_global->VAR_THREAD_DISP_STYLE_RULES, 
+ 			  FOR_RULE | FOR_THREAD, (ENVELOPE *) NULL);
+   if (rule || ps_global->VAR_THREAD_DISP_STYLE){
+      for(i = 0; v = thread_disp_styles(i); i++)
+         if(!strucmp(rule ? rule->result : ps_global->VAR_THREAD_DISP_STYLE, 
+ 		    rule ? (v ? v->name : "" ) : S_OR_L(v))){
+               ps_global->thread_disp_style = v->value;
+               break;
+         }
+      if (rule){
+ 	if (rule->result)
+ 	   fs_give((void **)&rule->result);
+ 	fs_give((void **)&rule);
+      }
+   }
+ }
diff -rc pine4.61/pine/mailpart.c pine4.61.I.USE/pine/mailpart.c
*** pine4.61/pine/mailpart.c	Tue Jul 13 18:35:16 2004
--- pine4.61.I.USE/pine/mailpart.c	Fri Jul 16 12:05:27 2004
***************
*** 808,815 ****
--- 808,821 ----
  	    /*--- get string  ---*/
  	    {int   rc, found = 0;
  	     char *result = NULL, buf[64];
+ 	     static char last_pat[64] = {'\0'};
  	     static char last[64], tmp[64];
  	     HelpType help;
+              static ESCKEY_S ekey[] = {
+                 {0, 0, "", ""},
+                 {ctrl('N'), 9, "^N", "Ins Pat"},
+                 {-1, 0, NULL, NULL}};
+ 
  
  	     ps->mangled_footer = 1;
  	     buf[0] = '\0';
***************
*** 822,839 ****
  		 int flags = OE_APPEND_CURRENT | OE_SEQ_SENSITIVE;
  
  		 rc = optionally_enter(buf,-FOOTER_ROWS(ps),0,sizeof(buf),
! 					 tmp,NULL,help,&flags);
  		 if(rc == 3)
  		   help = help == NO_HELP ? h_attach_index_whereis : NO_HELP;
! 		 else if(rc == 0 || rc == 1 || !buf[0]){
  		     if(rc == 0 && !buf[0] && last[0])
  		       strcpy(buf, last);
! 
! 		     break;
  		 }
  	     }
  
  	     if(rc == 0 && buf[0]){
  		 ctmp = current;
  		 while(ctmp = next_attline(ctmp))
  		   if(srchstr(ctmp->dstring, buf)){
--- 828,850 ----
  		 int flags = OE_APPEND_CURRENT | OE_SEQ_SENSITIVE;
  
  		 rc = optionally_enter(buf,-FOOTER_ROWS(ps),0,sizeof(buf),
! 					 tmp,ekey,help,&flags);
  		 if(rc == 3)
  		   help = help == NO_HELP ? h_attach_index_whereis : NO_HELP;
! 		 else if(rc == 0 || rc == 1 || rc == 9 || !buf[0]){
  		     if(rc == 0 && !buf[0] && last[0])
  		       strcpy(buf, last);
! 		     if (rc == 9)
! 			insert_pattern_in_string(buf, last_pat, 63);
! 		     else
! 			break;
  		 }
  	     }
  
  	     if(rc == 0 && buf[0]){
+ 		strncpy(last_pat, buf, sizeof(last_pat));
+ 		last_pat[sizeof(last_pat)-1] = '\0';
+      
  		 ctmp = current;
  		 while(ctmp = next_attline(ctmp))
  		   if(srchstr(ctmp->dstring, buf)){
***************
*** 3466,3472 ****
      /*
       * For consistency, the first question is always "include text?"
       */
!     if((include_text = reply_text_query(ps_global, 1, &prefix)) >= 0
         && reply_news_test(a->body->nested.msg->env, outgoing) > 0
         && reply_harvest(ps_global, msgno, a->number,
  			a->body->nested.msg->env, &saved_from,
--- 3477,3483 ----
      /*
       * For consistency, the first question is always "include text?"
       */
!     if((include_text = reply_text_query(ps_global, 1, NULL, &prefix)) >= 0
         && reply_news_test(a->body->nested.msg->env, outgoing) > 0
         && reply_harvest(ps_global, msgno, a->number,
  			a->body->nested.msg->env, &saved_from,
diff -rc pine4.61/pine/mailview.c pine4.61.I.USE/pine/mailview.c
*** pine4.61/pine/mailview.c	Wed Jul 14 17:25:10 2004
--- pine4.61.I.USE/pine/mailview.c	Fri Aug  6 08:57:16 2004
***************
*** 75,80 ****
--- 75,89 ----
      int		len;
  } SCRLFILE_S;
  
+ #include <regex.h>
+ 
+ #define REGERROR 128
+ 
+ typedef struct IVAL {
+    int start;
+    int end;
+    struct IVAL *next;
+ } IVAL_S;
  
  /*
   * Struct to help write lines do display as they're decoded
***************
*** 152,157 ****
--- 161,167 ----
  #define	SS_CUR	2
  #define	SS_FREE	3
  
+ static ACTION_S *role_chosen = NULL;
  
  /*
   * Def's to help page reframing based on handles
***************
*** 235,246 ****
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
  	RCOMPOSE_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
  	NULL_MENU};
  INST_KEY_MENU(view_keymenu, view_keys);
  #define VIEW_ATT_KEY		 3
--- 245,256 ----
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
  	RCOMPOSE_MENU,
! 	{"(","Prev Threa",{MC_PRETHREAD,1,{'('}},KS_NONE},
! 	{")","Next Threa",{MC_NEXTHREAD,1,{')'}},KS_NONE},
! 	{"^D","Delete Thr",{MC_DELTHREAD,1,{ctrl('D')}},KS_NONE},
! 	{"^U","Undel Thre",{MC_UNDTHREAD,1,{ctrl('U')}},KS_NONE},
! 	{"^T","selcT Thre",{MC_SELTHREAD,1,{ctrl('T')}},KS_NONE},
! 	{"^H","ChkIncFl",{MC_FORCECHECK,1,{ctrl('H')}},KS_NONE},
  	NULL_MENU};
  INST_KEY_MENU(view_keymenu, view_keys);
  #define VIEW_ATT_KEY		 3
***************
*** 268,274 ****
  	{"S", "Save", {MC_SAVETEXT,1,{'s'}}, KS_SAVE}};
  INST_KEY_MENU(simple_text_keymenu, simple_text_keys);
  
! 
  
  
  /*
--- 278,284 ----
  	{"S", "Save", {MC_SAVETEXT,1,{'s'}}, KS_SAVE}};
  INST_KEY_MENU(simple_text_keymenu, simple_text_keys);
  
! static char *prefix;
  
  
  /*
***************
*** 361,366 ****
--- 371,385 ----
  void	    embed_color PROTO((COLOR_PAIR *, gf_io_t));
  int         color_a_quote PROTO((long, char *, LT_INS_S **, void *));
  int         color_signature PROTO((long, char *, LT_INS_S **, void *));
+ IVAL_S	   *copy_ival PROTO((IVAL_S *));
+ IVAL_S *    compute_interval PROTO((char *, char *, int));
+ void	    interval_free PROTO((IVAL_S **));
+ char *	    regex_pattern PROTO((char **));
+ LT_INS_S ** insert_color_special_text PROTO((LT_INS_S **, char **, IVAL_S *,
+ 							int, COLOR_PAIR *));
+ int	    any_color_in_string PROTO((char *));
+ int	    length_color PROTO((char *, int));
+ int         color_this_text PROTO((long, char *, LT_INS_S **, void *));
  int         color_headers PROTO((long, char *, LT_INS_S **, void *));
  int	    url_hilite_hdr PROTO((long, char *, LT_INS_S **, void *));
  int	    url_launch PROTO((HANDLE_S *));
***************
*** 386,391 ****
--- 405,412 ----
  int	    pcpine_resize_scroll PROTO((void));
  int	    pcpine_view_cursor PROTO((int, long));
  #endif
+ int         is_word PROTO((char [], int, int));
+ int         is_mailbox PROTO((char [], int, int));
  
  
  
***************
*** 466,471 ****
--- 487,503 ----
  	else
  	  ps->unseen_in_view = !mc->seen;
  
+ 	prefix = reply_quote_str(env);
+ 	/* Make sure the prefix is not only made of spaces, so that we do not
+ 	 * paint the screen incorrectly
+ 	 */
+ 	if (prefix && *prefix){
+ 	   int i;
+ 	   for (i = 0; isspace((unsigned char) prefix[i]); i++);
+ 	   if (i == strlen(prefix))
+ 	     fs_give((void **)&prefix);
+ 	}
+ 
  #if	defined(DOS) && !defined(WIN32)
  	/* 
  	 * Handle big text for DOS here.
***************
*** 624,629 ****
--- 656,663 ----
      }
      while(ps->next_screen == SCREEN_FUN_NULL);
  
+     if (prefix && *prefix)
+        fs_give((void **)&prefix);
      if(we_cancel)
        cancel_busy_alarm(-1);
  
***************
*** 1580,1585 ****
--- 1614,1627 ----
  	    if((flgs & FM_DISPLAY)
  	       && !(flgs & FM_NOCOLOR)
  	       && pico_usingcolor()
+ 	       && ps_global->VAR_SPECIAL_TEXT_FORE_COLOR
+ 	       && ps_global->VAR_SPECIAL_TEXT_BACK_COLOR){
+ 		gf_link_filter(gf_line_test, gf_line_test_opt(color_this_text, NULL));
+ 	    }
+ 
+ 	    if((flgs & FM_DISPLAY)
+ 	       && !(flgs & FM_NOCOLOR)
+ 	       && pico_usingcolor()
  	       && ps_global->VAR_SIGNATURE_FORE_COLOR
  	       && ps_global->VAR_SIGNATURE_BACK_COLOR){
  		gf_link_filter(gf_line_test, gf_line_test_opt(color_signature, &is_in_sig));
***************
*** 1590,1597 ****
  	       && pico_usingcolor()
  	       && ps_global->VAR_QUOTE1_FORE_COLOR
  	       && ps_global->VAR_QUOTE1_BACK_COLOR){
! 		gf_link_filter(gf_line_test, gf_line_test_opt(color_a_quote, NULL));
  	    }
  
  	    wrapflags = (flgs & FM_DISPLAY) ? GFW_HANDLES : 0;
  	    if(flgs & FM_DISPLAY
--- 1632,1641 ----
  	       && pico_usingcolor()
  	       && ps_global->VAR_QUOTE1_FORE_COLOR
  	       && ps_global->VAR_QUOTE1_BACK_COLOR){
! 		gf_link_filter(gf_quote_test,gf_line_test_opt(color_a_quote, NULL));
  	    }
+ 	    else
+ 		gf_link_filter(gf_quote_test,gf_line_test_opt(select_quote, NULL));
  
  	    wrapflags = (flgs & FM_DISPLAY) ? GFW_HANDLES : 0;
  	    if(flgs & FM_DISPLAY
***************
*** 2681,2686 ****
--- 2725,2732 ----
  	{0, 'a', "A", "editApp"},
  	{-1, 0, NULL, NULL}};
  
+     if (role_chosen)
+ 	free_action(&role_chosen);
      if(handle->type == URL){
  	launch_opts[4].ch = 'u';
  
***************
*** 2791,2801 ****
  	 * sense if you just say View selected URL ...
  	 */
  	if(handle->type == URL &&
! 	   !struncmp(handle->h.url.path, "mailto:", 7))
! 	  sprintf(prompt, "Compose mail to \"%.*s%s\" ? ",
! 		  min(max(0,sc - 25), sizeof(prompt)-50), handle->h.url.path+7,
! 		  (strlen(handle->h.url.path+7) > max(0,sc-25)) ? "..." : "");
! 	else
  	  sprintf(prompt, "View selected %s %s%.*s%s ? ",
  		  (handle->type == URL) ? "URL" : "Attachment",
  		  (handle->type == URL) ? "\"" : "",
--- 2837,2877 ----
  	 * sense if you just say View selected URL ...
  	 */
  	if(handle->type == URL &&
! 	   !struncmp(handle->h.url.path, "mailto:", 7)){
! 	  int rolenick = role_chosen ? strlen(role_chosen->nick) : 0;
! 	  int offset   = 25 + (role_chosen ? 20 : 0);
! 	  int offset2  = max(0, sc - offset) - strlen(handle->h.url.path+7);
! 	  int offset3  = sc - strlen(handle->h.url.path+7) - rolenick - offset;
! 	  int laddress = min(max(0,sc - offset), sizeof(prompt)-50);
! 	  int lrole    = rolenick;
! 
! 	  if (offset3 < 0){
! 		lrole    = rolenick;
! 		laddress = sc - offset - lrole;
! 		offset3 = laddress - 20; /* redefine offset3 */
! 		if (offset3 < 0){
! 		   laddress = 20;
! 		   lrole    = sc - offset - laddress;
! 		}
! 	  }
! 	  launch_opts[2].ch = 'r';
! 	  launch_opts[2].rval = 'r';
! 	  launch_opts[2].name = "R";
! 	  launch_opts[2].label = "Set Role";
! 	  sprintf(prompt, "Compose mail to \"%.*s%s\" %s%.*s%s%s? ",
! 		  laddress, handle->h.url.path+7,
! 		  offset2 < 0 ? "..." : "",
! 		  role_chosen ? "using role \"" : "",
! 		  role_chosen ? lrole : 0,
! 		  role_chosen ? role_chosen->nick  : "",
! 		  role_chosen ? (rolenick > lrole ? "..." : "") : "",
! 		  role_chosen ? "\" " : "");
! 	}
! 	else{
! 	  launch_opts[2].ch = -2;
! 	  launch_opts[2].rval = 0;
! 	  launch_opts[2].name = NULL;
! 	  launch_opts[2].label = NULL;
  	  sprintf(prompt, "View selected %s %s%.*s%s ? ",
  		  (handle->type == URL) ? "URL" : "Attachment",
  		  (handle->type == URL) ? "\"" : "",
***************
*** 2804,2815 ****
--- 2880,2915 ----
  		  (handle->type == URL)
  		    ? ((strlen(handle->h.url.path) > max(0,sc-27))
  			    ? "...\"" : "\"") : "");
+ 	}
  
  	switch(radio_buttons(prompt, -FOOTER_ROWS(ps_global),
  			     launch_opts, 'y', 0, NO_HELP, RB_SEQ_SENSITIVE)){
  	  case 'y' :
  	    return(1);
  
+ 	  case 'r':
+ 	 {
+ 	   void (*prev_screen)() = ps_global->prev_screen,
+                 (*redraw)() = ps_global->redrawer;
+ 	   ps_global->redrawer = NULL;
+ 	   ps_global->next_screen = SCREEN_FUN_NULL;
+ 	   if(role_select_screen(ps_global, &role_chosen, 1) < 0){
+ 	      cmd_cancelled("Compose");
+ 	      ps_global->next_screen = prev_screen;
+ 	      ps_global->redrawer = redraw;
+ 	      if(ps_global->redrawer)
+ 		(*ps_global->redrawer)();
+ 	      return 0;
+ 	   }
+ 	   ps_global->next_screen = prev_screen;
+ 	   ps_global->redrawer = redraw;
+ 	   if(role_chosen)
+ 	     role_chosen = combine_inherited_role(role_chosen);
+ 	   if(ps_global->redrawer)
+ 	     (*ps_global->redrawer)();
+ 	 }
+          break;
+ 
  	  case 'u' :
  	    strncpy(tmp, handle->h.url.path, sizeof(tmp)-1);
  	    tmp[sizeof(tmp)-1] = '\0';
***************
*** 3471,3476 ****
--- 3571,3605 ----
      return(buf);
  }
  
+ #define is_digit(c) ((((c) >= '0') && ((c) <= '9')) ? 1 : 0)
+ 
+ #define is_letter(c) (((c) >= 'a' && (c) <= 'z') || \
+                          ((c) >= 'A' && (c) <= 'Z'))
+ 
+ #define next(w,i) ((((w)[(i)]) != 0) ? ((w)[(i) + 1]) : 0)
+ 
+ #define single_level(c) (((c) == '>') || ((c) == '|') || ((c) == '~') || \
+ 			  ((c) == ']'))
+ 
+ int
+ is_word (buf, i, j)
+ char buf[NSTRING];
+ int i;
+ int j;
+ {
+  return i <= j && is_letter(buf[i]) ?
+          (i < j ? is_word(buf,i+1,j) : 1) : 0;
+ }
+ 
+ int
+ is_mailbox(buf,i,j)
+ char buf[NSTRING];
+ int i;
+ int j;
+ {
+  return i <= j && (is_letter(buf[i]) || is_digit(buf[i]) || buf[i] == '.')
+         ? (i < j ? is_mailbox(buf,i+1,j) : 1) : 0;
+ }
  
  int
  colorcmp(color1, color2)
***************
*** 3493,3498 ****
--- 3622,3694 ----
      struct quote_colors *next;
  };
  
+ 
+ int 
+ next_level_quote(buf, line, i, is_flowed)
+    char *buf;
+    char **line;
+    int i;
+    int is_flowed;
+ {
+    int j;
+ 
+    if (!single_level(buf[i])){
+ 	if(is_mailbox(buf,i,i)){
+ 	  for (j = i; buf[j] && !isspace(buf[j]); j++);
+ 	  if (is_word(buf,i,j) || is_mailbox(buf,i,j))
+ 	     j += isspace(buf[j]) ? 2 : 1;
+ 	}
+ 	else{
+ 	   switch(buf[i]){
+ 	     case ':' :
+ 		      if (next(buf,i) != RPAREN)
+ 		           j = i + 1;
+ 		      else
+ 			   j = i + 2;
+ 		    break;
+ 
+ 	     case '-' :
+ 		     if (next(buf,i) != '-')
+ 		        j = i + 2;
+ 		     else
+ 		        j = i + 3;
+ 		    break;
+ 
+ 	     case '+' :
+ 	     case '*' :
+ 		    if (next(buf,i) != ' ')
+ 		       j = i + 2;
+ 		    else
+ 		       j = i + 3;
+ 		    break;
+ 
+ 	     default  :
+ 		   for (j = i; buf[j] && !isspace(buf[j])
+ 		         && (!single_level(buf[i]) && !is_letter(buf[j])); j++);
+ 		   j += isspace(buf[j]) ? 1 : 0;
+ 	           break;
+              }
+ 	}
+ 	if (line && *line)
+ 	   (*line) += j - i;
+     }
+     else{
+        j = i+1;
+        if (line && *line)
+ 	  (*line)++;
+     }
+     if(!is_flowed){
+ 	if(line && *line)
+ 	  for(; isspace((unsigned char)*(*line)); (*line)++);
+ 	for (i = j; isspace((unsigned char) buf[i]); i++);
+     }
+     else i = j;
+     if (is_flowed && i != j)
+        buf[i] = '\0';
+    return i;
+ }
+ 
+ 
  int
  color_a_quote(linenum, line, ins, is_flowed_msg)
      long       linenum;
***************
*** 3500,3518 ****
      LT_INS_S **ins;
      void      *is_flowed_msg;
  {
!     int countem = 0;
      struct variable *vars = ps_global->vars;
      char *p;
      struct quote_colors *colors = NULL, *cp, *next;
      COLOR_PAIR *col = NULL;
      int is_flowed = is_flowed_msg ? *((int *)is_flowed_msg) : 0;
  
      p = line;
      if(!is_flowed)
!       while(isspace((unsigned char)*p))
  	p++;
  
!     if(p[0] == '>'){
  	struct quote_colors *c;
  
  	/*
--- 3696,3726 ----
      LT_INS_S **ins;
      void      *is_flowed_msg;
  {
!     int countem = 0, i, j = 0;
      struct variable *vars = ps_global->vars;
      char *p;
+     char buf[NSTRING] = {'\0'};
      struct quote_colors *colors = NULL, *cp, *next;
      COLOR_PAIR *col = NULL;
      int is_flowed = is_flowed_msg ? *((int *)is_flowed_msg) : 0;
  
+     select_quote(linenum, line, ins, is_flowed_msg);
+     for (i = 0; tmp_20k_buf[i] && (buf[i] = tmp_20k_buf[i]); i++);
+     buf[i] = '\0';
+ 
      p = line;
      if(!is_flowed)
!       for(i = 0;isspace((unsigned char)buf[i]); i++)
  	p++;
+     else{
+ 	for (j = 0; buf[j] && isspace((unsigned char)buf[j]); j++);
+ 	if (buf[j]){
+ 	   p += j;
+ 	}
+ 	i = j;
+     }
  
!     if(buf[i]){
  	struct quote_colors *c;
  
  	/*
***************
*** 3561,3567 ****
        free_color_pair(&col);
  
      cp = NULL;
!     while(*p == '>'){
  	cp = (cp && cp->next) ? cp->next : colors;
  
  	if(countem > 0)
--- 3769,3775 ----
        free_color_pair(&col);
  
      cp = NULL;
!     while(buf[i]){
  	cp = (cp && cp->next) ? cp->next : colors;
  
  	if(countem > 0)
***************
*** 3571,3580 ****
  
  	countem = (countem == 1) ? 0 : countem;
  
! 	p++;
! 	if(!is_flowed)
! 	  for(; isspace((unsigned char)*p); p++)
! 	    ;
      }
  
      if(colors){
--- 3779,3787 ----
  
  	countem = (countem == 1) ? 0 : countem;
  
! 	i = next_level_quote(buf, &p, i, is_flowed);
! 	for (; isspace((unsigned char)*p); p++);
! 	for (; isspace((unsigned char)buf[i]); i++);
      }
  
      if(colors){
***************
*** 3638,3643 ****
--- 3845,4144 ----
      return(0);
  }
  
+ int
+ select_quote(linenum, line, ins, is_flowed_msg)
+     long       linenum;
+     char      *line;
+     LT_INS_S **ins;
+     void      *is_flowed_msg;
+ {
+     int i;
+     struct variable *vars = ps_global->vars;
+     char *p;
+     char buf[NSTRING] = {'\0'};
+     static char GLine[NSTRING] = {'\0'};
+     static char PLine[NSTRING] = {'\0'};
+     char NLine[NSTRING] = {'\0'};
+     QSTRING_S *qs;
+ 
+     if (linenum != 0){
+        for (i = 0; GLine[i] && (PLine[i] = GLine[i]); i++);
+        PLine[i] = 0;
+     }
+ 
+     for (i = 0; tmp_20k_buf[i] && (tmp_20k_buf[i] != '\015') && (i < NSTRING)
+               && (i < SIZEOF_20KBUF)
+               && (NLine[i] = tmp_20k_buf[i]); i++);
+     NLine[i] = '\0';
+ 
+     if (line){
+        for (i = 0; (i < NSTRING) && ((GLine[i] = line[i]) != 0); i++);
+        GLine[NSTRING - 1] = '\0';
+     }
+     else
+        GLine[0] = '\0';
+ 
+     qs = do_quote_match(prefix && *prefix ? prefix : ">",
+ 						GLine, NLine, PLine, 0);
+     flatten_qstring(qs, buf);
+     free_qs(&qs);
+     /* do not paint an extra level for a line with a >From string at the
+      * begining of it
+      */
+     if (buf[0] && (strlen(buf) + strlen("From ") + 1 < NSTRING)){
+ 	i = strlen(buf);
+ 	if (strstr(line,(char *)strcat(buf,"From ")) == line)
+ 	    buf[i - 1] = '\0';
+ 	else
+ 	    buf[i] = '\0';
+     }
+     tmp_20k_buf[0] = '\0';
+     for (i = 0; buf[i] && (tmp_20k_buf[i] = buf[i]); i++);
+     tmp_20k_buf[i] = '\0';
+     return -1;
+ }
+ 
+ IVAL_S *
+ copy_ival(ival)
+   IVAL_S *ival;
+ {
+   IVAL_S *cp;
+ 
+   if (!ival)
+     return (IVAL_S *)NULL;
+ 
+   cp = (IVAL_S *) malloc (sizeof(IVAL_S));
+   memset (cp, 0, sizeof(IVAL_S));
+ 
+   cp->start = ival->start;
+   cp->end = ival->end;
+   cp->next = copy_ival(ival->next);
+   return cp;
+ }
+ 
+ void
+ interval_free(ival)
+   IVAL_S **ival;
+ {
+   if (!(*ival))
+     return;
+ 
+   if ((*ival)->next)
+     interval_free(&((*ival)->next));
+ 
+   (*ival)->next = (IVAL_S *) NULL;
+ 
+   free((void *)(*ival));
+   *ival = (IVAL_S *) NULL;
+ }
+ 
+ IVAL_S *
+ compute_interval (string, pattern, endm)
+  char *string;
+  char *pattern;
+  int endm;
+ {
+   IVAL_S *ival = NULL, *nextival= NULL;
+   int error, sizerror;
+   regex_t preg;
+   regmatch_t pmatch;
+ 
+   if (error = regcomp(&preg, pattern, REG_EXTENDED)){
+ /*  char message[REGERROR];
+       sizerror = regerror(error, &preg, message, REGERROR);
+       printf("%s\n", message);*/
+       regfree(&preg);
+       return (IVAL_S *) NULL;
+   }
+   else{
+     if (((error = regexec(&preg, string, 1, &pmatch, 0)) != REG_NOMATCH)
+  	&& !error){
+        ival = (IVAL_S *) malloc(sizeof(IVAL_S));
+        memset (ival, 0, sizeof(IVAL_S));
+        ival->start = endm + pmatch.rm_so;
+        ival->end   = endm + pmatch.rm_eo;
+        nextival = compute_interval(string+pmatch.rm_so+1, pattern, ival->start+1);
+        if (nextival){
+ 	   if (nextival->start <= ival->end){
+ 	      ival->end  = nextival->end;
+ 	      ival->next = copy_ival(nextival->next);
+ 	      interval_free(&nextival);
+ 	   }
+ 	   else
+ 	      ival->next = nextival;
+        }
+     }
+   }
+   regfree(&preg);
+   return ival;
+ }
+ 
+ char *
+ regex_pattern(plist)
+   char **plist;
+ {
+   int i = 0, j = 0, k = 0, n = 0, len = 0;
+   char *pattern = NULL;
+ 
+   if(plist && plist[0] && plist[0][0]){
+     for (i = 0; plist[i] && plist[i][0]; i++)
+ 	len += strlen(plist[i]) + 1;
+     pattern = (char *) fs_get(len * sizeof(char));
+     for (j = 0; j < i; j++){
+        for(k = 0; plist[j][k]; k++)
+ 	  pattern[n++] = plist[j][k];
+        pattern[n++] = (j == i - 1) ? '\0' : '|';
+     }
+   }
+   return pattern;
+ }
+ 
+ LT_INS_S **
+ insert_color_special_text(ins, p, ival, last_end, col)
+     LT_INS_S **ins;
+     char **p;
+     IVAL_S *ival;
+     int last_end;
+     COLOR_PAIR *col;
+ {
+    struct variable *vars = ps_global->vars;
+ 
+    if (ival){
+       *p += ival->start - last_end;
+       ins = gf_line_test_new_ins(ins, *p,  color_embed(col->fg, col->bg),
+ 				   (2 * RGBLEN) + 4);
+       *p += ival->end - ival->start;
+       ins = gf_line_test_new_ins(ins, *p, color_embed(VAR_NORM_FORE_COLOR,
+ 		      VAR_NORM_BACK_COLOR), (2 * RGBLEN) + 4);
+       ins = insert_color_special_text(ins, p, ival->next, ival->end, col);
+    }
+    return ins;
+ }  
+ 
+ int
+ length_color(p, begin_color)
+   char *p;
+   int  begin_color;
+ {
+   int len = 0, done = begin_color ? 0 : -1;
+   char *orig = p;
+ 
+   while (*p  && done <= 0){
+         switch(*p++){
+            case TAG_HANDLE :
+              p += *p + 1; 
+ 	     done++;
+            break;
+ 
+            case TAG_FGCOLOR :
+            case TAG_BGCOLOR :
+              p += RGBLEN;
+ 	     if (!begin_color)
+ 		done++;  
+            break;
+ 
+            default :
+              break;
+         }
+    }
+    len = p - orig;
+    return len;
+ }
+ 
+ int
+ any_color_in_string(p)
+   char *p;
+ {
+    int rv = 0;
+    char *orig = p;
+    while (*p && !rv)
+       if (*p++ == TAG_EMBED)
+ 	rv = p - orig;
+    return rv;
+ }
+ 
+ 
+ int
+ color_this_text(linenum, line, ins, local)
+     long       linenum;
+     char      *line;
+     LT_INS_S **ins;
+     void      *local;
+ {
+     struct variable *vars = ps_global->vars;
+     COLOR_PAIR *col = NULL;
+     char *p;
+     int i = 0;
+     static char *pattern = NULL;
+ /*    QSTRING_S  *qs;
+     char NLine[NSTRING] = {'\0'};
+     static char GLine[NSTRING] = {'\0'};
+     static char PLine[NSTRING] = {'\0'};
+     static char buf[NSTRING] = {'\0'};
+ 
+     if (linenum != 0){
+        for (i = 0; GLine[i] && (PLine[i] = GLine[i]); i++);
+        PLine[i] = '\0';
+     }
+ 
+     for (i = 0; tmp_20k_buf[i] && (tmp_20k_buf[i] != '\015') && (i < NSTRING)
+                 && (i < SIZEOF_20KBUF)
+                 && (NLine[i] = tmp_20k_buf[i]); i++);
+     NLine[i] = '\0';
+ 
+     for (i = 0; (i < NSTRING) && ((GLine[i] = line[i]) != '\0'); i++);
+     GLine[NSTRING - 1] = '\0';
+     qs = do_quote_match(prefix && *prefix ? prefix : ">",
+                                         GLine, NLine, PLine, 1);
+     flatten_qstring(qs, buf);
+     i = buf && buf[0] ? strlen(buf) : 0;
+     free_qs(&qs);
+ */
+     p = line + i;
+ 
+     if(VAR_SPECIAL_TEXT_FORE_COLOR && VAR_SPECIAL_TEXT_BACK_COLOR
+        && (col = new_color_pair(VAR_SPECIAL_TEXT_FORE_COLOR,
+                                 VAR_SPECIAL_TEXT_BACK_COLOR))
+        && !pico_is_good_colorpair(col))
+           free_color_pair(&col);
+ 
+     if (linenum == 0){
+        if (pattern)
+ 	  fs_give((void **)&pattern);
+        pattern = regex_pattern(ps_global->VAR_SPECIAL_TEXT);
+     }
+ 
+     if(pattern && col){
+        IVAL_S *ival;
+        int done = 0, begin_color = 0;
+ 
+         while (!done){
+            if (i = any_color_in_string(p)){
+ 	      begin_color = (begin_color + 1) % 2;
+ 	      if (begin_color){
+                  p[i - 1] = '\0';
+                  ival = compute_interval(p, pattern, 0);
+                  p[i - 1] = TAG_EMBED;
+ 	         ins = insert_color_special_text(ins, &p, ival, 0, col);
+ 	      }
+               for (;*p++ != TAG_EMBED; );
+               p += length_color(p, begin_color);
+            }
+            else{
+               ival = compute_interval(p, pattern, 0);
+ 	      ins = insert_color_special_text(ins, &p, ival, 0, col);
+ 	      done++;
+            }
+ 	   interval_free(&ival);
+            if (!*p)
+              done++;
+         }
+         free_color_pair(&col);
+     }
+ 
+     return 0;
+ }
+ 
  
  /*
   * Paint the signature.
***************
*** 3650,3676 ****
      void      *is_in_sig;
  {
      struct variable *vars = ps_global->vars;
!     int             *in_sig_block;
      COLOR_PAIR      *col = NULL;
  
      if(is_in_sig == NULL)
        return 0;
  
      in_sig_block = (int *) is_in_sig;
!     
!     if(!strcmp(line, SIGDASHES))
!       *in_sig_block = START_SIG_BLOCK; 
!     else if(*line == '\0')
        /* 
         * Suggested by Eduardo: allow for a blank line right after 
         * the sigdashes. 
         */
        *in_sig_block = (*in_sig_block == START_SIG_BLOCK)
  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
      else
!       *in_sig_block = (*in_sig_block != OUT_SIG_BLOCK)
  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
  
      if(*in_sig_block != OUT_SIG_BLOCK
         && VAR_SIGNATURE_FORE_COLOR && VAR_SIGNATURE_BACK_COLOR
         && (col = new_color_pair(VAR_SIGNATURE_FORE_COLOR,
--- 4151,4230 ----
      void      *is_in_sig;
  {
      struct variable *vars = ps_global->vars;
!     int             *in_sig_block, i, j,same_qstr = 0;
      COLOR_PAIR      *col = NULL;
+     static char GLine[NSTRING] = {'\0'};
+     static char PLine[NSTRING] = {'\0'};
+     char NLine[NSTRING] = {'\0'};
+     static char *buf, buf2[NSTRING] = {'\0'};
+     QSTRING_S *qs;
+     static qstrlen = 0;
  
      if(is_in_sig == NULL)
        return 0;
  
+     if (linenum != 0){
+        for (i = 0; GLine[i] && (PLine[i] = GLine[i]); i++);
+        PLine[i] = '\0';
+     }
+ 
+     for (i = 0; tmp_20k_buf[i] && (tmp_20k_buf[i] != '\015') && (i < NSTRING)
+ 		&& (i < SIZEOF_20KBUF)
+ 		&& (NLine[i] = tmp_20k_buf[i]); i++);
+     NLine[i] = '\0';
+ 
+     for (i = 0; (i < NSTRING) && ((GLine[i] = line[i]) != 0); i++);
+     GLine[NSTRING - 1] = '\0';
+     qs = do_quote_match(prefix && *prefix ? prefix : ">", 
+ 					GLine, NLine, PLine, 1); 
+     flatten_qstring(qs, buf2);
+     i = buf2 && buf2[0] ? strlen(buf2) : 0;
+     free_qs(&qs);
+ 
+     /* determine if buf and buf2 are the same quote string */
+     if (!struncmp(buf, buf2, qstrlen)){
+ 	for (j = qstrlen; buf2[j] && isspace((unsigned char)buf2[j]); j++);
+ 	if (!buf2[j] || buf2[j] == '|' || (buf2[j] == '*' && buf2[j+1] != '>'))
+ 	   same_qstr++;
+     }
+ 
      in_sig_block = (int *) is_in_sig;
! 
!     if (*in_sig_block != OUT_SIG_BLOCK){
! 	if (line && *line && (strlen(line) >= qstrlen) && same_qstr)
! 	   line += qstrlen;
!         else if (strlen(line) < qstrlen)
! 	   line += i;
! 	else if (!same_qstr)
! 	   *in_sig_block = OUT_SIG_BLOCK;
!     }
!     else
! 	line += i;
! 
!     if(!strcmp(line, SIGDASHES) || !strcmp(line, "--")){
!       *in_sig_block = START_SIG_BLOCK;
!        buf = (char *) fs_get((i + 1)*sizeof(char));
!        buf = cpystr(buf2);
!        qstrlen = i;
!     }
!     else if(*line == '\0'){
        /* 
         * Suggested by Eduardo: allow for a blank line right after 
         * the sigdashes. 
         */
        *in_sig_block = (*in_sig_block == START_SIG_BLOCK)
  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
+     }
      else
!          *in_sig_block = (*in_sig_block != OUT_SIG_BLOCK)
  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
  
+     if (*in_sig_block == OUT_SIG_BLOCK){
+ 	qstrlen = 0;	/* reset back in case there's another paragraph */
+ 	if (buf)
+ 	   fs_give((void **)&buf);
+     }
+ 
      if(*in_sig_block != OUT_SIG_BLOCK
         && VAR_SIGNATURE_FORE_COLOR && VAR_SIGNATURE_BACK_COLOR
         && (col = new_color_pair(VAR_SIGNATURE_FORE_COLOR,
***************
*** 4916,4922 ****
  	fs_give((void **) &urlp);
  
  	rflags = ROLE_COMPOSE;
! 	if(nonempty_patterns(rflags, &dummy)){
  	    role = set_role_from_msg(ps_global, rflags, -1L, NULL);
  	    if(confirm_role(rflags, &role))
  	      role = combine_inherited_role(role);
--- 5470,5476 ----
  	fs_give((void **) &urlp);
  
  	rflags = ROLE_COMPOSE;
! 	if(!(role = copy_action(role_chosen)) && nonempty_patterns(rflags, &dummy)){
  	    role = set_role_from_msg(ps_global, rflags, -1L, NULL);
  	    if(confirm_role(rflags, &role))
  	      role = combine_inherited_role(role);
***************
*** 4989,4994 ****
--- 5543,5549 ----
      
      free_redraft_pos(&redraft_pos);
      free_action(&role);
+     free_action(&role_chosen);
  
      return(rv);
  }
***************
*** 5561,5567 ****
      char       *err, *charset;
      int		filtcnt = 0, error_found = 0, column, wrapit;
      int         is_in_sig = OUT_SIG_BLOCK;
!     int         is_flowed_msg = 0;
      int         filt_only_c0 = 0;
      char       *parmval;
      CONV_TABLE *ct = NULL;
--- 6116,6122 ----
      char       *err, *charset;
      int		filtcnt = 0, error_found = 0, column, wrapit;
      int         is_in_sig = OUT_SIG_BLOCK;
!     int         is_flowed_msg = 0, add_me = 1;
      int         filt_only_c0 = 0;
      char       *parmval;
      CONV_TABLE *ct = NULL;
***************
*** 5638,5643 ****
--- 6193,6207 ----
  	    filters[filtcnt++].data = gf_line_test_opt(url_hilite, handlesp);
  	}
  
+ 	if((flags & FM_DISPLAY)
+ 	   && !(flags & FM_NOCOLOR)
+ 	   && pico_usingcolor()
+ 	   && VAR_SPECIAL_TEXT_FORE_COLOR
+ 	   && VAR_SPECIAL_TEXT_BACK_COLOR){
+ 	    filters[filtcnt].filter = gf_line_test;
+ 	    filters[filtcnt++].data = gf_line_test_opt(color_this_text, NULL);
+ 	}
+ 
  	/*
  	 * First, paint the signature.
  	 * Disclaimers noted below for coloring quotes apply here as well.
***************
*** 5665,5671 ****
  	   && pico_usingcolor()
  	   && VAR_QUOTE1_FORE_COLOR
  	   && VAR_QUOTE1_BACK_COLOR){
! 	    filters[filtcnt].filter = gf_line_test;
  	    filters[filtcnt++].data = gf_line_test_opt(color_a_quote,
  						       &is_flowed_msg);
  	}
--- 6229,6236 ----
  	   && pico_usingcolor()
  	   && VAR_QUOTE1_FORE_COLOR
  	   && VAR_QUOTE1_BACK_COLOR){
! 	    add_me = 0;
! 	    filters[filtcnt].filter = gf_quote_test;
  	    filters[filtcnt++].data = gf_line_test_opt(color_a_quote,
  						       &is_flowed_msg);
  	}
***************
*** 5704,5709 ****
--- 6269,6279 ----
  						    handlesp, opts);
      }
  
+     if (add_me){
+ 	filters[filtcnt].filter = gf_quote_test;
+ 	filters[filtcnt++].data = gf_line_test_opt(select_quote, NULL);
+     }
+ 
      if(wrapit && !(flags & FM_NOWRAP)){
  	int   margin = 0, wrapflags = (flags & FM_DISPLAY) ? GFW_HANDLES : 0;
  
***************
*** 6292,6300 ****
        format_addr_string(s, n, sect, "Return-Path: ", e->return_path,
  			 flags, pc);
  
!     if((which & FE_NEWSGROUPS) && e->newsgroups)
        format_newsgroup_string("Newsgroups: ", e->newsgroups, flags, pc);
  
      if((which & FE_FOLLOWUPTO) && e->followup_to)
        format_newsgroup_string("Followup-To: ", e->followup_to, flags, pc);
  
--- 6862,6883 ----
        format_addr_string(s, n, sect, "Return-Path: ", e->return_path,
  			 flags, pc);
  
!     if((which & FE_NEWSGROUPS) && e->newsgroups){
! 	int bogus = NIL;
        format_newsgroup_string("Newsgroups: ", e->newsgroups, flags, pc);
  
+        if(!e->ngbogus && e->message_id &&
+        strncmp (e->message_id,"<Pine.",6) &&
+        strncmp (e->message_id,"<MS-C.",6) &&
+        strncmp (e->message_id,"<MailManager.",13) &&
+        strncmp (e->message_id,"<EasyMail.",11) &&
+        strncmp (e->message_id,"<ML-",4)) bogus = T;
+ 
+ 	if(bogus)
+ 	  q_status_message(SM_ORDER, 0, 3,
+      "Unverified Newsgroup header -- Message MAY or MAY NOT have been posted");
+     }
+ 
      if((which & FE_FOLLOWUPTO) && e->followup_to)
        format_newsgroup_string("Followup-To: ", e->followup_to, flags, pc);
  
***************
*** 7021,7027 ****
  {
      register long    cur_top_line,  num_display_lines;
      int              result, done, ch, cmd, found_on, found_on_col,
! 		     first_view, force, scroll_lines, km_size,
  		     cursor_row, cursor_col, km_popped;
      long             jn;
      struct key_menu *km;
--- 7604,7610 ----
  {
      register long    cur_top_line,  num_display_lines;
      int              result, done, ch, cmd, found_on, found_on_col,
! 		     first_view, force, scroll_lines, km_size, skip = 0,
  		     cursor_row, cursor_col, km_popped;
      long             jn;
      struct key_menu *km;
***************
*** 7230,7235 ****
--- 7813,7820 ----
  	/*============ Check for New Mail and CheckPoint ============*/
          if(!sparms->quell_newmail &&
  	   new_mail(force, NM_TIMING(ch), NM_STATUS_MSG) >= 0){
+ 	    skip = 0;
+ 	    ps_global->force_check_now = 1;
  	    update_scroll_titlebar(cur_top_line, 1);
  	    if(ps_global->mangled_footer)
                draw_keymenu(km, bitmap, ps_global->ttyo->screen_cols,
***************
*** 7237,7242 ****
--- 7822,7841 ----
  
  	    ps_global->mangled_footer = 0;
  	}
+ 	ps_global->in_pico = 0;
+ 
+ 	if (!skip){
+ 	    ps_global->in_indx = !ps_global->in_fld_list;
+ 	    new_mail_incfolder(ps_global,MC_IFAUTOCHECK);
+ 	}
+ 	skip = 0;
+ 	if (ps_global->refresh_list > 0){
+ 	   ps_global->refresh_list = 0;
+ 	   if (ps_global->in_fld_list){
+ 	      cmd = MC_RESIZE;
+ 	      goto end;
+ 	   }
+ 	}
  
  	/*
  	 * If an expunge of the current message happened during the
***************
*** 7371,7376 ****
--- 7970,7976 ----
  	      break;
  	  }
  
+         ps_global->force_check_now = (((cmd == MC_NONE) || (cmd == MC_FORCECHECK)) ? 1 : 0);
  
  	/*============= Execute command =======================*/
  	switch(cmd){
***************
*** 8082,8087 ****
--- 8682,8733 ----
  	    print_to_printer(sparms);
  	    break;
  
+           case MC_NEXTHREAD:
+           case MC_PRETHREAD:
+              if (THREADING()){
+                 if (any_messages(ps_global->msgmap, NULL,
+                                         "to move to other thread"))
+                   move_thread(ps_global, ps_global->mail_stream, ps_global->msgmap,
+                                                 cmd == MC_NEXTHREAD ? 1 : -1);
+ 		  done = 1;
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 1,
+                          "Command available in threaded mode only");
+           break;
+ 
+           case MC_DELTHREAD:
+              if (THREADING()){
+                 if (any_messages(ps_global->msgmap, NULL, "to delete"))
+                     cmd_delete_thread(ps_global, ps_global->mail_stream, ps_global->msgmap);
+ 		done = 1;
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 1,
+                          "Command available in threaded mode only");
+           break;  
+                 
+           case MC_UNDTHREAD:
+              if (THREADING()){
+                 if (any_messages(ps_global->msgmap, NULL, "to undelete"))
+                     cmd_undelete_thread(ps_global, ps_global->mail_stream, ps_global->msgmap);
+ 		done = 1;
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 1,
+                          "Command available in threaded mode only");   
+           break;
+              
+           case MC_SELTHREAD:
+              if (THREADING()){
+                 if (any_messages(ps_global->msgmap, NULL, "to undelete"))
+                     cmd_select_thread(ps_global, ps_global->mail_stream, ps_global->msgmap);
+ 		done = 1;
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 1,
+                          "Command available in threaded mode only");
+           break;
  
  	    /* ------- First handle on Line ------ */
  	  case MC_GOTOBOL :
***************
*** 8114,8120 ****
--- 8760,8782 ----
  
              break;
  
+                 /*------- Check incoming folders -------*/
+            case MC_FORCECHECK:
+ 	      ps_global->force_check_now = 1;
+ 	      if (new_mail_incfolder(ps_global,MC_FORCECHECK) && 
+ 		   ps_global->refresh_list > 0){
+ 		ps_global->refresh_list = 0;
+ 		if (ps_global->in_fld_list){
+ 		   cmd = MC_RESIZE;
+ 		   goto end;
+ 		}
+ 	      }
+ 	     break;
  
+            case MC_TAB:
+ 		skip++;
+         /* do not check for new mail in inc fldrs and fall through */ 
+             
  	    /*------- Standard commands ------*/
            default:
  	    whereis_pos.row = 0;
***************
*** 8186,8191 ****
--- 8848,8854 ----
  
      } /* End of while() -- loop executing commands */
  
+ end:
      ps_global->redrawer	= NULL;	/* next statement makes this invalid! */
      zero_scroll_text();		/* very important to zero out on return!!! */
      scroll_state(SS_FREE);
***************
*** 8294,8301 ****
--- 8957,8966 ----
      char        prompt[MAX_SEARCH+50], nsearch_string[MAX_SEARCH+1];
      HelpType	help;
      int         rc, flags;
+     static char last_search_string[MAX_SEARCH+1] = { '\0' };
      static char search_string[MAX_SEARCH+1] = { '\0' };
      static ESCKEY_S word_search_key[] = { { 0, 0, "", "" },
+ 					 {ctrl('N'),  9, "^N", "Ins Pat"},
  					 {ctrl('Y'), 10, "^Y", "First Line"},
  					 {ctrl('V'), 11, "^V", "Last Line"},
  					 {-1, 0, NULL, NULL}
***************
*** 8317,8322 ****
--- 8982,8990 ----
              help = help == NO_HELP ? h_oe_searchview : NO_HELP;
              continue;
          }
+ 	else if(rc == 9)
+ 	    insert_pattern_in_string(nsearch_string, last_search_string,
+ 						     MAX_SEARCH);
  	else if(rc == 10){
  	    strcpy(report, "Searched to First Line.");
  	    return(-4);
***************
*** 8326,8332 ****
  	    return(-5);
  	}
  
!         if(rc != 4)
            break;
      }
  
--- 8994,9000 ----
  	    return(-5);
  	}
  
!         if(rc != 4 && rc != 9)
            break;
      }
  
***************
*** 8338,8343 ****
--- 9006,9014 ----
  	search_string[sizeof(search_string)-1] = '\0';
      }
  
+     strncpy(last_search_string, nsearch_string, sizeof(last_search_string));
+     last_search_string[sizeof(last_search_string)-1] = '\0';
+ 
      rc = search_scroll_text(start_line, start_col, search_string, cursor_pos,
  			    offset_in_line);
      return(rc);
diff -rc pine4.61/pine/newmail.c pine4.61.I.USE/pine/newmail.c
*** pine4.61/pine/newmail.c	Wed Jul 14 11:17:12 2004
--- pine4.61.I.USE/pine/newmail.c	Tue Aug  3 10:59:08 2004
***************
*** 48,53 ****
--- 48,55 ----
  
  #include "headers.h"
  
+ static long incoming_folders_new_mail  = 0L;
+ 
  
  /*
   * Internal prototypes
***************
*** 682,687 ****
--- 684,690 ----
  				"subject:"
      };
  
+     ps_global->refresh_list += 1;	/* Force update in folder screen */
      if(stream)
        e = pine_mail_fetchstructure(stream, max_num, NULL);
  
***************
*** 1056,1061 ****
--- 1059,1069 ----
  	if(m && sp_flagged(m, SP_LOCKED))
  	  sp_set_mail_since_cmd(m, 0L);
      }
+ 
+     if (incoming_folders_new_mail > 0L){
+ 	icon_text(NULL, IT_NEWMAIL);
+ 	incoming_folders_new_mail = 0L;
+     }
  }
  
  
***************
*** 1124,1126 ****
--- 1132,1475 ----
  
      return(rv);
  }
+ 
+ /*  Check for new mail in incoming folders */
+ 
+ int 
+ new_mail_incfolder(state,command)
+    struct pine *state;
+    int command;
+ {
+  char **listflds = NULL, **listnflds= NULL;
+  char *fldslctd  = NULL, *message   = NULL, *message2  = NULL;
+  int  *selfld    = NULL;
+  int   index = 0, i, nflds = 0, tflds, tlflds = 0, newflds = 0, save_state;
+  static time_t now, old = 0;
+  static int check_started = 0;
+  int  tcp_query_timeout = state->tcp_query_timeout;
+  int  tcp_open_timeout = 30;
+  int  long_report = F_OFF(F_ENABLE_FAST_RECENT, state);
+  FOLDER_S *inc_fld;
+  char  mailbox_name[MAXPATH+1];
+ 
+    if (F_OFF(F_ENABLE_INCOMING,ps_global) 
+ 	|| F_OFF(F_ENABLE_INCOMING_CHECK,ps_global)
+ 	|| (state->inc_check_rule == IC_MAN
+ 		&& command != MC_FORCECHECK)
+ 	|| (state->inc_check_rule == IC_MAN_AUTO
+ 		&& check_started == 0 && command != MC_FORCECHECK))
+       return -1;
+ 
+    if ((!state->force_check_now) || (state->checking_incfld)){
+        state->force_check_now = 1;      /* I'll be back, but wait a moment */
+         return -1;
+    }
+ 
+    now = time(0);
+    if ((old != 0) && (command != MC_FORCECHECK) && 
+       (state->refresh_list == 0) &&
+       (now - old < timeo*state->delay))
+ 	return -1;
+ 
+    state->checking_incfld = 1;		/* point of no return */
+    check_started = 1;			/* checks have already started */
+    ps_global->mm_log_error = 0;		/* turn off display of errors */
+    ps_global->noshow_error = 1;
+ 
+    if(state->VAR_TCPOPENTIMEO)
+       (void)SVAR_TCP_OPEN(state, tcp_open_timeout, tmp_20k_buf);
+    mail_parameters(NULL, SET_OPENTIMEOUT, (void *)(long)state->incfld_timeout);
+ 
+    save_state = ps_global->in_init_seq;
+    state->in_init_seq = 0;  /* force output of cue during check */
+    check_cue_display("+");      /* Show something to indicate delay */
+    MoveCursor(state->ttyo->screen_rows -FOOTER_ROWS(state),0);
+    fflush(stdout);
+    state->tcp_query_timeout = state->incfld_timeout;
+ 
+    if(state->context_current){
+      char	*nxtfld = NULL;
+      MAILSTREAM *nxtstrm = NULL;
+      long        rec, tot;
+      int	 opstrm;
+      CONTEXT_S  *ctxt = sp_context(sp_inbox_stream());
+ 
+     /* Look for the Incoming folder collections, Normally the incoming folders
+      * collection is the first collection, but just to be sure, we back up to
+      * the beginning and go forward from there to try to find it.
+      */
+ 
+      if (!ctxt){
+ 	ctxt =  state->context_current;
+ 	while (1){
+ 	  if (ctxt->prev)
+ 	     ctxt = ctxt->prev;
+ 	  else
+ 	     break;
+ 	}
+ 	while (1){
+ 	  if (ctxt->use & CNTXT_INCMNG)
+ 	     break;
+ 	  else
+ 	     ctxt = ctxt->next;
+ 	}
+      }
+ 
+      tflds    = folder_total(FOLDERS(ctxt));
+      listflds = (char **) fs_get((tflds + 2) * sizeof(char *));
+      listnflds= (char **) fs_get((tflds + 2) * sizeof(char *));
+      selfld   = (int   *) fs_get((tflds + 2) * sizeof(int));
+ 
+      memset((void *)(selfld), 0, (tflds + 2) * sizeof(int));
+      memset((void *)(listflds), 0, (tflds + 2) * sizeof(char *));
+      memset((void *)(listnflds), 0, (tflds + 2) * sizeof(int *));
+ 
+      nxtfld = (char *) fs_get((strlen(state->inbox_name) + 1)*sizeof(char));
+      nxtfld = cpystr(state->inbox_name);
+ 
+      for(index = folder_index(nxtfld, ctxt, FI_FOLDER) + long_report ? 0 : 1;
+ 	index >= (long_report ? 0 : 1) && index < tflds
+         && (inc_fld = folder_entry(index, FOLDERS(ctxt)))
+         && !inc_fld->isdir; index++){
+ 
+ 	if (nxtfld)
+ 	   fs_give((void **)&nxtfld);
+ 
+         nxtfld = (char *) fs_get((strlen(FLDR_NAME(inc_fld)) + 1)*sizeof(char));
+         nxtfld = cpystr(FLDR_NAME(inc_fld));
+ 
+ 	fldslctd = next_folder_check(&nxtstrm, ctxt, &rec, &tot, inc_fld,
+ 								 &opstrm);
+ 
+ 	if ((opstrm && (rec != inc_fld->origrecent || tot != inc_fld->messages))
+ 	   || (!opstrm && (rec != inc_fld->recent || tot != inc_fld->messages)))
+ 	  state->refresh_list++;
+ 
+ 	inc_fld->countrecent = rec > inc_fld->origrecent
+ 					? rec - inc_fld->origrecent : 0;
+ 	inc_fld->messages    = tot;
+ 	inc_fld->recent      = rec;
+ 
+ 	if (long_report && inc_fld->countrecent == 0L && fldslctd)
+ 	     fs_give((void **)&fldslctd);
+ 
+         if (fldslctd){
+ 	   state->refresh_list += inc_fld->selected ? 0 : 1;
+ 	   inc_fld->selected = 1;
+ 	   inc_fld->notified = 0;	/* reset */
+ 	   if (strcmp(fldslctd, state->inbox_name)){
+ 		listflds[++nflds] = (char *) 
+ 			 fs_get((strlen(fldslctd) + 5) * sizeof(char *));
+ 		listflds[nflds] = cpystr(fldslctd);
+ 		tlflds += strlen(nxtfld) + 4; /* 1 space, 2 quotes, 1 comma */
+ 		selfld[nflds] = index;
+ 	   }
+ 	   fs_give((void **)&fldslctd);
+         }
+ 	else{
+ 	   if (inc_fld->selected)
+ 	     state->refresh_list += inc_fld->user_selected ? 0 : 1;
+ 	   if (folder_in_message_list(FLDR_NAME(inc_fld)))
+ 	     inc_fld->selected    = inc_fld->user_selected ? 1 : 0;
+ 	}
+      }
+      if (nxtfld)
+ 	fs_give((void **)&nxtfld);
+ 
+      state->mm_log_error = 0;	/* turn display of errors back on */
+      state->noshow_error = 1;
+ 
+      if(nflds == 0){
+         if (command == MC_FORCECHECK && state->VAR_INCOMING_FOLDERS_CHECK)
+ 	   q_status_message(SM_ORDER, 0, 2,
+                    "There are NO new messages in your Incoming Folders");
+         if (state->last_message)
+            fs_give((void **)&(state->last_message));
+      }
+      else{  /* nflds > 0 */
+ 	message = (char *) fs_get((tlflds + 30)*sizeof(char));	\
+ 	strcpy(message,"New message in folder");
+ 	if (!state->last_message)
+ 	   state->last_message = cpystr(message);
+ 	strcat(message,(nflds > 1) ? "s " : " ");
+ 	if(nflds > 1){
+            for (i = 1; i <= nflds - 2; i++){
+ 	     strcat(message,"\"");
+              strcat(message,listflds[i]);
+ 	     strcat(message,"\", ");
+              if (!folder_in_message_list(listflds[i])){
+                 listnflds[++newflds] = (char *)
+                          fs_get((strlen(listflds[i]) + 1)*sizeof(char));
+                 listnflds[newflds] = cpystr(listflds[i]);
+              }
+ 	   }
+            strcat(message,"\"");
+            strcat(message,listflds[nflds - 1]);
+            strcat(message,"\" and \"");
+            strcat(message,listflds[nflds]);
+            strcat(message,"\"");
+            if (!folder_in_message_list(listflds[nflds-1])){
+               listnflds[++newflds] = (char *)
+                            fs_get((strlen(listflds[nflds-1]) + 1)*sizeof(char));
+               listnflds[newflds] = cpystr(listflds[nflds-1]);
+            }
+            if (!folder_in_message_list(listflds[nflds])){
+               listnflds[++newflds] = (char *)
+                            fs_get((strlen(listflds[nflds]) + 1)*sizeof(char));
+               listnflds[newflds] = cpystr(listflds[nflds]);
+            }
+ 	} 
+ 	else{
+           strcat(message,"\"");
+           strcat(message,listflds[1]);
+           strcat(message,"\"");
+           if (!folder_in_message_list(listflds[1])){
+             listnflds[++newflds] = (char *)
+                          fs_get((strlen(listflds[1]) + 1) * sizeof(char));
+             listnflds[newflds] = cpystr(listflds[1]);
+           }
+         }
+         if (newflds){
+ 	   state->refresh_list += 1;
+            message2 = (char *) malloc((tlflds + 30)*sizeof(char));
+            strcpy(message2,"New message in folder");
+            strcat(message2,(newflds > 1) ? "s " : " ");
+ 	   if (newflds > 1){
+ 	      for (i = 1; i <= newflds - 2; i++){
+                   strcat(message2,"\"");
+                   strcat(message2,listnflds[i]);
+                   strcat(message2,"\", ");
+ 	      }
+               strcat(message2,"\"");
+               strcat(message2,listnflds[newflds - 1]);
+               strcat(message2,"\" and \"");
+               strcat(message2,listnflds[newflds]);
+               strcat(message2,"\"");
+ 
+ 	   } 
+ 	   else{
+              strcat(message2,"\"");
+              strcat(message2,listnflds[1]);
+              strcat(message2,"\"");
+ 	   }
+         }
+         state->last_message = cpystr(message);
+         /* decide if we are going to use "message" or "message2" */
+         if (newflds && (newflds != nflds) && (command != MC_FORCECHECK)){
+ 	  if (message)
+ 	    fs_give((void **)&message);
+ 	  message = cpystr(message2);
+         }
+         if ((newflds > 0  && 
+ 	    (!folder_in_message_list(state->cur_folder) || !state->in_indx)) 
+ 	   || (command == MC_FORCECHECK)){
+           if (strlen(message) < state->ttyo->screen_cols - 2){
+              if (command != MC_FORCECHECK){
+                 q_status_message(SM_ASYNC | SM_DING, 0, 60, message);
+                 icon_text(message, IT_NEWMAIL);
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 2, message);
+           }
+           else{
+ 	     message = (char *) fs_get (80 * sizeof(char));
+              message = cpystr("You have NEW messages in your Incoming Folders");
+              if (strlen(message) < state->ttyo->screen_cols - 2){
+                if (command != MC_FORCECHECK){
+                   q_status_message(SM_ASYNC | SM_DING, 0, 60, message);
+                   icon_text(message, IT_NEWMAIL);
+                }
+                else
+                   q_status_message(SM_ORDER, 0, 2, message);
+              }
+           }
+         }
+         if (message)
+ 	   fs_give((void **)&message);
+ 	if (message2)
+ 	   fs_give((void **)&message2);
+      } /* end of nflds > 0 */
+    }
+    state->checking_incfld = 0;
+    check_cue_display(" ");		/* Erase the "+" added before */  
+    state->in_init_seq = save_state;	/* restore original value     */
+    MoveCursor(state->ttyo->screen_rows -FOOTER_ROWS(state),0);
+    incoming_folders_new_mail = nflds;
+ 
+    if (listflds){
+       for (i = 0; i < nflds && listflds[i]; i++);
+ 	fs_give((void **)&listflds[i]);
+       fs_give((void **)listflds);
+     }
+    if (listnflds){
+       for (i = 0; i < newflds && listnflds[i]; i++);
+ 	fs_give((void **)&listnflds[i]);
+       fs_give((void **)listnflds);
+    }
+    if (selfld)
+      fs_give((void **)&selfld);
+    old = time(0);
+    state->delay = time(0) - now + 1;
+    state->tcp_query_timeout = tcp_query_timeout;
+    mail_parameters(NULL, SET_OPENTIMEOUT, (void *)(long)tcp_open_timeout);
+ 
+    return nflds;
+ }
+ 
+ char *
+ folder_in_list(folder)
+ char *folder;
+ {   
+  int length = strlen(folder) + 4;
+  char *result;
+  int i;
+  
+     result = (char *) fs_get((length)*sizeof(char));
+             
+     result[0] = ' '; /* a space */
+     result[1] = '\"'; /* quotes */
+     for (i = 0; i < strlen(folder); i++)
+        result[i+2] = folder[i];   
+     result[length - 2] = '\"';
+     result[length - 1] = '\0';
+  return  result;
+ }
+ 
+ 
+ int
+ folder_in_message_list(folder)
+ char *folder;
+ {
+ int rv = 0;
+ char *folderquoted = folder_in_list(folder);
+ 
+   if (ps_global->last_message && *ps_global->last_message
+         && strstr(ps_global->last_message, folderquoted))
+      rv++;
+   if (folderquoted)
+      fs_give((void **)&folderquoted);
+  return rv;
+ }
+ 
+ char *
+ new_mail_in_open_stream(stream, rec, tot)
+   MAILSTREAM *stream;
+   long *rec;
+   long *tot;
+ {
+    long excluded;
+ 
+    if((excluded = any_lflagged(sp_msgmap(stream), MN_EXLD))){
+       *tot = stream->nmsgs - excluded;
+       if(tot)
+          *rec = count_flagged(stream, F_RECENT);
+       else
+          *rec = 0L;
+    }
+    else{
+       *tot = stream->nmsgs;
+       *rec = stream->recent;
+    }
+ 
+    return *rec ? cpystr(STREAMNAME(stream)) : NULL;
+ }
diff -rc pine4.61/pine/osdep/os-cyg.h pine4.61.I.USE/pine/osdep/os-cyg.h
*** pine4.61/pine/osdep/os-cyg.h	Fri May 23 09:06:59 2003
--- pine4.61.I.USE/pine/osdep/os-cyg.h	Thu Sep 16 22:24:21 2004
***************
*** 1,299 ****
! /*----------------------------------------------------------------------
!   $Id: os-cyg.h,v 1.3 2003/05/23 16:05:21 hubert Exp $
! 
!             T H E    P I N E    M A I L   S Y S T E M
! 
!    Laurence Lundblade and Mike Seibel
!    Networks and Distributed Computing
!    Computing and Communications
!    University of Washington
!    Administration Builiding, AG-44
!    Seattle, Washington, 98195, USA
!    Internet: lgl@CAC.Washington.EDU
!              mikes@CAC.Washington.EDU
! 
!    Please address all bugs and comments to "pine-bugs@cac.washington.edu"
! 
! 
!    Pine and Pico are registered trademarks of the University of Washington.
!    No commercial use of these trademarks may be made without prior written
!    permission of the University of Washington.
! 
!    Pine, Pico, and Pilot software and its included text are Copyright
!    1989-1998 by the University of Washington.
! 
!    The full text of our legal notices is contained in the file called
!    CPYRIGHT, included with this distribution.
! 
! 
!    Pine is in part based on The Elm Mail System:
!     ***********************************************************************
!     *  The Elm Mail System  -  Revision: 2.13                             *
!     *                                                                     *
!     * 			Copyright (c) 1986, 1987 Dave Taylor              *
!     * 			Copyright (c) 1988, 1989 USENET Community Trust   *
!     ***********************************************************************
!  
! 
!   ----------------------------------------------------------------------*/
! 
! #ifndef _OS_INCLUDED
! #define _OS_INCLUDED
! 
! #include "../c-client/osdep.h"
! 
! 
! /*----------------------------------------------------------------------
! 
!    This first section has some constants that you may want to change
!    for your configuration.  This is the Linux 0.99.10 version of the os.h file.
!    Further down in the file are os-dependent things that need to be set up
!    correctly for each os.  They aren't interesting, they just have to be
!    right.  There are also a few constants down there that may be of
!    interest to some.
! 
!  ----*/
! 
! /*----------------------------------------------------------------------
!    Define this if you want the disk quota to be checked on startup.
!    Of course, this only makes sense if your system has quotas.  If it doesn't,
!    there should be a dummy disk_quota() routine in os-xxx.c so that defining
!    this won't be harmful anyway.
!  ----*/
! /* #define USE_QUOTAS */
! 
! 
! 
! /*----------------------------------------------------------------------
!    Define this if you want to be sure to not allow users to change their
!    From header line when they send out mail. Even if you don't define
!    this the default is to not allow From to be changed. The user would have
!    to edit (by hand) "allow-changing-from" into their .pinerc feature list
!    or the sys-admin would have to include it in the default feature-list.
!    Even after that, the user still has to include it in either their
!    default-composer-hdrs or customized-hdrs to get at it. Instead of
!    defining NEVER_ALLOW_CHANGING_FROM, an easier way of preventing From
!    changing is to put the feature "no-allow-changing-from" in the
!    /usr/local/lib/pine.conf.fixed file.
!  ----*/
! /* #define NEVER_ALLOW_CHANGING_FROM */
! 
! 
! 
! /*----------------------------------------------------------------------
!    Define this if you want to allow users to turn on the feature that
!    enables sending to take place in a fork()'d child.  This may reduce
!    the time on the user's wall clock it takes to post mail.
!    NOTE: You'll also have to make sure the appropriate osdep/postreap.*
!          file is included in the os-*.ic file for your system.
!  ----*/
! #define BACKGROUND_POST
! 
! 
! 
! /*----------------------------------------------------------------------
!     Turn this on if you want to disable the keyboard lock function.
!  ----*/
! /* #define NO_KEYBOARD_LOCK */
! 
! 
! 
! /*----------------------------------------------------------------------
!     Turn this on to trigger QP encoding of sent message text if it contains
!   "From " at the beginning of a line or "." on a line by itself.
!  ----*/
! /* #define ENCODE_FROMS */
! 
! 
! 
! /*----------------------------------------------------------------------
!     Timeouts (seconds)
!  ----*/
! #ifndef DF_MAILCHECK
! #define DF_MAILCHECK      "150" /* How often to check for new mail, by
! 				   default.  There's some expense in doing
! 				   this so it shouldn't be done too
! 				   frequently.  (Can be set in config
! 				   file now.)  */
! #endif
! 
! /*----------------------------------------------------------------------
!     Check pointing (seconds)
!  ----*/
! #define CHECK_POINT_TIME (7*60) /* Check point the mail file (write changes
! 				   to disk) if more than CHECK_POINT_TIME
! 				   seconds have passed since the first
! 				   change was made.  Depending on what is
! 				   happening, we may wait up to three times
! 				   this long, since we don't want to do the
! 				   slow check pointing and irritate the user. */
!                                      
! #define CHECK_POINT_FREQ   (12) /* Check point the mail file if there have been
!                                    at least this many (status) changes to the
! 				   current mail file.  We may wait longer if
! 				   it isn't a good time to do the checkpoint. */
! 
! 
! 
! /*----------------------------------------------------------------------
!  In scrolling through text, the number of lines from the previous
!  screen to overlap when showing the next screen.  Usually set to two.
!  ----*/
! #define	DF_OVERLAP	"2"
! 
! 
! 
! /*----------------------------------------------------------------------
!  When scrolling screens, the number of lines from top and bottom of
!  the screen to initiate single-line scrolling.
!  ----*/
! #define	DF_MARGIN	"0"
! 
! 
! 
! /*----------------------------------------------------------------------
!  Default fill column for pine composer and maximum fill column.  The max
!  is used to stop people from setting their custom fill column higher than
!  that number.  Note that DF_FILLCOL is a string but MAX_FILLCOL is an integer.
!  ----*/
! #define	DF_FILLCOL	"74"
! #define	MAX_FILLCOL	80
! 
! 
! 
! /*----- System-wide config file ----------------------------------------*/
! #ifndef SYSTEM_PINERC
! #define SYSTEM_PINERC             "/usr/local/lib/pine.conf"
! #endif
! #ifndef SYSTEM_PINERC_FIXED
! #define SYSTEM_PINERC_FIXED       "/usr/local/lib/pine.conf.fixed"
! #endif
! 
! 
! 
! /*----------------------------------------------------------------------
!    The default folder names and folder directories (some for backwards
!    compatibility).  Think hard before changing any of these.
!  ----*/
! #define DF_DEFAULT_FCC            "sent-mail"
! #define DEFAULT_SAVE              "saved-messages"
! #define POSTPONED_MAIL            "postponed-mail"
! #define POSTPONED_MSGS            "postponed-msgs"
! #define INTERRUPTED_MAIL          ".pine-interrupted-mail"
! #define DEADLETTER                "dead.letter"
! #define DF_MAIL_DIRECTORY         "mail"
! #define INBOX_NAME                "INBOX"
! #define DF_SIGNATURE_FILE         ".signature"
! #define DF_ELM_STYLE_SAVE         "no"
! #define DF_HEADER_IN_REPLY        "no"
! #define DF_OLD_STYLE_REPLY        "no"
! #define DF_USE_ONLY_DOMAIN_NAME   "no"
! #define DF_FEATURE_LEVEL          "sapling"
! #define DF_SAVE_BY_SENDER         "no"
! #define DF_SORT_KEY               "arrival"
! #define DF_AB_SORT_RULE           "fullname-with-lists-last"
! #define DF_FLD_SORT_RULE          "alphabetical"
! #define DF_SAVED_MSG_NAME_RULE    "default-folder"
! #define DF_FCC_RULE               "default-fcc"
! #define DF_STANDARD_PRINTER       "lpr"
! #define ANSI_PRINTER              "attached-to-ansi"
! #define DF_ADDRESSBOOK            ".addressbook"
! #define DF_BUGS_FULLNAME          "Pine Developers"
! #define DF_BUGS_ADDRESS           "pine-bugs@cac.washington.edu"
! #define DF_SUGGEST_FULLNAME       "Pine Developers"
! #define DF_SUGGEST_ADDRESS        "pine-suggestions@cac.washington.edu"
! #define DF_PINEINFO_FULLNAME      "Pine-Info News Group"
! #define DF_PINEINFO_ADDRESS       "pine-info@cac.washington.edu"
! #define DF_LOCAL_FULLNAME         "Local Support"
! #define DF_LOCAL_ADDRESS          "postmaster"
! #define DF_KBLOCK_PASSWD_COUNT    "1"
! #define DF_REMOTE_ABOOK_HISTORY   "3"
! 
! /*----------------------------------------------------------------------
!    The default printer when pine starts up for the first time with no printer
!  ----*/
! #define DF_DEFAULT_PRINTER        ANSI_PRINTER
! 
! 
! 
! /*----- The usual sendmail configuration for sending mail on Unix ------*/
! #ifndef SENDMAIL
! #define SENDMAIL	"/usr/sbin/sendmail"
! #endif
! #ifndef SENDMAILFLAGS
! #define SENDMAILFLAGS	"-bs -odb -oem"	/* send via smtp with backgroud
! 					   delivery and mail back errors */
! #endif
! 
! 
! /*----------------------------------------------------------------------
!    If no nntp-servers are defined, this program will be used to post news.
!  ----*/
! /* #define SENDNEWS	"/usr/local/bin/inews -h" */
! 
! 
! /*--------- Program employed by users to change their password ---------*/
! #ifndef	PASSWD_PROG
! #define	PASSWD_PROG	"/bin/passwd"
! #endif
! 
! 
! /*-------------- A couple constants used to size arrays ----------------*/
! #include <sys/param.h>          /* Get it from param.h if available */
! #undef MAXPATH                  /* Sometimes defined in param.h differently */
! #define MAXPATH MAXPATHLEN      /* Longest pathname we ever expect */
! /* #define MAXPATH        (512) */ /* Longest pathname we ever expect */
! #define MAXFOLDER      (64)     /* Longest foldername we ever expect */  
! 
! 
! /*-- Max screen pine will display on. Used to define some array sizes --*/
! #define MAX_SCREEN_COLS  (170) 
! #define MAX_SCREEN_ROWS  (200) 
! 
! 
! /*----------------------------------------------------------------------
!     Where to put the output of pine in debug mode. Files are created
!  in the user's home directory and have a number appended to them when
!  there is more than one.
!  ----*/
! #define DEBUGFILE	".pine-debug"
! 
! /*----------------------------------------------------------------------
!     The number of debug files to save in the user's home diretory. The files
!  are useful for figuring out what a user did when he complains that something
!  went wrong. It's important to keep a bunch around, usually 4, so that the
!  debug file in question will still be around when the problem gets 
!  investigated. Users tend to go in and out of Pine a few times and there
!  is one file for each pine invocation
!  ----*/
! #define NUMDEBUGFILES 4
! 
! /*----------------------------------------------------------------------
!    The default debug level to set (approximate meanings):
!        1 logs only highest level events and errors
!        2 logs events like file writes
!        3
!        4 logs each command
!        5
!        6 
!        7 logs details of command execution (7 is highest to run any production)
!        8
!        9 logs gross details of command execution
!  ----*/
! #define DEFAULT_DEBUG 2
! 
! 
! 
! /*----------------------------------------------------------------------
!     Various maximum field lengths, probably shouldn't be changed.
!  ----*/
! #define MAX_FULLNAME     (100) 
! #define MAX_NICKNAME      (80)
! #define MAX_ADDRESS      (500)
! #define MAX_NEW_LIST     (500)  /* Max addrs to be added when creating list */
! #define MAX_SEARCH       (100)  /* Longest string to search for             */
! #define MAX_ADDR_EXPN   (1000)  /* Longest expanded addr                    */
! #define MAX_ADDR_FIELD (10000)  /* Longest fully-expanded addr field        */
! 
! 
! #endif /* _OS_INCLUDED */
--- 1,299 ----
! /*----------------------------------------------------------------------
!   $Id: os-cyg.h,v 1.3 2003/05/23 16:05:21 hubert Exp $
! 
!             T H E    P I N E    M A I L   S Y S T E M
! 
!    Laurence Lundblade and Mike Seibel
!    Networks and Distributed Computing
!    Computing and Communications
!    University of Washington
!    Administration Builiding, AG-44
!    Seattle, Washington, 98195, USA
!    Internet: lgl@CAC.Washington.EDU
!              mikes@CAC.Washington.EDU
! 
!    Please address all bugs and comments to "pine-bugs@cac.washington.edu"
! 
! 
!    Pine and Pico are registered trademarks of the University of Washington.
!    No commercial use of these trademarks may be made without prior written
!    permission of the University of Washington.
! 
!    Pine, Pico, and Pilot software and its included text are Copyright
!    1989-1998 by the University of Washington.
! 
!    The full text of our legal notices is contained in the file called
!    CPYRIGHT, included with this distribution.
! 
! 
!    Pine is in part based on The Elm Mail System:
!     ***********************************************************************
!     *  The Elm Mail System  -  Revision: 2.13                             *
!     *                                                                     *
!     * 			Copyright (c) 1986, 1987 Dave Taylor              *
!     * 			Copyright (c) 1988, 1989 USENET Community Trust   *
!     ***********************************************************************
!  
! 
!   ----------------------------------------------------------------------*/
! 
! #ifndef _OS_INCLUDED
! #define _OS_INCLUDED
! 
! #include "../c-client/osdep.h"
! 
! 
! /*----------------------------------------------------------------------
! 
!    This first section has some constants that you may want to change
!    for your configuration.  This is the Linux 0.99.10 version of the os.h file.
!    Further down in the file are os-dependent things that need to be set up
!    correctly for each os.  They aren't interesting, they just have to be
!    right.  There are also a few constants down there that may be of
!    interest to some.
! 
!  ----*/
! 
! /*----------------------------------------------------------------------
!    Define this if you want the disk quota to be checked on startup.
!    Of course, this only makes sense if your system has quotas.  If it doesn't,
!    there should be a dummy disk_quota() routine in os-xxx.c so that defining
!    this won't be harmful anyway.
!  ----*/
! /* #define USE_QUOTAS */
! 
! 
! 
! /*----------------------------------------------------------------------
!    Define this if you want to be sure to not allow users to change their
!    From header line when they send out mail. Even if you don't define
!    this the default is to not allow From to be changed. The user would have
!    to edit (by hand) "allow-changing-from" into their .pinerc feature list
!    or the sys-admin would have to include it in the default feature-list.
!    Even after that, the user still has to include it in either their
!    default-composer-hdrs or customized-hdrs to get at it. Instead of
!    defining NEVER_ALLOW_CHANGING_FROM, an easier way of preventing From
!    changing is to put the feature "no-allow-changing-from" in the
!    /usr/local/lib/pine.conf.fixed file.
!  ----*/
! /* #define NEVER_ALLOW_CHANGING_FROM */
! 
! 
! 
! /*----------------------------------------------------------------------
!    Define this if you want to allow users to turn on the feature that
!    enables sending to take place in a fork()'d child.  This may reduce
!    the time on the user's wall clock it takes to post mail.
!    NOTE: You'll also have to make sure the appropriate osdep/postreap.*
!          file is included in the os-*.ic file for your system.
!  ----*/
! #define BACKGROUND_POST
! 
! 
! 
! /*----------------------------------------------------------------------
!     Turn this on if you want to disable the keyboard lock function.
!  ----*/
! /* #define NO_KEYBOARD_LOCK */
! 
! 
! 
! /*----------------------------------------------------------------------
!     Turn this on to trigger QP encoding of sent message text if it contains
!   "From " at the beginning of a line or "." on a line by itself.
!  ----*/
! /* #define ENCODE_FROMS */
! 
! 
! 
! /*----------------------------------------------------------------------
!     Timeouts (seconds)
!  ----*/
! #ifndef DF_MAILCHECK
! #define DF_MAILCHECK      "150" /* How often to check for new mail, by
! 				   default.  There's some expense in doing
! 				   this so it shouldn't be done too
! 				   frequently.  (Can be set in config
! 				   file now.)  */
! #endif
! 
! /*----------------------------------------------------------------------
!     Check pointing (seconds)
!  ----*/
! #define CHECK_POINT_TIME (7*60) /* Check point the mail file (write changes
! 				   to disk) if more than CHECK_POINT_TIME
! 				   seconds have passed since the first
! 				   change was made.  Depending on what is
! 				   happening, we may wait up to three times
! 				   this long, since we don't want to do the
! 				   slow check pointing and irritate the user. */
!                                      
! #define CHECK_POINT_FREQ   (12) /* Check point the mail file if there have been
!                                    at least this many (status) changes to the
! 				   current mail file.  We may wait longer if
! 				   it isn't a good time to do the checkpoint. */
! 
! 
! 
! /*----------------------------------------------------------------------
!  In scrolling through text, the number of lines from the previous
!  screen to overlap when showing the next screen.  Usually set to two.
!  ----*/
! #define	DF_OVERLAP	"2"
! 
! 
! 
! /*----------------------------------------------------------------------
!  When scrolling screens, the number of lines from top and bottom of
!  the screen to initiate single-line scrolling.
!  ----*/
! #define	DF_MARGIN	"0"
! 
! 
! 
! /*----------------------------------------------------------------------
!  Default fill column for pine composer and maximum fill column.  The max
!  is used to stop people from setting their custom fill column higher than
!  that number.  Note that DF_FILLCOL is a string but MAX_FILLCOL is an integer.
!  ----*/
! #define	DF_FILLCOL	"74"
! #define	MAX_FILLCOL	80
! 
! 
! 
! /*----- System-wide config file ----------------------------------------*/
! #ifndef SYSTEM_PINERC
! #define SYSTEM_PINERC             "/usr/local/lib/pine.conf"
! #endif
! #ifndef SYSTEM_PINERC_FIXED
! #define SYSTEM_PINERC_FIXED       "/usr/local/lib/pine.conf.fixed"
! #endif
! 
! 
! 
! /*----------------------------------------------------------------------
!    The default folder names and folder directories (some for backwards
!    compatibility).  Think hard before changing any of these.
!  ----*/
! #define DF_DEFAULT_FCC            "sent-mail"
! #define DEFAULT_SAVE              "saved-messages"
! #define POSTPONED_MAIL            "postponed-mail"
! #define POSTPONED_MSGS            "postponed-msgs"
! #define INTERRUPTED_MAIL          ".pine-interrupted-mail"
! #define DEADLETTER                "dead.letter"
! #define DF_MAIL_DIRECTORY         "mail"
! #define INBOX_NAME                "INBOX"
! #define DF_SIGNATURE_FILE         ".signature"
! #define DF_ELM_STYLE_SAVE         "no"
! #define DF_HEADER_IN_REPLY        "no"
! #define DF_OLD_STYLE_REPLY        "no"
! #define DF_USE_ONLY_DOMAIN_NAME   "no"
! #define DF_FEATURE_LEVEL          "sapling"
! #define DF_SAVE_BY_SENDER         "no"
! #define DF_SORT_KEY               "arrival"
! #define DF_AB_SORT_RULE           "fullname-with-lists-last"
! #define DF_FLD_SORT_RULE          "alphabetical"
! #define DF_SAVED_MSG_NAME_RULE    "default-folder"
! #define DF_FCC_RULE               "default-fcc"
! #define DF_STANDARD_PRINTER       "lpr"
! #define ANSI_PRINTER              "attached-to-ansi"
! #define DF_ADDRESSBOOK            ".addressbook"
! #define DF_BUGS_FULLNAME          "Pine Developers"
! #define DF_BUGS_ADDRESS           "pine-bugs@cac.washington.edu"
! #define DF_SUGGEST_FULLNAME       "Pine Developers"
! #define DF_SUGGEST_ADDRESS        "pine-suggestions@cac.washington.edu"
! #define DF_PINEINFO_FULLNAME      "Pine-Info News Group"
! #define DF_PINEINFO_ADDRESS       "pine-info@cac.washington.edu"
! #define DF_LOCAL_FULLNAME         "Local Support"
! #define DF_LOCAL_ADDRESS          "postmaster"
! #define DF_KBLOCK_PASSWD_COUNT    "1"
! #define DF_REMOTE_ABOOK_HISTORY   "3"
! 
! /*----------------------------------------------------------------------
!    The default printer when pine starts up for the first time with no printer
!  ----*/
! #define DF_DEFAULT_PRINTER        ANSI_PRINTER
! 
! 
! 
! /*----- The usual sendmail configuration for sending mail on Unix ------*/
! #ifndef SENDMAIL
! #define SENDMAIL	"/usr/sbin/sendmail"
! #endif
! #ifndef SENDMAILFLAGS
! #define SENDMAILFLAGS	"-bs -odb -oem"	/* send via smtp with backgroud
! 					   delivery and mail back errors */
! #endif
! 
! 
! /*----------------------------------------------------------------------
!    If no nntp-servers are defined, this program will be used to post news.
!  ----*/
! /* #define SENDNEWS	"/usr/local/bin/inews -h" */
! 
! 
! /*--------- Program employed by users to change their password ---------*/
! #ifndef	PASSWD_PROG
! #define	PASSWD_PROG	"/bin/passwd"
! #endif
! 
! 
! /*-------------- A couple constants used to size arrays ----------------*/
! #include <sys/param.h>          /* Get it from param.h if available */
! #undef MAXPATH                  /* Sometimes defined in param.h differently */
! #define MAXPATH MAXPATHLEN      /* Longest pathname we ever expect */
! /* #define MAXPATH        (512) */ /* Longest pathname we ever expect */
! #define MAXFOLDER      (128)     /* Longest foldername we ever expect */  
! 
! 
! /*-- Max screen pine will display on. Used to define some array sizes --*/
! #define MAX_SCREEN_COLS  (170) 
! #define MAX_SCREEN_ROWS  (200) 
! 
! 
! /*----------------------------------------------------------------------
!     Where to put the output of pine in debug mode. Files are created
!  in the user's home directory and have a number appended to them when
!  there is more than one.
!  ----*/
! #define DEBUGFILE	".pine-debug"
! 
! /*----------------------------------------------------------------------
!     The number of debug files to save in the user's home diretory. The files
!  are useful for figuring out what a user did when he complains that something
!  went wrong. It's important to keep a bunch around, usually 4, so that the
!  debug file in question will still be around when the problem gets 
!  investigated. Users tend to go in and out of Pine a few times and there
!  is one file for each pine invocation
!  ----*/
! #define NUMDEBUGFILES 4
! 
! /*----------------------------------------------------------------------
!    The default debug level to set (approximate meanings):
!        1 logs only highest level events and errors
!        2 logs events like file writes
!        3
!        4 logs each command
!        5
!        6 
!        7 logs details of command execution (7 is highest to run any production)
!        8
!        9 logs gross details of command execution
!  ----*/
! #define DEFAULT_DEBUG 2
! 
! 
! 
! /*----------------------------------------------------------------------
!     Various maximum field lengths, probably shouldn't be changed.
!  ----*/
! #define MAX_FULLNAME     (100) 
! #define MAX_NICKNAME      (80)
! #define MAX_ADDRESS      (500)
! #define MAX_NEW_LIST     (500)  /* Max addrs to be added when creating list */
! #define MAX_SEARCH       (100)  /* Longest string to search for             */
! #define MAX_ADDR_EXPN   (1000)  /* Longest expanded addr                    */
! #define MAX_ADDR_FIELD (10000)  /* Longest fully-expanded addr field        */
! 
! 
! #endif /* _OS_INCLUDED */
diff -rc pine4.61/pine/osdep/pw_stuff pine4.61.I.USE/pine/osdep/pw_stuff
*** pine4.61/pine/osdep/pw_stuff	Mon Aug 30 13:23:45 1999
--- pine4.61.I.USE/pine/osdep/pw_stuff	Sat Aug 28 21:09:43 2004
***************
*** 17,27 ****
      /* replace any & with logname in upper case */
  
      for(fncp = fullname, gcoscp= gcos_field, end = fullname + MAX_FULLNAME - 1;
!         (*gcoscp != ',' && *gcoscp != '\0' && fncp != end);
  	gcoscp++) {
  
  	if(*gcoscp == '&') {
! 	    for(lncp = logname; *lncp; fncp++, lncp++)
  		*fncp = toupper((unsigned char)(*lncp));
  	} else {
  	    *fncp++ = *gcoscp;
--- 17,27 ----
      /* replace any & with logname in upper case */
  
      for(fncp = fullname, gcoscp= gcos_field, end = fullname + MAX_FULLNAME - 1;
!         (*gcoscp != ',' && *gcoscp != '\0' && fncp < end);
  	gcoscp++) {
  
  	if(*gcoscp == '&') {
! 	    for(lncp = logname; *lncp && fncp < end; fncp++, lncp++)
  		*fncp = toupper((unsigned char)(*lncp));
  	} else {
  	    *fncp++ = *gcoscp;
diff -rc pine4.61/pine/osdep/termin.gen pine4.61.I.USE/pine/osdep/termin.gen
*** pine4.61/pine/osdep/termin.gen	Wed Dec  3 16:51:08 2003
--- pine4.61.I.USE/pine/osdep/termin.gen	Fri Jul 16 11:56:15 2004
***************
*** 6,11 ****
--- 6,28 ----
  int	pcpine_oe_cursor PROTO((int, long));
  #endif
  
+ void
+ fake_config_screen(tt)
+      struct ttyo **tt;
+ {
+     struct ttyo *ttyo;
+ 
+     ttyo = (struct ttyo *)fs_get(sizeof (struct ttyo));
+ 
+     ttyo->header_rows = 2;
+     ttyo->footer_rows = 3;
+     ttyo->screen_rows = 24;
+     ttyo->screen_cols = 80;
+ 
+     *tt = ttyo;
+ 
+ }
+ 
  
  /*
   *     Generic tty input routines
***************
*** 227,233 ****
  	       (escape_list && escape_list[0].ch != -1)
  		 ? escape_list[0].label: ""));
  
!     if(!ps_global->ttyo)
        return(pre_screen_config_opt_enter(string, field_len, prompt,
  					 escape_list, help, flags));
  
--- 244,250 ----
  	       (escape_list && escape_list[0].ch != -1)
  		 ? escape_list[0].label: ""));
  
!     if((!ps_global->ttyo) || (ps_global->send_immediately))
        return(pre_screen_config_opt_enter(string, field_len, prompt,
  					 escape_list, help, flags));
  
***************
*** 1040,1046 ****
      }
  
      if(firsttime) {
! 	firsttime = 0;
  	if(ps_global->in_init_seq) {
  	    ps_global->in_init_seq = 0;
  	    ps_global->save_in_init_seq = 0;
--- 1057,1063 ----
      }
  
      if(firsttime) {
! 	firsttime = ps_global->checking_incfld ? (char) 1 : 0;
  	if(ps_global->in_init_seq) {
  	    ps_global->in_init_seq = 0;
  	    ps_global->save_in_init_seq = 0;
diff -rc pine4.61/pine/osdep/termin.unx pine4.61.I.USE/pine/osdep/termin.unx
*** pine4.61/pine/osdep/termin.unx	Tue Nov 25 09:38:42 2003
--- pine4.61.I.USE/pine/osdep/termin.unx	Fri Jul 16 11:56:03 2004
***************
*** 46,51 ****
--- 46,53 ----
  init_tty_driver(ps)
       struct pine *ps;
  {
+    if(ps->send_immediately)
+      return 0;
  #ifdef	MOUSE
      if(F_ON(F_ENABLE_MOUSE, ps_global))
        init_mouse();
***************
*** 573,578 ****
--- 575,583 ----
  init_keyboard(use_fkeys)
       int use_fkeys;
  {
+     if (ps_global->send_immediately)
+ 	return;
+ 
      if(use_fkeys && (!strucmp(term_name,"vt102")
  		     || !strucmp(term_name,"vt100")))
        printf("\033\133\071\071\150");
***************
*** 591,596 ****
--- 596,604 ----
  end_keyboard(use_fkeys)
       int use_fkeys;
  {
+     if(ps_global->send_immediately)
+ 	return;
+ 
      if(use_fkeys && (!strcmp(term_name, "vt102")
  		     || !strcmp(term_name, "vt100"))){
  	printf("\033\133\071\071\154");
diff -rc pine4.61/pine/osdep/termout.unx pine4.61.I.USE/pine/osdep/termout.unx
*** pine4.61/pine/osdep/termout.unx	Thu Oct  9 12:46:42 2003
--- pine4.61.I.USE/pine/osdep/termout.unx	Fri Jul 16 11:56:03 2004
***************
*** 160,165 ****
--- 160,168 ----
  void
  init_screen()
  {
+     if(ps_global->send_immediately)
+ 	return;
+ 
      if(_termcap_init)			/* init using termcap's rule */
        tputs(_termcap_init, 1, outchar);
  
***************
*** 268,273 ****
--- 271,279 ----
  
      dprint(9, (debugfile, "end_screen called\n"));
  
+     if(ps_global->send_immediately)
+ 	return;
+ 
      if(FOOTER_ROWS(ps_global) == 1){
  	footer_rows_was_one++;
  	FOOTER_ROWS(ps_global) = 3;
***************
*** 314,320 ****
      _line = 0;	/* clear leaves us at top... */
      _col  = 0;
  
!     if(ps_global->in_init_seq)
        return;
  
      mark_status_unknown();
--- 320,326 ----
      _line = 0;	/* clear leaves us at top... */
      _col  = 0;
  
!     if(ps_global->in_init_seq || ps_global->send_immediately)
        return;
  
      mark_status_unknown();
diff -rc pine4.61/pine/other.c pine4.61.I.USE/pine/other.c
*** pine4.61/pine/other.c	Fri Jul  2 14:38:16 2004
--- pine4.61.I.USE/pine/other.c	Fri Sep 17 09:38:54 2004
***************
*** 357,364 ****
  char    *checkbox_pretty_value PROTO((struct pine *, CONF_S *));
  char    *color_pretty_value PROTO((struct pine *, CONF_S *));
  char    *radio_pretty_value PROTO((struct pine *, CONF_S *));
! char    *sort_pretty_value PROTO((struct pine *, CONF_S *));
! char    *generalized_sort_pretty_value PROTO((struct pine *, CONF_S *, int));
  char    *yesno_pretty_value PROTO((struct pine *, CONF_S *));
  char    *sigfile_pretty_value PROTO((struct pine *, CONF_S *));
  void     set_radio_pretty_vals PROTO((struct pine *, CONF_S **));
--- 357,364 ----
  char    *checkbox_pretty_value PROTO((struct pine *, CONF_S *));
  char    *color_pretty_value PROTO((struct pine *, CONF_S *));
  char    *radio_pretty_value PROTO((struct pine *, CONF_S *));
! char    *sort_pretty_value PROTO((struct pine *, CONF_S *, int));
! char    *generalized_sort_pretty_value PROTO((struct pine *, CONF_S *, int, int));
  char    *yesno_pretty_value PROTO((struct pine *, CONF_S *));
  char    *sigfile_pretty_value PROTO((struct pine *, CONF_S *));
  void     set_radio_pretty_vals PROTO((struct pine *, CONF_S **));
***************
*** 1513,1519 ****
  	      if(lv < (j = strlen(sort_name(ps->sort_types[i]))))
  		lv = j;
  	    
! 	    decode_sort(pval, &def_sort, &def_sort_rev);
  
  	    for(j = 0; j < 2; j++){
  		for(i = 0; ps->sort_types[i] != EndofList; i++){
--- 1513,1519 ----
  	      if(lv < (j = strlen(sort_name(ps->sort_types[i]))))
  		lv = j;
  	    
! 	    decode_sort(pval, &def_sort, &def_sort_rev, 0);
  
  	    for(j = 0; j < 2; j++){
  		for(i = 0; ps->sort_types[i] != EndofList; i++){
***************
*** 1528,1533 ****
--- 1528,1583 ----
  		}
  	    }
  	}
+         else if(vtmp == &ps->vars[V_THREAD_SORT_KEY]){ /* radio case */
+             SortOrder thread_def_sort;
+             int       thread_def_sort_rev;
+ 
+             ctmpa->flags       |= CF_NOSELECT;
+             ctmpa->keymenu      = &config_radiobutton_keymenu;
+             ctmpa->tool         = NULL;
+ 
+             /* put a nice delimiter before list */
+             new_confline(&ctmpa)->var = NULL;
+             ctmpa->varnamep               = ctmpb;
+             ctmpa->keymenu                = &config_radiobutton_keymenu;
+             ctmpa->help                   = NO_HELP;
+             ctmpa->tool                   = radiobutton_tool;
+             ctmpa->valoffset              = 12;
+             ctmpa->flags                 |= CF_NOSELECT;
+             ctmpa->value = cpystr("Set    Thread Sort Options");
+ 
+             new_confline(&ctmpa)->var = NULL;
+             ctmpa->varnamep           = ctmpb;
+             ctmpa->keymenu            = &config_radiobutton_keymenu;
+             ctmpa->help               = NO_HELP;
+             ctmpa->tool               = radiobutton_tool;
+             ctmpa->valoffset          = 12;
+             ctmpa->flags             |= CF_NOSELECT;
+             ctmpa->value = cpystr("---  ----------------------");
+   
+             /* find longest value's name */
+             for(lv = 0, i = 0; ps->sort_types[i] != EndofList; i++)
+               if(lv < (j = strlen(sort_name(ps->sort_types[i]))))
+                 lv = j;
+ 
+             decode_sort(pval, &thread_def_sort, &thread_def_sort_rev, 1);
+ 
+             for(j = 0; j < 2; j++){
+                 for(i = 0; ps->sort_types[i] != EndofList; i++){
+ 		  if (ps->sort_types[i] == SortArrival
+ 		      || ps->sort_types[i] == SortThread){
+                     new_confline(&ctmpa)->var = vtmp;
+                     ctmpa->varnamep           = ctmpb;
+                     ctmpa->keymenu            = &config_radiobutton_keymenu;
+                     ctmpa->help               = config_help(vtmp - ps->vars, 0);
+                     ctmpa->tool               = radiobutton_tool;
+                     ctmpa->valoffset          = 12;
+                     ctmpa->varmem             = i + (j * EndofList);
+                     ctmpa->value              = pretty_value(ps, ctmpa);
+ 		  }
+                 }
+             }
+         }
  	else if(vtmp == &ps->vars[V_USE_ONLY_DOMAIN_NAME]){ /* yesno case */
  	    ctmpa->keymenu = &config_yesno_keymenu;
  	    ctmpa->tool	   = yesno_tool;
***************
*** 1581,1586 ****
--- 1631,1637 ----
  	       || vtmp == &ps->vars[V_TCPREADWARNTIMEO]
  	       || vtmp == &ps->vars[V_TCPWRITEWARNTIMEO]
  	       || vtmp == &ps->vars[V_TCPQUERYTIMEO]
+ 	       || vtmp == &ps->vars[V_INCFLDTIMEO]
  	       || vtmp == &ps->vars[V_RSHOPENTIMEO]
  	       || vtmp == &ps->vars[V_SSHOPENTIMEO]
  	       || vtmp == &ps->vars[V_USERINPUTTIMEO]
***************
*** 1686,1691 ****
--- 1737,1751 ----
  	}
      }
  
+     pval = PVAL(&ps->vars[V_THREAD_SORT_KEY], ew);
+     if(vsave[V_THREAD_SORT_KEY].saved_user_val.p && pval
+        && strcmp(vsave[V_THREAD_SORT_KEY].saved_user_val.p, pval)){
+       if(!mn_get_mansort(ps_global->msgmap)){
+           clear_index_cache();
+           reset_sort_order(SRT_VRB);
+       }
+     }
+ 
      treat_color_vars_as_text = 0;
      free_saved_config(ps, &vsave, expose_hidden_config);
  #ifdef _WINDOWS
***************
*** 1706,1711 ****
--- 1766,1772 ----
  	   v == &ps->vars[V_FCC_RULE] ||
  	   v == &ps->vars[V_GOTO_DEFAULT_RULE] ||
  	   v == &ps->vars[V_INCOMING_STARTUP] ||
+ 	   v == &ps->vars[V_INCOMING_RULE] ||
  	   v == &ps->vars[V_PRUNING_RULE] ||
  	   v == &ps->vars[V_REOPEN_RULE] ||
  	   v == &ps->vars[V_THREAD_DISP_STYLE] ||
***************
*** 1735,1740 ****
--- 1796,1803 ----
        rulefunc = goto_rules;
      else if(v == &ps->vars[V_INCOMING_STARTUP])
        rulefunc = incoming_startup_rules;
+     else if(v == &ps->vars[V_INCOMING_RULE])
+       rulefunc = incoming_check_rules;
      else if(v == startup_ptr)
        rulefunc = startup_rules;
      else if(v == &ps->vars[V_PRUNING_RULE])
***************
*** 1840,1846 ****
      CONF_S *ctmp;
  
      if(!(cl && *cl &&
!        ((*cl)->var == &ps->vars[V_SORT_KEY] ||
          standard_radio_var(ps, (*cl)->var) ||
  	(*cl)->var == startup_ptr)))
        return;
--- 1903,1910 ----
      CONF_S *ctmp;
  
      if(!(cl && *cl &&
!         (((*cl)->var == &ps->vars[V_SORT_KEY]) || 
!         ((*cl)->var == &ps->vars[V_THREAD_SORT_KEY]) ||
          standard_radio_var(ps, (*cl)->var) ||
  	(*cl)->var == startup_ptr)))
        return;
***************
*** 1909,1914 ****
--- 1973,1979 ----
        case V_TCPREADWARNTIMEO :
        case V_TCPWRITEWARNTIMEO :
        case V_TCPQUERYTIMEO :
+       case V_INCFLDTIMEO :
        case V_RSHCMD :
        case V_RSHPATH :
        case V_RSHOPENTIMEO :
***************
*** 6316,6322 ****
      int		  multicol;
  {
      char	  tmp[MAXPATH+1];
!     int		  cmd, i, j, ch = 'x', done = 0, changes = 0;
      int		  retval = 0;
      int		  km_popped = 0, stay_in_col = 0;
      struct	  key_menu  *km = NULL;
--- 6381,6387 ----
      int		  multicol;
  {
      char	  tmp[MAXPATH+1];
!     int		  cmd, i, j, k = 1, ch = 'x', done = 0, changes = 0;
      int		  retval = 0;
      int		  km_popped = 0, stay_in_col = 0;
      struct	  key_menu  *km = NULL;
***************
*** 6358,6363 ****
--- 6423,6429 ----
  	}
  
  	/*----------- Check for new mail -----------*/
+         if (!ps->send_immediately){
          if(new_mail(0, NM_TIMING(ch), NM_STATUS_MSG | NM_DEFER_SORT) >= 0)
            ps->mangled_header = 1;
  
***************
*** 6476,6483 ****
  #ifdef	_WINDOWS
  	mswin_setscrollcallback(NULL);
  #endif
! 
! 	cmd = menu_command(ch, km);
  
  	if(km_popped)
  	  switch(cmd){
--- 6542,6564 ----
  #ifdef	_WINDOWS
  	mswin_setscrollcallback(NULL);
  #endif
!         } /* send_immediately */
!                        
!         if (ps->send_immediately){
!               ch = (char) ps->free_initial_cmds[k++];
!               if (ch == 'n')
!                 cmd = MC_CHARDOWN;
!               if (ch == 'p')
!                 cmd = MC_CHARDOWN;
!               if (ch == '\r'){
!                 cmd = MC_CHOICE;
!                 role_select_tool(ps, cmd, &screen->current, 512);
!               }
!               if (ch == '\030')   /* ^X, bye */
!                 goto end;
!         }           
!         else
! 	   cmd = menu_command(ch, km);
  
  	if(km_popped)
  	  switch(cmd){
***************
*** 6897,6906 ****
--- 6978,6989 ----
  #define FOUND_NOSELECT 0x08
  #define FOUND_ABOVE    0x10
  	     char *result = NULL, buf[64];
+ 	     static char last_pat[64] = {'\0'};
  	     static char last[64];
  	     HelpType help;
  	     static ESCKEY_S ekey[] = {
  		{0, 0, "", ""},
+ 		{ctrl('N'),  9, "^N", "Ins Pat"},
  		{ctrl('Y'), 10, "^Y", "Top"},
  		{ctrl('V'), 11, "^V", "Bottom"},
  		{-1, 0, NULL, NULL}};
***************
*** 6919,6931 ****
  					 tmp,ekey,help,&flags);
  		 if(rc == 3)
  		   help = help == NO_HELP ? h_config_whereis : NO_HELP;
! 		 else if(rc == 0 || rc == 1 || rc == 10 || rc == 11 || !buf[0]){
  		     if(rc == 0 && !buf[0] && last[0])
  		       strncpy(buf, last, 64);
  
! 		     break;
  		 }
  	     }
  
  	     screen->current->flags &= ~CF_VAR2;
  	     if(rc == 0 && buf[0]){
--- 7002,7023 ----
  					 tmp,ekey,help,&flags);
  		 if(rc == 3)
  		   help = help == NO_HELP ? h_config_whereis : NO_HELP;
! 		 else if(rc == 0 || rc == 1 || rc == 9 || rc == 10 
! 						|| rc == 11 || !buf[0]){
  		     if(rc == 0 && !buf[0] && last[0])
  		       strncpy(buf, last, 64);
  
! 		     if(rc == 9)
! 			insert_pattern_in_string(buf, last_pat, 63);
! 		     else
! 			break;
  		 }
  	     }
+      
+ 	     if (buf[0] != '\0'){
+ 		strncpy(last_pat, buf, sizeof(last_pat));
+ 		last_pat[sizeof(buf) - 1] = '\0';
+ 	     }
  
  	     screen->current->flags &= ~CF_VAR2;
  	     if(rc == 0 && buf[0]){
***************
*** 7137,7143 ****
  	    break;
  	}
      }
! 
      screen->current = first_confline(screen->current);
      free_conflines(&screen->current);
      return(retval);
--- 7229,7235 ----
  	    break;
  	}
      }
! end:
      screen->current = first_confline(screen->current);
      free_conflines(&screen->current);
      return(retval);
***************
*** 7280,7285 ****
--- 7372,7379 ----
  	return(h_config_nntp_server);
        case V_INBOX_PATH :
  	return(h_config_inbox_path);
+       case V_INCOMING_FOLDERS_CHECK :
+         return(h_config_check_inc_fld);
        case V_PRUNED_FOLDERS :
  	return(h_config_pruned_folders);
        case V_DEFAULT_FCC :
***************
*** 7318,7327 ****
--- 7412,7449 ----
  	return(h_config_fcc_rule);
        case V_SORT_KEY :
  	return(h_config_sort_key);
+       case V_THREAD_SORT_KEY :
+ 	return(h_config_thread_sort_key);
        case V_AB_SORT_RULE :
  	return(h_config_ab_sort_rule);
        case V_FLD_SORT_RULE :
  	return(h_config_fld_sort_rule);
+       case V_THREAD_DISP_STYLE_RULES:
+ 	return(h_config_thread_display_style_rule);
+       case V_THREAD_INDEX_STYLE_RULES:
+ 	return(h_config_thread_index_style_rule);
+       case V_COMPOSE_RULES:
+ 	return(h_config_compose_rules);
+       case V_FORWARD_RULES:
+ 	return(h_config_forward_rules);
+       case V_INDEX_RULES:
+ 	return(h_config_index_rules);
+       case V_REPLACE_RULES:
+ 	return(h_config_replace_rules);
+       case V_REPLY_INDENT_RULES:
+ 	return(h_config_reply_indent_rules);
+       case V_REPLY_LEADIN_RULES:
+ 	return(h_config_reply_leadin_rules);
+       case V_RESUB_RULES:
+ 	return(h_config_resub_rules);
+       case V_SAVE_RULES:
+ 	return(h_config_save_rules);
+       case V_SMTP_RULES:
+ 	return(h_config_smtp_rules);
+       case V_SORT_RULES:
+ 	return(h_config_sort_rules);
+       case V_STARTUP_RULES:
+ 	return(h_config_startup_rules);
        case V_CHAR_SET :
  	return(h_config_char_set);
        case V_EDITOR :
***************
*** 7350,7355 ****
--- 7472,7479 ----
  	return(h_config_scroll_margin);
        case V_DEADLETS :
  	return(h_config_deadlets);
+        case V_SPECIAL_TEXT :
+ 	return(h_config_special_text_to_color);
        case V_FILLCOL :
  	return(h_config_composer_wrap_column);
  #ifdef DEBUGJOURNAL
***************
*** 7364,7369 ****
--- 7488,7495 ----
  	return(h_config_tcp_writewarn_timeo);
        case V_TCPQUERYTIMEO :
  	return(h_config_tcp_query_timeo);
+       case V_INCFLDTIMEO :
+ 	return(h_config_inc_fld_timeo);
        case V_RSHOPENTIMEO :
  	return(h_config_rsh_open_timeo);
        case V_SSHOPENTIMEO :
***************
*** 7444,7449 ****
--- 7570,7577 ----
  	return(h_config_goto_default);
        case V_INCOMING_STARTUP:
  	return(h_config_inc_startup);
+       case V_INCOMING_RULE:
+ 	return(h_config_inc_rule);
        case V_PRUNING_RULE:
  	return(h_config_pruning_rule);
        case V_REOPEN_RULE:
***************
*** 7464,7469 ****
--- 7592,7599 ----
  	return(h_config_mimetype_path);
        case V_NEWSRC_PATH :
  	return(h_config_newsrc_path);
+       case V_MAILDIR_LOCATION :
+ 	return(h_config_maildir_location);
        case V_BROWSER :
  	return(h_config_browser);
  #if defined(DOS) || defined(OS2)
***************
*** 7495,7500 ****
--- 7625,7633 ----
        case V_SIGNATURE_FORE_COLOR :
        case V_SIGNATURE_BACK_COLOR :
  	return(h_config_signature_color);
+       case V_SPECIAL_TEXT_FORE_COLOR :
+       case V_SPECIAL_TEXT_BACK_COLOR :
+ 	return(h_config_special_text_color);
        case V_PROMPT_FORE_COLOR :
        case V_PROMPT_BACK_COLOR :
  	return(h_config_prompt_color);
***************
*** 7875,7880 ****
--- 8008,8017 ----
  	    lowrange = 5;
  	    hirange  = 1000;
  	}
+ 	else if((*cl)->var == &ps->vars[V_INCFLDTIMEO]){
+ 	    lowrange = 2;
+ 	    hirange  = 60;
+ 	}
  	else if((*cl)->var == &ps->vars[V_TCPWRITEWARNTIMEO] ||
  	        (*cl)->var == &ps->vars[V_RSHOPENTIMEO] ||
  	        (*cl)->var == &ps->vars[V_SSHOPENTIMEO] ||
***************
*** 9208,9214 ****
  	    }
  
  	    set_current_val((*cl)->var, TRUE, TRUE);
! 	    if(decode_sort(ps->VAR_SORT_KEY, &def_sort, &def_sort_rev) != -1){
  		ps->def_sort     = def_sort;
  		ps->def_sort_rev = def_sort_rev;
  	    }
--- 9345,9351 ----
  	    }
  
  	    set_current_val((*cl)->var, TRUE, TRUE);
! 	    if(decode_sort(ps->VAR_SORT_KEY, &def_sort, &def_sort_rev,0) != -1){
  		ps->def_sort     = def_sort;
  		ps->def_sort_rev = def_sort_rev;
  	    }
***************
*** 9217,9222 ****
--- 9354,9390 ----
  	    ps->mangled_body = 1;	/* BUG: redraw it all for now? */
  	    rv = 1;
  	}
+         else if((*cl)->var == &ps->vars[V_THREAD_SORT_KEY]){
+             SortOrder thread_def_sort;
+             int       thread_def_sort_rev;
+ 
+             thread_def_sort_rev  = (*cl)->varmem >= (short) EndofList;
+             thread_def_sort      = (SortOrder) ((*cl)->varmem - (thread_def_sort_rev
+                                                                  * EndofList));
+             sprintf(tmp_20k_buf, "%s%s", sort_name(thread_def_sort),
+                    (thread_def_sort_rev) ? "/Reverse" : "");
+ 
+             if((*cl)->var->cmdline_val.p)
+               fs_give((void **)&(*cl)->var->cmdline_val.p);
+ 
+             if(apval){
+                 if(*apval)
+                   fs_give((void **)apval);
+ 
+                 *apval = cpystr(tmp_20k_buf);
+             }
+ 
+             set_current_val((*cl)->var, TRUE, TRUE);
+             if(decode_sort(ps->VAR_THREAD_SORT_KEY, &thread_def_sort, 
+                                         &thread_def_sort_rev, 1) != -1){
+                 ps->thread_def_sort     = thread_def_sort;
+                 ps->thread_def_sort_rev = thread_def_sort_rev;
+             }
+ 
+             set_radio_pretty_vals(ps, cl);
+             ps->mangled_body = 1;       /* BUG: redraw it all for now? */
+             rv = 1;
+         }
  	else
  	  q_status_message(SM_ORDER | SM_DING, 3, 6,
  			   "Programmer botch!  Unknown radiobutton type.");
***************
*** 10689,10695 ****
      else if(standard_radio_var(ps, v) || v == startup_ptr)
        return(radio_pretty_value(ps, cl));
      else if(v == &ps->vars[V_SORT_KEY])
!       return(sort_pretty_value(ps, cl));
      else if(v == &ps->vars[V_SIGNATURE_FILE])
        return(sigfile_pretty_value(ps, cl));
      else if(v == &ps->vars[V_USE_ONLY_DOMAIN_NAME])
--- 10857,10865 ----
      else if(standard_radio_var(ps, v) || v == startup_ptr)
        return(radio_pretty_value(ps, cl));
      else if(v == &ps->vars[V_SORT_KEY])
!        return(sort_pretty_value(ps, cl, 0));
!      else if(v == &ps->vars[V_THREAD_SORT_KEY])
!        return(sort_pretty_value(ps, cl, 1));
      else if(v == &ps->vars[V_SIGNATURE_FILE])
        return(sigfile_pretty_value(ps, cl));
      else if(v == &ps->vars[V_USE_ONLY_DOMAIN_NAME])
***************
*** 11358,11376 ****
  
  
  char *
! sort_pretty_value(ps, cl)
      struct pine *ps;
      CONF_S      *cl;
  {
!     return(generalized_sort_pretty_value(ps, cl, 1));
  }
  
  
  char *
! generalized_sort_pretty_value(ps, cl, default_ok)
      struct pine *ps;
      CONF_S      *cl;
      int          default_ok;
  {
      char  tmp[MAXPATH];
      char *pvalnorm, *pvalexc, *pval;
--- 11528,11548 ----
  
  
  char *
! sort_pretty_value(ps, cl, thread)
      struct pine *ps;
      CONF_S      *cl;
+     int		 thread;
  {
!     return(generalized_sort_pretty_value(ps, cl, 1, thread));
  }
  
  
  char *
! generalized_sort_pretty_value(ps, cl, default_ok, thread)
      struct pine *ps;
      CONF_S      *cl;
      int          default_ok;
+     int		 thread;
  {
      char  tmp[MAXPATH];
      char *pvalnorm, *pvalexc, *pval;
***************
*** 11420,11426 ****
      }
      else if(fixed){
  	pval = v->fixed_val.p;
! 	decode_sort(pval, &var_sort, &var_sort_rev);
  	is_the_one = (var_sort_rev == line_sort_rev && var_sort == line_sort);
  
  	sprintf(tmp, "(%c)  %s%-*s%*s%s",
--- 11592,11598 ----
      }
      else if(fixed){
  	pval = v->fixed_val.p;
! 	decode_sort(pval, &var_sort, &var_sort_rev, thread);
  	is_the_one = (var_sort_rev == line_sort_rev && var_sort == line_sort);
  
  	sprintf(tmp, "(%c)  %s%-*s%*s%s",
***************
*** 11431,11439 ****
  		is_the_one ? "   (value is fixed)" : "");
      }
      else if(is_set_for_this_level){
! 	decode_sort(pval, &var_sort, &var_sort_rev);
  	is_the_one = (var_sort_rev == line_sort_rev && var_sort == line_sort);
! 	decode_sort(pvalexc, &exc_sort, &exc_sort_rev);
  	the_exc_one = (editing_normal_which_isnt_except && pvalexc &&
  		       exc_sort_rev == line_sort_rev && exc_sort == line_sort);
  	sprintf(tmp, "(%c)  %s%-*s%*s%s",
--- 11603,11611 ----
  		is_the_one ? "   (value is fixed)" : "");
      }
      else if(is_set_for_this_level){
! 	decode_sort(pval, &var_sort, &var_sort_rev, thread);
  	is_the_one = (var_sort_rev == line_sort_rev && var_sort == line_sort);
! 	decode_sort(pvalexc, &exc_sort, &exc_sort_rev, thread);
  	the_exc_one = (editing_normal_which_isnt_except && pvalexc &&
  		       exc_sort_rev == line_sort_rev && exc_sort == line_sort);
  	sprintf(tmp, "(%c)  %s%-*s%*s%s",
***************
*** 11451,11457 ****
      }
      else{
  	if(pvalexc){
! 	    decode_sort(pvalexc, &exc_sort, &exc_sort_rev);
  	    is_the_one = (exc_sort_rev == line_sort_rev &&
  			  exc_sort == line_sort);
  	    sprintf(tmp, "( )  %s%-*s%*s%s",
--- 11623,11629 ----
      }
      else{
  	if(pvalexc){
! 	    decode_sort(pvalexc, &exc_sort, &exc_sort_rev, thread);
  	    is_the_one = (exc_sort_rev == line_sort_rev &&
  			  exc_sort == line_sort);
  	    sprintf(tmp, "( )  %s%-*s%*s%s",
***************
*** 11462,11468 ****
  	}
  	else{
  	    pval = v->current_val.p;
! 	    decode_sort(pval, &var_sort, &var_sort_rev);
  	    is_the_one = ((pval || default_ok) &&
  			  var_sort_rev == line_sort_rev &&
  			  var_sort == line_sort);
--- 11634,11640 ----
  	}
  	else{
  	    pval = v->current_val.p;
! 	    decode_sort(pval, &var_sort, &var_sort_rev, thread);
  	    is_the_one = ((pval || default_ok) &&
  			  var_sort_rev == line_sort_rev &&
  			  var_sort == line_sort);
***************
*** 11660,11665 ****
--- 11832,11850 ----
  
  	cl->value = pretty_value(ps, cl);
      }
+     if (f->id == F_ENHANCED_THREAD && ps->mail_stream 
+ 	&& SORT_IS_THREADED(ps->msgmap)){
+ 	  refresh_sort(ps->mail_stream, ps->msgmap, SRT_NON);
+ 	  if (COLL_THRDS())	/* sortring by thread destroys collapsed info */
+ 	     kolapse_thread(ps, ps->mail_stream, ps->msgmap,'[', 0);
+ 	  if(SEP_THRDINDX() && SORT_IS_THREADED(ps->msgmap) 
+ 				     && sp_viewing_a_thread(ps->mail_stream)){
+ 	     unview_thread(ps, ps->mail_stream, ps->msgmap);
+ 	     view_thread(ps, ps->mail_stream, ps->msgmap, 0);
+ 	     ps_global->next_screen = SCREEN_FUN_NULL;
+ 	  }
+     }
+ 
  
      /*
       * Handle any features that need special attention here...
***************
*** 12446,12460 ****
  	    ps->mangled_header = 1;
  	}
  	else if(sp_inbox_stream()
! 		&& strcmp(ps->VAR_INBOX_PATH, sp_inbox_stream()->mailbox)){
  	    /*
  	     * if we don't have inbox directly open, but have it
  	     * open for new mail notification, close the stream like
  	     * any other ordinary folder, and clean up...
  	     */
! 	    sp_unflag(sp_inbox_stream(), SP_PERMLOCKED | SP_INBOX);
! 	    sp_set_fldr(sp_inbox_stream(), sp_inbox_stream()->mailbox);
! 	    expunge_and_close(sp_inbox_stream(), NULL, EC_NONE);
  	}
      }
      else if(var == &ps->vars[V_ADDRESSBOOK] ||
--- 12631,12646 ----
  	    ps->mangled_header = 1;
  	}
  	else if(sp_inbox_stream()
! 	    && strcmp(ps->VAR_INBOX_PATH, sp_inbox_stream()->original_mailbox)){
! 	    MAILSTREAM *m = sp_inbox_stream();
  	    /*
  	     * if we don't have inbox directly open, but have it
  	     * open for new mail notification, close the stream like
  	     * any other ordinary folder, and clean up...
  	     */
! 	    sp_unflag(m, SP_PERMLOCKED | SP_INBOX);
! 	    sp_set_fldr(m, m->mailbox);
! 	    expunge_and_close(m, NULL, EC_NONE);
  	}
      }
      else if(var == &ps->vars[V_ADDRESSBOOK] ||
***************
*** 12606,12611 ****
--- 12792,12803 ----
  	  if(ps->VAR_TCPQUERYTIMEO && SVAR_TCP_QUERY(ps, val, tmp_20k_buf))
  	    q_status_message(SM_ORDER, 3, 5, tmp_20k_buf);
      }
+     else if(var == &ps->vars[V_INCFLDTIMEO]){
+ 	val = 5;
+ 	if(!revert)
+ 	  if(ps->VAR_INCFLDTIMEO && SVAR_TCP_QUERY(ps, val, tmp_20k_buf))
+ 	    q_status_message(SM_ORDER, 3, 5, tmp_20k_buf);
+     }
      else if(var == &ps->vars[V_RSHOPENTIMEO]){
  	val = 15;
  	if(!revert)
***************
*** 12655,12660 ****
--- 12847,12857 ----
  	}
      }
  #endif
+     else if(var == &ps->vars[V_INCOMING_FOLDERS_CHECK] && 
+ 	    F_OFF(F_ENABLE_FAST_RECENT, ps)){
+ 	ps->force_check_now = 1;
+ 	new_mail_incfolder(ps, MC_FORCECHECK);	/* yes, update it now */
+     }
      else if(var == &ps->vars[V_MAILCHECK]){
  	timeo = 15;
  	if(SVAR_MAILCHK(ps, timeo, tmp_20k_buf)){
***************
*** 12720,12725 ****
--- 12917,12927 ----
  			  (void *)var->current_val.p);
      }
  #endif
+     else if(var == &ps->vars[V_MAILDIR_LOCATION]){
+ 	if(var->current_val.p && var->current_val.p[0])
+ 	  mail_parameters(NULL, SET_MDINBOX,
+ 			  (void *)var->current_val.p);
+     }
      else if(revert && standard_radio_var(ps, var)){
  
  	cur_rule_value(var, TRUE, FALSE);
***************
*** 12766,12774 ****
      else if(revert && var == &ps->vars[V_SORT_KEY]){
  	int def_sort_rev;
  
! 	decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev);
  	ps->def_sort_rev = def_sort_rev;
      }
      else if(var == &ps->vars[V_THREAD_MORE_CHAR] ||
              var == &ps->vars[V_THREAD_EXP_CHAR] ||
              var == &ps->vars[V_THREAD_LASTREPLY_CHAR]){
--- 12968,12982 ----
      else if(revert && var == &ps->vars[V_SORT_KEY]){
  	int def_sort_rev;
  
! 	decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev, 0);
  	ps->def_sort_rev = def_sort_rev;
      }
+     else if(revert && var == &ps->vars[V_THREAD_SORT_KEY]){
+       int thread_def_sort_rev;
+ 
+       decode_sort(VAR_THREAD_SORT_KEY, &ps->thread_def_sort, &thread_def_sort_rev, 1);
+       ps->thread_def_sort_rev = thread_def_sort_rev;
+     }
      else if(var == &ps->vars[V_THREAD_MORE_CHAR] ||
              var == &ps->vars[V_THREAD_EXP_CHAR] ||
              var == &ps->vars[V_THREAD_LASTREPLY_CHAR]){
***************
*** 13462,13474 ****
  
      if(!(nonempty_patterns(rflags, &pstate) &&
           first_pattern(&pstate))){
! 	q_status_message(SM_ORDER, 0, 3,
  			 "No roles available. Use Setup/Rules to add roles.");
  	return(ret);
      }
  
! 
!     if(alt_compose){
  	menu_init_binding(&role_select_km,
  	  alt_compose == MC_FORWARD ? 'F' : alt_compose == MC_REPLY ? 'R' : 'C',
  	  MC_CHOICE,
--- 13670,13687 ----
  
      if(!(nonempty_patterns(rflags, &pstate) &&
           first_pattern(&pstate))){
! 	if (!ps->send_immediately)
! 	   q_status_message(SM_ORDER, 0, 3,
  			 "No roles available. Use Setup/Rules to add roles.");
+ 	else{
+ 	   printf("No roles available. Use Setup/Rules to add roles.");
+ 	   exit(-1);
+ 	}
  	return(ret);
      }
  
!     if (!ps->send_immediately){
!       if(alt_compose){
  	menu_init_binding(&role_select_km,
  	  alt_compose == MC_FORWARD ? 'F' : alt_compose == MC_REPLY ? 'R' : 'C',
  	  MC_CHOICE,
***************
*** 13478,13498 ****
  	  DEFAULT_KEY);
  	menu_add_binding(&role_select_km, ctrl('J'), MC_CHOICE);
  	menu_add_binding(&role_select_km, ctrl('M'), MC_CHOICE);
!     }
!     else{
  	menu_init_binding(&role_select_km, 'S', MC_CHOICE, "S", "[Select]",
  			  DEFAULT_KEY);
  	menu_add_binding(&role_select_km, ctrl('J'), MC_CHOICE);
  	menu_add_binding(&role_select_km, ctrl('M'), MC_CHOICE);
!     }
  
!     if(alt_compose){
  	helptitle = "HELP FOR SELECTING A ROLE TO COMPOSE AS";
  	help      = h_role_select;
!     }
!     else{
  	helptitle = "HELP FOR SELECTING A ROLE NICKNAME";
  	help      = h_role_nick_select;
      }
  
      for(pat = first_pattern(&pstate);
--- 13691,13712 ----
  	  DEFAULT_KEY);
  	menu_add_binding(&role_select_km, ctrl('J'), MC_CHOICE);
  	menu_add_binding(&role_select_km, ctrl('M'), MC_CHOICE);
!       }
!       else{
  	menu_init_binding(&role_select_km, 'S', MC_CHOICE, "S", "[Select]",
  			  DEFAULT_KEY);
  	menu_add_binding(&role_select_km, ctrl('J'), MC_CHOICE);
  	menu_add_binding(&role_select_km, ctrl('M'), MC_CHOICE);
!       }
  
!       if(alt_compose){
  	helptitle = "HELP FOR SELECTING A ROLE TO COMPOSE AS";
  	help      = h_role_select;
!       }
!       else{
  	helptitle = "HELP FOR SELECTING A ROLE NICKNAME";
  	help      = h_role_nick_select;
+       }
      }
  
      for(pat = first_pattern(&pstate);
***************
*** 17616,17622 ****
  	
  	pval = PVAL(&sort_act_var, ew);
  	if(pval)
! 	  decode_sort(pval, &def_sort, &def_sort_rev);
  
  	/* allow user to set their default sort order */
  	new_confline(&ctmp)->var = &sort_act_var;
--- 17830,17836 ----
  	
  	pval = PVAL(&sort_act_var, ew);
  	if(pval)
! 	  decode_sort(pval, &def_sort, &def_sort_rev, 0);
  
  	/* allow user to set their default sort order */
  	new_confline(&ctmp)->var = &sort_act_var;
***************
*** 17626,17632 ****
  	ctmp->tool	      = role_sort_tool;
  	ctmp->valoffset	      = 12;
  	ctmp->varmem	      = -1;
! 	ctmp->value	      = generalized_sort_pretty_value(ps, ctmp, 0);
  
  	for(j = 0; j < 2; j++){
  	    for(i = 0; ps->sort_types[i] != EndofList; i++){
--- 17840,17846 ----
  	ctmp->tool	      = role_sort_tool;
  	ctmp->valoffset	      = 12;
  	ctmp->varmem	      = -1;
! 	ctmp->value	      = generalized_sort_pretty_value(ps, ctmp, 0, 0);
  
  	for(j = 0; j < 2; j++){
  	    for(i = 0; ps->sort_types[i] != EndofList; i++){
***************
*** 17638,17644 ****
  		ctmp->valoffset	      = 12;
  		ctmp->varmem	      = i + (j * EndofList);
  		ctmp->value	      = generalized_sort_pretty_value(ps, ctmp,
! 								      0);
  	    }
  	}
  
--- 17852,17858 ----
  		ctmp->valoffset	      = 12;
  		ctmp->varmem	      = i + (j * EndofList);
  		ctmp->value	      = generalized_sort_pretty_value(ps, ctmp,
! 								      0, 0);
  	    }
  	}
  
***************
*** 18494,18500 ****
  	  (*result)->patgrp->stat_8bitsubj = PAT_STAT_EITHER;
  
  	if(sort_act){
! 	    decode_sort(sort_act, &def_sort, &def_sort_rev);
  	    (*result)->action->sort_is_set = 1;
  	    (*result)->action->sortorder = def_sort;
  	    (*result)->action->revsort = (def_sort_rev ? 1 : 0);
--- 18708,18714 ----
  	  (*result)->patgrp->stat_8bitsubj = PAT_STAT_EITHER;
  
  	if(sort_act){
! 	    decode_sort(sort_act, &def_sort, &def_sort_rev, 0);
  	    (*result)->action->sort_is_set = 1;
  	    (*result)->action->sortorder = def_sort;
  	    (*result)->action->revsort = (def_sort_rev ? 1 : 0);
***************
*** 20877,20882 ****
--- 21091,21101 ----
  	    if(apval)
  	      *apval = (role && role->nick) ? cpystr(role->nick) : NULL;
  
+ 	    if (ps_global->role)
+                 fs_give((void **)&ps_global->role);  
+ 	    if (role && role->nick)
+ 		ps_global->role = cpystr(role->nick);
+ 
  	    if((*cl)->value)
  	      fs_give((void **)&((*cl)->value));
  
***************
*** 23007,23012 ****
--- 23226,23232 ----
      set_color_val(&vars[V_IND_REC_FORE_COLOR], 0);
      set_color_val(&vars[V_IND_UNS_FORE_COLOR], 0);
      set_color_val(&vars[V_SIGNATURE_FORE_COLOR], 0);
+     set_color_val(&vars[V_SPECIAL_TEXT_FORE_COLOR], 0);
  
      set_current_val(&ps->vars[V_VIEW_HDR_COLORS], TRUE, TRUE);
      set_custom_hdr_colors(ps);
***************
*** 23556,23558 ****
--- 23776,23780 ----
      return(TRUE);
  }
  #endif	/* _WINDOWS */
+ 
+ #include "rules.c"
diff -rc pine4.61/pine/pine.c pine4.61.I.USE/pine/pine.c
*** pine4.61/pine/pine.c	Wed Jul 14 11:17:13 2004
--- pine4.61.I.USE/pine/pine.c	Fri Jul 16 11:56:15 2004
***************
*** 251,256 ****
--- 251,257 ----
      pine_state                 = (struct pine *)fs_get(sizeof (struct pine));
      memset((void *)pine_state, 0, sizeof(struct pine));
      ps_global                  = pine_state;
+     ps_global->thread_def_sort = SortDate;
      ps_global->def_sort        = SortArrival;
      ps_global->sort_types[0]   = SortSubject;
      ps_global->sort_types[1]   = SortArrival;
***************
*** 263,268 ****
--- 264,271 ----
      ps_global->sort_types[8]   = SortScore;
      ps_global->sort_types[9]   = SortThread;
      ps_global->sort_types[10]   = EndofList;
+     ps_global->force_check_now = 1;
+     ps_global->delay	       = 1;
      ps_global->atmts           = (ATTACH_S *) fs_get(sizeof(ATTACH_S));
      ps_global->atmts_allocated = 1;
      ps_global->atmts->description = NULL;
***************
*** 341,347 ****
      pine_args(pine_state, argc, argv, &args);
  
  #ifndef	_WINDOWS
!     if(!isatty(0)){
  	/*
  	 * monkey with descriptors so our normal tty i/o routines don't
  	 * choke...
--- 344,350 ----
      pine_args(pine_state, argc, argv, &args);
  
  #ifndef	_WINDOWS
!     if((!pine_state->send_immediately) && !isatty(0)){
  	/*
  	 * monkey with descriptors so our normal tty i/o routines don't
  	 * choke...
***************
*** 371,376 ****
--- 374,380 ----
      mail_parameters(NULL, SET_TIMEOUT, (void *) pine_tcptimeout);
      /* could be TO_BAIL_THRESHOLD, 15 seems more appropriate for now */
      pine_state->tcp_query_timeout = 15;
+     pine_state->incfld_timeout	  =  5;
  
      mail_parameters(NULL, SET_SENDCOMMAND, (void *) pine_imap_cmd_happened);
      mail_parameters(NULL, SET_FREESTREAMSPAREP, (void *) sp_free_callback);
***************
*** 504,509 ****
--- 508,518 ----
  	ps_global->s_pool.max_remstream));
  
      init_vars(pine_state);
+     if (args.action == aaFolder && !args.data.folder &&
+                 ps_global->send_immediately){
+         printf("No value for To: field specified\n");
+     exit(-1);
+     }
  
      set_collation(F_OFF(F_DISABLE_SETLOCALE_COLLATE, ps_global),
  		  F_ON(F_ENABLE_SETLOCALE_CTYPE, ps_global));
***************
*** 710,715 ****
--- 719,725 ----
          
  
      /*--- output side ---*/
+     if (!ps_global->send_immediately){
      rv = config_screen(&(pine_state->ttyo));
  #if !defined(DOS) && !defined(OS2)	/* always succeeds under DOS! */
      if(rv){
***************
*** 734,739 ****
--- 744,752 ----
          exit(-1);
      }
  #endif
+     }
+     else
+      fake_config_screen(&(pine_state->ttyo));
  
      if(F_ON(F_BLANK_KEYMENU,ps_global))
        FOOTER_ROWS(ps_global) = 1;
***************
*** 780,786 ****
  	goodnight_gracey(pine_state, exit_val);
      }
  
!     if(args.action == aaFolder
         && (pine_state->first_time_user || pine_state->show_new_version)){
  	pine_state->mangled_header = 1;
  	show_main_screen(pine_state, 0, FirstMenu, &main_keymenu, 0,
--- 793,799 ----
  	goodnight_gracey(pine_state, exit_val);
      }
  
!     if(!pine_state->send_immediately && args.action == aaFolder
         && (pine_state->first_time_user || pine_state->show_new_version)){
  	pine_state->mangled_header = 1;
  	show_main_screen(pine_state, 0, FirstMenu, &main_keymenu, 0,
***************
*** 934,939 ****
--- 947,957 ----
          int	    len, good_addr = 1;
  	int	    exit_val = 0;
  	BUILDER_ARG fcc;
+         ACTION_S  *role = NULL;
+ 
+         if (pine_state->in_init_seq && pine_state->send_immediately &&
+               ((char) pine_state->free_initial_cmds[0] == '#'))
+             role_select_screen(pine_state, &role, 1);
  
  	if(pine_state->in_init_seq){
  	    pine_state->in_init_seq = pine_state->save_in_init_seq = 0;
***************
*** 969,975 ****
  	  memset(&fcc, 0, sizeof(fcc));
  
  	if(good_addr){
! 	    compose_mail(addr, fcc.tptr, NULL,
  			 args.data.mail.attachlist, stdin_getc);
  	}
  	else{
--- 987,993 ----
  	  memset(&fcc, 0, sizeof(fcc));
  
  	if(good_addr){
! 	    compose_mail(addr, fcc.tptr, role,
  			 args.data.mail.attachlist, stdin_getc);
  	}
  	else{
***************
*** 1002,1007 ****
--- 1020,1026 ----
              
          pine_state->mail_stream    = NULL;
          pine_state->mangled_screen = 1;
+         pine_state->subject        = NULL;
  
  	if(args.action == aaURL){
  	    url_tool_t f;
***************
*** 1077,1082 ****
--- 1096,1102 ----
  		"mail folder");
          }
  
+        if (!pine_state->send_immediately)
          fflush(stdout);
  
  	if(pine_state->in_init_seq){
***************
*** 3121,3127 ****
  {
      int quit = 0;
  
!     dprint(1, (debugfile, "\n\n    ---- QUIT SCREEN ----\n"));    
  
      if(F_ON(F_CHECK_MAIL_ONQUIT,ps_global)
         && new_mail(1, VeryBadTime, NM_STATUS_MSG | NM_DEFER_SORT) > 0
--- 3141,3148 ----
  {
      int quit = 0;
  
!     dprint(1, (debugfile, "\n\n    ---- QUIT SCREEN ----\n"));
!     ps_global->in_pico = 1; /* we are leaving anyway */
  
      if(F_ON(F_CHECK_MAIL_ONQUIT,ps_global)
         && new_mail(1, VeryBadTime, NM_STATUS_MSG | NM_DEFER_SORT) > 0
***************
*** 3166,3171 ****
--- 3187,3193 ----
      extern KBESC_T *kbesc;
  
      dprint(2, (debugfile, "goodnight_gracey:\n"));    
+     sprintf(pine_state->cur_folder, pine_state->inbox_name);
  
      for(i = 0; i < ps_global->s_pool.nstream; i++){
  	m = ps_global->s_pool.streams[i];
***************
*** 3301,3306 ****
--- 3323,3330 ----
      free_saved_query_parameters();
  #endif
  
+     if(pine_state->subject != NULL)
+       fs_give((void **)&pine_state->subject);
      if(pine_state->hostname != NULL)
        fs_give((void **)&pine_state->hostname);
      if(pine_state->localdomain != NULL)
***************
*** 3906,3919 ****
  
  	was_invisible = (mc->spare || mc->spare4) ? 1 : 0;
  
  	if(chk_thrd_cnt = ((msgs->visible_threads >= 0L)
  	   && THRD_INDX_ENABLED() && (f & MN_HIDE) && (mc->spare != v))){
- 	    thrd = fetch_thread(stream, rawno);
  	    if(thrd && thrd->top){
! 		if(thrd->top == thrd->rawno)
  		  topthrd = thrd;
  		else
! 		  topthrd = fetch_thread(stream, thrd->top);
  	    }
  
  	    if(topthrd){
--- 3930,3944 ----
  
  	was_invisible = (mc->spare || mc->spare4) ? 1 : 0;
  
+         thrd = fetch_thread(stream, rawno);
+ 
  	if(chk_thrd_cnt = ((msgs->visible_threads >= 0L)
  	   && THRD_INDX_ENABLED() && (f & MN_HIDE) && (mc->spare != v))){
  	    if(thrd && thrd->top){
! 		if(top_thread(stream,thrd->top) == thrd->rawno)
  		  topthrd = thrd;
  		else
! 		  topthrd = fetch_thread(stream, top_thread(stream,thrd->top));
  	    }
  
  	    if(topthrd){
diff -rc pine4.61/pine/pine.h pine4.61.I.USE/pine/pine.h
*** pine4.61/pine/pine.h	Wed Jul 14 17:25:12 2004
--- pine4.61.I.USE/pine/pine.h	Thu Aug 19 13:30:25 2004
***************
*** 229,234 ****
--- 229,237 ----
  #ifndef DF_INCOMING_STARTUP
  #define DF_INCOMING_STARTUP	"first-unseen"
  #endif
+ #ifndef DF_INCOMING_RULE
+ #define DF_INCOMING_RULE	"automatic"
+ #endif
  #ifndef DF_PRUNING_RULE
  #define DF_PRUNING_RULE		"ask-ask"
  #endif
***************
*** 596,601 ****
--- 599,605 ----
  		, V_SMTP_SERVER
  		, V_NNTP_SERVER
  		, V_INBOX_PATH
+              	, V_INCOMING_FOLDERS_CHECK
  		, V_ARCHIVED_FOLDERS
  		, V_PRUNED_FOLDERS
  		, V_DEFAULT_FCC
***************
*** 616,625 ****
--- 620,631 ----
  		, V_SAVED_MSG_NAME_RULE
  		, V_FCC_RULE
  		, V_SORT_KEY
+ 		, V_THREAD_SORT_KEY
  		, V_AB_SORT_RULE
  		, V_FLD_SORT_RULE
  		, V_GOTO_DEFAULT_RULE
  		, V_INCOMING_STARTUP
+ 		, V_INCOMING_RULE
  		, V_PRUNING_RULE
  		, V_REOPEN_RULE
  		, V_THREAD_DISP_STYLE
***************
*** 627,636 ****
--- 633,656 ----
  		, V_THREAD_MORE_CHAR
  		, V_THREAD_EXP_CHAR
  		, V_THREAD_LASTREPLY_CHAR
+ 		, V_THREAD_DISP_STYLE_RULES
+ 		, V_THREAD_INDEX_STYLE_RULES
+ 		, V_COMPOSE_RULES
+ 		, V_FORWARD_RULES
+ 		, V_INDEX_RULES
+ 		, V_REPLACE_RULES
+ 		, V_REPLY_INDENT_RULES
+ 		, V_REPLY_LEADIN_RULES
+ 		, V_RESUB_RULES
+ 		, V_SAVE_RULES
+ 		, V_SMTP_RULES
+ 		, V_SORT_RULES
+ 		, V_STARTUP_RULES
  		, V_CHAR_SET
  		, V_EDITOR
  		, V_SPELLER
  		, V_FILLCOL
+ 		, V_SPECIAL_TEXT
  		, V_REPLY_STRING
  		, V_REPLY_INTRO
  		, V_EMPTY_HDR_MSG
***************
*** 661,666 ****
--- 681,687 ----
  		, V_NEWSRC_PATH
  		, V_NEWS_ACTIVE_PATH
  		, V_NEWS_SPOOL_DIR
+ 		, V_MAILDIR_LOCATION
  		, V_UPLOAD_CMD
  		, V_UPLOAD_CMD_PREFIX
  		, V_DOWNLOAD_CMD
***************
*** 694,699 ****
--- 715,721 ----
  		, V_TCPREADWARNTIMEO
  		, V_TCPWRITEWARNTIMEO
  		, V_TCPQUERYTIMEO
+ 		, V_INCFLDTIMEO
  		, V_RSHCMD
  		, V_RSHPATH
  		, V_RSHOPENTIMEO
***************
*** 755,760 ****
--- 777,784 ----
  		, V_QUOTE3_BACK_COLOR
  		, V_SIGNATURE_FORE_COLOR
  		, V_SIGNATURE_BACK_COLOR
+ 		, V_SPECIAL_TEXT_FORE_COLOR
+ 		, V_SPECIAL_TEXT_BACK_COLOR
  		, V_PROMPT_FORE_COLOR
  		, V_PROMPT_BACK_COLOR
  		, V_IND_PLUS_FORE_COLOR
***************
*** 808,813 ****
--- 832,839 ----
  #define VAR_INBOX_PATH		     vars[V_INBOX_PATH].current_val.p
  #define GLO_INBOX_PATH		     vars[V_INBOX_PATH].global_val.p
  #define VAR_INCOMING_FOLDERS	     vars[V_INCOMING_FOLDERS].current_val.l
+ #define VAR_INCOMING_FOLDERS_CHECK   vars[V_INCOMING_FOLDERS_CHECK].current_val.p
+ #define GLO_INCOMING_FOLDERS_CHECK   vars[V_INCOMING_FOLDERS_CHECK].global_val.p
  #define VAR_FOLDER_SPEC		     vars[V_FOLDER_SPEC].current_val.l
  #define GLO_FOLDER_SPEC		     vars[V_FOLDER_SPEC].global_val.l
  #define VAR_NEWS_SPEC		     vars[V_NEWS_SPEC].current_val.l
***************
*** 862,877 ****
--- 888,945 ----
  #define VAR_SORT_KEY		     vars[V_SORT_KEY].current_val.p
  #define GLO_SORT_KEY		     vars[V_SORT_KEY].global_val.p
  #define COM_SORT_KEY		     vars[V_SORT_KEY].cmdline_val.p
+ #define VAR_THREAD_SORT_KEY	     vars[V_THREAD_SORT_KEY].current_val.p
+ #define GLO_THREAD_SORT_KEY	     vars[V_THREAD_SORT_KEY].global_val.p
+ #define COM_THREAD_SORT_KEY	     vars[V_THREAD_SORT_KEY].cmdline_val.p
  #define VAR_AB_SORT_RULE	     vars[V_AB_SORT_RULE].current_val.p
  #define GLO_AB_SORT_RULE	     vars[V_AB_SORT_RULE].global_val.p
  #define VAR_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].current_val.p
  #define GLO_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].global_val.p
+ #define VAR_COMPOSE_RULES	     vars[V_COMPOSE_RULES].current_val.l
+ #define GLO_COMPOSE_RULES	     vars[V_COMPOSE_RULES].global_val.l
+ #define USR_COMPOSE_RULES	     vars[V_COMPOSE_RULES].user_val.l
+ #define VAR_FORWARD_RULES	     vars[V_FORWARD_RULES].current_val.l
+ #define GLO_FORWARD_RULES	     vars[V_FORWARD_RULES].global_val.l
+ #define USR_FORWARD_RULES	     vars[V_FORWARD_RULES].user_val.l
+ #define VAR_INDEX_RULES		     vars[V_INDEX_RULES].current_val.l
+ #define GLO_INDEX_RULES		     vars[V_INDEX_RULES].global_val.l
+ #define USR_INDEX_RULES		     vars[V_INDEX_RULES].user_val.l
+ #define VAR_REPLACE_RULES	     vars[V_REPLACE_RULES].current_val.l
+ #define GLO_REPLACE_RULES	     vars[V_REPLACE_RULES].global_val.l
+ #define USR_REPLACE_RULES	     vars[V_REPLACE_RULES].user_val.l
+ #define VAR_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].current_val.l
+ #define GLO_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].global_val.l
+ #define USR_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].user_val.l
+ #define VAR_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].current_val.l
+ #define GLO_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].global_val.l
+ #define USR_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].user_val.l
+ #define VAR_RESUB_RULES		     vars[V_RESUB_RULES].current_val.l
+ #define GLO_RESUB_RULES		     vars[V_RESUB_RULES].global_val.l
+ #define USR_RESUB_RULES		     vars[V_RESUB_RULES].user_val.l
+ #define VAR_THREAD_DISP_STYLE_RULES  vars[V_THREAD_DISP_STYLE_RULES].current_val.l
+ #define GLO_THREAD_DISP_STYLE_RULES  vars[V_THREAD_DISP_STYLE_RULES].global_val.l
+ #define VAR_THREAD_INDEX_STYLE_RULES vars[V_THREAD_INDEX_STYLE_RULES].current_val.l
+ #define GLO_THREAD_INDEX_STYLE_RULES vars[V_THREAD_INDEX_STYLE_RULES].global_val.l
+ #define VAR_SAVE_RULES		     vars[V_SAVE_RULES].current_val.l
+ #define GLO_SAVE_RULES		     vars[V_SAVE_RULES].global_val.l
+ #define USR_SAVE_RULES		     vars[V_SAVE_RULES].user_val.l
+ #define VAR_SMTP_RULES		     vars[V_SMTP_RULES].current_val.l
+ #define GLO_SMTP_RULES		     vars[V_SMTP_RULES].global_val.l
+ #define USR_SMTP_RULES		     vars[V_SMTP_RULES].user_val.l
+ #define VAR_SORT_RULES		     vars[V_SORT_RULES].current_val.l
+ #define GLO_SORT_RULES		     vars[V_SORT_RULES].global_val.l
+ #define USR_SORT_RULES		     vars[V_SORT_RULES].user_val.l
+ #define VAR_STARTUP_RULES	     vars[V_STARTUP_RULES].current_val.l
+ #define GLO_STARTUP_RULES	     vars[V_STARTUP_RULES].global_val.l
+ #define USR_STARTUP_RULES	     vars[V_STARTUP_RULES].user_val.l
  #define VAR_CHAR_SET		     vars[V_CHAR_SET].current_val.p
  #define GLO_CHAR_SET		     vars[V_CHAR_SET].global_val.p
  #define VAR_EDITOR		     vars[V_EDITOR].current_val.l
  #define GLO_EDITOR		     vars[V_EDITOR].global_val.l
  #define VAR_SPELLER		     vars[V_SPELLER].current_val.p
  #define GLO_SPELLER		     vars[V_SPELLER].global_val.p
+ #define VAR_SPECIAL_TEXT	     vars[V_SPECIAL_TEXT].current_val.l
+ #define GLO_SPECIAL_TEXT	     vars[V_SPECIAL_TEXT].global_val.l
  #define VAR_FILLCOL		     vars[V_FILLCOL].current_val.p
  #define GLO_FILLCOL		     vars[V_FILLCOL].global_val.p
  #define VAR_DEADLETS		     vars[V_DEADLETS].current_val.p
***************
*** 951,956 ****
--- 1019,1026 ----
  #define GLO_NEWS_ACTIVE_PATH	     vars[V_NEWS_ACTIVE_PATH].global_val.p
  #define VAR_NEWS_SPOOL_DIR	     vars[V_NEWS_SPOOL_DIR].current_val.p
  #define GLO_NEWS_SPOOL_DIR	     vars[V_NEWS_SPOOL_DIR].global_val.p
+ #define VAR_MAILDIR_LOCATION	     vars[V_MAILDIR_LOCATION].current_val.p
+ #define GLO_MAILDIR_LOCATION	     vars[V_MAILDIR_LOCATION].global_val.p
  #define VAR_DISABLE_DRIVERS	     vars[V_DISABLE_DRIVERS].current_val.l
  #define VAR_DISABLE_AUTHS	     vars[V_DISABLE_AUTHS].current_val.l
  #define VAR_REMOTE_ABOOK_METADATA    vars[V_REMOTE_ABOOK_METADATA].current_val.p
***************
*** 1000,1005 ****
--- 1070,1076 ----
  #define VAR_TCPREADWARNTIMEO	     vars[V_TCPREADWARNTIMEO].current_val.p
  #define VAR_TCPWRITEWARNTIMEO	     vars[V_TCPWRITEWARNTIMEO].current_val.p
  #define VAR_TCPQUERYTIMEO	     vars[V_TCPQUERYTIMEO].current_val.p
+ #define VAR_INCFLDTIMEO		     vars[V_INCFLDTIMEO].current_val.p
  #define VAR_RSHOPENTIMEO	     vars[V_RSHOPENTIMEO].current_val.p
  #define VAR_RSHPATH		     vars[V_RSHPATH].current_val.p
  #define VAR_RSHCMD		     vars[V_RSHCMD].current_val.p
***************
*** 1010,1015 ****
--- 1081,1088 ----
  #define VAR_BROWSER		     vars[V_BROWSER].current_val.l
  #define VAR_INCOMING_STARTUP	     vars[V_INCOMING_STARTUP].current_val.p
  #define GLO_INCOMING_STARTUP	     vars[V_INCOMING_STARTUP].global_val.p
+ #define VAR_INCOMING_RULE	     vars[V_INCOMING_RULE].current_val.p
+ #define GLO_INCOMING_RULE	     vars[V_INCOMING_RULE].global_val.p
  #define VAR_PRUNING_RULE	     vars[V_PRUNING_RULE].current_val.p
  #define GLO_PRUNING_RULE	     vars[V_PRUNING_RULE].global_val.p
  #define VAR_REOPEN_RULE		     vars[V_REOPEN_RULE].current_val.p
***************
*** 1085,1090 ****
--- 1158,1165 ----
  #define VAR_QUOTE3_BACK_COLOR	     vars[V_QUOTE3_BACK_COLOR].current_val.p
  #define VAR_SIGNATURE_FORE_COLOR     vars[V_SIGNATURE_FORE_COLOR].current_val.p
  #define VAR_SIGNATURE_BACK_COLOR     vars[V_SIGNATURE_BACK_COLOR].current_val.p
+ #define VAR_SPECIAL_TEXT_FORE_COLOR  vars[V_SPECIAL_TEXT_FORE_COLOR].current_val.p
+ #define VAR_SPECIAL_TEXT_BACK_COLOR  vars[V_SPECIAL_TEXT_BACK_COLOR].current_val.p
  #define VAR_PROMPT_FORE_COLOR	     vars[V_PROMPT_FORE_COLOR].current_val.p
  #define VAR_PROMPT_BACK_COLOR	     vars[V_PROMPT_BACK_COLOR].current_val.p
  #define VAR_VIEW_HDR_COLORS	     vars[V_VIEW_HDR_COLORS].current_val.l
***************
*** 1114,1119 ****
--- 1189,1195 ----
  	F_FULL_AUTO_EXPUNGE,
  	F_EXPUNGE_MANUALLY,
  	F_AUTO_READ_MSGS,
+ 	F_AUTO_READ_MSGS_RULES,
  	F_AUTO_FCC_ONLY,
  	F_READ_IN_NEWSRC_ORDER,
  	F_SELECT_WO_CONFIRM,
***************
*** 1128,1133 ****
--- 1204,1210 ----
  	F_ALT_ED_NOW,
  	F_SHOW_DELAY_CUE,
  	F_AUTO_OPEN_NEXT_UNREAD,
+ 	F_AUTO_CIRCULAR_TAB,
  	F_SELECTED_SHOWN_BOLD,
  	F_QUOTE_ALL_FROMS,
  	F_AUTO_INCLUDE_IN_REPLY,
***************
*** 1144,1149 ****
--- 1221,1228 ----
  	F_DISABLE_PIPES_IN_TEMPLATES,
  	F_ATTACHMENTS_IN_REPLY,
  	F_ENABLE_INCOMING,
+ 	F_ENABLE_INCOMING_CHECK,
+ 	F_ENABLE_INCOMING_RECHECK,
  	F_NO_NEWS_VALIDATION,
  	F_QUELL_EXTRA_POST_PROMPT,
  	F_DISABLE_TAKE_LASTFIRST,
***************
*** 1169,1174 ****
--- 1248,1254 ----
  	F_AUTO_REPLY_TO,
  	F_VERBOSE_POST,
  	F_FCC_ON_BOUNCE,
+ 	F_USE_DOMAIN_NAME,
  	F_SEND_WO_CONFIRM,
  	F_USE_SENDER_NOT_X,
  	F_BLANK_KEYMENU,
***************
*** 1271,1280 ****
--- 1351,1362 ----
  	F_MAILDROPS_PRESERVE_STATE,
  	F_EXPOSE_HIDDEN_CONFIG,
  	F_ALT_COMPOSE_MENU,
+ 	F_ALT_REPLY_MENU,
  	F_ALT_ROLE_MENU,
  	F_ALWAYS_SPELL_CHECK,
  	F_QUELL_TIMEZONE,
  	F_COLOR_LINE_IMPORTANT,
+ 	F_ENHANCED_THREAD,
  	F_SLASH_COLL_ENTIRE,
  	F_ENABLE_FULL_HDR_AND_TEXT,
  	F_QUELL_FULL_HDR_RESET,
***************
*** 1501,1506 ****
--- 1583,1595 ----
  #define	IS_NOTSET			7	/* for reset version */
  
  /*
+  * Incoming check rules
+  */
+ #define	IC_AUTO		0
+ #define	IC_MAN_AUTO	1
+ #define	IC_MAN		2
+ 
+ /*
   * Pruning rules. If these grow, widen pruning_rule.
   */
  #define	PRUNE_ASK_AND_ASK		0
***************
*** 1782,1787 ****
--- 1871,1880 ----
  #define	SVAR_TCP_QUERY(ps, n, e) strtoval((ps)->VAR_TCPQUERYTIMEO, 	  \
  					 &(n), 5, 30000, 0, (e),	  \
  					"Tcp-Query-Timeout")
+ #define SVAR_INCFLDQUERY(ps, n, e) strtoval((ps)->VAR_INCFLDTIMEO,	\
+                                         &(n), 2, 60, 0, (e),		\
+                                        "Inc-fld-timeout")
+ 
  #define	SVAR_RSH_OPEN(ps, n, e)	strtoval((ps)->VAR_RSHOPENTIMEO, 	  \
  					 &(n), 5, 30000, 0, (e),	  \
  					"Rsh-Open-Timeout")
***************
*** 1882,1888 ****
  	      SortSubject2, SortScore, SortThread, EndofList}   SortOrder;
  
  #define	refresh_sort(S,M,F)	sort_folder((S), (M), mn_get_sort(M), \
! 					    mn_get_revsort(M), (F))
  
  /*
   * The two structs below hold all knowledge regarding
--- 1975,1981 ----
  	      SortSubject2, SortScore, SortThread, EndofList}   SortOrder;
  
  #define	refresh_sort(S,M,F)	sort_folder((S), (M), mn_get_sort(M), \
! 					    mn_get_revsort(M), (F), 1)
  
  /*
   * The two structs below hold all knowledge regarding
***************
*** 1925,1937 ****
  typedef struct pine_thrd {
      unsigned long rawno;	/* raw msgno of this message		*/
      unsigned long thrdno;	/* thread number			*/
-     unsigned long flags;
      unsigned long next;		/* msgno of first reply to us		*/
      unsigned long branch;	/* like THREADNODE branch, next replier	*/
      unsigned long parent;	/* message that this is a reply to	*/
      unsigned long nextthd;	/* next thread, only tops have this	*/
      unsigned long prevthd;	/* previous thread, only tops have this	*/
      unsigned long top;		/* top of this thread			*/
      unsigned long head;		/* head of the whole thread list	*/
  } PINETHRD_S;
  
--- 2018,2030 ----
  typedef struct pine_thrd {
      unsigned long rawno;	/* raw msgno of this message		*/
      unsigned long thrdno;	/* thread number			*/
      unsigned long next;		/* msgno of first reply to us		*/
      unsigned long branch;	/* like THREADNODE branch, next replier	*/
      unsigned long parent;	/* message that this is a reply to	*/
      unsigned long nextthd;	/* next thread, only tops have this	*/
      unsigned long prevthd;	/* previous thread, only tops have this	*/
      unsigned long top;		/* top of this thread			*/
+     unsigned long toploose;	/* top of this thread, if is loose	*/
      unsigned long head;		/* head of the whole thread list	*/
  } PINETHRD_S;
  
***************
*** 2511,2520 ****
--- 2604,2619 ----
      unsigned	    scanned:1;			/* scanned by c-client	      */
      unsigned	    parent:1;			/* visit parent		      */
      unsigned	    selected:1;			/* selected by user	      */
+     unsigned	    user_selected:1;		/* selected by user (not Pine)*/
      unsigned	    subscribed:1;		/* selected by user	      */
      unsigned long   varhash;			/* hash of var for incoming   */
      unsigned long   uidvalidity;		/* only for #move folder      */
      unsigned long   uidnext;			/* only for #move folder      */
+     int		    notified;			/* notified the change?	      */
+     long	    origrecent;			/* # recent messages in stream*/
+     long	    countrecent;		/* # recent messages displayed*/
+     long	    recent;			/* # recent messages adjusted */
+     long	    messages;			/* # messages		      */
      char	   *nickname;			/* folder's short name        */
      char	    name[1];			/* folder's name              */
  } FOLDER_S;
***************
*** 2533,2543 ****
  	      iTime24, iTime12,
  	      iCurDate, iCurDateIso, iCurDateIsoS, iCurTime24, iCurTime12,
  	      iMessNo, iAtt, iMsgID, iSubject, iSubjKey,
! 	      iSize, iSizeComma, iSizeNarrow, iDescripSize,
  	      iNewsAndTo, iToAndNews, iNewsAndRecips, iRecipsAndNews,
  	      iFromTo, iFromToNotNews, iFrom, iTo, iSender, iCc, iNews, iRecips,
  	      iMailbox, iAddress, iInit, iCursorPos,
  	      iDay2Digit, iMon2Digit, iYear2Digit,
  	      iSTime, iKSize,
  	      iRoleNick,
  	      iScore, iDayOfWeekAbb, iDayOfWeek,
--- 2632,2645 ----
  	      iTime24, iTime12,
  	      iCurDate, iCurDateIso, iCurDateIsoS, iCurTime24, iCurTime12,
  	      iMessNo, iAtt, iMsgID, iSubject, iSubjKey,
! 	      iSize, iSizeComma, iSizeNarrow, iDescripSize, iSizeThread,
  	      iNewsAndTo, iToAndNews, iNewsAndRecips, iRecipsAndNews,
  	      iFromTo, iFromToNotNews, iFrom, iTo, iSender, iCc, iNews, iRecips,
  	      iMailbox, iAddress, iInit, iCursorPos,
  	      iDay2Digit, iMon2Digit, iYear2Digit,
+ 	      iFolder, iFlag, iCollection, iRole,
+ 	      iNick, iAddressTo, iAddressCc, iAddressRecip, iBcc, iLcc, 
+ 	      iFfrom, iFadd,
  	      iSTime, iKSize,
  	      iRoleNick,
  	      iScore, iDayOfWeekAbb, iDayOfWeek,
***************
*** 2554,2565 ****
  } INDEX_PARSE_T;
  
  /* these are flags for the what_for field in INDEX_PARSE_T */
! #define FOR_NOTHING	0x00
! #define FOR_INDEX	0x01
! #define FOR_REPLY_INTRO	0x02
! #define FOR_TEMPLATE	0x04		/* or for signature */
! #define DELIM_USCORE	0x10
! #define DELIM_PAREN	0x20
  
  #define DEFAULT_REPLY_INTRO "default"
  
--- 2656,2678 ----
  } INDEX_PARSE_T;
  
  /* these are flags for the what_for field in INDEX_PARSE_T */
! #define FOR_NOTHING		0x0000
! #define FOR_INDEX		0x0001
! #define FOR_REPLY_INTRO		0x0002
! #define FOR_TEMPLATE		0x0004  /* or for signature */
! #define FOR_STARTUP 		0x0008  /* for rules */
! #define DELIM_USCORE  		0x0010
! #define DELIM_PAREN		0x0020
! #define FOR_SAVE      		0x0040  /* for rules */
! #define FOR_FOLDER    		0x0080  /* for rules */
! #define FOR_RULE      		0x0100  /* for rules */
! #define FOR_TRIM      		0x0200  /* for rules */
! #define FOR_RESUB     		0x0400  /* for rules */
! #define FOR_REPLACE   		0x0800  /* for rules */
! #define FOR_SORT      		0x1000  /* for rules */
! #define FOR_FLAG		0x2000  /* for rules */
! #define FOR_COMPOSE		0x4000  /* for rules */
! #define FOR_THREAD		0x8000	/* for rules */
  
  #define DEFAULT_REPLY_INTRO "default"
  
***************
*** 2921,2931 ****
--- 3034,3059 ----
  #define	MC_NOT		797
  #define	MC_COLLAPSE	798
  #define	MC_CHK_RECENT	799
+ #define MC_PRETHREAD	800
+ #define MC_CTHREAD	801
+ #define MC_OTHREAD	802
+ #define MC_KOLAPSE	803
+ #define MC_EXPTHREAD	804
+ #define MC_DELTHREAD	805
+ #define MC_UNDTHREAD	806
+ #define MC_SELTHREAD	807
+ #define MC_SSUTHREAD	808
+ #define MC_DSUTHREAD	809
+ #define MC_USUTHREAD	810
+ #define MC_SORTHREAD	811
+ #define MC_NEXTHREAD	812
  
  
  /*
   * Some standard Key/Command Bindings 
   */
+ #define MC_IFAUTOCHECK	812
+ #define MC_FORCECHECK		813
  #define	NULL_MENU	{NULL, NULL, {MC_NONE}, KS_NONE}
  #define	HELP_MENU	{"?", "Help", \
  			 {MC_HELP, 2, {'?',ctrl('G')}}, \
***************
*** 3604,3610 ****
  #define	HEX_CHAR1(C)	HEX_ARRAY[((C) & 0xf0) >> 4]
  #define	HEX_CHAR2(C)	HEX_ARRAY[(C) & 0xf]
  
! 
  
  
  /*------------------------------
--- 3732,3746 ----
  #define	HEX_CHAR1(C)	HEX_ARRAY[((C) & 0xf0) >> 4]
  #define	HEX_CHAR2(C)	HEX_ARRAY[(C) & 0xf]
  
! typedef struct extra_rule {
!         char *data;             /* The actual data entered by the user */
!         char *context;          /* Context in which we are looking for the rule */
! } EXTRA_RULES;
! 
! typedef struct rule {
!         char *result;           /* The result of the rule */
!         int number;     /* The number of the rule that succeded, -1 if not */   
! } RULE_RESULT;
  
  
  /*------------------------------
***************
*** 3753,3758 ****
--- 3889,3895 ----
      PrivateAffector *affector;
  } PrivateTop;
  
+ #define DF_THREAD_SORT_KEY  "thread"
  
  typedef enum {OpenFolder, SaveMessage, FolderMaint, GetFcc,
  		Subscribe, PostNews} FolderFun;
***************
*** 3867,3872 ****
--- 4004,4010 ----
      long     n;			/* number of chars seen                  */
      short    f1;		/* flags                                 */
      int	     f2;		/* second place for flags                */
+     int	     f3;		/* third place for flags		 */
      unsigned char t;		/* temporary char                        */
      char     *line;		/* place for temporary storage           */
      char     *linep;		/* pointer into storage space            */
***************
*** 4141,4150 ****
--- 4279,4300 ----
      MAILSTREAM  *mail_stream;		/* ptr to current folder stream */
      MSGNO_S	*msgmap;		/* ptr to current message map   */
  
+     char	*role;			/* role used when composing */
+     int		 exiting;
+ 
      unsigned     read_predicted:1;
  
      char         cur_folder[MAXPATH+1];
      char         last_unambig_folder[MAXPATH+1];
+     char        *last_message;
+     int          refresh_list;
+     int          in_pico;
+     int		 in_indx;
+     int		 in_fld_list;
+     int		 force_check_now;
+     int          checking_incfld;
+     int          incfld_timeout;
+     int		 delay;
      ATTACH_S    *atmts;
      int          atmts_allocated;
      int	         remote_abook_validity;	/* minutes, -1=never, 0=only on opens */
***************
*** 4168,4173 ****
--- 4318,4325 ----
      unsigned     unseen_in_view:1;
      unsigned     start_in_context:1;	/* start fldr_scrn in current cntxt */
      unsigned     def_sort_rev:1;	/* true if reverse sort is default  */ 
+     unsigned     thread_def_sort_rev:1; /* true if reverse sort is default in thread screen  */ 
+     unsigned     msgmap_thread_def_sort_rev:1; /* true if reverse sort is being used in thread screen  */ 
      unsigned     restricted:1;
      unsigned	 show_dot_names:1;
  
***************
*** 4179,4184 ****
--- 4331,4337 ----
      unsigned     titlebar_color_style:3;
      unsigned	 fld_sort_rule:3;
      unsigned	 inc_startup_rule:3;
+     unsigned	 inc_check_rule:2;
      unsigned	 pruning_rule:3;
      unsigned	 reopen_rule:4;
      unsigned	 goto_default_rule:3;
***************
*** 4267,4272 ****
--- 4420,4426 ----
      short	 init_context;
  
      int         *initial_cmds;         /* cmds to execute on startup */
+     int         *initial_cmds_backup;  /* backup to cmds to execute on startup */
      int         *free_initial_cmds;    /* used to free when done */
  
      char         c_client_error[300];  /* when nowhow_error is set and PARSE */
***************
*** 4304,4309 ****
--- 4458,4466 ----
      EditWhich	 ew_for_other_take;
  
      SortOrder    def_sort,	/* Default sort type */
+                  thread_def_sort, /* Default Sort Type in Thread Screen */
+                  thread_cur_sort, /* Current Sort Type in Thread Screen */
+                  msgmap_thread_sort,
  		 sort_types[22];
  
      int          last_expire_year, last_expire_month;
***************
*** 4314,4319 ****
--- 4471,4479 ----
  
      int		 composer_fillcol;
  
+     char	*subject;
+     int		 send_immediately;
+ 
      int          hours_to_timeout;
  
      int          tcp_query_timeout;
***************
*** 4457,4462 ****
--- 4617,4623 ----
  void	    gf_busy PROTO((FILTER_S *, int));
  void	    gf_nvtnl_local PROTO((FILTER_S *, int));
  void	    gf_local_nvtnl PROTO((FILTER_S *, int));
+ void	    gf_quote_test PROTO((FILTER_S *, int));
  void	    gf_line_test PROTO((FILTER_S *, int));
  void	   *gf_line_test_opt PROTO((linetest_t, void *));
  LT_INS_S  **gf_line_test_new_ins PROTO((LT_INS_S **, char *, char *, int));
***************
*** 4493,4504 ****
--- 4654,4670 ----
  char	   *folder_is_nick PROTO((char *, void *, int));
  char	   *next_folder PROTO((MAILSTREAM **, char *, char *,CONTEXT_S *,
  			       long *, int *));
+ char	   *next_folder_check PROTO((MAILSTREAM **, CONTEXT_S *, long *, long *,
+ 			       FOLDER_S *, int *));
  void	    init_inbox_mapping PROTO((char *, CONTEXT_S *));
  int	    news_build PROTO((char *, char **, char **, BUILDER_ARG *, int *));
  char	   *news_group_selector PROTO((char **));
  void	    free_newsgrp_cache PROTO(());
  char	   *context_edit_screen PROTO((struct pine *, char *, char *,
  				       char *, char *, char *));
+ void	    update_incoming_folder_data PROTO((MAILSTREAM *, CONTEXT_S *));
+ FOLDER_S   *incoming_folder_data PROTO((MAILSTREAM *, CONTEXT_S *));
+ int	    need_folder_report PROTO ((char *));
  SELECTED_S *new_selected PROTO((void));
  void	    free_selected PROTO((SELECTED_S **));
  int	    add_new_folder PROTO((CONTEXT_S *, EditWhich, int, char *, size_t,
***************
*** 4553,4559 ****
  int	    write_pinerc PROTO((struct pine *, EditWhich));
  int	    var_in_pinerc PROTO((char *));
  void	    free_pinerc_lines PROTO((PINERC_LINE **));
! int	    decode_sort PROTO((char *, SortOrder *, int *));
  void	    dump_global_conf PROTO((void));
  void	    dump_new_pinerc PROTO((char *));
  int	    set_variable PROTO((int, char *, int, int, EditWhich));
--- 4719,4725 ----
  int	    write_pinerc PROTO((struct pine *, EditWhich));
  int	    var_in_pinerc PROTO((char *));
  void	    free_pinerc_lines PROTO((PINERC_LINE **));
! int	    decode_sort PROTO((char *, SortOrder *, int *, int));
  void	    dump_global_conf PROTO((void));
  void	    dump_new_pinerc PROTO((char *));
  int	    set_variable PROTO((int, char *, int, int, EditWhich));
***************
*** 4582,4587 ****
--- 4748,4754 ----
  NAMEVAL_S  *titlebar_col_style PROTO((int));
  NAMEVAL_S  *fld_sort_rules PROTO((int));
  NAMEVAL_S  *incoming_startup_rules PROTO((int));
+ NAMEVAL_S  *incoming_check_rules PROTO((int));
  NAMEVAL_S  *startup_rules PROTO((int));
  NAMEVAL_S  *pruning_rules PROTO((int));
  NAMEVAL_S  *reopen_rules PROTO((int));
***************
*** 4624,4633 ****
  int	    set_mime_extension_by_type PROTO((char *, char *));
  
  /*---- mailcmd.c ----*/
  int	    process_cmd PROTO((struct pine *, MAILSTREAM *, MSGNO_S *,
  			       int, CmdWhere, int *));
  int	    apply_command PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int,
! 				 int, int));
  int	    menu_command PROTO((int, struct key_menu *));
  void	    menu_init_binding PROTO((struct key_menu *, int, int,
  				     char *, char *, int));
--- 4791,4801 ----
  int	    set_mime_extension_by_type PROTO((char *, char *));
  
  /*---- mailcmd.c ----*/
+ MAILSTREAM *find_open_stream PROTO((void));
  int	    process_cmd PROTO((struct pine *, MAILSTREAM *, MSGNO_S *,
  			       int, CmdWhere, int *));
  int	    apply_command PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int,
! 				 int, int, int));
  int	    menu_command PROTO((int, struct key_menu *));
  void	    menu_init_binding PROTO((struct key_menu *, int, int,
  				     char *, char *, int));
***************
*** 4669,4674 ****
--- 4837,4843 ----
  char	   *get_uname PROTO((char *, char *, int));
  char	   *build_updown_cmd PROTO((char *, char *, char *, char*));
  int	    file_lister PROTO((char *, char *, int, char *, int, int, int));
+ unsigned long rules_cursor_pos PROTO((MAILSTREAM *));
  int	    display_folder_list PROTO((CONTEXT_S **, char *, int,
  				       int (*) PROTO((struct pine *,
  						      CONTEXT_S **,
***************
*** 4693,4698 ****
--- 4862,4868 ----
  #endif
  
  /*--- mailindx.c ---*/
+ void	    insert_pattern_in_string PROTO((char *, char *, int));
  void	    mail_index_screen PROTO((struct pine *));
  int	    index_lister PROTO((struct pine *, CONTEXT_S *, char *,
  				MAILSTREAM *, MSGNO_S *));
***************
*** 4723,4729 ****
  				   MSGNO_S *, IndexType, int *, int));
  char	   *sort_name PROTO((SortOrder));
  void	    sort_folder PROTO((MAILSTREAM *, MSGNO_S *,
! 			       SortOrder, int, unsigned));
  int	    percent_sorted PROTO((void));
  void	    msgno_init PROTO((MSGNO_S **, long));
  void	    msgno_give PROTO((MSGNO_S **));
--- 4893,4899 ----
  				   MSGNO_S *, IndexType, int *, int));
  char	   *sort_name PROTO((SortOrder));
  void	    sort_folder PROTO((MAILSTREAM *, MSGNO_S *,
! 			       SortOrder, int, unsigned, int));
  int	    percent_sorted PROTO((void));
  void	    msgno_init PROTO((MSGNO_S **, long));
  void	    msgno_give PROTO((MSGNO_S **));
***************
*** 4745,4751 ****
  void	    free_pine_elt PROTO((void **));
  SEARCHSET  *build_searchset PROTO((MAILSTREAM *));
  void	    collapse_or_expand PROTO((struct pine *, MAILSTREAM *, MSGNO_S *,
! 				      unsigned long));
  PINETHRD_S *fetch_thread PROTO((MAILSTREAM *, unsigned long));
  PINETHRD_S *fetch_head_thread PROTO((MAILSTREAM *));
  int         view_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int));
--- 4915,4921 ----
  void	    free_pine_elt PROTO((void **));
  SEARCHSET  *build_searchset PROTO((MAILSTREAM *));
  void	    collapse_or_expand PROTO((struct pine *, MAILSTREAM *, MSGNO_S *,
! 				      unsigned long, int));
  PINETHRD_S *fetch_thread PROTO((MAILSTREAM *, unsigned long));
  PINETHRD_S *fetch_head_thread PROTO((MAILSTREAM *));
  int         view_thread PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int));
***************
*** 4793,4798 ****
--- 4963,4970 ----
  					    int, char *));
  
  /*--- mailview.c ---*/
+ int         select_quote PROTO((long, char *, LT_INS_S **, void *));
+ int	    next_level_quote PROTO((char *, char **, int, int));
  void	    mail_view_screen PROTO((struct pine *));
  int	    scrolltool PROTO((SCROLL_S *));
  char	   *body_type_names PROTO((int));
***************
*** 4836,4841 ****
--- 5008,5017 ----
  void	    check_point_change PROTO((MAILSTREAM *));
  void	    reset_check_point PROTO((MAILSTREAM *));
  void	    zero_new_mail_count PROTO((void));
+ int	    new_mail_incfolder PROTO((struct pine *, int));
+ char	   *folder_in_list PROTO((char *));
+ int	    folder_in_message_list PROTO((char *));
+ char	   *new_mail_in_open_stream PROTO((MAILSTREAM *, long *, long *));
  int	    changes_to_checkpoint PROTO((MAILSTREAM *));
  
  /*-- os.c --*/
***************
*** 5032,5038 ****
  				 ENVELOPE *, ADDRESS **, ADDRESS **,
  				 ADDRESS **, ADDRESS **,int *));
  int	    reply_news_test PROTO((ENVELOPE *, ENVELOPE *));
! int	    reply_text_query PROTO((struct pine *, long, char **));
  BODY	   *reply_body PROTO((MAILSTREAM *, ENVELOPE *, BODY *, long,
  			      char *, void *, char *, int, ACTION_S *, int,
  			      REDRAFT_POS_S **));
--- 5208,5214 ----
  				 ENVELOPE *, ADDRESS **, ADDRESS **,
  				 ADDRESS **, ADDRESS **,int *));
  int	    reply_news_test PROTO((ENVELOPE *, ENVELOPE *));
! int	    reply_text_query PROTO((struct pine *, long, ENVELOPE *, char **));
  BODY	   *reply_body PROTO((MAILSTREAM *, ENVELOPE *, BODY *, long,
  			      char *, void *, char *, int, ACTION_S *, int,
  			      REDRAFT_POS_S **));
***************
*** 5070,5075 ****
--- 5246,5254 ----
  char	   *body_partno PROTO((MAILSTREAM *, long, BODY *));
  char	   *partno PROTO((BODY *, BODY *));
  ACTION_S   *set_role_from_msg PROTO((struct pine *, long, long, char *));
+ ACTION_S   *set_role_from_agg PROTO((struct pine *, long, char *));
+ int	    msg_matches_pattern PROTO ((struct pine *, long, char *, long,
+ 					PAT_S *));
  int	    confirm_role PROTO((long, ACTION_S **));
  char	   *detoken PROTO((ACTION_S *, ENVELOPE *, int, int, int,
  			   REDRAFT_POS_S **, int *));
***************
*** 5201,5206 ****
--- 5380,5386 ----
  void	    removing_leading_white_space PROTO((char *));
  void	    removing_leading_and_trailing_white_space PROTO((char *));
  int 	    removing_double_quotes PROTO((char *));
+ void	    removing_extra_stuff PROTO((char *));
  char	   *skip_white_space PROTO((char *));
  char	   *skip_to_white_space PROTO((char *));
  char	   *removing_quotes PROTO((char *));
***************
*** 5374,5379 ****
--- 5554,5560 ----
  void	    MoveCursor PROTO((int, int));
  void	    NewLine PROTO((void));
  int	    config_screen PROTO((struct ttyo **));
+ void	    fake_config_screen PROTO((struct ttyo **));
  void	    init_screen PROTO((void));
  void	    end_screen PROTO((char *, int));
  void	    outchar PROTO((int));
diff -rc pine4.61/pine/pine.hlp pine4.61.I.USE/pine/pine.hlp
*** pine4.61/pine/pine.hlp	Thu Jul 15 10:37:22 2004
--- pine4.61.I.USE/pine/pine.hlp	Tue Jul 27 19:15:26 2004
***************
*** 2973,2979 ****
--- 2973,2981 ----
  <li><a href="h_config_alt_role_menu">FEATURE: Alternate-Role-Menu</a>
  <li><a href="h_config_force_low_speed">FEATURE: Assume-Slow-Link</a>
  <li><a href="h_config_auto_read_msgs">FEATURE: Auto-Move-Read-Msgs</a>
+ <li><a href="h_config_auto_read_msgs_rules">FEATURE: auto-move-read-msgs-using-rules</a>
  <li><a href="h_config_auto_open_unread">FEATURE: Auto-Open-Next-Unread</a>
+ <li><a href="h_config_circular_tab">FEATURE: enable-circular-tab</a>
  <li><a href="h_config_auto_unzoom">FEATURE: Auto-Unzoom-After-Apply</a>
  <li><a href="h_config_auto_zoom">FEATURE: Auto-Zoom-After-Select</a>
  <li><a href="h_config_check_mail_onquit">FEATURE: Check-Newmail-When-Quitting</a>
***************
*** 3222,3227 ****
--- 3224,3230 ----
  <li><a href="h_config_abook_formats">OPTION: Addressbook-Formats</a>
  <li><a href="h_config_alt_addresses">OPTION: Alt-Addresses</a>
  <li><a href="h_config_char_set">OPTION: Character-Set</a>
+ <li><a href="h_config_special_text_to_color">OPTION: Special Text to Color</a>
  <li><a href="h_config_color_style">OPTION: Color-Style</a>
  <li><a href="h_config_composer_wrap_column">OPTION: Composer-Wrap-Column</a>
  <li><a href="h_config_index_color_style">OPTION: Current-Indexline-Style</a>
***************
*** 3318,3326 ****
--- 3321,3331 ----
  <li><a href="h_config_sending_filter">OPTION: Sending-Filters</a>
  <li><a href="h_config_sendmail_path">OPTION: Sendmail-Path</a>
  <li><a href="h_config_signature_color">OPTION: Signature Color</a>
+ <li><a href="h_config_special_text_color">OPTION: Special Text Color</a>
  <li><a href="h_config_signature_file">OPTION: Signature-File</a>
  <li><a href="h_config_smtp_server">OPTION: SMTP-Server</a>
  <li><a href="h_config_sort_key">OPTION: Sort-Key</a>
+ <li><a href="h_config_thread_sort_key">OPTION: Thread-Sort-Key</a>
  <li><a href="h_config_speller">OPTION: Speller</a>
  <li><a href="h_config_sshcmd">OPTION: Ssh-Command</a>
  <li><a href="h_config_ssh_open_timeo">OPTION: Ssh-Open-Timeout</a>
***************
*** 4826,4831 ****
--- 4831,4989 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ======= h_thread_index_sort_arrival =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Arrival</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Arrival</H1>
+ 
+ The <EM>Arrival</EM> sort option arranges threads according to the last 
+ time that a message was added to it. In this order the last thread 
+ contains the most recent message in the folder.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_date =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Date</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Date</H1>
+ 
+ The <EM>Date</EM> sort option in the THREAD&nbsp;INDEX screen is the same
+ as sorting by thread, the most likely thing is that you won't see Pine
+ sorting the folder, because it's already sorted.
+ 
+ <P>
+ On a folder like INBOX, sorting by &quot;Date&quot; should be almost
+ identical to sorting by &quot;Arrival&quot;.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_subj =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Subject</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Subject</H1>
+ 
+ The <EM>Subject</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_ordsubj =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: OrderedSubject</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: OrderedSubject</H1>
+ 
+ The <EM>OrderedSubject</EM> sort option in the THREAD&nbsp;INDEX screen is
+ the same as sorting by <A HREF="h_thread_index_sort_subj">Subject</A>.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_thread =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Thread</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Thread</H1>
+ 
+ The <EM>Thread</EM> sort option in the THREAD&nbsp;INDEX screen sorts all 
+ messages by the proposed algorithm by Crispin and Murchison. In this 
+ method of sorting once threads have been isolated they are sorted by the 
+ date of their parents, or if that is missing, the first message in that 
+ thread.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_from =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: From</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: From</H1>
+ 
+ The <EM>From</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_size =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Size</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Size</H1>
+ 
+ The <EM>Size</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_score =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Score</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Score</H1>
+ 
+ The <EM>Score</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_to =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: To</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: To</H1>
+ 
+ The <EM>To</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_cc =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Cc</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Cc</H1>
+ 
+ The <EM>Cc</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ======= h_index_cmd_whereis =======
  <HTML>
  <HEAD>
***************
*** 6043,6048 ****
--- 6201,6246 ----
  not preserved.
  
  <P>
+ This version of Pine contains an enhanced algorithm for justification,
+ which allows you to justify text that contains more complicated quote
+ strings. This algorithm is based on pragmatics, rather than on a theory,
+ and seems to work well with most messages. Below you will find technical
+ information on how this algorithm works.
+ 
+ <P>
+ When justifying, Pine goes through each line of the text and tries to
+ determine for each line what the quote string of that line is. The quote
+ string you provided is always recognized. Among other characters 
+ recognized is &quot;&gt;&quot;.
+ 
+ <P>
+ Some other constructions of quote strings are recognized only if they
+ appear enough in the text. For example &quot;Peter :&quot; is only
+ recognized if it appears in two consecutive lines.
+ 
+ <P> 
+ Additionaly, Pine recognizes indent-strings and justifies text in a
+ paragraph to the right of indent-string, padding with spaces if necessary.
+ An indent string is one which you use to delimit elements of a list. For
+ example, if you were to write a list of groceries, one may write:
+ 
+ <UL>
+ <LI> Fruit
+ <LI> Bread
+ <LI> Eggs
+ </UL>
+ 
+ <P> 
+ In this case the character &quot;*&quot; is the indent-string. Pine
+ recognizes numbers (0, 1, 2.5, etc) also as indent-strings, and certain
+ combinations of spaces, periods, and parenthesis. In any case, numbers are
+ recognized <B>ONLY</B> if the line preceeding the given line is empty or
+ ends in one of the characters &quot;.&quot; or &quot;:&quot;.
+ In addition to the explanation of what constitutes a paragraph above, a
+ new paragraph is recognized when an indent-string is found in it (and
+ validated according to the above stated rules).
+ 
+ <P>
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
***************
*** 16373,16379 ****
  This set of special tokens may be used in the
  <A HREF="h_config_index_format">&quot;Index-Format&quot; option</A>,
  in the <A HREF="h_config_reply_intro">&quot;Reply-Leadin&quot; option</A>,
! in signature files,
  and in template files used in
  <A HREF="h_rules_roles">&quot;roles&quot;</A>.
  Some of them aren't available in all situations.
--- 16571,16577 ----
  This set of special tokens may be used in the
  <A HREF="h_config_index_format">&quot;Index-Format&quot; option</A>,
  in the <A HREF="h_config_reply_intro">&quot;Reply-Leadin&quot; option</A>,
! in signature files, in the <A HREF="h_config_reply_leadin_rules">&quot;new-rules&quot; option</A>,
  and in template files used in
  <A HREF="h_rules_roles">&quot;roles&quot;</A>.
  Some of them aren't available in all situations.
***************
*** 16384,16390 ****
  <P>
  <P>
  
! <H1><EM>Tokens Available for all Cases</EM></H1>
  
  <DL>
  <DT>SUBJECT</DT>
--- 16582,16588 ----
  <P>
  <P>
  
! <H1><EM>Tokens Available for all Cases (with the exception, maybe, of new-rules)</EM></H1>
  
  <DL>
  <DT>SUBJECT</DT>
***************
*** 16406,16411 ****
--- 16604,16618 ----
  For example, &quot;mailbox@domain&quot;.
  </DD>
  
+ <DT>ADDRESSTO</DT>
+ <DD>
+ This is similar to the &quot;TO&quot; token, only it is always the
+ email address of all people listed in the TO: field of the messages. Addresses
+ are separated by a blank space. Example, &quot;mailbox@domain&quot; when
+ the e-mail message contains only one person in the To: field, or
+ &quot;peter@flintstones.com president@world.com&quot;.
+ </DD>
+ 
  <DT>MAILBOX</DT>
  <DD>
  This is the same as the &quot;ADDRESS&quot; except that the 
***************
*** 16453,16458 ****
--- 16660,16674 ----
  message's &quot;Cc:&quot; header field.
  </DD>
  
+ <DT>ADDRESSCC</DT>
+ <DD>
+ This is similar to the &quot;CC&quot; token, only it is always the
+ email address of all people listed in the Cc: field of the messages. Addresses
+ are separated by a blank space. Example: &quot;mailbox@domain&quot; when
+ the e-mail message contains only one person in the Cc: field, or
+ &quot;peter@flintstones.com president@world.com&quot;.
+ </DD>
+ 
  <DT>RECIPS</DT>
  <DD>
  This token represents the personal names (or email addresses if the names
***************
*** 16461,16466 ****
--- 16677,16690 ----
  the message's &quot;Cc:&quot; header field.
  </DD>
  
+ <DT>ADDRESSRECIPS</DT>
+ <DD>
+ This token represent the e-mail addresses of the people in the To: and
+ Cc: fields, exactly in that order separated by a space. It is almost obtained
+ by concatenating the ADDRESSTO and ADDRESSCC tokens.
+ </DD>
+ 
+ 
  <DT>NEWSANDRECIPS</DT>
  <DD>
  This token represents the newsgroups from the
***************
*** 16831,16836 ****
--- 17055,17068 ----
  <P>
  </DD>
  
+ <DT>SIZETHREAD</DT>
+ <DD>
+ This token represents the total size of the thread for a collapsed thread
+ or the size of the branch for an expanded thread. The field is omitted for
+ messages that are not top of threads nor branches and it defaults to
+ the SIZE token when your folders is not sorted by thread.
+ </DD>
+ 
  <DT>SIZENARROW</DT>
  <DD>
  This token represents the total size, in bytes, of the message.
***************
*** 16974,16979 ****
--- 17206,17283 ----
  </DL>
  
  <P>
+ <H1><EM>Tokens Available Only for New-Rules</EM></H1>
+ 
+ <DL>
+ <DT>FOLDER</DT>
+ <DD>
+ Name of the folder where the rule will be applied
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>COLLECTION</DT>
+ <DD>
+ Name of the collection list where the rule will be applied.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>ROLE</DT>
+ <DD>
+ Name of the Role used to reply a message.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>BCC</DT>
+ <DD>
+ Not implemented yet, but it will be implemented in future versions. It will
+ be used for <A HREF="h_config_compose_rules">compose</A>
+ <A HREF="h_config_reply_rules">reply</A>
+ <A HREF="h_config_forward_rules">forward</A>
+ rules.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>LCC</DT>
+ <DD>
+ This is the value of the Lcc: field at the moment that you start the composition.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>FORWARDFROM</DT>
+ <DD>
+ This corresponds to the personal name (or address if there's no personal
+ name) of the person who sent the message that you are forwarding.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>FORWARDADDRESS</DT>
+ <DD>
+ This is the address of the person that sent the message that you
+ are forwarding.
+ </DD>
+ </DL>
+ 
+ 
+ 
+ 
+ <DL>
+ <DT>FLAG</DT>
+ <DD> 
+ A string containing the value of all the flags associated to a specific
+ message. The possible values of allowed flags are "*" for Important, "N"
+ for recent or new, "U" for unseen or unread, "R" for seen or read, "A" for
+ answered and "D" for deleted. See an example of its use in the 
+ <A HREF="h_config_new_rules">new rules</A> explanation and example help.
+ </DD>
+ </DL>
+ 
+ <P>
  <H1><EM>Token Available Only for Templates and Signatures</EM></H1>
  
  <DL>
***************
*** 17655,17660 ****
--- 17959,17981 ----
  be combined with the other fields if you'd like.
  
  <End of help on this topic>
+ ====== h_config_check_inc_fld ======
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: incoming-folders-to-check</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: incoming-folders-to-check</H1>
+ <P>
+ if you set this option and <A HREF="h_config_enable_check_incoming">
+ enable-check-incoming-folders</A> then you can use this option to write a space
+ separate list of incoming folders where you want new mail to be
+ checked. If you want all your incoming folders to be checked just write a
+ "*" as the value for this option.
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ======= h_address_format =======
  <HTML>
  <HEAD>
***************
*** 18750,18755 ****
--- 19071,19104 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_maildir_location ======
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: maildir-location</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: maildir-location</H1>
+ 
+ This option should be used only if you have a Maildir folder which you
+ want to use as your INBOX. If this is not your case (or don't know what
+ this is), you can safely ignore this option.
+ 
+ This option overrides the default directory Pine uses to find the location of
+ your INBOX, in case this is in Maildir format. The default value of this
+ option is "Maildir", but in some systems, this directory could have been
+ renamed (e.g. to ".maildir"). If this is your case use this option to change
+ the default.
+ 
+ The value of this option is prefixed with the "~/" string to determine the
+ full path to your INBOX.
+ 
+ <P><UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL>
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_literal_sig =====
  <HTML>
  <HEAD>
***************
*** 19525,19530 ****
--- 19874,19914 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_thread_sort_key =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Thread-Sort-Key</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Thread-Sort-Key</H1>
+ 
+ This option determines the order in which threads will be displayed. You
+ can choose from the following options.
+ 
+ <P>
+ <UL>
+  <LI> <A HREF="h_thread_index_sort_arrival">Arrival</A>
+ <!-- <LI> <A HREF="h_thread_index_sort_date">Date</A>
+  <LI> <A HREF="h_thread_index_sort_subj">Subject</A>
+  <LI> <A HREF="h_thread_index_sort_ordsubj">OrderedSubj</A>-->
+  <LI> <A HREF="h_thread_index_sort_thread">Thread</A>
+ <!-- <LI> <A HREF="h_thread_index_sort_from">From</A>
+  <LI> <A HREF="h_thread_index_sort_size">Size</A>
+  <LI> <A HREF="h_thread_index_sort_score">Score</A>
+  <LI> <A HREF="h_thread_index_sort_to">To</A>
+  <LI> <A HREF="h_thread_index_sort_cc">Cc</A>-->
+ </UL>
+ 
+ <P> Each type of sort may also be reversed. Normal default is by
+ &quot;Thread&quot;.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_other_startup =====
  <HTML>
  <HEAD>
***************
*** 19673,19698 ****
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
! ====== h_config_char_set =====
  <HTML>
  <HEAD>
! <TITLE>OPTION: Character-Set</TITLE>
  </HEAD>
  <BODY>
! <H1>OPTION: Character-Set</H1>
  
! The Character-Set configuration option is used for both displaying
! and sending messages.
  
! <P>
! When displaying a message, Pine compares this setting to the character
! set specified in the message.  If they do not match, then Pine places
! a comment in the displayed text (enclosed in square-brackets) indicating
! that some characters may not be displayed correctly.
  
! <P>
! When sending a message the text typed in the composer and all text
! attachments are labeled with the character set specified by this option.
  
  <P>
  The default value for this option is &quot;US-ASCII&quot;.
--- 20057,20721 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
! ====== h_config_compose_rules =====
  <HTML>
  <HEAD>
! <TITLE>OPTION: Compose-Rule</TITLE>
  </HEAD>
  <BODY>
! <H1>OPTION: Compose-Rule</H1>
  
! <P> At this time, this option is used to generate values for signature
! files that is not possible to do with the use of 
! <A HREF="h_rules_roles">roles</A>.
  
! <P> For example, you can have a rule like:<BR>
! _TO_ >> {Peter Flinstones} => _SIGNATURE_{~/.petersignature}
  
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! </BODY>
! </HTML>
! ====== h_config_forward_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Forward-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Forward-Rule</H1>
! 
! <P> At this time this option can be used to trim values of some fields,
! for example it can be used in the following way:
! 
! <P>
! _ROLE_ == {work} => _LCC_ := _TRIM_{_FORWARDFROM_ <_FORWARDADDRESS_>}
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! </BODY>
! </HTML>
! ====== h_config_index_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Index-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Index-Rule</H1>
! 
! <P> This option is used to supercede the value of the option <A
! HREF="h_config_index_format">index-format</A> for specific folders. In
! this form you can have different index-formats for different folders. For
! example an entry here may be:
! 
! <P>
! _FOLDER_ == {INBOX} => _INDEX_{IMAPSTATUS DATE FROM(33%) SIZE SUBJECT(67%)}
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! </BODY>
! </HTML>
! ====== h_config_replace_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Replace-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Replace-Rule</H1>
! 
! <P> This option is used to have Pine print different values for specific 
! tokens in the <A HREF="h_config_index_format">index-format</A>. For example you
! can replace strings like "To: newsgroup" by your name.
! 
! <P> Here are examples of possible rules:<BR>
! _FOLDER_ != {sent-mail} && _NICK_ != {} => _FROM_ := _REPLACE_{_FROM_ (_NICK_)}
! 
! <P> or if you receive messages with tags that contain arbitrary numbers, and
! you want them removed from the index (but not from the subject), use a rule
! like the following<BR>
! _FOLDER_ == {INBOX} => _SUBJECT_ := _REXTRIM_{&#92;[some-tag-here #[0-9].*&#92;]}
! 
! <P> You can also use this configuration option to remove specific strings of
! the index display screen, so that you can trim unnecessary information in
! your index.
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! </BODY>
! </HTML>
! ====== h_config_reply_leadin_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Reply-Leadin-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Reply-Leadin-Rule</H1>
! 
! <P> This option is used to have Pine generate a different 
! <A HREF="h_config_reply_intro">reply-leadin</A> string dependent either on
! the person you are replying to, or the folder where the message is being
! replied is in, or both.
! 
! <P> Here there are examples of how this can be used. One can use the definition
! below to post to newsgroups and the pine-info mailing list, say:
! <P>
! _FOLDER_ << {pine-info;_NEWS_} => _REPLY_{*** _FROM_ _ADDRESS_("_FROM_"  "" "(_ADDRESS_) ")wrote in_NEWS_("" " the" "") _FOLDER_ _NEWS_("" "list " "")_SMARTDATE_("Today" "today" "on _LONGDATE_"):}
! 
! <P> Here there is an example that one can use to change the reply indent string
! to reply people that speak spanish.
! <P>
! _FROM_{Condorito;Quico} => _REPLY_{*** _FROM_ (_ADDRESS_) escribi&oacute; _SMARTDATE_("Today" "hoy" "en _LONGDATE_"):}
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! </BODY>
! </HTML>
! ====== h_config_resub_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Replace-Subject-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Replace-Subject-Rule</H1>
! 
! <P> This option is used to have Pine generate a different subject when
! replying rather than the one Pine would generate automatically. Notice
! that you should consider starting this generated reply subject with the
! "Re: " string, so that no mail reading program gets confused with your
! subject reply string.
! 
! <P> Here there are a couple of examples about how to use this
! configuration option:
! 
! <P> In order to have messages with empty subject to be replied with the message
! "your message" use the rule<BR>
! <center>_SUBJECT_ == {} => _RESUB_{Re: your message}</center>
! 
! <P> If you want to trim some parts of the subject when you reply use the
! rule<BR> 
! <center>_SUBJECT_ >> {[one];two} => _SUBJECT_ := _TRIM_{[;];two}</center> 
! 
! <P>this rule removes the brackets "[" and "]" whenever the string "[one]"
! appears in it, it also removes the word "two" from it.
! 
! <P> You can also use this configuration option to customize reply subjects
! according to the sender of the message.
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! </BODY>
! </HTML>
! ====== h_config_sort_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Sort-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Sort-Rule</H1>
! 
! <P> This option is used to have Pine sort different folders in different orders
! and thus override the value already set in the
! <A HREF="h_config_sort_key">sort-key</A> configuration option.
! 
! <P> Here's an example of the way it can be used. In this case all incoming
! folders are mailing lists, except for INBOX, so we sort INBOX by arrival
! (which is the default type of sort), but we want all the rest of mailing
! lists and newsgroups to be sorted by thread.
! 
! <P>
! _COLLECTION_ >> {Incoming-Folders;News} && _FOLDER_ != {INBOX} => _SORT_{tHread}
! 
! <P> Another example could be<BR>
! _FOLDER_ == {Mailing List} => _SORT_{Reverse tHread}
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! 
! </BODY>
! </HTML>
! ====== h_config_save_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Save-Rules</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Save-Rules</H1>
! 
! <P> This option is used to specify which folder should be used to save a
! message depending either on the folder the message is in, who the message
! is from, or text that the message contains in specific headers (Cc:,
! Subject:, etc).
! 
! <P> If this option is set and the 
! <A HREF="h_config_auto_read_msgs">auto-move-read-msgs</A> configuration
! option is also set then these definitions will be used to move messages
! from your INBOX when exiting Pine.
! 
! <P>Here there are some examples<BR>
! _FLAG_ >> {D} -> Trash<BR>
! _FROM_ == {U2} -> Bono<BR>
! _FOLDER_ == {comp.mail.pine} -> pine-stuff<BR>
! _NICK_ != {} -> _NICK_/_NICK_
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! 
! </BODY>
! </HTML>
! ====== h_config_reply_indent_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Reply-indent-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Reply-indent-Rule</H1>
! 
! <P> This option is used to specify which reply-indent-string is to be used
! when replying to an e-mail. If none of the rules are successful, the result in
! the variable <a href="h_config_reply_indent_string">reply-indent-string</a>
! is used.
! 
! <P> The associated function to this configuration option is called "RESTR" (for
! REply STRing). Some examples of its use are:<BR>
! _FROM_ == {Your Boss} => _RESTR_{"> "}<BR>
! _FROM_ == {My Wife} => _RESTR_{":* "}<BR>
! _FROM_ == {Perter Flinstone;Wilma Flinstone} => _RESTR_{"_INIT_ > "}<BR>
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! 
! </BODY>
! </HTML>
! ====== h_config_smtp_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: SMTP-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: SMTP-Rule</H1>
! 
! <P> This option is used to specify which SMTP server should be used when
! sending a message, if this rule is not defined, or the execution of the rule
! results in no server selected, then Pine will look for 
! the value from the role that is being used to compose the message. If no smtp
! server is defined in that role or you are not using a role, then Pine will get
! the name of the server from the
! <A HREF="h_config_smtp_server">&quot;smtp-server&quot;</A> configuration
! option according to the rules used in that variable.
! 
! <P> The function associated to this configuration option is _SMTP_, an example
! of the use of this function is<BR>
! _ADDRESSTO_ == {peter@bedrock.com} => _SMTP_{smtp.bedrock.com}
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! 
! </BODY>
! </HTML>
! ====== h_config_startup_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Startup-Rule</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Startup-Rule</H1>
! 
! <P> This option is used when a folder is being opened. You can use it to 
! specify its <A HREF="h_config_inc_startup">incoming-startup-rule</A> and override
! Pine's global value set for all folders.
! 
! <P> An example of the usage of this option is:<BR>
! _FOLDER_ == {Lynx;pine-info;_NEWS_} => _STARTUP_{first-unseen}
! 
! <P> This configuration option is just one of many that allow you to
! override the value of some global configurations within Pine. There is a
! help text explaining how to define all of them, which you can read by
! following this <A HREF="h_config_new_rules">link</A>.
! 
! <P>&lt;End of help on this topic&gt;
! 
! </BODY>
! </HTML>
! ====== h_config_new_rules =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: New Rules Explained</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: New Rules Explained</H1>
! 
! This is a quite powerful option. Here you can define rules that override
! the values of any other global rule you have globally set in pine.
! 
! <P>
!   For example, you can set your folders to be sorted in a certain way when
! you open them (say by Arrival). You may not want to be this the behavior
! of, say, a Newsgroup, maybe you would like there to have your folder to be
! automatically ordered by Ordered Subject. The purpose of this feature is
! to accomplish exactly that. You can use this option for defining such
! exception and make Pine automatically sort your favorite Newsgroup by
! Ordered Subject.
! 
! <P>
!   On the other hand you may be suscribed to a mailing list, and maybe you
! don't care to see in the index the size of the messages, however in other
! lists you may want to see the size of the messages. You can use this
! configuration for changing the way the index is displayed in a folder.
! 
! <P>
!   Also there may be a mailing list that identifies itself by adding a
! certain string to its subject which makes difficult to read the total
! subject, so you may want to delete that string from the subject whenever
! it appears. You can do that also with this configuration.
! 
! <P>
!   You may also want to make your reply-leadin-string person or folder
! dependent. You can do this with this feature (part of this feature can be
! accomplised with the roles definitions, but roles are not the right tool
! to do this as you will see).
! 
! <P>
!   Every rule has three parts, a condition, a separator and an action. The
! action is what will happen if the condition of the rule is satisified.
! 
! <P>
!   Here is an example:
! 
! <P>
!    _FROM_ == {Fred Flinstone} =&gt; _SAVE_{Fred}
! 
! <P>
!   Here the separator is "=&gt;". Whatever is to the left of the separator
! is the condition (that is to say _FROM_ == {Fred Flinstone}) and to the
! right is the action (_SAVE_{Fred}). The condition means that the rule will
! be applied only if the message that you are reading is from "Fred
! Flinstone", and the action will be that you will be offered to save it in
! the folder "Fred", whenever you press the letter "S" to save a message.
! 
! <P>
!   The separator is always "=&gt;", with one exception to be seen later.
! But for the most part this will be the only one you'll ever need.
! 
! <P>
!   Now let us see how to do it. There are 12 functions already defined for 
! you. These are: _INDEX_, _REPLACE_, _REPLY_, _RESUB_, _SAVE_, _SIGNATURE_, 
! _SORT_, _STARTUP_, _TRIM_, _REXTRIM_, _THREADSTYLE and _THREADINDEX_. The 
! parameter of a function has to be enclosed between "{" and "}", so for 
! example you can specify _SAVE_{saved-messages} as a valid sentence.
! 
! <P>
!   At the end of the document you will find more examples.Here is a short
! description of what each function does: 
! 
! <P>
! <UL>
! <LI> _INDEX_ : This function takes as an argument an index-format, and
! makes that the index-format for the specified folder.
! <LI> _REPLACE_ : This function replaces the subject/from of the given e-mail by
! another subject/from only when displaying the index.
! <LI> _REPLY_ : This function takes as an argument a definition of a
! reply-leadin-string and makes this the reply-leading-string of the
! specified folder or person.
! <LI> _RESTR_ : This function takes as an argument the value of the 
! reply-indent-string to be used to answer the message being replied to.
! <LI> _RESUB_ : This function replaces the subject of the given e-mail by
! another subject only when replying to a message.
! <LI> _SAVE_ : The save function takes as an argument the name of a
! possibly non existing folder, whenever you want to save a message, that
! folder will be offered for you to save.
! <LI> _SIGNATURE_ : This function takes as an argument a signature file and
! uses that file as the signature for the message you are about to
! compose/reply/forward.
! <LI> _SMTP_ : This function takes as an argument the definition of a
! SMTP server.
! <LI> _SORT_ : This function takes as an argument a Sort Style, and sorts a
! specified folder in that sort order.
! <LI> _TRIM_ : This function takes as an argument a list of strings that
! you want removed from another string. At this time this only works for
! _FROM_ and _SUBJECT_.
! <LI> _REXTRIM_ : Same as _TRIM_ but its argument is one and
! only one extended regular expression.
! <LI> _STARTUP_ : This function takes as an argument an
! incoming-startup-rule, and open an specified folder using that rule.
! <LI> _THREADSTYLE_ : This function takes as an argument a
! threading-display-style and uses it to display threads in a folder.
! <LI> _THREADINDEX_ : This function takes as an argument a
! threading-index-style and uses it to display threads in a folder.
! </UL>
! 
! <P>
! You must me wondering how to define the person/folder over who to apply
! the action. This is done in the condition. When you specify a rule, the
! rule is only executed if the condition is satisfied. In another words for
! the rule:
! 
! <P>
!    _FROM_ == {Fred Flinstone} =&gt; _SAVE_{Fred}
! 
! <P>
! it will only be applied if the from is "Fred Flinstone", if the From is
! "Wilma Flinstone" the rule will be skipped.
! 
! <P> In order to test a condition you can use the following tokens (in
! alphabetical order): _ADDRESS_,_CC_, _FOLDER_, _FROM_,_NICK_, _ROLE,
! _SENDER_, _SUBJECT_ and _TO_. The token will always be tested against what
! it is between "{" and "}" in the condition, this part of the condition is
! called the "condition set". The definition of each token can be found 
! <A HREF="h_index_tokens">here</A>.
! 
! <P>
! You can also test in different ways, you can
! use the following "test operands": &lt;&lt;, !&lt;, &gt;&gt;, !&gt;, ==
! and !=. All of them are two strings long. Here is the meaning of them:
! 
! <P>
! <UL> 
! <LI> &lt;&lt; : It tests if the value of the token is contained in
! the condition set. Here for example if the condition set were equal to
! "Freddy", then the condition: _NICK_ &lt;&lt; {Freddy}, would be true if
! the value of _NICK_ were "Fred", "red" or "Freddy". You are just looking
! for substrings here.
! <LI> &gt;&gt; : It tests if the value of the token contains the value of
! the condition set. Here for example if the condittion set were equal to
! "Fred", then the condition: _FROM_ &gt;&gt; {Fred}, would be true if
! the value of _FROM_ were "Fred Flinstone" or "Fred P. Flinstone" or "Freddy".
! <LI> == : It tests if the value of the token is exactly equal to the value
! of the set condition. For example _NICK_ == {Fred} will be false if the value 
! of _NICK_ is "Freddy" or "red". 
! <LI> !&lt; : This is true only when &lt;&lt; is false and viceversa.
! <LI> !&gt; : This is true only when &gt;&gt; is false and viceversa.
! <LI> != : This is true only when == is false and viceversa.
! </UL>
! 
! <P>
!   Now let us say that you want the same action to be applied to more than
! one person or folder, say you want "folder1" and "folder2" to be sorted by
! Ordered Subject upon entering. Then you can list them all of them in the
! condition part separting them by a ";". Here is the way to do it.
! 
! <P>
!  _FOLDER_ &lt;&lt; {folder1; folder2} =&gt; _SORT_{OrderedSubj}
! 
! <P>
!   Here is the first subtelty about these definitions. Notice that the
! following rule:
! 
! <P>
!  _FOLDER_ == {folder1; folder2} =&gt; _SORT_{Reverse OrderedSubj}
! 
! <P> works only for "folder1" but not for "folder2". This is because the
! comparison of the name of the folder is done with whatever is in between
! "{", ";" or "}", so in the above rule you would be testing <BR>
! "folder2" == " folder2". The extra space makes the difference. 
! The reason why the first rule does not fail is because 
! "folder2" &lt;&lt; " folder2" is actually
! true. If something ever fails this may be something to look into.
! 
! <P>
!  Here are a few examples of what we have talked about before.
! 
! <P>
! _NICK_ == {lisa;kika} =&gt; _SAVE_{_NICK_/_NICK_} <BR>
! This means that if the nick is lisa, it will 
! save the message in the folder "lisa/lisa", and if the nick 
! is "kika", it will save the message in the folder "kika/kika"
! 
! <P>
! _FOLDER_ == {Lynx} -&gt; lynx <BR>
! This, is an abreviation of the following rule:<BR>
! _FOLDER_ == {Lynx} =&gt; _SAVE_{lynx} <BR>
! (note the change in separator from "=&gt;" to "-&gt;"). In the future 
! I will use that abreviation.
! 
! <P> _FOLDER_ &lt;&lt; {comp.mail.pine; pine-info; pine-alpha} -&gt; pine <BR>
! Any message in the folders "comp.mail.pine", "pine-info" or "pine-alpha"
! will be saved to the folder "pine".
! 
! <P> _FROM_ &lt;&lt; {Pine Master} -&gt; pine <BR>
! Any message whose From field contains
! "Pine Master" will be saved in the folder pine.
! 
! <P> _FOLDER_ &lt;&lt; {Lynx; pine-info; comp.mail.pine} =&gt;
! _INDEX_{IMAPSTATUS MSGNO DATE FROMORTO(33%) SUBJECT(66%)} <BR> Use a
! different index-format for the folders "Lynx", "pine-info" and
! "comp.mail.pine", where the size is not present.
! 
! <P> _FOLDER_ == {Lynx;pine-info} =&gt; _REPLY_{*** _FROM_ (_ADDRESS_)
! wrote in the _FOLDER_ list _SMARTDATE_("Today" "today" "on
! _LONGDATE_"):}<BR> If a message is in one of the incoming folders "Lynx"
! or "pine-info", create a reply-leadin-string that acknowledges that. Note
! the absence of "," in the function _SMARTDATE_. For example answering to a
! message in the pine-info list would look like:
! 
! <P>
! *** Steve Hubert (hubert@cac.washington.edu) wrote in the pine-info list today:
! 
! <P>
! However replying for a message in the Lynx list would look:
! 
! <P>
! *** mattack@area.com (mattack@area.com) wrote in the Lynx list today:
! 
! <P>
! If you write in more than one language you can use this feature to create
! Reply-leadin-strings in different languages.
! 
! <P> Note that at least for people you can create particular
! reply-leadin-string using the role features, but it does not work as this
! one does. This seems to be the right way to do it.
! 
! <P> _FOLDER_ &lt;&lt; {Lynx; comp.mail.pine; pine_info; pine-alpha} =&gt;
! _SORT_{OrderedSubj}<BR> This means upon opening, sort the folders "Lynx",
! "comp.mail.pine", etc in ordered subject. All the others use the default
! sort order. You can not sort in reverse in this form. The possible
! arguments of this function are listed in the definition of the
! default-sort-rule (Arrival, scorE, siZe, etc).
! 
! <P> The last examples use the function _TRIM_ which has a special form.
! This function can only be used in the index list.
! 
! <P> _FOLDER_ &lt;&lt; {Lynx} =&gt; _SUBJECT_ := _TRIM_{lynx-dev }<BR> In
! the folder "Lynx" eliminate from the subject the string "lynx-dev " (with
! the space at the end). For example a message whose subject is "Re:
! lynx-dev unvisited Visited Links", would be shown in the index with
! subject: "Re: unvisited Visited Links", making the subject shorter and
! giving the same information.
! 
! <P> _FROM_ &gt;&gt; {Name (Comment)} =&gt; _FROM_ :=
! _TRIM_{ (Comment)}<BR> Remove the part " (Comment)"
! from the _FROM_, so when displaying in the index the real From "Name"
! will appear.
! 
! <P> _SUBJECT_ == {} =&gt; _RESUB_{Re: your mail without subject}
! If there is no subject in the message, use the subject "Re: your mail
! wiyhout subject" as a subject for the reply message.
! 
! <P> You can add more complexity to your rules by checking more than one
! conditions before a rule is executed. For example: Assume that you want to
! answer every email that contains the string "bug report", with the subject
! "Re: About your bug report", you could make
! 
! <P>
! _SUBJECT_ == {bug report} =&gt; _RESUB_{Re: About your _SUBJECT_}
! 
! <P> The problem with this construction is that if the person emails you
! back, then the next time you answer the message the subject will be: "Re:
! About your Re: About your bug report", so it grew. You may want to avoid
! this growth by using the following rule:
! 
! <P>
! _SUBJECT_ &gt;&gt; {bug report} &&  _SUBJECT_ !&gt; {Re: } =&gt; _RESUB_{Re: About your _SUBJECT_}<BR>
! 
! <P>
! which will only add the string "Re: About your" only the first time the
! message is replied.
! 
! <P>
!   Say your personal name is "Fred Flinstones", and assume that you don't
! like to see "To: comp.mail.pine" in every post you make to this newsgroup,
! but instead would like to see it as everyone else sees it. <BR> 
! _FOLDER_ == {comp.mail.pine} && _FROM_ == {Fred Flinstones} => _FROM_ := _REPLACE_{_FROM_}
! 
! <P> 
!   You can also list your index by nick, in the following way:<BR>
! _NICK_ != {} => _FROM_ := _REPLACE_{_NICK_}
! 
! <P>
!   If you want to open the folder "pine-info" in the first non-read message
! use the rule:<BR>
! _FOLDER_ == {pine-info} => _STARTUP_{first-unseen}
! 
! <P>
!  If you want to move your deleted messages to a folder, called "Trash", use
! the following rule:<BR>
! _FLAG_ >> {D} -> Trash
! 
! <P>
! The reason why the above test is not "_FLAG_ == {D}" is because that would mean
! that this is the only flag set in the message. It's better to test by containment in this case.
! 
! <P> If you want to use a specific signature when you are in a specific collection
! use the following rule:<BR>
! _COLLECTION_ == {Mail} => _SIGNATURE_{/full/path/to/.signature}
! 
! <P> Finally about the question of which rule will be executed. Only the
! first rule that matches will be executed. It is important to notice though
! that "saving" rules do not compete with "sorting" rules. So the first
! "saving" rule that matches will be executed in the case of saving and so
! on.
! 
! <P> Here are some things to do still:
! <UL>
! <LI> To make _TRIM_ compatible with more tokens (_TO_, _SENDER_, etc)
! <LI> To make this list dissapear!
! </UL>
! 
! <P>
! <UL>
! <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
! </UL><P>
! &lt;End of help on this topic&gt;
! </BODY>
! </HTML>
! ====== h_config_char_set =====
! <HTML>
! <HEAD>
! <TITLE>OPTION: Character-Set</TITLE>
! </HEAD>
! <BODY>
! <H1>OPTION: Character-Set</H1>
! 
! The Character-Set configuration option is used for both displaying
! and sending messages.
! 
! <P>
! When displaying a message, Pine compares this setting to the character
! set specified in the message.  If they do not match, then Pine places
! a comment in the displayed text (enclosed in square-brackets) indicating
! that some characters may not be displayed correctly.
! 
! <P>
! When sending a message the text typed in the composer and all text
! attachments are labeled with the character set specified by this option.
  
  <P>
  The default value for this option is &quot;US-ASCII&quot;.
***************
*** 19805,19810 ****
--- 20828,20869 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_special_text_to_color =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Special Text to Color</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Specil Text to Color</H1>
+ 
+ Use this option to enter patterns (text or regular expressions) that Pine
+ will highlight in the body of the text that is not part of a handle (and 
+ internal or external link that Pine paints in a different color). 
+ 
+ <P> 
+ Enter each pattern in a different line. Pine will internally merge these
+ patterns (by adding a "|" character), or you can add them all in one line
+ by separating them by a "|" character.
+ 
+ <P>
+ Pine will use the colors defined in the 
+ <A HREF="h_config_special_text_color"> Special Text Color</A> variable. 
+ to paint any match.
+ 
+ <P> 
+ If the Special Text Color is not set, setting this variable will not
+ cause that special text to be indicated in any special way. It will look
+ like any normal text. You must set those colors in order to make Pine
+ paint the screen differently when it finds the patterns specified in this
+ variable.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_display_filters =====
  <HTML>
  <HEAD>
***************
*** 20638,20643 ****
--- 21697,21734 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_inc_fld_timeo =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: inc-fld-timeout</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: inc-fld-timeout</H1>
+ 
+ When Pine is checking for new mail in an external incoming folder, and the
+ amount of time specified in this variable has elapsed without Pine being
+ able to connect to the server holding that mailbox, Pine will drop the
+ connection to that server and continue checking for new mail in other
+ incoming folders, if any.
+ 
+ <P>
+ Observe that Pine will not print an error message in this case, but it
+ will silently drop the connection. If your connections are fast setting
+ this to a large value will not cause you any problem, but if your
+ connections are slow setting this to a small value will make Pine speed
+ checking for new mail, although it is possible that not all of your
+ incoming folders will be checked for new mail.
+ 
+ <P>
+ The default is 5 seconds, which is also the minimum and the maximum is 60.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_incoming_folders =====
  <HTML>
  <HEAD>
***************
*** 22660,22665 ****
--- 23751,23826 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_thread_display_style_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Threading-Display-Style-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Threading-Display-Style-Rule</H1>
+ 
+ This option is very similar to <A HREF="h_config_thread_disp_style">
+ threading-display-style</A>, but it is a rule which specifies the
+ display styles for a thread that you want displayed in a specific
+ folder or collection.
+ <P>
+ The token to be used in this function is _THREADSTYLE_. Here there is
+ an example of its use
+ <P>
+ _FOLDER_ == {pine-info} => _THREADSTYLE_{mutt-like}
+ <P>
+ The values that can be given for the _THREADSTYLE_ function are the
+ values of the threading-display-style function, which can be found
+ listed in the <A HREF="h_config_thread_disp_style">threading-display-style</A>
+ configuration option.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_thread_index_style_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Threading-Index-Style-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Threading-Index-Style-Rule</H1>
+ 
+ This option is very similar to <A HREF="h_config_thread_index_style">
+ threading-index-style</A>, but it is a rule which specifies the
+ index styles for a thread that you want displayed in a specific
+ folder or collection.
+ <P>
+ The token to be used in this function is _THREADINDEX_. Here there is
+ an example of its use
+ <P>
+ _FOLDER_ == {pine-info} => _THREADINDEX_{regular-index-with-expanded-threads}
+ <P>
+ The values that can be given for the _THREADINDEX_ function are the
+ values of the threading-index-display function, which can be found
+ listed in the <A HREF="h_config_thread_index_style">threading-index-display</A>
+ configuration option.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_pruning_rule =====
  <HTML>
  <HEAD>
***************
*** 22953,22958 ****
--- 24114,24164 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_inc_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Incoming-Check-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Incoming-Check-Rule</H1>
+ 
+ This value affects Pine's behavior when  starting Pine. It determines
+ how and when Pine will check for new mail in your incoming folders. The
+ default value is &quot;automatic&quot;.
+ 
+ <P>
+ The three possible values for this option are:
+ 
+ <DL>
+ <DT>automatic</DT>
+ <DD>This is the default. When this is selected the first check for new
+ mail will be done when Pine is starting up and you either go to the
+ INDEX or FOLDER LIST screens.
+ </DD>
+ 
+ <DT>automatic-after-first-manual-check</DT>
+ <DD>Similar to the default, but no check is done until you force the first
+ one by pressing CTRL-H. All checks are automatic after the first one. Observe
+ that this feature does not work once an automatic check has been done.
+ </DD>
+ 
+ <DT>manual-only</DT>
+ <DD>This forces Pine to do only manual checks. This will probably speed
+ Pine, since checks will  only happen when they are forced by pressing CTRL-H.
+ </DD>
+ </DL>
+ 
+ <P>
+ If you just want to stop Pine from checking in one folder, then simply
+ select that folder. Checks on that folder will be skipped.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_browser =====
  <HTML>
  <HEAD>
***************
*** 23894,23899 ****
--- 25100,25182 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_enable_check_incoming ======
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: enable-check-incoming-folders</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: enable-check-incoming-folders</H1>
+ If you have enabled <A HREF="h_config_enable_incoming">incoming
+ folders</A> then setting this feature allows you to check for new mail in
+ these. A message stating that new mail was received and in which folders
+ will be written in the screen. You can decide which incoming folders you
+ want to check for new mail, and the list of them has to be entered in the
+ setting <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>.
+ 
+ <P> If you have the option 
+ <A HREF="h_config_fast_recent">enable-fast-recent-test</A>
+ <B>disabled</B>, but have this feature enabled, then a full report on the
+ total number of messages, and the number of new messages in the folder is
+ printed in the <A HREF="h_folder_maint">FOLDER LIST</A> screen 
+ for each folder listed in the variable 
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>. The report for each
+ folder is made in the format
+ 
+ <P>
+ folder-name [Number of new messages/Number of messages in the folder]
+ 
+ <P>
+ If an incoming folder is not listed in the variable
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>, then only 
+ the name of the folder and no other report is made about that folder.
+ 
+ <P>
+ Other important features related to this feature are:
+ <OL>
+ <LI><A HREF="h_config_enable_recheck_incoming">recheck-all-incoming-folders</A>,
+ which allows you to decide if you want to check all folders every check,
+ <LI><A HREF="h_config_inc_rule">incoming-check-rule</A>, which determines
+ how and when Pine will check for new mail in your incoming folders.
+ </OL>
+ 
+ <P>
+ <UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL>
+ </BODY>
+ </HTML>
+ ====== h_config_enable_recheck_incoming ======
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: recheck-all-incoming-folders</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: recheck-all-incoming-folders</H1>
+ If you have enabled <A HREF="h_config_enable_incoming">incoming folders</A>
+ and <A HREF="h_config_enable_check_incoming">enable-check-incoming-folder</A>
+ then setting this feature will force Pine to recheck all incoming folders
+ for new mail. The normal behavior (that is to say, when this feature
+ is not enabled) is that Pine will skip checking for new mail in folders
+ where it already found. This is done to speed checking for new mail.
+ 
+ <P>
+ The default behavior, however, can cause problems if you use two clients
+ to access the same incoming folders, because Pine will not realize that
+ new mail does not exist in one folder where it already reported new mail,
+ but was opened with the other client. Setting this feature will cause Pine
+ to recheck all folders all the time. In this way Pine will know for sure
+ which folders DO contain new mail.
+ 
+ <P> If you only use Pine to access your incoming folders, then DO NOT
+ enable this feature.
+ 
+ <P>
+ <UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL>
+ </BODY>
+ </HTML>
  ====== h_config_attach_in_reply ======
  <HTML>
  <HEAD>
***************
*** 24192,24197 ****
--- 25475,25496 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_use_domain =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: return-path-uses-domain-name </TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: return-path-uses-domain-name</H1>
+ 
+ If you enable this configuration option Pine will use your domain name and your
+ username in that domain name to construct your Return-Path header, if not Pine
+ will use the address that you have set in the From: field to construct it.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_use_sender_not_x =====
  <HTML>
  <HEAD>
***************
*** 24334,24339 ****
--- 25633,25665 ----
  successes.  You will usually receive the full message back when there is
  a failure.
  
+ <P> When this feature is <B>disabled</B>, and the feature 
+ <A HREF="h_config_enable_check_incoming">enable-check-incoming-folders</A>
+ is enabled, then a full report of the number of messages and number of
+ new messages in each incoming folder listed in the option
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A> is made. This
+ report is printed in the <A HREF="h_folder_maint">FOLDER LIST</A> screen. The 
+ report is given in the form
+ 
+ <P>
+ folder-name [Number of New Messages/Number of messages in the folder]
+ 
+ <P> If an incoming-folder is not listed in the variable 
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>, no check for
+ that folder is made, so only the folder name, and no other information is
+ printed about that folder.
+ 
+ <P> If this feature is enabled and the feature 
+ <A HREF="h_config_enable_recheck_incoming">recheck-all-incoming-folders</A>
+ is disabled, then selecting a folder will cancel further checks on that
+ folder. This is useful if checks to a particular incoming folder are slow
+ and want to be avoided (until the folder is unselected and a new cycle of
+ checks is done) without changing the list of folders to be checked.
+ Selecting a folder in order to avoid checks for new mail does not work in
+ other cases, since it is either explicitly requested this way or because
+ it is necessary to update the count of new and total number of messages of
+ every requested folder.
+ 
  <P>
  If you turn on the DSNOpts the default is to return as much information as
  possible to you.  That is, by default, the Success and Delay options are
***************
*** 24712,24717 ****
--- 26038,26086 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_alt_reply_menu =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: alternate-reply-menu</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: alternate-reply-menu</H1>
+ 
+ This feature controls the menu that is displayed when Reply is selected.
+ If set, a list of options will be presented, with each option representing
+ the type of composition that could be used. This feature is most useful
+ for users who want to avoid being prompted with each option separately, or
+ would like to override some defaults set in your configuration for the
+ message that you are replying (e.g. you may have set the option to strip
+ signatures, but for the message you are answering you would like not to do
+ that)
+ 
+ <P>
+ The way this feature works is as follows. Initially you get the question
+ if you want to include the message, and in the menu you will see several
+ options, each option is accompanied by some text explaining what will
+ happen if you press return to continue. For example, if you read the text
+ "S Strip Sig", it means that if you press return the signature will be
+ stripped off the message you are replying, if you press "S", then the
+ message will change to "S No Strip", which means that if you press RETURN,
+ the signature will not be stripped off from the message.
+ 
+ <P>
+ The possible options are:
+ 
+ <OL>
+ <LI> S: To strip the signature from a message, only available is the feature
+         <a href="h_config_sigdashes">enable-sigdashes</a> or the
+ <a href="h_config_strip_sigdashes">strip-from-sigdashes-on-reply</a> option are
+ enabled.
+ 
+ <LI> R: To set a role, if you do not want Pine to set one automatically for you
+ or would like to set one when you can not select any.
+ </OL>
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_del_from_dot =====
  <HTML>
  <HEAD>
***************
*** 25546,25551 ****
--- 26915,26943 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_auto_read_msgs_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: auto-move-read-msgs-using-rules</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: auto-move-read-msgs-using-rules</H1>
+ This feature controls an aspect of Pine's behavior upon quitting.  If set,
+ and the 
+ <A HREF="h_config_read_message_folder">&quot;read-message-folder&quot;</A>
+ option is also set, then Pine will automatically transfer all read
+ messages to the designated folder using the rules that you have defined in
+ your
+ <A HREF="h_config_save_rules">&quot;save-rules&quot;</A> and mark
+ them as deleted in the INBOX.  Messages in the INBOX marked with an 
+ &quot;N&quot; (meaning New, or unseen) are not affected.
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_auto_fcc_only =====
  <HTML>
  <HEAD>
***************
*** 25934,25939 ****
--- 27326,27348 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_enhanced_thread =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: enhanced-fancy-thread-support</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: enhanced-fancy-thread-support</H1>
+ 
+ If this option is set certain commands in Pine will operate in loose
+ threads too. For example, the command ^D marks a thread deleted, but if
+ this feature is set, it will remove all threads that share the same missing
+ parent with this thread.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_news_cross_deletes =====
  <HTML>
  <HEAD>
***************
*** 26414,26419 ****
--- 27823,27849 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_circular_tab =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: enable-circular-tab</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: enable-circular-tab</H1>
+ 
+ <P> 
+ This Feature is like 
+ <A HREF="h_config_auto_open_unread">&quot;auto-open-next-unread&quot;</A>, 
+ in the sense that you can use TAB to browse through all of your Incoming
+ Folders checking for new mail. Once it gets to the last folder of the
+ collection it goes back to check again until it returns to the original
+ folder where it started.
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_auto_include_reply =====
  <HTML>
  <HEAD>
***************
*** 26877,26882 ****
--- 28307,28336 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_special_text_color =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Special Text Color</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Special Text Color</H1>
+ 
+ Sets the color Pine uses for coloring any text in the body of the message
+ that is not part of a handle (and internal or external link that Pine 
+ paints in a different color). By default, this variable is not defined, 
+ which means that text that matches the pattern is not painted in any
+ particular way. This variable must be set in a special form if you
+ want text to be painted.
+ 
+ <P>
+ <A HREF="h_color_setup">Descriptions of the available commands</A>
+ <P>
+ Look <A HREF="h_edit_nav_cmds">here</A>
+ to see the available Editing and Navigation commands.
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_prompt_color =====
  <HTML>
  <HEAD>
diff -rc pine4.61/pine/reply.c pine4.61.I.USE/pine/reply.c
*** pine4.61/pine/reply.c	Tue Jul 13 18:35:20 2004
--- pine4.61.I.USE/pine/reply.c	Tue Aug  3 12:21:52 2004
***************
*** 62,67 ****
--- 62,69 ----
  
  #include "headers.h"
  
+ static ACTION_S *role_chosen;
+ static int strip;
  
  
  /*
***************
*** 278,284 ****
  	if(!times){		/* only first time */
  	    char *p = cpystr(prefix);
  
! 	    if((include_text=reply_text_query(pine_state,totalm,&prefix)) < 0)
  	      goto done_early;
  	    
  	    /* edited prefix? */
--- 280,286 ----
  	if(!times){		/* only first time */
  	    char *p = cpystr(prefix);
  
! 	    if((include_text=reply_text_query(pine_state,totalm,env,&prefix)) < 0)
  	      goto done_early;
  	    
  	    /* edited prefix? */
***************
*** 309,314 ****
--- 311,346 ----
  	else if(i == 0)
  	  goto done_early;
  
+ 	if (ps_global->role)
+ 	   fs_give((void **)&ps_global->role);
+ 
+         /* Setup possible role */
+         if (role_chosen)
+          role = role_chosen;
+         else if(role_arg)
+          role = copy_action(role_arg);
+ 
+ 	if (!role){
+ 	   rflags = ROLE_REPLY;
+            if(!role_chosen && nonempty_patterns(rflags, &dummy)){
+ 	     if(!times)
+ 	    /* setup default role */
+             role = totalm > 1L ? set_role_from_agg(pine_state, rflags, NULL):
+                  set_role_from_msg(pine_state, rflags, seq[times], NULL);
+ 
+ 	     if(confirm_role(rflags, &role))
+ 	       role = combine_inherited_role(role);
+ 	     else{				/* cancel reply */
+ 	        role = NULL;
+ 	        cmd_cancelled("Reply");
+ 	        goto done_early;
+ 	     }
+           }
+ 	}
+ 
+ 	if (role)
+             ps_global->role = cpystr(role->nick); /* remember the role */
+ 
  	/*------------ Format the subject line ---------------*/
  	if(outgoing->subject){
  	    /*
***************
*** 321,328 ****
  		outgoing->subject = cpystr("Re: several messages");
  	    }
  	}
! 	else
! 	  outgoing->subject = reply_subject(env->subject, NULL, 0);
      }
  
  
--- 353,371 ----
  		outgoing->subject = cpystr("Re: several messages");
  	    }
  	}
! 	else{
! 	   RULE_RESULT *rule;
! 	   rule = (RULE_RESULT *) get_result_rule(ps_global->VAR_RESUB_RULES,
! 					    FOR_RULE|FOR_RESUB|FOR_TRIM , env);
! 	   if (rule){
! 	     outgoing->subject = cpystr(rule->result);
! 	     if (rule->result)
! 	        fs_give((void **)&rule->result);
! 	     fs_give((void **)&rule);
! 	   }
! 	   else
! 	       outgoing->subject = reply_subject(env->subject, NULL, 0);
! 	}
      }
  
  
***************
*** 333,359 ****
      if(sp_expunge_count(pine_state->mail_stream))	/* cur msg expunged */
        goto done_early;
  
-     /* Setup possible role */
-     if(role_arg)
-       role = copy_action(role_arg);
- 
-     if(!role){
- 	rflags = ROLE_REPLY;
- 	if(nonempty_patterns(rflags, &dummy)){
- 	    if(!times)
- 	      /* setup default role */
- 	      role = set_role_from_msg(pine_state, rflags, seq[times], NULL);
- 
- 	    if(confirm_role(rflags, &role))
- 	      role = combine_inherited_role(role);
- 	    else{				/* cancel reply */
- 		role = NULL;
- 		cmd_cancelled("Reply");
- 		goto done_early;
- 	    }
- 	}
-     }
- 
      /*
       * Reply_seed may call c-client in get_fcc_based_on_to, so env may
       * no longer be valid. Get it again.
--- 376,381 ----
***************
*** 815,820 ****
--- 837,905 ----
      return(1);
  }
  
+ int
+ msg_matches_pattern (ps, rflags, section, msgno, pat)
+     struct pine *ps;
+     long         rflags;
+     char        *section;
+     long	 msgno;
+     PAT_S       *pat;
+ {
+     SEARCHSET     *ss = NULL;
+     int rv = 0;
+ 
+     if(msgno > 0L){
+ 	ss = mail_newsearchset();
+ 	ss->first = ss->last = (unsigned long)msgno;
+     }
+ 
+     if(ss && pat && scores_are_used(SCOREUSE_GET) & SCOREUSE_ROLES &&
+        get_msg_score(ps->mail_stream, msgno) == SCORE_UNDEF)
+       (void)calculate_some_scores(ps->mail_stream, ss, 0);
+ 
+     if (match_pattern(pat->patgrp, ps->mail_stream, ss, section,
+ 				 get_msg_score, 0) && pat->action && 
+ 				!pat->action->bogus)  rv++;
+ 
+     return rv;
+ }
+ 
+ /* 
+  * We want to find a pattern that matches all messages in the list of messages,
+  * this could be done by going in a loop that checks if all of them match
+  * the role that the first one matches, but that may not be the case, we want
+  * to find a common role, which may or may not be the first role that the
+  * first message matches.
+  */
+ 
+ ACTION_S *
+ set_role_from_agg(ps, rflags, section)
+     struct pine *ps;
+     long         rflags;
+     char        *section;
+ {
+     PAT_S         *pat = NULL;
+     PAT_STATE      pstate;
+     long	   msgno;
+ 
+     if(!nonempty_patterns(rflags, &pstate))
+       return(NULL);
+ 
+     pat = first_pattern(&pstate);
+ 
+     while (pat){
+ 	  for(msgno = mn_first_cur(ps->msgmap);
+ 	    msgno > 0L &&
+ 	    msg_matches_pattern (ps, rflags, section, msgno, pat);
+ 	    msgno = mn_next_cur(ps->msgmap));
+ 
+ 	  if (msgno <= 0L)   /* bingo! */
+ 	     break;
+ 	  pat = next_pattern(&pstate);
+     }
+ 
+     return pat ? pat->action : NULL;
+ }
  
  ACTION_S *
  set_role_from_msg(ps, rflags, msgno, section)
***************
*** 823,830 ****
      long         msgno;
      char        *section;
  {
!     ACTION_S      *role = NULL;
!     PAT_S         *pat = NULL;
      SEARCHSET     *ss = NULL;
      PAT_STATE      pstate;
  
--- 908,915 ----
      long         msgno;
      char        *section;
  {
!     ACTION_S	  *role = NULL;
!     PAT_S         *pat = NULL, *pat_rv = NULL;
      SEARCHSET     *ss = NULL;
      PAT_STATE      pstate;
  
***************
*** 985,991 ****
  		    prompt_fodder);
  	}
  
! 	cmd = radio_buttons(prompt, -FOOTER_ROWS(ps_global), ekey,
  			    'y', 'x', help, RB_NORM);
  
  	switch(cmd){
--- 1070,1077 ----
  		    prompt_fodder);
  	}
  
! 	cmd = ps_global->send_immediately ? 'n' :
! 		radio_buttons(prompt, -FOOTER_ROWS(ps_global), ekey,
  			    'y', 'x', help, RB_NORM);
  
  	switch(cmd){
***************
*** 1608,1615 ****
      ENVELOPE *env;
  {
      char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];
  
!     strncpy(buf, ps_global->VAR_REPLY_STRING, sizeof(buf)-1);
      buf[sizeof(buf)-1] = '\0';
  
      /* set up the prefix to quote included text */
--- 1694,1722 ----
      ENVELOPE *env;
  {
      char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];
+     char reply_string[MAX_PREFIX+1];
+ 
+     { RULE_RESULT *rule;
+       rule = (RULE_RESULT *)
+              get_result_rule(ps_global->vars[V_REPLY_INDENT_RULES].current_val.l,
+                                  FOR_RULE | FOR_COMPOSE , env);
+        if (rule){
+            strncpy(reply_string,rule->result,sizeof(reply_string));
+ 	   reply_string[sizeof(reply_string)-1] = '\0';
+            if (rule->result)
+ 	      fs_give((void **)&rule->result);
+ 	   fs_give((void **)&rule);
+        }
+        else
+ 	  if ((ps_global->VAR_REPLY_STRING) && (ps_global->VAR_REPLY_STRING[0])){
+ 	    strncpy(reply_string,ps_global->VAR_REPLY_STRING, sizeof(reply_string)-1);
+ 	    reply_string[sizeof(reply_string)-1] = '\0';
+ 	  }
+ 	  else
+            strncpy(reply_string,"> ",sizeof("> "));
+     }
  
!     strncpy(buf, reply_string, sizeof(buf)-1);
      buf[sizeof(buf)-1] = '\0';
  
      /* set up the prefix to quote included text */
***************
*** 1665,1674 ****
  int
  reply_quote_str_contains_tokens()
  {
!     return(ps_global->VAR_REPLY_STRING && ps_global->VAR_REPLY_STRING[0] &&
! 	   (strstr(ps_global->VAR_REPLY_STRING, from_token) ||
! 	    strstr(ps_global->VAR_REPLY_STRING, nick_token) ||
! 	    strstr(ps_global->VAR_REPLY_STRING, init_token)));
  }
  
  /*
--- 1772,1802 ----
  int
  reply_quote_str_contains_tokens()
  {
!    char *reply_string;
!       
!    reply_string = (char *) malloc( 80*sizeof(char));
!    { RULE_RESULT *rule;
!      rule = (RULE_RESULT *)
!             get_result_rule(ps_global->vars[V_REPLY_INDENT_RULES].current_val.l,
!                                 FOR_RULE | FOR_COMPOSE, (ENVELOPE *)NULL);
!       if (rule){
!           reply_string = cpystr(rule->result);
! 	  if (rule->result)
! 	     fs_give((void **)&rule->result);
! 	  fs_give((void **)&rule);
!       }
!       else
! 	  if ((ps_global->VAR_REPLY_STRING) && (ps_global->VAR_REPLY_STRING[0])){
! 	    strncpy(reply_string,ps_global->VAR_REPLY_STRING, sizeof(reply_string)-1);
! 	    reply_string[sizeof(reply_string)-1] = '\0';
! 	  }
! 	  else
!           reply_string = cpystr("> ");
!    }
!     return(reply_string && reply_string[0] &&
! 	   (strstr(reply_string, from_token) ||
! 	    strstr(reply_string, nick_token) ||
! 	    strstr(reply_string, init_token)));
  }
  
  /*
***************
*** 1678,1723 ****
   *	     0 if we're NOT to include the text
   *	    -1 on cancel or error
   */
  int
! reply_text_query(ps, many, prefix)
      struct pine *ps;
      long	 many;
      char       **prefix;
  {
      int ret, edited = 0;
!     static ESCKEY_S rtq_opts[] = {
! 	{'y', 'y', "Y", "Yes"},
! 	{'n', 'n', "N", "No"},
! 	{-1, 0, NULL, NULL},	                  /* may be overridden below */
! 	{-1, 0, NULL, NULL}
!     };
  
      if(F_ON(F_AUTO_INCLUDE_IN_REPLY, ps)
!        && F_OFF(F_ENABLE_EDIT_REPLY_INDENT, ps))
        return(1);
  
      while(1){
! 	sprintf(tmp_20k_buf, "Include %s%soriginal message%s in Reply%s%s%s? ",
  		(many > 1L) ? comatose(many) : "",
  		(many > 1L) ? " " : "",
  		(many > 1L) ? "s" : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? " (using \"" : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? *prefix : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? "\")" : "");
  
! 	if(F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps)){
! 	    rtq_opts[2].ch    = ctrl('R');
! 	    rtq_opts[2].rval  = 'r';
! 	    rtq_opts[2].name  = "^R";
! 	    rtq_opts[2].label = "Edit Indent String";
  	}
! 	else
! 	  rtq_opts[2].ch    = -1;
  
  	switch(ret = radio_buttons(tmp_20k_buf, 
  				   ps->ttyo->screen_rows > 4
  				     ? -FOOTER_ROWS(ps_global) : -1,
! 				   rtq_opts,
  				   (edited || F_ON(F_AUTO_INCLUDE_IN_REPLY, ps))
  				       ? 'y' : 'n',
  				   'x', NO_HELP, RB_SEQ_SENSITIVE)){
--- 1806,1896 ----
   *	     0 if we're NOT to include the text
   *	    -1 on cancel or error
   */
+ 
+ #define MAX_REPLY_OPTIONS 8
+ 
  int
! reply_text_query(ps, many, env, prefix)
      struct pine *ps;
      long	 many;
+     ENVELOPE	*env;
      char       **prefix;
  {
      int ret, edited = 0;
!     static ESCKEY_S compose_style[MAX_REPLY_OPTIONS];
!     int     ekey_num;
! 
!     role_chosen = NULL;
!     strip = 1;
  
      if(F_ON(F_AUTO_INCLUDE_IN_REPLY, ps)
!        && F_OFF(F_ENABLE_EDIT_REPLY_INDENT, ps) && F_OFF(F_ALT_REPLY_MENU,ps))
        return(1);
  
      while(1){
!      sprintf(tmp_20k_buf,"Include %s%soriginal message%s in Reply%s%s%s%s%s? ",
  		(many > 1L) ? comatose(many) : "",
  		(many > 1L) ? " " : "",
  		(many > 1L) ? "s" : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? " (using \"" : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? *prefix : "",
+ 		role_chosen ? "\" and role \"" : "", 
+ 		role_chosen ? role_chosen->nick : "", 
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? "\")" : "");
  
! 	   ekey_num = 0;
! 	   compose_style[ekey_num].ch    = 'y';
! 	   compose_style[ekey_num].rval  = 'y';
! 	   compose_style[ekey_num].name  = "Y";
! 	   compose_style[ekey_num++].label = "Yes";
! 
! 	   compose_style[ekey_num].ch    = 'n';
! 	   compose_style[ekey_num].rval  = 'n';
! 	   compose_style[ekey_num].name  = "N";
! 	   compose_style[ekey_num++].label = "No";
! 		
! 	   if (F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps)){
!   	      compose_style[ekey_num].ch      = ctrl('R');
!               compose_style[ekey_num].rval    = 'r';
!               compose_style[ekey_num].name    = "^R";
!               compose_style[ekey_num++].label = "Indent Str" ;
! 	   }
! 
! 
! 
! /***** Alternate Reply Menu ********/
! 
! 	if (F_ON(F_ALT_REPLY_MENU, ps)){
!            unsigned which_help;
!             
! 	   if (F_ON(F_ENABLE_STRIP_SIGDASHES, ps) ||
! 		F_ON(F_ENABLE_SIGDASHES, ps)){
!   	      compose_style[ekey_num].ch      = 's';
!               compose_style[ekey_num].rval    = 's';
!               compose_style[ekey_num].name    = "S";
! 	      if (!strip)
! 	          compose_style[ekey_num++].label = "No Strip";
! 	      else
! 	          compose_style[ekey_num++].label = "Strip Sig";
! 	   }
! 
! 	   compose_style[ekey_num].ch      = 'r';
! 	   compose_style[ekey_num].rval    = 'R';
! 	   compose_style[ekey_num].name    = "R";
! 	   compose_style[ekey_num++].label = "Set Role";
! 
  	}
! 	compose_style[ekey_num].ch    = -1;
! 	compose_style[ekey_num].name  = NULL;
! 	compose_style[ekey_num].label = NULL;
! 
! 
! /***** End Alt Reply Menu  *********/
  
  	switch(ret = radio_buttons(tmp_20k_buf, 
  				   ps->ttyo->screen_rows > 4
  				     ? -FOOTER_ROWS(ps_global) : -1,
! 				   compose_style,
  				   (edited || F_ON(F_AUTO_INCLUDE_IN_REPLY, ps))
  				       ? 'y' : 'n',
  				   'x', NO_HELP, RB_SEQ_SENSITIVE)){
***************
*** 1725,1730 ****
--- 1898,1936 ----
  	    cmd_cancelled("Reply");
  	    return(-1);
  
+ 	  case 's':
+ 	   if (F_ON(F_ENABLE_STRIP_SIGDASHES, ps) ||
+ 		F_ON(F_ENABLE_SIGDASHES, ps)){
+ 		strip = (strip + 1) % 2;
+ 	   }
+ 	   else
+ 	    q_status_message1(SM_ORDER, 3, 4,
+ 			      "Invalid rval \'%s\'", pretty_command(ret));
+ 	   break;
+ 
+ 	  case 'R':
+ 	  {
+            void (*prev_screen)() = ps->prev_screen,
+                (*redraw)() = ps->redrawer;
+            ps->redrawer = NULL;
+            ps->next_screen = SCREEN_FUN_NULL;
+            if(role_select_screen(ps, &role_chosen, 1) < 0){
+              cmd_cancelled("Reply");
+              ps->next_screen = prev_screen;
+              ps->redrawer = redraw;
+ 	     if (ps->redrawer)
+ 		(*ps->redrawer)();
+ 	     continue;
+            }
+            ps->next_screen = prev_screen;
+            ps->redrawer = redraw;
+            if(role_chosen)
+               role_chosen = combine_inherited_role(role_chosen);
+ 	  }
+ 	  if (ps->redrawer)
+ 	     (*ps->redrawer)();
+ 	  break;
+ 
  	  case 'r':
  	    if(prefix && *prefix){
  		int  done = 0;
***************
*** 2236,2241 ****
--- 2442,2451 ----
      buf[0] = '\0';
  
      switch(type){
+       case iFfrom:
+ 	addr = env && env->sparep ? env->sparep : NULL;
+ 	break;
+ 
        case iFrom:
  	addr = env ? env->from : NULL;
  	break;
***************
*** 2643,2663 ****
  
  	break;
  
        case iFrom:
        case iTo:
        case iCc:
        case iSender:
        case iRecips:
        case iInit:
  	get_addr_data(env, type, buf, maxlen);
  	break;
  
!       case iRoleNick:
! 	if(role && role->nick){
! 	    strncpy(buf, role->nick, maxlen);
! 	    buf[maxlen] = '\0';
! 	}
! 	break;
  
        case iAddress:
        case iMailbox:
--- 2853,2973 ----
  
  	break;
  
+       case iRole:
+         if (ps_global->role)
+ 	   sprintf(buf, ps_global->role);
+       break;
+ 
+       case iRoleNick:
+ 	if(role && role->nick){
+ 	    strncpy(buf, role->nick, maxlen);
+ 	    buf[maxlen] = '\0';
+ 	}
+ 	break;
+ 
+       case iFfrom:
        case iFrom:
        case iTo:
        case iCc:
        case iSender:
        case iRecips:
        case iInit:
+       if (env)  
  	get_addr_data(env, type, buf, maxlen);
  	break;
  
!      case iFolder:
!       sprintf(buf,ps_global->cur_folder);
!       break;
! 
!      case iCollection:
!       sprintf(buf,ps_global->context_current->nickname);
!       break;
!       
!      case iFlag:
!         {MAILSTREAM *stream = find_open_stream();
! 	 MSGNO_S *msgmap = NULL;
!          long msgno;
!          MESSAGECACHE *mc;
!          strcpy(buf, "_FLAG_");         /* default value */
! 	 if (stream){
! 	     mn_init(&msgmap, stream->nmsgs);
! 	     msgno =  mn_m2raw(msgmap, rules_cursor_pos(stream));
! 	     if (msgno > 0L) mc = stream ? mail_elt(stream,  msgno) : NULL;
! 	     if (mc)
! 		sprintf(buf,"%s%s%s%s",mc->flagged ? "*" : "",
! 		mc->recent   ? (mc->seen ? "R" : "N") : (mc->seen) ? "R" : "U",
! 		mc->answered ? "A" : "",
! 		mc->deleted  ? "D" : "" );
! 	     mn_give(&msgmap);
! 	 }
! 	}
!         break;
!          
!      case iNick:
!      {
!       ADDRESS *tmp_adr = NULL;
!       if (env){
!          tmp_adr = env->from ? copyaddr(env->from)
!                      : env->sender ? copyaddr(env->sender) : NULL;
!          get_nickname_from_addr(tmp_adr,buf,maxlen);
! 	 mail_free_address(&tmp_adr);
!       }
!      }
!         break;
! 
!      case iAddressCc:
!      case iAddressRecip:
!      case iAddressTo:
!      case iFadd:
!      {
!      int plen = 0; 	/* partial length */
!      ADDRESS *sparep2 = (type == iAddressTo || type == iAddressRecip) 
! 			? ((env && env->to) 
! 			   ? copyaddrlist(env->to)
! 			   : NULL)
! 			: (type == iAddressCc)
! 			    ? ((env && env->cc) 
! 				? copyaddrlist(env->cc)
! 				: NULL)
! 			    : ((env && env->sparep) 
! 				? copyaddr((ADDRESS *)env->sparep)
! 				: NULL);
!       ADDRESS *sparep;
! 
!       if (type == iAddressRecip){
! 	  ADDRESS *last_to = NULL;
! 
! 	for(last_to = sparep2;last_to && last_to->next; last_to= last_to->next);
! 	
! 	/* Make the end of To list point to cc list */
! 	if(last_to)
! 	  last_to->next = (env && env->cc ? copyaddrlist(env->cc) : NULL);
! 
!       }
!       sparep = sparep2;
!       for(; sparep ; sparep = sparep->next)
! 	if(sparep && sparep->mailbox && sparep->mailbox[0] &&
! 	   (plen ? plen + 1 : plen) + strlen(sparep->mailbox) <= maxlen){
! 	   if (plen == 0)
! 	       strcpy(buf, sparep->mailbox);
! 	   else{
! 	       strcat(buf, " ");
! 	       strcat(buf, sparep->mailbox);
! 	   }
! 	   if(sparep->host &&
!         	   sparep->host[0] &&
! 		   sparep->host[0] != '.' &&
! 		   strlen(buf) + strlen(sparep->host) + 1 <= maxlen){
! 	      strcat(buf, "@");
!               strcat(buf, sparep->host);
!            }
! 	   plen = strlen(buf);
! 	}
! 	 mail_free_address(&sparep2);
!      }
!          
!       break;  
  
        case iAddress:
        case iMailbox:
***************
*** 2676,2681 ****
--- 2986,2996 ----
  
  	break;
  
+       case iLcc:	/* fake it, there are not enough spare pointers */
+ 	if (env && env->date)
+ 	  sprintf(buf,env->date);
+ 	break;
+ 
        case iNews:
  	get_news_data(env, type, buf, maxlen);
  	break;
***************
*** 2782,2789 ****
      char          *filtered = NULL;
      int            len;
  
  
-     strncpy(buf, ps_global->VAR_REPLY_INTRO, MAX_DELIM);
      buf[MAX_DELIM] = '\0';
      /* preserve exact default behavior from before */
      if(!strcmp(buf, DEFAULT_REPLY_INTRO)){
--- 3097,3116 ----
      char          *filtered = NULL;
      int            len;
  
+     { RULE_RESULT *rule;
+        rule = (RULE_RESULT *)
+               get_result_rule(ps_global->VAR_REPLY_LEADIN_RULES,
+                                         FOR_RULE | FOR_REPLY_INTRO, env);
+        if (rule){
+           strncpy(buf, rule->result, MAX_DELIM);
+           if (rule->result)
+ 	     fs_give((void **)&rule->result);
+ 	  fs_give((void **)&rule);
+        }
+        else
+           strncpy(buf, ps_global->VAR_REPLY_INTRO, MAX_DELIM);
+     }
  
      buf[MAX_DELIM] = '\0';
      /* preserve exact default behavior from before */
      if(!strcmp(buf, DEFAULT_REPLY_INTRO)){
***************
*** 2954,2962 ****
  	}
  	else if(!outgoing->newsgroups)
  	  outgoing->newsgroups = cpystr(env->newsgroups);
- 	if(!IS_NEWS(ps_global->mail_stream))
- 	  q_status_message(SM_ORDER, 2, 3,
-  "Replying to message that MAY or MAY NOT have been posted to newsgroup");
      }
  
      return(ret);
--- 3281,3286 ----
***************
*** 3017,3022 ****
--- 3341,3348 ----
  
      if(is_sig){
  	/*
+ 	 * First we check if there is a rule about signatures, if there is
+ 	 * use it, otherwise keep going and do the following:
  	 * If role->litsig is set, we use it;
  	 * Else, if VAR_LITERAL_SIG is set, we use that;
  	 * Else, if role->sig is set, we use that;
***************
*** 3030,3043 ****
  	 * there is no reason to mix them, so we don't provide support to
  	 * do so.
  	 */
! 	if(role && role->litsig)
! 	  literal_sig = role->litsig;
! 	else if(ps_global->VAR_LITERAL_SIG)
! 	  literal_sig = ps_global->VAR_LITERAL_SIG;
! 	else if(role && role->sig)
! 	  sigfile = role->sig;
! 	else
! 	  sigfile = ps_global->VAR_SIGNATURE_FILE;
      }
      else if(role && role->template)
        sigfile = role->template;
--- 3356,3382 ----
  	 * there is no reason to mix them, so we don't provide support to
  	 * do so.
  	 */
!         { RULE_RESULT *rule;
!            rule = (RULE_RESULT *)
!               get_result_rule(ps_global->vars[V_COMPOSE_RULES].current_val.l,
!                                      FOR_RULE | FOR_COMPOSE, env);
!            if (rule){
!                sigfile = cpystr(rule->result);
! 	       if (rule->result)
! 	          fs_give((void **)&rule->result);
! 	       fs_give((void **)&rule);
! 	   }
!         }
! 	if (!sigfile){
! 	  if(role && role->litsig)
! 	    literal_sig = role->litsig;
! 	  else if(ps_global->VAR_LITERAL_SIG)
! 	    literal_sig = ps_global->VAR_LITERAL_SIG;
! 	  else if(role && role->sig)
! 	    sigfile = role->sig;
! 	  else
! 	    sigfile = ps_global->VAR_SIGNATURE_FILE;
! 	}
      }
      else if(role && role->template)
        sigfile = role->template;
***************
*** 3236,3242 ****
  		    }
  		}
  		/* these are all from the envelope */
! 		else if(pt->what_for & FOR_REPLY_INTRO)
  		  repl = get_reply_data(env, role, pt->ctype,
  					subbuf, sizeof(subbuf)-1);
  
--- 3575,3581 ----
  		    }
  		}
  		/* these are all from the envelope */
! 		else if(pt->what_for & (FOR_REPLY_INTRO| FOR_RULE))
  		  repl = get_reply_data(env, role, pt->ctype,
  					subbuf, sizeof(subbuf)-1);
  
***************
*** 3689,3695 ****
  	rflags = ROLE_FORWARD;
  	if(nonempty_patterns(rflags, &dummy)){
  	    role = (totalmsgs == 1) ? set_role_from_msg(ps, rflags, msgno, NULL)
! 				    : NULL;
  	    if(confirm_role(rflags, &role))
  	      role = combine_inherited_role(role);
  	    else{				/* cancel reply */
--- 4028,4034 ----
  	rflags = ROLE_FORWARD;
  	if(nonempty_patterns(rflags, &dummy)){
  	    role = (totalmsgs == 1) ? set_role_from_msg(ps, rflags, msgno, NULL)
! 				    :  set_role_from_agg(ps, rflags, NULL);
  	    if(confirm_role(rflags, &role))
  	      role = combine_inherited_role(role);
  	    else{				/* cancel reply */
***************
*** 3701,3709 ****
  	}
      }
  
!     if(role)
        q_status_message1(SM_ORDER, 3, 4,
  			"Forwarding using role \"%.200s\"", role->nick);
  
      if(role && role->template){
  	char *filtered;
--- 4040,4053 ----
  	}
      }
  
!     if (ps_global->role)
! 	fs_give((void **)&ps_global->role);
! 
!     if(role){
        q_status_message1(SM_ORDER, 3, 4,
  			"Forwarding using role \"%.200s\"", role->nick);
+       ps_global->role = cpystr(role->nick);
+     }
  
      if(role && role->template){
  	char *filtered;
***************
*** 3907,3912 ****
--- 4251,4257 ----
  #if	defined(DOS) && !defined(_WINDOWS)
      free((void *)reserve);
  #endif
+     outgoing->sparep = env && env->from ? (ADDRESS *)copyaddr(env->from) : NULL;
      pine_send(outgoing, &body, "FORWARD MESSAGE",
  	      role, NULL, reply.flags ? &reply : NULL, redraft_pos,
  	      NULL, NULL, FALSE);
***************
*** 4828,4833 ****
--- 5173,5181 ----
   		if(flow_res)
  		  wrapflags |= GFW_FLOW_RESULT;
  
+ 		filters[i].filter = gf_quote_test;
+ 		filters[i++].data = gf_line_test_opt(select_quote, NULL);
+ 
  		filters[i].filter = gf_wrap;
  		/* 
  		 * The 80 will cause longer lines than what is likely
***************
*** 4877,4882 ****
--- 5225,5234 ----
  	    filters[i].filter = gf_rich2plain;
  	    filters[i++].data = gf_rich2plain_opt(1);
  	}
+ 	if(strucmp(body->subtype,"enriched") == 0){
+ 	    filters[i].filter = gf_enriched2plain;
+ 	    filters[i++].data = gf_enriched2plain_opt(1);
+ 	}
  	else if(strucmp(body->subtype,"html") == 0){
  	    filters[i].filter = gf_html2plain;
  	    filters[i++].data = gf_html2plain_opt(NULL,
***************
*** 4886,4893 ****
      }
  
      if(prefix){
! 	if(F_ON(F_ENABLE_SIGDASHES, ps_global) ||
! 	   F_ON(F_ENABLE_STRIP_SIGDASHES, ps_global)){
  	    dashdata = 0;
  	    filters[i].filter = gf_line_test;
  	    filters[i++].data = gf_line_test_opt(sigdash_strip, &dashdata);
--- 5238,5245 ----
      }
  
      if(prefix){
! 	if(strip && (F_ON(F_ENABLE_SIGDASHES, ps_global) ||
! 	   F_ON(F_ENABLE_STRIP_SIGDASHES, ps_global))){
  	    dashdata = 0;
  	    filters[i].filter = gf_line_test;
  	    filters[i++].data = gf_line_test_opt(sigdash_strip, &dashdata);
diff -rc pine4.61/pine/rules.c pine4.61.I.USE/pine/rules.c
*** pine4.61/pine/rules.c	Thu Sep 23 15:32:08 2004
--- pine4.61.I.USE/pine/rules.c	Fri Sep 17 09:26:29 2004
***************
*** 0 ****
--- 1,1150 ----
+ /*----------------------------------------------------------------------
+   
+             T H E    P I N E    M A I L   S Y S T E M
+ 
+    Laurence Lundblade and Mike Seibel
+    Networks and Distributed Computing
+    Computing and Communications
+    University of Washington
+    Administration Builiding, AG-44
+    Seattle, Washington, 98195, USA
+    Internet: lgl@CAC.Washington.EDU
+              mikes@CAC.Washington.EDU
+ 
+    Please address all bugs and comments to "pine-bugs@cac.washington.edu"
+ 
+    This set of rules was written by
+ 
+    Eduardo Chappa (chappa@math.washington.edu)
+    http://www.math.washington.edu/~chappa/pine/
+ 
+    Original Version: November 1999
+    Last Modified   : July 26, 2004
+ 
+    Send bug reports about this module to the address above.
+ 
+    Pine and Pico are registered trademarks of the University of Washington.
+    No commercial use of these trademarks may be made without prior written
+    permission of the University of Washington.
+ 
+    Pine, Pico, and Pilot software and its included text are Copyright
+    1989-2002 by the University of Washington.
+ 
+    The full text of our legal notices is contained in the file called
+    CPYRIGHT, included with this distribution.
+ 
+ 
+    Pine is in part based on The Elm Mail System:
+     ***********************************************************************
+     *  The Elm Mail System  -  Revision: 2.13                             *
+     *                                                                     *
+     *                   Copyright (c) 1986, 1987 Dave Taylor              *
+     *                   Copyright (c) 1988, 1989 USENET Community Trust   *
+     ***********************************************************************
+  
+ 
+   ----------------------------------------------------------------------*/
+ 
+ #include "rules.h"
+ 
+ /* get_result_rule:
+  * Parameters: list: the list of rules to be passed to the function to check
+  *             rule_context: context of the rule
+  *             env : envelope used to check the rule, if needed.
+  *
+  *
+  *
+  * Returns: The value of the first rule that is satisfied in the list, or
+  *          NULL if not. This function should be called in the following 
+  *          way (notice that memory is freed by caller).
+  *
+  * You should use this function to obtain the result of a rule. You can
+  * also call directly "process_rule", but I advice to use this function if
+  * there's no difference on which function to call.
+ 
+    RULE_RESULT *rule;
+ 
+    rule = (RULE_RESULT *) 
+            get_result_rule(ps_global->VAR_SOME_RULE, context, envelope);
+ 
+    if (rule){ 
+        assign the value of rule->result;
+        if (rule->result)
+           fs_give((void **)&rule->result);
+        fs_give((void **)&rule);
+    }
+  */
+ 
+ RULE_RESULT *
+ get_result_rule(list, rule_context, env)
+ char **list;
+ int   rule_context;
+ ENVELOPE *env;
+ {
+     char  *rule_result = NULL;
+     int    n = 0, we_cancel = FALSE;
+     char  *rule_data;
+     RULE_RESULT *rule;
+     
+     if (list && *list){
+        while (!we_cancel && list[n] && *list[n]){
+          rule_data = cpystr(list[n++]);
+          rule_result = (char *)process_rule(rule_data, rule_context, env);
+          if (rule_result && *rule_result)
+             we_cancel = TRUE;
+          if (rule_data)
+             fs_give ((void **)&rule_data);
+        }
+        if (rule_result && *rule_result){
+           rule = (RULE_RESULT *) fs_get (sizeof(RULE_RESULT));
+           rule->result = cpystr(rule_result);
+           rule->number = --n;
+           fs_give((void **)&rule_result);
+           return rule;
+        }
+     }
+     return (RULE_RESULT *) NULL;
+ }
+ 
+ /* process_rule:
+    Parameters: rule_data, is a rule. It's obtained as
+                 rule_data = ps_global->vars[V_SOME_RULE].current_val.l[n], for
+                 some integer n
+                 rule_context: context of the rule, and
+                 env: An envelope if needed.
+ 
+    Returns   : The value of the processed rule_data if the processing was 
+                successful and matches context and possibly the envelope, or
+                NULL if there's no match
+  */
+ 
+ char *process_rule (rule_data, rule_context, env)
+ char *rule_data;
+ int  rule_context;
+ ENVELOPE *env;
+ {
+     RULE_ACTION *action;       /* The part of the rule after the separator  */
+     int   i;
+     char *new_rule, *result = NULL;
+ 
+     action = get_action(rule_data,rule_context, env);
+         
+     if (action && action->value && *action->value){
+         if (action->type)
+           result = (char *) detoken_src(action->value, rule_context, env, NULL, NULL, NULL);
+         else{
+           for (i = 0; i < NFCN; i++){
+               if (action_has_function(action->value,rule_fcns[i].name)){
+                 result = (*rule_fcns[i].execute)(action->value, rule_context, env);
+                 break;
+               }
+           }
+         }
+     }
+     if (action){
+        if (action->value)
+           fs_give((void **)&action->value);
+         fs_give((void **)&action);
+     }
+     return result;
+ }
+ 
+ /*
+  * The following function tests if a condition given in a rule is satisfied or
+  * not. Returns true if and only if the condition is satisfied.
+  *
+  *  Parameters: Rule_condition : the condition to be tested
+  *              rule_context   : in which context will the condition be tested
+  *              env            : If we are in a context were we need an envelope
+  *                               to test this variable is needed. It is NULL 
+  *                               if not needed.
+  */
+ int
+ test_condition(rule_condition, rule_context, env)
+ char *rule_condition;
+ int rule_context;
+ ENVELOPE *env;
+ {
+     int   list_of_rel[NREL] = {0};
+     int   save_to_rule, apply_rule, and_rel, test;
+     char *separator;         /* Pointer to the position of a separtor   */
+     char *group;             /* The value of the group to compare the token */
+     int   next_step = TRUE;
+     int   i;
+ 
+     /*---------  find the relation -------------*/
+ 
+     if (next_step){
+ 	for (i = 0; i < NREL && next_step; i++){
+ 	   if (strstr(rule_condition,rel_rules_test[i].value)){
+ 	      list_of_rel[i] = (strstr(rule_condition,rel_rules_test[i].value) != NULL);
+ 	      next_step =  list_of_rel[i];
+ 	   }
+ 	}
+ 	next_step = next_step && (list_of_rel[NREL - 2] == list_of_rel[NREL - 1]);
+     }
+ 
+    /*------- Get the set (we call it group in here) ------------*/
+ 
+     separator = strstr(rule_condition,OPEN_SET);
+     if ((next_step) && (*separator++)){
+         char *new_group = get_group(separator);
+         group = (char *) detoken_src(new_group, rule_context, env, NULL, NULL, NULL);
+         fs_give((void **)&new_group);
+     }
+     else
+         next_step = FALSE;
+ 
+ 
+    /*------- Test the token with the set ------------*/
+ 
+     if (next_step){
+         i = -1;
+         do{
+           if (list_of_rel[++i]){
+              list_of_rel[i] = (*rel_rules_test[i].execute)(group, rule_condition, env, rule_context);
+              list_of_rel[i] = (list_of_rel[i] < NTOKENS);
+           }
+         } while ((i < (NREL - 3)) && (!list_of_rel[i]));
+         next_step = list_of_rel[i];
+     }
+     if (group)
+         fs_give((void **)&group);
+    return next_step;
+ }
+ 
+ /* returns the name of the token it found or NULL if there is no token, the 
+  * real value of the token is obtained by calling the detoken_src function. I
+  * guess I should have called it get_name_token. Memory freed by caller.
+  * Leave condition unchanged.
+  */
+ 
+ char *
+ get_value_token (condition)
+   char *condition;
+ {
+   char *p = NULL, *q, *s;
+ 
+     if (q = strchr(condition,'_')){
+ 	if (s = strchr(q+1,'_')){
+ 	    char c = *++s;
+ 	    *s = '\0';
+ 	     p = cpystr(q);
+ 	    *s = c;
+ 	}
+     }
+     return p;
+ }
+ 
+ /* This function tests if a string contained in the variable "group" is
+    in the "condition"
+  */
+ 
+ int test_in (group, condition, env, rule_context)
+ char *group;
+ char *condition;
+ ENVELOPE *env;
+ int rule_context;
+ {
+  int i = 0;
+  char *test, *src;
+ 
+     src  = get_value_token(condition);
+     test = (char *) detoken_src(src, rule_context, env, NULL, NULL, NULL);
+     if (test && *test)
+ 	while ((i < NTOKENS) && ((strstr(condition,token_rules[i]) == NULL) 
+ 	   || (strstr(group, test) == NULL)))
+        i++;
+     else
+        i = NTOKENS;
+     if (src) fs_give((void **)&src);
+     if (test) fs_give((void **)&test);
+ 
+     return i;
+ }
+ 
+ int 
+ test_ni (group, condition, env, rule_context)
+ char *group;
+ char *condition;
+ ENVELOPE *env;
+ int rule_context;
+ {
+  int i = 0;
+  char *test, *src;
+  src   = get_value_token(condition);
+  test  = (char *) detoken_src(src, rule_context, env, NULL, NULL, NULL);
+  while ((i < NTOKENS) && ((strstr(condition,token_rules[i]) == NULL) 
+         || !(contain(group,test))))
+    i++;
+  if (src)  fs_give((void **)&src);
+  if (test) fs_give((void **)&test);
+ return i;
+ }
+ 
+ int test_not_in (group, condition, env, rule_context)
+ char *group;
+ char *condition;
+ ENVELOPE *env;
+ int rule_context;
+ {
+  int i = 0;
+  char *test, *src;
+  src  = get_value_token(condition);
+  test = (char *) detoken_src(src, rule_context, env, NULL, NULL, NULL);
+  if (test && *test)
+  while ((i < NTOKENS) && ((strstr(condition,token_rules[i]) == NULL) 
+         || ((int) strstr(group, test) != 0)))
+    i++;
+   else
+     i = NTOKENS;
+   if (src)  fs_give((void **)&src);
+   if (test) fs_give((void **)&test);
+ return i;
+ }
+ 
+ int test_not_ni (group, condition, env, rule_context)
+ char  *group;
+ char *condition;
+ ENVELOPE *env;
+ int rule_context;
+ {
+  int i = 0;
+  char *test, *src;
+  src  = get_value_token(condition);
+  test = (char *) detoken_src(src, rule_context, env, NULL, NULL, NULL);
+  while ((i < NTOKENS) && ((strstr(condition,token_rules[i]) == NULL) 
+         || (contain(group,test))))
+    i++;
+   if (src)  fs_give((void **)&src);
+   if (test) fs_give((void **)&test);
+ return i;
+ }
+ 
+ int test_eq (group, condition, env, rule_context)
+ char *group;
+ char *condition;
+ ENVELOPE *env;
+ int rule_context;
+ {
+  int i = 0;
+  char *test, *src;
+  src   = get_value_token(condition);
+  test  = (char *) detoken_src(src, rule_context, env, NULL, NULL, NULL);
+  while ((i < NTOKENS) && ((strstr(condition,token_rules[i]) == NULL) 
+         || (mystrcmp(group, test))))
+    i++;
+  if (src)  fs_give((void **)&src);
+  if (test) fs_give((void **)&test);
+ return i;
+ }
+ 
+ int test_not_eq (group, condition, env, rule_context)
+ char *group;
+ char *condition;
+ ENVELOPE *env;
+ int rule_context;
+ {
+  int i = 0;
+  char *test, *src;
+  src  = get_value_token(condition);
+  test = (char *) detoken_src(src, rule_context, env, NULL, NULL, NULL);
+  while ((i < NTOKENS) && ((strstr(condition,token_rules[i]) == NULL) 
+         || (!mystrcmp(group, test))))
+    i++;
+  if (src)  fs_give((void **)&src);
+  if (test) fs_give((void **)&test);
+ return i;
+ }
+ 
+ int test_open (group, condition, env, rule_context)
+ char *group;
+ char *condition;
+ ENVELOPE *env;
+ int rule_context;
+ {
+ return 0;
+ }
+ 
+ int test_close (group, condition, env, rule_context)
+ char *group;
+ char *condition;
+ ENVELOPE *env;
+ int rule_context;
+ {
+ return 0;
+ }
+ 
+ int contain (group, condition)
+ char *group;
+ char *condition;
+ {
+  int error = 0;
+  int rv = TRUE;
+    if (!(condition && *condition))
+       return (group && *group) ? FALSE : TRUE;
+ 
+    if (group && *group){
+      int length = 0;
+      char *group_backup;
+      if (*group == ';')
+          group++;
+      group_backup = advance_to_char(group,';', RELAXED, &error);
+      if (group_backup && *group_backup && 
+ 	(strstr(condition, group_backup) == NULL)){
+ 	  group += strlen(group_backup) + error;
+ 	  rv = (group && *group) ? contain(++group,condition) : FALSE;
+ 	  fs_give((void **)&group_backup);
+      }
+    }
+    return rv; /* to make _TOKEN_ >> {} always TRUE */
+ }
+ 
+ int mystrcmp (group, condition) /* answers the question: are group and */
+ char *group;                    /* condition different? */
+ char *condition;
+ {
+  int error = 0;
+  int rv = FALSE;
+  if (group && *group){
+    int length = 0;
+    char *group_backup;
+    if (*group == ';')
+         group++;
+    group_backup = advance_to_char(group,';', RELAXED, &error);
+    if (!(condition && *condition)){
+       if (group_backup){
+ 	  group += *group_backup ? strlen(group_backup) : 0;
+ 	  rv = (group && *group) ? mystrcmp(group, condition) : TRUE;
+ 	  fs_give((void **)&group_backup);
+       }
+       return rv;
+    }
+    if (group_backup && *group_backup)
+        if (!strcmp(group_backup, condition)){
+           fs_give((void **)&group_backup);
+           return rv;
+        }
+        else{
+           group += strlen(group_backup);
+           fs_give((void **)&group_backup);
+ 	  rv = (*group) ? mystrcmp(group,condition) 
+ 			: ((condition && *condition) ? TRUE : FALSE);
+        }
+     else /* group_backup && *group_backup  */
+        rv =  (condition && *condition) ? TRUE : FALSE;
+  }
+  else  /* group  && *group */
+     rv = (condition && *condition) ?  TRUE : FALSE;
+  return rv;
+ }
+ 
+ char *
+ do_trim (begin_text, end_text)
+ char *begin_text;
+ char *end_text;
+ {
+    int error = 0;
+    char *position, *result;
+    if (begin_text && *begin_text && end_text && *end_text){
+       char *end_text_backup;
+       if (*end_text == ';')
+          *end_text++; 
+       end_text_backup = advance_to_char(end_text,';', RELAXED, &error);
+       if (begin_text[strlen(begin_text) - 1] == '\002')
+         begin_text[strlen(begin_text) - 1] = '\0';
+       if (!(end_text_backup && *end_text_backup)){
+         *end_text++;
+         return do_trim (begin_text, end_text);
+       }
+       while (strstr(begin_text,end_text_backup)){
+          char *new_begin_text;
+          int i = 0, j = 0, l, where;
+ 
+          position = cpystr(strstr(begin_text,end_text_backup));
+          where = strlen(begin_text) - strlen(position);
+          new_begin_text = (char *) fs_get((strlen(begin_text) + strlen(position) - strlen(end_text_backup) + 1)*sizeof(char));
+          while (i < where){
+            new_begin_text[i] = begin_text[i];
+            i++;
+          }
+          l = strlen(end_text_backup);
+          while (position[l + j]){
+            new_begin_text[i + j] = position[l + j];
+            j++;
+          }
+          new_begin_text[i + j] = '\0';
+          begin_text = cpystr(new_begin_text);
+          fs_give((void **)&position);
+          fs_give((void **)&new_begin_text);
+       }
+       end_text += strlen(end_text_backup);
+       if (end_text_backup)
+          fs_give((void **)&end_text_backup);
+       if (end_text && *end_text){
+          end_text++;
+          return do_trim (begin_text, end_text);
+       }
+       else{
+          result = cpystr(begin_text);
+          return result;
+       }
+    }
+    else{
+      result = cpystr(begin_text);
+      return result;
+    }
+ }
+ 
+ 
+ char *save_to (condition, context, env)
+ char *condition;
+ int   context;
+ ENVELOPE *env;
+ {
+ int error = 0;
+ char *token;
+ char *save_condition, *new_condition, *save_folder;
+ 
+ if (context & FOR_SAVE){
+    save_condition = strstr(condition, SAVE_FCN);
+    while (save_condition && *save_condition)
+      if (*save_condition != '{')
+         *save_condition++;
+      else
+         break;
+    token = get_value_token(save_condition);
+    if (token){
+      new_condition = (char *) detoken_src(save_condition, context, env, NULL, NULL, NULL);
+      fs_give((void **)&token);
+    }
+    else
+      new_condition = cpystr(save_condition);
+    *new_condition++;
+    save_folder = advance_to_char(new_condition,'}', RELAXED, &error);
+    if (new_condition){
+       *new_condition--;
+       fs_give((void **)&new_condition);
+    }
+    return save_folder;
+ }
+ else
+    return NULL;
+ }
+ 
+ 
+ char *
+ get_end_text(condition, context, env, function)
+ char *condition;
+ int  context;
+ ENVELOPE *env;
+ char *function;
+ {
+    char *new_end_text, *separator, *end_text, *token;
+    int length;
+ 
+    if (condition)
+       length = strlen(condition);
+    else
+       return NULL;
+ 
+    condition +=length;
+    for (length; length > 0; length--){
+ 
+         *condition--;
+         if (separator = strstr(condition, function)){
+            separator += strlen(function) + 1;
+            new_end_text = get_group(separator);
+            token = get_value_token(new_end_text);
+            if (token){
+                 end_text = (char *) detoken_src(new_end_text, context, env, NULL, NULL, NULL);
+                 fs_give((void **)&token);
+                 fs_give((void **)&new_end_text);
+            }
+            else
+               end_text = new_end_text;
+            break;
+         }
+    }
+    return end_text;
+ }
+ 
+ char *
+ get_begin_text(condition, context, env, function)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ char *function;
+ {
+    char *new_begin_text, *token, *begin_text;
+    int copy = 1, i = 0,  j = 0, k, separator = 0, save, found = 0;
+    int length;
+ 
+    if (condition)
+       length = strlen(condition);
+    else
+       return NULL;
+ 
+    while (condition[i]){
+       switch(condition[i]){
+ 	case ':' : copy = 0; save = i; separator++;
+ 	      break;
+ 	case '=' : if (separator)
+ 		found++;
+ 	      separator = 0;
+ 	      break;
+ 	case '_' : if (found || (i < 2)){
+ 		for (k = 0; condition[i+k] == function[k]; k++);
+ 		  if (k == strlen(function)) /* bingo! */
+ 		    i = length;
+ 		  else{
+ 		    if (found) 
+ 			i = save;
+ 		    copy++;
+ 		  }
+ 	      }
+ 	      found = 0;
+ 	      break;
+       }
+       if (copy)	j++;
+       i++;
+    }
+    condition[j] = '\0';
+    token = get_value_token(condition);
+    if (token){
+         begin_text = (char *) detoken_src(condition, context, env, NULL, NULL, NULL);
+         fs_give((void **)&token);
+    }
+    else
+       begin_text = condition;
+    return begin_text;
+ }
+ 
+ 
+ 
+ char *
+ trim (condition, context, env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ char *begin_text, *end_text, *result;
+ 
+ if (context & FOR_TRIM){
+    if (!condition || !*condition)
+        return NULL;
+    end_text = get_end_text(condition,context,env, TRIM_FCN);
+    begin_text = get_begin_text(condition, context, env, TRIM_FCN);
+    result = do_trim(begin_text,end_text);
+    if (begin_text) fs_give((void **)&begin_text);
+    if (end_text)   fs_give((void **)&end_text);
+    return result;
+ }
+ else
+    return NULL;
+ }
+ 
+ char *
+ rextrim (condition, context, env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ char *begin_text, *end_text, *final_end_text, *result;
+ 
+ if (context & FOR_TRIM){
+    if (!condition || !*condition)
+       return NULL;
+    end_text = get_end_text(condition,context,env, REXTRIM_FCN);
+    begin_text = get_begin_text(condition, context, env, REXTRIM_FCN);
+    final_end_text = expand(begin_text, end_text);
+    result = do_trim(begin_text,final_end_text);
+    /* free, free, set them free! */
+    if (begin_text)	fs_give((void **)&begin_text);
+    if (end_text)	fs_give((void **)&end_text);
+    if (final_end_text)	fs_give((void **)&final_end_text);
+    return result;
+ }
+ else
+    return NULL;
+ }
+ 
+ char *
+ replace (condition, context, env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+    return  (context & FOR_REPLACE) 
+ 	   ? get_end_text(condition,context,env, REPLACE_FCN)
+ 	   : NULL;
+ }
+ 
+ 
+ char *
+ get_sort_rule (condition, context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn(condition, SORT_FCN, context, FOR_SORT);
+ }
+ 
+ char *
+ get_sgn_rule (condition, context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn(condition, SIGNATURE_FCN, context, FOR_COMPOSE);
+ }
+ 
+ char *
+ get_smtp_rule (condition, context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn(condition, SMTP_FCN, context, FOR_COMPOSE);
+ }
+ 
+ char *
+ rep_str_rule (condition, context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn(condition, REPLYSTR_FCN, context, FOR_COMPOSE);
+ }
+ 
+ 
+ char *
+ get_index_rule (condition,context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn(condition, INDEX_FCN, context, FOR_INDEX);
+ }
+ 
+ char *
+ thrdstyle (condition,context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn(condition, THRDSTYLE_FCN, context, FOR_THREAD);
+ }
+ 
+ char *
+ thrdindex (condition,context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn(condition, THRDINDEX_FCN, context, FOR_THREAD);
+ }
+ 
+ 
+ char *
+ get_reply_str (condition,context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn((char *) detoken_src(condition, context, env, NULL, NULL, NULL), REPLY_FCN, context, FOR_REPLY_INTRO);
+ }
+ 
+ char *
+ get_reply_sub (condition,context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn((char *) detoken_src(condition, context, env, NULL, NULL, NULL), RESUB_FCN, context, FOR_RESUB);
+ }
+ 
+ char *
+ startup_rule (condition,context,env)
+ char *condition;
+ int context;
+ ENVELOPE *env;
+ {
+ return execute_fcn(condition, STARTUP_FCN, context, FOR_STARTUP);
+ }
+ 
+ 
+ char *
+ execute_fcn (condition, given_condition,context, given_context)
+ char *condition;
+ char *given_condition;
+ int context;
+ int given_context;
+ {
+ int error = 0;
+ if (context & given_context){
+    condition = strstr(condition, given_condition);
+    while (condition && *condition)
+      if (*condition != '{')
+         *condition++;
+      else
+         break;
+    *condition++;
+    return advance_to_end(condition);
+ }
+ else
+    return NULL;
+ }
+ 
+ /* advances until the last '}' */
+ 
+ char *
+ advance_to_end(condition)
+ char *condition;
+ {
+  char *q,*p = condition;
+  if (condition && *condition){
+      while (*condition)
+         *condition++;
+      condition--;
+      while (condition && *condition && (*condition != '}'))
+         *condition--;
+      *condition = '\0';
+      q = cpystr(p);
+      return q;
+  }
+  return NULL;
+ }
+ 
+ 
+ /* advances given_string until it finds given_char  */
+ 
+ char *advance_to_char(given_string,given_char, flag, error) 
+ char *given_string;                          
+ char given_char;
+ int flag;
+ int *error;
+ {
+    char *special_characters = "{};"; /* {};  are special characters*/
+    char *string_backup;
+    int  i, j;
+    int  length_string;
+    int  is_special_character = FALSE;
+    int  there_is_special_character = FALSE;
+ 
+    if (error) 
+       *error = 0;
+ 
+    if (given_string && *given_string)
+        length_string = strlen(given_string);
+    else
+        return NULL;
+ 
+    while (special_characters && *special_characters && !is_special_character)
+         is_special_character = (*special_characters++ == given_char);
+ 
+    string_backup = (char *) fs_get((length_string + 1)*sizeof(char));
+    for (i = 0, j = 0 ; given_string && given_string[i]; i++){
+         if (given_string[i] != given_char)
+            string_backup[j++] = given_string[i];
+         else{
+            char c = given_string[i-1];
+            if (c){
+ 		if (c == '\\'){ /* special character was escaped */
+ 		  string_backup[j--] = given_char;  /* correct string backup */
+ 		  there_is_special_character = TRUE;
+ 		  *error++;
+ 		}
+ 		else
+ 		  break;
+ 	   }
+ 	   else
+ 	      break; /* found it in the first position! */
+ 	}
+    }
+ 
+    if ((j == length_string) && (flag & STRICT)){
+      if (string_backup)
+         fs_give((void **)&string_backup);
+      return NULL;   /* character not found */
+    }
+ 
+    string_backup[j] = '\0';	/* tie me off, thank you. */
+    *error = there_is_special_character ? *error : 0;
+    if (string_backup && *string_backup)
+       return string_backup;
+    else{
+       if (string_backup)
+         fs_give((void **)&string_backup);
+       return NULL;
+    }
+ }
+ 
+ RULE_ACTION *get_action(rule_data,rule_context, env)
+ char *rule_data;
+ int rule_context;
+ ENVELOPE *env;
+ {
+     RULE_ACTION *result;
+     char *new_rule, *p, *condition[10];
+     int number_conditions = 0;
+     int begin_condition = FALSE, end_of_conditions = FALSE;
+     int save_to_rule = FALSE, apply_rule = FALSE;
+     int length = 0, test_ok = FALSE, i = 0, try_again = FALSE, error =0;
+ 
+     /* We isolate any condition in a variable called "new_rule" and test it.
+      * If all grammar is correct and all the conditions are satisfied the
+      * rule is executed, otherwise return NULL
+      */
+ 
+     p = rule_data;
+     while ((*p) && (!try_again)){
+         switch(*p){
+           case '_' : begin_condition = !begin_condition;
+                      if (begin_condition){
+ 			new_rule = advance_to_char(p,'}', STRICT, &error);
+ 			if (new_rule && *new_rule){
+ 			   begin_condition = !begin_condition;
+ 			   length = strlen(new_rule);
+ 			   new_rule += length;
+ 			   *new_rule++ = '}';
+ 			   *new_rule   = '\0';
+ 			   new_rule -= length + 1;
+ 			   p += length + 1;
+ 			   test_ok = TRUE;
+ 			   number_conditions++;
+ 			}
+ 			else
+ 			   return (RULE_ACTION *) NULL;  /* Bad Grammar, condition not ended */
+ 			if (!good_grammar(new_rule)){
+ 			   fs_give((void **)&new_rule);
+ 			   return (RULE_ACTION *) NULL;  /* Bad Grammar in condition */
+ 			}
+                      }
+                      else
+                         return NULL; /* Bad Grammar, forbidden '_' before condition */ 
+                      break;
+           case '&' : if ((!begin_condition) && (p[1] != '&')){
+                         if (new_rule)
+                            fs_give((void **)&new_rule);
+                         return (RULE_ACTION *) NULL; /* Bad Grammar, user needed to write && */
+                      }
+                      else{
+                         if (new_rule)
+                            fs_give((void **)&new_rule);
+                         *p++;
+                      }
+                      break;          /* outside a condition, but he/she did not */
+           case '=' : if ((!begin_condition) && (p[1] != '>')){
+ 			if (new_rule)
+ 			   fs_give((void **)&new_rule);
+ 			return (RULE_ACTION *) NULL; /* Bad Grammar, user did not write => */
+                      }
+                      else{            /* outside a condition */
+ 			if (!begin_condition){
+ 			   apply_rule = rule_context & FOR_RESUB|FOR_FOLDER|FOR_INDEX|FOR_SAVE|FOR_STARTUP|FOR_REPLY_INTRO|FOR_REPLACE|FOR_TRIM;
+ 			   end_of_conditions = TRUE;
+ 			   *p++;
+ 			}
+ 			if (new_rule)
+ 			   fs_give((void **)&new_rule);
+                      }
+                      break;
+           case '-' : if ((!begin_condition) && (p[1] != '>')){
+                         if (new_rule)
+                            fs_give((void **)&new_rule);
+                         return (RULE_ACTION *) NULL; /* Bad Grammar, user did not write -> */
+                      }
+                      else{            /* outside a condition */
+                         if (!begin_condition){
+                            save_to_rule = rule_context & FOR_SAVE;
+                            end_of_conditions = TRUE;
+                            *p++;
+                         }
+                         if (new_rule)
+                            fs_give((void **)&new_rule);
+                      }
+                      break;
+           default  : break;
+ 
+         }
+         *p++;
+         if (end_of_conditions){
+            if (save_to_rule || apply_rule){
+               result = (RULE_ACTION *) fs_get(sizeof(RULE_ACTION));
+               result->type  = save_to_rule;
+               if (p && (p[0] == ' '))
+                  while (*p == ' ')
+                  *p++;  
+               result->value = cpystr(p);
+               if (result && result->value && *result->value){
+                   if (result->type)
+                      try_again = TRUE;
+                   else{
+                      for (i = 0; i < NFCN; i++)
+                         if ((action_has_function(result->value,rule_fcns[i].name)) &&
+                              (rule_context & rule_fcns[i].what_for))
+                            try_again = TRUE;
+                      if (!try_again){
+                         if (result->value)
+                            fs_give((void **)&result->value);
+                         if (result)
+                            fs_give((void **)&result);
+                         return (RULE_ACTION *) NULL; /* wrong context*/
+                      }
+                   }
+               }
+            }
+            else
+               return (RULE_ACTION *) NULL; /* wrong context*/
+         }
+         if (test_ok)
+            condition[i++] = cpystr(new_rule);
+         test_ok = FALSE;
+       }
+       i = 0;
+       while ((i < number_conditions) && (try_again)){
+          try_again = try_again && test_condition(condition[i],rule_context,env);
+          fs_give((void **)&(condition[i++]));
+     }
+     if (condition)
+         fs_give((void **)&condition);
+     if (new_rule)
+         fs_give((void **)&new_rule);
+     if (try_again)
+         return result;
+     else
+         return (RULE_ACTION *) NULL;
+    }
+ 
+ char *get_group(given_string)
+ char *given_string;
+ {
+ int error = 0;
+ return advance_to_char(given_string,'}', RELAXED, &error);
+ }
+ 
+ int good_grammar(condition)
+ char *condition;
+ {
+    int error = 0, end_test = FALSE, rv = FALSE, i = 0;
+    char *token;
+ 
+    while (!end_test && (i < NTOKENS))
+         end_test = ((token = strstr(condition,token_rules[i++])) == condition);
+    if (end_test){
+       condition += strlen(token_rules[--i]);
+       if (condition && *condition){
+ 	 while (condition && *condition == ' ')
+            condition++;
+ 	 if (condition && *condition){
+ 	    char *separator;
+ 	    i = 0;
+            end_test = FALSE; /* rewrite end_test from the beginning */
+            while (!end_test && (i < (NREL - 2)))
+              end_test = ((separator = strstr(condition,rel_rules_test[i++].value)) == condition);
+            if (end_test){
+               condition += strlen(rel_rules_test[--i].value);
+               if (condition && *condition){
+ 		 while (condition && *condition == ' ')
+ 		    condition++;
+ 		 if (condition && *condition){
+                    char *open_set, *open_set_test;
+ 
+                    open_set = (*condition == '{') ? cpystr(condition) : NULL;
+                    end_test = open_set && *open_set;
+                    open_set_test = advance_to_char(open_set,'}', STRICT, &error);
+                    end_test = end_test ? (open_set_test ? 1 : 0) : FALSE;
+                    if (open_set)
+                       fs_give((void **)&open_set);
+                    if (open_set_test)
+                       fs_give((void **)&open_set_test);
+ 		   rv = end_test;
+ 		 }
+               }
+            }
+         }
+       }
+    }
+    return rv;
+ }
+ 
+ 
+ int action_has_function(action,function)
+ char *action;
+ char *function;
+ {
+   char *where = strstr(action,function);
+   char *token;
+   int i = 0;
+ 
+   if (!where)
+       return FALSE;
+ 
+   if (where == action
+ 	&& strcmp(function,"_TRIM_") && strcmp(function,"_REXTRIM_")
+ 	&& strcmp(function, "_REPLACE_"))
+       return TRUE;
+ 
+   /* The action must have the form _TOKEN_ := function{something} */
+ 
+   token = get_value_token(action);
+   if (token){
+      char *where_token = strstr(action, token);
+ 
+      while ((i < NTOKENS) && (strcmp(token,token_rules[i])))
+         i++;
+      if (i == NTOKENS){
+         fs_give((void **)&token);
+         return FALSE;
+      }
+ 
+      if (where_token == action){
+                          /* the action does not look like "garbage _TOKEN_" */
+ 
+         action += strlen(token) + 1;
+         fs_give((void **)&token);
+         while (*action == ' ')
+             *action++;
+ 
+         if ((*action == ':') && (*++action == '=')){
+            *action++;
+            while (*action == ' ')
+               *action++;
+            where_token = strstr(action,function);
+            if (where_token == action)
+               return TRUE;
+         }
+      }
+   }
+   return FALSE;
+ }
+ 
+ /* Regular Expressions Support */
+ 
+ char *
+ expand (string, pattern)
+ char *string;
+ char *pattern;
+ {
+  int error, i = 0;
+  char *new_start;
+  char *ret_string;
+  regex_t preg;
+  regmatch_t pmatch;
+  
+   if (regcomp(&preg, pattern, REG_EXTENDED))
+      return NULL;
+   else{
+     if (((error = regexec(&preg, string, 1, &pmatch, 0)) != REG_NOMATCH)
+ 	&& !error){
+       ret_string = (char *) fs_get((pmatch.rm_eo-pmatch.rm_so+1)*sizeof(char));
+       for (i = 0; i + pmatch.rm_so < pmatch.rm_eo; i++)
+ 	  ret_string[i] = string[i + pmatch.rm_so];
+       ret_string[i] = '\0';
+       return ret_string;
+     }
+     else
+       return NULL;
+   }
+ }
diff -rc pine4.61/pine/rules.h pine4.61.I.USE/pine/rules.h
*** pine4.61/pine/rules.h	Thu Sep 23 15:32:08 2004
--- pine4.61.I.USE/pine/rules.h	Mon Jul 26 09:21:50 2004
***************
*** 0 ****
--- 1,236 ----
+ #include "headers.h"
+ #ifndef _REGEX_H_
+ #include <regex.h>
+ #endif
+ /*  
+  *
+  *  This set of rules was written by
+  *
+  *  Eduardo Chappa (chappa@math.washington.edu)
+  *  http://www.math.washington.edu/~chappa/pine/
+  *
+  *  Original Version: November 1999
+  *  Last Modified   : July 26, 2004
+  *
+  */
+ 
+ typedef struct {
+         char       *value;
+         int        type;
+ } RULE_ACTION;
+ 
+ 
+ RULE_RESULT *get_result_rule PROTO ((char **,int, ENVELOPE *));
+ char    *process_rule   PROTO ((char *,int, ENVELOPE *));
+ int      test_condition PROTO ((char *,int, ENVELOPE *));
+ int      test_in        PROTO ((char *,char *, ENVELOPE *, int));   
+ int      test_ni        PROTO ((char *,char *, ENVELOPE *, int));
+ int      test_not_in    PROTO ((char *,char *, ENVELOPE *, int));
+ int      test_not_ni    PROTO ((char *,char *, ENVELOPE *, int));
+ int      test_eq        PROTO ((char *,char *, ENVELOPE *, int));
+ int      test_not_eq    PROTO ((char *,char *, ENVELOPE *, int));
+ int      test_open      PROTO ((char *,char *, ENVELOPE *, int));
+ int      test_close     PROTO ((char *,char *, ENVELOPE *, int));
+ int      contain        PROTO ((char *,char *));
+ int      mystrcmp       PROTO ((char *,char *));
+ char    *do_trim        PROTO ((char *,char *));
+ char    *save_to        PROTO ((char *, int, ENVELOPE *));
+ char    *trim           PROTO ((char *, int, ENVELOPE *));
+ char    *rextrim        PROTO ((char *, int, ENVELOPE *));
+ char    *replace        PROTO ((char *, int, ENVELOPE *));
+ char    *get_index_rule PROTO ((char *, int, ENVELOPE *));
+ char    *get_sgn_rule   PROTO ((char *, int, ENVELOPE *));
+ char    *get_sort_rule  PROTO ((char *, int, ENVELOPE *));
+ char    *get_smtp_rule  PROTO ((char *, int, ENVELOPE *));
+ char    *rep_str_rule   PROTO ((char *, int, ENVELOPE *));
+ char	*get_end_text	PROTO((char *,int, ENVELOPE *, char *));
+ char	*get_begin_text PROTO((char *,int, ENVELOPE *, char *));
+ char    *get_reply_str  PROTO ((char *, int, ENVELOPE *));
+ char    *get_reply_sub  PROTO ((char *, int, ENVELOPE *));
+ char    *startup_rule   PROTO ((char *, int, ENVELOPE *));
+ char    *thrdstyle	PROTO ((char *, int, ENVELOPE *));
+ char    *thrdindex	PROTO ((char *, int, ENVELOPE *));
+ char    *execute_fcn    PROTO ((char *, char *, int, int));
+ RULE_ACTION *get_action PROTO ((char *,int, ENVELOPE *));
+ char    *advance_to_char PROTO ((char *, char, int, int *));
+ char    *advance_to_end  PROTO ((char *));
+ char    *get_group      PROTO ((char *));
+ int      action_has_function PROTO ((char *, char*));
+ char	*expand PROTO((char *, char *));
+ 
+ /* Separators:
+  *
+  * A separator is a string that separates the rule condition with the rule
+  * action. Below is the list of separators
+  *
+  */
+ 
+ #define  SAVE_TO_SEP  "->"              /* Separator for save_to */
+ #define  APPLY_SEP    "=>"              /* Separator for do the action */
+ 
+ /*------- Definitions of tokens -------*/
+ /*------ Keep the list alphabetically sorted, thanks -------*/
+ 
+ #define ADDR_TOKEN	"_ADDRESS_"
+ #define ADDCC_TOKEN	"_ADDRESSCC_"
+ #define ADDRECIP_TOKEN	"_ADDRESSRECIPS_"
+ #define ADDTO_TOKEN	"_ADDRESSTO_"
+ #define BCC_TOKEN	"_BCC_"
+ #define CC_TOKEN	"_CC_"
+ #define COLLECT_TOKEN	"_COLLECTION_"
+ #define FLAG_TOKEN	"_FLAG_"
+ #define FOLDER_TOKEN	"_FOLDER_"
+ #define FADDRESS_TOKEN	"_FORWARDADDRESS_"
+ #define FFROM_TOKEN	"_FORWARDFROM_"
+ #define FROM_TOKEN	"_FROM_"
+ #define LCC_TOKEN	"_LCC_"
+ #define NICK_TOKEN	"_NICK_"
+ #define ROLE_TOKEN	"_ROLE_"
+ #define SEND_TOKEN	"_SENDER_"
+ #define SUBJ_TOKEN	"_SUBJECT_"
+ #define THDDSPSTY_TOKEN	"_THREADSTYLE_"
+ #define THDNDXSTY_TOKEN	"_THREADINDEX_"
+ #define TO_TOKEN	"_TO_"
+ 
+ /* Mail related tokens 
+  *
+  * The following is an array with the list of tokens.
+  */
+ 
+ char* token_rules[] = {
+    FROM_TOKEN,
+    NICK_TOKEN,
+    ROLE_TOKEN,
+    FOLDER_TOKEN,
+    SUBJ_TOKEN,
+    THDDSPSTY_TOKEN,
+    THDNDXSTY_TOKEN,
+    FLAG_TOKEN,
+    COLLECT_TOKEN,
+    THDDSPSTY_TOKEN,
+    ADDR_TOKEN,
+    TO_TOKEN,
+    ADDTO_TOKEN,
+    ADDCC_TOKEN,
+    ADDRECIP_TOKEN,
+    SEND_TOKEN,
+    CC_TOKEN,
+    LCC_TOKEN,
+    BCC_TOKEN,
+    FFROM_TOKEN,
+    FADDRESS_TOKEN,
+    NULL
+ };
+ 
+ #define NTOKENS  (sizeof(token_rules)/sizeof(token_rules[0]) - 1)
+ 
+ /*------ Definitions of relational operands -------------*/
+ 
+ typedef struct {
+         char       *value;
+         int        (*execute)();
+ } REL_TOKEN;
+ 
+ /* Relational Operands */
+ #define AND_REL     "&&"        /* For putting more than one condition  */
+ #define IN_REL      "<<"        /* For belonging relation */
+ #define NI_REL      ">>"        /* For contain relation   */
+ #define NOT_IN_REL  "!<"        /* Negation of IN_REL   */
+ #define NOT_NI_REL  "!>"        /* Negation of NI_REL   */
+ #define EQ_REL      "=="        /* Test of equality     */
+ #define NOT_EQ_REL  "!="        /* Test of inequality   */
+ #define OPEN_SET    "{"         /* Braces to open a set */
+ #define CLOSE_SET   "}"         /* Braces to close a set*/
+ 
+ 
+ REL_TOKEN rel_rules_test[] = {
+    {IN_REL,             test_in},
+    {NI_REL,             test_ni},
+    {NOT_IN_REL,         test_not_in},
+    {NOT_NI_REL,         test_not_ni},
+    {EQ_REL,             test_eq},
+    {NOT_EQ_REL,         test_not_eq},
+    {OPEN_SET,           test_open},
+    {CLOSE_SET,          test_close},
+    {NULL,               NULL}
+ };
+ 
+ #define NREL  (sizeof(rel_rules_test)/sizeof(rel_rules_test[0]) - 1)
+ 
+ /*--- Context in which these variables can be used ---*/
+ 
+ typedef struct use_context {
+     char        *name;
+     int          what_for;
+ } USE_IN_CONTEXT;
+ 
+ 
+ static USE_IN_CONTEXT tokens_use[] = {
+     {NICK_TOKEN,        FOR_SAVE},
+     {FROM_TOKEN,        FOR_SAVE},
+     {ROLE_TOKEN,        FOR_COMPOSE},
+     {FOLDER_TOKEN,      FOR_SAVE|FOR_FOLDER|FOR_THREAD},
+     {SUBJ_TOKEN,        FOR_SAVE|FOR_FOLDER},
+     {FLAG_TOKEN,        FOR_SAVE|FOR_FLAG},
+     {COLLECT_TOKEN,     FOR_SAVE|FOR_COMPOSE|FOR_FOLDER|FOR_THREAD},
+     {THDDSPSTY_TOKEN,   FOR_THREAD},
+     {THDNDXSTY_TOKEN,   FOR_THREAD},
+     {ADDR_TOKEN,        FOR_SAVE|FOR_FOLDER},
+     {TO_TOKEN,          FOR_SAVE},
+     {ADDTO_TOKEN,       FOR_SAVE|FOR_COMPOSE},
+     {ADDCC_TOKEN,       FOR_SAVE|FOR_COMPOSE},
+     {ADDRECIP_TOKEN,    FOR_SAVE|FOR_COMPOSE},
+     {SEND_TOKEN,        FOR_SAVE},
+     {CC_TOKEN,          FOR_SAVE},
+     {BCC_TOKEN,         FOR_COMPOSE},
+     {LCC_TOKEN,         FOR_COMPOSE},
+     {FFROM_TOKEN,       FOR_COMPOSE},
+     {FADDRESS_TOKEN,    FOR_COMPOSE},
+     {NULL,              FOR_NOTHING}
+ };
+ 
+ 
+ typedef struct {
+         char         *name;
+         char*        (*execute)();
+         int          what_for;
+ } RULE_FCN;
+ 
+ #define INDEX_FCN       "_INDEX_"
+ #define REPLACE_FCN     "_REPLACE_"
+ #define REPLYSTR_FCN    "_RESTR_"
+ #define REPLY_FCN       "_REPLY_"
+ #define RESUB_FCN       "_RESUB_"
+ #define REXTRIM_FCN	"_REXTRIM_"
+ #define SAVE_FCN        "_SAVE_"
+ #define SIGNATURE_FCN   "_SIGNATURE_"
+ #define SMTP_FCN        "_SMTP_"
+ #define SORT_FCN        "_SORT_"
+ #define STARTUP_FCN     "_STARTUP_"
+ #define THRDSTYLE_FCN   "_THREADSTYLE_"
+ #define THRDINDEX_FCN   "_THREADINDEX_"
+ #define TRIM_FCN        "_TRIM_"
+ 
+ 
+ RULE_FCN rule_fcns[] = {
+ {SAVE_FCN,      save_to,        FOR_SAVE},
+ {TRIM_FCN,      trim,           FOR_TRIM | FOR_RESUB},
+ {REPLACE_FCN,   replace,        FOR_REPLACE},
+ {SORT_FCN,      get_sort_rule,  FOR_SORT},
+ {INDEX_FCN,     get_index_rule, FOR_INDEX},
+ {SMTP_FCN,      get_smtp_rule,  FOR_COMPOSE},
+ {REPLYSTR_FCN,  rep_str_rule,   FOR_COMPOSE},
+ {REPLY_FCN,     get_reply_str,  FOR_REPLY_INTRO},
+ {SIGNATURE_FCN, get_sgn_rule,   FOR_COMPOSE},
+ {RESUB_FCN,     get_reply_sub,  FOR_RESUB},
+ {STARTUP_FCN,   startup_rule,   FOR_STARTUP},
+ {REXTRIM_FCN,   rextrim,	FOR_TRIM | FOR_RESUB},
+ {THRDSTYLE_FCN, thrdstyle,	FOR_THREAD},
+ {THRDINDEX_FCN, thrdindex,	FOR_THREAD}
+ };
+ 
+ #define NFCN    (sizeof(rule_fcns)/sizeof(rule_fcns[0]))
+ 
+ #define STRICT  0x1
+ #define RELAXED 0x2
+ 
diff -rc pine4.61/pine/send.c pine4.61.I.USE/pine/send.c
*** pine4.61/pine/send.c	Wed Jun 30 11:28:02 2004
--- pine4.61.I.USE/pine/send.c	Tue Jul 20 10:23:40 2004
***************
*** 376,381 ****
--- 376,386 ----
  	role->nick = cpystr("Default Role");
      }
  
+     if (ps_global->role)
+        fs_give((void **)&ps_global->role);  
+ 
+     ps_global->role = cpystr(role->nick);
+ 
      pine_state->redrawer = NULL;
      compose_mail(NULL, NULL, role, NULL, NULL);
      free_action(&role);
***************
*** 580,587 ****
  	      }
  	      ps_global->next_screen = prev_screen;
  	      ps_global->redrawer = redraw;
! 	      if(role)
  		role = combine_inherited_role(role);
  	    }
  	    break;
  	  case 'f':
--- 585,596 ----
  	      }
  	      ps_global->next_screen = prev_screen;
  	      ps_global->redrawer = redraw;
! 	      if (ps_global->role)
! 		  fs_give((void **)&ps_global->role);  
! 	      if(role){
  		role = combine_inherited_role(role);
+ 		ps_global->role = cpystr(role->nick);
+ 	      }
  	    }
  	    break;
  	  case 'f':
***************
*** 863,868 ****
--- 872,878 ----
          if(given_to)
  	  rfc822_parse_adrlist(&outgoing->to, given_to, ps_global->maildomain);
  
+         outgoing->subject = cpystr(ps_global->subject);
          outgoing->message_id = generate_message_id();
  
  	/*
***************
*** 893,901 ****
  	    }
  	}
  
! 	if(role)
  	  q_status_message1(SM_ORDER, 3, 4, "Composing using role \"%.200s\"",
  			    role->nick);
  
  	/*
  	 * The type of storage object allocated below is vitally
--- 903,917 ----
  	    }
  	}
  
!  	if (ps_global->role)
!  	    fs_give((void **)&ps_global->role);  
! 
! 
! 	if(role){
  	  q_status_message1(SM_ORDER, 3, 4, "Composing using role \"%.200s\"",
  			    role->nick);
+  	  ps_global->role = cpystr(role->nick);
+  	}
  
  	/*
  	 * The type of storage object allocated below is vitally
***************
*** 2178,2184 ****
  static struct headerentry he_template[]={
    {"From    : ",  "From",        h_composer_from,       10, 0, NULL,
     build_address, NULL, NULL, addr_book_compose,    "To AddrBk", NULL,
!    0, 1, 0, 1, 0, 1, 0, 0, 0, 0, KS_TOADDRBOOK},
    {"Reply-To: ",  "Reply To",    h_composer_reply_to,   10, 0, NULL,
     build_address, NULL, NULL, addr_book_compose,    "To AddrBk", NULL,
     0, 1, 0, 1, 0, 1, 0, 0, 0, 0, KS_TOADDRBOOK},
--- 2194,2200 ----
  static struct headerentry he_template[]={
    {"From    : ",  "From",        h_composer_from,       10, 0, NULL,
     build_address, NULL, NULL, addr_book_compose,    "To AddrBk", NULL,
!    0, 1, 0, 0, 0, 1, 0, 0, 0, 0, KS_TOADDRBOOK},
    {"Reply-To: ",  "Reply To",    h_composer_reply_to,   10, 0, NULL,
     build_address, NULL, NULL, addr_book_compose,    "To AddrBk", NULL,
     0, 1, 0, 1, 0, 1, 0, 0, 0, 0, KS_TOADDRBOOK},
***************
*** 2285,2291 ****
  #define	N_OURREPLYTO  21
  #define	N_OURHDRS 22
  #define N_SENDER  23
! 
  #define TONAME "To"
  #define CCNAME "cc"
  #define SUBJNAME "Subject"
--- 2301,2308 ----
  #define	N_OURREPLYTO  21
  #define	N_OURHDRS 22
  #define N_SENDER  23
! #define CAN_EDIT(x) (!((x)->never_allow_changing_from) && \
!                        F_ON(F_ALLOW_CHANGING_FROM, (x)))
  #define TONAME "To"
  #define CCNAME "cc"
  #define SUBJNAME "Subject"
***************
*** 2293,2299 ****
  /* this is used in pine_send and pine_simple_send */
  /* name::type::canedit::writehdr::localcopy::rcptto */
  static PINEFIELD pf_template[] = {
!   {"From",        Address,	0, 1, 1, 0},
    {"Reply-To",    Address,	0, 1, 1, 0},
    {TONAME,        Address,	1, 1, 1, 1},
    {CCNAME,        Address,	1, 1, 1, 1},
--- 2310,2316 ----
  /* this is used in pine_send and pine_simple_send */
  /* name::type::canedit::writehdr::localcopy::rcptto */
  static PINEFIELD pf_template[] = {
!   {"From",        Address,	1, 1, 1, 0},
    {"Reply-To",    Address,	0, 1, 1, 0},
    {TONAME,        Address,	1, 1, 1, 1},
    {CCNAME,        Address,	1, 1, 1, 1},
***************
*** 2442,2448 ****
  	    *p = *(p+4);
  
          pf->type        = pf_template[i].type;
! 	pf->canedit     = pf_template[i].canedit;
  	pf->rcptto      = pf_template[i].rcptto;
  	pf->writehdr    = pf_template[i].writehdr;
  	pf->localcopy   = pf_template[i].localcopy;
--- 2459,2465 ----
  	    *p = *(p+4);
  
          pf->type        = pf_template[i].type;
! 	pf->canedit     = (i == N_FROM) ? CAN_EDIT(ps_global) : pf_template[i].canedit;
  	pf->rcptto      = pf_template[i].rcptto;
  	pf->writehdr    = pf_template[i].writehdr;
  	pf->localcopy   = pf_template[i].localcopy;
***************
*** 3158,3163 ****
--- 3175,3182 ----
      pbf = &pbuf1;
      standard_picobuf_setup(pbf);
  
+     pbf->auto_cmds = ps_global->initial_cmds_backup; /* save the list of commands */
+ 
      /*
       * Cancel any pending initial commands since pico uses a different
       * input routine.  If we didn't cancel them, they would happen after
***************
*** 3642,3647 ****
--- 3661,3671 ----
  			he->rich_header = 0;
  		    }
  		}
+ 		if (F_ON(F_ALLOW_CHANGING_FROM, ps_global) &&
+ 		   !ps_global->never_allow_changing_from){
+ 		  he->display_it  = 1;  /* show it */
+ 		  he->rich_header = 0;
+ 		}
  
  		he_from			= he;
  		break;
***************
*** 3749,3754 ****
--- 3773,3797 ----
  		    removing_trailing_white_space(pf->textbuf);
  		    (void)removing_double_quotes(pf->textbuf);
  		    build_address(pf->textbuf, &addr, NULL, NULL, NULL);
+ 		    if (!strncmp(pf->name,"Lcc",3) && addr && *addr){
+ 			RULE_RESULT *rule;
+ 
+   			outgoing->date = cpystr(addr);
+ 			rule = (RULE_RESULT *)
+ 			       get_result_rule(ps_global->VAR_FORWARD_RULES,
+ 			           FOR_RULE|FOR_COMPOSE|FOR_TRIM, outgoing);
+ 			if (rule){
+ 			    addr = cpystr(rule->result);
+ 			    removing_trailing_white_space(addr);
+ 			    (void)removing_extra_stuff(addr);
+ 			    if (rule->result)
+ 				fs_give((void **)&rule->result);
+ 				fs_give((void **)&rule);
+ 			}
+ 			if (outgoing->date)
+ 			    fs_give((void **)&outgoing->date);
+ 		    }   
+ 
  		    rfc822_parse_adrlist(pf->addr, addr,
  					 ps_global->maildomain);
  		    fs_give((void **)&addr);
***************
*** 3826,3832 ****
  
  		switch(set_default_hdrval(pf, custom)){
  		  case Replace:
! 		    if(*pf->addr)
  		      mail_free_address(pf->addr);
  		    
  		    removing_trailing_white_space(pf->textbuf);
--- 3869,3875 ----
  
  		switch(set_default_hdrval(pf, custom)){
  		  case Replace:
! 		    if(pf->addr && *pf->addr)
  		      mail_free_address(pf->addr);
  		    
  		    removing_trailing_white_space(pf->textbuf);
***************
*** 3865,3877 ****
  		switch(set_default_hdrval(pf, custom)){
  		  case Replace:
  		  case Combine:
! 		    if(*pf->addr)
  		      mail_free_address(pf->addr);
  		    
  		    removing_trailing_white_space(pf->textbuf);
  		    (void)removing_double_quotes(pf->textbuf);
  		    build_address(pf->textbuf, &addr, NULL, NULL, NULL);
! 		    rfc822_parse_adrlist(pf->addr, addr, ps_global->maildomain);
  		    fs_give((void **)&addr);
  		    break;
  
--- 3908,3921 ----
  		switch(set_default_hdrval(pf, custom)){
  		  case Replace:
  		  case Combine:
! 		    if(pf->addr && *pf->addr)
  		      mail_free_address(pf->addr);
  		    
  		    removing_trailing_white_space(pf->textbuf);
  		    (void)removing_double_quotes(pf->textbuf);
  		    build_address(pf->textbuf, &addr, NULL, NULL, NULL);
! 		    if(pf->addr && *pf->addr)
! 		      rfc822_parse_adrlist(pf->addr, addr, ps_global->maildomain);
  		    fs_give((void **)&addr);
  		    break;
  
***************
*** 4250,4258 ****
--- 4294,4305 ----
  	/* turn off user input timeout when in composer */
  	saved_user_timeout = ps_global->hours_to_timeout;
  	ps_global->hours_to_timeout = 0;
+ 	ps_global->in_pico = 1; /* in */
  	dprint(1, (debugfile, "\n  ---- COMPOSER ----\n"));
  	editor_result = pico(pbf);
+ 	ps_global->force_check_now = 0; /* do not check incoming folders now */
  	dprint(4, (debugfile, "... composer returns (0x%x)\n", editor_result));
+ 	ps_global->in_pico = 0; /* out */
  	ps_global->hours_to_timeout = saved_user_timeout;
  
  #if	defined(DOS) && !defined(_WINDOWS)
***************
*** 4261,4267 ****
  #ifdef _WINDOWS
  	mswin_setwindowmenu (MENU_DEFAULT);
  #endif
! 	fix_windsize(ps_global);
  	/*
  	 * Only reinitialize signals if we didn't receive an interesting
  	 * one while in pico, since pico's return is part of processing that
--- 4308,4315 ----
  #ifdef _WINDOWS
  	mswin_setwindowmenu (MENU_DEFAULT);
  #endif
! 	if (!ps_global->send_immediately)
! 	   fix_windsize(ps_global);
  	/*
  	 * Only reinitialize signals if we didn't receive an interesting
  	 * one while in pico, since pico's return is part of processing that
***************
*** 4321,4327 ****
  	if(outgoing->return_path)
  	  mail_free_address(&outgoing->return_path);
  
! 	outgoing->return_path = rfc822_cpy_adr(outgoing->from);
  
  	/*
  	 * Don't ever believe the sender that is there.
--- 4369,4377 ----
  	if(outgoing->return_path)
  	  mail_free_address(&outgoing->return_path);
  
!         outgoing->return_path = F_ON(F_USE_DOMAIN_NAME,ps_global) 
! 				? rfc822_cpy_adr(generate_from())
! 				: rfc822_cpy_adr(outgoing->from);
  
  	/*
  	 * Don't ever believe the sender that is there.
***************
*** 4923,4932 ****
  	    if(sending_filter_requested
  	       && !filter_message_text(sending_filter_requested, outgoing,
  				       *body, &orig_so, &header)){
! 		q_status_message1(SM_ORDER, 3, 3,
  				 "Problem filtering!  Nothing sent%.200s.",
  				 fcc ? " or saved to fcc" : "");
! 		continue;
  	    }
  
              /*------ Actually post  -------*/
--- 4973,4988 ----
  	    if(sending_filter_requested
  	       && !filter_message_text(sending_filter_requested, outgoing,
  				       *body, &orig_so, &header)){
! 		if (!ps_global->send_immediately){
! 		   q_status_message1(SM_ORDER, 3, 3,
  				 "Problem filtering!  Nothing sent%.200s.",
  				 fcc ? " or saved to fcc" : "");
! 		   continue;
! 		}
! 		else{ 
! 		   fprintf(stderr, "Problem filtering! Nothing sent or saved to Fcc\n");
! 		   exit(-1);
!     		}
  	    }
  
              /*------ Actually post  -------*/
***************
*** 5147,5152 ****
--- 5203,5210 ----
              /*----- Mail Post FAILED, back to composer -----*/
              if(result & (P_MAIL_LOSE | P_FCC_LOSE)){
  		dprint(1, (debugfile, "Send failed, continuing\n"));
+                 if (ps_global->send_immediately)
+                  exit(1);
  
  		if(result & P_FCC_LOSE){
  		    /*
***************
*** 5181,5186 ****
--- 5239,5245 ----
  	    update_answered_flags(reply);
  
              /*----- Signed, sealed, delivered! ------*/
+          if (!ps_global->send_immediately)
  	    q_status_message(SM_ORDER, 0, 3,
  			     pine_send_status(result, fcc, tmp_20k_buf, NULL));
  
***************
*** 5758,5764 ****
      if(background_posting(FALSE))
        return("Can't send while background posting. Use postpone.");
  
!     if(F_ON(F_SEND_WO_CONFIRM, ps_global))
        return(NULL);
  
      ps_global->redrawer = redraw_pico;
--- 5817,5823 ----
      if(background_posting(FALSE))
        return("Can't send while background posting. Use postpone.");
  
!     if(!ps_global->send_immediately && F_ON(F_SEND_WO_CONFIRM, ps_global))
        return(NULL);
  
      ps_global->redrawer = redraw_pico;
***************
*** 5918,5924 ****
  
      opts[i].ch = -1;
  
!     fix_windsize(ps_global);
  
      while(1){
  	if(filters && filters->filter && (p = strindex(filters->filter, ' ')))
--- 5977,5984 ----
  
      opts[i].ch = -1;
  
!     if (!ps_global->send_immediately)
!        fix_windsize(ps_global);
  
      while(1){
  	if(filters && filters->filter && (p = strindex(filters->filter, ' ')))
***************
*** 6053,6059 ****
  
  	if(double_rad +
  	   (dsn_requested ? 4 : F_ON(F_DSN, ps_global) ? 1 : 0) > 11)
! 	  rv = double_radio_buttons(tmp_20k_buf, -FOOTER_ROWS(ps_global), opts,
  			   'y', 'z',
  			   (F_ON(F_DSN, ps_global) && allow_flowed)
  					          ? h_send_prompt_dsn_flowed :
--- 6113,6120 ----
  
  	if(double_rad +
  	   (dsn_requested ? 4 : F_ON(F_DSN, ps_global) ? 1 : 0) > 11)
! 	  rv = ps_global->send_immediately ? 'y' :
! 	      double_radio_buttons(tmp_20k_buf, -FOOTER_ROWS(ps_global), opts,
  			   'y', 'z',
  			   (F_ON(F_DSN, ps_global) && allow_flowed)
  					          ? h_send_prompt_dsn_flowed :
***************
*** 6062,6068 ****
  						       h_send_prompt,
  			   RB_NORM);
  	else
! 	  rv = radio_buttons(tmp_20k_buf, -FOOTER_ROWS(ps_global), opts,
  			   'y', 'z',
  			   (double_rad +
  			    (dsn_requested ? 4 : F_ON(F_DSN, ps_global)
--- 6123,6130 ----
  						       h_send_prompt,
  			   RB_NORM);
  	else
! 	  rv = ps_global->send_immediately ? 'y' :
! 		radio_buttons(tmp_20k_buf, -FOOTER_ROWS(ps_global), opts,
  			   'y', 'z',
  			   (double_rad +
  			    (dsn_requested ? 4 : F_ON(F_DSN, ps_global)
***************
*** 6610,6618 ****
  	    if(tmp_so = so_get(PicoText, NULL, EDIT_ACCESS)){
  		gf_set_so_writec(&pc, tmp_so);
  		ps_global->mangled_screen = 1;
! 		suspend_busy_alarm();
! 		ClearScreen();
! 		fflush(stdout);
  		if(tmpf){
  		    PIPE_S *fpipe;
  
--- 6672,6682 ----
  	    if(tmp_so = so_get(PicoText, NULL, EDIT_ACCESS)){
  		gf_set_so_writec(&pc, tmp_so);
  		ps_global->mangled_screen = 1;
! 		if (!ps_global->send_immediately){
! 		   suspend_busy_alarm();
! 		   ClearScreen();
! 		   fflush(stdout);
! 		}
  		if(tmpf){
  		    PIPE_S *fpipe;
  
***************
*** 6718,6726 ****
  		    b->encoding = ENCOTHER;
  		    set_mime_type_by_grope(b, NULL);
  		}
! 
! 		ClearScreen();
! 		resume_busy_alarm(0);
  	    }
  	    else
  	      errstr = "Can't create space for filtered text.";
--- 6782,6791 ----
  		    b->encoding = ENCOTHER;
  		    set_mime_type_by_grope(b, NULL);
  		}
! 		if (!ps_global->send_immediately){
! 		   ClearScreen();
! 		   resume_busy_alarm(0);
! 		}
  	    }
  	    else
  	      errstr = "Can't create space for filtered text.";
***************
*** 6751,6760 ****
  	if(tmp_so)
  	  so_give(&tmp_so);
  
! 	q_status_message1(SM_ORDER | SM_DING, 3, 6, "Problem filtering: %.200s",
  			  errstr);
! 	dprint(1, (debugfile, "Filter FAILED: %s\n",
  	       errstr ? errstr : "?"));
      }
  
      return(errstr == NULL);
--- 6816,6831 ----
  	if(tmp_so)
  	  so_give(&tmp_so);
  
! 	if (!ps_global->send_immediately){
! 	   q_status_message1(SM_ORDER | SM_DING, 3, 6, "Problem filtering: %.200s",
  			  errstr);
! 	   dprint(1, (debugfile, "Filter FAILED: %s\n",
  	       errstr ? errstr : "?"));
+ 	}
+ 	else{
+ 	   fprintf(stderr, "Filter FAILED: %s\n", errstr ? errstr : "?");
+ 	   exit(-1);
+ 	}
      }
  
      return(errstr == NULL);
***************
*** 6910,6918 ****
      char         error_buf[200], *error_mess = NULL, *postcmd;
      ADDRESS     *a;
      ENVELOPE	*fake_env = NULL;
!     int          addr_error_count, we_cancel = 0;
      long	 smtp_opts = 0L;
!     char	*verbose_file = NULL;
      BODY	*bp = NULL;
      PINEFIELD	*pf;
  
--- 6981,6989 ----
      char         error_buf[200], *error_mess = NULL, *postcmd;
      ADDRESS     *a;
      ENVELOPE	*fake_env = NULL;
!     int          addr_error_count, we_cancel = 0, choice, num_rules = 0, added_rules = -1;
      long	 smtp_opts = 0L;
!     char	*verbose_file = NULL, **smtp_list;
      BODY	*bp = NULL;
      PINEFIELD	*pf;
  
***************
*** 7040,7058 ****
       * was either none specified or we decided not to use it.  So,
       * if there's an smtp-server defined anywhere, 
       */
!     if(alt_smtp_servers && alt_smtp_servers[0] && alt_smtp_servers[0][0]){
! 	/*---------- SMTP ----------*/
! 	dprint(4, (debugfile, "call_mailer: via TCP (%s)\n",
! 		alt_smtp_servers[0]));
! 	TIME_STAMP("smtp-open start (tcp)", 1);
! 	sending_stream = smtp_open(alt_smtp_servers, smtp_opts);
      }
!     else if(ps_global->VAR_SMTP_SERVER && ps_global->VAR_SMTP_SERVER[0]
! 	    && ps_global->VAR_SMTP_SERVER[0][0]){
  	/*---------- SMTP ----------*/
! 	dprint(4, (debugfile, "call_mailer: via TCP\n"));
  	TIME_STAMP("smtp-open start (tcp)", 1);
! 	sending_stream = smtp_open(ps_global->VAR_SMTP_SERVER, smtp_opts);
      }
      else if(postcmd = smtp_command(ps_global->c_client_error)){
  	char *cmdlist[2];
--- 7111,7154 ----
       * was either none specified or we decided not to use it.  So,
       * if there's an smtp-server defined anywhere, 
       */
! 
!      /* First we check for rules and make a list using the rules */
!     if(ps_global->VAR_SMTP_RULES && ps_global->VAR_SMTP_RULES[0]
!         && ps_global->VAR_SMTP_RULES[0][0])
!         while (ps_global->VAR_SMTP_RULES[num_rules]) num_rules++;
! 
!     if(num_rules){
!         int i = 0, j = 0;
!      
!         added_rules = 0;
!         smtp_list = (char **) fs_get ((num_rules + 1)*sizeof(char*));
!         for (i = 0; i < num_rules; i++){
!           char *rule_result = (char *) process_rule(ps_global->VAR_SMTP_RULES[i],FOR_RULE | FOR_COMPOSE, header->env);
!            if (rule_result && *rule_result){
!               smtp_list[j++] = cpystr(rule_result);
!              added_rules++;
!            }
!         }
      }
! 
!     if (added_rules < 0){
!         smtp_list = (char **) fs_get (sizeof(char*));
!         added_rules = 0;
!     }
!     smtp_list[added_rules] = NULL;
! 
!     choice = smtp_list && smtp_list[0] && smtp_list[0][0] ? 3 :
! 	     (alt_smtp_servers && alt_smtp_servers[0] && alt_smtp_servers[0][0] ? 2 :
! 	     (ps_global->VAR_SMTP_SERVER && ps_global->VAR_SMTP_SERVER[0] && ps_global->VAR_SMTP_SERVER[0][0] ? 1 : -1));
! 
!     if(choice > 0){
  	/*---------- SMTP ----------*/
! 	dprint(4, (debugfile, "call_mailer: via TCP (%s)\n",
! 		smtp_list[0]));
  	TIME_STAMP("smtp-open start (tcp)", 1);
! 	sending_stream = smtp_open(choice == 3 ? smtp_list 
! 					: (choice == 2 ? alt_smtp_servers 
! 					: ps_global->VAR_SMTP_SERVER), smtp_opts);
      }
      else if(postcmd = smtp_command(ps_global->c_client_error)){
  	char *cmdlist[2];
***************
*** 7252,7257 ****
--- 7348,7355 ----
  
          q_status_message(SM_ORDER | SM_DING, 4, 7, error_mess);
  	dprint(1, (debugfile, "call_mailer ERROR: %s\n", error_mess));
+         if (ps_global->send_immediately)
+         printf("%s\n",error_mess);
  	return(-1);
      }
      else{
diff -rc pine4.61/pine/signals.c pine4.61.I.USE/pine/signals.c
*** pine4.61/pine/signals.c	Fri May  7 15:56:50 2004
--- pine4.61.I.USE/pine/signals.c	Fri Jul 16 11:58:25 2004
***************
*** 675,681 ****
  
  		add_review_message(buf, -1);
  	    }
! 	    else{
  		q_status_message(SM_ORDER, 0, 1, progress);
  
  		/*
--- 675,682 ----
  
  		add_review_message(buf, -1);
  	    }
! 	    else if (!ps_global->send_immediately
! 		     && !ps_global->checking_incfld){
  		q_status_message(SM_ORDER, 0, 1, progress);
  
  		/*
***************
*** 685,702 ****
  		 * its min display time yet.  In that case, we don't want
  		 * to force out the initial message.
  		 */
! 		display_message('x');
  	    }
  	}
  	
  #ifdef _WINDOWS
  	mswin_setcursor (MSWIN_CURSOR_BUSY);
  #endif
  	fflush(stdout);
      }
  
      /* set alarm */
!     if(F_OFF(F_DISABLE_ALARM, ps_global))
        alarm(seconds);
  
      return(retval);
--- 686,705 ----
  		 * its min display time yet.  In that case, we don't want
  		 * to force out the initial message.
  		 */
! 		    display_message('x');
  	    }
  	}
  	
  #ifdef _WINDOWS
  	mswin_setcursor (MSWIN_CURSOR_BUSY);
  #endif
+       if (!ps_global->send_immediately)
  	fflush(stdout);
      }
  
      /* set alarm */
!     if(F_OFF(F_DISABLE_ALARM, ps_global) && !ps_global->send_immediately
! 	&& !ps_global->checking_incfld)
        alarm(seconds);
  
      return(retval);
***************
*** 733,750 ****
  
  		right = (slots_used - 4)/2;
  		left  = slots_used - 4 - right;
  		sprintf(progress, "%s |%*s100%%%*s|",
  		    busy_message, left, "", right, "");
  		q_status_message(SM_ORDER,
  		    message_pri>=2 ? max(message_pri,3) : 0,
! 		    message_pri+2, progress);
  	    }
  	    else{
  		sprintf(progress, "%s%*sDONE", busy_message,
  		    DISPLAY_CHARS_COLS - 4 + 1, "");
  		q_status_message(SM_ORDER,
  		    message_pri>=2 ? max(message_pri,3) : 0,
! 		    message_pri+2, progress);
  	    }
  	}
  	else
--- 736,757 ----
  
  		right = (slots_used - 4)/2;
  		left  = slots_used - 4 - right;
+               if (!ps_global->send_immediately){
  		sprintf(progress, "%s |%*s100%%%*s|",
  		    busy_message, left, "", right, "");
+ 		if (!ps_global->checking_incfld)
  		q_status_message(SM_ORDER,
  		    message_pri>=2 ? max(message_pri,3) : 0,
! 		    message_pri+2, progress);}
  	    }
  	    else{
+               if (!ps_global->send_immediately){
  		sprintf(progress, "%s%*sDONE", busy_message,
  		    DISPLAY_CHARS_COLS - 4 + 1, "");
+ 		if (!ps_global->checking_incfld)
  		q_status_message(SM_ORDER,
  		    message_pri>=2 ? max(message_pri,3) : 0,
! 		    message_pri+2, progress);}
  	    }
  	}
  	else
diff -rc pine4.61/pine/status.c pine4.61.I.USE/pine/status.c
*** pine4.61/pine/status.c	Fri May  7 15:56:52 2004
--- pine4.61.I.USE/pine/status.c	Fri Jul 16 11:56:04 2004
***************
*** 142,147 ****
--- 142,150 ----
      char  *clean_msg;
      size_t mlen;
  
+     if (ps_global->send_immediately)
+ 	return;
+ 
      /*
       * The 41 is room for 40 escaped control characters plus a
       * terminating null.
***************
*** 1170,1176 ****
      char *q2;
      int	  rv;
  
!     if(!ps_global->ttyo)
        return(pre_screen_config_want_to(question, dflt, on_ctrl_C));
  #ifdef _WINDOWS
      if (mswin_usedialog ()) {
--- 1173,1179 ----
      char *q2;
      int	  rv;
  
!     if((!ps_global->ttyo) || (ps_global->send_immediately))
        return(pre_screen_config_want_to(question, dflt, on_ctrl_C));
  #ifdef _WINDOWS
      if (mswin_usedialog ()) {
diff -rc pine4.61/pine/strings.c pine4.61.I.USE/pine/strings.c
*** pine4.61/pine/strings.c	Wed Jul 14 15:15:10 2004
--- pine4.61.I.USE/pine/strings.c	Fri Jul 16 11:50:44 2004
***************
*** 5935,5941 ****
  	    SortOrder def_sort;
  	    int       def_sort_rev;
  
! 	    if(decode_sort(p, &def_sort, &def_sort_rev) != -1){
  		action->sort_is_set = 1;
  		action->sortorder = def_sort;
  		action->revsort   = (def_sort_rev ? 1 : 0);
--- 5935,5941 ----
  	    SortOrder def_sort;
  	    int       def_sort_rev;
  
! 	    if(decode_sort(p, &def_sort, &def_sort_rev, 0) != -1){
  		action->sort_is_set = 1;
  		action->sortorder = def_sort;
  		action->revsort   = (def_sort_rev ? 1 : 0);
***************
*** 10752,10754 ****
--- 10752,10786 ----
  
      return(idata);
  }
+ 
+ 
+ void
+ removing_extra_stuff(string)
+     char *string;
+ {
+     char *p = NULL;
+     int change = 0, length = 0;
+ 
+ 
+     if(!string)
+       return;
+ 
+     for(; *string; string++, length++)
+       p = ((unsigned char)*string != ',') ? NULL : (!p) ? string : p;
+ 
+     if(p)
+       *p = '\0';
+ 
+     string -= length;
+         for (; *string; string++){
+            if (change){
+               *string = ' ';
+               change = 0;
+            }
+            if ((((unsigned char)*string == ' ') ||
+                 ((unsigned char)*string == ',')) &&
+                 ((unsigned char)*(string + 1) == ','))
+             change++;
+         }
+ }
+ 
diff -rc pine4.61/pine/takeaddr.c pine4.61.I.USE/pine/takeaddr.c
*** pine4.61/pine/takeaddr.c	Tue Jun 29 12:55:22 2004
--- pine4.61.I.USE/pine/takeaddr.c	Fri Sep 17 10:55:46 2004
***************
*** 1755,1764 ****
--- 1755,1766 ----
      TA_S *p;
      int   rc, found = 0, wrapped = 0, flags;
      char *result = NULL, buf[MAX_SEARCH+1], tmp[MAX_SEARCH+20];
+     static char last_pat[MAX_SEARCH+1] = {'\0'};
      static char last[MAX_SEARCH+1];
      HelpType help;
      static ESCKEY_S ekey[] = {
  	{0, 0, "", ""},
+ 	{ctrl('N'),  9, "^N", "Ins Pat"},
  	{ctrl('Y'), 10, "^Y", "Top"},
  	{ctrl('V'), 11, "^V", "Bottom"},
  	{-1, 0, NULL, NULL}};
***************
*** 1779,1795 ****
  				 tmp,ekey,help,&flags);
  	if(rc == 3)
  	  help = help == NO_HELP ? h_config_whereis : NO_HELP;
! 	else if(rc == 0 || rc == 1 || rc == 10 || rc == 11 || !buf[0]){
  	    if(rc == 0 && !buf[0] && last[0]){
  		strncpy(buf, last, sizeof(buf)-1);
  		buf[sizeof(buf)-1] = '\0';
  	    }
! 
! 	    break;
  	}
      }
  
      if(rc == 0 && buf[0]){
  	p = current;
  	while(p = next_taline(p))
  	  if(srchstr((char *)rfc1522_decode((unsigned char *)tmp_20k_buf,
--- 1781,1801 ----
  				 tmp,ekey,help,&flags);
  	if(rc == 3)
  	  help = help == NO_HELP ? h_config_whereis : NO_HELP;
! 	else if(rc == 0 || rc == 1 || rc == 10 || rc == 11 || rc == 9 || !buf[0]){
  	    if(rc == 0 && !buf[0] && last[0]){
  		strncpy(buf, last, sizeof(buf)-1);
  		buf[sizeof(buf)-1] = '\0';
  	    }
! 	    if (rc == 9)
! 		insert_pattern_in_string(buf, last_pat, MAX_SEARCH);
! 	    else
! 		break;
  	}
      }
  
      if(rc == 0 && buf[0]){
+ 	strncpy(last_pat, buf, sizeof(last_pat));
+ 	last_pat[sizeof(last_pat)-1] = '\0';
  	p = current;
  	while(p = next_taline(p))
  	  if(srchstr((char *)rfc1522_decode((unsigned char *)tmp_20k_buf,
***************
*** 4568,4574 ****
      return(res);
  }
  
! 
  /*
   * Look for possible addresses in the first text part of a message for
   * use by TakeAddr command.
--- 4574,4581 ----
      return(res);
  }
  
! #define ALLOWED_TYPE(t) (!strucmp((t), "plain") || !strucmp((t), "html") || \
! 			!strucmp((t), "enriched") || !strucmp((t), "richtext"))
  /*
   * Look for possible addresses in the first text part of a message for
   * use by TakeAddr command.
***************
*** 4594,4605 ****
       * If it is text/plain or it is multipart with a first part of text/plain,
       * we want to continue, else forget it.
       */
!     if(!((body->type == TYPETEXT && body->subtype &&
! 		!strucmp(body->subtype, "plain"))
  			      ||
           (body->type == TYPEMULTIPART && body->nested.part
  		&& body->nested.part->body.type == TYPETEXT
! 		&& !strucmp(body->nested.part->body.subtype, "plain"))))
        return 0;
  
  #ifdef DOS
--- 4601,4612 ----
       * If it is text/plain or it is multipart with a first part of text/plain,
       * we want to continue, else forget it.
       */
!     if(!((body->type == TYPETEXT && body->subtype && 
! 		ALLOWED_TYPE(body->subtype))
  			      ||
           (body->type == TYPEMULTIPART && body->nested.part
  		&& body->nested.part->body.type == TYPETEXT
! 		&& ALLOWED_TYPE(body->nested.part->body.subtype))))
        return 0;
  
  #ifdef DOS
